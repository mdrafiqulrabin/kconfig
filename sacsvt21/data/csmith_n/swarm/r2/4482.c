/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --no-math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1381634740
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_34(void);
static float  func_35(uint32_t  p_36, int32_t  p_37, const float  p_38, float  p_39, int16_t  p_40);
inline static uint16_t  func_56(const int16_t  p_57, int32_t  p_58, float  p_59, int32_t  p_60);
inline static int32_t  func_62(int32_t  p_63);
static int32_t * func_64(int16_t  p_65);
inline static int32_t ** func_67(uint32_t  p_68);
static const int32_t * const  func_70(const int32_t * const  p_71);
inline static uint32_t  func_84(int16_t  p_85, uint16_t  p_86, int32_t  p_87, uint8_t  p_88);
static int16_t  func_89(int16_t  p_90);
static int32_t * func_104(uint32_t  p_105, int32_t * p_106, int32_t ** p_107);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_34(void)
{ /* block id: 36 */
    int16_t l_41 = (-5);
    uint8_t l_42 = 0x9B;
    int32_t l_690 = 7;
    l_690 = func_35(l_41, l_41, ((l_42 == ((safe_add_func_float_f_f((safe_mul_func_float_f_f((safe_sub_func_float_f_f(l_41, l_41)), 0xE.2BE197p+24)), (!((safe_sub_func_float_f_f(l_41, (safe_mul_func_float_f_f(l_41, l_42)))) == 0x0.1D25BBp+13)))) >= l_42)) <= l_41), l_41, l_42);
    return l_690;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_35(uint32_t  p_36, int32_t  p_37, const float  p_38, float  p_39, int16_t  p_40)
{ /* block id: 37 */
    const uint16_t l_61 = 0xA6D7;
    int32_t l_689 = 0xAF58E577;
    int32_t *l_688 = &l_689;
    (*l_688) = ((safe_rshift_func_int16_t_s_u((0x4FA7 > func_56(l_61, p_40, l_61, func_62(p_40))), 9)) > p_40);
    (*l_688) = func_62((*l_688));
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_56(const int16_t  p_57, int32_t  p_58, float  p_59, int32_t  p_60)
{ /* block id: 374 */
    uint16_t l_656 = 0xB7E9;
    int32_t l_658 = (-10);
    int32_t *l_657 = &l_658;
    int16_t l_673 = 3;
    int32_t **l_684 = &l_657;
    int32_t ***l_683 = &l_684;
    int32_t ****l_682 = &l_683;
    const int32_t ***l_687 = (void*)0;
    const int32_t ****l_686 = &l_687;
    const int32_t *****l_685 = &l_686;
    (*l_657) = l_656;
    for (l_656 = 0; (l_656 <= 32); l_656++)
    { /* block id: 378 */
        int32_t l_665 = (-9);
        uint32_t l_666 = 0U;
        if ((safe_add_func_int16_t_s_s((*l_657), (safe_mul_func_uint16_t_u_u(65535U, l_665)))))
        { /* block id: 379 */
            return l_666;
        }
        else
        { /* block id: 381 */
            for (p_60 = 0; (p_60 <= 11); p_60++)
            { /* block id: 384 */
                for (l_665 = 29; (l_665 <= 6); l_665 = safe_sub_func_uint32_t_u_u(l_665, 1))
                { /* block id: 387 */
                    (*l_657) = (safe_add_func_uint16_t_u_u(__builtin_ia32_crc32qi(l_673, l_665), (safe_mod_func_uint32_t_u_u(0x45820DCA, p_58))));
                }
                for (l_665 = 0; (l_665 != (-12)); l_665 = safe_sub_func_uint16_t_u_u(l_665, 6))
                { /* block id: 392 */
                    for (p_58 = 10; (p_58 <= 25); p_58++)
                    { /* block id: 395 */
                        const int32_t *l_680 = &l_658;
                        int32_t **l_681 = &l_657;
                        l_680 = (void*)0;
                        /* statement id: 396 */
                        assert (l_680 == 0);
                    }
                    if (p_60)
                        continue;
                    if (l_666)
                        continue;
                }
            }
            (*l_657) = (p_57 & l_665);
        }
    }
    (*l_685) = l_682;
    /* statement id: 408 */
    assert (l_686 == &l_683);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_62(int32_t  p_63)
{ /* block id: 38 */
    int32_t l_624 = 0x95DF65F0;
    int32_t *l_623 = &l_624;
    int32_t **l_622 = &l_623;
    int32_t ***l_621 = &l_622;
    int32_t **** const l_620 = &l_621;
    float * const *l_637 = (void*)0;
    if (p_63)
    { /* block id: 39 */
        uint8_t l_66 = 0xA3;
        int32_t **l_611 = (void*)0;
        int32_t *l_613 = (void*)0;
        int32_t **l_612 = &l_613;
        (*l_612) = func_64(l_66);
    }
    else
    { /* block id: 335 */
        int32_t *l_614 = (void*)0;
        int32_t l_645 = 0xB3243C53;
        if (((l_614 != (void*)0) & 0x8EBE))
        { /* block id: 336 */
            int16_t l_617 = 0x0DE2;
            int32_t **l_629 = (void*)0;
            int32_t **l_641 = (void*)0;
            int32_t **l_642 = (void*)0;
            const int32_t *l_644 = &l_624;
            const int32_t **l_643 = &l_644;
            for (p_63 = 0; (p_63 == (-22)); p_63 = safe_sub_func_uint32_t_u_u(p_63, 9))
            { /* block id: 339 */
                uint8_t l_634 = 0x1A;
                float *l_639 = (void*)0;
                float **l_638 = &l_639;
                if (l_617)
                { /* block id: 340 */
                    float l_619 = 0xA.5B2839p+86;
                    float *l_618 = &l_619;
                    (*l_618) = 0x7.6694FAp-76;
                }
                else
                { /* block id: 342 */
                    int32_t ****l_626 = &l_621;
                    int32_t *****l_625 = &l_626;
                    (*l_625) = l_620;
                }
                (*l_623) = ((((safe_lshift_func_uint16_t_u_u((l_629 != &l_614), (safe_lshift_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(((((****l_620) & l_634) == (safe_rshift_func_int16_t_s_s((l_637 != l_638), 12))) || (safe_unary_minus_func_uint16_t_u(l_634))), l_634)), (((0x983E & 0xF66D) == 8U) <= p_63))))) == (-1)) | 0x685C75FA) < 4294967295U);
                (***l_620) = l_614;
                /* statement id: 346 */
                assert (l_623 == 0);
                return p_63;
            }
            (*l_643) = func_70((*l_622));
            (**l_621) = (***l_620);
            (**l_622) = ((****l_620) >= 0x53C9);
        }
        else
        { /* block id: 352 */
            return l_645;
        }
        for (p_63 = 0; (p_63 <= 15); p_63 = safe_add_func_uint32_t_u_u(p_63, 6))
        { /* block id: 357 */
            float l_649 = 0x0.3p+1;
            float *l_648 = &l_649;
            int32_t **l_650 = &l_623;
            (*l_648) = 0x2.1p+1;
            (*l_650) = func_70((*l_622));
            (*l_623) = 0x4.05E0ECp-33;
        }
    }
lbl_655:
    (*l_622) = func_104((**l_622), (**l_621), (**l_620));
    for (l_624 = (-27); (l_624 == 14); l_624 = safe_add_func_uint32_t_u_u(l_624, 7))
    { /* block id: 366 */
        for (p_63 = 5; (p_63 == 23); p_63++)
        { /* block id: 369 */
            if (l_624)
                goto lbl_655;
        }
    }
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_64(int16_t  p_65)
{ /* block id: 40 */
    int16_t l_69 = 0xB100;
    int32_t l_605 = 0x99AB8530;
    int32_t *l_604 = &l_605;
    int32_t **l_603 = &l_604;
    int32_t *l_606 = &l_605;
    int32_t *l_607 = &l_605;
    int32_t *l_608 = &l_605;
    int32_t *l_609 = &l_605;
    int32_t *l_610 = (void*)0;
    l_603 = func_67(((-1) & l_69));
    /* statement id: 332 */
    assert (l_603 == 0);
    return l_610;
    /* statement id: 333 */
    //assert (func_64_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_67(uint32_t  p_68)
{ /* block id: 41 */
    int32_t l_73 = 1;
    const int32_t * const l_72 = &l_73;
    int32_t *l_371 = &l_73;
    int32_t **l_370 = &l_371;
    int32_t ***l_402 = &l_370;
    int32_t ****l_401 = &l_402;
    float ***l_429 = (void*)0;
    uint32_t l_430 = 0x8BABC1A2;
    uint16_t l_516 = 65532U;
    int32_t **l_541 = (void*)0;
    const int32_t * const l_564 = (void*)0;
    float l_598 = 0x0.Cp+1;
    float *l_597 = &l_598;
    int32_t **l_599 = &l_371;
    int32_t **l_600 = &l_371;
    int32_t **l_601 = &l_371;
    int32_t **l_602 = (void*)0;
    (*l_370) = func_70(l_72);
    for (p_68 = 0; (p_68 > 48); p_68 = safe_add_func_uint32_t_u_u(p_68, 4))
    { /* block id: 233 */
        int16_t l_374 = 0xEE03;
        (*l_370) = (*l_370);
        if (l_374)
            break;
    }
    if ((safe_lshift_func_uint16_t_u_s((*l_72), (p_68 <= (~(safe_sub_func_uint32_t_u_u(((safe_sub_func_uint32_t_u_u(0xCAF75AB8, (safe_sub_func_int16_t_s_s(((safe_add_func_int32_t_s_s((~(*l_371)), 0)) < (safe_mul_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((((safe_mod_func_int16_t_s_s((func_89((safe_mul_func_uint16_t_u_u((**l_370), (*l_371)))) < (*l_72)), p_68)) >= (**l_370)) || (*l_72)), p_68)), p_68))), p_68)))) || (*l_371)), p_68)))))))
    { /* block id: 237 */
        uint32_t l_398 = 0x765D163B;
        float l_408 = 0x4.0E6689p-23;
        float *l_407 = &l_408;
        int32_t **l_410 = (void*)0;
        int32_t *l_464 = &l_73;
        uint32_t l_466 = 0xA1A6C9B0;
        float ****l_528 = &l_429;
        int16_t l_537 = 0x81FD;
        int32_t l_551 = 5;
        (*l_370) = (**l_402);
lbl_507:
        if (((~(*l_72)) ^ (safe_rshift_func_int16_t_s_s(((**l_402) != (void*)0), 15))))
        { /* block id: 239 */
            int32_t **l_416 = &l_371;
            (***l_401) = l_407;
            /* statement id: 240 */
            assert (l_371 == &l_408);
            for (l_73 = (-10); (l_73 >= (-9)); l_73++)
            { /* block id: 243 */
                int32_t **l_417 = (void*)0;
                return l_417;
                /* statement id: 244 */
                //assert (func_67_rv == 0);
            }
        }
        else
        { /* block id: 246 */
            float l_419 = 0x0.D72E1Fp-65;
            int32_t l_422 = 0xA9922677;
            int32_t **l_431 = &l_371;
            uint32_t l_432 = 0x84324CCB;
            const float *l_455 = (void*)0;
            const float **l_454 = &l_455;
            if ((~((**l_370) >= (safe_mul_func_int16_t_s_s(((l_422 | (l_422 <= l_422)) > (safe_mul_func_int16_t_s_s((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(((l_429 == (void*)0) != (((l_430 < (p_68 | (((l_431 == l_431) & 0x1FDC) <= p_68))) == p_68) < (-1))), 5)), p_68)), l_432))), (**l_431))))))
            { /* block id: 247 */
                int32_t ** const *l_444 = &l_410;
                const float ** const l_456 = &l_455;
                int32_t l_458 = 0x974DAB2A;
                uint16_t l_459 = 0x5153;
                for (l_422 = (-29); (l_422 > 24); l_422 = safe_add_func_uint32_t_u_u(l_422, 6))
                { /* block id: 250 */
                    int32_t ****l_441 = &l_402;
                    const uint8_t l_442 = 0x4F;
                    const int16_t l_443 = 2;
                    if (((func_89(p_68) <= (func_84(p_68, p_68, (safe_rshift_func_uint16_t_u_s(((safe_mul_func_int16_t_s_s(((safe_lshift_func_int16_t_s_u((p_68 > ((void*)0 == l_441)), 3)) > l_442), p_68)) && l_443), (****l_441))), (**l_370)) ^ 1)) | (**l_431)))
                    { /* block id: 251 */
                        int32_t *l_449 = &l_73;
                        int16_t l_457 = 0x0AD5;
                        (**l_370) = (l_444 != (void*)0);
                        (*l_407) = ((((-(-(func_84(((((****l_441) <= (safe_lshift_func_uint16_t_u_s((l_449 != (**l_402)), ((-1) != (safe_mod_func_int32_t_s_s(((0x8EFB ^ (safe_rshift_func_int16_t_s_u(p_68, (****l_441)))) >= __builtin_ia32_crc32qi((l_454 != l_456), (*l_371))), 0xB13B51E8)))))) >= (*l_449)) && l_457), l_458, p_68, l_459) == 0xD.CBC9E0p-45))) < p_68) >= (-0x1.Bp+1)) > p_68);
                        if ((**l_431))
                            break;
                    }
                    else
                    { /* block id: 255 */
                        int32_t **l_460 = &l_371;
                        (*l_460) = func_70(func_70((***l_441)));
                    }
                    (***l_401) = l_407;
                    /* statement id: 258 */
                    assert (l_371 == &l_408);
                }
            }
            else
            { /* block id: 260 */
                int32_t **l_461 = &l_371;
                return l_410;
                /* statement id: 261 */
                //assert (func_67_rv == 0);
            }
        }
        l_464 = l_407;
        /* statement id: 264 */
        assert (l_464 == &l_408);
        if (((~l_466) >= (safe_rshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_s(p_68, func_84(((p_68 & ((0x0323B8CB != (safe_mod_func_uint16_t_u_u(((((safe_add_func_uint16_t_u_u(p_68, p_68)) && (*l_464)) | 0xF325F3E0) == 4), 0x925F))) ^ p_68)) ^ (*l_72)), p_68, (*l_464), p_68))), p_68))))
        { /* block id: 265 */
            uint8_t l_481 = 0x67;
            int32_t *l_488 = &l_73;
            float ***l_525 = (void*)0;
            if ((safe_lshift_func_int16_t_s_u((safe_sub_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(((p_68 != l_481) > (safe_rshift_func_int16_t_s_u(7, ((*l_371) >= (p_68 || __builtin_bswap64((safe_rshift_func_int16_t_s_s(((safe_sub_func_int32_t_s_s(((***l_401) == (***l_401)), (*l_371))) ^ (l_488 == (void*)0)), p_68)))))))), p_68)), 0U)), (*l_488))))
            { /* block id: 266 */
                (*l_488) = (p_68 > (safe_sub_func_uint16_t_u_u(((safe_unary_minus_func_uint16_t_u((*l_464))) >= (***l_402)), p_68)));
            }
            else
            { /* block id: 268 */
                uint8_t l_492 = 0U;
                int32_t l_506 = 1;
                int32_t **l_515 = &l_488;
                int32_t **l_520 = &l_488;
                l_492 = p_68;
lbl_522:
                for (l_492 = 20; (l_492 <= 46); l_492 = safe_add_func_int32_t_s_s(l_492, 9))
                { /* block id: 272 */
                    float ****l_495 = (void*)0;
                    const float ***l_497 = (void*)0;
                    const float ****l_496 = &l_497;
                    int32_t *l_505 = &l_73;
                    (*l_496) = (void*)0;
                    if ((safe_add_func_uint32_t_u_u(__builtin_clzl(((void*)0 != &l_429)), (safe_rshift_func_int16_t_s_s(p_68, 4)))))
                    { /* block id: 274 */
                        float **** const l_504 = &l_429;
                        (****l_401) = (safe_add_func_uint32_t_u_u((*l_371), (((void*)0 != l_504) ^ (****l_401))));
                        (***l_401) = l_505;
                        /* statement id: 276 */
                        assert (l_371 == &l_73);
                        l_506 = (*l_505);
                    }
                    else
                    { /* block id: 278 */
                        int32_t **l_514 = (void*)0;
                        int32_t ****l_521 = &l_402;
                        (*l_407) = p_68;
                        if (l_430)
                            goto lbl_507;
                        if (l_430)
                            goto lbl_522;
                        (**l_402) = func_104((p_68 ^ (((safe_rshift_func_int16_t_s_u(p_68, 7)) ^ (safe_lshift_func_uint16_t_u_u((safe_add_func_uint16_t_u_u((*l_72), l_492)), func_84(p_68, (l_514 != l_515), p_68, p_68)))) < p_68)), (*l_370), l_515);
                        /* statement id: 281 */
                        assert (l_371 == &l_73);
                        (*l_488) = ((*l_464) < func_84(p_68, (*l_505), l_516, (safe_add_func_int16_t_s_s((p_68 != (safe_unary_minus_func_int16_t_s((*l_464)))), (((void*)0 == l_520) != ((void*)0 != l_521))))));
                    }
                    /* facts after branching */
                    assert (l_371 == &l_73);
                }
                (*l_407) = (**l_515);
            }
            if (((((&l_402 != (void*)0) >= (safe_mul_func_int16_t_s_s((*l_488), (((void*)0 != l_525) > ((safe_rshift_func_int16_t_s_s((l_528 == &l_525), ((safe_add_func_int32_t_s_s(0xD5CFDD42, (safe_add_func_int16_t_s_s((!(safe_add_func_uint32_t_u_u(func_89(p_68), p_68))), (*l_488))))) > 0xBFE9561F))) || p_68))))) <= p_68) < p_68))
            { /* block id: 288 */
                (*l_464) = ((safe_unary_minus_func_int16_t_s(l_537)) > p_68);
            }
            else
            { /* block id: 290 */
                int32_t **l_538 = &l_488;
                int32_t **l_539 = &l_488;
                int32_t **l_540 = &l_464;
                return l_541;
                /* statement id: 291 */
                //assert (func_67_rv == 0);
            }
        }
        else
        { /* block id: 293 */
            uint8_t l_545 = 1U;
            (*l_464) = ((((!(safe_rshift_func_int16_t_s_u((l_545 | p_68), ((safe_mul_func_int16_t_s_s(((p_68 < (l_545 ^ 0x26CC)) < (**l_370)), p_68)) | 0)))) <= ((((safe_sub_func_uint16_t_u_u((!(((0x2E20 >= p_68) | (*l_464)) == (*l_464))), p_68)) != l_551) ^ (*l_464)) || (-10))) | l_545) ^ p_68);
        }
    }
    else
    { /* block id: 296 */
        float l_560 = 0xE.DF5A1Cp-96;
        int32_t l_561 = 0;
        const int32_t *l_578 = (void*)0;
        uint8_t l_579 = 0U;
        float *l_580 = &l_560;
        for (l_516 = 20; (l_516 < 29); l_516++)
        { /* block id: 299 */
            uint16_t l_554 = 0xB136;
            int32_t l_555 = 0x1A13F819;
            l_555 = (p_68 || l_554);
            for (l_430 = (-30); (l_430 > 41); l_430++)
            { /* block id: 303 */
                int32_t *l_565 = &l_73;
                if (l_554)
                    break;
                for (l_73 = 0; (l_73 > 26); l_73 = safe_add_func_int32_t_s_s(l_73, 7))
                { /* block id: 307 */
                    l_560 = 0x1.0p-1;
                    if (l_561)
                        continue;
                    for (l_555 = (-3); (l_555 < 23); l_555 = safe_add_func_int32_t_s_s(l_555, 1))
                    { /* block id: 312 */
                        l_561 = p_68;
                        if (p_68)
                            break;
                    }
                }
                (***l_401) = l_565;
            }
        }
        for (l_73 = 26; (l_73 == 17); l_73 = safe_sub_func_int32_t_s_s(l_73, 9))
        { /* block id: 322 */
            int32_t l_572 = 0x2DF70743;
            const int32_t *l_576 = &l_561;
            int32_t **l_577 = &l_371;
            if (p_68)
                break;
            l_561 = (__builtin_bswap64(p_68) && (safe_lshift_func_int16_t_s_u(__builtin_bswap32((*l_72)), ((safe_mul_func_uint16_t_u_u(l_572, ((***l_402) < (safe_mod_func_int16_t_s_s((-9), ((~(****l_401)) ^ (-5))))))) & l_572))));
            (*l_577) = l_576;
            /* statement id: 325 */
            assert (l_371 == &l_561);
            l_576 = l_578;
            /* statement id: 326 */
            assert (l_576 == 0);
        }
        /* facts after for loop */
        assert (l_371 == &l_561 || l_371 == &l_73);
        (*l_580) = (__builtin_parity(l_579) >= 0x4.408552p+29);
    }
    /* facts after branching */
    //assert (l_371 == dangling || l_371 == &l_73);
    (*l_597) = (safe_sub_func_float_f_f(((safe_sub_func_float_f_f(0x0.Bp-1, __builtin_ctzl((((safe_rshift_func_int16_t_s_u(0xFD9D, 10)) || p_68) ^ p_68)))) < ((safe_mul_func_float_f_f((!(safe_add_func_float_f_f((safe_sub_func_float_f_f((!(safe_add_func_float_f_f(p_68, (*l_72)))), p_68)), p_68))), 0x1.3p-1)) >= p_68)), 0x0.4455F9p-35));
    return l_602;
    /* statement id: 331 */
    //assert (func_67_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * const  func_70(const int32_t * const  p_71)
{ /* block id: 42 */
    uint16_t l_74 = 9U;
    const uint32_t l_136 = 0xBAD64B6C;
    int32_t l_324 = 0xC67197F0;
    float l_340 = 0x7.568525p-5;
    float *l_339 = &l_340;
    float **l_338 = &l_339;
    float ***l_337 = &l_338;
    int32_t **l_350 = (void*)0;
    int32_t *l_364 = &l_324;
    int32_t **l_363 = &l_364;
    uint8_t l_368 = 0x9F;
    uint16_t l_369 = 0xF0D8;
lbl_344:
    if (l_74)
    { /* block id: 43 */
        uint32_t l_83 = 0x4C01F903;
        const int32_t * const l_325 = &l_324;
        l_324 = (safe_rshift_func_uint16_t_u_s((safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((((safe_sub_func_uint32_t_u_u(l_83, func_84(func_89(l_83), l_74, l_74, ((l_136 == 6) > l_83)))) != 0xB051) > l_83), 14)), 1U)), 8));
        return p_71;
        /* statement id: 207 */
        //assert (func_70_rv == &l_73 || func_70_rv == &l_408 || func_70_rv == &l_624);
    }
    else
    { /* block id: 208 */
        uint16_t l_331 = 2U;
        float ****l_341 = &l_337;
        for (l_324 = (-10); (l_324 < 18); l_324 = safe_add_func_int16_t_s_s(l_324, 2))
        { /* block id: 211 */
            int32_t l_332 = 1;
            int32_t *l_335 = &l_332;
            int32_t **l_336 = &l_335;
            l_332 = __builtin_clz(__builtin_clz(((safe_rshift_func_uint16_t_u_u((l_136 | (*p_71)), 5)) > (0xB199A5BF | (l_324 != (safe_unary_minus_func_uint16_t_u(l_331)))))));
            (*l_335) = (4U >= __builtin_popcount((safe_sub_func_uint32_t_u_u(__builtin_clzll(l_74), 0x2B00B98D))));
            (*l_336) = p_71;
            /* statement id: 214 */
            //assert (l_335 == &l_73 || l_335 == &l_408 || l_335 == &l_624);
            if ((*p_71))
                continue;
        }
        (*l_341) = l_337;
    }
    for (l_324 = 0; (l_324 < (-3)); l_324 = safe_sub_func_uint32_t_u_u(l_324, 3))
    { /* block id: 221 */
        uint16_t l_347 = 0xEF1B;
        int32_t *l_352 = &l_324;
        int32_t **l_351 = &l_352;
        float ** const l_354 = &l_339;
        if (l_74)
            goto lbl_344;
        (**l_338) = 0x8.Cp+1;
        (*l_351) = p_71;
        /* statement id: 224 */
        //assert (l_352 == &l_73 || l_352 == &l_408 || l_352 == &l_624);
        (**l_351) = (!((((*l_337) != l_354) != (((safe_sub_func_float_f_f(((**l_351) >= ((safe_sub_func_float_f_f((((**l_351) == (0x5.8C55A4p-73 != 0x8.5p+1)) <= (safe_sub_func_float_f_f(((0x8.BD74A3p+91 > ((0x0.Bp-1 <= ((**l_351) >= 0x6.7p-1)) < 0xC.0B315Bp+24)) >= (**l_351)), (*l_352)))), (*l_352))) == 0x3.C1642Cp-7)), (**l_351))) <= (**l_351)) == (**l_351))) < l_74));
    }
    (*l_363) = p_71;
    /* statement id: 227 */
    //assert (l_364 == &l_73 || l_364 == &l_408 || l_364 == &l_624);
    (*l_364) = (((((!0x4301AFE7) <= (*p_71)) == (((**l_363) != (__builtin_popcountll((*l_364)) == (safe_sub_func_int16_t_s_s((*l_364), ((__builtin_ctzll((**l_363)) <= (**l_363)) == (**l_363)))))) | l_368)) | (**l_363)) >= l_369);
    return p_71;
    /* statement id: 229 */
    //assert (func_70_rv == &l_73 || func_70_rv == &l_408 || func_70_rv == &l_624);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_84(int16_t  p_85, uint16_t  p_86, int32_t  p_87, uint8_t  p_88)
{ /* block id: 85 */
    int32_t l_144 = 0x9369D405;
    int32_t *l_143 = &l_144;
    int32_t **l_142 = &l_143;
    int32_t ***l_141 = &l_142;
    int32_t l_280 = 0x6CC6B5D0;
    float l_323 = 0x4.27ECB8p-61;
    float *l_322 = &l_323;
    for (p_88 = (-25); (p_88 == 40); p_88 = safe_add_func_int32_t_s_s(p_88, 1))
    { /* block id: 88 */
        const uint32_t l_145 = 6U;
        float *l_152 = (void*)0;
        int32_t **l_161 = &l_143;
        uint8_t l_224 = 1U;
        float l_254 = 0x1.6p-1;
        int32_t l_273 = 0x6A9FABDE;
        int32_t l_284 = 0;
        int32_t *l_318 = &l_144;
    }
    (*l_322) = (safe_mul_func_float_f_f((0x0.Ep+1 >= 0xC.051C77p-45), ((**l_142) == (0xC.834DD0p-22 >= (-(0x1.6p+1 < (**l_142)))))));
    return p_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_89(int16_t  p_90)
{ /* block id: 44 */
    uint32_t l_91 = 0x2489AFFF;
    int32_t l_94 = 0x25D8284A;
    int32_t *l_93 = &l_94;
    int32_t **l_92 = &l_93;
    float l_96 = 0x1.Cp+1;
    float *l_95 = &l_96;
    uint8_t l_133 = 255U;
    int32_t l_135 = 0x0AFC6290;
    (*l_95) = (__builtin_ffsl(l_91) <= (l_92 == &l_93));
    for (l_94 = 15; (l_94 > (-24)); --l_94)
    { /* block id: 48 */
        float l_108 = 0x4.0E4510p+66;
        int32_t l_109 = 0x53D3C485;
        int32_t **l_118 = &l_93;
        for (l_91 = 0; (l_91 < 30); l_91 = safe_add_func_uint16_t_u_u(l_91, 2))
        { /* block id: 51 */
            uint8_t l_101 = 0xE9;
            int32_t l_103 = 7;
            int32_t *l_102 = &l_103;
            (*l_102) = __builtin_clzl(l_101);
            (*l_92) = func_104(((*l_102) ^ l_109), &l_109, &l_102);
            /* statement id: 55 */
            assert (l_93 == &l_103);
        }
        (*l_92) = &l_109;
        /* statement id: 57 */
        assert (l_93 == &l_109);
        if (p_90)
        { /* block id: 58 */
            uint32_t l_121 = 0x6EFE450D;
            (**l_92) = p_90;
            for (l_109 = 0; (l_109 >= 28); l_109 = safe_add_func_int16_t_s_s(l_109, 1))
            { /* block id: 62 */
                int32_t **l_116 = &l_93;
                for (l_91 = 0; (l_91 == 19); l_91 = safe_add_func_uint16_t_u_u(l_91, 5))
                { /* block id: 65 */
                    int32_t *l_117 = (void*)0;
                    for (p_90 = 0; (p_90 < (-26)); p_90 = safe_sub_func_uint16_t_u_u(p_90, 7))
                    { /* block id: 68 */
                        int32_t * const *l_120 = &l_117;
                        int32_t * const **l_119 = &l_120;
                        l_117 = func_104((**l_92), func_104(p_90, &l_109, &l_93), l_116);
                        /* statement id: 69 */
                        assert (l_117 == &l_109);
                        (*l_116) = func_104(l_109, l_117, l_118);
                        (*l_119) = (void*)0;
                        /* statement id: 71 */
                        assert (l_120 == 0);
                        l_121 = (**l_92);
                    }
                    /* facts after for loop */
                    assert (l_117 == &l_109 || l_117 == 0);
                    return p_90;
                }
            }
            if (l_121)
                continue;
            //assert (l_93 == dangling);
            (*l_92) = (*l_118);
        }
        else
        { /* block id: 79 */
            int16_t l_134 = (-3);
            (*l_118) = (*l_118);
            (*l_118) = func_104(((!((~((safe_unary_minus_func_uint16_t_u((**l_92))) && ((safe_add_func_uint16_t_u_u(((safe_add_func_int16_t_s_s(((**l_118) > p_90), 1)) ^ (*l_93)), (4294967295U | (safe_sub_func_uint32_t_u_u(p_90, (p_90 == (safe_add_func_int32_t_s_s((l_133 > l_134), (-3))))))))) || (**l_92)))) ^ p_90)) || 8U), (*l_118), l_118);
        }
    }
    /* facts after for loop */
    //assert (l_93 == dangling || l_93 == &l_94);
    return l_135;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_104(uint32_t  p_105, int32_t * p_106, int32_t ** p_107)
{ /* block id: 53 */
    return (*p_107);
    /* statement id: 54 */
    //assert (func_104_rv == &l_103 || func_104_rv == &l_109 || func_104_rv == &l_144 || func_104_rv == 0 || func_104_rv == &l_73 || func_104_rv == &l_624);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 171
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 146
   depth: 2, occurrence: 37
   depth: 3, occurrence: 5
   depth: 4, occurrence: 6
   depth: 5, occurrence: 4
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 150

XXX times a variable address is taken: 160
XXX times a pointer is dereferenced on RHS: 163
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 63
   depth: 3, occurrence: 18
   depth: 4, occurrence: 8
XXX times a pointer is dereferenced on LHS: 103
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 20
   depth: 3, occurrence: 10
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 453

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 206
   level: 2, occurrence: 140
   level: 3, occurrence: 39
   level: 4, occurrence: 18
XXX number of pointers point to pointers: 83
XXX number of pointers point to scalars: 67
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26
XXX average alias set size: 1.25

XXX times a non-volatile is read: 897
XXX times a non-volatile is write: 302
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 146
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 25
   depth: 2, occurrence: 36
   depth: 3, occurrence: 19
   depth: 4, occurrence: 15
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 16.5
XXX percentage an existing variable is used: 83.5
********************* end of statistics **********************/

