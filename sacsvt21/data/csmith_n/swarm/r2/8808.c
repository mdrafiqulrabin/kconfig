/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2928994000
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint32_t  f1;
   signed f2 : 14;
   uint32_t  f3;
   float  f4;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint8_t  f0;
   uint32_t  f1;
   float  f2;
   uint8_t  f3;
   int32_t  f4;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_30(void);
static float  func_31(struct S0  p_32, int32_t  p_33, struct S1  p_34);
static struct S0  func_35(uint32_t  p_36);
static struct S1  func_50(uint8_t  p_51, int32_t  p_52);
static uint16_t  func_53(uint16_t  p_54, uint8_t  p_55, float  p_56);
static struct S0  func_61(uint32_t  p_62);
static struct S0  func_63(int16_t  p_64, uint32_t  p_65, float  p_66, int16_t  p_67, uint32_t  p_68);
static uint16_t  func_74(uint32_t  p_75);
static struct S1  func_95(struct S0  p_96, uint32_t  p_97, uint32_t  p_98, uint16_t  p_99);
static struct S0  func_100(struct S0  p_101, uint16_t  p_102, struct S1  p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_30(void)
{ /* block id: 36 */
    float l_39 = 0x1.6p-1;
    int32_t l_40 = 0xAB5BF7C2L;
    int32_t l_47 = (-5L);
    struct S1 l_340 = {1UL,0UL,0x0.9p+1,0x88L,-1L};
    uint16_t l_351 = 65535UL;
    int32_t l_352 = (-1L);
    int32_t l_364 = 0x20E41F59L;
    struct S0 l_379 = {0L,1UL,-6,0UL,0x4.5CE1E1p-68};
    struct S1 l_464 = {2UL,0xEFC51182L,0x1.B1F027p-94,0x0BL,2L};
    uint8_t l_472 = 0UL;
    l_40 = ((0x0.5p-1 > 0xA.C587C7p+53) < ((-0x1.Bp+1) >= (func_31(func_35((((int32_t)(l_40 >= l_40) % (int32_t)((uint16_t)0xA3A7L - (uint16_t)((uint16_t)(((uint16_t)l_40 - (uint16_t)(l_47 = 0x48E0L)) | l_40) - (uint16_t)l_40))) == l_40)), l_40, l_340) , l_40)));
    if (((((l_47 , l_47) >= ((l_352 = (l_40 = ((((uint32_t)l_340.f0 - (uint32_t)(((int16_t)((l_47 && l_340.f1) & (((l_340.f4 > (l_340.f0 >= (l_340.f0 <= l_340.f3))) , l_351) && l_340.f4)) % (int16_t)l_340.f3) > l_351)) > (-2L)) | 0x82B84019L))) & l_47)) == 0xC7DB43E4L) == l_340.f4))
    { /* block id: 191 */
        uint8_t l_362 = 0x48L;
        struct S0 l_424 = {0L,1UL,-11,2UL,0x8.9p-1};
        uint32_t l_460 = 0UL;
        int32_t l_465 = 0xD4B2F84BL;
        int32_t l_467 = 0x320ADF26L;
        for (l_340.f1 = 12; (l_340.f1 == 34); l_340.f1 += 1)
        { /* block id: 194 */
            int16_t l_359 = (-8L);
            int32_t l_363 = 0xABF68952L;
            int16_t l_371 = 0x9B76L;
            int32_t l_390 = 0xCBE5B5EFL;
            float l_446 = (-0x8.2p-1);
            struct S1 l_451 = {0UL,0xB136FE55L,0x3.685B68p-0,253UL,0L};
            uint8_t l_458 = 246UL;
            if ((65526UL >= (l_340.f1 & ((l_352 = (((int16_t)l_359 % (int16_t)((func_50(l_359, (l_363 = ((uint16_t)func_53(l_340.f1, l_340.f4, (0xF.711359p-87 != (__builtin_popcountll((l_340.f1 || (l_362 == l_362))) >= 0x9.0E7673p+62))) >> (uint16_t)9))) , 0xF3ABFB58L) || l_363)) <= l_359)) <= l_364))))
            { /* block id: 197 */
                struct S0 l_369 = {-5L,18446744073709551615UL,125,18446744073709551615UL,0x5.26D729p+80};
                struct S1 l_391 = {0x78L,1UL,0x0.7p-1,0x7DL,0xC15BA14CL};
                struct S1 l_415 = {255UL,1UL,0x1.Fp-1,0xA1L,1L};
                uint16_t l_418 = 1UL;
                int32_t l_441 = 0L;
                uint8_t l_447 = 0UL;
                int32_t l_450 = (-7L);
                for (l_351 = (-2); (l_351 != 52); l_351 += 9)
                { /* block id: 200 */
                    uint16_t l_370 = 0x5FA1L;
                    int32_t l_372 = 0x5D851CD8L;
                    struct S0 l_392 = {-9L,0xF26B0735L,-85,0x1798C67DL,0x7.B22305p+65};
                    struct S1 l_416 = {255UL,0xC5ABDA87L,0xA.8727A0p-99,0x1DL,0x84BA11D4L};
                    struct S1 l_422 = {255UL,0xA052EB0FL,0xC.4D1C60p+8,5UL,8L};
                    if ((((int32_t)(l_362 ^ (l_340.f3 || (l_369 , l_363))) % (int32_t)l_340.f4) ^ (((l_371 = __builtin_ctzll((0UL == l_370))) < ((l_352 < l_372) && l_372)) , l_340.f1)))
                    { /* block id: 202 */
                        float l_373 = 0x1.Dp-1;
                        int32_t l_374 = 0x4E1FA583L;
                        if (l_370)
                            break;
                        l_374 = l_369.f3;
                        l_374 = (l_362 & ((l_364 , l_47) == ((int16_t)(-(int32_t)(l_372 = l_371)) + (int16_t)(!0x8C017859L))));
                    }
                    else
                    { /* block id: 207 */
                        uint32_t l_388 = 4294967294UL;
                        int32_t l_389 = 0xE6010BBAL;
                        l_392 = (l_369.f0 , func_100(l_379, ((~__builtin_clz(((uint16_t)(l_363 | func_53((l_363 > (((l_363 | ((l_388 = (!(l_372 ^ ((uint32_t)((uint16_t)(l_369.f0 = 1UL) >> (uint16_t)l_340.f0) - (uint32_t)0UL)))) >= l_359)) > l_369.f3) , l_369.f2)), l_389, l_370)) << (uint16_t)1))) == l_390), l_391));
                    }
                    l_47 = ((uint16_t)((__builtin_popcountl(((!(l_340 , l_391.f1)) && (func_95(func_100((func_95(func_100(l_369, l_392.f1, l_340), l_392.f0, ((l_363 = (((((uint32_t)(l_369.f2 || 0x3794DB26L) - (uint32_t)0xAC1601FBL) , l_392.f0) <= l_372) , 8UL)) , l_392.f2), l_362) , l_369), l_364, l_391), l_371, l_392.f1, l_362) , 4L))) >= 6UL) < l_359) + (uint16_t)l_390);
                    for (l_369.f1 = 0; (l_369.f1 >= 40); l_369.f1 += 1)
                    { /* block id: 216 */
                        uint16_t l_404 = 0xACBBL;
                        l_392 = func_100(l_369, l_363, func_50(((uint16_t)l_362 << (uint16_t)(((uint32_t)(l_392.f1 && l_359) % (uint32_t)l_362) | l_369.f0)), ((l_404 < ((-1L) < 65535UL)) , l_369.f0)));
                    }
                    if (l_362)
                    { /* block id: 219 */
                        uint8_t l_409 = 0xAAL;
                        int32_t l_414 = 0x87A49A58L;
                        l_416 = (((uint16_t)((uint16_t)l_370 % (uint16_t)l_409) + (uint16_t)(0x4098L >= (func_74(func_74((l_414 = ((!l_362) , (((((!func_74(l_392.f2)) <= l_363) > ((uint16_t)l_362 + (uint16_t)(((l_372 = (l_369.f2 <= l_40)) ^ l_392.f0) | l_391.f3))) , l_391) , l_392.f0))))) | 0xF79899B8L))) , l_415);
                        l_369.f2 = 0x684CC45CL;
                    }
                    else
                    { /* block id: 224 */
                        float l_417 = 0xD.403DDEp-9;
                        int32_t l_421 = 0x7C7FCC72L;
                        int32_t l_423 = 0x4F09820AL;
                        l_424 = func_63(l_363, l_379.f1, l_340.f3, (l_421 = ((l_47 = (l_418 = 65535UL)) && ((((int16_t)l_362 >> (int16_t)9) == (l_362 <= (4294967289UL || (l_421 < (((((l_379.f3 < 0x6A92L) >= l_392.f3) , l_422) , l_371) && l_340.f1))))) > l_369.f3))), l_423);
                        l_424.f0 = ((float)l_363 + (float)l_372);
                    }
                }
                l_369.f2 = ((float)0x0.Fp-1 + (float)l_424.f3);
                if (((int32_t)((uint16_t)((l_369.f0 = (((int16_t)(((((uint32_t)(((uint16_t)l_424.f3 << (uint16_t)3) , l_362) - (uint32_t)(l_424.f0 = (((l_40 = (((((65527UL && l_359) , l_424.f3) , (((float)(l_447 = ((l_441 = 0xB.100DE2p-4) > ((float)((float)(((l_446 >= l_359) != (l_379.f1 < 0xF.80E682p-16)) != l_390) - (float)l_424.f0) - (float)l_415.f3))) + (float)l_362) < l_415.f3)) <= l_359) < l_371)) == l_371) , 0x892DB682L))) != l_359) || l_40) , l_424.f1) >> (int16_t)l_340.f1) <= (-1L))) == l_424.f2) + (uint16_t)(-8L)) - (int32_t)1L))
                { /* block id: 238 */
                    uint32_t l_456 = 0x76B98D45L;
                    uint16_t l_457 = 0x1D4EL;
                    if ((((((int16_t)((l_352 = (l_450 , (l_451 , (l_369.f0 = ((((l_451.f1 >= ((l_390 = (l_371 == ((uint16_t)l_424.f3 << (uint16_t)8))) | (65535UL == (-8L)))) , ((((int16_t)0xDA8DL - (int16_t)0x4B78L) ^ l_424.f0) >= l_415.f0)) || l_456) >= 4294967295UL))))) && l_364) + (int16_t)l_424.f2) | l_457) || l_451.f0) < l_457))
                    { /* block id: 242 */
                        return l_352;
                    }
                    else
                    { /* block id: 244 */
                        uint8_t l_459 = 3UL;
                        l_458 = l_456;
                        if (l_459)
                            break;
                    }
                }
                else
                { /* block id: 248 */
                    l_390 = l_451.f1;
                }
            }
            else
            { /* block id: 251 */
                uint32_t l_461 = 0x6BAD3585L;
                l_464 = func_95(l_379, (((l_40 = l_460) && (l_461 <= (l_451.f0 <= ((((l_359 , ((int16_t)l_47 >> (int16_t)8)) <= 4294967295UL) == (1L != l_362)) , 0xD5A098B0L)))) , 0x3C3D4229L), l_451.f3, l_460);
            }
            if (l_424.f3)
                break;
            l_379 = func_100(l_379, ((l_465 = l_424.f2) == ((l_351 == (l_47 = 0xE8BFD0AAL)) ^ (((l_424.f2 > 0x1EA5L) && l_351) < (~l_340.f1)))), (l_467 , l_340));
        }
    }
    else
    { /* block id: 260 */
        int32_t l_473 = (-7L);
        l_352 = (((float)l_464.f0 - (float)((((int16_t)l_379.f2 >> (int16_t)7) , (func_53(l_472, l_473, l_473) >= l_464.f3)) == (l_40 <= (0x0.8p-1 < l_473)))) > 0x1.Bp-1);
        return l_47;
    }
    l_352 = l_379.f0;
    return l_379.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_31(struct S0  p_32, int32_t  p_33, struct S1  p_34)
{ /* block id: 184 */
    float l_342 = 0x1.5p+1;
    int32_t l_345 = 0x8210BEDAL;
    struct S0 l_346 = {0xA9C8A471L,4UL,-25,0x69F79CD5L,0x1.Dp+1};
    l_346 = func_35((p_34.f1 , (p_33 ^ (((~p_32.f0) == ((p_34.f4 != (l_345 = (((uint16_t)(p_32.f2 <= (-4L)) << (uint16_t)0) == 0x6140L))) <= p_32.f0)) || l_345))));
    return p_32.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_35(uint32_t  p_36)
{ /* block id: 38 */
    float l_48 = 0x3.8p-1;
    int32_t l_49 = (-1L);
    int32_t l_57 = 1L;
    struct S1 l_338 = {0xB0L,18446744073709551614UL,0x1.6p-1,0x9EL,0xBECDB6F0L};
    struct S0 l_339 = {1L,0x51FEE5F7L,-2,9UL,-0x1.Bp-1};
    l_49 = l_49;
    l_338 = func_50((func_53(l_49, ((l_57 = l_49) || (__builtin_parityll(__builtin_bswap32(p_36)) <= l_49)), l_49) , (l_57 & p_36)), l_49);
    return l_339;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_50(uint8_t  p_51, int32_t  p_52)
{ /* block id: 43 */
    int32_t l_78 = 0x6CCCE42BL;
    int32_t l_94 = 0L;
    int32_t l_144 = (-5L);
    struct S0 l_229 = {0x62014B1BL,0x3E451EC3L,-78,1UL,-0x8.Fp-1};
    int32_t l_264 = (-8L);
    struct S1 l_265 = {1UL,0xE4DEC8ADL,0xE.F752B4p+85,0UL,4L};
    int32_t l_272 = 0x1F7334F8L;
    struct S0 l_331 = {0x7613CF34L,18446744073709551612UL,79,0xBFCD6ECBL,-0x3.Dp-1};
    for (p_51 = 18; (p_51 > 22); p_51 += 2)
    { /* block id: 46 */
        int32_t l_73 = 0x49CF94A2L;
        int32_t l_93 = 0x8679DD5AL;
        int32_t l_143 = 1L;
        uint16_t l_145 = 1UL;
        uint32_t l_232 = 3UL;
        struct S0 l_233 = {-1L,0x3D6F2558L,-126,0UL,0x4.2A77DDp-66};
        int32_t l_240 = (-1L);
        l_229 = func_61(((func_63(p_51, (((int32_t)(l_145 = func_53(((l_143 = ((int16_t)((l_73 , p_52) < func_74((((int16_t)(l_78 = (9UL != 0UL)) + (int16_t)((int16_t)((int16_t)((p_52 <= l_73) ^ (((l_94 = ((uint16_t)((uint16_t)((int16_t)l_73 * (int16_t)(l_93 = (((int16_t)((int16_t)((p_51 | 0L) == p_52) - (int16_t)p_52) - (int16_t)l_73) != l_73))) + (uint16_t)p_52) - (uint16_t)p_52)) , (-10L)) , l_73)) % (int16_t)p_51) << (int16_t)14)) == p_51))) << (int16_t)8)) >= l_144), p_51, p_52)) % (int32_t)2L) ^ l_73), p_52, l_73, p_52) , p_52) || l_93));
        l_78 = (((((float)((p_51 > (p_51 , 0x6.925AE9p+88)) <= l_232) + (float)p_52) < (l_233 , ((((((l_229.f0 = ((((uint16_t)(__builtin_parity(((int16_t)(l_144 = (func_74(p_52) < ((int16_t)(p_51 != l_94) >> (int16_t)l_229.f3))) - (int16_t)p_51)) >= 0x558AL) >> (uint16_t)l_240) > p_52) < 4L)) >= l_145) >= l_229.f3) >= p_51) , (-0x2.2p+1)) == p_51))) < 0x9.09FFE9p-88) != 0x0.8p+1);
        l_93 = 6L;
        l_240 = p_52;
    }
    for (p_51 = 0; (p_51 < 6); ++p_51)
    { /* block id: 135 */
        struct S1 l_243 = {0x1DL,0x76A9F0FDL,0x6.092234p-29,0xB0L,0xCA7656AEL};
        struct S1 l_244 = {0xABL,0UL,0x5.431218p-43,0UL,0L};
        int32_t l_245 = 0x6EDA828DL;
        l_244 = l_243;
        l_245 = p_52;
        l_229.f0 = (func_53(p_52, p_51, l_244.f3) > (p_51 < __builtin_clzl((((int16_t)((int16_t)(func_74((l_229.f2 , ((uint16_t)func_74(p_52) << (uint16_t)11))) , p_52) >> (int16_t)p_52) >> (int16_t)6) < l_78))));
    }
    if ((func_74((((4294967287UL == ((uint16_t)(0xB080ABBFL || (((uint16_t)(func_100(func_63(((((int16_t)(-1L) >> (int16_t)8) == (((int16_t)(l_229.f0 = func_53(l_229.f2, p_51, ((float)((((int16_t)(p_51 && 0x57F1D9F5L) - (int16_t)func_74((__builtin_clz(p_51) ^ p_51))) != p_51) , 0x2.181322p+18) + (float)l_264))) >> (int16_t)p_52) > p_52)) & l_229.f2), p_51, p_52, p_52, p_51), l_264, l_265) , p_52) % (uint16_t)1UL) ^ l_94)) + (uint16_t)p_52)) >= 0x2634L) , 18446744073709551607UL)) <= 0UL))
    { /* block id: 141 */
        return l_265;
    }
    else
    { /* block id: 143 */
        float l_270 = 0x1.CB3B76p-38;
        int32_t l_271 = 2L;
        struct S1 l_275 = {255UL,1UL,0x9.Dp+1,6UL,0xEB3F9A5FL};
        int32_t l_283 = (-3L);
        uint32_t l_287 = 0UL;
        struct S0 l_321 = {0x675F6B8CL,0x1C65E760L,13,0x6C35C314L,0x0.5E3F35p+93};
        struct S0 l_337 = {-1L,0x10863288L,-86,0x6739512AL,0x5.9612D3p-48};
        l_271 = (l_265.f1 == (l_144 == ((uint16_t)func_74(((l_94 = (((uint16_t)func_53((func_74(l_271) != (-4L)), l_272, (((-0x10.1p-1) >= 0x0.3p+1) >= l_264)) + (uint16_t)p_51) || 1L)) & (-1L))) << (uint16_t)l_144)));
        for (l_272 = 0; (l_272 >= (-20)); --l_272)
        { /* block id: 148 */
            float l_299 = (-0x1.3p+1);
            int32_t l_311 = (-1L);
            struct S0 l_312 = {0x2855B816L,0x2061BE2EL,-31,6UL,-0x1.Cp-1};
            if (__builtin_clz(p_51))
            { /* block id: 149 */
                int32_t l_284 = 0xF140DDB9L;
                int32_t l_301 = 0x1B3FF6D9L;
                struct S1 l_322 = {1UL,1UL,0xD.F358C7p-91,2UL,-1L};
                l_265 = l_275;
                for (l_271 = 0; (l_271 > 11); l_271++)
                { /* block id: 153 */
                    uint8_t l_278 = 0x8DL;
                    uint16_t l_300 = 1UL;
                    int32_t l_315 = 0xCEACF3CDL;
                    l_284 = ((((l_278 < (((int16_t)0xCD52L >> (int16_t)4) , 0L)) > (func_53(((uint16_t)0UL % (uint16_t)p_51), p_52, (l_283 = l_144)) < (p_52 || l_284))) >= l_284) && p_52);
                    l_301 = (((int16_t)l_283 << (int16_t)l_287) < (((l_284 = (((((((uint16_t)((0UL | (((uint16_t)((uint16_t)((((uint16_t)(!__builtin_parity(l_278)) >> (uint16_t)p_51) | 0L) == 3UL) >> (uint16_t)7) - (uint16_t)((uint16_t)(((((l_265.f3 & p_51) && 0x2E7B3C1AL) & p_51) & p_51) > l_283) << (uint16_t)p_51)) , l_275.f0)) <= l_300) + (uint16_t)p_51) && l_300) , p_51) && p_52) >= p_51) , p_52)) | l_144) & 0x1ACBL));
                    l_315 = (((int16_t)((((l_283 = 0x9290L) == p_51) != 0x79D3L) , l_278) << (int16_t)((uint16_t)(~__builtin_bswap32((((p_52 ^ (((int32_t)((uint32_t)__builtin_ffsll(((l_284 = (l_311 | (l_312 , (((((int16_t)0L >> (int16_t)12) > (l_284 >= p_51)) && l_78) , p_51)))) >= p_52)) + (uint32_t)0x36ECE72CL) - (int32_t)p_52) >= l_311)) & 0xF7E6L) == 0xFA19L))) % (uint16_t)l_275.f0)) && 0x2ADB1AD0L);
                    l_321 = func_61((-(uint16_t)(((-6L) != ((__builtin_ctzll(p_52) || func_74((0xEC5BL <= (l_312.f0 = (p_52 == ((uint32_t)((p_51 > ((uint32_t)p_52 - (uint32_t)l_272)) , __builtin_ffsl((p_52 >= p_52))) + (uint32_t)p_52)))))) != 0xCF762508L)) != 1L)));
                }
                l_322 = l_322;
                l_311 = p_51;
            }
            else
            { /* block id: 166 */
                l_321.f2 = p_52;
            }
            l_312.f2 = (l_229.f0 == (__builtin_ctzl((((int32_t)((int32_t)l_272 + (int32_t)((uint16_t)__builtin_parityll(func_74(((l_321 = (l_331 = func_61(((int16_t)func_53(((((p_51 != 0x855DL) >= l_321.f0) >= p_52) == 0UL), p_52, p_52) << (int16_t)0)))) , 0x97F9CA66L))) << (uint16_t)1)) - (int32_t)p_52) & p_51)) > 0x5.8A839Dp+72));
            l_312 = l_321;
        }
        l_265 = func_95(l_229, l_275.f4, l_265.f0, ((l_272 & p_52) >= (((~((int16_t)(l_321.f2 = (l_78 = (l_331.f1 || ((uint16_t)1UL - (uint16_t)p_51)))) >> (int16_t)(l_144 = l_287))) & p_52) == p_51)));
        l_229 = l_337;
    }
    l_78 = p_51;
    return l_265;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_53(uint16_t  p_54, uint8_t  p_55, float  p_56)
{ /* block id: 41 */
    uint16_t l_58 = 0UL;
    return l_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_61(uint32_t  p_62)
{ /* block id: 123 */
    uint32_t l_221 = 5UL;
    uint16_t l_226 = 0UL;
    int32_t l_227 = (-3L);
    struct S0 l_228 = {0L,1UL,-35,0x5DC2C40DL,0xE.919841p-58};
    l_227 = func_53(l_221, p_62, ((float)((float)(((l_221 == p_62) == (((p_62 >= ((((l_226 == (-0x1.Fp-1)) > (p_62 != p_62)) <= p_62) == 0x0.5p+1)) >= l_226) > l_226)) > (-0x8.Dp+1)) + (float)l_221) + (float)p_62));
    return l_228;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_63(int16_t  p_64, uint32_t  p_65, float  p_66, int16_t  p_67, uint32_t  p_68)
{ /* block id: 77 */
    int32_t l_151 = 0xFDF4E952L;
    int32_t l_184 = 0x7EDD3F16L;
    struct S1 l_186 = {1UL,9UL,0x1.DD3BA1p-77,3UL,0x8FA3BE20L};
    struct S0 l_220 = {0x0E171A2FL,9UL,-115,1UL,0x8.959467p-26};
    for (p_68 = 0; (p_68 != 21); p_68 += 7)
    { /* block id: 80 */
        int16_t l_154 = 4L;
        int32_t l_209 = 0L;
        uint32_t l_211 = 4294967295UL;
        for (p_65 = (-8); (p_65 >= 34); p_65++)
        { /* block id: 83 */
            int16_t l_150 = 0L;
            int32_t l_181 = 1L;
            int32_t l_182 = 0x692F62A8L;
            int32_t l_185 = 0x7AFBAD67L;
            struct S1 l_187 = {0UL,0x87A3C928L,0xB.B97862p+15,0x0CL,0x1538398EL};
            l_151 = l_150;
            if (((int32_t)(0xD0841373L < (l_154 , l_151)) - (int32_t)(!p_68)))
            { /* block id: 85 */
                l_151 = 0xF21EC415L;
            }
            else
            { /* block id: 87 */
                struct S1 l_160 = {255UL,0x8CF04115L,0xE.20038Bp+40,0UL,0xB982148FL};
                uint8_t l_169 = 255UL;
                int32_t l_170 = 0x5D01DBD8L;
                uint16_t l_212 = 0UL;
                uint32_t l_215 = 0x442B78B9L;
                for (p_64 = (-30); (p_64 == (-22)); p_64 += 3)
                { /* block id: 90 */
                    uint16_t l_180 = 0x110CL;
                    int32_t l_183 = 0x42889293L;
                    int32_t l_210 = 0x776CDE9CL;
                    l_187 = ((((l_184 = func_53(((uint16_t)(l_160 , (l_183 = (((uint16_t)(l_182 = ((int32_t)3L + (int32_t)((p_67 = ((((float)((l_154 < ((float)(__builtin_bswap32((l_170 = l_169)) == ((p_65 >= (l_181 = (l_180 = (-(float)(l_151 = (((float)(p_66 = p_64) + (float)(p_65 <= __builtin_ffsl(((uint32_t)((int16_t)((((int32_t)((-1L) == 65527UL) % (int32_t)p_68) | 65534UL) , l_160.f1) >> (int16_t)l_160.f1) + (uint32_t)p_65)))) >= p_65)))))) > l_150)) - (float)p_64)) == 0x0.Fp-1) + (float)0xB.622FFCp+89) , 8UL) ^ 0x6844EC94L)) ^ 0x225EL))) >> (uint16_t)l_150) & l_160.f4))) << (uint16_t)l_150), p_68, l_184)) >= 0x88CAL) & l_185) , l_186);
                    if (__builtin_clzll(func_53((((uint16_t)(-(int32_t)(__builtin_ctzll(((l_187.f4 , ((int16_t)(((int16_t)((int16_t)((__builtin_clzl(p_68) & (l_184 && (((((((((float)(((l_210 = (((float)((((l_183 = (l_160 , ((int16_t)l_184 << (int16_t)((int16_t)((-1L) != ((l_209 = ((uint16_t)(0xF815L <= ((l_154 ^ p_67) ^ 0x5ABEL)) - (uint16_t)p_67)) < 0x041843AEL)) % (int16_t)1UL)))) , 4294967295UL) == 0x7537B090L) , (-0x8.5p-1)) + (float)0xB.93C712p-90) > 0x0.9p+1)) > p_65) < p_67) + (float)0x6.477A05p-2) != 0x0.5p+1) <= 0x5.2BF454p-92) <= l_211) , p_64) , l_209) || p_65) < l_180))) , l_186.f1) << (int16_t)0) % (int16_t)p_65) , p_65) - (int16_t)1UL)) && p_68)) , l_160.f3)) << (uint16_t)l_182) && l_212), l_211, p_64)))
                    { /* block id: 104 */
                        struct S1 l_213 = {0UL,1UL,-0x1.Fp+1,0x1CL,-10L};
                        l_160 = l_213;
                    }
                    else
                    { /* block id: 106 */
                        int32_t l_214 = 0xD08EFB34L;
                        l_215 = (p_65 && __builtin_ffsll(l_214));
                        l_214 = l_212;
                        l_209 = ((int16_t)(-1L) % (int16_t)(p_67 | ((l_170 = (l_214 = (((l_160.f3 <= (((l_187.f4 >= (l_151 = p_67)) , func_53(p_65, p_64, (0x2.9625EFp+57 != p_64))) || l_187.f0)) <= l_211) <= 0x26D7F8DAL))) || l_183)));
                    }
                }
            }
            l_151 = ((int16_t)p_64 >> (int16_t)6);
        }
    }
    l_186 = l_186;
    l_220 = l_220;
    l_151 = ((0xAF60L || (l_220.f2 , p_65)) || 0xAEE2L);
    return l_220;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_74(uint32_t  p_75)
{ /* block id: 50 */
    struct S0 l_104 = {1L,9UL,-34,5UL,-0x1.3p-1};
    int32_t l_110 = 0xDEA94120L;
    int32_t l_111 = 0xABE3F132L;
    int32_t l_112 = 0xE4C08A2BL;
    struct S1 l_113 = {248UL,1UL,0xE.FCE132p+90,0xA4L,0L};
    int32_t l_142 = 0x0D7201B9L;
    l_142 = (func_95(func_100(l_104, l_104.f3, (((int32_t)(((65535UL || func_53((l_111 = ((int32_t)(l_110 = (~__builtin_popcountl(p_75))) + (int32_t)l_104.f1)), (l_104.f0 && 0UL), (((l_112 = (l_104.f1 > 0x1.Bp+1)) > p_75) > p_75))) , p_75) != p_75) + (int32_t)p_75) , l_113)), p_75, l_113.f3, l_113.f4) , p_75);
    return l_113.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_95(struct S0  p_96, uint32_t  p_97, uint32_t  p_98, uint16_t  p_99)
{ /* block id: 59 */
    int32_t l_126 = 0x8FA35296L;
    uint32_t l_132 = 1UL;
    int32_t l_139 = (-3L);
    uint8_t l_140 = 0xACL;
    struct S1 l_141 = {0x0BL,0x8BA31763L,0x0.7p-1,0xB6L,7L};
    p_96.f0 = __builtin_ffsll(l_126);
    for (p_99 = 0; (p_99 != 34); ++p_99)
    { /* block id: 63 */
        struct S0 l_129 = {-1L,3UL,-11,0x63C429AAL,-0x2.4p-1};
        l_129 = l_129;
        l_126 = (((-9L) >= (l_126 & l_129.f3)) >= p_97);
        p_96.f0 = p_97;
        l_129.f2 = p_96.f2;
    }
    l_126 = ((float)l_126 - (float)((((__builtin_popcountll(l_126) < (p_96.f4 = l_132)) > (l_126 , ((((float)(l_132 == ((float)(((float)0x1.4p+1 - (float)((((l_139 = (l_126 < (l_132 == 0xC.19732Ep+83))) == (-0x8.Ap-1)) != l_140) >= p_96.f0)) > 0x9.054287p+45) - (float)l_132)) - (float)0x3.1p+1) <= l_132) > p_96.f2))) > p_98) != l_132));
    return l_141;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_100(struct S0  p_101, uint16_t  p_102, struct S1  p_103)
{ /* block id: 54 */
    float l_118 = 0x4.8A40F9p-15;
    int32_t l_119 = 0x30DA5F02L;
    int32_t l_124 = 0x68FEE394L;
    int32_t l_125 = (-3L);
    l_125 = (((int16_t)p_103.f3 >> (int16_t)12) , (((float)l_118 - (float)(l_119 , (l_119 = (__builtin_parityll(((int16_t)l_119 >> (int16_t)(((uint16_t)(p_102 = p_101.f2) << (uint16_t)12) | l_119))) >= l_119)))) > ((l_124 >= (-0x1.9p-1)) >= p_101.f1)));
    return p_101;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 109
   depth: 1, occurrence: 35
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 16
breakdown:
   indirect level: 0, occurrence: 16
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 13
XXX times a bitfields struct on RHS: 19
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 19

XXX max expression depth: 46
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 6, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 4
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 4
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1
   depth: 36, occurrence: 1
   depth: 41, occurrence: 1
   depth: 42, occurrence: 1
   depth: 46, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 524
XXX times a non-volatile is write: 141
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 98
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 20
   depth: 2, occurrence: 9
   depth: 3, occurrence: 11
   depth: 4, occurrence: 12
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 21.8
XXX percentage an existing variable is used: 78.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

