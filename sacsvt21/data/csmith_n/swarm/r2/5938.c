/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      3471985718
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint16_t g_12 = 0x4E70L;
static int32_t g_16 = 1L;
static int32_t g_59 = 7L;
static float g_63 = 0xE.F9752Ep-55;
static int32_t * volatile g_75 = &g_59;/* VOLATILE GLOBAL g_75 */
static int32_t g_83 = 0x06F8A133L;
static int32_t * volatile g_82 = &g_83;/* VOLATILE GLOBAL g_82 */
static int32_t **g_91 = (void*)0;
static int32_t ***g_90 = &g_91;
static volatile float g_162 = 0xF.D1ADB1p-50;/* VOLATILE GLOBAL g_162 */
static int32_t ****g_242 = &g_90;
static int32_t ***** volatile g_241 = &g_242;/* VOLATILE GLOBAL g_241 */
static int32_t g_246 = (-1L);
static float * volatile g_307 = &g_63;/* VOLATILE GLOBAL g_307 */
static int16_t g_382 = (-10L);
static float * volatile g_383 = &g_63;/* VOLATILE GLOBAL g_383 */
static int32_t * volatile g_406 = &g_83;/* VOLATILE GLOBAL g_406 */
static int32_t ** volatile g_421 = (void*)0;/* VOLATILE GLOBAL g_421 */
static uint32_t g_500 = 18446744073709551610UL;
static float * volatile g_536 = &g_63;/* VOLATILE GLOBAL g_536 */
static volatile float g_675 = 0x6.1p+1;/* VOLATILE GLOBAL g_675 */
static int32_t ***** volatile g_698 = (void*)0;/* VOLATILE GLOBAL g_698 */
static int32_t * volatile g_785 = &g_83;/* VOLATILE GLOBAL g_785 */
static int32_t * volatile g_880 = &g_59;/* VOLATILE GLOBAL g_880 */
static int32_t g_901 = (-1L);
static float * volatile g_921 = (void*)0;/* VOLATILE GLOBAL g_921 */
static float * volatile g_923 = &g_63;/* VOLATILE GLOBAL g_923 */
static const int32_t **** volatile g_975 = (void*)0;/* VOLATILE GLOBAL g_975 */
static const int32_t *g_979 = &g_246;
static const int32_t **g_978 = &g_979;
static const int32_t ***g_977 = &g_978;
static const int32_t **** volatile g_976 = &g_977;/* VOLATILE GLOBAL g_976 */
static uint64_t g_1001 = 0UL;
static float * volatile g_1069 = &g_63;/* VOLATILE GLOBAL g_1069 */
static float * volatile g_1105 = (void*)0;/* VOLATILE GLOBAL g_1105 */
static float * volatile g_1146 = &g_63;/* VOLATILE GLOBAL g_1146 */
static float * volatile g_1147 = &g_63;/* VOLATILE GLOBAL g_1147 */
static float *g_1153 = &g_63;
static float **g_1152 = &g_1153;


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_1(void);
inline static uint16_t  func_8(float  p_9, float  p_10);
inline static int32_t ** func_17(const int32_t  p_18, int64_t  p_19);
inline static uint16_t  func_23(int32_t * p_24, float  p_25, float  p_26);
inline static int32_t * func_27(int32_t  p_28, uint16_t  p_29, uint32_t  p_30, uint16_t  p_31, int8_t  p_32);
static uint32_t  func_35(int32_t * p_36, int32_t * p_37);
static int32_t * func_38(const int32_t * p_39, int8_t  p_40);
inline static int32_t * func_41(int32_t ** p_42);
static int32_t ** func_43(int32_t * p_44, int32_t ** p_45, int32_t ** p_46, int32_t * p_47, int8_t  p_48);
static int32_t ** func_49(int64_t  p_50);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_16 g_59 g_901 g_500 g_83 g_90 g_91 g_246 g_382 g_406 g_75 g_242 g_976 g_978 g_979 g_977 g_536 g_63 g_1001 g_241 g_82 g_383 g_1069 g_307 g_923 g_1153 g_1152
 * writes: g_12 g_83 g_977 g_16 g_63 g_246 g_59 g_979 g_1152
 */
static int8_t  func_1(void)
{ /* block id: 0 */
    uint64_t l_11 = 0x989226C312FBB6BCLL;
    uint32_t l_935 = 18446744073709551608UL;
    float l_940 = 0x1.0p+1;
    const int32_t l_941 = 0xFC1B02E0L;
    const int32_t *l_942 = &g_901;
    int32_t l_958 = 0x5B7B5AC7L;
    uint32_t l_971 = 0x1AE22E54L;
    uint64_t l_1098 = 0xD3D1D5CF663A5436LL;
    uint32_t l_1102 = 4294967295UL;
    int32_t *****l_1137 = &g_242;
    float **l_1157 = &g_1153;
    uint64_t l_1169 = 18446744073709551614UL;
    uint16_t l_1171 = 0x27ABL;
    int32_t l_1181 = 0L;
    if (((safe_sub_func_int16_t_s_s(((((~((+(((safe_mod_func_int16_t_s_s((-1L), func_8(l_11, g_12))) ^ l_11) <= ((safe_rshift_func_uint16_t_u_u((((safe_lshift_func_int16_t_s_u(((((((safe_add_func_int32_t_s_s(l_935, (safe_mod_func_uint32_t_u_u(g_12, g_59)))) | (safe_mod_func_int16_t_s_s(((g_901 ^ g_500) >= g_59), l_941))) && 0xCE5DL) & 0x0D50L) != g_901) <= l_11), 3)) <= 5L) > l_941), 9)) && g_83))) && l_935)) | 4294967295UL) < l_935) & 4294967295UL), 0x7A4CL)) && 18446744073709551615UL))
    { /* block id: 423 */
        int32_t *l_970 = &g_83;
        int32_t l_999 = 9L;
lbl_982:
        l_942 = func_38(l_942, ((*g_90) != (void*)0));
        /* statement id: 424 */
        assert (l_942 == &g_246);
        for (g_12 = 0; (g_12 <= 35); g_12 = safe_add_func_int64_t_s_s(g_12, 1))
        { /* block id: 427 */
            int32_t ****l_948 = &g_90;
            int32_t l_1000 = 4L;
            float *l_1002 = &g_63;
            if ((safe_rshift_func_uint16_t_u_u(g_246, 6)))
            { /* block id: 428 */
                int32_t *l_969 = &g_246;
                int32_t **l_972 = (void*)0;
                int32_t **l_973 = &l_969;
                (*l_973) = func_27((safe_unary_minus_func_int32_t_s(((void*)0 != l_948))), (safe_lshift_func_uint16_t_u_u((1UL || (safe_add_func_uint32_t_u_u(((safe_mod_func_uint16_t_u_u((+65535UL), (safe_add_func_int32_t_s_s(((((l_958 != ((safe_sub_func_int64_t_s_s((((safe_add_func_int64_t_s_s((safe_sub_func_uint16_t_u_u(((((g_382 > (safe_mod_func_uint64_t_u_u((safe_mod_func_uint64_t_u_u(((l_969 == l_970) | ((0L || (*l_942)) ^ g_83)), 3L)), g_901))) & (*l_969)) == (*g_406)) < g_16), (*l_942))), 0x6166A9DD9AEDD361LL)) ^ 8UL) && g_16), l_971)) < g_901)) & (*l_969)) & (*l_969)) > 1UL), g_901)))) > 4294967295UL), 0x19454767L))), g_901)), g_16, (*l_969), (*l_969));
                /* statement id: 429 */
                assert (l_969 == 0 || l_969 == &g_63);
                if ((0x860EL < (*l_970)))
                { /* block id: 430 */
                    const int32_t **l_974 = &l_942;
                    l_970 = func_38((*l_973), (*l_970));
                    /* statement id: 431 */
                    assert (l_970 == &g_246);
                    (*l_974) = l_942;
                    (*g_976) = &l_974;
                    /* statement id: 433 */
                    assert (g_977 == &l_974);
                    (**g_977) = (*g_978);
                }
                else
                { /* block id: 435 */
                    for (g_16 = 25; (g_16 != 18); g_16 = safe_sub_func_uint32_t_u_u(g_16, 7))
                    { /* block id: 438 */
                        uint32_t l_983 = 0x1401D64CL;
                        if (g_246)
                            goto lbl_982;
                        if (l_983)
                            continue;
                    }
                }
            }
            else
            { /* block id: 443 */
                int32_t ****l_984 = &g_90;
                (*g_406) = (l_984 != (void*)0);
            }
            (*l_1002) = ((safe_sub_func_float_f_f(((*g_536) < (safe_add_func_float_f_f((safe_add_func_float_f_f((((!(((g_63 <= (safe_add_func_float_f_f(((((g_83 < g_83) <= ((g_83 >= (safe_sub_func_float_f_f((g_500 == g_246), (((-((safe_add_func_float_f_f(g_500, 0x6.B4E86Ep-84)) == l_999)) <= g_382) > 0x5.DB82E0p-45)))) == g_246)) >= l_1000) <= (*l_970)), (*l_970)))) >= g_63) >= g_16)) <= g_1001) <= (*l_942)), 0xA.720FE2p-49)), (*l_970)))), (-0x3.Bp+1))) != g_1001);
        }
        if ((l_942 == &l_999))
        { /* block id: 448 */
lbl_1016:
            (*l_970) = (safe_unary_minus_func_uint16_t_u(g_12));
            (*l_970) = (0UL != (safe_lshift_func_uint16_t_u_u((*l_970), (((safe_sub_func_int64_t_s_s(g_83, (safe_lshift_func_int16_t_s_s((0xCA5863DDL || (*l_970)), 4)))) < ((safe_rshift_func_uint16_t_u_s((safe_lshift_func_uint16_t_u_s((((*l_942) && (*l_970)) < (((safe_add_func_int32_t_s_s(0xC45BEEEAL, (*l_970))) == (*l_942)) <= g_16)), 8)), 8)) | (*l_970))) && 65535UL))));
            if (l_958)
                goto lbl_1016;
            for (l_11 = (-15); (l_11 <= 48); l_11 = safe_add_func_int16_t_s_s(l_11, 1))
            { /* block id: 454 */
                return g_59;
            }
        }
        else
        { /* block id: 457 */
            int32_t l_1023 = 0xEC5DB8EFL;
            uint64_t l_1041 = 0xF02FFF7E78C30666LL;
            const int32_t ***l_1042 = &g_978;
            const int32_t ****l_1043 = &g_977;
            float *l_1046 = &l_940;
            int32_t l_1051 = 0L;
            for (l_935 = (-2); (l_935 != 45); l_935++)
            { /* block id: 460 */
                int32_t *****l_1032 = &g_242;
                l_942 = (void*)0;
                /* statement id: 461 */
                assert (l_942 == 0);
                (*l_970) = ((safe_mod_func_uint32_t_u_u(((l_1023 > (safe_rshift_func_uint16_t_u_s((safe_lshift_func_uint16_t_u_u((safe_add_func_uint16_t_u_u((0x37FD5391L > (((&g_976 != l_1032) | ((void*)0 == l_970)) > (-9L))), (safe_add_func_int32_t_s_s((((safe_add_func_uint64_t_u_u((7L > (safe_add_func_uint16_t_u_u((((safe_lshift_func_uint16_t_u_s(((g_83 & (*l_970)) < g_246), g_83)) | (*g_406)) || l_1023), g_83))), g_901)) || g_83) && 4294967287UL), l_1023)))), 4)), g_1001))) >= l_1041), (*g_979))) < g_382);
            }
            /* facts after for loop */
            assert (l_942 == 0 || l_942 == &g_246);
            (*l_1043) = l_1042;
            /* statement id: 464 */
            assert (g_977 == &g_978);
            l_1051 = ((safe_add_func_int32_t_s_s((&l_942 != (void*)0), (l_1046 == l_970))) || ((((***l_1042) >= ((safe_rshift_func_int16_t_s_u((g_83 && ((safe_sub_func_uint64_t_u_u(((*g_241) != (void*)0), (*l_970))) || (*g_82))), g_246)) >= (-8L))) | 0L) <= g_500));
        }
        /* facts after branching */
        assert (l_942 == 0 || l_942 == &g_246);
    }
    else
    { /* block id: 467 */
        int64_t l_1060 = 0x76E326A4843E4A29LL;
        int32_t *l_1067 = &g_59;
        int32_t **l_1066 = &l_1067;
        int64_t l_1068 = 0x41294D24AD4E9A25LL;
        uint16_t l_1070 = 0x982AL;
        float *l_1151 = &l_940;
        float **l_1150 = &l_1151;
        int32_t l_1170 = 0xB4E40C35L;
        int64_t l_1172 = 0L;
        int64_t l_1190 = (-2L);
        uint16_t l_1191 = 65535UL;
        for (l_935 = 0; (l_935 < 40); l_935 = safe_add_func_uint16_t_u_u(l_935, 1))
        { /* block id: 470 */
            int8_t l_1054 = 0x1FL;
            int32_t ***l_1086 = &g_91;
            uint64_t l_1138 = 3UL;
            if ((*g_82))
            { /* block id: 471 */
                uint32_t l_1055 = 18446744073709551615UL;
                l_1055 = l_1054;
            }
            else
            { /* block id: 473 */
                int64_t l_1082 = 0xD58A32CA74039330LL;
                int32_t l_1101 = 0L;
                (*g_1069) = (((((*g_383) >= ((safe_add_func_float_f_f((((safe_add_func_float_f_f(l_1060, ((safe_sub_func_float_f_f((-(safe_sub_func_float_f_f(0x0.716474p-37, ((g_382 <= ((*g_242) != (*g_242))) > (&l_942 != l_1066))))), g_12)) > 0x1.Bp-1))) >= 0x1.Cp+1) != 0xE.48B456p+23), g_1001)) == (*l_1067))) >= l_1068) < 0xB.61888Fp+30) == g_1001);
                (*g_978) = func_38(func_41(func_17((*l_942), (((*g_241) == &g_977) >= g_901))), g_1001);
                l_1082 = (((((*l_1067) > l_1070) <= (safe_sub_func_float_f_f((!(*l_1067)), (safe_sub_func_float_f_f((*g_536), (safe_add_func_float_f_f(((safe_add_func_float_f_f(0xB.16EE01p-19, 0xF.F04563p+41)) == (g_12 >= (safe_add_func_float_f_f((0x5.9p-1 <= 0x1.Bp+1), 0x3.7p+1)))), 0x1.3p+1))))))) > (*l_942)) < 0x0.2EBF54p+83);
                if ((safe_add_func_uint16_t_u_u(((~(**l_1066)) != (((*l_1067) | (g_1001 > ((l_1086 == (void*)0) < (safe_lshift_func_uint16_t_u_s((+(((safe_rshift_func_uint16_t_u_u((((safe_sub_func_int64_t_s_s((safe_mod_func_uint64_t_u_u((g_901 & (g_500 != (safe_mul_func_int32_t_s_s(l_1098, (((((safe_sub_func_int64_t_s_s((l_1082 && g_246), (**l_1066))) || l_1082) ^ 0UL) < 5L) >= l_1082))))), l_1101)), g_16)) > l_1102) <= (*l_942)), 5)) > 0xD761L) & g_382)), (**l_1066)))))) ^ l_1082)), (*l_1067))))
                { /* block id: 477 */
                    const int8_t l_1119 = (-1L);
                    const float *l_1120 = &g_63;
                    for (g_246 = (-24); (g_246 >= 5); g_246 = safe_add_func_int16_t_s_s(g_246, 3))
                    { /* block id: 480 */
                        float *l_1106 = &l_940;
                        (*l_1106) = (*g_923);
                    }
                    if ((safe_rshift_func_int16_t_s_s((0xAABC6902L == l_1054), (4294967295UL & (safe_mod_func_int32_t_s_s((*g_406), 0x95A3767DL))))))
                    { /* block id: 483 */
                        float *l_1131 = &g_63;
                        int32_t l_1132 = 0xB9BAEE76L;
                        (**l_1066) = ((safe_lshift_func_uint16_t_u_u(0UL, ((safe_add_func_int64_t_s_s(0x80DA4FB0F5D13214LL, (safe_add_func_uint64_t_u_u(((g_500 || (safe_rshift_func_int16_t_s_s((l_1119 || (((void*)0 == l_1120) & ((void*)0 == (*g_242)))), 7))) && (safe_add_func_int64_t_s_s(0xFE4083E208F2278ELL, g_382))), 5L)))) & g_500))) > 3L);
                        (**l_1066) = (safe_lshift_func_uint16_t_u_u((safe_sub_func_uint64_t_u_u(g_12, ((safe_add_func_uint32_t_u_u((l_1119 == ((g_500 != g_16) < (safe_lshift_func_uint16_t_u_u(g_1001, ((void*)0 == l_1131))))), ((l_1132 ^ (g_1001 != 18446744073709551615UL)) > 3UL))) && l_1082))), (*l_942)));
                        (***g_976) = func_41((***g_241));
                        /* statement id: 486 */
                        assert (g_979 == &g_59);
                    }
                    else
                    { /* block id: 487 */
                        if (l_1101)
                            break;
                    }
                    /* facts after branching */
                    assert (g_979 == &g_246 || g_979 == &g_59);
                    for (l_1054 = 0; (l_1054 < (-22)); l_1054 = safe_sub_func_int32_t_s_s(l_1054, 1))
                    { /* block id: 492 */
                        int64_t l_1144 = 0xE4B8917FC865B9A9LL;
                        const int32_t ***l_1145 = &g_978;
                    }
                    (**g_977) = (***g_976);
                }
                else
                { /* block id: 499 */
                    uint32_t l_1148 = 0xA09E86B8L;
                    const int32_t *l_1149 = &g_901;
                    if ((***g_977))
                        break;
                    if (l_1148)
                    { /* block id: 501 */
                        (*l_1067) = (****g_976);
                    }
                    else
                    { /* block id: 503 */
                        l_1149 = (**g_977);
                        /* statement id: 504 */
                        assert (l_1149 == &g_246);
                    }
                    /* facts after branching */
                    assert (l_1149 == &g_246 || l_1149 == &g_901);
                }
                /* facts after branching */
                assert (g_979 == &g_246 || g_979 == &g_59);
            }
            /* facts after branching */
            assert (g_979 == &g_246 || g_979 == &g_59);
            return g_16;
        }
        g_1152 = l_1150;
        /* statement id: 510 */
        assert (g_1152 == &l_1151);
        if ((0L != ((((((((*l_1067) <= (~(safe_rshift_func_int16_t_s_s(((l_1157 != &l_1151) && 0xFE90D9C8L), (!0UL))))) == (((safe_rshift_func_int16_t_s_u(((safe_rshift_func_int16_t_s_u(((**l_1066) | ((safe_lshift_func_uint16_t_u_u(((0x635CA4F5366F0390LL & ((safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s(((((void*)0 != (*l_1066)) ^ (*l_942)) ^ l_1169), 2)), g_16)) || (**l_1066))) | 0xF6BE0C8F5497CDF6LL), g_12)) >= (*l_1067))), 2)) >= l_1170), (*l_942))) <= 0xD1C6E608CE9DF0FCLL) || 0xCACAB670L)) | l_1171) || g_901) != (**l_1066)) || l_1172) ^ 0x73DCL)))
        { /* block id: 511 */
            int32_t **l_1180 = &l_1067;
            (*l_1067) = (safe_sub_func_uint16_t_u_u(((0x12D04E7CL == ((((((((safe_add_func_int64_t_s_s((safe_add_func_int32_t_s_s(((4294967295UL <= (-1L)) <= 0x92AE8C6DB5792A3FLL), ((+18446744073709551607UL) | ((*l_1067) | ((((l_1180 == l_1180) || 0x6E85L) > (-1L)) < g_500))))), (**l_1180))) != g_16) >= 18446744073709551606UL) & 0UL) ^ g_500) || g_59) ^ l_1181) | (**l_1066))) < (**l_1066)), g_500));
            return g_83;
            /* statement id: 513 */
            //assert (g_1152 == dangling);
        }
        else
        { /* block id: 514 */
            int8_t l_1185 = 0x40L;
            (**l_1150) = ((safe_sub_func_float_f_f((*g_536), ((*g_1153) > (((0xC.AF7684p+56 >= (**l_1066)) <= ((((!l_1185) < (safe_add_func_float_f_f((*l_1067), (((safe_add_func_float_f_f((-0x1.3p-1), (**g_1152))) != (((*g_1153) < 0xF.D4F156p+73) >= 0x5.B899D2p+10)) >= 0x5.3p+1)))) > l_1190) == (*l_1067))) < (*g_1153))))) == l_1191);
        }
        (**g_977) = (*g_978);
    }
    /* facts after branching */
    assert (l_942 == &g_901 || l_942 == 0 || l_942 == &g_246);
    //assert (g_977 == &g_978 || g_977 == dangling);
    //assert (g_1152 == dangling || g_1152 == &g_1153);
    return g_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_16
 * writes:
 */
inline static uint16_t  func_8(float  p_9, float  p_10)
{ /* block id: 1 */
    int32_t *l_22 = &g_16;
    uint32_t l_538 = 3UL;
    int32_t ***l_572 = &g_91;
    uint32_t l_641 = 0xC98A9FD4L;
    int64_t l_851 = (-1L);
    int32_t *****l_866 = &g_242;
    uint32_t l_873 = 18446744073709551615UL;
    float l_876 = 0x3.B30839p+61;
    int32_t l_892 = (-1L);
    int32_t l_927 = 1L;
    return (*l_22);
}


/* ------------------------------------------ */
/* 
 * reads : g_536 g_63 g_382 g_12 g_90 g_83 g_500 g_246 g_75 g_59 g_242 g_91 g_16 g_406 g_241
 * writes: g_63 g_83
 */
inline static int32_t ** func_17(const int32_t  p_18, int64_t  p_19)
{ /* block id: 233 */
    const int16_t l_550 = 8L;
    float l_553 = 0x9.A34276p+25;
    int32_t ****l_557 = &g_90;
    float *l_558 = &g_63;
    int32_t **l_563 = (void*)0;
    int32_t **l_564 = (void*)0;
    int32_t **l_565 = (void*)0;
    int32_t **l_566 = (void*)0;
    int32_t *l_568 = &g_16;
    int32_t **l_567 = &l_568;
    for (p_19 = (-9); (p_19 > (-4)); p_19 = safe_add_func_int64_t_s_s(p_19, 1))
    { /* block id: 236 */
        const int32_t *l_543 = &g_246;
        const int32_t **l_542 = &l_543;
        (*l_542) = &p_18;
        /* statement id: 237 */
        assert (l_543 == &p_18);
    }
    (*l_558) = (safe_sub_func_float_f_f((((safe_add_func_float_f_f((safe_add_func_float_f_f((p_19 == l_550), ((safe_sub_func_float_f_f(0x0.6p-1, (p_18 >= ((p_19 <= l_553) > (((safe_add_func_float_f_f(l_550, (+0x1.8p-1))) < ((l_557 == (void*)0) == p_19)) != l_550))))) != p_18))), (*g_536))) >= p_18) >= 0xF.1C39FBp+77), g_382));
    (*l_567) = func_27(g_12, g_382, (safe_sub_func_int64_t_s_s((4294967292UL ^ ((*l_557) == (*l_557))), (0xE9E411ACL || ((p_19 > 0x045D2DD9L) & (safe_rshift_func_uint16_t_u_s(g_83, g_500)))))), p_19, g_246);
    /* statement id: 240 */
    assert (l_568 == 0 || l_568 == &g_63);
    return (***g_241);
    /* statement id: 241 */
    //assert (func_17_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_382 g_16 g_500 g_242 g_90 g_91 g_12 g_536
 * writes: g_382 g_16 g_63
 */
inline static uint16_t  func_23(int32_t * p_24, float  p_25, float  p_26)
{ /* block id: 178 */
    int32_t *l_434 = &g_59;
    int32_t **l_433 = &l_434;
    int32_t l_470 = 5L;
    int32_t *****l_486 = &g_242;
    for (g_382 = 20; (g_382 >= (-9)); g_382 = safe_sub_func_int64_t_s_s(g_382, 1))
    { /* block id: 181 */
        uint32_t l_427 = 1UL;
        float *l_459 = &g_63;
        int32_t *****l_482 = &g_242;
        int64_t l_489 = 0x8BED67247FC99E68LL;
    }
lbl_537:
    (*l_433) = p_24;
    /* statement id: 224 */
    assert (l_434 == &g_63 || l_434 == 0);
    for (g_16 = 14; (g_16 >= 5); g_16 = safe_sub_func_uint32_t_u_u(g_16, 9))
    { /* block id: 227 */
        int16_t l_526 = 1L;
        int8_t l_535 = 0x4FL;
        l_535 = (safe_lshift_func_int16_t_s_u((l_434 != (void*)0), (safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((l_526 >= ((safe_mod_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s(g_500, 10)), (-9L))) > ((l_526 && ((***l_486) != (*g_90))) > ((safe_sub_func_uint32_t_u_u((p_24 != p_24), 0UL)) != l_526)))), g_12)), 6)), 7)), l_526))));
        (*g_536) = l_526;
        if (g_12)
            goto lbl_537;
    }
    return g_382;
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_59 g_83 g_12 g_242 g_90 g_91 g_16 g_382 g_406
 * writes: g_83
 */
inline static int32_t * func_27(int32_t  p_28, uint16_t  p_29, uint32_t  p_30, uint16_t  p_31, int8_t  p_32)
{ /* block id: 155 */
    int32_t **l_384 = (void*)0;
    int32_t *****l_385 = &g_242;
    int8_t l_386 = 0x6EL;
    int32_t *l_391 = (void*)0;
    uint32_t l_417 = 18446744073709551615UL;
    int32_t **l_423 = &l_391;
    int32_t *l_424 = (void*)0;
    l_384 = l_384;
    l_385 = l_385;
    if ((l_386 >= ((safe_sub_func_uint32_t_u_u(((*g_75) & g_83), (safe_lshift_func_int16_t_s_s(((void*)0 == l_391), 14)))) & (safe_mod_func_uint16_t_u_u(((g_12 == (safe_rshift_func_uint16_t_u_s((safe_mod_func_int16_t_s_s((+((((((void*)0 == l_391) <= (((safe_lshift_func_int16_t_s_s((safe_add_func_uint32_t_u_u((((***l_385) == (***l_385)) <= 4L), p_29)), p_32)) | g_16) == p_28)) && p_31) | p_31) < p_29)), g_16)), 13))) != g_382), g_83)))))
    { /* block id: 158 */
        float *l_405 = &g_63;
        for (p_31 = 13; (p_31 <= 6); p_31 = safe_sub_func_uint64_t_u_u(p_31, 1))
        { /* block id: 161 */
            int32_t l_416 = 1L;
            if ((*g_75))
                break;
            (*g_406) = (l_405 == (void*)0);
            for (p_29 = (-14); (p_29 <= 34); p_29 = safe_add_func_uint32_t_u_u(p_29, 1))
            { /* block id: 166 */
                int32_t **l_409 = &l_391;
                int32_t *l_418 = (void*)0;
                int32_t *l_419 = &g_83;
                (*l_409) = (void*)0;
                (*l_419) = (0L == ((((0xD5DDD99CL == p_28) > ((((0x3DB485D1L && (0x989AA41EL == (safe_lshift_func_int16_t_s_u(g_59, 10)))) | ((safe_sub_func_uint32_t_u_u((safe_add_func_uint32_t_u_u(l_416, 0xF19BAF28L)), ((void*)0 != &g_242))) > g_83)) <= 0x0E5DD26EA70BEF7CLL) || l_417)) > g_16) < p_31));
                return l_405;
                /* statement id: 169 */
                //assert (func_27_rv == &g_63);
            }
        }
    }
    else
    { /* block id: 172 */
        int32_t *l_420 = (void*)0;
        int32_t **l_422 = &l_391;
        (*l_422) = l_420;
        (*l_422) = (*l_422);
    }
    (*l_423) = (void*)0;
    return l_424;
    /* statement id: 177 */
    //assert (func_27_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_307 g_63 g_83 g_12 g_246 g_16 g_382 g_383
 * writes: g_63
 */
static uint32_t  func_35(int32_t * p_36, int32_t * p_37)
{ /* block id: 152 */
    float l_375 = (-0x1.Cp+1);
    int32_t ***l_376 = &g_91;
    int32_t l_381 = 0xF23D3C10L;
    (*g_383) = (safe_add_func_float_f_f(((((*g_307) != g_83) != 0xA.B3A83Fp+18) != ((safe_sub_func_float_f_f((0x5.422305p-65 < (((safe_sub_func_float_f_f((l_375 < ((void*)0 == l_376)), g_12)) != ((safe_sub_func_float_f_f((((safe_add_func_float_f_f((g_63 == g_246), l_381)) != 0x1.Ap-1) < 0x1.0p+1), (-0x10.Cp-1))) < g_246)) != 0x6.7BD910p-5)), g_16)) >= 0x7.B5CCB4p+23)), g_382));
    return g_246;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_38(const int32_t * p_39, int8_t  p_40)
{ /* block id: 150 */
    int32_t *l_368 = &g_246;
    return l_368;
    /* statement id: 151 */
    //assert (func_38_rv == &g_246);
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_59 g_307 g_63 g_83 g_246 g_12 g_16 g_90 g_91 g_241 g_242
 * writes: g_63 g_59
 */
inline static int32_t * func_41(int32_t ** p_42)
{ /* block id: 127 */
    uint16_t l_313 = 0xE438L;
    int16_t l_334 = 0x2B35L;
    int32_t *l_339 = &g_59;
    int32_t **l_340 = &l_339;
    int32_t ****l_345 = &g_90;
    const int8_t l_359 = 1L;
    int32_t l_360 = 0L;
    const uint64_t l_365 = 0x8684C55312F0BC0FLL;
    int32_t **l_366 = &l_339;
    int32_t *l_367 = &g_59;
    if ((*g_75))
    { /* block id: 128 */
        float *l_312 = &g_63;
        int32_t l_319 = 0L;
        int32_t *l_335 = &l_319;
        int32_t *l_338 = &g_59;
        (*l_312) = (safe_add_func_float_f_f(((*g_307) == ((safe_add_func_float_f_f(((void*)0 != l_312), (-0x4.1p+1))) != l_313)), (safe_sub_func_float_f_f((((p_42 == p_42) <= (g_83 <= g_246)) < g_12), l_313))));
        for (l_313 = 0; (l_313 < 56); l_313++)
        { /* block id: 132 */
            uint32_t l_318 = 0UL;
            int16_t l_330 = (-10L);
            int32_t l_331 = 0xCE139A79L;
            l_319 = l_318;
            l_331 = (((safe_add_func_int16_t_s_s(((((((((safe_mod_func_int16_t_s_s((l_313 != ((((g_246 >= (safe_mod_func_uint64_t_u_u((l_313 != 2UL), (g_246 | ((l_318 || ((-8L) && (((((g_83 <= (safe_lshift_func_int16_t_s_s(((!((safe_unary_minus_func_int32_t_s(l_313)) != g_12)) > l_313), 14))) ^ 1L) ^ 0x9D27L) | l_319) < l_318))) >= l_313))))) || 1L) >= l_319) != l_318)), g_83)) && l_318) <= 0UL) == 0xE73BL) == (*g_75)) != l_330) & g_16) ^ l_330), 0x8294L)) & g_83) != l_313);
        }
        (*l_335) = (safe_rshift_func_int16_t_s_s(l_313, l_334));
        for (l_334 = 2; (l_334 > 13); l_334 = safe_add_func_int32_t_s_s(l_334, 4))
        { /* block id: 139 */
            l_339 = l_338;
            if ((*l_338))
                continue;
            l_340 = (*g_90);
            /* statement id: 142 */
            assert (l_340 == 0);
        }
        /* facts after for loop */
        assert (l_340 == 0 || l_340 == &l_339);
    }
    else
    { /* block id: 144 */
        int32_t ****l_346 = &g_90;
        const int32_t l_350 = 0L;
        (*l_339) = (safe_rshift_func_int16_t_s_s((((l_345 == l_346) != (**l_340)) != ((void*)0 != (*g_241))), ((**l_340) & (g_246 ^ (+(safe_add_func_uint16_t_u_u((*l_339), l_350)))))));
    }
    /* facts after branching */
    assert (l_340 == 0 || l_340 == &l_339);
    (*l_339) = ((+(~(safe_mod_func_int32_t_s_s((((safe_mod_func_uint64_t_u_u(((((l_359 < ((&g_242 == &l_345) ^ g_16)) <= l_360) && (!(g_16 | (l_345 != l_345)))) | (safe_lshift_func_int16_t_s_s((!(*l_339)), 10))), (*l_339))) <= (*l_339)) < (*l_339)), (*l_339))))) <= l_365);
    (*l_366) = l_339;
    return l_367;
    /* statement id: 149 */
    //assert (func_41_rv == &g_59);
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_83 g_90 g_91 g_241 g_242
 * writes: g_82 g_59 g_83
 */
static int32_t ** func_43(int32_t * p_44, int32_t ** p_45, int32_t ** p_46, int32_t * p_47, int8_t  p_48)
{ /* block id: 75 */
    int32_t *l_244 = &g_83;
    int32_t *****l_278 = &g_242;
    g_82 = (void*)0;
    /* statement id: 76 */
    assert (g_82 == 0);
    (*g_75) = 0xE196A490L;
    for (g_83 = 0; (g_83 <= 11); g_83 = safe_add_func_uint16_t_u_u(g_83, 1))
    { /* block id: 80 */
        int32_t *l_237 = &g_59;
        int32_t ****l_283 = &g_90;
        int32_t *l_296 = &g_83;
        for (p_48 = 0; (p_48 != 3); p_48++)
        { /* block id: 83 */
            int32_t **l_238 = &l_237;
            int32_t *l_305 = &g_83;
            (*l_238) = l_237;
        }
        return (**l_283);
        /* statement id: 124 */
        //assert (func_43_rv == 0);
    }
    return (***g_241);
    /* statement id: 126 */
    //assert (func_43_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_16 g_59 g_75 g_90 g_91
 * writes: g_63 g_59
 */
static int32_t ** func_49(int64_t  p_50)
{ /* block id: 6 */
    const int8_t l_51 = 0xAEL;
    int32_t *l_58 = &g_59;
    int32_t l_101 = 0xAFFF67D6L;
    uint16_t l_105 = 4UL;
    uint16_t l_222 = 1UL;
    int32_t ***l_229 = &g_91;
    if ((l_51 | (safe_mod_func_int32_t_s_s(p_50, (safe_mod_func_uint16_t_u_u((p_50 & (4294967295UL & p_50)), (0x0B42B8FFD0204613LL || g_16)))))))
    { /* block id: 7 */
        int32_t **l_56 = (void*)0;
        int32_t **l_57 = (void*)0;
        int32_t **l_60 = &l_58;
        l_58 = &g_16;
        /* statement id: 8 */
        assert (l_58 == &g_16);
        (*l_60) = l_58;
    }
    else
    { /* block id: 10 */
        int32_t **l_61 = &l_58;
        float *l_62 = &g_63;
        (*l_62) = (l_61 == (void*)0);
    }
    /* facts after branching */
    assert (l_58 == &g_59 || l_58 == &g_16);
    (*g_75) = (safe_mod_func_int32_t_s_s(0xA40A7B48L, (safe_sub_func_int16_t_s_s((((l_58 == (void*)0) >= 0x10F121ADF561F660LL) | (4L | (((safe_lshift_func_int16_t_s_u((((void*)0 == l_58) <= p_50), 1)) <= (safe_mod_func_uint64_t_u_u(((safe_sub_func_int16_t_s_s((!(l_58 != l_58)), g_16)) != 2UL), p_50))) >= (*l_58)))), (*l_58)))));
    for (p_50 = (-10); (p_50 < (-3)); p_50 = safe_add_func_int64_t_s_s(p_50, 1))
    { /* block id: 16 */
        int32_t **l_84 = &l_58;
        int32_t *l_178 = (void*)0;
    }
    return (*g_90);
    /* statement id: 74 */
    //assert (func_49_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_12, "g_12", print_hash_value);
    transparent_crc(g_16, "g_16", print_hash_value);
    transparent_crc(g_59, "g_59", print_hash_value);
    transparent_crc_bytes (&g_63, sizeof(g_63), "g_63", print_hash_value);
    transparent_crc(g_83, "g_83", print_hash_value);
    transparent_crc_bytes (&g_162, sizeof(g_162), "g_162", print_hash_value);
    transparent_crc(g_246, "g_246", print_hash_value);
    transparent_crc(g_382, "g_382", print_hash_value);
    transparent_crc(g_500, "g_500", print_hash_value);
    transparent_crc_bytes (&g_675, sizeof(g_675), "g_675", print_hash_value);
    transparent_crc(g_901, "g_901", print_hash_value);
    transparent_crc(g_1001, "g_1001", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 224
XXX total union variables: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 117
   depth: 2, occurrence: 25
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 3
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 180

XXX times a variable address is taken: 177
XXX times a pointer is dereferenced on RHS: 265
breakdown:
   depth: 1, occurrence: 213
   depth: 2, occurrence: 39
   depth: 3, occurrence: 12
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 136
breakdown:
   depth: 1, occurrence: 126
   depth: 2, occurrence: 9
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 59
XXX times a pointer is compared with address of another variable: 19
XXX times a pointer is compared with another pointer: 25
XXX times a pointer is qualified to be dereferenced: 1249

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 629
   level: 2, occurrence: 183
   level: 3, occurrence: 186
   level: 4, occurrence: 107
   level: 5, occurrence: 50
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 95
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 28.3
XXX average alias set size: 1.27

XXX times a non-volatile is read: 1360
XXX times a non-volatile is write: 343
XXX times a volatile is read: 62
XXX    times read thru a pointer: 0
XXX times a volatile is write: 22
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 345
XXX percentage of non-volatile access: 95.3

XXX forward jumps: 0
XXX backward jumps: 6

XXX stmts: 112
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 24
   depth: 2, occurrence: 23
   depth: 3, occurrence: 14
   depth: 4, occurrence: 11
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 13.7
XXX percentage an existing variable is used: 86.3
********************* end of statistics **********************/

