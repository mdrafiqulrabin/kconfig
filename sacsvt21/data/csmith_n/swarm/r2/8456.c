/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      2862280018
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint16_t g_5 = 0xF825L;
static int32_t g_84 = 0L;
static int32_t *g_83 = &g_84;
static const int32_t *g_190 = &g_84;
static const int32_t ** volatile g_189 = &g_190;/* VOLATILE GLOBAL g_189 */
static int32_t ** volatile g_226 = (void*)0;/* VOLATILE GLOBAL g_226 */
static int32_t *g_228 = &g_84;
static int32_t ** volatile g_227 = &g_228;/* VOLATILE GLOBAL g_227 */
static int32_t g_254 = 1L;
static const int32_t ** volatile *g_269 = &g_189;
static const int32_t ** volatile ** const  volatile g_268 = &g_269;/* VOLATILE GLOBAL g_268 */
static int32_t * const  volatile g_322 = (void*)0;/* VOLATILE GLOBAL g_322 */
static int32_t g_355 = 0x24C6BFACL;
static volatile int32_t g_384 = 3L;/* VOLATILE GLOBAL g_384 */
static volatile int32_t *g_383 = &g_384;
static volatile int32_t * volatile *g_382 = &g_383;
static volatile int32_t * volatile **g_381 = &g_382;
static volatile int32_t * volatile ***g_380 = &g_381;
static volatile int32_t * volatile *** volatile * volatile g_379 = &g_380;/* VOLATILE GLOBAL g_379 */
static const int32_t ** volatile ** const  volatile g_481 = &g_269;/* VOLATILE GLOBAL g_481 */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_24(void);
static int16_t  func_28(uint16_t  p_29, uint32_t  p_30, uint32_t  p_31, int32_t  p_32);
static const int32_t  func_45(int16_t  p_46, uint32_t  p_47, const uint32_t  p_48, uint32_t  p_49);
static int32_t  func_58(int16_t  p_59, uint32_t  p_60, uint32_t  p_61);
static int32_t * func_73(uint32_t  p_74);
static int16_t  func_77(int16_t  p_78, int32_t * p_79, int32_t * p_80, int32_t * p_81, int32_t * p_82);
static int32_t * func_85(int32_t * p_86, uint32_t  p_87, int32_t * p_88);
static int32_t * const  func_94(int32_t * p_95);
static int32_t * func_96(int32_t * p_97, const int32_t * p_98, int32_t * p_99, int32_t * p_100, uint32_t  p_101);
static const int32_t * func_102(int32_t * p_103, int32_t * p_104, int32_t * p_105, int32_t * p_106, const uint16_t  p_107);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_384 g_380 g_381 g_383 g_481 g_269 g_189 g_190 g_84
 * writes: g_5 g_384 g_381
 */
static int32_t  func_24(void)
{ /* block id: 36 */
    uint32_t l_33 = 0xE5A945CBL;
    const int32_t l_35 = 0xB2C593C8L;
    uint32_t l_72 = 1UL;
    int32_t ****l_587 = (void*)0;
    uint32_t l_596 = 4UL;
    int32_t **l_609 = (void*)0;
    for (g_5 = (-30); (g_5 >= 16); g_5 += 1)
    { /* block id: 39 */
        int16_t l_27 = (-1L);
        return l_27;
    }
    if ((0x1324L <= ((((func_28(l_33, g_5, l_33, ((-(int32_t)(l_35 >= l_33)) <= ((uint16_t)(l_33 >= ((0xCCA6L == (__builtin_clzll(((int16_t)(-1L) + (int16_t)l_33)) < g_5)) > l_35)) % (uint16_t)l_33))) | g_5) >= l_33) == 0xCF59L) <= 0UL)))
    { /* block id: 44 */
        uint16_t l_44 = 0x7F47L;
        int32_t l_571 = (-9L);
        int32_t l_604 = 0xD21FE613L;
    }
    else
    { /* block id: 337 */
        const int32_t l_613 = 1L;
        int32_t ***l_615 = &l_609;
        (*g_383) = (((((void*)0 != l_609) , g_384) <= 4L) ^ (!((void*)0 != (*g_380))));
        for (l_72 = 0; (l_72 >= 55); l_72 += 1)
        { /* block id: 341 */
            uint32_t l_614 = 0xD877F1F5L;
            int32_t *l_624 = &g_355;
        }
    }
    (*g_380) = (l_72 , (*g_380));
    return (****g_481);
}


/* ------------------------------------------ */
/* 
 * reads : g_5
 * writes:
 */
static int16_t  func_28(uint16_t  p_29, uint32_t  p_30, uint32_t  p_31, int32_t  p_32)
{ /* block id: 42 */
    return g_5;
}


/* ------------------------------------------ */
/* 
 * reads : g_379 g_380 g_5 g_228 g_84 g_481 g_269 g_189 g_190 g_268 g_355 g_384 g_254 g_227
 * writes: g_355 g_84 g_190
 */
static const int32_t  func_45(int16_t  p_46, uint32_t  p_47, const uint32_t  p_48, uint32_t  p_49)
{ /* block id: 313 */
    int32_t **l_553 = &g_228;
    int32_t ***l_552 = &l_553;
    int32_t ****l_551 = &l_552;
lbl_556:
    (**l_553) = __builtin_popcount(((int16_t)(l_551 != (*g_379)) >> (int16_t)6));
    for (g_84 = 0; (g_84 == (-10)); g_84 -= 1)
    { /* block id: 317 */
        if (g_5)
            goto lbl_556;
        (**g_269) = (***g_481);
    }
    (**g_269) = ((((**l_551) == (**l_551)) , p_47) , (***g_268));
    (**g_227) = ((int16_t)(((((int16_t)__builtin_ffsll(((int16_t)(****l_551) % (int16_t)65535UL)) >> (int16_t)g_384) == 1UL) , g_254) ^ 0UL) + (int16_t)p_48);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_83 g_84 g_189 g_190 g_227 g_228 g_268 g_269 g_254 g_379 g_381 g_382 g_383 g_384 g_355 g_380 g_481
 * writes: g_84 g_190 g_228 g_379 g_384 g_355 g_383
 */
static int32_t  func_58(int16_t  p_59, uint32_t  p_60, uint32_t  p_61)
{ /* block id: 45 */
    int32_t l_91 = 0L;
    int32_t ***l_518 = (void*)0;
    int32_t *l_525 = &l_91;
    const int32_t *l_547 = &g_84;
    (**g_269) = func_73(((((((((int16_t)((((((0L >= func_77(g_5, g_83, func_85((((int16_t)(((l_91 , func_28(l_91, l_91, l_91, ((int32_t)((((((((((l_91 , func_94(&g_84)) == &l_91) ^ 65535UL) , g_254) == p_61) , (void*)0) != &l_91) , 0x27CD6940L) , l_91) != p_59) % (int32_t)l_91))) , 0UL) & p_60) << (int16_t)p_61) , (*g_227)), l_91, &l_91), &l_91, &g_355)) ^ 1L) != g_5) & l_91) > l_91) , 0L) >> (int16_t)g_254) > p_60) || p_61) < 0x6D1BL) <= 65535UL) >= 4294967295UL) <= 65530UL));
    if (((int16_t)(l_518 == l_518) >> (int16_t)(0x3C83F8DCL | ((*g_189) != &g_84))))
    { /* block id: 280 */
        uint32_t l_519 = 0UL;
        int32_t *l_522 = &g_84;
        if (l_519)
        { /* block id: 281 */
            int32_t *l_524 = &g_355;
            for (p_61 = 0; (p_61 > 3); p_61 += 6)
            { /* block id: 284 */
                uint16_t l_523 = 6UL;
                (*g_383) = ((void*)0 == l_522);
                (*g_189) = func_96(func_96(((0xD710L <= ((void*)0 == &l_522)) , (l_523 , l_524)), func_96((*g_227), l_522, l_525, &g_84, g_84), &g_84, l_522, p_59), l_522, &g_355, l_524, g_355);
                (***g_381) = p_59;
                if (p_59)
                { /* block id: 288 */
                    (***g_380) = (****g_379);
                }
                else
                { /* block id: 290 */
                    (*l_524) = (*l_522);
                    (*g_228) = (-9L);
                    (**g_382) = 5L;
                }
            }
            (*g_228) = p_59;
            (**g_381) = (****g_379);
        }
        else
        { /* block id: 298 */
            int32_t l_533 = 0x1E7F310BL;
            if ((((!func_77(((void*)0 != &l_91), ((((uint16_t)(((((uint32_t)(((__builtin_popcountl((((((int32_t)(((((l_533 , g_355) > (((((((int16_t)0x56DAL % (int16_t)(p_59 | 0x345FE6D7L)) & p_59) & l_533) ^ p_60) >= (****g_481)) , 0L)) != 0xBDA5A589L) & (*l_522)) && g_5) % (int32_t)0xC969600CL) , p_60) , (void*)0) != (*g_380))) <= l_533) <= (*l_525)) , l_533) / (uint32_t)g_84) , l_533) , 65532UL) | 0xAEC5L) >> (uint16_t)0) < (*l_525)) , (*g_227)), l_522, &g_84, l_522)) , g_384) > g_254))
            { /* block id: 299 */
                uint32_t l_536 = 0x1A9FD327L;
                return l_536;
            }
            else
            { /* block id: 301 */
                return l_533;
            }
        }
        (*l_522) = (p_61 , (g_254 > (((int32_t)p_59 % (int32_t)(0xF35B3EC2L ^ 0x0BEF9DECL)) || (((((((int16_t)(((uint16_t)(((((__builtin_parity((*l_522)) >= (((int32_t)((func_28(((*l_522) ^ ((((uint16_t)((**g_227) ^ 8L) % (uint16_t)65535UL) , p_61) , (*l_525))), g_355, g_254, (*g_190)) < p_60) > (*l_522)) - (int32_t)(*l_522)) < (*g_190))) || p_60) < g_84) == p_60) | (*g_228)) << (uint16_t)g_254) < (*l_522)) << (int16_t)13) , (*l_522)) < 0L) < p_61) | p_61) , (-7L)))));
    }
    else
    { /* block id: 306 */
        uint32_t l_548 = 1UL;
        l_547 = (**g_269);
        l_548 = ((*g_382) == (void*)0);
        (*l_525) = (****g_268);
        (*g_382) = (void*)0;
    }
    return (*l_547);
}


/* ------------------------------------------ */
/* 
 * reads : g_228 g_355 g_84 g_227 g_5 g_269 g_189 g_384 g_381 g_382 g_383
 * writes: g_190 g_384
 */
static int32_t * func_73(uint32_t  p_74)
{ /* block id: 276 */
    int32_t **l_512 = &g_228;
    const int32_t *l_513 = &g_355;
    int32_t * const l_514 = &g_84;
    uint32_t l_515 = 0xA23B5FD5L;
    (***g_381) = __builtin_popcount((((uint32_t)((int16_t)p_74 - (int16_t)(((((uint32_t)(((int16_t)(((((int16_t)p_74 / (int16_t)((((void*)0 != l_512) > (**l_512)) ^ p_74)) , func_96((*g_227), l_513, (*l_512), &g_84, g_5)) == l_514) ^ (**l_512)) << (int16_t)11) , g_84) / (uint32_t)(*l_514)) == 1L) ^ l_515) & (*l_514))) % (uint32_t)p_74) , g_384));
    return (*l_512);
}


/* ------------------------------------------ */
/* 
 * reads : g_83 g_355 g_383 g_384 g_381 g_382 g_269 g_189 g_84 g_5 g_380 g_227 g_228 g_190 g_379
 * writes: g_84 g_355 g_384 g_190 g_383 g_228
 */
static int16_t  func_77(int16_t  p_78, int32_t * p_79, int32_t * p_80, int32_t * p_81, int32_t * p_82)
{ /* block id: 169 */
    int16_t l_397 = 1L;
    int32_t l_406 = 1L;
    int32_t ****l_409 = (void*)0;
    volatile int32_t * volatile l_476 = (void*)0;/* VOLATILE GLOBAL l_476 */
    int32_t * const l_488 = &g_84;
    int32_t **l_494 = &g_228;
    int32_t ***l_493 = &l_494;
lbl_478:
    (*g_83) = l_397;
    if (((int16_t)g_355 + (int16_t)l_397))
    { /* block id: 171 */
        uint16_t l_411 = 5UL;
        int32_t *l_416 = &g_84;
        const int16_t l_463 = (-7L);
        for (g_355 = 2; (g_355 != (-26)); g_355 -= 4)
        { /* block id: 174 */
            uint32_t l_407 = 1UL;
            int32_t ****l_410 = (void*)0;
        }
    }
    else
    { /* block id: 224 */
        int32_t l_477 = 0x3322A087L;
        int32_t ** const *l_479 = (void*)0;
        if (l_477)
        { /* block id: 225 */
            const int32_t ** volatile ** const  volatile *l_480 = &g_481;
            if (g_355)
                goto lbl_478;
            (***g_381) = (((void*)0 == l_479) && (*g_383));
            (**g_269) = (void*)0;
            l_480 = &g_268;
        }
        else
        { /* block id: 230 */
            return g_384;
        }
        (*p_80) = func_28(((void*)0 != &g_268), p_78, g_84, (*p_81));
        return g_384;
    }
    for (l_406 = (-19); (l_406 < 9); l_406 += 7)
    { /* block id: 238 */
        int32_t l_485 = 0x037DB4C8L;
        (*p_80) = ((p_78 , 0x479DC69FL) | (-(uint16_t)func_28((g_384 , (p_78 < l_485)), (l_485 , 0x82B4B9ABL), ((2UL != (0xE1A3L >= l_485)) < 0xCEE8L), (*p_80))));
        (*g_382) = (***g_380);
        for (l_485 = 0; (l_485 >= 1); l_485 += 1)
        { /* block id: 243 */
            int32_t **l_489 = (void*)0;
            int32_t *l_490 = (void*)0;
            l_490 = l_488;
            for (g_84 = 0; (g_84 > 23); g_84 += 1)
            { /* block id: 247 */
                int32_t l_495 = 4L;
                int32_t *l_496 = &g_355;
                (**g_382) = func_28((l_493 == (void*)0), l_495, (g_384 == (g_355 || ((*p_81) ^ (p_78 || l_485)))), (3L > l_495));
                (**g_269) = l_496;
            }
            (**g_269) = p_80;
            for (g_355 = 0; (g_355 != (-4)); g_355 -= 1)
            { /* block id: 254 */
                int16_t l_499 = (-1L);
                int32_t *l_500 = &g_84;
                int32_t l_501 = 0x172BB060L;
                if ((*g_383))
                { /* block id: 255 */
                    (*l_493) = &p_81;
                    (**g_269) = (*g_227);
                }
                else
                { /* block id: 258 */
                    (**l_493) = p_79;
                    if (((l_499 , (g_355 ^ p_78)) || ((__builtin_parityl((((void*)0 == l_500) | (**g_189))) == ((l_501 <= g_355) ^ 1L)) >= 0x64D2L)))
                    { /* block id: 260 */
                        (**g_269) = p_82;
                        (**l_493) = p_79;
                    }
                    else
                    { /* block id: 263 */
                        if ((*p_81))
                            break;
                        (*g_382) = (****g_379);
                        (****g_380) = (p_78 , (((*p_81) , (**g_189)) > (*l_500)));
                        return (*l_500);
                    }
                    (*l_494) = p_82;
                }
            }
        }
    }
    (*g_228) = 1L;
    return g_384;
}


/* ------------------------------------------ */
/* 
 * reads : g_379 g_83 g_84 g_381 g_382 g_383 g_269 g_189 g_384 g_355
 * writes: g_379 g_384 g_190 g_84
 */
static int32_t * func_85(int32_t * p_86, uint32_t  p_87, int32_t * p_88)
{ /* block id: 163 */
    int32_t *l_385 = &g_84;
    const int16_t l_396 = 0x1476L;
    g_379 = g_379;
    (***g_381) = (*g_83);
    (**g_269) = l_385;
    (*g_83) = ((p_87 , ((((int16_t)(&g_268 == (void*)0) - (int16_t)(*l_385)) <= (((int32_t)(*g_383) + (int32_t)(((int16_t)((*l_385) , 0L) >> (int16_t)((((((p_87 <= (g_84 > 0x5165B1FAL)) == 0x7B2CC81FL) && 0UL) != 0UL) != l_396) || (-1L))) < g_355)) && (*l_385))) == (*p_88))) | (*l_385));
    return l_385;
}


/* ------------------------------------------ */
/* 
 * reads : g_84 g_83 g_5 g_189 g_190 g_227 g_228 g_268 g_269 g_254 g_355 l_91
 * writes: g_84 g_190 g_228
 */
static int32_t * const  func_94(int32_t * p_95)
{ /* block id: 46 */
    int32_t *l_108 = &g_84;
    int32_t *l_354 = &g_355;
    int32_t *l_378 = &g_355;
    l_354 = func_96(p_95, func_102(p_95, &g_84, l_108, &g_84, (*l_108)), g_83, l_354, g_5);
    if (g_254)
        goto lbl_377;
lbl_377:
    (**g_269) = l_354;
    (**g_269) = l_378;
    return p_95;
}


/* ------------------------------------------ */
/* 
 * reads : g_269 g_189 g_228 g_227
 * writes: g_190
 */
static int32_t * func_96(int32_t * p_97, const int32_t * p_98, int32_t * p_99, int32_t * p_100, uint32_t  p_101)
{ /* block id: 154 */
    int32_t *l_356 = (void*)0;
    int32_t l_363 = 0L;
    int16_t l_372 = 0x3F7AL;
    int32_t **l_376 = &g_228;
    int32_t ***l_375 = &l_376;
    int32_t ****l_374 = &l_375;
    int32_t *****l_373 = &l_374;
    (**g_269) = l_356;
    p_98 = (***l_374);
    return (*g_227);
}


/* ------------------------------------------ */
/* 
 * reads : g_84 g_83 g_5 g_189 g_190 g_227 g_228 g_268 g_269 g_254 g_355 l_91
 * writes: g_84 g_190 g_228
 */
static const int32_t * func_102(int32_t * p_103, int32_t * p_104, int32_t * p_105, int32_t * p_106, const uint16_t  p_107)
{ /* block id: 47 */
    int16_t l_117 = 0xD4AEL;
    int16_t l_126 = 0xA944L;
    int32_t *l_142 = &g_84;
    int16_t l_145 = 0x98B4L;
    int16_t l_152 = 0xEFFBL;
    int32_t **l_300 = &l_142;
    int32_t ***l_299 = &l_300;
    int32_t ****l_298 = &l_299;
    int32_t *****l_297 = &l_298;
    l_126 = ((uint32_t)((uint16_t)g_84 << (uint16_t)4) + (uint32_t)(g_84 && (((((int16_t)(g_84 | (((*g_83) < 0x770660D0L) >= ((((int16_t)((l_117 , ((int16_t)((int16_t)(((uint16_t)((int16_t)p_107 + (int16_t)g_84) >> (uint16_t)g_84) & 0x2F179D16L) * (int16_t)0L) - (int16_t)2UL)) && p_107) >> (int16_t)l_117) >= 0xCCA842DFL) | g_84))) << (int16_t)g_5) , g_5) && l_117) >= l_117)));
    (*p_106) = (l_117 < p_107);
    (*p_105) = (((int32_t)((uint16_t)((uint16_t)p_107 / (uint16_t)p_107) >> (uint16_t)0) - (int32_t)(~l_126)) >= ((int32_t)(l_117 >= (*g_83)) % (int32_t)((g_84 ^ l_117) , func_28(p_107, ((uint16_t)((uint16_t)(p_107 > (-1L)) >> (uint16_t)10) + (uint16_t)l_126), p_107, (*p_104)))));
    if (((int16_t)func_28(((&g_84 != l_142) , (!((!((l_145 > (0xF44AL <= (-(int32_t)(*g_83)))) <= (((*l_142) > (*g_83)) < func_28((!((int16_t)g_84 << (int16_t)7)), ((uint16_t)((((*l_142) | l_152) , (*g_83)) < (*p_106)) >> (uint16_t)g_84), g_84, (*g_83))))) != g_84))), (*l_142), p_107, (*g_83)) % (int16_t)g_5))
    { /* block id: 51 */
        int32_t * const l_155 = &g_84;
        const int32_t l_168 = 0x824F8FB3L;
        int32_t l_281 = 0x982D639CL;
        const int32_t *l_301 = (void*)0;
        uint16_t l_305 = 0UL;
        int32_t l_314 = 0xF107A54BL;
        if (((int16_t)(0x4418BAE6L | g_84) >> (int16_t)((l_155 != (((uint16_t)((*l_142) , (0UL | (((p_107 && ((uint32_t)p_107 - (uint32_t)((int16_t)((((int16_t)((uint16_t)((-1L) & ((int16_t)(1L != g_5) >> (int16_t)g_5)) % (uint16_t)(*l_142)) + (int16_t)0x18E4L) <= g_84) | 0x3F393C2DL) + (int16_t)p_107))) == 65535UL) == g_5))) + (uint16_t)l_168) , p_105)) & g_5)))
        { /* block id: 52 */
            int32_t l_173 = 0x9F0A174FL;
            const int32_t *l_188 = (void*)0;
            (*p_104) = __builtin_parityll(__builtin_clz(((uint16_t)0UL << (uint16_t)p_107)));
            if ((func_28((((p_107 >= ((uint32_t)0UL / (uint32_t)(((func_28(((*l_155) >= (*g_83)), ((void*)0 == l_142), p_107, l_173) , (void*)0) != &g_84) , (*l_155)))) != p_107) , g_5), p_107, (*l_155), (*g_83)) > (*l_155)))
            { /* block id: 54 */
                (*l_155) = l_173;
            }
            else
            { /* block id: 56 */
                int16_t l_185 = (-1L);
                int32_t l_198 = 0x83F7B260L;
                if (((((uint32_t)(-(int32_t)((uint16_t)func_28((p_107 && ((uint16_t)(p_103 == p_103) >> (uint16_t)(((uint16_t)65535UL % (uint16_t)((uint32_t)l_185 + (uint32_t)4294967288UL)) >= ((uint16_t)0xDDC9L >> (uint16_t)2)))), p_107, g_84, (*p_103)) % (uint16_t)g_84)) - (uint32_t)p_107) , l_155) == &g_84))
                { /* block id: 57 */
                    (*g_189) = l_188;
                }
                else
                { /* block id: 59 */
                    uint16_t l_197 = 4UL;
                    for (g_84 = (-16); (g_84 != 16); g_84 += 1)
                    { /* block id: 62 */
                        int32_t l_196 = 0x05A64256L;
                        int32_t l_201 = (-1L);
                        l_196 = ((*p_106) , (((int16_t)g_5 << (int16_t)(!l_196)) & g_84));
                        l_197 = (*g_190);
                        l_198 = (*p_106);
                        l_196 = ((g_84 && p_107) ^ ((int32_t)(p_107 ^ l_201) / (int32_t)(((~(((uint32_t)0UL + (uint32_t)(0x4691L != ((uint16_t)(p_107 <= 0x2AD2L) >> (uint16_t)(((*g_83) ^ 0L) == 4294967289UL)))) > 0xB1E2L)) , g_84) , 0x3F84D8DAL)));
                    }
                }
                if (((((((((*l_155) & (func_28(g_84, p_107, (((uint32_t)((((uint32_t)((uint16_t)p_107 >> (uint16_t)6) + (uint32_t)g_84) || 0xA4EC0DFEL) | (((uint16_t)0x5C8CL / (uint16_t)0xD7F4L) <= ((uint16_t)((((int32_t)(*g_83) - (int32_t)0xA36B31EAL) >= g_84) , p_107) << (uint16_t)p_107))) % (uint32_t)(*p_105)) , (*l_142)), (*g_83)) & 0x1A52L)) | p_107) && 0x756BAA74L) > g_5) == p_107) <= 4294967291UL) & p_107))
                { /* block id: 69 */
                    int32_t **l_223 = &l_142;
                    (*l_223) = (void*)0;
                }
                else
                { /* block id: 71 */
                    for (l_117 = 21; (l_117 != 21); l_117 += 8)
                    { /* block id: 74 */
                        (*g_189) = &l_198;
                    }
                    p_104 = ((*p_105) , (void*)0);
                }
            }
        }
        else
        { /* block id: 80 */
            uint16_t l_250 = 0xF2AEL;
            int32_t l_323 = 0x8688D3ECL;
            const int32_t *l_336 = &l_323;
            (*g_227) = p_105;
            for (l_126 = 0; (l_126 != 26); l_126 += 1)
            { /* block id: 84 */
                (*g_228) = (((uint16_t)((void*)0 == l_155) - (uint16_t)p_107) && p_107);
            }
            (**g_227) = (*p_104);
            for (g_84 = 27; (g_84 == 14); g_84 -= 1)
            { /* block id: 90 */
                const uint32_t l_237 = 0x97C0C016L;
                int16_t l_255 = 1L;
                int32_t l_266 = 0x91A87AE2L;
                const int32_t **l_277 = &g_190;
                const int32_t ***l_276 = &l_277;
                const int32_t ****l_275 = &l_276;
                uint16_t l_306 = 0xA130L;
                int32_t l_335 = 0xD3C6F077L;
            }
        }
    }
    else
    { /* block id: 148 */
        uint32_t l_353 = 0x689C20EAL;
        (*p_105) = (*p_103);
        (**l_300) = (1UL != ((uint16_t)(g_5 < (((int32_t)(0x9BA2L < (((((int16_t)((((uint16_t)g_5 << (uint16_t)1) >= (*l_142)) && ((int32_t)((*g_268) == (void*)0) / (int32_t)((int32_t)(*p_103) - (int32_t)(func_28((g_5 || g_254), g_5, g_5, (*****l_297)) && g_5)))) >> (int16_t)5) > g_254) ^ l_353) ^ p_107)) - (int32_t)l_353) < l_353)) >> (uint16_t)(*l_142)));
        return p_106;
    }
    return p_105;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_24();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_84, "g_84", print_hash_value);
    transparent_crc(g_254, "g_254", print_hash_value);
    transparent_crc(g_355, "g_355", print_hash_value);
    transparent_crc(g_384, "g_384", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 119
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 136
   depth: 2, occurrence: 19
   depth: 3, occurrence: 1
   depth: 4, occurrence: 6
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 3
   depth: 25, occurrence: 1
   depth: 33, occurrence: 1
   depth: 36, occurrence: 1
   depth: 44, occurrence: 1

XXX total number of pointers: 105

XXX times a variable address is taken: 112
XXX times a pointer is dereferenced on RHS: 207
breakdown:
   depth: 1, occurrence: 165
   depth: 2, occurrence: 19
   depth: 3, occurrence: 13
   depth: 4, occurrence: 9
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 94
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 28
   depth: 3, occurrence: 11
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 547

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 718
   level: 2, occurrence: 136
   level: 3, occurrence: 62
   level: 4, occurrence: 27
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 47
XXX number of pointers point to scalars: 58
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 19
XXX average alias set size: 1.5

XXX times a non-volatile is read: 984
XXX times a non-volatile is write: 229
XXX times a volatile is read: 87
XXX    times read thru a pointer: 35
XXX times a volatile is write: 63
XXX    times written thru a pointer: 50
XXX times a volatile is available for access: 215
XXX percentage of non-volatile access: 89

XXX forward jumps: 1
XXX backward jumps: 7

XXX stmts: 117
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 38
   depth: 1, occurrence: 22
   depth: 2, occurrence: 19
   depth: 3, occurrence: 13
   depth: 4, occurrence: 14
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 12.5
XXX percentage an existing variable is used: 87.5
********************* end of statistics **********************/

