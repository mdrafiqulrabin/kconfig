/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      584290882
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_33(void);
static uint16_t  func_44(int32_t  p_45, int32_t  p_46);
static float  func_59(int32_t  p_60, uint32_t  p_61, float  p_62, uint16_t  p_63, int32_t  p_64);
static const uint32_t  func_88(int16_t  p_89, int32_t  p_90);
static uint16_t  func_91(uint32_t  p_92);
static int8_t  func_96(const int32_t  p_97, int32_t  p_98, float  p_99, int16_t  p_100);
static const float  func_123(const uint32_t  p_124);
static uint32_t  func_125(uint32_t  p_126, const int16_t  p_127, uint16_t  p_128, float  p_129, const float  p_130);
static int16_t  func_138(uint16_t  p_139, const uint32_t  p_140, int8_t  p_141, uint16_t  p_142);
static int16_t  func_150(float  p_151, int32_t  p_152, int16_t  p_153, uint32_t  p_154, const uint32_t  p_155);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_33(void)
{ /* block id: 36 */
    int8_t l_34 = 1L;
    uint32_t l_35 = 0x858905B8L;
    uint32_t l_475 = 0xD8342909L;
    float l_479 = 0x1.7p+1;
    float *l_478 = &l_479;
    int32_t ***l_488 = (void*)0;
    int32_t l_499 = 1L;
    int32_t ****l_540 = &l_488;
    int32_t *****l_539 = &l_540;
    l_35 = l_34;
    if ((((0x1CD43096L && (safe_mod_func_int32_t_s_s((safe_div_func_uint32_t_u_u((((l_35 || ((safe_mod_func_int16_t_s_s(l_34, (safe_div_func_uint16_t_u_u(func_44(l_35, ((l_35 > (safe_sub_func_int32_t_s_s(1L, 4294967295UL))) == (safe_lshift_func_int16_t_s_u(l_35, 4)))), l_34)))) > l_35)) , l_35) >= l_35), l_35)), l_35))) || l_475) <= l_475))
    { /* block id: 240 */
        float l_477 = (-0x1.0p-1);
        const float *l_476 = &l_477;
        int32_t l_481 = 0xE11DEAA6L;
        int32_t *l_480 = &l_481;
        uint16_t l_491 = 0x56C3L;
        float **l_498 = &l_478;
        int8_t l_504 = (-1L);
        int32_t **l_509 = &l_480;
        int32_t ***l_508 = &l_509;
        (*l_480) = (l_476 == l_478);
        (*l_480) = func_150((((((-(safe_add_func_float_f_f((safe_sub_func_float_f_f((l_35 != ((!((void*)0 != l_488)) >= (*l_480))), (((*l_480) < (safe_div_func_float_f_f(((l_491 != (*l_480)) <= (((&l_481 == &l_481) < l_35) > (*l_480))), l_35))) < (*l_480)))), (*l_480)))) != (*l_480)) < (-0x5.5p-1)) , 0x3.5p+1) >= l_34), (*l_480), l_475, (*l_480), (*l_480));
        if (((*l_480) == (safe_unary_minus_func_int16_t_s((0x6FB0L < (*l_480))))))
        { /* block id: 243 */
            float **l_497 = &l_478;
            const int32_t l_500 = 0xD6FE7FA3L;
            (*l_478) = func_150((*l_480), ((safe_lshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_u((((((*l_480) < ((__builtin_ffs((*l_480)) & __builtin_ctzl((*l_480))) , (__builtin_ffsll((l_497 != l_498)) && (*l_480)))) != l_499) != l_475) & l_500), l_500)), (*l_480))) <= l_500), l_500, l_500, (*l_480));
        }
        else
        { /* block id: 245 */
            const float l_503 = 0xB.28FC71p-1;
            int32_t **l_505 = &l_480;
            (*l_478) = (__builtin_ffs((4294967287UL ^ (safe_rshift_func_uint16_t_u_u((*l_480), l_504)))) > ((((*l_480) | (*l_480)) , 0xC.BEBF86p-92) < l_475));
            (*l_505) = &l_481;
            (**l_508) = (((**l_505) <= (0xEA5BL <= (safe_rshift_func_uint16_t_u_s((((-1L) >= (**l_505)) | (**l_505)), (((*l_480) != (*l_480)) , (((void*)0 == l_508) == 0x5552L)))))) , (void*)0);
            /* statement id: 248 */
            assert (l_480 == 0);
        }
        /* facts after branching */
        assert (l_480 == 0 || l_480 == &l_481);
    }
    else
    { /* block id: 250 */
        int32_t l_514 = 1L;
        for (l_35 = 25; (l_35 < 38); ++l_35)
        { /* block id: 253 */
            float l_512 = (-0x1.3p+1);
            uint16_t l_513 = 0x5927L;
            if ((l_475 < l_513))
            { /* block id: 254 */
                return l_514;
            }
            else
            { /* block id: 256 */
                int32_t l_515 = 6L;
                int32_t l_517 = (-1L);
                int32_t *l_516 = &l_517;
                (*l_516) = l_515;
            }
        }
    }
    for (l_35 = 0; (l_35 == 37); l_35 = safe_add_func_uint32_t_u_u(l_35, 1))
    { /* block id: 263 */
        uint32_t l_523 = 0x270EBE68L;
        int16_t l_527 = 0x5A0EL;
        int32_t l_531 = 0L;
        int32_t *l_530 = &l_531;
        float **l_534 = &l_478;
        float ***l_533 = &l_534;
        float ****l_532 = &l_533;
        int32_t ****l_536 = (void*)0;
        int32_t *****l_535 = &l_536;
        (*l_478) = (safe_sub_func_float_f_f((+l_523), (__builtin_bswap32(l_523) > ((-(((~l_34) != ((func_150(l_523, (~l_523), l_527, ((l_523 , (((safe_div_func_uint16_t_u_u(((l_527 , l_527) , 0xC83AL), 1L)) > l_523) | 0xD87AL)) > l_523), l_523) < l_523) == l_34)) , l_527)) != l_523))));
        l_530 = l_530;
        (*l_478) = (((void*)0 != l_532) <= (((*l_530) , l_535) != ((safe_rshift_func_int16_t_s_s(l_35, 8)) , l_539)));
        (***l_533) = (0x1.Bp+1 <= (*l_530));
    }
    return l_499;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_44(int32_t  p_45, int32_t  p_46)
{ /* block id: 38 */
    int32_t l_54 = 6L;
    int32_t l_322 = (-1L);
    int32_t *l_321 = &l_322;
    float ***l_323 = (void*)0;
    float l_326 = 0x3.Dp-1;
    float *l_325 = &l_326;
    float **l_324 = &l_325;
    int32_t **l_376 = &l_321;
    int32_t ***l_375 = &l_376;
    int32_t ****l_374 = &l_375;
    uint32_t l_379 = 0UL;
    int32_t l_384 = 0xBF9C21C5L;
    int32_t l_437 = 1L;
    const int8_t l_463 = 0x23L;
    int32_t l_472 = 6L;
    (*l_321) = (((safe_mod_func_uint32_t_u_u((((((+p_45) >= ((l_54 != (safe_add_func_float_f_f((safe_sub_func_float_f_f(func_59(p_45, (((((((l_54 > (safe_rshift_func_int16_t_s_u(__builtin_clzll(((safe_add_func_uint32_t_u_u(0x7092FF82L, (safe_mod_func_int16_t_s_s(__builtin_ffs(l_54), (l_54 || ((-9L) == p_46)))))) > p_46)), 2))) , l_54) != l_54) | l_54) , p_45) , p_45) , p_46), p_45, p_46, p_46), l_54)), p_45))) < p_45)) , l_54) > 8L) || l_54), p_46)) == 0x7921FCF2L) & l_54);
    l_324 = (void*)0;
    /* statement id: 147 */
    assert (l_324 == 0);
    for (p_46 = 0; (p_46 > 14); ++p_46)
    { /* block id: 150 */
        int32_t *l_333 = &l_322;
        uint32_t l_342 = 0xF32BFF61L;
        const int16_t l_406 = 0xC1CCL;
        float **l_457 = &l_325;
    }
    (*l_325) = func_88(func_91((p_46 || ((safe_add_func_int32_t_s_s(((p_46 , p_45) , (***l_375)), (***l_375))) , ((((((safe_rshift_func_int16_t_s_s(func_88(l_472, ((safe_div_func_int32_t_s_s((****l_374), p_45)) == (**l_376))), p_45)) || (-10L)) && p_46) || 0xE4D31844L) | 0L) , p_46)))), p_45);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_59(int32_t  p_60, uint32_t  p_61, float  p_62, uint16_t  p_63, int32_t  p_64)
{ /* block id: 39 */
    int16_t l_84 = 0x9DB5L;
    uint32_t l_95 = 0xF50EDC67L;
    const int32_t *l_246 = (void*)0;
    int32_t ***l_308 = (void*)0;
    const int16_t l_315 = 0x634AL;
    int32_t l_317 = (-10L);
    int32_t *l_316 = &l_317;
    int32_t *l_318 = &l_317;
    int32_t **l_319 = (void*)0;
    int32_t **l_320 = &l_316;
    for (p_61 = (-24); (p_61 < 22); p_61 = safe_add_func_uint32_t_u_u(p_61, 2))
    { /* block id: 42 */
        const int8_t l_101 = 1L;
        int32_t l_243 = 0xFF70A894L;
        int32_t *l_242 = &l_243;
        const int8_t l_270 = 1L;
        float l_293 = 0x1.9p+1;
        float *l_292 = &l_293;
        uint32_t l_304 = 0UL;
    }
    (*l_316) = ((l_308 != l_308) , (safe_rshift_func_int16_t_s_u(((safe_add_func_int32_t_s_s(p_61, (safe_lshift_func_uint16_t_u_u(0x6AC2L, 14)))) && (((p_60 == (p_64 & l_315)) > p_63) , 8UL)), p_61)));
    (*l_320) = l_318;
    (**l_320) = func_138((**l_320), p_63, (*l_318), p_61);
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_88(int16_t  p_89, int32_t  p_90)
{ /* block id: 96 */
    return p_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_91(uint32_t  p_92)
{ /* block id: 88 */
    const int32_t l_226 = 1L;
    uint32_t l_227 = 0xD5CCC3D4L;
    l_227 = l_226;
    for (p_92 = (-6); (p_92 > 1); p_92 = safe_add_func_uint32_t_u_u(p_92, 7))
    { /* block id: 92 */
        return p_92;
    }
    return l_226;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_96(const int32_t  p_97, int32_t  p_98, float  p_99, int16_t  p_100)
{ /* block id: 49 */
    uint32_t l_110 = 1UL;
    uint32_t l_116 = 0x33481FF7L;
    int32_t **l_219 = (void*)0;
    if (__builtin_popcountl((((safe_add_func_int32_t_s_s(p_100, ((safe_mod_func_uint32_t_u_u(((safe_sub_func_int16_t_s_s((safe_sub_func_int16_t_s_s(__builtin_ffsl(l_110), 8UL)), p_97)) , 0UL), (safe_sub_func_int32_t_s_s((((safe_add_func_int16_t_s_s((~(p_100 ^ __builtin_popcount((2L & l_110)))), 1L)) > 4294967290UL) != l_110), l_116)))) , 0xEF177DAEL))) > l_116) > (-4L))))
    { /* block id: 50 */
        const uint32_t l_131 = 7UL;
        float *l_211 = (void*)0;
        float l_213 = (-0x1.9p+1);
        float *l_212 = &l_213;
        int32_t l_216 = 1L;
        int32_t *l_215 = &l_216;
        int32_t **l_214 = &l_215;
        (*l_212) = (safe_sub_func_float_f_f((safe_sub_func_float_f_f(((safe_add_func_float_f_f((__builtin_clzll(p_97) < p_98), (func_123(func_125(l_110, l_131, ((safe_sub_func_int16_t_s_s((0xE34927B9L != ((safe_sub_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s(func_138(l_110, p_97, (safe_mod_func_int32_t_s_s(((0xFCBC420BL == l_110) == l_110), 0x7621CC8EL)), l_116), p_97)), p_98)) > p_100)), l_131)) , l_131), p_98, l_110)) < p_98))) < 0x1.982E97p+23), 0xD.CADED1p+86)), 0x3.E70E50p+47));
        (*l_214) = (void*)0;
        /* statement id: 82 */
        assert (l_215 == 0);
    }
    else
    { /* block id: 83 */
        float l_218 = (-0x1.6p+1);
        float *l_217 = &l_218;
        (*l_217) = p_98;
    }
    p_98 = ((l_116 ^ (0x8F057B95L ^ (l_219 != l_219))) < (safe_mod_func_int32_t_s_s((((l_219 != l_219) || (p_97 | (safe_mod_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((l_116 == (&p_98 != &p_98)), p_98)), p_97)))) == l_110), p_100)));
    return p_100;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_123(const uint32_t  p_124)
{ /* block id: 77 */
    int16_t l_198 = 0xC7FAL;
    int8_t l_201 = 0x46L;
    int32_t *l_202 = (void*)0;
    int32_t l_204 = (-2L);
    int32_t *l_203 = &l_204;
    float l_210 = 0x0.0p-1;
    float *l_209 = &l_210;
    (*l_203) = func_138(p_124, p_124, p_124, (safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u((safe_add_func_int16_t_s_s((-1L), (safe_sub_func_int32_t_s_s(((p_124 & 0x3209L) && (l_198 != ((p_124 , ((__builtin_ffsll((safe_mod_func_uint16_t_u_u(l_198, 0x8868L))) < 0x7F57L) < 0xA9D5L)) <= l_201))), l_201)))), l_198)) & p_124), 0)), l_198)));
    (*l_209) = ((safe_add_func_int16_t_s_s(((p_124 != (((((0x6.5411A6p+49 > (__builtin_parityl((*l_203)) < (*l_203))) , &l_203) != (void*)0) && __builtin_ctz((p_124 > p_124))) != p_124)) & 65527UL), 0xACC3L)) , p_124);
    return p_124;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_125(uint32_t  p_126, const int16_t  p_127, uint16_t  p_128, float  p_129, const float  p_130)
{ /* block id: 75 */
    return p_126;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_138(uint16_t  p_139, const uint32_t  p_140, int8_t  p_141, uint16_t  p_142)
{ /* block id: 51 */
    uint32_t l_145 = 0x38FA4CEBL;
    int8_t l_167 = 0xFDL;
    int32_t l_171 = 0x6F24FD69L;
    int32_t *l_170 = &l_171;
    int32_t l_172 = 0x00924423L;
    if ((((l_145 > (safe_div_func_uint32_t_u_u((l_145 , 1UL), p_140))) , (safe_div_func_int16_t_s_s(func_150((p_141 , (l_145 == (-((p_140 > (l_145 != (((l_145 <= p_140) < p_142) != l_145))) == p_139)))), p_139, l_145, p_142, l_145), l_167))) || l_167))
    { /* block id: 56 */
        int32_t l_169 = (-1L);
        int32_t *l_168 = &l_169;
        l_170 = l_168;
        /* statement id: 57 */
        assert (l_170 == &l_169);
        (*l_168) = (&l_169 != &l_169);
        (*l_168) = ((*l_170) | (((((*l_168) , &l_169) == (p_140 , (void*)0)) ^ l_172) <= (p_139 < ((void*)0 != &l_169))));
        (*l_168) = (__builtin_clz((*l_168)) ^ (safe_add_func_uint32_t_u_u((((5L || 4294967290UL) && (p_139 && 6L)) || p_140), (((&l_170 != (void*)0) , (*l_170)) , p_140))));
    }
    else
    { /* block id: 61 */
        uint32_t l_179 = 1UL;
        int32_t *l_185 = &l_171;
        if ((p_139 | func_150((safe_sub_func_float_f_f((safe_add_func_float_f_f(p_139, p_142)), p_141)), l_179, l_179, p_142, ((void*)0 != &l_170))))
        { /* block id: 62 */
            int32_t *l_182 = &l_171;
            int32_t **l_184 = &l_170;
            for (l_145 = (-17); (l_145 != 59); l_145 = safe_add_func_int32_t_s_s(l_145, 1))
            { /* block id: 65 */
                int32_t **l_183 = &l_182;
                (*l_183) = l_182;
                if (p_142)
                    break;
            }
            (*l_184) = &l_171;
        }
        else
        { /* block id: 70 */
            const int32_t *l_187 = &l_171;
            const int32_t **l_186 = &l_187;
            (*l_186) = l_185;
        }
    }
    /* facts after branching */
    //assert (l_170 == &l_171 || l_170 == dangling);
    return p_139;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_150(float  p_151, int32_t  p_152, int16_t  p_153, uint32_t  p_154, const uint32_t  p_155)
{ /* block id: 52 */
    int8_t l_161 = 0L;
    const int32_t l_163 = 0x0D5298B4L;
    const int32_t *l_162 = &l_163;
    int32_t l_166 = 1L;
    int32_t *l_165 = &l_166;
    int32_t **l_164 = &l_165;
    (*l_164) = ((safe_sub_func_int16_t_s_s((safe_div_func_int16_t_s_s(p_153, 1L)), l_161)) , l_162);
    /* statement id: 53 */
    assert (l_165 == &l_163);
    (*l_164) = (*l_164);
    return p_154;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 117
XXX total union variables: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 14, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 27, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 96

XXX times a variable address is taken: 102
XXX times a pointer is dereferenced on RHS: 84
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 11
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 63
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 195

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 146
   level: 2, occurrence: 25
   level: 3, occurrence: 12
   level: 4, occurrence: 7
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 53
XXX number of pointers point to scalars: 43
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 28.1
XXX average alias set size: 1.21

XXX times a non-volatile is read: 678
XXX times a non-volatile is write: 176
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 59
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 17
   depth: 2, occurrence: 8
   depth: 3, occurrence: 4

XXX percentage a fresh-made variable is used: 17.8
XXX percentage an existing variable is used: 82.2
********************* end of statistics **********************/

