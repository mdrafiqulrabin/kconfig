/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      2311803898
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const unsigned f0 : 11;
   signed f1 : 20;
   int16_t  f2;
   const float  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int32_t  func_12(float  p_13, uint32_t  p_14, int32_t  p_15, const int32_t * p_16);
static float  func_17(int32_t * p_18, uint16_t  p_19);
static int32_t * func_20(uint16_t  p_21, int32_t * p_22, int32_t  p_23, int16_t  p_24);
static const int32_t  func_27(const int32_t * p_28, uint16_t  p_29);
static uint16_t  func_30(const float  p_31, int32_t * p_32, int32_t * p_33);
static int32_t ** func_34(int32_t ** p_35, int32_t  p_36, struct S0  p_37, int32_t * p_38, struct S0  p_39);
static int32_t ** func_40(struct S0  p_41, int32_t * p_42, int32_t  p_43, uint16_t  p_44, const int32_t * p_45);
static struct S0  func_46(int32_t * p_47, int16_t  p_48);
static int32_t * func_53(float  p_54, int32_t  p_55, int32_t * p_56, int32_t * p_57, int32_t * p_58);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_2 = 0xBB6748F6;
    int32_t l_4 = 0x14B733C6;
    int32_t *l_3 = &l_4;
    int32_t l_1116 = (-1);
    const int32_t *l_1115 = &l_1116;
    int32_t l_1117 = 0xA40F379F;
    (*l_3) = l_2;
    for (l_4 = 0; (l_4 <= (-2)); l_4--)
    { /* block id: 4 */
        uint16_t l_11 = 0x6576;
        int32_t *l_26 = &l_4;
        int16_t l_856 = (-5);
        int32_t l_1104 = 0x8E106397;
        if (((int16_t)((int16_t)(0x2579253A > (*l_3)) >> (int16_t)l_11) + (int16_t)0xA5A4))
        { /* block id: 5 */
            int32_t *l_25 = &l_4;
            int32_t l_1106 = 0x639D9810;
            int32_t *l_1105 = &l_1106;
            (*l_1105) = func_12(func_17(func_20((0xC8D46758 ^ (((l_25 != l_26) | (*l_3)) <= func_27(l_26, func_30((*l_26), l_26, l_25)))), l_26, l_856, (*l_26)), (*l_26)), l_1104, (*l_26), &l_4);
        }
        else
        { /* block id: 545 */
            float *l_1107 = (void*)0;
            float l_1109 = 0xC.6F2CBEp+76;
            float *l_1108 = &l_1109;
            int32_t l_1110 = 0x808C3D78;
            (*l_1108) = ((*l_26) < (-0x1.4p+1));
            return l_1110;
        }
        for (l_11 = 19; (l_11 != 21); l_11 += 1)
        { /* block id: 551 */
            const int32_t *l_1114 = (void*)0;
            const int32_t **l_1113 = &l_1114;
            l_1115 = ((*l_1113) = &l_4);
            /* statement id: 553 */
            assert (l_1115 == &l_4);
            assert (l_1114 == &l_4);
        }
    }
    /* facts after for loop */
    assert (l_1115 == &l_4 || l_1115 == &l_1116);
    return l_1117;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_12(float  p_13, uint32_t  p_14, int32_t  p_15, const int32_t * p_16)
{ /* block id: 541 */
    p_13 = 0x1.Ep-1;
    return (*p_16);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_17(int32_t * p_18, uint16_t  p_19)
{ /* block id: 392 */
    int16_t l_865 = (-2);
    uint32_t l_870 = 0x5CEB02AE;
    uint32_t *l_869 = &l_870;
    int32_t l_879 = 0x111237BD;
    int32_t *l_878 = &l_879;
    uint32_t l_918 = 4294967288U;
    uint32_t **l_940 = &l_869;
    uint32_t ***l_939 = &l_940;
    uint32_t ****l_938 = &l_939;
    struct S0 *l_1001 = (void*)0;
    struct S0 **l_1000 = &l_1001;
    int32_t ***l_1062 = (void*)0;
    struct S0 l_1070 = {14,186,0x1603,0xF.0128A0p+23};
    struct S0 *l_1069 = &l_1070;
    uint16_t *l_1077 = (void*)0;
    uint16_t **l_1076 = &l_1077;
    if (((uint16_t)l_865 << (uint16_t)(l_865 == ((uint16_t)(-(uint32_t)l_865) + (uint16_t)(l_865 >= ((*l_869) = 1U))))))
    { /* block id: 394 */
        int32_t *****l_871 = (void*)0;
        int32_t l_872 = (-1);
        l_871 = l_871;
        p_18 = p_18;
        l_872 = l_872;
    }
    else
    { /* block id: 398 */
        uint32_t *l_890 = &l_870;
        int32_t l_902 = 0x74C8E575;
        int32_t l_916 = 0;
        uint32_t ****l_941 = (void*)0;
        float l_967 = 0x1.6p-1;
        float *l_966 = &l_967;
        uint32_t l_974 = 0xE43290A8;
        float **l_989 = &l_966;
        float ***l_988 = &l_989;
        int32_t *l_997 = &l_902;
        uint32_t l_1027 = 0x289B7316;
        float l_1028 = (-0x1.4p-1);
        uint16_t ****l_1059 = (void*)0;
        int16_t *l_1081 = &l_865;
        int16_t **l_1080 = &l_1081;
        uint16_t l_1103 = 65535U;
        for (l_865 = 0; (l_865 >= (-25)); l_865 -= 6)
        { /* block id: 401 */
            uint16_t l_875 = 6U;
            uint16_t *l_899 = &l_875;
            int32_t l_917 = 0x810C59D2;
            uint32_t l_923 = 0x4282D4DC;
            const uint32_t ***l_924 = (void*)0;
            int32_t l_994 = (-6);
            struct S0 *l_1012 = (void*)0;
            int32_t l_1024 = (-10);
            int32_t *l_1045 = &l_1024;
            uint32_t l_1048 = 1U;
            uint16_t ***l_1058 = (void*)0;
            uint16_t ****l_1057 = &l_1058;
            float l_1063 = 0xC.F09924p+63;
            if (l_875)
            { /* block id: 402 */
                int32_t l_888 = 7;
                for (l_870 = (-20); (l_870 < 60); l_870 += 1)
                { /* block id: 405 */
                    int32_t **l_880 = &l_878;
                    int32_t *l_882 = &l_879;
                    int32_t **l_881 = &l_882;
                    (*l_881) = ((*l_880) = l_878);
                    for (l_879 = 1; (l_879 == 5); l_879 += 1)
                    { /* block id: 410 */
                        uint16_t l_885 = 0x00E8;
                        l_885 = 0x6.2p-1;
                    }
                }
                for (l_879 = 17; (l_879 < 16); l_879 -= 1)
                { /* block id: 416 */
                    l_888 = p_19;
                }
            }
            else
            { /* block id: 419 */
                int32_t **l_889 = &l_878;
                if (p_19)
                    break;
                (*l_889) = &l_879;
            }
        }
    }
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_20(uint16_t  p_21, int32_t * p_22, int32_t  p_23, int16_t  p_24)
{ /* block id: 390 */
    int32_t l_858 = 0x63F1DD14;
    int32_t *l_857 = &l_858;
    int32_t *l_859 = &l_858;
    int32_t *l_860 = &l_858;
    int32_t *l_861 = &l_858;
    int32_t *l_862 = (void*)0;
    return l_862;
    /* statement id: 391 */
    //assert (func_20_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_27(const int32_t * p_28, uint16_t  p_29)
{ /* block id: 36 */
    int32_t ****l_125 = (void*)0;
    int32_t *****l_124 = &l_125;
    float l_145 = 0x0.7p-1;
    uint16_t l_150 = 0U;
    uint16_t *l_149 = &l_150;
    int32_t l_151 = 0xFE3867A3;
    int32_t l_152 = (-10);
    float **l_213 = (void*)0;
    float ***l_212 = &l_213;
    int16_t l_262 = (-9);
    int32_t l_428 = (-3);
    struct S0 l_475 = {4,-150,-6,0x0.3p-1};
    struct S0 *l_474 = &l_475;
    const int32_t ***l_493 = (void*)0;
    const int32_t ****l_492 = &l_493;
    int32_t *l_566 = &l_151;
    int32_t *l_567 = &l_151;
    struct S0 **l_575 = (void*)0;
    struct S0 ***l_574 = &l_575;
    int32_t **l_594 = &l_566;
    int32_t ***l_593 = &l_594;
    uint16_t **l_608 = (void*)0;
    uint16_t ***l_607 = &l_608;
    uint32_t l_622 = 0xDC2EB67A;
    uint32_t *l_621 = &l_622;
    uint32_t **l_620 = &l_621;
    int32_t *l_635 = &l_151;
    int32_t **l_636 = &l_635;
    int16_t l_661 = 0xEDC6;
    uint32_t l_688 = 0x073AF742;
    uint32_t l_737 = 0xF51C489F;
    const uint32_t *l_739 = &l_737;
    const uint32_t **l_738 = &l_739;
    int32_t l_742 = (-1);
    int32_t l_757 = 0x9894A632;
    uint32_t l_786 = 0x8F6BD39F;
    const int32_t l_855 = 1;
    l_124 = l_124;
    return (*p_28);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_30(const float  p_31, int32_t * p_32, int32_t * p_33)
{ /* block id: 6 */
    int32_t l_49 = (-6);
    int32_t *l_60 = &l_49;
    int32_t **l_59 = &l_60;
    int32_t **l_62 = (void*)0;
    int32_t ***l_61 = &l_62;
    struct S0 l_116 = {5,-127,0xE0B9,0xD.64D233p-77};
    (*l_61) = func_34(func_40(func_46(p_32, l_49), ((*l_59) = func_53((p_31 != p_31), (((l_59 != ((*l_61) = &p_33)) <= (l_60 == l_60)) || (***l_61)), p_33, p_33, p_32)), l_49, l_49, p_32), (*p_33), l_116, p_33, l_116);
    /* statement id: 34 */
    assert (l_60 == 0);
    return l_116.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_34(int32_t ** p_35, int32_t  p_36, struct S0  p_37, int32_t * p_38, struct S0  p_39)
{ /* block id: 30 */
    int32_t l_119 = 8;
    int32_t *l_118 = &l_119;
    int32_t **l_117 = &l_118;
    float *l_120 = (void*)0;
    float l_122 = 0x1.4p-1;
    float *l_121 = &l_122;
    int32_t **l_123 = (void*)0;
    (*l_121) = ((**l_117) = (l_117 != (void*)0));
    return l_123;
    /* statement id: 33 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_4
 * writes:
 */
static int32_t ** func_40(struct S0  p_41, int32_t * p_42, int32_t  p_43, uint16_t  p_44, const int32_t * p_45)
{ /* block id: 15 */
    int32_t l_72 = 0xDDA102F3;
    int32_t *l_76 = &l_72;
    int32_t **l_75 = &l_76;
    uint16_t l_84 = 0x66DE;
    int32_t l_100 = 0x05E375EF;
    int32_t **l_103 = &l_76;
    int32_t **l_104 = &l_76;
    int32_t **l_105 = &l_76;
    int32_t **l_106 = &l_76;
    int32_t **l_107 = &l_76;
    int32_t **l_108 = &l_76;
    int32_t **l_109 = &l_76;
    int32_t **l_110 = &l_76;
    int32_t **l_111 = &l_76;
    int32_t **l_112 = &l_76;
    int32_t **l_113 = &l_76;
    int32_t **l_114 = &l_76;
    int32_t **l_115 = (void*)0;
    for (p_44 = 0; (p_44 != 38); p_44 += 1)
    { /* block id: 18 */
        uint32_t l_71 = 4294967286U;
        int32_t *l_73 = &l_72;
        int32_t **l_74 = &l_73;
        (*l_74) = func_53(p_41.f0, l_71, func_53(p_41.f2, l_72, p_42, l_73, &l_72), p_42, p_42);
        /* statement id: 19 */
        assert (l_73 == 0);
    }
    (*l_75) = &l_72;
    if (((((uint16_t)65530U * (uint16_t)((int16_t)((-(int16_t)(p_41.f1 <= ((p_43 == (((&l_75 != &l_75) >= ((int32_t)0x91F7D461 % (int32_t)l_84)) >= (-(uint16_t)(((void*)0 == p_42) ^ p_44)))) | (**l_75)))) <= (*l_76)) + (int16_t)p_41.f2)) <= p_41.f1) == 0x1B43))
    { /* block id: 22 */
        int32_t ***l_88 = &l_75;
        int32_t ***l_90 = &l_75;
        int32_t ****l_89 = &l_90;
        float l_102 = 0xB.42A635p-5;
        float *l_101 = &l_102;
        (*l_75) = func_53((((float)((-0x1.Cp-1) != ((l_88 == ((*l_89) = l_88)) > (((float)((float)(-(float)(((*l_76) == p_41.f1) > (*l_76))) + (float)((float)((*l_101) = (p_41.f2 <= (((((float)0x5.CF7483p+64 - (float)(-0x1.6p-1)) > p_41.f1) < l_100) > p_41.f1))) * (float)0x7.9p+1)) * (float)0x2.Ep+1) != p_41.f1))) - (float)p_41.f3) > 0x0.4p+1), (*p_45), (**l_88), (*l_75), p_42);
        /* statement id: 25 */
        assert (l_76 == 0);
    }
    else
    { /* block id: 26 */
        (*l_75) = (void*)0;
        /* statement id: 27 */
        assert (l_76 == 0);
    }
    /* facts after branching */
    assert (l_76 == 0);
    return l_115;
    /* statement id: 29 */
    //assert (func_40_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_46(int32_t * p_47, int16_t  p_48)
{ /* block id: 7 */
    float l_51 = (-0x1.Ep-1);
    float *l_50 = &l_51;
    struct S0 l_52 = {3,857,0xDA1E,0xD.F2BBA2p+60};
    (*l_50) = ((void*)0 != &p_47);
    return l_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_53(float  p_54, int32_t  p_55, int32_t * p_56, int32_t * p_57, int32_t * p_58)
{ /* block id: 11 */
    int32_t l_64 = 0x0FD77138;
    int32_t *l_63 = &l_64;
    int32_t **l_65 = &l_63;
    int32_t *l_66 = &l_64;
    int32_t *l_67 = &l_64;
    int32_t *l_68 = (void*)0;
    (*l_65) = l_63;
    return l_68;
    /* statement id: 13 */
    //assert (func_53_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 253
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 22
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 13
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 11

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 11, occurrence: 1
   depth: 15, occurrence: 1
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 316

XXX times a variable address is taken: 292
XXX times a pointer is dereferenced on RHS: 146
breakdown:
   depth: 1, occurrence: 112
   depth: 2, occurrence: 23
   depth: 3, occurrence: 11
XXX times a pointer is dereferenced on LHS: 212
breakdown:
   depth: 1, occurrence: 181
   depth: 2, occurrence: 19
   depth: 3, occurrence: 10
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 30
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 1012

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 476
   level: 2, occurrence: 121
   level: 3, occurrence: 82
   level: 4, occurrence: 33
   level: 5, occurrence: 75
XXX number of pointers point to pointers: 178
XXX number of pointers point to scalars: 127
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 31.6
XXX average alias set size: 1.27

XXX times a non-volatile is read: 1060
XXX times a non-volatile is write: 583
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 6

XXX stmts: 44
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 9
   depth: 2, occurrence: 5
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 15
XXX percentage an existing variable is used: 85
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

