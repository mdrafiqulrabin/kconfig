/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2617704364
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_12 = 1L;
static float g_55 = 0x3.14B812p+91;
static int32_t g_56 = 0x6930509BL;
static int32_t *g_94 = &g_56;
static uint8_t g_115 = 255UL;
static int32_t **g_150 = &g_94;
static float *g_156 = &g_55;
static float * const *g_155 = &g_156;
static const float *g_296 = &g_55;
static const float **g_295 = &g_296;
static const float ** const *g_294 = &g_295;
static const float ** const **g_293 = &g_294;
static uint64_t g_427 = 18446744073709551615UL;
static float ****g_482 = (void*)0;
static float *****g_518 = &g_482;


/* --- FORWARD DECLARATIONS --- */
static const int16_t  func_1(void);
static const uint64_t  func_10(int8_t  p_11);
static const uint16_t  func_17(int32_t  p_18, int32_t  p_19, uint64_t  p_20, int64_t  p_21);
static int32_t  func_24(uint64_t  p_25);
static int32_t  func_26(int16_t  p_27, uint8_t  p_28);
static uint8_t  func_30(const uint32_t  p_31, int8_t  p_32, int16_t  p_33, int32_t  p_34);
static int32_t  func_35(uint64_t  p_36, float  p_37, uint32_t  p_38, int8_t  p_39);
static float  func_44(uint16_t  p_45, uint64_t  p_46, int64_t  p_47);
static uint64_t  func_48(int8_t  p_49, int64_t  p_50, int8_t  p_51);
static int8_t  func_59(float  p_60, uint16_t  p_61);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_56 g_55 g_155 g_156 g_115 g_150 g_94 g_295 g_296 g_293 g_294 g_427 g_518
 * writes: g_55 g_56 g_94 g_294 g_115 g_12 g_427 g_482
 */
static const int16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_4 = 7L;
    int16_t l_9 = 0xFC39L;
    int32_t l_517 = 0xF17BE234L;
    float *****l_519 = &g_482;
    int32_t l_520 = 0xF596106FL;
    l_517 = ((((int16_t)l_4 % (int16_t)((uint16_t)((uint32_t)8UL % (uint32_t)4294967286UL) >> (uint16_t)9)) == (((l_9 >= func_10(g_12)) && ((void*)0 == (*g_293))) && ((void*)0 == (*g_293)))) ^ 1L);
    (*g_150) = &l_517;
    l_520 = (0x8D3CL != (((1L | l_517) | (g_518 != l_519)) != ((*g_150) == &l_517)));
    (**g_155) = 0x9.CC94A3p+43;
    return g_56;
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_56 g_55 g_155 g_156 g_115 g_150 g_94 g_295 g_296 g_293 g_294 g_427
 * writes: g_55 g_56 g_94 g_294 g_115 g_12 g_427 g_482
 */
static const uint64_t  func_10(int8_t  p_11)
{ /* block id: 1 */
    int32_t *l_516 = &g_12;
    (*l_516) = ((int64_t)((uint16_t)func_17(((int8_t)p_11 >> (int8_t)2), func_24(p_11), g_427, p_11) >> (uint16_t)13) / (int64_t)p_11);
    (*g_150) = &g_56;
    (*g_150) = (void*)0;
    return (*l_516);
}


/* ------------------------------------------ */
/* 
 * reads : g_427 g_115 g_56 g_12 g_150 g_156 g_294 g_295 g_296 g_55 g_293 g_155 g_94
 * writes: g_12 g_427 g_94 g_55 g_482
 */
static const uint16_t  func_17(int32_t  p_18, int32_t  p_19, uint64_t  p_20, int64_t  p_21)
{ /* block id: 165 */
    int64_t l_432 = 0xE0713F5139A76395LL;
    uint8_t l_447 = 0x15L;
    int32_t *l_448 = &g_12;
    float **l_481 = &g_156;
    float ***l_480 = &l_481;
    float ****l_479 = &l_480;
    (*l_448) = (((int8_t)((uint16_t)((0x32CC213E5AC41574LL <= 1L) || l_432) - (uint16_t)(((((((int16_t)((int16_t)5L << (int16_t)14) >> (int16_t)12) <= g_427) == ((uint64_t)((int16_t)((((int64_t)(((((uint16_t)((((int8_t)(0x0EL != (((l_432 | (g_115 & (g_427 ^ g_56))) <= p_20) < 246UL)) >> (int8_t)5) && 4294967295UL) != g_12) >> (uint16_t)g_12) >= l_432) && g_115) >= l_447) / (int64_t)l_432) & l_432) | 0L) >> (int16_t)2) / (uint64_t)18446744073709551615UL)) <= g_12) < l_447) < 65527UL)) % (int8_t)p_19) & g_427);
    if (((*l_448) < (((uint16_t)p_19 << (uint16_t)(*l_448)) && g_56)))
    { /* block id: 167 */
        int32_t **l_466 = &l_448;
        float **l_471 = &g_156;
        float ***l_470 = &l_471;
        float ****l_469 = &l_470;
        float *****l_468 = &l_469;
        int32_t *l_478 = &g_56;
        for (g_427 = 0; (g_427 <= 14); g_427 += 1)
        { /* block id: 170 */
            float *****l_465 = (void*)0;
            int32_t l_467 = (-6L);
            int32_t **l_474 = &g_94;
            for (l_447 = 9; (l_447 == 51); l_447 += 1)
            { /* block id: 173 */
                const float *****l_457 = (void*)0;
                int32_t l_462 = 0x5952602CL;
                if ((((uint8_t)(((void*)0 == l_457) > 0UL) << (uint8_t)(((((uint8_t)p_20 << (uint8_t)6) || ((-8L) < (0xD2DAACF49DBCD600LL < l_462))) < ((int16_t)0x137FL << (int16_t)(&g_293 == l_465))) >= (*l_448))) && p_19))
                { /* block id: 174 */
                    return g_115;
                }
                else
                { /* block id: 176 */
                    if (p_18)
                    { /* block id: 177 */
                        l_466 = &g_94;
                        if (l_467)
                            continue;
                        l_465 = l_468;
                        (*g_150) = &g_12;
                    }
                    else
                    { /* block id: 182 */
                        p_19 = ((int32_t)(l_474 != (void*)0) % (int32_t)p_21);
                    }
                    if ((!((int64_t)g_12 % (int64_t)p_20)))
                    { /* block id: 185 */
                        (*l_468) = (*l_468);
                    }
                    else
                    { /* block id: 187 */
                        (*l_474) = l_478;
                        (***l_470) = (-0x4.4p+1);
                    }
                }
                (*l_466) = &p_19;
            }
            g_482 = l_479;
        }
        return g_427;
    }
    else
    { /* block id: 197 */
        (*g_150) = l_448;
        if ((g_115 > ((((((-1L) || p_21) | (((uint16_t)(~(p_20 == ((-4L) ^ 0x2151L))) >> (uint16_t)6) || (((*l_448) > ((*l_448) > g_115)) | 0x2679L))) | 0x5BL) || 0UL) || g_56)))
        { /* block id: 199 */
            int32_t **l_496 = &g_94;
            (*g_156) = ((float)((((float)(((***g_294) == (****g_293)) < ((float)((float)(-0x6.Fp-1) / (float)((float)(l_496 == &g_94) / (float)p_19)) + (float)((((float)0x8.22CEAEp+47 + (float)(((float)p_18 / (float)((float)((*l_479) == (void*)0) / (float)(***g_294))) == 0x0.Cp+1)) <= (**g_155)) <= 0x3.1D5A46p-11))) / (float)(*l_448)) == (**l_496)) != (**l_496)) / (float)p_18);
        }
        else
        { /* block id: 201 */
            for (l_432 = 0; (l_432 > 3); l_432 += 9)
            { /* block id: 204 */
                float **l_505 = &g_156;
                p_19 = p_20;
                (**l_479) = l_505;
            }
            (*g_150) = (*g_150);
            (**g_155) = (-0x7.Dp-1);
        }
        (**g_150) = 0L;
    }
    (**g_150) = ((uint32_t)(((uint64_t)((g_12 & ((((((uint64_t)((**l_480) == (void*)0) - (uint64_t)g_12) || (((int8_t)((int64_t)(*l_448) + (int64_t)(&g_94 != &g_94)) % (int8_t)0xDEL) ^ ((void*)0 != &p_19))) > 0x2393L) | (*l_448)) > 5UL)) == g_12) - (uint64_t)(-2L)) <= 1L) - (uint32_t)(*g_94));
    (*g_150) = &p_19;
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_56 g_55 g_155 g_156 g_115 g_150 g_94 g_295 g_296 g_293 g_294
 * writes: g_55 g_56 g_94 g_294 g_115 g_12
 */
static int32_t  func_24(uint64_t  p_25)
{ /* block id: 2 */
    uint8_t l_29 = 0UL;
    int8_t l_52 = (-1L);
    int32_t l_426 = 0x67DE76BAL;
    l_426 = (func_26(l_29, func_30(p_25, g_12, g_12, func_35(p_25, (((((float)((!(!l_29)) != func_44(p_25, func_48(l_29, p_25, l_52), g_115)) - (float)p_25) == 0x5.A07113p-42) == l_29) < p_25), p_25, l_52))) ^ l_52);
    (*g_150) = &l_426;
    return p_25;
}


/* ------------------------------------------ */
/* 
 * reads : g_115 g_12 g_56 g_150 g_156 g_94
 * writes: g_115 g_94 g_55 g_56 g_12
 */
static int32_t  func_26(int16_t  p_27, uint8_t  p_28)
{ /* block id: 125 */
    int64_t l_389 = 1L;
    int32_t *l_416 = &g_56;
    float * const **l_422 = &g_155;
    float * const ***l_421 = &l_422;
    float * const ****l_420 = &l_421;
    for (g_115 = (-21); (g_115 >= 60); g_115 += 1)
    { /* block id: 128 */
        int64_t l_397 = (-1L);
        uint64_t l_402 = 0x9BE1A63A71FD06F5LL;
        int32_t *l_403 = &g_56;
        if (l_389)
            break;
        if ((((int32_t)((int16_t)g_12 >> (int16_t)(((p_28 ^ (-(uint64_t)((p_28 >= 0xBB62L) == (l_397 == ((uint64_t)((18446744073709551615UL < ((((((int8_t)((0x9568L > (0L || (4294967295UL ^ p_28))) == l_389) << (int8_t)2) ^ g_56) > 0xF38AL) > g_12) >= g_12)) != p_28) + (uint64_t)l_397))))) > 0xA61F3BF5L) < l_397)) % (int32_t)l_402) & 0L))
        { /* block id: 130 */
            int32_t *l_404 = (void*)0;
            (*g_150) = l_403;
            (*g_150) = l_404;
        }
        else
        { /* block id: 133 */
            float **l_409 = &g_156;
            float ***l_408 = &l_409;
            float ****l_407 = &l_408;
            int32_t *l_419 = &g_12;
            if (((uint8_t)(((void*)0 != l_407) && p_28) << (uint8_t)3))
            { /* block id: 134 */
                int32_t *l_410 = &g_12;
                (*g_150) = l_410;
            }
            else
            { /* block id: 136 */
                int32_t *l_417 = &g_56;
                int8_t l_418 = 3L;
                for (p_28 = 0; (p_28 >= 59); p_28 += 1)
                { /* block id: 139 */
                    int32_t l_413 = (-8L);
                    (*g_156) = 0x1.8p+1;
                    (*l_403) = l_413;
                    if ((-(int32_t)(p_27 ^ ((!(l_416 == l_417)) >= (l_418 >= g_115)))))
                    { /* block id: 142 */
                        (*g_150) = l_419;
                        (*g_94) = p_28;
                    }
                    else
                    { /* block id: 145 */
                        (*g_150) = l_417;
                    }
                }
                (*l_417) = (*l_417);
            }
            l_420 = l_420;
        }
    }
    for (p_28 = 0; (p_28 < 12); p_28 += 1)
    { /* block id: 156 */
        int32_t *l_425 = &g_12;
        (*g_150) = l_416;
        (*g_150) = l_425;
        return (*g_94);
    }
    return (*l_416);
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_150 g_293 g_294
 * writes: g_56 g_94 g_294
 */
static uint8_t  func_30(const uint32_t  p_31, int8_t  p_32, int16_t  p_33, int32_t  p_34)
{ /* block id: 117 */
    float * const **l_382 = &g_155;
    float * const ***l_381 = &l_382;
    int32_t l_386 = 1L;
    if ((l_381 == &l_382))
    { /* block id: 118 */
        int32_t *l_385 = &g_56;
        (*l_385) = ((g_12 != 1L) < ((void*)0 == &p_34));
        (*g_150) = &p_34;
    }
    else
    { /* block id: 121 */
        (*g_293) = (*g_293);
    }
    return l_386;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_35(uint64_t  p_36, float  p_37, uint32_t  p_38, int8_t  p_39)
{ /* block id: 114 */
    int32_t *l_380 = (void*)0;
    l_380 = l_380;
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_295 g_296 g_55
 * writes:
 */
static float  func_44(uint16_t  p_45, uint64_t  p_46, int64_t  p_47)
{ /* block id: 111 */
    float **l_378 = (void*)0;
    float ***l_379 = &l_378;
    (*l_379) = l_378;
    return (**g_295);
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_56 g_55 g_155 g_156 g_115 g_150 g_94
 * writes: g_55 g_56 g_94
 */
static uint64_t  func_48(int8_t  p_49, int64_t  p_50, int8_t  p_51)
{ /* block id: 3 */
    float *l_53 = (void*)0;
    float *l_54 = &g_55;
    int32_t l_71 = 8L;
    int64_t l_370 = 1L;
    uint64_t l_371 = 18446744073709551610UL;
    int32_t *l_377 = (void*)0;
    (*l_54) = (-0x3.Ep+1);
    g_56 = p_49;
    if (((int8_t)func_59(((float)(((float)(g_12 != ((float)((float)(-0x1.Dp+1) - (float)(!((l_71 > 0x7.D1CC0Cp-49) <= l_71))) - (float)g_56)) - (float)((((((float)((float)(((((float)(((float)((l_71 != (l_71 == ((float)(!(((float)(l_71 <= p_50) - (float)g_12) > (-0x1.Ep+1))) / (float)g_56))) < p_51) / (float)p_51) < p_50) - (float)l_71) > l_71) > l_71) == l_71) - (float)g_55) / (float)g_12) < 0xF.C102D1p+70) >= p_50) <= 0x0.1p+1) <= g_12)) == 0x3.35309Fp+67) - (float)0xC.24E228p+34), l_71) << (int8_t)p_49))
    { /* block id: 101 */
        int32_t *l_366 = &g_56;
        (*l_366) = (**g_150);
        (*g_150) = (*g_150);
    }
    else
    { /* block id: 104 */
        uint8_t l_369 = 0xEEL;
        int32_t **l_374 = &g_94;
        const float ** const ** const l_375 = (void*)0;
        int32_t l_376 = 0x02C53580L;
        l_71 = 4L;
        l_376 = ((l_369 | l_370) & (l_371 >= (((((uint8_t)((void*)0 == l_374) / (uint8_t)(**l_374)) == (&g_294 == l_375)) != 0x8732CC38L) || 1UL)));
        (*g_150) = &l_71;
        l_377 = (*g_150);
    }
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_56 g_155 g_156 g_115 g_55
 * writes: g_56 g_55 g_94
 */
static int8_t  func_59(float  p_60, uint16_t  p_61)
{ /* block id: 6 */
    int32_t l_87 = 0x68E480B0L;
    int32_t **l_110 = &g_94;
    float **l_158 = &g_156;
    uint64_t l_250 = 1UL;
    uint32_t l_325 = 0x4737F3D3L;
    if (((uint64_t)p_61 - (uint64_t)l_87))
    { /* block id: 7 */
        int32_t *l_88 = &g_56;
        int32_t **l_89 = &l_88;
        (*l_88) = g_12;
        (*l_89) = &g_12;
    }
    else
    { /* block id: 10 */
        int32_t *l_91 = (void*)0;
        int32_t **l_90 = &l_91;
        float *l_92 = &g_55;
        int32_t *l_93 = &g_12;
        (*l_90) = &g_12;
        (*l_90) = &g_56;
        (*l_92) = g_56;
        g_94 = l_93;
    }
    if (((int16_t)((uint16_t)((int8_t)l_87 / (int8_t)0x88L) >> (uint16_t)p_61) >> (int16_t)7))
    { /* block id: 16 */
        int32_t *l_120 = &g_56;
        int8_t l_125 = 0xB3L;
        float * const l_154 = &g_55;
        float * const *l_153 = &l_154;
        int32_t l_162 = 0xCB199FC8L;
        for (l_87 = (-1); (l_87 != (-1)); l_87 += 9)
        { /* block id: 19 */
            const int16_t l_103 = 0x9822L;
            int32_t **l_189 = &l_120;
            const int64_t l_290 = 0L;
        }
        for (l_125 = 0; (l_125 <= 0); l_125 += 1)
        { /* block id: 92 */
            uint32_t l_357 = 0x26EC9F88L;
            (**g_155) = ((void*)0 == &l_154);
            (*l_120) = ((*l_120) < (((g_115 & (((uint8_t)((uint64_t)(((uint8_t)p_61 << (uint8_t)((((int16_t)(l_158 != &l_154) + (int16_t)(g_56 != p_61)) != l_357) >= ((((int8_t)((uint16_t)(((int16_t)(p_61 || p_61) << (int16_t)p_61) | 9L) % (uint16_t)g_12) - (int8_t)1L) > 0xBDL) != p_61))) < (*l_120)) + (uint64_t)l_357) >> (uint8_t)(*l_120)) > (*l_120))) && 0xB503CBCBL) >= 6UL));
        }
    }
    else
    { /* block id: 96 */
        int32_t *l_364 = (void*)0;
        int32_t *l_365 = &l_87;
        (*l_365) = 0xE7733B7CL;
        (**l_158) = (*g_156);
    }
    return g_56;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_12, "g_12", print_hash_value);
    transparent_crc_bytes (&g_55, sizeof(g_55), "g_55", print_hash_value);
    transparent_crc(g_56, "g_56", print_hash_value);
    transparent_crc(g_115, "g_115", print_hash_value);
    transparent_crc(g_427, "g_427", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 90
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 130
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 31, occurrence: 2

XXX total number of pointers: 81

XXX times a variable address is taken: 106
XXX times a pointer is dereferenced on RHS: 84
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 28
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 77
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 260

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 152
   level: 2, occurrence: 66
   level: 3, occurrence: 7
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 48
XXX number of pointers point to scalars: 33
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21
XXX average alias set size: 1.31

XXX times a non-volatile is read: 529
XXX times a non-volatile is write: 196
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 98
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 29
   depth: 2, occurrence: 12
   depth: 3, occurrence: 7
   depth: 4, occurrence: 6
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 18.3
XXX percentage an existing variable is used: 81.7
********************* end of statistics **********************/

