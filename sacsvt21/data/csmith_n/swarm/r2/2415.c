/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1469192238
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 5;
   signed f1 : 6;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 0x8C45CDBE;
static struct S0 g_60 = {1,4};
static int32_t *g_61 = (void*)0;
static int32_t g_64 = 1;
static int32_t g_69 = 0x9BB643C8;
static int32_t *g_68 = &g_69;
static int32_t *g_138 = (void*)0;
static int32_t **g_147 = &g_138;
static int32_t ***g_146 = &g_147;
static int32_t **** volatile g_145 = &g_146;/* VOLATILE GLOBAL g_145 */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_27(void);
static int32_t * func_28(struct S0  p_29, int32_t * p_30, int32_t  p_31, int16_t  p_32, uint32_t  p_33);
static int32_t * func_35(int32_t * p_36, int32_t * p_37, int32_t * p_38);
static int32_t * func_39(int16_t  p_40, int32_t * p_41, uint32_t  p_42, uint32_t  p_43);
static int32_t * func_46(struct S0  p_47, uint16_t  p_48, int32_t * p_49, int32_t * p_50, struct S0  p_51);
static uint16_t  func_52(int32_t * p_53, int32_t  p_54);
static int32_t * func_55(struct S0  p_56, int32_t * p_57, uint32_t  p_58, int32_t * p_59);
static int32_t  func_71(int32_t  p_72, uint16_t  p_73);
static struct S0  func_75(uint16_t  p_76);
static struct S0  func_77(int32_t * p_78, int32_t ** p_79, uint8_t  p_80, int32_t * p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_60 g_61 g_68 g_69 g_64 g_138 g_145 g_146 g_147
 * writes: g_64 g_61 g_69 g_68 g_146 g_138
 */
static struct S0  func_27(void)
{ /* block id: 36 */
    struct S0 l_34 = {3,4};
    int32_t *l_70 = &g_69;
    int32_t l_182 = 0x3884B002;
    uint32_t l_183 = 0xC347C869;
    (*g_147) = func_28(l_34, func_35(func_39((0x3260 > ((uint32_t)l_34.f0 - (uint32_t)g_3)), func_46(l_34, func_52(func_55(g_60, g_61, (g_60.f1 && 0x77DA19AE), g_61), l_34.f0), g_68, l_70, l_34), g_60.f1, g_60.f0), (*g_147), l_70), l_34.f1, g_60.f1, g_3);
    /* statement id: 109 */
    assert (g_61 == &g_64);
    assert (g_68 == &g_64 || g_68 == &g_69);
    assert (g_138 == &g_69);
    //assert (g_146 == dangling || g_146 == &g_147);
    (*g_61) = ((((void*)0 == &l_70) >= (g_60.f0 < (g_3 | ((uint16_t)((*l_70) < ((((int16_t)(((int32_t)(*g_68) / (int32_t)((uint16_t)g_69 * (uint16_t)((g_60.f1 <= (0x1CDE <= 65535U)) != (*l_70)))) > (*l_70)) + (int16_t)l_182) & 0xA080E1D1) >= l_183)) << (uint16_t)(*l_70))))) & g_60.f1);
    return l_34;
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_61 g_68
 * writes: g_64 g_69
 */
static int32_t * func_28(struct S0  p_29, int32_t * p_30, int32_t  p_31, int16_t  p_32, uint32_t  p_33)
{ /* block id: 102 */
    int32_t l_169 = 0xBCE3F75E;
    int32_t *l_173 = &g_69;
    for (p_33 = (-9); (p_33 == 52); p_33 += 6)
    { /* block id: 105 */
        int32_t l_170 = 0xBE801A4E;
        (*g_68) = (((p_31 & ((uint16_t)l_169 + (uint16_t)((((0x13F6 != (p_31 != func_71(l_170, g_64))) != p_29.f0) == ((uint16_t)0xEF0C + (uint16_t)65526U)) | 0x29CD))) == p_29.f0) == 0);
    }
    return l_173;
    /* statement id: 108 */
    //assert (func_28_rv == &g_69);
}


/* ------------------------------------------ */
/* 
 * reads : g_69 g_60.f0 g_61 g_64
 * writes: g_69
 */
static int32_t * func_35(int32_t * p_36, int32_t * p_37, int32_t * p_38)
{ /* block id: 99 */
    uint32_t l_157 = 0xB53E2DD1;
    int32_t *l_164 = &g_64;
    (*p_38) = func_71(l_157, ((((int32_t)((int32_t)l_157 / (int32_t)(*p_38)) + (int32_t)__builtin_clzll(g_60.f0)) <= __builtin_clzl(((int16_t)l_157 << (int16_t)l_157))) | ((void*)0 == l_164)));
    return p_36;
    /* statement id: 101 */
    //assert (func_35_rv == &g_64 || func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_69 g_145 g_146 g_64 g_3 g_68 g_138
 * writes: g_69 g_146 g_64
 */
static int32_t * func_39(int16_t  p_40, int32_t * p_41, uint32_t  p_42, uint32_t  p_43)
{ /* block id: 86 */
    int32_t **l_144 = &g_138;
    int32_t ***l_143 = &l_144;
    if ((*p_41))
    { /* block id: 87 */
        return &g_64;
        /* statement id: 88 */
        //assert (func_39_rv == &g_64);
    }
    else
    { /* block id: 89 */
        uint8_t l_154 = 0x8E;
        for (g_69 = 0; (g_69 != 12); g_69 += 4)
        { /* block id: 92 */
            int32_t l_155 = (-2);
            int32_t l_156 = (-5);
            (*g_145) = l_143;
            /* statement id: 93 */
            assert (g_146 == &l_144);
            l_156 = (((((*g_146) == (*l_143)) && (p_42 | __builtin_clzl((((0x557A && ((g_64 | ((uint16_t)((int32_t)((((int32_t)(p_43 && l_154) - (int32_t)0x7A248570) && __builtin_parity((p_43 != p_43))) & p_40) % (int32_t)l_155) / (uint16_t)g_64)) & p_40)) ^ g_3) < g_64)))) ^ p_43) == p_43);
        }
        /* facts after for loop */
        assert (g_146 == &l_144 || g_146 == &g_147);
    }
    /* facts after branching */
    assert (g_146 == &l_144 || g_146 == &g_147);
    (*g_68) = (*p_41);
    return (*l_144);
    /* statement id: 98 */
    //assert (g_146 == dangling || g_146 == &g_147);
    //assert (func_39_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_69 g_60.f0 g_64 g_61 g_60 g_68 g_3 g_138
 * writes: g_69 g_64 g_68 g_61
 */
static int32_t * func_46(struct S0  p_47, uint16_t  p_48, int32_t * p_49, int32_t * p_50, struct S0  p_51)
{ /* block id: 49 */
    int32_t *l_74 = &g_64;
    int32_t **l_139 = (void*)0;
    int32_t **l_140 = &g_61;
    (*p_50) = func_71((*p_50), (((p_51.f0 >= g_60.f0) < (g_64 ^ (&p_50 != &g_68))) <= (l_74 == l_74)));
    (*l_140) = func_55(func_75(p_47.f0), g_138, p_51.f1, g_138);
    /* statement id: 84 */
    assert (g_68 == &g_64 || g_68 == &g_69);
    return &g_69;
    /* statement id: 85 */
    //assert (func_46_rv == &g_69);
}


/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes: g_61
 */
static uint16_t  func_52(int32_t * p_53, int32_t  p_54)
{ /* block id: 46 */
    int32_t **l_67 = &g_61;
    (*l_67) = p_53;
    /* statement id: 47 */
    assert (g_61 == &g_64);
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_64
 */
static int32_t * func_55(struct S0  p_56, int32_t * p_57, uint32_t  p_58, int32_t * p_59)
{ /* block id: 37 */
    uint32_t l_62 = 0x03B5B0D6;
    int32_t *l_63 = &g_64;
    (*l_63) = l_62;
    for (l_62 = 22; (l_62 < 55); l_62 += 1)
    { /* block id: 41 */
        return &g_64;
        /* statement id: 42 */
        //assert (func_55_rv == &g_64);
    }
    (*l_63) = 0x866B3883;
    return &g_64;
    /* statement id: 45 */
    //assert (func_55_rv == &g_64);
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_64
 * writes:
 */
static int32_t  func_71(int32_t  p_72, uint16_t  p_73)
{ /* block id: 50 */
    return (*g_61);
}


/* ------------------------------------------ */
/* 
 * reads : g_60 g_68 g_69 g_3 g_61 g_64
 * writes: g_64 g_69 g_68 g_61
 */
static struct S0  func_75(uint16_t  p_76)
{ /* block id: 53 */
    int32_t **l_82 = &g_68;
    struct S0 l_83 = {3,-1};
    l_83 = func_77(&g_69, l_82, p_76, func_55(l_83, func_55(g_60, (*l_82), (**l_82), &g_69), p_76, (*l_82)));
    /* statement id: 82 */
    assert (g_68 == &g_64 || g_68 == &g_69);
    return l_83;
}


/* ------------------------------------------ */
/* 
 * reads : g_69 g_68 g_3 g_60.f0 g_61 g_64 g_60
 * writes: g_69 g_68 g_64 g_61
 */
static struct S0  func_77(int32_t * p_78, int32_t ** p_79, uint8_t  p_80, int32_t * p_81)
{ /* block id: 54 */
    uint8_t l_86 = 255U;
    int32_t l_131 = 1;
    struct S0 l_137 = {0,-2};
    if (((int32_t)0xA3C3A871 - (int32_t)l_86))
    { /* block id: 55 */
        int32_t *l_89 = &g_69;
        int16_t l_118 = 0xADB2;
        for (g_69 = 8; (g_69 == 8); g_69 += 1)
        { /* block id: 58 */
            int32_t *l_96 = &g_69;
            struct S0 l_124 = {4,6};
            (*p_79) = l_89;
            /* statement id: 59 */
            assert (g_68 == &g_69);
            if ((*g_68))
                continue;
            if ((65532U | ((((uint16_t)((uint32_t)(&g_69 != (void*)0) - (uint32_t)(((uint32_t)((void*)0 != l_96) - (uint32_t)0x1B63E3B6) <= ((int16_t)p_80 / (int16_t)__builtin_clz((l_86 || (p_80 != (**p_79))))))) * (uint16_t)2U) <= p_80) > 0x2819)))
            { /* block id: 61 */
                int32_t **l_101 = (void*)0;
                (*p_81) = ((((((((int32_t)(0x8BDC > (&g_61 != l_101)) / (int32_t)(-(uint16_t)((uint16_t)(((int16_t)(((((int16_t)((uint16_t)p_80 - (uint16_t)((p_80 != 0x79BC9383) > ((uint32_t)((uint16_t)(+((uint32_t)((*p_79) != l_89) + (uint32_t)__builtin_parityl(g_3))) * (uint16_t)p_80) / (uint32_t)l_118))) + (int16_t)0xD530) < g_60.f0) >= p_80) >= (-7)) >> (int16_t)2) || (*p_78)) >> (uint16_t)0))) == 0xAF9C) < 4294967290U) ^ g_60.f0) < p_80) < (*g_61)) != 0U);
            }
            else
            { /* block id: 63 */
                uint32_t l_123 = 0xE9DA5FDE;
                (*p_79) = func_55(g_60, (*p_79), (((int16_t)((int16_t)l_123 << (int16_t)(func_52(func_55(l_124, &g_69, ((uint16_t)((uint32_t)((0x90C3 > __builtin_ctz(g_69)) & (((int16_t)p_80 % (int16_t)g_60.f1) & l_86)) + (uint32_t)g_3) << (uint16_t)g_64), &g_69), (*l_89)) && (-1))) >> (int16_t)12) >= l_86), &g_69);
                /* statement id: 64 */
                assert (g_68 == &g_64);
                l_131 = (((0xBA6A349B <= (*g_68)) <= (&g_68 != (void*)0)) == 0xBBE02B32);
                for (l_118 = 0; (l_118 >= 20); l_118 += 3)
                { /* block id: 68 */
                    (**p_79) = l_86;
                }
            }
            /* facts after branching */
            assert (g_68 == &g_64 || g_68 == &g_69);
            for (l_131 = 0; (l_131 != (-17)); l_131 -= 1)
            { /* block id: 74 */
                return l_124;
            }
        }
        /* facts after for loop */
        assert (g_68 == &g_64 || g_68 == &g_69);
    }
    else
    { /* block id: 78 */
        struct S0 l_136 = {1,-4};
        return l_136;
    }
    /* facts after branching */
    assert (g_68 == &g_64 || g_68 == &g_69);
    return l_137;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_60.f0, "g_60.f0", print_hash_value);
    transparent_crc(g_60.f1, "g_60.f1", print_hash_value);
    transparent_crc(g_64, "g_64", print_hash_value);
    transparent_crc(g_69, "g_69", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 6
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 6
breakdown:
   indirect level: 0, occurrence: 6
XXX full-bitfields structs in the program: 6
breakdown:
   indirect level: 0, occurrence: 6
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 13
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 20

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 7
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 38

XXX times a variable address is taken: 31
XXX times a pointer is dereferenced on RHS: 25
breakdown:
   depth: 1, occurrence: 23
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 15
breakdown:
   depth: 1, occurrence: 14
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 5
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 64

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 58
   level: 2, occurrence: 8
   level: 3, occurrence: 2
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 11
XXX number of pointers point to scalars: 27
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 28.9
XXX average alias set size: 1.32

XXX times a non-volatile is read: 183
XXX times a non-volatile is write: 39
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 7
XXX percentage of non-volatile access: 99.6

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 42
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 6
   depth: 2, occurrence: 6
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 21.1
XXX percentage an existing variable is used: 78.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

