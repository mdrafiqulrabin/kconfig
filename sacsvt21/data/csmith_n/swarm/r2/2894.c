/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      12571228
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_31(void);
static int16_t  func_43(int32_t  p_44, int64_t  p_45);
static int32_t * func_49(int32_t * p_50, int32_t * p_51, int8_t  p_52, int32_t * p_53);
static int32_t * func_56(int8_t  p_57, int32_t * p_58);
static int32_t ** func_62(uint32_t  p_63, float  p_64);
static int16_t  func_67(int8_t  p_68);
static int32_t  func_69(const uint16_t  p_70, uint32_t  p_71, int32_t  p_72, struct S0  p_73, int32_t * p_74);
static int16_t  func_83(int8_t  p_84, const float  p_85, int32_t ** p_86);
static const int32_t  func_94(const int8_t  p_95, int32_t * p_96, struct S0  p_97, int32_t ** p_98, int64_t  p_99);
static struct S0  func_100(const int32_t ** p_101, struct S0  p_102, int32_t * p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_31(void)
{ /* block id: 36 */
    int64_t l_34 = 0x54C975158018D9DCLL;
    int32_t l_1128 = (-1L);
    const int32_t *l_1130 = (void*)0;
    const int32_t **l_1129 = &l_1130;
    struct S0 l_1131 = {0x9DB2L};
    int32_t l_1133 = 0L;
    int32_t *l_1132 = &l_1133;
    struct S0 *l_1134 = &l_1131;
    float l_1136 = 0x0.8p-1;
    uint32_t l_1137 = 0x8A48C7E8L;
    uint32_t l_1139 = 18446744073709551608UL;
    int32_t *l_1140 = &l_1133;
    int32_t l_1141 = (-1L);
    int8_t l_1142 = 9L;
    float l_1143 = (-0x1.2p+1);
    int64_t l_1144 = (-1L);
    l_1128 = ((int64_t)l_34 - (int64_t)((uint32_t)((((uint16_t)((int16_t)l_34 - (int16_t)((int16_t)(-1L) - (int16_t)((0x86F25DB2L > (func_43(l_34, l_34) != l_34)) > (l_34 < l_34)))) / (uint16_t)0x2C00L) < l_34) && l_34) % (uint32_t)l_34));
    (*l_1134) = l_1131;
    (*l_1129) = func_56((func_69(((!((*l_1132) & ((l_1137 == ((*l_1132) > ((*l_1132) || ((-(int64_t)(*l_1132)) != (l_1139 <= func_94((*l_1132), l_1140, (*l_1134), &l_1132, (*l_1132))))))) | (*l_1140)))) ^ l_1141), l_1142, (*l_1132), (*l_1134), &l_1133) ^ (*l_1140)), &l_1133);
    return l_1144;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_43(int32_t  p_44, int64_t  p_45)
{ /* block id: 37 */
    uint32_t l_59 = 8UL;
    int32_t l_61 = (-2L);
    int32_t *l_60 = &l_61;
    int32_t l_933 = 0xFE1B1F10L;
    int32_t *l_932 = &l_933;
    const int32_t *l_1013 = &l_933;
    const int32_t **l_1012 = &l_1013;
    float **l_1075 = (void*)0;
    float ***l_1074 = &l_1075;
    float ****l_1073 = &l_1074;
    int32_t *l_1109 = &l_61;
    for (p_44 = 0; (p_44 <= 27); ++p_44)
    { /* block id: 40 */
        struct S0 l_48 = {0x237FL};
        int32_t l_55 = 2L;
        int32_t *l_54 = &l_55;
        int32_t *l_975 = (void*)0;
        int32_t *l_978 = &l_61;
        int32_t ***l_1025 = (void*)0;
        int32_t ****l_1024 = &l_1025;
        struct S0 *l_1042 = &l_48;
        struct S0 **l_1041 = &l_1042;
        struct S0 **l_1043 = &l_1042;
        int16_t l_1102 = 1L;
        const int32_t **l_1106 = &l_1013;
        struct S0 l_1108 = {65535UL};
        const float ****l_1116 = (void*)0;
    }
    (*l_1012) = (void*)0;
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_49(int32_t * p_50, int32_t * p_51, int8_t  p_52, int32_t * p_53)
{ /* block id: 661 */
    const float ***l_934 = (void*)0;
    const float ****l_935 = &l_934;
    int32_t *l_936 = (void*)0;
    int32_t **l_937 = &l_936;
    const int32_t l_946 = (-1L);
    const int32_t **l_947 = (void*)0;
    struct S0 l_948 = {65526UL};
    struct S0 l_950 = {65535UL};
    const int32_t *l_957 = (void*)0;
    const int32_t **l_956 = &l_957;
    (*l_935) = l_934;
    (*l_937) = l_936;
    if (((uint16_t)9UL << (uint16_t)p_52))
    { /* block id: 664 */
        int32_t l_943 = 3L;
        int32_t *l_942 = &l_943;
        int32_t **l_949 = (void*)0;
        float *l_951 = (void*)0;
        float l_953 = 0x9.5081BEp-10;
        float *l_952 = &l_953;
        l_942 = func_56(((int16_t)0x9D8AL >> (int16_t)10), func_56(p_52, l_942));
        (*l_952) = ((float)(__builtin_ctz((4294967295UL > (__builtin_ffsl((0UL && (p_52 <= 4UL))) && func_69(l_946, ((*l_942) ^ 0xBD939450L), p_52, l_950, p_51)))) < (*l_942)) + (float)p_52);
    }
    else
    { /* block id: 667 */
        struct S0 l_958 = {1UL};
        for (l_950.f0 = 0; (l_950.f0 < 19); ++l_950.f0)
        { /* block id: 670 */
            struct S0 *l_959 = &l_958;
            (*l_937) = p_51;
            (*l_959) = l_958;
            if ((*p_53))
                break;
        }
    }
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_56(int8_t  p_57, int32_t * p_58)
{ /* block id: 44 */
    int32_t l_907 = 0x35BFF7BFL;
    int32_t *l_906 = &l_907;
    int32_t **l_905 = &l_906;
    int32_t ***l_904 = &l_905;
    struct S0 l_908 = {0xA2F2L};
    struct S0 *l_909 = &l_908;
    int64_t l_929 = 0x7083CBA3BD125AABLL;
    (*l_904) = func_62(p_57, p_57);
    (*l_909) = l_908;
    for (l_908.f0 = 0; (l_908.f0 <= 16); l_908.f0 += 5)
    { /* block id: 652 */
        int8_t l_925 = 0xACL;
        int64_t l_928 = 1L;
        float l_931 = 0xE.7359D6p+34;
        float *l_930 = &l_931;
        for (p_57 = 0; (p_57 == (-13)); p_57 -= 5)
        { /* block id: 655 */
            (*p_58) = (*p_58);
        }
        (*l_930) = ((float)((!0x0.9p+1) != __builtin_parity(((0x44666EBBL < ((int16_t)(((int16_t)((((uint16_t)((int16_t)(__builtin_parity(l_925) && ((int64_t)0xEDA8E92D2D958826LL - (int64_t)l_928)) >> (int16_t)14) + (uint16_t)l_929) & 0x8662L) == __builtin_popcountll(p_57)) >> (int16_t)p_57) != (*l_906)) - (int16_t)p_57)) > p_57))) * (float)(-0x6.3p+1));
    }
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_62(uint32_t  p_63, float  p_64)
{ /* block id: 45 */
    const uint32_t l_75 = 0UL;
    int16_t l_78 = 1L;
    int32_t l_89 = 0xE63B6910L;
    int32_t *l_88 = &l_89;
    int32_t **l_87 = &l_88;
    const uint16_t l_90 = 0xCE61L;
    struct S0 l_485 = {0x4836L};
    int32_t *l_486 = &l_89;
    float **l_505 = (void*)0;
    const int32_t *l_510 = &l_89;
    const int32_t **l_509 = &l_510;
    int32_t **l_527 = &l_88;
    const struct S0 *l_564 = &l_485;
    const struct S0 **l_563 = &l_564;
    const struct S0 ***l_562 = &l_563;
    int32_t **l_585 = (void*)0;
    int32_t ***l_628 = (void*)0;
    int32_t ****l_627 = &l_628;
    const float l_659 = 0xC.CCB4F9p-90;
    const float *l_658 = &l_659;
    const float **l_657 = &l_658;
    const float ***l_656 = &l_657;
    const float ****l_655 = &l_656;
    int32_t *l_674 = &l_89;
    uint16_t l_706 = 65528UL;
    const uint32_t l_759 = 0x266CC68DL;
    uint32_t l_760 = 0x22950938L;
    int32_t **l_791 = &l_88;
    uint32_t l_807 = 0x00B4D399L;
    int32_t **l_853 = &l_674;
    int32_t **l_857 = &l_486;
    int32_t **l_858 = &l_674;
    float l_894 = 0x1.8p-1;
    int32_t **l_901 = &l_88;
    int32_t **l_902 = &l_88;
    int32_t **l_903 = (void*)0;
    if (__builtin_ctzl(((int16_t)func_67((func_69(l_75, l_75, ((uint32_t)(l_78 >= ((int64_t)(4L || ((uint16_t)l_75 * (uint16_t)func_83(((void*)0 != l_87), l_90, &l_88))) - (int64_t)p_63)) / (uint32_t)0x1F5FFA15L), l_485, l_486) != 4294967291UL)) % (int16_t)(*l_486))))
    { /* block id: 369 */
        int32_t *l_504 = &l_89;
        float ***l_506 = &l_505;
        struct S0 l_514 = {0x5E6BL};
        int32_t **l_528 = (void*)0;
        struct S0 **l_566 = (void*)0;
        struct S0 ***l_565 = &l_566;
        for (l_78 = (-16); (l_78 > (-20)); l_78 -= 1)
        { /* block id: 372 */
            int32_t *l_503 = &l_89;
            l_504 = l_503;
        }
        (*l_506) = l_505;
        for (l_485.f0 = 0; (l_485.f0 != 24); l_485.f0 += 2)
        { /* block id: 378 */
            struct S0 l_512 = {9UL};
            struct S0 *l_511 = &l_512;
            const int32_t **l_513 = &l_510;
            int32_t **l_522 = &l_88;
            float ****l_536 = &l_506;
            float *****l_535 = &l_536;
            struct S0 **l_540 = &l_511;
            struct S0 ***l_539 = &l_540;
            (*l_511) = func_100(l_509, l_485, (*l_87));
            (*l_511) = l_514;
            for (l_514.f0 = 0; (l_514.f0 < 46); l_514.f0 += 1)
            { /* block id: 383 */
                int32_t *l_520 = &l_89;
                (*l_513) = l_504;
                if ((*l_504))
                { /* block id: 385 */
                    for (l_78 = (-5); (l_78 == 27); l_78 += 4)
                    { /* block id: 388 */
                        int32_t *l_519 = &l_89;
                        (*l_87) = l_519;
                    }
                }
                else
                { /* block id: 391 */
                    (*l_513) = l_520;
                }
                if ((*l_520))
                    break;
                if ((*l_504))
                { /* block id: 395 */
                    int8_t l_521 = 0xA9L;
                    int32_t **l_523 = &l_486;
                    int32_t **l_526 = &l_486;
                    (*l_509) = (void*)0;
                    if (__builtin_popcountll(l_521))
                    { /* block id: 397 */
                        int32_t **l_524 = &l_504;
                        int32_t **l_525 = &l_504;
                        return l_528;
                    }
                    else
                    { /* block id: 399 */
                        uint16_t l_537 = 0xC02FL;
                        int32_t *l_538 = &l_89;
                        (*l_88) = (!(((int16_t)p_63 % (int16_t)((uint16_t)__builtin_ffs(p_63) - (uint16_t)((+__builtin_parityll((*l_486))) > ((void*)0 != l_535)))) > l_537));
                        (*l_526) = l_538;
                    }
                }
                else
                { /* block id: 403 */
                    struct S0 ****l_541 = &l_539;
                    (*l_541) = l_539;
                }
            }
            (*l_509) = (*l_527);
        }
        if (__builtin_ffsll(p_63))
        { /* block id: 409 */
            uint16_t l_544 = 65529UL;
            uint16_t l_551 = 1UL;
            struct S0 *l_569 = &l_514;
            for (l_485.f0 = 25; (l_485.f0 > 45); l_485.f0 += 3)
            { /* block id: 412 */
                uint16_t l_557 = 0x970DL;
                struct S0 *l_560 = &l_514;
                struct S0 **l_559 = &l_560;
                const int32_t **l_572 = &l_510;
                float ***l_582 = &l_505;
                if (l_544)
                    break;
                for (l_89 = 0; (l_89 <= (-5)); l_89 -= 7)
                { /* block id: 416 */
                    for (p_63 = (-5); (p_63 < 12); ++p_63)
                    { /* block id: 419 */
                        uint32_t l_556 = 0UL;
                        struct S0 *l_558 = &l_514;
                        struct S0 ***l_561 = &l_559;
                        p_64 = ((float)0x7.52574Ap-22 + (float)(__builtin_popcount(l_551) > ((float)(*l_504) * (float)((float)(0xA.93790Dp-75 > __builtin_parityl((0xA060F06785279585LL != ((l_556 ^ (p_63 && p_63)) | 0x54F2F56DB81EF6E2LL)))) + (float)l_557))));
                        (*l_558) = l_485;
                        (*l_561) = l_559;
                    }
                    if ((((l_562 == l_565) && (p_63 > 4294967289UL)) && l_557))
                    { /* block id: 424 */
                        int32_t **l_567 = (void*)0;
                        return l_567;
                    }
                    else
                    { /* block id: 426 */
                        int32_t l_568 = (-2L);
                        (**l_559) = (*l_560);
                        if (l_568)
                            break;
                        (**l_562) = l_569;
                    }
                }
                for (l_551 = 0; (l_551 <= 22); l_551 += 1)
                { /* block id: 434 */
                    int32_t *l_573 = &l_89;
                }
            }
            return l_585;
        }
        else
        { /* block id: 440 */
            const int32_t l_600 = 0x7B1F3AF0L;
            struct S0 l_612 = {1UL};
            struct S0 l_635 = {65535UL};
            int32_t *l_637 = &l_89;
            if (((uint16_t)(&l_565 == &l_562) << (uint16_t)(l_506 == (void*)0)))
            { /* block id: 441 */
                float ****l_602 = &l_506;
                float *****l_601 = &l_602;
                int32_t l_604 = 0x6295AF4FL;
                for (l_514.f0 = 4; (l_514.f0 == 43); l_514.f0 += 4)
                { /* block id: 444 */
                    struct S0 l_590 = {2UL};
                    struct S0 *l_591 = &l_485;
                    (*l_591) = l_590;
                    (*l_527) = (*l_87);
                }
                (**l_87) = p_63;
                (*l_486) = ((int16_t)(((p_63 >= 1UL) > (((uint16_t)((uint64_t)(p_63 > ((int16_t)l_600 * (int16_t)((void*)0 != l_601))) + (uint64_t)((~(l_604 | (((uint16_t)((__builtin_bswap64(p_63) && 1L) ^ p_63) - (uint16_t)0x44A3L) & l_600))) >= (-10L))) - (uint16_t)0x87B8L) == 0xF78BC298L)) <= (*l_486)) >> (int16_t)0);
                for (p_63 = 0; (p_63 < 34); ++p_63)
                { /* block id: 452 */
                    struct S0 l_614 = {8UL};
                    for (l_78 = (-27); (l_78 >= (-24)); l_78 += 1)
                    { /* block id: 455 */
                        const int32_t **l_611 = (void*)0;
                        int32_t *l_613 = (void*)0;
                        struct S0 *l_615 = &l_485;
                        (*l_615) = l_614;
                        if (p_63)
                            break;
                    }
                    for (l_514.f0 = 0; (l_514.f0 == 36); l_514.f0 += 1)
                    { /* block id: 461 */
                        struct S0 *l_618 = (void*)0;
                        struct S0 l_619 = {0x24F5L};
                        l_619 = l_614;
                    }
                    for (l_604 = 0; (l_604 == 20); l_604++)
                    { /* block id: 466 */
                        struct S0 l_622 = {0x5CB4L};
                        (*l_88) = 0xC7E64A29L;
                        l_622 = (***l_562);
                    }
                }
            }
            else
            { /* block id: 471 */
                const int32_t **l_632 = &l_510;
                if (((int32_t)((uint16_t)p_63 >> (uint16_t)2) / (int32_t)p_63))
                { /* block id: 472 */
                    int32_t *****l_629 = &l_627;
                    struct S0 l_633 = {0xE61AL};
                    (*l_509) = (*l_509);
                    (*l_629) = l_627;
                    for (l_612.f0 = 16; (l_612.f0 <= 30); l_612.f0 += 1)
                    { /* block id: 477 */
                        int32_t *l_634 = &l_89;
                        struct S0 *l_636 = &l_635;
                        l_635 = func_100(l_632, l_633, l_634);
                        (*l_636) = l_635;
                        (*l_632) = l_637;
                        if ((*l_637))
                            continue;
                    }
                }
                else
                { /* block id: 483 */
                    int32_t *l_638 = &l_89;
                    l_637 = l_637;
                    (*l_527) = l_638;
                }
                for (l_485.f0 = (-19); (l_485.f0 <= 20); ++l_485.f0)
                { /* block id: 489 */
                    uint16_t l_643 = 0x3ABDL;
                    float l_645 = 0x1.600163p+23;
                    float *l_644 = &l_645;
                    (*l_644) = ((float)(**l_632) * (float)func_83(l_643, (*l_637), &l_504));
                    (*l_644) = (*l_637);
                    (*l_644) = ((float)p_63 * (float)((float)(((**l_632) >= (-(float)((**l_87) <= (p_64 == 0x1.4p-1)))) != (((float)((float)(*l_504) * (float)(*l_486)) / (float)p_63) > 0x9.Ap-1)) / (float)p_64));
                }
                (**l_87) = p_63;
                (*l_632) = l_637;
            }
            (*l_509) = (*l_509);
        }
    }
    else
    { /* block id: 499 */
        int32_t *l_660 = &l_89;
        struct S0 *l_717 = &l_485;
        struct S0 **l_716 = &l_717;
        struct S0 ***l_715 = &l_716;
        const int32_t **l_732 = &l_510;
        int32_t *l_734 = &l_89;
        int32_t l_808 = 0x2E8FB2FCL;
        int32_t **l_819 = &l_674;
        int32_t **l_820 = &l_674;
        const float ***l_847 = (void*)0;
        if (func_67(((void*)0 != l_655)))
        { /* block id: 500 */
            const int16_t l_663 = 1L;
            int32_t **l_679 = (void*)0;
            struct S0 *l_680 = &l_485;
            (*l_509) = l_660;
            (*l_660) = ((float)l_663 * (float)(**l_509));
            for (l_485.f0 = 0; (l_485.f0 >= 53); ++l_485.f0)
            { /* block id: 505 */
                int64_t l_670 = 0x0315900BA01E0062LL;
                float ***l_671 = &l_505;
                int32_t *l_676 = &l_89;
            }
            (*l_680) = func_100(&l_510, (***l_562), l_660);
        }
        else
        { /* block id: 529 */
            uint16_t l_681 = 65535UL;
            int32_t **l_686 = (void*)0;
            const float ***l_707 = &l_657;
            float l_712 = (-0x7.8p-1);
            float *l_711 = &l_712;
            if (l_681)
            { /* block id: 530 */
                struct S0 l_682 = {0xDA16L};
                struct S0 *l_683 = &l_682;
                (*l_509) = l_660;
                (**l_87) = 0x10701CF6L;
                (*l_683) = l_682;
                (*l_683) = (***l_562);
            }
            else
            { /* block id: 535 */
                int32_t *l_684 = &l_89;
                struct S0 l_685 = {0xE9AFL};
                (**l_87) = func_94((**l_509), l_684, l_685, l_686, (l_684 != l_684));
                for (l_485.f0 = 0; (l_485.f0 >= 33); ++l_485.f0)
                { /* block id: 539 */
                    struct S0 *l_689 = &l_685;
                    const int32_t **l_692 = (void*)0;
                    (*l_689) = (***l_562);
                    if ((*l_684))
                        break;
                    for (p_63 = (-30); (p_63 >= 9); p_63 += 1)
                    { /* block id: 544 */
                        struct S0 l_693 = {7UL};
                        (*l_689) = l_693;
                    }
                }
                (*l_486) = ((int16_t)(((p_63 <= 4294967295UL) < ((uint16_t)l_681 * (uint16_t)(((((p_63 && ((int16_t)4L + (int16_t)p_63)) || (((*l_660) || ((int32_t)(((uint16_t)(((p_63 | ((*l_627) != &l_686)) > 5L) < (*l_684)) << (uint16_t)11) == 0x8A470E8DL) / (int32_t)p_63)) && 18446744073709551613UL)) && p_63) && (-1L)) == (**l_87)))) ^ (-7L)) % (int16_t)p_63);
            }
            for (p_63 = 17; (p_63 >= 12); p_63 -= 1)
            { /* block id: 552 */
                (*l_509) = l_660;
                if (l_706)
                    break;
                return l_686;
            }
            l_707 = (*l_655);
            (*l_711) = ((float)__builtin_ctzl(p_63) + (float)((!(*l_660)) < p_64));
        }
        for (l_89 = 0; (l_89 == 29); l_89 += 6)
        { /* block id: 562 */
            struct S0 ****l_718 = &l_715;
            (*l_718) = l_715;
        }
        for (l_706 = 0; (l_706 >= 29); l_706 += 6)
        { /* block id: 567 */
            float l_730 = 0x1.9p+1;
            const int32_t l_731 = 4L;
            const float *****l_770 = &l_655;
            int16_t l_781 = 0xEF4DL;
            struct S0 l_782 = {65527UL};
            int32_t **l_789 = &l_734;
            const struct S0 ****l_813 = &l_562;
            if (p_63)
                break;
            if (((((uint16_t)((*l_88) & (*l_88)) >> (uint16_t)6) == ((uint16_t)(!((int32_t)(*l_660) % (int32_t)0x33825F88L)) * (uint16_t)((p_63 < ((int16_t)p_63 << (int16_t)5)) <= l_731))) | 0UL))
            { /* block id: 569 */
                struct S0 l_733 = {0x0094L};
                float ***l_776 = &l_505;
                int32_t **l_788 = &l_88;
                int32_t **l_790 = &l_674;
                int32_t **l_792 = (void*)0;
                (**l_716) = l_733;
                for (l_89 = 0; (l_89 == 6); l_89 += 2)
                { /* block id: 573 */
                    int32_t l_737 = (-9L);
                    float ***l_739 = (void*)0;
                    float ****l_738 = &l_739;
                    int32_t **l_787 = &l_486;
                    if (l_737)
                    { /* block id: 574 */
                        float *****l_740 = &l_738;
                        int32_t *l_741 = &l_737;
                        (*l_740) = l_738;
                        l_737 = (-8L);
                        (*l_732) = l_741;
                    }
                    else
                    { /* block id: 578 */
                        int64_t l_761 = 0xF254E215AE740152LL;
                        l_761 = ((float)((+((l_731 <= func_83((!((uint32_t)(*l_88) % (uint32_t)p_63)), ((float)((*l_734) == ((float)((float)(-(float)((((float)(((((float)l_759 + (float)p_63) >= (-0x1.Fp+1)) != p_63) != (**l_527)) + (float)(*l_660)) <= l_760) >= p_64)) - (float)p_63) / (float)(-0x1.Cp+1))) - (float)p_64), &l_660)) >= 0x3.039C68p-11)) < p_63) / (float)p_64);
                        if (p_63)
                            break;
                    }
                    if (((uint64_t)0x4668D86F083AFA5BLL - (uint64_t)((uint16_t)(__builtin_bswap32((((int16_t)p_63 >> (int16_t)3) && 0x97D0669EL)) != ((((((p_63 ^ ((&l_655 != l_770) == ((int64_t)l_733.f0 % (int64_t)((int16_t)p_63 >> (int16_t)p_63)))) == 65534UL) >= 0UL) != l_731) || l_731) | p_63)) - (uint16_t)(**l_87))))
                    { /* block id: 582 */
                        int32_t *l_775 = &l_737;
                        (*l_775) = __builtin_ffsll(p_63);
                        if (l_731)
                            break;
                    }
                    else
                    { /* block id: 585 */
                        int32_t *l_783 = &l_737;
                        struct S0 l_786 = {9UL};
                        (*l_738) = l_776;
                        l_737 = (((uint64_t)((int16_t)(*l_660) * (int16_t)func_94((func_69(l_731, l_781, p_63, l_782, l_783) <= (((int16_t)(l_737 & (*l_783)) << (int16_t)p_63) || p_63)), (*l_87), l_786, &l_783, l_733.f0)) - (uint64_t)3L) & (*l_660));
                        return l_792;
                    }
                    l_807 = ((float)((float)((&l_733 == &l_782) >= (((((float)(((**l_789) > (p_63 > 0x1.0p-1)) == (((float)p_64 + (float)p_63) < (**l_789))) + (float)((float)((float)((float)p_63 * (float)(*l_660)) + (float)0x7.3p+1) * (float)0x5.E99CF5p-59)) > p_63) < 0x8.E9D4CEp-34) <= p_64)) - (float)(**l_787)) - (float)0xD.6B5629p+48);
                    l_808 = (p_63 == (*l_734));
                }
            }
            else
            { /* block id: 593 */
                int32_t **l_818 = &l_734;
                int32_t **l_821 = &l_88;
                int32_t **l_822 = &l_674;
                int32_t **l_824 = (void*)0;
                for (l_760 = 10; (l_760 == 50); ++l_760)
                { /* block id: 596 */
                    int32_t *l_816 = &l_808;
                    int32_t **l_823 = &l_486;
                    struct S0 l_825 = {65535UL};
                    float ***l_838 = &l_505;
                    float ****l_837 = &l_838;
                    if (((uint16_t)65535UL * (uint16_t)__builtin_ctz((**l_789))))
                    { /* block id: 597 */
                        struct S0 ****l_815 = &l_715;
                        struct S0 *****l_814 = &l_815;
                        int32_t **l_817 = &l_660;
                        (*l_87) = (void*)0;
                        (*l_814) = l_813;
                        (*l_789) = l_816;
                        return l_824;
                    }
                    else
                    { /* block id: 602 */
                        struct S0 l_826 = {0x06B7L};
                        int32_t l_836 = 0xD878B441L;
                        l_826 = l_825;
                        l_836 = ((uint32_t)(**l_822) / (uint32_t)((int32_t)(**l_789) % (int32_t)((p_63 == (~((uint32_t)p_63 + (uint32_t)func_67(p_63)))) || ((((int16_t)(**l_789) << (int16_t)(0x2D8DC2E478CD3E27LL ^ ((**l_823) == 0x0A39L))) < (**l_823)) != p_63))));
                        (***l_813) = (*l_563);
                        l_837 = l_837;
                    }
                    (*l_734) = ((float)(l_824 == &l_816) - (float)((*l_88) == p_63));
                    (*l_823) = (*l_823);
                }
            }
        }
        (*l_486) = ((uint64_t)((int16_t)(&l_656 == &l_656) >> (int16_t)__builtin_clzll((((*l_660) == ((int32_t)1L + (int32_t)0xEBD2781DL)) > (l_847 != (*l_655))))) / (uint64_t)__builtin_ffs(p_63));
    }
    if (((uint32_t)p_63 % (uint32_t)(*l_674)))
    { /* block id: 615 */
        int32_t l_850 = (-1L);
        int32_t **l_852 = &l_88;
        int32_t **l_854 = &l_88;
        int32_t **l_855 = &l_486;
        int32_t **l_859 = &l_674;
        struct S0 l_863 = {65528UL};
        uint64_t l_868 = 0xA03BE042DE0D48E5LL;
        const int32_t **l_878 = &l_510;
        int32_t ****l_890 = (void*)0;
        struct S0 *l_898 = &l_485;
        (*l_674) = l_850;
        if (__builtin_popcountl(p_63))
        { /* block id: 617 */
            int32_t **l_851 = &l_674;
            int32_t **l_856 = &l_486;
            int32_t **l_860 = (void*)0;
            (*l_527) = &l_850;
            return l_860;
        }
        else
        { /* block id: 620 */
            float l_865 = 0xC.7025C6p+95;
            float *l_864 = &l_865;
            int32_t l_880 = 0x62805EB4L;
            int32_t **l_883 = &l_486;
            struct S0 *l_889 = &l_485;
            int64_t l_895 = 0L;
            (*l_864) = ((float)0x1.Fp+1 / (float)(func_94((**l_854), (*l_855), l_863, l_855, (9UL ^ __builtin_popcount(p_63))) > 0x0.Ep+1));
            for (l_78 = 0; (l_78 >= 26); ++l_78)
            { /* block id: 624 */
                int16_t l_871 = 0xB6EFL;
                struct S0 l_879 = {0x2739L};
                int32_t ****l_891 = &l_628;
                const float *****l_897 = (void*)0;
                (**l_859) = ((l_868 <= (((int32_t)0x7582BBE8L % (int32_t)l_871) || ((int16_t)((uint64_t)0x7D3E775A522300FCLL + (uint64_t)(~(func_69((+p_63), p_63, p_63, l_879, (*l_855)) && l_880))) - (int16_t)(*l_674)))) == l_871);
                for (l_760 = (-21); (l_760 == 4); ++l_760)
                { /* block id: 628 */
                    int32_t **l_884 = (void*)0;
                    return l_884;
                }
                for (l_871 = 0; (l_871 <= (-19)); l_871 -= 6)
                { /* block id: 633 */
                    const uint64_t l_896 = 18446744073709551615UL;
                    (**l_859) = ((p_63 < ((float)(((l_889 == (**l_562)) >= ((p_63 > (l_890 == l_891)) <= p_64)) > (((float)l_894 / (float)(0x2.9A9D98p+73 >= l_895)) < (**l_883))) + (float)l_896)) != l_896);
                    (**l_852) = (l_897 != l_897);
                    if ((**l_854))
                        continue;
                }
            }
        }
        (*l_898) = l_863;
    }
    else
    { /* block id: 641 */
        int32_t *l_899 = &l_89;
        (*l_627) = (void*)0;
        (*l_87) = l_899;
        (*l_853) = (*l_87);
    }
    (**l_853) = (3UL <= (~0xFC9ED822L));
    return l_903;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_67(int8_t  p_68)
{ /* block id: 362 */
    uint64_t l_500 = 0xD1A0008B653837C1LL;
    for (p_68 = 0; (p_68 > 1); p_68++)
    { /* block id: 365 */
        return l_500;
    }
    return l_500;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_69(const uint16_t  p_70, uint32_t  p_71, int32_t  p_72, struct S0  p_73, int32_t * p_74)
{ /* block id: 355 */
    int32_t l_497 = 1L;
    for (p_71 = 0; (p_71 >= 28); p_71 += 9)
    { /* block id: 358 */
        int32_t l_489 = 1L;
        uint32_t l_491 = 0x7E8EA873L;
        float l_496 = (-0x1.4p+1);
        float *l_495 = &l_496;
        (*l_495) = (l_489 == (+(l_491 >= ((float)l_491 - (float)(!0x6.5E4691p+49)))));
    }
    return l_497;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_83(int8_t  p_84, const float  p_85, int32_t ** p_86)
{ /* block id: 46 */
    int8_t l_93 = 4L;
    int32_t l_106 = (-1L);
    const int32_t *l_105 = &l_106;
    const int32_t **l_104 = &l_105;
    struct S0 l_107 = {0x2CF1L};
    int32_t **l_303 = (void*)0;
    struct S0 *l_324 = &l_107;
    struct S0 l_446 = {65532UL};
    const struct S0 ***l_452 = (void*)0;
    uint16_t l_478 = 0x22B7L;
    struct S0 l_484 = {65532UL};
    for (p_84 = (-10); (p_84 < (-8)); ++p_84)
    { /* block id: 49 */
        int32_t *l_323 = (void*)0;
        const int32_t l_352 = (-5L);
        struct S0 l_353 = {0x7F3DL};
        const int32_t **l_355 = &l_105;
        int32_t *l_358 = &l_106;
        float **l_372 = (void*)0;
        uint64_t l_436 = 0UL;
        int32_t l_473 = 0x2EC44FEFL;
    }
    (*l_324) = l_484;
    (*l_104) = (*p_86);
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads : l_89
 * writes:
 */
static const int32_t  func_94(const int8_t  p_95, int32_t * p_96, struct S0  p_97, int32_t ** p_98, int64_t  p_99)
{ /* block id: 196 */
    struct S0 l_306 = {0xFC83L};
    struct S0 *l_305 = &l_306;
    struct S0 **l_304 = &l_305;
    int32_t l_317 = 1L;
    int32_t *l_316 = &l_317;
    (*l_304) = (void*)0;
    if (((int16_t)((int64_t)p_99 / (int64_t)((uint32_t)l_306.f0 / (uint32_t)p_99)) - (int16_t)l_306.f0))
    { /* block id: 198 */
        int32_t l_315 = 0x5AF4611EL;
        int32_t *l_314 = &l_315;
        int32_t **l_313 = &l_314;
        (*l_313) = p_96;
        return (*l_314);
    }
    else
    { /* block id: 201 */
        int32_t **l_318 = &l_316;
        (*l_318) = l_316;
    }
    for (l_306.f0 = 0; (l_306.f0 != 45); l_306.f0 += 3)
    { /* block id: 206 */
        const float l_321 = 0x8.C91147p+97;
        const int32_t l_322 = 0x69DB7763L;
        return l_322;
    }
    return (*p_96);
}


/* ------------------------------------------ */
/* 
 * reads : l_89
 * writes: l_89
 */
static struct S0  func_100(const int32_t ** p_101, struct S0  p_102, int32_t * p_103)
{ /* block id: 50 */
    struct S0 l_108 = {2UL};
    int32_t l_116 = 0x0AA4AECAL;
    int32_t *l_115 = &l_116;
    float *l_211 = (void*)0;
    float **l_210 = &l_211;
    float ***l_209 = &l_210;
    float ****l_208 = &l_209;
    int32_t ****l_227 = (void*)0;
    int8_t l_233 = 0x44L;
    const int32_t *l_237 = &l_116;
    l_108 = p_102;
    p_102 = p_102;
    if ((p_102.f0 <= ((uint32_t)l_108.f0 % (uint32_t)((int16_t)(0x955DL & ((int16_t)(l_115 != &l_116) << (int16_t)((*l_115) > (p_102.f0 | ((void*)0 == &p_103))))) / (int16_t)p_102.f0))))
    { /* block id: 53 */
        int64_t l_117 = 0x32E7A53CC61BBCB5LL;
        int32_t *l_140 = &l_116;
        const int32_t ****l_156 = (void*)0;
        struct S0 l_214 = {0x99CEL};
        int32_t **l_231 = &l_115;
        int32_t ***l_230 = &l_231;
        if (l_117)
        { /* block id: 54 */
            int32_t *l_121 = &l_116;
            int32_t ***l_137 = (void*)0;
            struct S0 l_142 = {65533UL};
            struct S0 l_143 = {9UL};
            struct S0 *l_145 = &l_142;
            struct S0 **l_144 = &l_145;
            for (l_116 = (-7); (l_116 >= 11); ++l_116)
            { /* block id: 57 */
                struct S0 *l_120 = &l_108;
                (*l_120) = p_102;
            }
            (*p_101) = l_121;
            if (((uint32_t)(((uint16_t)((int16_t)((int32_t)((int16_t)((int16_t)(*l_115) << (int16_t)p_102.f0) + (int16_t)((*l_121) && (*l_121))) / (int32_t)((*l_121) && ((p_102.f0 || p_102.f0) && 0xCBB7A7919EE48480LL))) >> (int16_t)13) >> (uint16_t)4) < 1UL) - (uint32_t)(*p_103)))
            { /* block id: 61 */
                const int32_t *l_141 = &l_116;
                (*p_101) = &l_116;
                for (l_117 = 23; (l_117 != 21); l_117 -= 1)
                { /* block id: 65 */
                    float l_136 = 0xA.2755FCp+32;
                    (*l_115) = l_117;
                    if ((*p_103))
                    { /* block id: 67 */
                        int32_t ****l_138 = &l_137;
                        (*p_101) = (*p_101);
                        (*p_101) = (*p_101);
                        (*l_138) = l_137;
                    }
                    else
                    { /* block id: 71 */
                        struct S0 *l_139 = &l_108;
                        (*l_139) = p_102;
                        (*p_101) = l_140;
                        l_141 = (*p_101);
                    }
                }
                l_143 = l_142;
            }
            else
            { /* block id: 78 */
                struct S0 ***l_146 = (void*)0;
                struct S0 ***l_147 = &l_144;
                int32_t l_157 = 6L;
                float l_159 = 0x7.42C8ACp-32;
                float *l_158 = &l_159;
                (*l_147) = l_144;
                (*l_158) = ((float)((float)p_102.f0 / (float)((*l_121) <= 0xB.29FA49p-23)) + (float)((p_102.f0 < ((((p_102.f0 < ((*l_140) < ((float)(p_102.f0 == ((float)((*l_140) == ((void*)0 == l_156)) + (float)0x2.224842p-41)) + (float)(-0x1.Cp+1)))) <= l_157) > 0xC.9F9D4Fp+39) == 0xE.03AF45p-20)) < (*l_140)));
                return p_102;
            }
        }
        else
        { /* block id: 83 */
            int64_t l_183 = (-3L);
            int32_t **l_189 = &l_140;
            float **l_198 = (void*)0;
            int32_t ***l_205 = &l_189;
            uint16_t l_219 = 65529UL;
            struct S0 l_229 = {0UL};
            if (((p_102.f0 > 0xCE90L) <= ((int64_t)(&p_103 != (void*)0) - (int64_t)__builtin_popcount(p_102.f0))))
            { /* block id: 84 */
                uint32_t l_190 = 0xD88A72D5L;
                int8_t l_204 = (-10L);
                struct S0 l_206 = {0x2CAEL};
                (*l_115) = (*p_103);
                if (((int16_t)((*l_115) == 0x5A0DL) >> (int16_t)__builtin_bswap32(p_102.f0)))
                { /* block id: 86 */
                    uint16_t l_168 = 65535UL;
                    uint32_t l_184 = 5UL;
                    float l_192 = 0x1.51342Bp-12;
                    float *l_191 = &l_192;
                    for (l_108.f0 = 0; (l_108.f0 != 36); l_108.f0 += 6)
                    { /* block id: 89 */
                        (*p_101) = (*p_101);
                        (*l_115) = ((int16_t)(__builtin_ffs((**p_101)) | l_168) / (int16_t)((int16_t)(((*l_115) & __builtin_popcountll(p_102.f0)) || p_102.f0) << (int16_t)0));
                        (*l_140) = (((uint64_t)((int16_t)(l_168 && (((uint64_t)(0x0B01L != (((int32_t)(*p_103) % (int32_t)(((int16_t)(((((uint16_t)l_183 << (uint16_t)p_102.f0) < p_102.f0) >= l_184) | ((uint16_t)((uint16_t)p_102.f0 % (uint16_t)1UL) >> (uint16_t)l_184)) << (int16_t)7) & p_102.f0)) || (-10L))) + (uint64_t)p_102.f0) == p_102.f0)) >> (int16_t)1) - (uint64_t)p_102.f0) >= 0x9393L);
                        l_189 = &p_103;
                    }
                    (*l_191) = __builtin_clzl((((0x063AL ^ p_102.f0) >= l_190) ^ __builtin_ffsll(p_102.f0)));
                }
                else
                { /* block id: 96 */
                    float *l_195 = (void*)0;
                    float l_197 = 0x4.3p-1;
                    float *l_196 = &l_197;
                    float ***l_199 = &l_198;
                    struct S0 *l_202 = &l_108;
                    (*l_196) = ((float)__builtin_popcountll((**l_189)) + (float)0x5.88BD6Cp-79);
                    (*l_199) = l_198;
                    for (p_102.f0 = 0; (p_102.f0 == 28); p_102.f0 += 4)
                    { /* block id: 101 */
                        struct S0 **l_203 = &l_202;
                        (*l_203) = l_202;
                    }
                }
                if ((l_190 != l_204))
                { /* block id: 105 */
                    (*p_101) = &l_116;
                    (*l_189) = &l_116;
                    (*p_101) = (void*)0;
                }
                else
                { /* block id: 109 */
                    l_205 = (void*)0;
                    (*p_101) = (*p_101);
                    return l_206;
                }
            }
            else
            { /* block id: 114 */
                float *****l_207 = (void*)0;
                l_208 = (void*)0;
                for (l_117 = 7; (l_117 > (-7)); l_117 -= 1)
                { /* block id: 118 */
                    return l_214;
                }
            }
            if (((int16_t)((uint16_t)__builtin_bswap64(l_219) >> (uint16_t)4) * (int16_t)((uint64_t)((**l_189) ^ ((uint32_t)(-(int16_t)(((int16_t)(0UL <= (l_227 != l_227)) * (int16_t)(!((**l_189) && ((*l_115) > 4UL)))) ^ 0x803A303ACD4B1B73LL)) / (uint32_t)4294967295UL)) / (uint64_t)(-1L))))
            { /* block id: 122 */
                return p_102;
            }
            else
            { /* block id: 124 */
                return l_229;
            }
        }
        (*l_230) = &p_103;
        return l_214;
    }
    else
    { /* block id: 130 */
        uint32_t l_232 = 0xDBE3FBEBL;
        float ***l_278 = &l_210;
        if (l_232)
        { /* block id: 131 */
            int16_t l_234 = 0x9ECAL;
            (*p_103) = (__builtin_bswap64(l_233) || l_234);
        }
        else
        { /* block id: 133 */
            int16_t l_240 = 0xBC14L;
            for (p_102.f0 = 8; (p_102.f0 >= 56); p_102.f0 += 9)
            { /* block id: 136 */
                uint32_t l_249 = 0UL;
                l_237 = (*p_101);
                (*p_103) = (((__builtin_clz(p_102.f0) && ((int16_t)((*l_115) | 0xE3A335C4L) / (int16_t)__builtin_ffs(l_240))) < ((((l_240 > ((int16_t)((uint16_t)((uint64_t)((l_249 | (l_240 & p_102.f0)) != p_102.f0) - (uint64_t)18446744073709551611UL) % (uint16_t)0x8928L) - (int16_t)l_240)) <= 4294967295UL) && 0xC8BBL) > 0L)) & l_240);
            }
            return p_102;
        }
        for (l_232 = 0; (l_232 != 11); l_232++)
        { /* block id: 144 */
            const struct S0 *l_252 = &l_108;
            int32_t *l_267 = (void*)0;
            float ****l_268 = &l_209;
            float ***l_277 = (void*)0;
            uint32_t l_291 = 4294967295UL;
            l_252 = l_252;
        }
    }
    return l_108;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 313
   depth: 1, occurrence: 45
XXX total union variables: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 286
   depth: 2, occurrence: 52
   depth: 3, occurrence: 6
   depth: 4, occurrence: 9
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 5
   depth: 12, occurrence: 3
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 4
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 329

XXX times a variable address is taken: 306
XXX times a pointer is dereferenced on RHS: 212
breakdown:
   depth: 1, occurrence: 172
   depth: 2, occurrence: 36
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 204
breakdown:
   depth: 1, occurrence: 183
   depth: 2, occurrence: 19
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 943

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1120
   level: 2, occurrence: 136
   level: 3, occurrence: 27
   level: 4, occurrence: 10
XXX number of pointers point to pointers: 192
XXX number of pointers point to scalars: 105
XXX number of pointers point to structs: 32
XXX percent of pointers has null in alias set: 24.9
XXX average alias set size: 1.26

XXX times a non-volatile is read: 1281
XXX times a non-volatile is write: 549
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 247
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 30
   depth: 2, occurrence: 37
   depth: 3, occurrence: 47
   depth: 4, occurrence: 48
   depth: 5, occurrence: 50

XXX percentage a fresh-made variable is used: 20.9
XXX percentage an existing variable is used: 79.1
********************* end of statistics **********************/

