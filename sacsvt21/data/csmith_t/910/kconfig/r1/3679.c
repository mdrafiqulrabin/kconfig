/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      176762792
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int8_t  f0;
   unsigned f1 : 15;
   signed f2 : 7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_33(void);
static int16_t  func_37(int32_t  p_38, struct S0  p_39, uint16_t  p_40, int16_t  p_41, uint16_t  p_42);
inline static uint32_t  func_64(int16_t  p_65, uint32_t  p_66, int32_t  p_67);
inline static struct S0  func_70(uint32_t  p_71);
inline static struct S0  func_72(uint32_t  p_73);
static struct S0  func_74(struct S0  p_75, int32_t  p_76, int32_t  p_77);
static uint16_t  func_85(int32_t  p_86);
static int32_t  func_87(int32_t  p_88, uint32_t  p_89, int8_t  p_90, int32_t  p_91);
inline static struct S0  func_94(int8_t  p_95, int16_t  p_96);
static uint16_t  func_109(uint16_t  p_110);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_33(void)
{ /* block id: 36 */
    int16_t l_34 = 0;
    int32_t l_48 = 0;
    int32_t l_49 = 0x33ECDC0F;
    int32_t l_50 = 0xA781B5F7;
    struct S0 l_51 = {0x36,153,-5};
    uint32_t l_475 = 4294967293U;
    l_34 = 0x07C70AB2;
    l_51.f2 = (((int16_t)func_37((__builtin_clz(l_34) , (l_50 = (l_49 = __builtin_bswap32(((int16_t)((int16_t)l_34 << (int16_t)(((~(-1)) < l_34) , ((l_48 |= 0xB884) < __builtin_popcountl(((l_34 & l_34) , (l_34 > l_34)))))) >> (int16_t)l_34))))), l_51, l_34, l_51.f1, l_51.f2) * (int16_t)l_51.f2) | l_51.f1);
    l_51 = ((l_49 = 0x6A7C) , func_72((((l_50 = (l_49 , l_51.f1)) | (~((l_51.f2 = ((l_475 && l_51.f0) & l_51.f1)) >= l_475))) != l_475)));
    return l_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_37(int32_t  p_38, struct S0  p_39, uint16_t  p_40, int16_t  p_41, uint16_t  p_42)
{ /* block id: 41 */
    int16_t l_68 = 0xD005;
    int16_t l_390 = 0x85F1;
    uint32_t l_394 = 0xB7BE2BC1;
    int32_t l_395 = 0x67B892A8;
    int32_t l_404 = 0x189C1302;
    int32_t l_405 = 0x751C81A5;
    uint32_t l_406 = 0U;
    uint32_t l_418 = 4294967289U;
    struct S0 l_419 = {0,29,6};
    int32_t l_473 = 0;
    for (p_40 = 0; (p_40 != 33); p_40 += 1)
    { /* block id: 44 */
        uint32_t l_60 = 0x114FF6A9;
        int32_t l_61 = 0x2039CE85;
        int32_t l_391 = 0;
        int32_t l_392 = 0xDDB280B6;
        uint16_t l_393 = 0xD4D6;
        int32_t l_459 = 0x38E9F50F;
        p_39.f2 = ((((((int16_t)(p_42 | (((int16_t)(((uint16_t)(l_60 = p_39.f1) - (uint16_t)(l_61 & (((((int16_t)(l_61 && (l_392 = ((((l_391 = (((p_41 ^ func_64(p_39.f1, __builtin_bswap64(l_68), p_39.f0)) != l_390) , l_61)) && 0xF301F7C6) >= l_68) & 0))) * (int16_t)l_393) >= l_394) && p_40) >= p_39.f1))) <= l_395) << (int16_t)l_61) && l_390)) % (int16_t)0xE528) <= 1U) | 65535U) >= p_41) != l_390);
        if (((int32_t)((int16_t)(-1) - (int16_t)((int16_t)((func_109((p_42 = ((uint16_t)l_394 * (uint16_t)((l_405 ^= func_87(l_390, p_39.f2, ((l_404 = 0x76D7F0A6) , (p_39.f0 >= l_392)), l_61)) <= p_39.f2)))) , l_395) ^ l_406) % (int16_t)l_60)) + (int32_t)p_40))
        { /* block id: 209 */
            int32_t l_425 = (-10);
            int32_t l_426 = (-1);
            int32_t l_439 = 0xC9BEFE6A;
            for (p_42 = (-20); (p_42 == 9); p_42 += 6)
            { /* block id: 212 */
                int32_t l_420 = 0x5FE38EC4;
                int32_t l_424 = (-9);
                uint32_t l_434 = 1U;
                struct S0 l_440 = {0x2F,167,-9};
                for (l_392 = (-17); (l_392 != 0); l_392 += 1)
                { /* block id: 215 */
                    int8_t l_423 = 0x3D;
                    l_426 |= (((-7) ^ (l_405 = (-(uint32_t)((int16_t)((p_39 = (((int32_t)((int16_t)func_87((p_38 = (((__builtin_ctzll((l_420 = ((l_418 == p_38) > ((l_419 , l_420) != p_39.f1)))) > func_87((l_424 ^= ((uint16_t)p_41 + (uint16_t)(l_423 = 65533U))), p_39.f0, l_425, p_39.f1)) != l_393) || l_420)), p_39.f2, l_392, l_425) * (int16_t)l_419.f1) - (int32_t)l_61) , p_39)) , l_61) * (int16_t)65534U)))) < 65526U);
                    for (l_390 = 16; (l_390 < 23); l_390 += 8)
                    { /* block id: 225 */
                        struct S0 l_429 = {-9,116,9};
                        l_429 = func_94(((l_424 |= l_392) , __builtin_clzl(((0x1E06 == p_39.f0) && (l_425 ^= (l_424 | (func_109(l_391) > l_405)))))), (p_41 = (((0U & p_42) & 0xCAD3) != p_40)));
                    }
                    p_39.f2 = ((((l_426 = ((uint32_t)(l_439 ^= (((uint16_t)func_109(l_419.f2) >> (uint16_t)10) , (l_404 = (((0U < ((p_39.f1 > (((l_426 , l_392) > (l_425 = __builtin_popcountl(l_434))) == ((int32_t)((int16_t)(__builtin_clzl(l_418) & l_424) >> (int16_t)p_39.f2) + (int32_t)l_426))) > l_395)) == p_39.f0) && p_39.f0)))) - (uint32_t)p_39.f1)) > 1) == l_434) >= l_424);
                    return p_41;
                }
                if (p_39.f2)
                    continue;
                p_39 = l_440;
            }
        }
        else
        { /* block id: 241 */
            int32_t l_441 = 0xC793CACA;
            int32_t l_449 = 0x0FE30266;
            if ((l_441 > (p_39.f2 = p_42)))
            { /* block id: 243 */
                p_39.f2 = p_41;
                if (l_393)
                    break;
            }
            else
            { /* block id: 246 */
                int32_t l_448 = 1;
                int32_t l_456 = 5;
                l_449 |= ((((int16_t)((int16_t)0xF30D + (int16_t)((0x183D2D2B > (l_60 , ((-1) || ((uint16_t)(p_42 = __builtin_ctzll((p_41 , 4294967291U))) >> (uint16_t)0)))) ^ l_448)) * (int16_t)l_404) > 0xD61A) > l_448);
                l_456 |= (p_39.f2 = ((l_60 , ((int16_t)(p_39 , l_406) + (int16_t)((func_87(((p_39.f0 || (((uint32_t)((p_42 = (p_42 == 0)) >= 0x9EBA) % (uint32_t)((uint16_t)(((p_39.f1 > l_448) || 0xF3F2544A) < l_390) * (uint16_t)p_39.f1)) , p_39.f1)) | l_391), p_39.f1, l_395, l_405) || l_419.f2) == p_41))) >= p_40));
            }
            for (l_395 = 0; (l_395 > 13); l_395 += 3)
            { /* block id: 255 */
                return p_42;
            }
            p_39.f2 = ((p_42 ^ ((l_449 = (l_459 == (0x1BB28938 >= ((!(((uint32_t)(p_39.f2 , (((int16_t)0x06DD % (int16_t)p_39.f0) && (l_392 != (__builtin_clz((4294967289U >= (-4))) , p_38)))) % (uint32_t)l_391) && p_42)) <= 0U)))) & l_391)) <= l_419.f2);
            if (l_390)
                break;
        }
    }
    for (p_42 = 0; (p_42 != 0); p_42 += 7)
    { /* block id: 265 */
        l_405 ^= (func_94((p_39.f0 = ((uint16_t)l_68 >> (uint16_t)12)), p_39.f2) , l_419.f1);
        if (p_39.f0)
            break;
        return p_42;
    }
    l_419 = ((l_473 = ((((uint16_t)((l_405 != (l_404 = (((((func_74(p_39, p_39.f1, p_39.f0) , p_39.f2) , ((((int16_t)p_39.f0 << (int16_t)p_40) > func_87(((p_39 , l_68) && l_473), l_395, p_42, p_39.f2)) , 4294967292U)) && 0x256F05E9) , p_39.f0) != p_38))) == l_473) << (uint16_t)p_39.f0) > 65535U) >= l_418)) , p_39);
    p_39 = p_39;
    return l_419.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_64(int16_t  p_65, uint32_t  p_66, int32_t  p_67)
{ /* block id: 46 */
    int32_t l_69 = 0xE5C5CC99;
    struct S0 l_381 = {0x07,139,-7};
    uint16_t l_384 = 65535U;
    uint32_t l_388 = 1U;
    int32_t l_389 = 2;
    l_69 = p_66;
    l_381 = func_70((p_66 = p_66));
    l_389 = ((uint16_t)(l_381.f1 != ((((l_384 | (p_65 & l_384)) ^ (l_381.f2 = ((((__builtin_ctzll(((p_65 == (l_381.f1 ^ ((uint16_t)(l_381.f0 || p_65) + (uint16_t)((~l_381.f2) | l_388)))) , p_66)) , 65535U) || 0x7BB6) , l_381.f2) , l_381.f1))) , p_66) , 3U)) << (uint16_t)14);
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_70(uint32_t  p_71)
{ /* block id: 49 */
    struct S0 l_78 = {-9,178,-2};
    uint32_t l_79 = 4294967289U;
    int32_t l_80 = 0x4BD9F5B6;
    uint32_t l_366 = 0U;
    uint32_t l_367 = 0xE262E621;
    int32_t l_368 = (-2);
    int32_t l_369 = 0xA52FB1A3;
    int32_t l_370 = 0xAA33F384;
    uint32_t l_371 = 0xBBF705CB;
    int32_t l_378 = 0x0760AC32;
    int16_t l_379 = (-1);
    struct S0 l_380 = {-1,83,5};
    l_78 = func_72((func_74(l_78, l_79, (l_78.f0 ^ (l_80 |= p_71))) , 0x887E981C));
    l_78.f2 |= ((int16_t)l_80 >> (int16_t)l_78.f1);
    l_78 = (((int16_t)((((uint16_t)((p_71 | p_71) >= ((int16_t)p_71 - (int16_t)((l_80 = (((uint16_t)func_87(l_80, p_71, ((((l_78.f2 = 0x4024) <= (l_370 = (p_71 != func_109((l_369 = (((l_368 &= ((((l_80 , (func_85((((p_71 ^ l_366) && 7U) & p_71)) < l_367)) & 1U) >= 1) , p_71)) >= l_78.f0) , l_80)))))) , 0xE659) != 1), p_71) << (uint16_t)l_366) | 0x350790CD)) , p_71))) * (uint16_t)l_371) != p_71) && p_71) << (int16_t)p_71) , l_78);
    l_380 = func_74((l_78 = func_94(l_78.f0, p_71)), l_367, ((l_80 = l_370) && ((int16_t)func_85((0xEAACACCC < ((uint16_t)(1 <= (((((func_87(p_71, ((int16_t)((((p_71 , p_71) , p_71) ^ p_71) != l_378) * (int16_t)p_71), l_79, l_366) || 0) , l_79) | p_71) , l_80) , l_79)) << (uint16_t)0))) - (int16_t)l_379)));
    return l_380;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_72(uint32_t  p_73)
{ /* block id: 54 */
    uint32_t l_82 = 0x16A5C54C;
    struct S0 l_236 = {1,35,-9};
    int32_t l_237 = 0xADF10BAC;
    uint16_t l_238 = 65533U;
    int32_t l_336 = 9;
    l_82 = __builtin_ctzll(p_73);
    l_336 = ((int16_t)(func_85(func_87((((((int32_t)(func_94(((l_82 || ((((int32_t)((int16_t)__builtin_ctz(((int16_t)((uint32_t)((0xCA85E45C ^ l_82) | ((l_236.f2 = (l_237 |= ((uint16_t)((uint16_t)func_109(p_73) % (uint16_t)0x1DBC) % (uint16_t)(65529U & ((((int32_t)8 % (int32_t)((int16_t)__builtin_ffsll((func_74(func_74(l_236, p_73, l_236.f1), p_73, p_73) , p_73)) - (int16_t)p_73)) , p_73) > 2U))))) && p_73)) % (uint32_t)p_73) * (int16_t)l_238)) + (int16_t)p_73) + (int32_t)p_73) & l_82) , p_73)) , 1), l_236.f0) , (-1)) % (int32_t)l_236.f1) || p_73) != l_238) ^ p_73), p_73, l_82, l_236.f0)) ^ p_73) << (int16_t)3);
    l_336 |= p_73;
    for (l_238 = 13; (l_238 == 2); l_238 -= 1)
    { /* block id: 164 */
        uint32_t l_341 = 4294967294U;
        struct S0 l_349 = {0xB4,152,-9};
        l_237 = ((uint16_t)p_73 >> (uint16_t)(p_73 != 0U));
        l_341 = p_73;
        for (l_336 = 0; (l_336 == 5); l_336 += 6)
        { /* block id: 169 */
            uint16_t l_350 = 0x7590;
            int32_t l_355 = 0xB52ADD3F;
            for (l_82 = 28; (l_82 >= 30); l_82 += 1)
            { /* block id: 172 */
                for (l_341 = 3; (l_341 < 39); l_341 += 1)
                { /* block id: 175 */
                    struct S0 l_348 = {0xE8,116,-0};
                    l_349 = l_348;
                    return l_236;
                }
            }
            l_236.f2 = (__builtin_parityl(((l_350 = 0U) && (((int16_t)(l_237 = (func_85(((int16_t)func_109(l_236.f0) * (int16_t)(l_349.f2 = ((l_236 , p_73) & l_336)))) > (0U >= (65528U == 0x78E6)))) * (int16_t)l_350) && l_349.f0))) != l_355);
        }
    }
    return l_236;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_74(struct S0  p_75, int32_t  p_76, int32_t  p_77)
{ /* block id: 51 */
    struct S0 l_81 = {1,77,9};
    p_75.f2 = p_76;
    return l_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_85(int32_t  p_86)
{ /* block id: 140 */
    struct S0 l_273 = {-1,36,-1};
    int32_t l_276 = 0x9AC39EC9;
    int8_t l_290 = 2;
    uint32_t l_293 = 1U;
    int32_t l_298 = 2;
    int32_t l_299 = 0xDA16F4BA;
    uint32_t l_300 = 0x9030FC9D;
    int32_t l_301 = 0xB9E970FD;
    uint16_t l_302 = 0x2A19;
    struct S0 l_303 = {0,61,-2};
    int32_t l_320 = 0x535540F0;
    struct S0 l_322 = {0x84,86,-2};
    l_303 = (func_74((l_273 = l_273), ((uint16_t)l_276 * (uint16_t)((int16_t)((((int16_t)((((int32_t)p_86 % (int32_t)(func_109((((~p_86) <= ((int32_t)((uint32_t)(l_301 = (func_94((5U & ((uint16_t)(((func_87(((l_290 | (((l_276 && (l_293 <= ((int16_t)__builtin_bswap64(((((uint16_t)(l_299 &= (l_298 ^= (1 > l_290))) - (uint16_t)9) > p_86) >= 0x637EA3EB)) + (int16_t)0x8290))) >= l_300) , p_86)) , l_300), p_86, l_290, l_290) , l_299) == p_86) > 4294967295U) << (uint16_t)6)), p_86) , p_86)) + (uint32_t)p_86) - (int32_t)0xF02D27C7)) != l_276)) | l_276)) < p_86) , p_86) >> (int16_t)l_302) != p_86) > 0x51EA) * (int16_t)l_293)), l_290) , l_273);
    l_322 = (((((int16_t)((uint16_t)(((l_301 = (((int16_t)(-(uint32_t)(l_303.f2 ^= 0xA7C0EDF7)) * (int16_t)(l_273.f2 = (((((uint16_t)(l_320 = (((l_300 & (p_86 != ((uint16_t)p_86 * (uint16_t)__builtin_ctzl((((uint16_t)((int16_t)0xB2A5 >> (int16_t)(0xFF82 <= (~l_320))) >> (uint16_t)((l_293 == ((((-(int32_t)(l_301 && 0x5091)) != 1U) & l_273.f0) , 0x3BD95B1C)) ^ p_86)) && l_303.f1))))) < l_273.f0) ^ p_86)) - (uint16_t)p_86) , l_273) , p_86) == l_303.f0))) || l_276)) , p_86) | (-3)) >> (uint16_t)l_303.f0) % (int16_t)l_290) <= 8U) , 0x29779F3C) , l_322);
    l_322.f2 = ((int32_t)(((((l_273.f2 &= 0x4E2F) != (((uint16_t)p_86 - (uint16_t)l_302) > (l_301 = ((uint32_t)((int16_t)(__builtin_bswap32(func_109((((~p_86) > ((uint16_t)l_299 << (uint16_t)12)) && ((p_86 , 1U) , l_322.f0)))) , l_293) >> (int16_t)1) - (uint32_t)0x732D4BDB)))) & 0x2F50FCE1) , p_86) ^ 65527U) + (int32_t)(-1));
    for (l_300 = 0; (l_300 == 6); l_300 += 1)
    { /* block id: 156 */
        p_86 = (l_302 <= l_302);
    }
    return p_86;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_87(int32_t  p_88, uint32_t  p_89, int8_t  p_90, int32_t  p_91)
{ /* block id: 131 */
    int32_t l_257 = (-1);
    int32_t l_258 = 2;
    int32_t l_271 = 0x614CAE8D;
    int32_t l_272 = 0;
    l_272 = (((int32_t)func_109((l_271 |= ((((int32_t)(!(p_89 = func_109(((uint16_t)((int32_t)(p_91 , (((int16_t)__builtin_bswap64(((uint16_t)0x8FBE << (uint16_t)((((int16_t)p_91 >> (int16_t)p_88) < ((__builtin_ffsl((l_258 = l_257)) , ((((uint16_t)(l_258 = l_258) * (uint16_t)((int32_t)((int32_t)((int16_t)l_257 >> (int16_t)((uint16_t)((uint16_t)p_89 * (uint16_t)(-5)) >> (uint16_t)11)) % (int32_t)0x8A72973F) + (int32_t)p_90)) != p_89) || p_91)) || 0xF385)) , 0x852D))) << (int16_t)13) != p_88)) % (int32_t)8U) << (uint16_t)l_257)))) % (int32_t)l_257) && p_89) <= 4294967293U))) - (int32_t)p_91) <= p_91);
    l_258 = l_257;
    l_272 = (-4);
    return l_258;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_94(int8_t  p_95, int16_t  p_96)
{ /* block id: 128 */
    uint16_t l_239 = 0xAB7F;
    int8_t l_240 = 0x80;
    struct S0 l_241 = {-1,34,1};
    l_240 |= l_239;
    return l_241;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_109(uint16_t  p_110)
{ /* block id: 56 */
    uint16_t l_117 = 65535U;
    int32_t l_118 = 0xFD02F95C;
    struct S0 l_131 = {0x43,131,-4};
    int32_t l_134 = 0x7F51BCBD;
    int32_t l_135 = 0x7C2D9536;
    uint32_t l_192 = 4294967293U;
    int32_t l_226 = 0x4C18CA03;
    uint32_t l_227 = 0x4AC0D40F;
    int32_t l_228 = 0x09B231F3;
    int32_t l_229 = (-8);
    int32_t l_230 = 0x7DB1D573;
    int8_t l_231 = (-4);
    l_135 |= ((uint32_t)(((int16_t)p_110 >> (int16_t)(((int16_t)((l_118 ^= l_117) , (l_118 = ((int16_t)((((int16_t)((uint16_t)((p_110 < l_118) & 3) * (uint16_t)l_118) >> (int16_t)15) < (((int16_t)(l_134 ^= ((int16_t)(l_131.f2 = ((int32_t)4 - (int32_t)((((((l_131 , ((((uint16_t)p_110 << (uint16_t)l_131.f2) , 0x0322) >= p_110)) && l_117) > 0xDECA30E3) <= 0xC8A6F198) >= l_131.f1) , 0x822E8431))) << (int16_t)l_117)) << (int16_t)l_131.f0) <= 65531U)) <= p_110) - (int16_t)p_110))) << (int16_t)p_110) , l_118)) != l_131.f0) - (uint32_t)p_110);
    if (l_117)
    { /* block id: 62 */
        int16_t l_139 = 0x2794;
        int32_t l_140 = 1;
        l_140 = (p_110 < ((int16_t)(!l_139) * (int16_t)l_139));
    }
    else
    { /* block id: 64 */
        int16_t l_143 = 0x2D3D;
        int32_t l_144 = 0xC9F35A7B;
        uint16_t l_147 = 0x27D2;
        int32_t l_152 = (-1);
        int32_t l_154 = 0;
        struct S0 l_160 = {0xA9,67,-3};
        if ((l_144 = ((((uint16_t)p_110 * (uint16_t)(0U < (l_131.f0 <= 9))) , 1) >= (l_143 = p_110))))
        { /* block id: 67 */
            int8_t l_151 = (-6);
            int32_t l_183 = (-5);
            int32_t l_193 = 0x250D9091;
            if (p_110)
            { /* block id: 68 */
                uint32_t l_157 = 0x1BCAB2B0;
                int32_t l_159 = 0;
                int32_t l_173 = (-1);
                for (l_131.f0 = 22; (l_131.f0 != (-4)); l_131.f0 -= 1)
                { /* block id: 71 */
                    int16_t l_150 = 0x153C;
                    int32_t l_153 = 0;
                    l_154 ^= (l_147 , (l_153 ^= (((int16_t)p_110 % (int16_t)__builtin_ctz(l_150)) ^ (l_144 = ((p_110 && l_151) > l_152)))));
                    if (((uint16_t)p_110 + (uint16_t)((l_153 = (l_157 & l_131.f1)) <= 0xE9E3DC10)))
                    { /* block id: 76 */
                        struct S0 l_158 = {1,15,5};
                        l_160 = func_74(l_158, (l_159 = l_150), p_110);
                        if (p_110)
                            continue;
                        l_173 = (((l_159 = (l_158.f2 &= (((l_154 = 0x3ECD) ^ (-(int16_t)__builtin_ctz(__builtin_parity(l_157)))) ^ ((uint16_t)(!l_134) * (uint16_t)0x4F0C)))) , ((int16_t)p_110 << (int16_t)((((uint16_t)((int16_t)((int32_t)p_110 + (int32_t)(l_160.f2 != p_110)) * (int16_t)p_110) >> (uint16_t)l_158.f1) == p_110) > l_159))) || l_117);
                    }
                    else
                    { /* block id: 84 */
                        uint32_t l_180 = 1U;
                        l_144 &= (((uint16_t)((int16_t)(l_160 , (l_134 >= p_110)) * (int16_t)p_110) << (uint16_t)13) <= (((((l_134 ^ (l_153 = (p_110 || ((uint16_t)((((l_150 < (65526U >= l_131.f1)) || l_180) <= 1U) | l_131.f0) << (uint16_t)9)))) , (-3)) , l_180) & p_110) == l_117));
                    }
                }
            }
            else
            { /* block id: 89 */
                int32_t l_187 = 1;
                l_154 = p_110;
                l_183 &= ((uint16_t)p_110 >> (uint16_t)p_110);
                l_183 &= ((l_151 <= ((uint16_t)l_144 - (uint16_t)(!l_187))) >= 0x09C9891B);
                l_193 = ((l_144 ^= __builtin_ctzll((l_154 = (((int32_t)p_110 - (int32_t)(l_183 = __builtin_ffs((l_187 |= ((uint16_t)0x472D >> (uint16_t)10))))) != 0x93AE)))) <= ((p_110 == 0xA6B184C1) && l_192));
            }
            return p_110;
        }
        else
        { /* block id: 100 */
            uint16_t l_219 = 2U;
            for (l_192 = 0; (l_192 != 36); l_192 += 9)
            { /* block id: 103 */
                for (p_110 = (-8); (p_110 > 58); p_110 += 6)
                { /* block id: 106 */
                    uint32_t l_220 = 0U;
                    int32_t l_221 = 0xB879365D;
                    l_135 |= ((int32_t)((p_110 < (((uint16_t)65527U << (uint16_t)13) | ((uint16_t)(((int16_t)((int16_t)__builtin_ctzll(l_143) >> (int16_t)((((((uint16_t)(l_160.f1 <= ((int32_t)((int32_t)((uint16_t)((uint32_t)(((-8) <= p_110) && (!0xF54A)) - (uint32_t)p_110) - (uint16_t)l_219) - (int32_t)p_110) % (int32_t)4)) >> (uint16_t)l_160.f2) ^ p_110) ^ l_219) != (-2)) ^ p_110)) >> (int16_t)2) <= p_110) >> (uint16_t)11))) , p_110) - (int32_t)l_220);
                    l_221 = 0x99A68D69;
                }
            }
            l_154 |= l_219;
        }
    }
    l_230 = (l_229 = ((l_228 |= (p_110 | (((l_227 = (l_226 = (((l_118 &= (l_134 = (l_131.f2 = __builtin_bswap32((0xEB09 ^ l_135))))) == ((uint16_t)l_135 >> (uint16_t)((int16_t)(-3) >> (int16_t)8))) , (l_118 = (l_131.f0 || (__builtin_ia32_crc32qi(l_118, (l_135 = 1U)) , l_131.f2)))))) == p_110) && l_134))) < (-6)));
    l_226 |= ((p_110 > l_231) , l_227);
    return l_228;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 111
   depth: 1, occurrence: 18
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 18
breakdown:
   indirect level: 0, occurrence: 18
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 16
XXX times a bitfields struct on RHS: 26
XXX times a single bitfield on LHS: 22
XXX times a single bitfield on RHS: 51

XXX max expression depth: 47
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 18
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 2
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 37, occurrence: 1
   depth: 45, occurrence: 1
   depth: 47, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 481
XXX times a non-volatile is write: 156
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 93
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 41
   depth: 1, occurrence: 11
   depth: 2, occurrence: 11
   depth: 3, occurrence: 15
   depth: 4, occurrence: 10
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

