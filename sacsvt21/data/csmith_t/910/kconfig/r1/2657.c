/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3799360776
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   signed f0 : 18;
   unsigned f1 : 31;
   float  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_27(void);
inline static uint16_t  func_39(const int32_t  p_40, float  p_41, uint32_t  p_42);
static float  func_43(int32_t  p_44);
inline static const uint16_t  func_50(int16_t  p_51, int32_t  p_52);
inline static int32_t  func_53(union U0  p_54, uint32_t  p_55, uint32_t  p_56);
static union U0  func_57(const int16_t  p_58);
inline static int32_t * func_59(int32_t * p_60, uint32_t  p_61, int32_t * p_62, int32_t  p_63, float  p_64);
inline static int32_t * func_65(float  p_66, float  p_67, int32_t  p_68);
inline static int16_t  func_69(float  p_70, union U0  p_71, int32_t  p_72, int32_t  p_73, union U0  p_74);
inline static union U0  func_75(float  p_76, float  p_77, int32_t  p_78);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_27(void)
{ /* block id: 36 */
    int32_t l_28 = 0x5B054DBB;
    uint32_t l_437 = 1U;
    union U0 l_447 = {-5};
    union U0 *l_458 = &l_447;
    union U0 **l_457 = &l_458;
    for (l_28 = (-17); (l_28 > 8); l_28 += 8)
    { /* block id: 39 */
        uint32_t l_36 = 0U;
        int32_t l_438 = 0xF0B77432;
        union U0 *l_456 = &l_447;
        union U0 **l_455 = &l_456;
        l_438 = (~((uint32_t)(((uint16_t)((l_36 && (((uint16_t)((func_39(l_28, func_43((l_28 && (~(((int16_t)((int32_t)(((l_28 == func_50((l_36 == func_53(func_57(l_36), l_36, l_36)), l_28)) <= 0xBCE7F420) == 0x148E350B) - (int32_t)l_36) % (int16_t)0xC055) ^ l_28)))), l_28) >= l_28) && 0) << (uint16_t)5) & l_36)) > l_437) % (uint16_t)(-2)) ^ l_28) - (uint32_t)l_36));
        for (l_36 = 0; (l_36 < 52); l_36 += 1)
        { /* block id: 287 */
            uint32_t l_448 = 6U;
            int16_t l_459 = (-8);
            int32_t *l_461 = &l_438;
            int32_t **l_460 = &l_461;
            for (l_437 = 0; (l_437 != 8); l_437 += 8)
            { /* block id: 290 */
                float *l_451 = &l_447.f2;
                int32_t l_452 = 0x1B65AA12;
                for (l_438 = 0; (l_438 != 20); ++l_438)
                { /* block id: 293 */
                    int32_t l_450 = 0x740CD579;
                    int32_t *l_449 = &l_450;
                    (*l_449) = ((uint16_t)l_28 << (uint16_t)(0xF6A51E5C ^ (0x7887B8A3 || func_53(l_447, l_36, l_448))));
                    if ((*l_449))
                        continue;
                }
                (*l_451) = l_438;
                /* statement id: 297 */
                                l_452 = 0x0FA0D30A;
            }
            (*l_460) = func_65(((float)l_438 - (float)(l_455 != l_457)), l_459, l_459);
            /* statement id: 300 */
            assert (l_461 == 0);
            (*l_460) = func_65(l_438, ((!(func_50((&l_438 != &l_438), (l_447.f0 & ((void*)0 != (*l_460)))) < l_447.f0)) <= ((func_43(l_438) >= 0xA.51EDD1p-64) != 0x3.14C4D4p+15)), l_438);
        }
    }
    return l_447.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_39(const int32_t  p_40, float  p_41, uint32_t  p_42)
{ /* block id: 281 */
    int32_t l_433 = 1;
    int32_t *l_436 = &l_433;
    (*l_436) = ((((int16_t)0x18B0 % (int16_t)(-1)) < l_433) && ((uint16_t)p_42 - (uint16_t)l_433));
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_43(int32_t  p_44)
{ /* block id: 276 */
    int32_t l_420 = 0x2325A27A;
    const int32_t *l_419 = &l_420;
    int32_t **l_421 = (void*)0;
    int32_t **l_422 = (void*)0;
    union U0 l_424 = {-1};
    const int32_t **l_425 = (void*)0;
    int16_t l_426 = (-1);
    int32_t *l_428 = &l_420;
    const int32_t *l_429 = (void*)0;
    int32_t **l_430 = &l_428;
    l_419 = l_419;
    l_419 = func_65(p_44, (!(p_44 <= func_69(p_44, l_424, p_44, p_44, l_424))), (*l_419));
    /* statement id: 278 */
    assert (l_419 == 0);
    (*l_430) = l_429;
    /* statement id: 279 */
    assert (l_428 == 0);
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_50(int16_t  p_51, int32_t  p_52)
{ /* block id: 273 */
    int32_t l_418 = 0x52DE9F1D;
    int32_t *l_417 = &l_418;
    (*l_417) = p_52;
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_53(union U0  p_54, uint32_t  p_55, uint32_t  p_56)
{ /* block id: 214 */
    uint32_t l_321 = 0x8648EDA7;
    int32_t l_323 = (-7);
    int32_t *l_322 = &l_323;
    int32_t ** const l_375 = &l_322;
    int32_t ** const *l_374 = &l_375;
    int32_t ** const **l_373 = &l_374;
    union U0 l_386 = {-1};
    l_321 = (p_54.f0 <= 0x06D2);
    (*l_322) = l_321;
    for (p_55 = 25; (p_55 >= 8); p_55 -= 8)
    { /* block id: 219 */
        uint32_t l_333 = 7U;
        int32_t l_368 = 0x875B382D;
        int32_t **l_394 = &l_322;
        union U0 l_407 = {-8};
        int32_t l_410 = 0;
    }
    return p_54.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_57(const int16_t  p_58)
{ /* block id: 40 */
    int32_t l_79 = (-2);
    union U0 l_87 = {1};
    uint32_t l_194 = 7U;
    int32_t **l_198 = (void*)0;
    int32_t **l_199 = (void*)0;
    int32_t *l_200 = &l_79;
    int32_t **l_201 = &l_200;
    union U0 l_213 = {5};
    float l_220 = 0x0.Cp-1;
    float *l_219 = &l_220;
    float **l_218 = &l_219;
    int32_t ***l_252 = &l_201;
    int32_t ****l_251 = &l_252;
    const int32_t l_258 = 1;
    uint32_t l_286 = 0U;
    union U0 *l_318 = &l_213;
    union U0 ** const l_317 = &l_318;
    union U0 l_320 = {0x269C6AF2};
    l_200 = func_59(func_65(p_58, p_58, (((func_69(p_58, func_75(l_79, (((l_79 < l_79) < 0x0.Cp-1) < l_79), (p_58 && p_58)), l_79, l_79, l_87) == p_58) <= 0U) > l_87.f0)), p_58, &l_79, l_194, l_79);
    /* statement id: 146 */
    assert (l_200 == 0);
    (*l_201) = &l_79;
    /* statement id: 147 */
    assert (l_200 == &l_79);
    if ((~(0U != (*l_200))))
    { /* block id: 148 */
        uint32_t l_203 = 0xE003A25D;
        float *l_204 = &l_87.f2;
        union U0 l_214 = {-1};
        float l_215 = (-0x6.4p+1);
        (*l_204) = l_203;
        /* statement id: 149 */
                if (((p_58 < p_58) == (((uint16_t)(func_69(func_69(((0xF.E688B2p+4 >= (((**l_201) != ((float)p_58 + (float)((-0x9.Ap-1) <= (func_69((((float)0xC.A6B184p-32 + (float)(((float)(**l_201) + (float)(((p_58 < l_203) >= p_58) >= (-0x1.8p+1))) <= p_58)) < (*l_200)), l_87, p_58, (**l_201), l_213) == l_203)))) < p_58)) <= l_203), l_214, p_58, p_58, l_87), l_87, p_58, l_214.f0, l_214) == l_214.f0) % (uint16_t)p_58) >= (**l_201))))
        { /* block id: 150 */
            (*l_204) = l_214.f0;
        }
        else
        { /* block id: 152 */
            (*l_201) = l_204;
            /* statement id: 153 */
            assert (l_200 == &l_87.f2);
        }
        /* facts after branching */
        assert (l_200 == &l_87.f2 || l_200 == &l_79);
    }
    else
    { /* block id: 155 */
        uint32_t l_221 = 0x1F4F54AD;
        int16_t l_226 = 0xA47A;
        int32_t ***l_235 = &l_201;
        int32_t ****l_234 = &l_235;
        int32_t *****l_233 = &l_234;
        int32_t **l_243 = (void*)0;
        union U0 l_244 = {0xA5802A5F};
        float *l_290 = (void*)0;
        float **l_304 = &l_290;
        union U0 *l_316 = &l_244;
        union U0 **l_315 = &l_316;
        for (l_79 = 1; (l_79 != (-8)); l_79 -= 1)
        { /* block id: 158 */
            int32_t ****l_224 = (void*)0;
            int32_t l_225 = 0xD4B5287A;
            union U0 l_227 = {0x53B87936};
            int32_t *****l_236 = (void*)0;
            int16_t l_305 = 1;
        }
        (*l_201) = (****l_233);
        l_315 = l_317;
        /* statement id: 210 */
        assert (l_315 == &l_318);
        (***l_252) = (!0x5.EE57E1p-87);
    }
    /* facts after branching */
    assert (l_200 == &l_87.f2 || l_200 == &l_79);
    return l_320;
    /* statement id: 213 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_59(int32_t * p_60, uint32_t  p_61, int32_t * p_62, int32_t  p_63, float  p_64)
{ /* block id: 143 */
    int32_t l_196 = 5;
    int32_t *l_195 = &l_196;
    int32_t *l_197 = (void*)0;
    (*p_62) = 0x2F2754ED;
    return l_197;
    /* statement id: 145 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_65(float  p_66, float  p_67, int32_t  p_68)
{ /* block id: 124 */
    uint32_t l_185 = 0U;
    const union U0 *l_186 = (void*)0;
    int32_t l_192 = (-2);
    int32_t *l_191 = &l_192;
    int32_t *l_193 = (void*)0;
    for (p_68 = 28; (p_68 > 17); p_68--)
    { /* block id: 127 */
        int32_t *l_175 = (void*)0;
        int32_t **l_174 = &l_175;
        int32_t l_176 = 0;
        (*l_174) = &p_68;
        /* statement id: 128 */
        assert (l_175 == &p_68);
        for (l_176 = 9; (l_176 == 20); l_176++)
        { /* block id: 131 */
            const int32_t ***l_179 = (void*)0;
            int32_t ***l_180 = (void*)0;
            int32_t * const *l_182 = (void*)0;
            int32_t * const **l_181 = &l_182;
            (*l_181) = &l_175;
            /* statement id: 132 */
            assert (l_182 == &l_175);
        }
        for (l_176 = 23; (l_176 <= (-8)); l_176--)
        { /* block id: 136 */
            float l_190 = (-0x6.0p+1);
            float *l_189 = &l_190;
            (*l_174) = &p_68;
            (*l_189) = (((((0x1.7p+1 < l_185) != (((-0x1.Dp-1) > (l_186 != (void*)0)) > __builtin_parityll((**l_174)))) == p_68) < ((float)p_67 + (float)0xA.469999p+79)) <= p_66);
        }
        (*l_174) = &p_68;
    }
    return l_193;
    /* statement id: 142 */
    //assert (func_65_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_69(float  p_70, union U0  p_71, int32_t  p_72, int32_t  p_73, union U0  p_74)
{ /* block id: 49 */
    int32_t l_105 = 0;
    int32_t *l_115 = &l_105;
    int32_t **l_114 = &l_115;
    int32_t ***l_113 = &l_114;
    int32_t ****l_112 = &l_113;
    int32_t *l_171 = &l_105;
    if (((int32_t)(p_72 != p_71.f0) % (int32_t)p_72))
    { /* block id: 50 */
        int32_t *l_91 = (void*)0;
        int32_t **l_90 = &l_91;
        (*l_90) = (void*)0;
    }
    else
    { /* block id: 52 */
        uint16_t l_96 = 65526U;
        uint16_t l_106 = 1U;
        const int32_t *l_123 = &l_105;
        for (p_72 = (-21); (p_72 >= 29); ++p_72)
        { /* block id: 55 */
            uint32_t l_107 = 4294967294U;
            for (p_73 = 23; (p_73 != 18); p_73--)
            { /* block id: 58 */
                int32_t ***l_111 = (void*)0;
                int32_t ****l_110 = &l_111;
            }
        }
        if ((p_73 ^ (((*l_115) >= ((uint16_t)(((****l_112) >= (***l_113)) != p_73) << (uint16_t)9)) ^ (__builtin_ctzll((****l_112)) && (((int16_t)p_72 << (int16_t)(*l_123)) >= (-6))))))
        { /* block id: 99 */
            int32_t *l_144 = &l_105;
            for (p_72 = 9; (p_72 >= 22); p_72++)
            { /* block id: 102 */
                uint16_t l_145 = 0xE843;
                l_144 = (void*)0;
                /* statement id: 103 */
                assert (l_144 == 0);
                l_145 = p_72;
                return p_72;
            }
            (*l_144) = (*l_144);
            (***l_112) = &p_73;
            /* statement id: 108 */
            assert (l_115 == &p_73);
        }
        else
        { /* block id: 109 */
            int32_t l_146 = 2;
            (***l_113) = l_146;
            (*l_114) = (void*)0;
            /* statement id: 111 */
            assert (l_115 == 0);
        }
        /* facts after branching */
        assert (l_115 == 0 || l_115 == &p_73);
        for (l_96 = 29; (l_96 <= 46); l_96++)
        { /* block id: 115 */
            int32_t ** const l_149 = &l_115;
            float *l_150 = (void*)0;
            float l_152 = 0x4.29FE0Dp-97;
            float *l_151 = &l_152;
            uint32_t l_160 = 4294967291U;
            int32_t *l_163 = &l_105;
            (*l_151) = (l_149 == (*l_113));
            (*l_151) = ((p_71.f0 < (+(&p_72 == (*l_149)))) <= ((((float)(p_70 == ((float)p_72 + (float)((-0x1.5p+1) > (__builtin_popcountl(__builtin_ffs((((uint16_t)5U << (uint16_t)9) | p_72))) != p_74.f0)))) + (float)(-0x1.Fp-1)) < 0x0.Ap+1) >= l_160));
            (*l_163) = ((uint16_t)p_71.f0 % (uint16_t)((*l_123) & p_71.f0));
            p_71.f0 = (((uint16_t)(&l_123 == (void*)0) >> (uint16_t)15) < ((uint32_t)p_73 - (uint32_t)((*l_163) ^ ((p_72 != ((p_73 & 4294967291U) && (((!((uint32_t)0x522A42F9 - (uint32_t)(*l_163))) && 4) || (*l_163)))) > p_72))));
        }
    }
    /* facts after branching */
    assert (l_115 == 0 || l_115 == &p_73 || l_115 == &l_105);
    (*l_114) = l_171;
    /* statement id: 122 */
    assert (l_115 == &l_105);
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_75(float  p_76, float  p_77, int32_t  p_78)
{ /* block id: 41 */
    int32_t l_82 = 0x02F603F5;
    int32_t *l_81 = &l_82;
    int32_t **l_80 = &l_81;
    const int32_t ***l_83 = (void*)0;
    union U0 l_86 = {0x91165901};
    l_80 = l_80;
    for (p_78 = 7; (p_78 <= 3); p_78 -= 4)
    { /* block id: 45 */
        (*l_80) = &p_78;
        /* statement id: 46 */
        assert (l_81 == &p_78);
    }
    /* facts after for loop */
    assert (l_81 == &p_78 || l_81 == &l_82);
    return l_86;
    /* statement id: 48 */
    }




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 118
XXX total union variables: 15

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 6
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 36
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 47

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 24, occurrence: 1
   depth: 28, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 126

XXX times a variable address is taken: 119
XXX times a pointer is dereferenced on RHS: 68
breakdown:
   depth: 1, occurrence: 34
   depth: 2, occurrence: 9
   depth: 3, occurrence: 10
   depth: 4, occurrence: 13
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 80
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 11
   depth: 3, occurrence: 8
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 335

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 232
   level: 2, occurrence: 43
   level: 3, occurrence: 60
   level: 4, occurrence: 48
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 55
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.2
XXX average alias set size: 1.23

XXX times a non-volatile is read: 666
XXX times a non-volatile is write: 236
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 71
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 17
   depth: 2, occurrence: 18
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 16.7
XXX percentage an existing variable is used: 83.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

