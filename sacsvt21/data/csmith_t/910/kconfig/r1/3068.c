/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3232753624
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int32_t  f0;
   int32_t  f1;
   int32_t  f2;
   unsigned f3 : 22;
   int32_t  f4;
   int32_t  f5;
   const uint32_t  f6;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_1(void);
inline static int8_t  func_10(uint32_t  p_11, uint32_t  p_12, uint32_t  p_13);
inline static int32_t  func_27(int32_t  p_28, uint16_t  p_29, uint32_t  p_30, uint16_t  p_31);
static int16_t  func_34(struct S0  p_35);
inline static struct S0  func_36(uint8_t  p_37, struct S0  p_38, int16_t  p_39);
static int32_t * func_51(uint32_t  p_52, struct S0  p_53, int32_t * p_54);
static struct S0  func_55(int32_t * p_56, int32_t * p_57, uint8_t  p_58);
inline static int32_t * func_59(int32_t * p_60);
static uint16_t  func_65(const uint8_t  p_66, int32_t  p_67, uint32_t  p_68, int32_t  p_69, uint32_t  p_70);
static int32_t * func_75(int32_t * p_76, int32_t * p_77, uint32_t  p_78, const int32_t  p_79, int8_t  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_1(void)
{ /* block id: 0 */
    int16_t l_14 = 0;
    int32_t l_1095 = 0xE78E6680;
    int32_t *l_1094 = &l_1095;
    int32_t **l_1093 = &l_1094;
    int32_t *** const l_1092 = &l_1093;
    int32_t *** const *l_1091 = &l_1092;
    uint32_t l_1130 = 0xF68ACCDE;
    struct S0 *l_1158 = (void*)0;
    struct S0 **l_1157 = &l_1158;
    struct S0 ***l_1156 = &l_1157;
    int32_t l_1168 = 1;
    int8_t l_1169 = 8;
    int16_t l_1176 = 0x2383;
    struct S0 l_1177 = {8,9,-2,1172,-1,0x30B50C17,0x4AAD9E47};
    if ((safe_add_func_int32_t_s_s(((1U == (safe_rshift_func_int8_t_s_u(((safe_add_func_int16_t_s_s(((safe_lshift_func_int8_t_s_u((func_10(l_14, l_14, l_14) <= 0xE1), l_14)) <= l_14), (l_14 > 0U))) ^ l_14), 2))) | l_14), l_14)))
    { /* block id: 514 */
        int32_t **l_1111 = (void*)0;
        struct S0 ****l_1159 = &l_1156;
        for (l_14 = (-4); (l_14 < (-13)); l_14 = safe_sub_func_int16_t_s_s(l_14, 1))
        { /* block id: 517 */
            int16_t l_1097 = 0x599F;
            int32_t l_1117 = 0x7A4F1807;
            uint32_t l_1133 = 0x0FA97124;
            (****l_1091) = (safe_mod_func_uint32_t_u_u((((void*)0 == l_1091) >= (safe_unary_minus_func_int16_t_s(l_1097))), (safe_lshift_func_uint8_t_u_s(l_1097, ((safe_add_func_int32_t_s_s(0xA4C00BD5, ((safe_sub_func_uint16_t_u_u((***l_1092), 0x2F02)) && (***l_1092)))) != ((safe_rshift_func_uint8_t_u_s(l_1097, 7)) && (-5)))))));
            for (l_1095 = 0; (l_1095 != (-14)); l_1095 = safe_sub_func_int16_t_s_s(l_1095, 7))
            { /* block id: 521 */
                int32_t l_1131 = 9;
                int32_t l_1132 = 0xB8A47DF0;
                int16_t l_1153 = 0x664E;
                int16_t l_1154 = 0xF1FC;
                for (l_1097 = 0; (l_1097 >= 25); ++l_1097)
                { /* block id: 524 */
                    int32_t l_1110 = 0xD670A49B;
                    int32_t ***l_1118 = &l_1111;
                    if ((*l_1094))
                    { /* block id: 525 */
                        int32_t l_1113 = 0xCBF8AC64;
                        int32_t *l_1112 = &l_1113;
                        struct S0 l_1115 = {0x05592108,1,0x0F1D5F24,424,0x4FB69E4C,0x90196065,4294967295U};
                        struct S0 *l_1114 = &l_1115;
                        struct S0 **l_1116 = &l_1114;
                        if (l_1110)
                            break;
                        (*l_1112) = (((void*)0 == l_1111) != 65535U);
                        (*l_1116) = l_1114;
                    }
                    else
                    { /* block id: 529 */
                        uint32_t l_1121 = 0xDCDD349C;
                        l_1117 = (****l_1091);
                        l_1132 = ((((((void*)0 == l_1118) || (-1)) < (l_1121 < ((((safe_sub_func_uint8_t_u_u(0xBC, ((((safe_mod_func_uint16_t_u_u(0xDC89, ((safe_rshift_func_int8_t_s_s((safe_rshift_func_int8_t_s_s(l_1130, 6)), 1)) && l_1131))) >= l_1131) > l_1131) && l_1097))) == l_1121) ^ 0xB1) >= 0xEC4A7A93))) ^ l_1097) <= l_1117);
                        l_1133 = ((*l_1118) == (void*)0);
                    }
                    l_1132 = (-10);
                }
                for (l_1097 = (-18); (l_1097 == (-21)); l_1097 = safe_sub_func_uint16_t_u_u(l_1097, 8))
                { /* block id: 538 */
                    int16_t l_1138 = 0xF781;
                    int32_t l_1155 = 9;
                    l_1155 = (safe_mul_func_int8_t_s_s(l_1138, ((l_1131 | ((safe_mod_func_uint8_t_u_u(l_1097, l_1138)) > (((void*)0 == l_1111) | (safe_mod_func_int32_t_s_s((((safe_div_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s(l_1132, ((safe_div_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((((safe_sub_func_int16_t_s_s((**l_1093), (-1))) > l_1153) || (*l_1094)), (**l_1093))), l_1153)) | 0xEEFD))), l_1154)) >= 0x7F32) <= (**l_1093)), (*l_1094)))))) >= l_1132)));
                    if (l_1117)
                        break;
                }
            }
        }
        (*l_1159) = l_1156;
        (**l_1092) = (**l_1092);
        for (l_1095 = 0; (l_1095 == (-6)); l_1095 = safe_sub_func_uint8_t_u_u(l_1095, 3))
        { /* block id: 548 */
            int32_t l_1162 = 0xB0F058F8;
            if (l_1162)
                break;
        }
    }
    else
    { /* block id: 551 */
        uint32_t l_1165 = 4294967295U;
        const struct S0 l_1173 = {1,-1,1,1038,-1,0xAACB8848,1U};
        const struct S0 *l_1172 = &l_1173;
        const struct S0 **l_1171 = &l_1172;
        const struct S0 ***l_1170 = &l_1171;
        struct S0 ****l_1174 = &l_1156;
        int32_t *l_1175 = &l_1095;
        (*l_1094) = (((safe_add_func_int16_t_s_s((l_1165 & ((****l_1091) < ((0x9BF70FEC > 0x376D7576) | (safe_add_func_int8_t_s_s(l_1165, ((*l_1094) ^ ((l_1168 || ((0U != (l_1165 && (****l_1091))) == l_1165)) & (-1)))))))), (***l_1092))) > l_1169) == 0x553A);
        (*l_1174) = l_1170;
        /* statement id: 553 */
        assert (l_1156 == &l_1171);
        (*l_1093) = l_1175;
    }
    /* facts after branching */
    //assert (l_1156 == dangling || l_1156 == &l_1157);
    (****l_1091) = l_1176;
    return l_1177;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_10(uint32_t  p_11, uint32_t  p_12, uint32_t  p_13)
{ /* block id: 1 */
    int16_t l_25 = 0x66AC;
    int32_t l_26 = (-1);
    struct S0 l_46 = {-10,0xFC71010F,1,937,0xFD9132E8,0x24086237,0xDC4EA3C9};
    uint16_t l_900 = 65535U;
    int32_t *l_999 = (void*)0;
    int32_t * const *l_998 = &l_999;
    int32_t * const **l_997 = &l_998;
    int32_t * const ***l_996 = &l_997;
    int32_t **l_1035 = &l_999;
    int32_t ***l_1034 = &l_1035;
lbl_1032:
    if ((((safe_rshift_func_int16_t_s_s((((safe_rshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s((safe_add_func_uint8_t_u_u(((l_25 < ((-9) && ((l_25 < ((l_26 || ((func_27(l_26, ((safe_lshift_func_uint8_t_u_s(l_26, 7)) == (3 ^ func_34(func_36(((!p_12) & (safe_div_func_int32_t_s_s((safe_lshift_func_int8_t_s_u((safe_unary_minus_func_int16_t_s(0xCA8B)), l_26)), 0xA7E8B7DD))), l_46, l_25)))), l_46.f1, l_900) < l_46.f1) & l_46.f1)) ^ l_46.f4)) <= l_46.f1))) > 0xC0D3A071), p_11)), p_12)), 13)), l_26)) < 0x9A48) > 0xD47C), 15)) >= 0xA682) > (-6)))
    { /* block id: 466 */
        int32_t *l_992 = &l_26;
        l_26 = l_900;
        (*l_992) = (p_12 >= p_13);
        (*l_992) = (*l_992);
    }
    else
    { /* block id: 470 */
        int8_t l_993 = 0;
        l_26 = l_993;
    }
    for (p_11 = 0; (p_11 > 54); ++p_11)
    { /* block id: 475 */
        int32_t *l_1003 = &l_46.f2;
        uint32_t l_1012 = 0U;
        int32_t **l_1030 = &l_1003;
        int32_t ***l_1029 = &l_1030;
        int32_t **** const l_1028 = &l_1029;
        int32_t **** const *l_1027 = &l_1028;
        int8_t l_1031 = 0xAF;
        int32_t l_1033 = 0;
        if (l_46.f6)
        { /* block id: 476 */
            uint32_t l_1000 = 0x5ABDA1F2;
            int32_t *l_1013 = &l_46.f5;
            if (((0xA93C && (p_13 | p_12)) | ((void*)0 != l_996)))
            { /* block id: 477 */
                int16_t l_1002 = 0;
                int32_t ***l_1015 = (void*)0;
                int32_t ****l_1014 = &l_1015;
                int32_t *****l_1016 = &l_1014;
                l_1000 = 0xDF2FF8DB;
                l_1003 = func_51((~l_1002), func_55(l_1003, func_59(&l_26), ((safe_mod_func_uint16_t_u_u((safe_add_func_uint8_t_u_u((p_13 && (((((((-8) ^ (l_1000 || (safe_rshift_func_uint16_t_u_s((((((safe_mod_func_int8_t_s_s(p_11, p_12)) >= (*l_1003)) && l_1000) > 0xE2CE2F25) <= 0xDBF9), 14)))) == l_1002) & l_1000) > 4294967286U) > (-1)) < p_13)), p_12)), l_1002)) < l_1012)), l_1013);
                /* statement id: 479 */
                assert (l_1003 == 0);
                (*l_1016) = l_1014;
            }
            else
            { /* block id: 481 */
                int32_t * const **l_1024 = &l_998;
                int32_t **l_1025 = (void*)0;
                int32_t **l_1026 = &l_1003;
                (*l_1003) = (0U == (0xCBA3 & (safe_unary_minus_func_uint32_t_u(((((safe_sub_func_uint16_t_u_u((0x26D7 && (safe_add_func_uint16_t_u_u(((void*)0 == (**l_997)), 0xB869))), ((0 | (*l_1013)) < (safe_lshift_func_uint16_t_u_s(((((l_1024 != (*l_996)) < 0xA021) <= p_12) != p_12), 9))))) <= p_11) | 253U) || p_13)))));
                (*l_1026) = (void*)0;
                /* statement id: 483 */
                assert (l_1003 == 0);
                (*l_1013) = (((((void*)0 == l_1027) >= p_13) && ((void*)0 != (*l_1027))) | l_1031);
            }
            /* facts after branching */
            assert (l_1003 == 0);
            if (l_46.f5)
                goto lbl_1032;
        }
        else
        { /* block id: 487 */
            uint16_t l_1040 = 0x2572;
            if (l_1033)
                break;
            l_1034 = (*l_1028);
            /* statement id: 489 */
            assert (l_1034 == &l_1030);
            for (l_1033 = (-17); (l_1033 >= (-1)); ++l_1033)
            { /* block id: 492 */
                int32_t * const ***l_1043 = &l_997;
                int32_t l_1046 = 0xA1B18BB3;
                (***l_1034) = (safe_rshift_func_int16_t_s_s(l_1040, 2));
                (***l_1028) = func_75((*l_1035), (*l_1035), (0x01247C24 || (((safe_add_func_int16_t_s_s((l_1043 == (void*)0), l_1040)) ^ p_12) | ((((safe_mod_func_int16_t_s_s((((((*l_996) != (void*)0) ^ 0xF6) == 0U) & l_1046), (****l_1028))) | (-7)) == 0) == l_1040))), p_13, (***l_1034));
                /* statement id: 494 */
                assert (l_1003 == &l_46.f2 || l_1003 == 0 || l_1003 == &l_26);
                return p_13;
            }
        }
        /* facts after branching */
        //assert (l_1034 == &l_1030 || l_1034 == dangling || l_1034 == &l_1035);
        assert (l_1003 == &l_46.f2 || l_1003 == 0);
        if (((0x7BA8 | 65535U) || (((safe_add_func_int16_t_s_s(((safe_sub_func_int16_t_s_s(p_13, p_11)) != p_11), p_11)) != p_12) & (safe_unary_minus_func_uint8_t_u((1U ^ (safe_rshift_func_int8_t_s_s((safe_mod_func_uint16_t_u_u(((p_13 < p_11) > 1U), p_13)), 0))))))))
        { /* block id: 498 */
            int32_t l_1056 = 0x92494B5C;
            l_1056 = ((&l_1028 == (void*)0) && l_1056);
        }
        else
        { /* block id: 500 */
            struct S0 *l_1062 = &l_46;
            const int32_t ***l_1082 = (void*)0;
            int32_t l_1083 = 0;
            int32_t *l_1086 = &l_46.f5;
            if (p_12)
            { /* block id: 501 */
                int32_t *l_1059 = &l_26;
                (*l_1059) = (safe_lshift_func_uint8_t_u_u(1U, 5));
                (*l_1035) = l_1059;
                /* statement id: 503 */
                assert (l_999 == &l_26);
                (*l_1030) = (*l_1035);
                /* statement id: 504 */
                assert (l_1003 == &l_26);
            }
            else
            { /* block id: 505 */
                int32_t ****l_1061 = &l_1034;
                int32_t *****l_1060 = &l_1061;
                struct S0 **l_1063 = &l_1062;
                (*l_1060) = (void*)0;
                /* statement id: 506 */
                assert (l_1061 == 0);
                (*l_1063) = l_1062;
            }
            /* facts after branching */
            assert (l_1003 == &l_46.f2 || l_1003 == 0 || l_1003 == &l_26);
            (*l_1086) = (((safe_lshift_func_int16_t_s_u(0xA481, 2)) == (safe_rshift_func_int8_t_s_s((((safe_rshift_func_int16_t_s_s((~((((safe_add_func_int8_t_s_s((safe_rshift_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((~0xB3E01154), ((-9) & (safe_add_func_uint32_t_u_u(((safe_rshift_func_uint8_t_u_s((((l_1082 != (*l_996)) & p_12) || l_1083), (safe_sub_func_uint32_t_u_u(p_11, (p_13 != p_13))))) <= 0x0D), 0x74EAA668))))), 5)), p_12)) & p_11) > p_13) < p_11)), p_12)) > 0U) || 3U), 5))) > p_13);
            (*l_1035) = (*l_1030);
        }
        /* facts after branching */
        assert (l_1003 == &l_46.f2 || l_1003 == 0 || l_1003 == &l_26);
    }
    return p_12;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_27(int32_t  p_28, uint16_t  p_29, uint32_t  p_30, uint16_t  p_31)
{ /* block id: 428 */
    int32_t l_902 = (-4);
    int32_t *l_901 = &l_902;
    uint32_t l_910 = 0x8FBCE68F;
    int32_t **l_911 = &l_901;
    struct S0 l_913 = {-5,1,-1,230,0x413ABFC2,0xA3055544,0U};
    struct S0 *l_912 = &l_913;
    struct S0 **l_914 = &l_912;
    int32_t ** const *l_947 = &l_911;
    int32_t ** const **l_946 = &l_947;
    int8_t l_991 = 0x02;
    (*l_911) = func_75(func_59(l_901), l_901, (l_901 != l_901), ((((p_31 > (safe_sub_func_int32_t_s_s((((safe_sub_func_uint8_t_u_u((safe_add_func_int8_t_s_s(p_28, ((!(l_910 == 0U)) < 0x35))), p_31)) == p_28) || 255U), 0))) <= p_31) | p_28) && p_30), p_30);
    (*l_914) = l_912;
    if ((((*l_914) != (*l_914)) || ((*l_914) != (*l_914))))
    { /* block id: 431 */
        struct S0 l_916 = {0x265154DF,0x658F677D,0x59C7A112,1583,0,0x1138A716,0xECE996C4};
        struct S0 *l_915 = &l_916;
        (*l_901) = (p_29 || (**l_911));
        l_915 = (*l_914);
        /* statement id: 433 */
        assert (l_915 == &l_913);
    }
    else
    { /* block id: 434 */
        uint32_t l_919 = 3U;
        struct S0 **l_927 = (void*)0;
        int32_t *l_928 = &l_913.f5;
        int32_t ***l_945 = &l_911;
        int32_t ****l_944 = &l_945;
        if (((safe_add_func_uint8_t_u_u(((-6) > (*l_901)), (((void*)0 != &l_911) | l_919))) < ((((~(safe_mod_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u((l_919 == p_28), 3)), (safe_sub_func_int16_t_s_s((l_927 == l_927), (*l_901)))))) >= 1U) != p_28) | l_919)))
        { /* block id: 435 */
            int32_t *l_929 = &l_913.f5;
            uint32_t l_948 = 0U;
            (**l_911) = l_919;
            (***l_946) = func_75(l_928, l_929, p_29, ((safe_lshift_func_int16_t_s_s((safe_rshift_func_int8_t_s_s(p_28, ((p_30 <= (safe_lshift_func_int8_t_s_s((((safe_sub_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s((*l_928), 9)), (safe_lshift_func_uint16_t_u_s((((safe_rshift_func_int8_t_s_s((p_30 != ((l_944 == l_946) ^ 0xFD3A)), 1)) ^ 0x0D) || (***l_945)), p_29)))) != p_29) >= (-1)), l_948))) >= 0x92549AC3))), (*l_928))) > (*l_929)), (****l_946));
            /* statement id: 437 */
            assert (l_901 == &l_913.f5);
            (*l_945) = (**l_944);
            for (l_913.f4 = 0; (l_913.f4 <= (-23)); l_913.f4 = safe_sub_func_int32_t_s_s(l_913.f4, 1))
            { /* block id: 441 */
                uint32_t l_951 = 0xB5668006;
                (**l_945) = func_75((**l_947), (***l_944), p_31, ((*l_929) ^ ((****l_944) & (-7))), p_28);
                if (l_951)
                    break;
            }
        }
        else
        { /* block id: 445 */
            const struct S0 *l_955 = &l_913;
            const struct S0 **l_954 = &l_955;
            const struct S0 ***l_953 = &l_954;
            const struct S0 ****l_952 = &l_953;
            int32_t l_966 = 0xC61F4A5C;
            (*l_946) = (*l_944);
            (*l_952) = &l_927;
            /* statement id: 447 */
            assert (l_953 == &l_927);
            (***l_946) = (***l_946);
            for (l_910 = 13; (l_910 == 5); l_910 = safe_sub_func_uint32_t_u_u(l_910, 2))
            { /* block id: 451 */
                int8_t l_964 = 0xCB;
                int32_t *****l_965 = &l_944;
                l_966 = ((safe_add_func_uint16_t_u_u((((safe_rshift_func_uint16_t_u_s(8U, (0x8A3C < (*l_901)))) || p_30) < (0xE27485B7 && (*l_901))), (((safe_lshift_func_int16_t_s_u((l_964 | (((((void*)0 != l_965) & 1U) >= p_29) < p_28)), l_966)) == p_28) > p_30))) & (****l_946));
                for (p_30 = 29; (p_30 == 11); p_30 = safe_sub_func_int16_t_s_s(p_30, 4))
                { /* block id: 455 */
                    (****l_946) = p_28;
                    if (p_29)
                        continue;
                    return l_966;
                }
                (*l_901) = (((safe_rshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_s(((*l_901) == 0U), (***l_945))), (safe_mod_func_int32_t_s_s((safe_rshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s((***l_947), (safe_mod_func_uint32_t_u_u((((***l_947) == 0x6B) ^ ((l_927 == (**l_952)) & (*l_928))), 4294967295U)))), l_966)), 0x3F105920)))) != 0x6D54) <= p_30);
                (*****l_965) = (safe_div_func_int8_t_s_s(((((safe_add_func_uint32_t_u_u(0x5F81CDD1, (safe_add_func_int8_t_s_s((((**l_965) == (void*)0) <= 0xDA), ((void*)0 == (*l_946)))))) ^ (-5)) | ((safe_mod_func_int8_t_s_s((safe_add_func_uint32_t_u_u(p_30, (0xAB33 & p_30))), 0x4F)) ^ (****l_944))) < p_28), (*****l_965)));
            }
        }
        /* facts after branching */
        assert (l_901 == &l_902 || l_901 == &l_913.f5);
    }
    /* facts after branching */
    assert (l_901 == &l_902 || l_901 == &l_913.f5);
    return l_991;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_34(struct S0  p_35)
{ /* block id: 4 */
    int32_t *l_81 = (void*)0;
    uint32_t l_842 = 0x66AE9F17;
    struct S0 l_857 = {0xAB720FC4,1,0xB8EADA78,1321,0x79310B8B,0x14273065,0xB918475E};
    const struct S0 *l_856 = &l_857;
    const struct S0 **l_855 = &l_856;
    struct S0 **** const l_870 = (void*)0;
    for (p_35.f5 = 22; (p_35.f5 < (-10)); p_35.f5 = safe_sub_func_int8_t_s_s(p_35.f5, 6))
    { /* block id: 7 */
        int32_t l_62 = 0x59FB14BE;
        int32_t *l_61 = &l_62;
        int32_t l_793 = 0;
        uint32_t l_799 = 3U;
        int32_t **l_813 = &l_81;
        int32_t ***l_812 = &l_813;
        int32_t l_819 = 0xD1587DE0;
        for (p_35.f2 = 9; (p_35.f2 > 16); p_35.f2 = safe_add_func_int16_t_s_s(p_35.f2, 9))
        { /* block id: 10 */
            int32_t *l_82 = (void*)0;
            const int32_t *l_786 = &l_62;
            const int32_t **l_785 = &l_786;
            int32_t ****l_817 = &l_812;
            (*l_785) = func_51(p_35.f6, func_55(func_59(l_61), l_61, p_35.f4), l_81);
            /* statement id: 332 */
            assert (l_786 == 0);
            (*l_785) = (void*)0;
            for (l_62 = 0; (l_62 == (-16)); l_62--)
            { /* block id: 336 */
                const int32_t l_789 = (-1);
                int32_t *l_798 = &l_793;
                if (l_789)
                { /* block id: 337 */
                    for (p_35.f1 = 0; (p_35.f1 > 2); p_35.f1 = safe_add_func_int8_t_s_s(p_35.f1, 5))
                    { /* block id: 340 */
                        uint16_t l_792 = 65530U;
                        (*l_785) = l_81;
                        l_793 = l_792;
                        if (p_35.f6)
                            break;
                    }
                }
                else
                { /* block id: 345 */
                    uint8_t l_797 = 0xD3;
                    for (p_35.f4 = (-17); (p_35.f4 > (-15)); p_35.f4 = safe_add_func_int16_t_s_s(p_35.f4, 7))
                    { /* block id: 348 */
                        int32_t l_796 = (-1);
                        return l_796;
                    }
                    if (l_797)
                        break;
                }
                (*l_798) = p_35.f4;
            }
        }
    }
    for (p_35.f5 = 0; (p_35.f5 >= (-20)); p_35.f5 = safe_sub_func_int16_t_s_s(p_35.f5, 2))
    { /* block id: 386 */
        struct S0 l_831 = {0x34D95118,-2,2,766,0xCC87E2F8,0,1U};
        struct S0 *l_830 = &l_831;
        int32_t **l_841 = &l_81;
        struct S0 **l_848 = &l_830;
        struct S0 ***l_847 = &l_848;
        uint16_t l_897 = 65530U;
        int32_t ***l_899 = &l_841;
        int32_t **** const l_898 = &l_899;
    }
    return p_35.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_36(uint8_t  p_37, struct S0  p_38, int16_t  p_39)
{ /* block id: 2 */
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_51(uint32_t  p_52, struct S0  p_53, int32_t * p_54)
{ /* block id: 324 */
    int32_t l_757 = (-4);
    int32_t *l_756 = &l_757;
    struct S0 *l_779 = (void*)0;
    struct S0 **l_778 = &l_779;
    int32_t l_781 = 0;
    uint32_t l_782 = 4294967295U;
    int32_t *l_784 = (void*)0;
    for (p_53.f4 = 0; (p_53.f4 > 12); p_53.f4 = safe_add_func_uint32_t_u_u(p_53.f4, 2))
    { /* block id: 327 */
        struct S0 **l_763 = (void*)0;
        struct S0 ***l_762 = &l_763;
        int32_t l_764 = 0xE42344F4;
        int16_t l_780 = 0x9657;
        int32_t *l_783 = &l_764;
        p_54 = func_75(func_75(l_756, p_54, (safe_add_func_uint8_t_u_u(0U, p_53.f2)), (((safe_div_func_int16_t_s_s(p_52, ((l_762 != (void*)0) & l_764))) > (safe_add_func_int8_t_s_s(p_52, (-1)))) < l_764), l_764), p_54, p_53.f1, (*l_756), p_53.f2);
        /* statement id: 328 */
        assert (p_54 == &l_757);
        l_783 = func_75(p_54, p_54, ((l_764 | ((safe_sub_func_uint8_t_u_u(((safe_add_func_uint8_t_u_u((((p_52 | p_53.f2) | (((-2) & ((safe_lshift_func_int16_t_s_s((0x95 <= (*l_756)), (safe_lshift_func_uint16_t_u_s((safe_div_func_int8_t_s_s((~((((l_778 == (void*)0) && (*l_756)) || l_780) & (*l_756))), 0x21)), p_53.f6)))) ^ l_781)) < p_52)) & 7U), p_53.f2)) & (*l_756)), 0xCF)) >= p_52)) & l_782), (*l_756), l_780);
        /* statement id: 329 */
        assert (l_783 == &l_757);
    }
    /* facts after for loop */
    //assert (p_54 == &l_757 || p_54 == 0 || p_54 == &l_46.f5);
    return l_784;
    /* statement id: 331 */
    //assert (func_51_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_55(int32_t * p_56, int32_t * p_57, uint8_t  p_58)
{ /* block id: 221 */
    int32_t l_489 = 2;
    int32_t * const l_488 = &l_489;
    int32_t * const *l_487 = &l_488;
    struct S0 l_499 = {-1,-1,0xFB32BE0F,2009,4,-6,1U};
    struct S0 *l_498 = &l_499;
    struct S0 **l_497 = &l_498;
    struct S0 * const *l_503 = &l_498;
    struct S0 * const **l_502 = &l_503;
    int32_t l_675 = 0xEE59BB50;
    int16_t l_688 = (-2);
    struct S0 l_753 = {0x853BB1EF,1,1,1575,0xD89FAE1A,0x119B0AC9,0U};
lbl_696:
    (*l_488) = ((((p_58 == p_58) || (&p_56 == l_487)) <= (0x15 ^ (safe_sub_func_uint16_t_u_u((!0), p_58)))) || (safe_div_func_int8_t_s_s((safe_lshift_func_uint8_t_u_s(((void*)0 != l_497), p_58)), (-7))));
    if ((*l_488))
    { /* block id: 223 */
        const int32_t *l_501 = (void*)0;
        const int32_t **l_500 = &l_501;
        struct S0 ***l_505 = &l_497;
        struct S0 ****l_504 = &l_505;
        uint32_t l_614 = 3U;
        uint16_t l_617 = 0x136A;
        uint32_t l_676 = 9U;
        int32_t l_713 = 0x69E44E88;
        uint8_t l_717 = 0xCC;
        int32_t *l_718 = &l_499.f5;
        int16_t l_722 = 0x6EFE;
        (*p_56) = (-4);
        (*l_500) = p_57;
        /* statement id: 225 */
        //assert (l_501 == &l_62 || l_501 == &l_489 || l_501 == &l_26);
        (*l_504) = l_502;
        /* statement id: 226 */
        assert (l_505 == &l_503);
        if ((((!p_58) || ((**l_487) & (safe_rshift_func_uint16_t_u_s((safe_div_func_uint16_t_u_u((p_58 >= (!p_58)), 0x599E)), (((*l_503) != (*l_497)) != ((**l_500) || ((!p_58) && (**l_487)))))))) & (*p_56)))
        { /* block id: 227 */
            const int32_t *l_515 = &l_499.f5;
            struct S0 ***l_520 = &l_497;
            (*l_488) = (safe_add_func_int16_t_s_s((((*l_504) != &l_503) != (248U | 0x34)), (**l_500)));
            (*l_500) = l_515;
            /* statement id: 229 */
            assert (l_501 == &l_499.f5);
            (*p_56) = ((safe_div_func_int16_t_s_s(((((safe_div_func_int16_t_s_s(0, 0x3F15)) ^ (l_520 == (*l_504))) > (*l_488)) & ((((0xECBDFCB6 && ((void*)0 != l_515)) <= ((safe_sub_func_uint16_t_u_u((p_58 && (**l_500)), 1U)) <= 6U)) | (*l_488)) >= (*l_515))), 0x0E60)) & p_58);
        }
        else
        { /* block id: 231 */
            int16_t l_540 = 9;
            struct S0 *l_562 = &l_499;
            int16_t l_635 = 0x31AC;
            int32_t *** const l_693 = (void*)0;
            int32_t *** const *l_692 = &l_693;
            struct S0 ****l_733 = &l_505;
            if (((**l_500) || (safe_lshift_func_uint16_t_u_u(((void*)0 == (*l_505)), 14))))
            { /* block id: 232 */
                struct S0 **l_539 = (void*)0;
                for (p_58 = 0; (p_58 <= 36); p_58 = safe_add_func_int16_t_s_s(p_58, 1))
                { /* block id: 235 */
                    int32_t *l_528 = (void*)0;
                    int32_t **l_527 = &l_528;
                    struct S0 **l_550 = &l_498;
                    (*l_527) = (*l_487);
                    /* statement id: 236 */
                    assert (l_528 == &l_489);
                    (*l_500) = func_75(p_56, p_56, (safe_rshift_func_uint8_t_u_u((safe_add_func_uint16_t_u_u((((**l_487) || (&p_57 != (void*)0)) && (*p_56)), ((void*)0 == &l_527))), 4)), (safe_rshift_func_int8_t_s_u(((safe_add_func_uint16_t_u_u((l_539 == l_539), 0xE496)) > (-1)), 5)), l_540);
                    /* statement id: 237 */
                    //assert (l_501 == &l_62 || l_501 == &l_46.f2);
                    for (l_499.f4 = 0; (l_499.f4 < 6); l_499.f4 = safe_add_func_uint16_t_u_u(l_499.f4, 1))
                    { /* block id: 240 */
                        struct S0 *l_558 = &l_499;
                        uint32_t l_561 = 0xEE54826B;
                        (*p_56) = (-6);
                        (**l_487) = (safe_lshift_func_uint8_t_u_s((~(safe_sub_func_int16_t_s_s((safe_sub_func_uint8_t_u_u(((void*)0 == p_56), p_58)), (l_540 || ((l_550 != (*l_505)) & (p_58 && (p_58 ^ ((safe_div_func_uint8_t_u_u(p_58, 0x23)) < p_58)))))))), 7));
                        (**l_527) = ((~(safe_add_func_int8_t_s_s(9, ((((safe_rshift_func_int16_t_s_s((l_558 == (*l_550)), (249U < (safe_lshift_func_uint8_t_u_s(l_540, 1))))) && (l_561 | (l_562 != (void*)0))) < (safe_div_func_int8_t_s_s((6 & p_58), (*l_488)))) > (*l_528))))) ^ (*l_528));
                    }
                }
                /* facts after for loop */
                //assert (l_501 == &l_62 || l_501 == &l_489 || l_501 == &l_46.f2 || l_501 == &l_26);
                (*l_500) = p_56;
                /* statement id: 246 */
                //assert (l_501 == &l_62 || l_501 == &l_46.f2);
                (*l_500) = p_56;
                (*l_500) = func_59(p_57);
                /* statement id: 248 */
                //assert (l_501 == &l_62 || l_501 == &l_489 || l_501 == &l_26);
            }
            else
            { /* block id: 249 */
                int32_t *l_573 = &l_499.f2;
                int32_t **l_572 = &l_573;
                int32_t ***l_571 = &l_572;
                int32_t * const * const *l_596 = &l_487;
                struct S0 l_601 = {0xC9CC4180,0xE379746D,0x20CB603B,816,-1,-7,4294967286U};
                for (l_499.f4 = 3; (l_499.f4 == 1); l_499.f4--)
                { /* block id: 252 */
                    struct S0 l_567 = {0x860C42AC,0x3BEA1271,0x8A5C257B,1218,0x4FC96F67,-9,0x0550F208};
                    return l_567;
                }
                (*l_500) = func_59(p_57);
                if ((~(((safe_sub_func_uint32_t_u_u((l_540 == (p_58 > p_58)), ((l_571 != (void*)0) <= (safe_sub_func_uint16_t_u_u(((0xA103 || (**l_572)) ^ (safe_sub_func_uint32_t_u_u((!(0x64A7 != (safe_sub_func_int16_t_s_s(((safe_mod_func_int32_t_s_s((((safe_mod_func_uint8_t_u_u(p_58, 0xDF)) & 4) && (*l_501)), p_58)) || l_540), (*l_501))))), (*p_57)))), 0x98F1))))) || 255U) & 254U)))
                { /* block id: 256 */
                    uint8_t l_595 = 0x3C;
                    if ((safe_lshift_func_int16_t_s_s(((0xBA > (safe_lshift_func_int16_t_s_u(p_58, p_58))) <= (((p_58 || (248U >= p_58)) >= ((l_540 != (safe_sub_func_uint16_t_u_u((p_58 & ((safe_add_func_uint8_t_u_u(l_595, l_595)) < p_58)), p_58))) < 65533U)) != l_540)), 2)))
                    { /* block id: 257 */
                        (**l_571) = p_57;
                        /* statement id: 258 */
                        //assert (l_573 == &l_62 || l_573 == &l_489 || l_573 == &l_26);
                        p_57 = (*l_487);
                        /* statement id: 259 */
                        assert (p_57 == &l_489);
                        (**l_487) = ((0 >= 4294967295U) && 0xCEE95F5B);
                    }
                    else
                    { /* block id: 261 */
                        int32_t ** const *l_598 = &l_572;
                        int32_t ** const **l_597 = &l_598;
                        (*l_597) = l_596;
                        /* statement id: 262 */
                        assert (l_598 == &l_487);
                    }
                    /* facts after branching */
                    //assert (l_573 == &l_499.f2 || l_573 == &l_62 || l_573 == &l_489 || l_573 == &l_26);
                }
                else
                { /* block id: 264 */
                    for (l_499.f1 = 0; (l_499.f1 <= (-26)); l_499.f1 = safe_sub_func_int8_t_s_s(l_499.f1, 1))
                    { /* block id: 267 */
                        return l_601;
                    }
                }
                /* facts after branching */
                //assert (l_573 == &l_499.f2 || l_573 == &l_62 || l_573 == &l_489 || l_573 == &l_26);
                (***l_571) = ((safe_div_func_uint16_t_u_u(3U, (**l_487))) & p_58);
            }
            (*p_56) = (safe_rshift_func_int8_t_s_s((safe_mod_func_int32_t_s_s((safe_add_func_uint16_t_u_u(((safe_sub_func_int8_t_s_s((&l_502 == &l_505), (!253U))) && 0U), ((~0x6C06) <= ((0x6E7423A7 < 0x8EE9ED2F) | ((0xFC != p_58) ^ l_614))))), (**l_500))), 4));
            (*p_57) = (p_58 | 0);
            if ((l_540 & ((safe_sub_func_int8_t_s_s(((0x99 || (l_617 ^ 0x43447322)) | (safe_mod_func_uint32_t_u_u((l_540 && (p_58 & 0x9036A033)), (safe_rshift_func_int16_t_s_s(((safe_div_func_uint32_t_u_u((0 & ((0 >= (**l_487)) < p_58)), 0xD105AE72)) ^ l_540), p_58))))), (**l_487))) & 0x094387CD)))
            { /* block id: 275 */
                uint32_t l_634 = 2U;
                struct S0 l_655 = {-1,-8,0xE2448264,548,1,0xD8A54C4F,0x27D33028};
                int32_t *l_679 = &l_499.f5;
                int32_t ***l_695 = (void*)0;
                int32_t ****l_694 = &l_695;
                if ((((safe_sub_func_uint8_t_u_u(p_58, (safe_add_func_int8_t_s_s((*l_488), ((*l_488) && (p_58 > (l_540 <= (((safe_div_func_int8_t_s_s(((safe_lshift_func_uint8_t_u_u((safe_add_func_int8_t_s_s((*l_488), l_540)), 7)) || (l_634 && (l_634 ^ l_635))), p_58)) && p_58) && (*l_488))))))))) >= (*p_56)) ^ p_58))
                { /* block id: 276 */
                    struct S0 **l_650 = &l_562;
                    (*p_57) = (((l_540 ^ ((safe_div_func_int16_t_s_s(0x501F, (safe_add_func_int8_t_s_s((safe_sub_func_int32_t_s_s((*p_57), (safe_mod_func_int8_t_s_s(((safe_mod_func_int8_t_s_s(((((safe_rshift_func_int16_t_s_u((-10), ((safe_sub_func_int8_t_s_s(((-7) ^ (l_650 == (*l_502))), (safe_sub_func_int8_t_s_s((*l_501), (((safe_rshift_func_int16_t_s_u((l_540 || p_58), 14)) != (*p_56)) == 0xFFD2F16D))))) && 0x8A))) >= p_58) && p_58) ^ 0x25), l_634)) == 0x73A1), p_58)))), p_58)))) == 0U)) ^ (**l_500)) < p_58);
                }
                else
                { /* block id: 278 */
                    (*l_500) = p_57;
                    return l_655;
                }
                (*l_488) = 0xF1B8DFB3;
                l_655.f2 = ((safe_add_func_int32_t_s_s((safe_lshift_func_int8_t_s_u(p_58, (p_58 < (safe_mod_func_uint16_t_u_u((p_58 <= (0x6D612AFB && (safe_unary_minus_func_uint32_t_u((l_655.f5 >= (safe_div_func_int8_t_s_s((safe_rshift_func_uint8_t_u_u((safe_sub_func_int16_t_s_s((*l_501), (safe_sub_func_int32_t_s_s((((*l_501) || (0xE5 ^ (((safe_div_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((((*l_488) >= p_58) & l_675), p_58)), 0xB50D)) < 0x096C) | (*p_56)))) & 9U), 0x933AEB0E)))), 2)), p_58))))))), l_676))))), l_655.f0)) || 0x20);
                for (l_540 = (-5); (l_540 <= 14); ++l_540)
                { /* block id: 286 */
                    int32_t *l_680 = &l_489;
                    (*l_500) = func_75(l_679, l_680, p_58, p_58, p_58);
                    /* statement id: 287 */
                    assert (l_501 == &l_499.f5);
                    if ((*p_56))
                    { /* block id: 288 */
                        struct S0 l_681 = {1,0x65170448,1,817,0xFC8FB8F4,-7,0x4924959F};
                        (*l_497) = l_562;
                        return l_681;
                    }
                    else
                    { /* block id: 291 */
                        struct S0 *l_691 = (void*)0;
                        (*l_500) = p_56;
                        /* statement id: 292 */
                        //assert (l_501 == &l_62 || l_501 == &l_46.f2);
                        (*p_57) = (safe_rshift_func_int16_t_s_s((((safe_sub_func_int32_t_s_s((safe_unary_minus_func_uint32_t_u((~(l_688 ^ p_58)))), (safe_sub_func_int32_t_s_s((*l_680), ((***l_504) == l_691))))) == (l_692 == l_694)) && 0x19B0), (*l_488)));
                        if (l_617)
                            goto lbl_696;
                    }
                    /* facts after branching */
                    //assert (l_501 == &l_62 || l_501 == &l_46.f2);
                    if ((*p_57))
                        continue;
                }
                /* facts after for loop */
                //assert (l_501 == &l_62 || l_501 == &l_489 || l_501 == &l_46.f2 || l_501 == &l_26);
            }
            else
            { /* block id: 298 */
                int8_t l_716 = 0xDB;
                if ((0xC95DFDBF <= ((((safe_rshift_func_int8_t_s_s(((safe_lshift_func_uint16_t_u_u(((safe_mul_func_uint16_t_u_u(((((safe_lshift_func_int16_t_s_u((safe_sub_func_uint32_t_u_u((*l_501), (safe_sub_func_uint32_t_u_u(p_58, ((((void*)0 != (*l_692)) < (safe_sub_func_uint32_t_u_u((safe_add_func_uint32_t_u_u((l_713 < ((4 & (safe_sub_func_int8_t_s_s(((**l_487) ^ p_58), 255U))) != 0x05)), p_58)), 0xDC892A78))) <= (**l_487)))))), (*l_488))) || l_716) || 0x11C6) < 0xCB61A0A4), 0U)) ^ p_58), 12)) & l_717), p_58)) >= 0xAF2D04DB) | p_58) != 246U)))
                { /* block id: 299 */
                    int16_t l_719 = 5;
                    int32_t **l_736 = &l_718;
                    int32_t ***l_735 = &l_736;
                    int32_t ****l_734 = &l_735;
                    int32_t * const ****l_737 = (void*)0;
                    int32_t * const **l_740 = &l_487;
                    int32_t * const ***l_739 = &l_740;
                    int32_t * const ****l_738 = &l_739;
                    (*l_500) = func_59(func_59(func_59(l_718)));
                    /* statement id: 300 */
                    assert (l_501 == &l_499.f5);
                    (*l_718) = (((l_719 < ((((safe_mod_func_uint16_t_u_u(0x97ED, l_722)) ^ (*p_56)) && (p_58 <= (safe_rshift_func_int8_t_s_u((safe_add_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((safe_add_func_int16_t_s_s((safe_div_func_uint32_t_u_u((*l_488), l_719)), ((l_733 != (void*)0) > 7))) <= 5), l_716)), p_58)), p_58)))) & 0xF3)) ^ 0) || p_58);
                    (*l_738) = l_734;
                    /* statement id: 302 */
                    assert (l_739 == &l_735);
                    (*l_736) = p_56;
                    /* statement id: 303 */
                    //assert (l_718 == &l_62 || l_718 == &l_46.f2);
                }
                else
                { /* block id: 304 */
                    int8_t l_743 = 0x31;
                    struct S0 **l_744 = &l_498;
                    for (l_614 = 27; (l_614 > 22); l_614 = safe_sub_func_int8_t_s_s(l_614, 9))
                    { /* block id: 307 */
                        if ((**l_487))
                            break;
                        (*l_718) = (*l_488);
                        (*l_488) = (l_743 || ((**l_733) != l_744));
                    }
                    (*l_488) = ((p_58 && (p_57 == p_56)) & ((void*)0 != (*l_505)));
                    (*l_500) = func_59(p_56);
                    /* statement id: 313 */
                    //assert (l_501 == &l_62 || l_501 == &l_46.f2);
                }
                /* facts after branching */
                //assert (l_501 == &l_62 || l_501 == &l_499.f5 || l_501 == &l_46.f2);
                //assert (l_718 == &l_499.f5 || l_718 == &l_62 || l_718 == &l_46.f2);
                (*l_718) = (safe_sub_func_uint32_t_u_u(8U, (safe_rshift_func_int16_t_s_u(l_716, (((*p_57) || (((*l_504) != (*l_504)) != (*p_57))) >= 0xFD2CBEBA)))));
                (*l_500) = p_56;
                /* statement id: 316 */
                //assert (l_501 == &l_62 || l_501 == &l_46.f2);
            }
            /* facts after branching */
            //assert (l_501 == &l_62 || l_501 == &l_489 || l_501 == &l_46.f2 || l_501 == &l_26);
            //assert (l_718 == &l_499.f5 || l_718 == &l_62 || l_718 == &l_46.f2);
        }
        /* facts after branching */
        //assert (l_501 == &l_62 || l_501 == &l_489 || l_501 == &l_499.f5 || l_501 == &l_46.f2 || l_501 == &l_26);
        //assert (l_718 == &l_499.f5 || l_718 == &l_62 || l_718 == &l_46.f2);
    }
    else
    { /* block id: 319 */
        int32_t *l_750 = (void*)0;
        int32_t **l_749 = &l_750;
        const struct S0 **l_751 = (void*)0;
        struct S0 **l_752 = &l_498;
        (*l_749) = p_56;
        /* statement id: 320 */
        //assert (l_750 == &l_62 || l_750 == &l_46.f2);
        (*l_752) = (**l_502);
    }
    return l_753;
}


/* ------------------------------------------ */
/* 
 * reads : l_62 l_26 l_46.f2
 * writes: l_62 l_26 l_46.f2
 */
inline static int32_t * func_59(int32_t * p_60)
{ /* block id: 11 */
    int32_t l_72 = (-3);
    const int32_t *l_71 = &l_72;
    uint8_t l_74 = 0x16;
    (*p_60) = (p_60 != (void*)0);
    (*p_60) = ((safe_add_func_int16_t_s_s((((void*)0 != p_60) < (((func_65((l_71 == &l_72), (*l_71), (*l_71), (*p_60), (*l_71)) || l_74) && (*l_71)) != 0x10E9FB38)), 65535U)) & (*l_71));
    return p_60;
    /* statement id: 17 */
    //assert (func_59_rv == &l_62 || func_59_rv == &l_113 || func_59_rv == &l_144 || func_59_rv == &l_499.f5 || func_59_rv == &l_489 || func_59_rv == &l_902 || func_59_rv == &l_26 || func_59_rv == &l_46.f2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_65(const uint8_t  p_66, int32_t  p_67, uint32_t  p_68, int32_t  p_69, uint32_t  p_70)
{ /* block id: 13 */
    int32_t l_73 = 0x5FFFC42E;
    p_69 = l_73;
    return l_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_75(int32_t * p_76, int32_t * p_77, uint32_t  p_78, const int32_t  p_79, int8_t  p_80)
{ /* block id: 18 */
    uint32_t l_86 = 0x3C7198F9;
    int32_t l_113 = (-9);
    int32_t *l_112 = &l_113;
    const int16_t l_154 = 0x3709;
    uint32_t l_155 = 4294967287U;
    int32_t *l_239 = &l_113;
    const int32_t *l_259 = &l_113;
    int32_t l_331 = 4;
    const int8_t l_349 = (-3);
    int32_t **l_381 = &l_112;
    int32_t ***l_380 = &l_381;
    if (l_86)
    { /* block id: 19 */
        int16_t l_108 = 1;
        int32_t l_131 = 0xE9A18863;
        int32_t **l_134 = &l_112;
        for (p_80 = 0; (p_80 >= 9); p_80 = safe_add_func_uint16_t_u_u(p_80, 4))
        { /* block id: 22 */
            int8_t l_109 = 0x41;
        }
        (**l_134) = ((l_131 ^ (((void*)0 == p_76) != (p_79 & ((safe_mod_func_uint32_t_u_u((((void*)0 == p_77) != (0 | ((l_108 && (((void*)0 != l_134) >= 0)) < (**l_134)))), (*l_112))) & 0xD133FD70)))) <= p_79);
        (*l_134) = (void*)0;
        /* statement id: 36 */
        assert (l_112 == 0);
        l_112 = func_59(&l_113);
        /* statement id: 37 */
        assert (l_112 == &l_113);
    }
    else
    { /* block id: 38 */
        uint8_t l_137 = 248U;
        int32_t l_144 = 8;
        int32_t **l_153 = (void*)0;
        const int32_t *l_260 = &l_113;
        uint32_t l_386 = 4294967286U;
        const int32_t l_462 = 0xD93E56EB;
        int32_t l_463 = 0x6F01627E;
    }
    return p_76;
    /* statement id: 220 */
    //assert (func_75_rv == &l_62 || func_75_rv == &l_499.f5 || func_75_rv == &l_757 || func_75_rv == &l_793 || func_75_rv == 0 || func_75_rv == &l_831.f2 || func_75_rv == &l_902 || func_75_rv == &l_913.f5 || func_75_rv == &l_46.f2 || func_75_rv == &l_26);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 223
   depth: 1, occurrence: 7
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 44
breakdown:
   indirect level: 0, occurrence: 7
   indirect level: 1, occurrence: 14
   indirect level: 2, occurrence: 11
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 23
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 25
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 9

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 197
   depth: 2, occurrence: 35
   depth: 3, occurrence: 5
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 6
   depth: 15, occurrence: 3
   depth: 16, occurrence: 5
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 4
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 33, occurrence: 1

XXX total number of pointers: 215

XXX times a variable address is taken: 208
XXX times a pointer is dereferenced on RHS: 240
breakdown:
   depth: 1, occurrence: 184
   depth: 2, occurrence: 35
   depth: 3, occurrence: 12
   depth: 4, occurrence: 8
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 158
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 16
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 74
XXX times a pointer is compared with address of another variable: 19
XXX times a pointer is compared with another pointer: 22
XXX times a pointer is qualified to be dereferenced: 808

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 952
   level: 2, occurrence: 199
   level: 3, occurrence: 62
   level: 4, occurrence: 33
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 129
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 20.5
XXX average alias set size: 1.42

XXX times a non-volatile is read: 1412
XXX times a non-volatile is write: 438
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 6

XXX stmts: 179
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 29
   depth: 2, occurrence: 30
   depth: 3, occurrence: 39
   depth: 4, occurrence: 29
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

