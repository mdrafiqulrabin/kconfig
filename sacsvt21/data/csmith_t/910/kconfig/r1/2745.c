/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3236530472
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 2;
   signed f1 : 15;
   signed f2 : 21;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 0xE87DF2F4;
static struct S0 g_80 = {0,27,259};
static uint32_t g_384 = 0x729D3353;
static int16_t g_385 = 0x743C;
static struct S0 g_490 = {-1,-56,-1019};


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_27(void);
static int16_t  func_35(int32_t  p_36, struct S0  p_37);
static int32_t  func_40(uint16_t  p_41, uint32_t  p_42);
static uint16_t  func_43(uint16_t  p_44);
static int32_t  func_47(int16_t  p_48, int16_t  p_49, int32_t  p_50, struct S0  p_51, struct S0  p_52);
static uint32_t  func_55(int32_t  p_56, uint16_t  p_57, int32_t  p_58, struct S0  p_59, struct S0  p_60);
static int32_t  func_63(uint16_t  p_64, int32_t  p_65);
static int16_t  func_67(int32_t  p_68, uint32_t  p_69);
static uint32_t  func_72(int32_t  p_73, struct S0  p_74);
static int32_t  func_85(int16_t  p_86, uint32_t  p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_80 g_384 g_385 g_490
 * writes: g_80.f0 g_80.f1 g_80.f2 g_80 g_384 g_385 g_490 g_3
 */
static uint32_t  func_27(void)
{ /* block id: 36 */
    uint32_t l_38 = 0xC57F39CE;
    struct S0 l_39 = {-0,-172,-796};
    int16_t l_578 = 1;
    int32_t l_604 = 0;
    uint32_t l_633 = 0x79553E0E;
    if ((-(int16_t)(((int32_t)(((((-3) ^ ((int32_t)(~(0x9576 == (~func_35(l_38, l_39)))) + (int32_t)((uint16_t)(~g_3) >> (uint16_t)l_39.f2))) | l_39.f1) ^ ((int16_t)((((uint16_t)(func_63(g_3, g_3) & g_3) << (uint16_t)8) <= l_578) && g_3) >> (int16_t)g_3)) != l_39.f1) + (int32_t)l_38) >= l_578)))
    { /* block id: 344 */
        uint16_t l_583 = 1U;
        int32_t l_607 = 1;
        struct S0 l_628 = {0,-98,109};
        for (g_385 = (-9); (g_385 >= 23); g_385 += 1)
        { /* block id: 347 */
            uint32_t l_581 = 0U;
            int32_t l_582 = 2;
            l_582 = l_581;
            if (((l_583 < ((((int16_t)0x720F >> (int16_t)1) <= l_583) || (1U == l_583))) & (__builtin_ctzl(g_490.f1) < l_582)))
            { /* block id: 349 */
                return g_80.f1;
            }
            else
            { /* block id: 351 */
                uint32_t l_586 = 0xDBB41DC9;
                int32_t l_596 = 0x782E7FEB;
                int16_t l_618 = 0x08DB;
                if ((l_586 > __builtin_ffsl(((uint16_t)(0x380E || g_385) >> (uint16_t)(l_586 >= l_581)))))
                { /* block id: 352 */
                    int32_t l_595 = 0x2B09AE77;
                    l_596 = ((((uint16_t)g_490.f2 - (uint16_t)((int32_t)g_384 + (int32_t)(g_385 || ((uint16_t)l_595 >> (uint16_t)10)))) && ((func_47(g_384, g_80.f2, l_595, g_80, g_80) != 0x296F36FB) ^ g_490.f2)) || g_80.f1);
                }
                else
                { /* block id: 354 */
                    int32_t l_599 = 0x32E502DC;
                    for (l_578 = 0; (l_578 > (-12)); l_578 -= 1)
                    { /* block id: 357 */
                        l_599 = 0x890F276A;
                        l_39.f2 = 1;
                        if (l_583)
                            break;
                        if (g_80.f1)
                            continue;
                    }
                    if (l_599)
                        continue;
                }
                l_607 = (g_490.f2 && ((uint16_t)((int16_t)l_604 << (int16_t)(g_490.f1 >= g_3)) + (uint16_t)((uint32_t)g_3 % (uint32_t)g_80.f2)));
                l_39.f0 = (func_47(l_596, ((uint32_t)(g_490.f0 < ((int32_t)(l_39.f2 | ((__builtin_parityll(l_607) > g_490.f2) ^ (g_80.f1 | 0x23654E69))) + (int32_t)l_596)) + (uint32_t)7), l_581, l_39, g_490) || 6);
                l_607 = ((l_39.f2 >= __builtin_ffs(g_80.f0)) | __builtin_parityl((((int32_t)(((((g_490.f1 & (g_490.f0 >= l_604)) != (g_80.f0 || ((uint32_t)(((int16_t)g_490.f0 >> (int16_t)12) && (g_490.f1 == 1)) - (uint32_t)l_618))) == g_490.f1) < l_586) >= l_583) + (int32_t)l_582) | l_596)));
            }
            for (l_581 = (-13); (l_581 > 19); l_581 += 1)
            { /* block id: 371 */
                if (g_80.f2)
                    break;
                if (g_490.f0)
                    break;
            }
            g_490.f1 = ((uint16_t)((int32_t)(((-10) > ((((!(1 < l_39.f0)) || ((uint16_t)func_43((((l_607 ^ func_47(g_385, g_385, g_490.f2, l_39, g_80)) | l_583) & l_583)) >> (uint16_t)2)) | l_604) | 0xDC637B55)) >= 0x3DA583C4) - (int32_t)4294967292U) >> (uint16_t)l_583);
        }
        l_628 = g_490;
    }
    else
    { /* block id: 378 */
        struct S0 l_631 = {-1,-80,-1330};
        for (g_3 = 0; (g_3 < 24); g_3 += 7)
        { /* block id: 381 */
            l_631 = l_631;
            l_631 = l_39;
        }
        l_631.f2 = 0xC76B76D2;
        if (g_80.f0)
        { /* block id: 386 */
            int16_t l_632 = (-10);
            g_80.f1 = l_632;
        }
        else
        { /* block id: 388 */
            int32_t l_634 = 0;
            l_633 = l_39.f2;
            g_490 = g_80;
            l_634 = g_490.f0;
            g_490 = g_490;
        }
    }
    return g_490.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_80 g_384 g_385 g_490
 * writes: g_80.f0 g_80.f1 g_80.f2 g_80 g_384 g_385 g_490
 */
static int16_t  func_35(int32_t  p_36, struct S0  p_37)
{ /* block id: 37 */
    uint32_t l_66 = 4294967295U;
    struct S0 l_489 = {-0,42,913};
    l_489.f1 = (func_40(func_43(((g_3 & 4294967295U) <= ((-(uint16_t)((-(int32_t)func_47((p_37.f1 & ((int16_t)(func_55(((int16_t)((((func_63(p_37.f1, (l_66 || func_67(((uint16_t)(func_72(((uint16_t)(((int32_t)__builtin_clz(g_3) - (int32_t)(!l_66)) | p_37.f2) + (uint16_t)g_3), g_80) || g_80.f2) - (uint16_t)g_384), l_66))) <= 4294967291U) ^ g_3) <= g_3) >= l_66) >> (int16_t)4), g_385, p_36, l_489, g_490) == g_3) << (int16_t)p_37.f1)), l_489.f2, p_36, g_490, p_37)) == g_3)) > p_37.f1))), p_37.f1) == p_37.f2);
    p_37.f2 = 0;
    p_37.f2 = ((int16_t)l_489.f1 - (int16_t)(0U != (((uint16_t)func_63((0x9B59 >= (((uint16_t)((7 | func_72((((uint16_t)g_80.f0 << (uint16_t)9) < ((int32_t)2 % (int32_t)((int16_t)((int16_t)(((int16_t)g_490.f0 << (int16_t)((int16_t)g_385 + (int16_t)(((p_37.f2 && l_489.f0) >= p_36) == l_489.f0))) || g_80.f0) >> (int16_t)p_36) - (int16_t)l_489.f0))), p_37)) <= l_489.f1) - (uint16_t)0x4144) || p_37.f0)), g_490.f0) + (uint16_t)(-1)) & p_37.f1)));
    for (g_385 = 0; (g_385 != 17); g_385 += 1)
    { /* block id: 331 */
        uint32_t l_559 = 2U;
        int32_t l_570 = (-1);
        g_490.f1 = ((((-6) == ((-5) != p_37.f2)) <= p_37.f1) ^ (4294967295U || ((0x5D88 != func_47(g_490.f2, (l_559 || ((65529U || p_37.f1) > 4294967295U)), l_489.f0, g_80, g_490)) == 65530U)));
        if ((l_489.f2 <= l_559))
        { /* block id: 333 */
            int16_t l_569 = 4;
            p_37.f0 = ((int16_t)__builtin_clzll((4294967295U <= (((uint16_t)(0x61598BFD <= ((int16_t)(-(uint16_t)((uint32_t)4294967295U % (uint32_t)g_3)) << (int16_t)12)) >> (uint16_t)g_384) || 1U))) >> (int16_t)6);
            l_569 = 0x430CDAC9;
            g_80.f0 = p_37.f2;
            l_570 = (g_3 | (0x102B47CC || p_36));
        }
        else
        { /* block id: 338 */
            l_489.f2 = g_384;
            p_36 = l_489.f1;
        }
    }
    return p_37.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_385 g_490
 * writes: g_385 g_490
 */
static int32_t  func_40(uint16_t  p_41, uint32_t  p_42)
{ /* block id: 310 */
    struct S0 l_534 = {0,133,-778};
    for (g_385 = (-6); (g_385 >= 28); g_385 += 1)
    { /* block id: 313 */
        struct S0 l_533 = {-0,-23,-579};
        l_534 = l_533;
        l_534 = g_490;
        if (l_534.f1)
            break;
    }
    l_534.f1 = p_42;
    for (p_42 = (-18); (p_42 > 3); p_42 += 3)
    { /* block id: 321 */
        return l_534.f0;
    }
    g_490 = g_490;
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads : g_385 g_3 g_490.f2
 * writes:
 */
static uint16_t  func_43(uint16_t  p_44)
{ /* block id: 305 */
    int32_t l_530 = 0x850474A2;
    l_530 = ((uint16_t)((!(g_385 ^ __builtin_clzl(l_530))) & g_490.f2) % (uint16_t)p_44);
    l_530 = l_530;
    l_530 = g_385;
    return l_530;
}


/* ------------------------------------------ */
/* 
 * reads : g_384 g_80.f1 g_80.f2 g_3 g_80.f0 g_385 g_80
 * writes: g_80.f0 g_384 g_80.f1 g_80.f2 g_80
 */
static int32_t  func_47(int16_t  p_48, int16_t  p_49, int32_t  p_50, struct S0  p_51, struct S0  p_52)
{ /* block id: 302 */
    p_52.f2 = (func_67(p_50, p_51.f2) || p_52.f0);
    return g_80.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_80.f0 g_3 g_80.f1 g_80 g_384 g_385 g_490
 * writes: g_80.f0 g_80.f1 g_80.f2 g_80 g_384 g_385
 */
static uint32_t  func_55(int32_t  p_56, uint16_t  p_57, int32_t  p_58, struct S0  p_59, struct S0  p_60)
{ /* block id: 272 */
    int32_t l_492 = 0;
    int32_t l_503 = 7;
    uint16_t l_526 = 0x1A8E;
    if (func_72(g_80.f0, p_59))
    { /* block id: 273 */
        struct S0 l_491 = {-0,30,1277};
        p_59 = g_490;
        l_491 = g_490;
        g_80.f0 = p_60.f1;
        l_492 = 0x076DD908;
    }
    else
    { /* block id: 278 */
        struct S0 l_493 = {-1,-63,-1071};
        l_493 = g_80;
        l_493.f1 = (((int16_t)p_58 + (int16_t)(0xF99A < ((uint32_t)l_492 + (uint32_t)(g_490.f0 | (-2))))) && (l_493.f1 <= 0x55A3));
    }
    for (g_384 = 0; (g_384 > 32); g_384 += 9)
    { /* block id: 284 */
        uint16_t l_500 = 0xC900;
        return l_500;
    }
    for (g_385 = 0; (g_385 >= (-25)); g_385 -= 9)
    { /* block id: 289 */
        int16_t l_504 = 0xB883;
        l_503 = g_384;
        return l_504;
    }
    for (l_492 = 0; (l_492 != (-24)); l_492 -= 1)
    { /* block id: 295 */
        uint16_t l_513 = 0x4EC6;
        if (g_80.f0)
            break;
        p_60.f1 = (0U <= (-1));
        p_59 = g_80;
        p_60.f2 = (0x2C87 & (((int16_t)((((uint16_t)(l_513 >= 0x5A64) + (uint16_t)(((uint16_t)p_59.f2 << (uint16_t)0) && (((uint32_t)(p_57 == ((int16_t)((uint16_t)((((__builtin_popcount((__builtin_popcountl(((__builtin_popcountll(g_490.f1) < func_63((((((uint32_t)(l_513 == ((int32_t)g_490.f2 + (int32_t)p_59.f2)) % (uint32_t)7) == g_490.f1) <= g_80.f1) > 4294967295U), p_60.f1)) == 4294967294U)) > p_59.f2)) & 0x8645) >= l_513) <= p_60.f0) | g_3) >> (uint16_t)l_503) - (int16_t)l_492)) + (uint32_t)l_503) == g_490.f0))) && l_526) == g_385) << (int16_t)2) != g_490.f2));
    }
    return l_492;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_63(uint16_t  p_64, int32_t  p_65)
{ /* block id: 269 */
    struct S0 l_488 = {-1,122,446};
    l_488 = l_488;
    return l_488.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_384 g_80.f1 g_80.f2 g_3 g_80.f0 g_385 g_80
 * writes: g_80.f0 g_384 g_80.f1 g_80.f2 g_80
 */
static int16_t  func_67(int32_t  p_68, uint32_t  p_69)
{ /* block id: 234 */
    uint32_t l_406 = 6U;
    int16_t l_413 = 0x2A54;
    int32_t l_428 = 0x50086035;
    int32_t l_472 = (-6);
    int32_t l_487 = 0xEFFF921C;
    g_80.f0 = p_68;
    for (g_384 = 0; (g_384 >= 24); g_384 += 6)
    { /* block id: 238 */
        return p_69;
    }
    l_406 = p_68;
    if (((g_384 ^ (((g_80.f1 > (l_406 == __builtin_ctzll(l_406))) > ((int16_t)((int16_t)0x52AF + (int16_t)((uint32_t)(((l_413 & (g_80.f2 != (g_80.f2 == g_80.f2))) | 0xD723) ^ g_384) % (uint32_t)(-1))) - (int16_t)4U)) < l_413)) || g_3))
    { /* block id: 242 */
        return p_68;
    }
    else
    { /* block id: 244 */
        uint32_t l_418 = 4294967288U;
        int32_t l_444 = 1;
        struct S0 l_449 = {0,68,779};
        l_428 = ((uint16_t)0xCAF5 - (uint16_t)((uint16_t)(l_418 | (l_418 ^ (((uint32_t)(l_418 && func_85((-(int32_t)__builtin_bswap64((((uint32_t)(l_418 ^ (__builtin_ctzl(l_406) != ((int16_t)g_3 % (int16_t)((int32_t)g_80.f0 % (int32_t)l_413)))) + (uint32_t)g_385) | p_68))), p_68)) % (uint32_t)0x8BA12700) | g_3))) - (uint16_t)g_3));
        for (l_418 = 0; (l_418 > 8); l_418 += 1)
        { /* block id: 248 */
            struct S0 l_437 = {-0,-173,844};
            g_80.f0 = ((int32_t)p_69 + (int32_t)(g_80.f1 <= ((((int32_t)p_69 - (int32_t)(0xA0033338 & ((uint32_t)((l_418 == p_69) == g_384) % (uint32_t)g_385))) <= p_69) >= l_418)));
            l_437 = g_80;
            l_437.f0 = ((uint32_t)(p_69 == (-8)) % (uint32_t)p_68);
        }
        for (l_406 = 0; (l_406 > 28); l_406 += 7)
        { /* block id: 255 */
            int32_t l_447 = 0xFF2E7E4A;
            uint32_t l_485 = 0x54AD161C;
            int16_t l_486 = 0;
            l_444 = ((uint16_t)g_80.f2 << (uint16_t)(p_69 & g_385));
            if ((((uint16_t)p_68 % (uint16_t)g_3) != l_447))
            { /* block id: 257 */
                struct S0 l_448 = {-1,-159,691};
                l_449 = l_448;
                l_449 = g_80;
                l_448.f2 = l_448.f1;
                l_448.f0 = ((~(((uint16_t)(((uint16_t)g_80.f2 >> (uint16_t)g_384) > 0xBCD0) + (uint16_t)(!((l_428 ^ ((((int16_t)((int16_t)(l_444 | l_406) + (int16_t)__builtin_bswap64(((int32_t)l_444 - (int32_t)((int32_t)l_447 - (int32_t)g_385)))) << (int16_t)g_3) == l_447) > 0x97E2)) || 0x8D2CDB75))) <= p_68)) >= p_69);
            }
            else
            { /* block id: 262 */
                l_449.f1 = ((uint32_t)((int16_t)g_80.f0 + (int16_t)__builtin_ffsll(p_68)) + (uint32_t)p_69);
            }
            l_487 = (((__builtin_parity(((int32_t)(((uint16_t)func_85(p_68, p_69) >> (uint16_t)l_472) >= l_418) + (int32_t)((((uint16_t)((((int16_t)((int32_t)(0x8F16 && (((int32_t)((int32_t)((uint16_t)p_69 % (uint16_t)l_447) + (int32_t)p_68) - (int32_t)p_68) != g_384)) % (int32_t)g_385) % (int16_t)l_472) ^ 0xD116) < 4294967290U) << (uint16_t)l_485) | g_385) != l_486))) >= g_385) > l_418) && l_485);
        }
    }
    return l_406;
}


/* ------------------------------------------ */
/* 
 * reads : g_80.f0 g_3 g_80.f1 g_80 g_384 g_385
 * writes: g_80.f0 g_80.f1 g_80.f2 g_80
 */
static uint32_t  func_72(int32_t  p_73, struct S0  p_74)
{ /* block id: 38 */
    int16_t l_82 = 0x3DF1;
    struct S0 l_220 = {-0,32,1377};
    int32_t l_252 = 0x2EF52723;
    int16_t l_264 = 0x3869;
    uint16_t l_272 = 1U;
    uint32_t l_306 = 0U;
    uint32_t l_327 = 0xE6DE127D;
    uint32_t l_359 = 4294967295U;
    int16_t l_403 = 0xE6EC;
    if ((-(uint32_t)((__builtin_ia32_crc32qi((g_80.f0 <= (__builtin_clzll(l_82) >= __builtin_ctzl(__builtin_parity(g_80.f1)))), (((((l_82 | 3) | (l_82 & p_74.f0)) <= g_80.f0) | g_80.f0) && 0x5039)) || 0x4791A13C) && 0x1739)))
    { /* block id: 39 */
        int32_t l_88 = (-2);
        int32_t l_194 = 1;
        uint32_t l_197 = 9U;
        struct S0 l_219 = {-0,70,-1238};
        for (p_73 = 0; (p_73 >= 4); p_73 += 1)
        { /* block id: 42 */
            int32_t l_103 = 0x3152899D;
            int16_t l_191 = 0x289A;
            struct S0 l_218 = {-1,146,-412};
            l_191 = __builtin_ia32_crc32qi((func_85(l_88, ((uint32_t)((((uint32_t)l_82 + (uint32_t)p_74.f1) > (((l_88 > (-(int32_t)(((!__builtin_clz((0x5AC29F8D || (((__builtin_popcountl((((uint16_t)(((((int16_t)g_80.f1 + (int16_t)p_74.f2) && (((int32_t)(p_74.f0 && ((uint16_t)(l_103 == p_74.f2) << (uint16_t)g_3)) - (int32_t)0) && 1)) < 0xD33F) | p_74.f2) % (uint16_t)g_3) != p_74.f1)) == l_82) && l_82) | 0x914B)))) != p_74.f0) & g_80.f1))) == p_74.f2) != l_103)) && g_80.f0) % (uint32_t)(-6))) != g_3), g_3);
            g_80.f2 = g_80.f2;
            if (l_82)
            { /* block id: 133 */
                l_194 = ((uint16_t)(7 ^ __builtin_clzll(p_73)) >> (uint16_t)p_74.f0);
            }
            else
            { /* block id: 135 */
                int16_t l_212 = 0x5E4C;
                struct S0 l_214 = {1,-16,-1100};
                l_103 = (p_74.f0 ^ p_74.f2);
                for (l_82 = (-25); (l_82 >= 17); l_82 += 1)
                { /* block id: 139 */
                    struct S0 l_198 = {-1,69,349};
                    if (g_80.f0)
                    { /* block id: 140 */
                        l_197 = 1;
                        g_80 = l_198;
                    }
                    else
                    { /* block id: 143 */
                        int16_t l_213 = 3;
                        g_80.f1 = __builtin_parity((((((~((int32_t)l_197 - (int32_t)((0x4AB7F0B0 == (0x151F != (((((int32_t)g_80.f0 + (int32_t)(((uint16_t)(((uint16_t)l_191 << (uint16_t)13) != ((int32_t)p_74.f1 % (int32_t)((uint32_t)(l_191 || (l_212 && 0x0974)) + (uint32_t)l_213))) + (uint16_t)g_3) != g_80.f0)) > p_74.f1) == 0xFBE2ECC4) & p_74.f1))) > l_103))) != g_3) == 0x79DF) ^ l_212) && p_74.f1));
                        g_80 = l_214;
                        g_80.f1 = ((!p_73) ^ (l_198.f2 != (((int16_t)(((p_74.f2 && p_74.f1) >= 1) || (p_73 < 0x7A68)) >> (int16_t)1) | p_73)));
                    }
                    g_80.f2 = p_74.f2;
                    l_218 = g_80;
                    p_74 = l_219;
                }
            }
            l_220 = g_80;
        }
    }
    else
    { /* block id: 155 */
        uint32_t l_225 = 0x62DCB01C;
        int32_t l_258 = 0x05B92934;
        struct S0 l_366 = {-0,-65,-645};
        if (((uint16_t)(((-6) == (g_80.f1 > (0xECD07D77 || 0x01DA8FA5))) ^ ((((uint16_t)((l_225 & ((uint32_t)(((int16_t)__builtin_clzll((((uint16_t)l_225 >> (uint16_t)1) ^ ((((int16_t)p_74.f0 << (int16_t)11) == __builtin_ctz(g_3)) > p_73))) >> (int16_t)5) > l_225) + (uint32_t)p_74.f2)) == 0x2756) << (uint16_t)p_73) & g_80.f2) == 0x4D15)) + (uint16_t)g_80.f2))
        { /* block id: 156 */
            int16_t l_238 = 0x18AA;
            int32_t l_243 = 0x9B1B637E;
            struct S0 l_254 = {1,-49,380};
            l_243 = ((uint32_t)func_85(((int16_t)0x308B << (int16_t)5), l_238) % (uint32_t)((uint32_t)((p_73 & l_225) != ((uint16_t)(p_74.f1 <= __builtin_ffs(((l_225 >= l_225) < p_74.f1))) >> (uint16_t)15)) % (uint32_t)g_3));
            l_252 = (0x5E15 | func_85((g_80.f1 < (p_74.f0 & (((uint16_t)((int16_t)g_3 + (int16_t)((uint16_t)(((int16_t)(0xC5EE > l_243) << (int16_t)7) && ((g_80.f2 != (4294967295U != 0x7C5E2B0F)) >= 2U)) % (uint16_t)p_74.f0)) << (uint16_t)14) || 0x54678E96))), p_73));
            if (__builtin_parity(p_74.f1))
            { /* block id: 159 */
                struct S0 l_253 = {1,-105,1062};
                p_74 = l_253;
            }
            else
            { /* block id: 161 */
                struct S0 l_255 = {0,-4,1047};
                l_255 = l_254;
                p_73 = ((func_85(((l_225 <= ((g_80.f2 >= (g_80.f1 ^ (p_73 >= ((int16_t)0xB2A5 % (int16_t)(g_80.f2 || l_220.f0))))) >= 0x03EE)) <= g_80.f1), l_258) && p_74.f2) & p_73);
            }
            g_80.f0 = p_74.f1;
        }
        else
        { /* block id: 166 */
            int32_t l_265 = 1;
            p_74.f0 = g_3;
            g_80 = p_74;
            l_220.f0 = (-(uint16_t)((uint16_t)g_3 << (uint16_t)(1 ^ ((int32_t)((((p_74.f1 | l_264) && 4U) <= l_265) > (((int16_t)l_225 - (int16_t)((((uint32_t)(((uint16_t)((l_258 != func_85(g_80.f2, l_272)) & 0xF0498DF5) << (uint16_t)g_3) ^ l_258) % (uint32_t)l_220.f0) >= p_73) | l_252)) >= p_73)) % (int32_t)g_3))));
            g_80.f0 = ((p_74.f0 > g_80.f0) || g_80.f2);
        }
        p_74.f2 = (((p_74.f2 | (__builtin_ia32_crc32qi(p_73, ((int16_t)((uint16_t)g_3 - (uint16_t)(func_85(((l_225 && ((uint16_t)g_3 << (uint16_t)13)) & ((-(int32_t)g_3) | ((int32_t)(((uint16_t)g_80.f0 << (uint16_t)5) < p_74.f2) - (int32_t)(((int16_t)0x1627 >> (int16_t)p_73) != l_225)))), g_80.f0) >= 0x93A66112)) + (int16_t)p_73)) != 0x1DA3)) > g_3) < 6U);
        g_80.f0 = (g_3 != ((int32_t)__builtin_ctzll(((((((int32_t)((((int16_t)(((-1) <= ((uint16_t)(((int32_t)(g_80.f1 != __builtin_clzll(g_80.f2)) - (int32_t)p_74.f2) && (0x4D117C2A != ((int16_t)__builtin_ctzll(p_74.f2) + (int16_t)g_3))) - (uint16_t)p_74.f2)) <= 0x6DA5) % (int16_t)g_80.f2) >= 0xD3FD) >= g_80.f2) - (int32_t)4294967291U) || (-7)) > p_73) || 0x8002) <= l_258)) + (int32_t)l_225));
        for (l_272 = 21; (l_272 <= 34); l_272 += 1)
        { /* block id: 176 */
            uint32_t l_328 = 0x68B0571D;
            int16_t l_337 = 0x3BC4;
            int32_t l_342 = 0x938994FF;
            int32_t l_351 = 0;
            struct S0 l_352 = {-1,-61,1223};
            int16_t l_386 = 0x4321;
            if (func_85(((4294967295U != 2U) && ((((((int32_t)(((uint32_t)(p_74.f2 != ((g_80.f0 && (p_73 <= (((((uint16_t)__builtin_popcountl(p_74.f0) - (uint16_t)(__builtin_parity(l_225) != g_3)) == 8) || g_80.f2) == p_74.f0))) == p_73)) % (uint32_t)g_80.f2) > g_80.f2) + (int32_t)p_74.f2) ^ 0) != g_80.f0) <= p_74.f1) < p_73)), l_306))
            { /* block id: 177 */
                uint32_t l_316 = 0x5B0EC12C;
                int32_t l_345 = 0xCF969432;
                if ((__builtin_bswap64(p_73) & (func_85((!p_74.f0), g_3) & 4)))
                { /* block id: 178 */
                    int16_t l_308 = 0;
                    return l_308;
                }
                else
                { /* block id: 180 */
                    int32_t l_315 = 1;
                    for (l_264 = 0; (l_264 < 23); l_264 += 1)
                    { /* block id: 183 */
                        l_316 = ((int32_t)(((int16_t)(func_85((p_74.f0 >= g_3), p_73) | (g_3 >= l_225)) >> (int16_t)4) >= (0x4E2D67D4 | __builtin_bswap64(l_315))) % (int32_t)0xEA5CE5B9);
                        g_80 = g_80;
                        g_80.f1 = 0;
                        g_80 = g_80;
                    }
                }
                if (((uint32_t)p_74.f1 % (uint32_t)((int32_t)g_80.f0 + (int32_t)(0xE697 & (((uint16_t)__builtin_ffsl((((int16_t)(((((uint16_t)65535U >> (uint16_t)4) > (l_327 < 0x3629)) >= g_3) || p_74.f2) >> (int16_t)p_74.f2) < g_80.f1)) % (uint16_t)l_328) || g_80.f2)))))
                { /* block id: 190 */
                    uint32_t l_329 = 0xDCDBF535;
                    int16_t l_349 = 0;
                    l_329 = g_3;
                    if (g_80.f2)
                        continue;
                    g_80.f2 = ((int32_t)(-(int16_t)(((0x18FD0311 > ((((((0U | p_74.f2) ^ p_73) < ((int32_t)(((int16_t)g_80.f1 + (int16_t)g_3) >= g_80.f2) - (int32_t)(0U == l_337))) >= p_73) & p_73) <= l_329)) ^ g_80.f1) ^ 1)) + (int32_t)(-1));
                    if ((p_73 <= (((__builtin_bswap64(((int32_t)(l_337 == l_316) - (int32_t)((uint16_t)(l_342 || g_80.f1) << (uint16_t)((int16_t)g_80.f2 - (int16_t)p_74.f1)))) && 5) & p_74.f2) | l_316)))
                    { /* block id: 194 */
                        return l_345;
                    }
                    else
                    { /* block id: 196 */
                        uint32_t l_350 = 4294967287U;
                        l_351 = ((uint16_t)((__builtin_ctzl(p_73) && (l_316 > (!((l_349 | (g_80.f2 < p_74.f1)) != (__builtin_ctzll((p_74.f0 || g_80.f1)) <= 0x8084))))) & l_350) << (uint16_t)p_74.f0);
                        l_352 = g_80;
                    }
                }
                else
                { /* block id: 200 */
                    uint16_t l_381 = 0x2DC9;
                    for (l_258 = (-10); (l_258 != (-17)); l_258 -= 1)
                    { /* block id: 203 */
                        p_74.f1 = (-1);
                        return p_74.f1;
                    }
                    for (l_327 = (-12); (l_327 > 9); l_327 += 9)
                    { /* block id: 209 */
                        l_220.f0 = (((int16_t)l_359 + (int16_t)(g_80.f2 <= __builtin_popcountll((l_225 && ((((uint16_t)0xBC3E + (uint16_t)(g_80.f1 && p_74.f2)) != g_80.f1) || ((int32_t)__builtin_parity(p_74.f0) % (int32_t)g_80.f2)))))) ^ g_80.f0);
                    }
                    for (l_264 = 9; (l_264 >= 24); l_264 += 1)
                    { /* block id: 214 */
                        p_74 = l_366;
                        l_366.f2 = ((uint32_t)((int16_t)((uint16_t)((int32_t)(((uint32_t)((func_85(g_3, (((((int16_t)5 >> (int16_t)15) < (((int16_t)l_381 << (int16_t)2) > (__builtin_ctzl(l_306) <= (((uint16_t)p_74.f0 >> (uint16_t)p_74.f0) >= g_384)))) <= (((g_80.f2 == 65535U) == g_385) & 0x1AFB)) && p_74.f0)) == g_385) & g_385) % (uint32_t)g_385) & g_3) % (int32_t)g_385) + (uint16_t)p_73) >> (int16_t)1) % (uint32_t)l_386);
                    }
                    p_74.f2 = l_366.f1;
                }
            }
            else
            { /* block id: 220 */
                for (l_328 = 0; (l_328 > 2); l_328 += 7)
                { /* block id: 223 */
                    return p_74.f1;
                }
                p_74.f0 = (~p_74.f1);
            }
            p_74 = p_74;
        }
    }
    l_220.f2 = (((((int32_t)l_82 - (int32_t)l_220.f2) >= 0x171D4F1D) != func_85((((0x4819 == g_80.f0) == ((uint16_t)((uint32_t)p_74.f1 + (uint32_t)(!l_220.f2)) >> (uint16_t)1)) > ((uint16_t)((int16_t)(p_73 & ((uint16_t)__builtin_ffs(p_74.f1) << (uint16_t)2)) >> (int16_t)l_220.f0) >> (uint16_t)7)), l_403)) ^ 8);
    g_80.f0 = (p_74.f2 && g_80.f2);
    return l_359;
}


/* ------------------------------------------ */
/* 
 * reads : g_80.f0 g_80.f1 g_3 g_80
 * writes: g_80.f0 g_80.f1 g_80.f2 g_80
 */
static int32_t  func_85(int16_t  p_86, uint32_t  p_87)
{ /* block id: 43 */
    int16_t l_108 = 0xF304;
    struct S0 l_190 = {0,174,-938};
    for (p_86 = 11; (p_86 < (-29)); p_86 -= 1)
    { /* block id: 46 */
        uint32_t l_115 = 0U;
        struct S0 l_164 = {-1,63,-300};
        if (((uint16_t)g_80.f0 + (uint16_t)(g_80.f0 && ((l_108 | ((uint16_t)p_86 % (uint16_t)(-8))) < ((int16_t)(((uint16_t)l_115 >> (uint16_t)13) & (((-1) < (-10)) < (g_80.f1 && p_86))) >> (int16_t)p_86)))))
        { /* block id: 47 */
            uint32_t l_118 = 4294967295U;
            int32_t l_128 = (-2);
            struct S0 l_143 = {1,-145,1291};
            if (((uint16_t)l_115 + (uint16_t)l_108))
            { /* block id: 48 */
                int32_t l_119 = 0x8FFE4DFD;
                struct S0 l_171 = {-0,155,-1107};
                if (g_3)
                { /* block id: 49 */
                    int32_t l_127 = 9;
                    struct S0 l_131 = {1,4,-478};
                    if (g_80.f1)
                    { /* block id: 50 */
                        l_119 = l_118;
                    }
                    else
                    { /* block id: 52 */
                        l_128 = ((int16_t)(((0U & p_86) >= (((uint16_t)((~l_127) > p_87) >> (uint16_t)12) > g_3)) & 0xCD8B) >> (int16_t)15);
                    }
                    g_80.f0 = (-3);
                    for (l_118 = 0; (l_118 != 46); l_118 += 1)
                    { /* block id: 58 */
                        l_131 = g_80;
                        l_119 = (p_87 || (((int16_t)(p_86 == ((0xFF75AEE6 & l_115) == ((uint16_t)(g_80.f1 == p_86) + (uint16_t)(-(int16_t)(-1))))) % (int16_t)(((l_119 != g_80.f0) == l_115) && g_80.f0)) >= g_80.f2));
                    }
                    l_128 = ((uint32_t)g_80.f1 + (uint32_t)(g_80.f1 >= p_86));
                }
                else
                { /* block id: 63 */
                    int32_t l_142 = 0xF9C57FF4;
                    for (p_87 = (-4); (p_87 < 20); p_87 += 1)
                    { /* block id: 66 */
                        int32_t l_141 = 1;
                        int32_t l_144 = 0x3FEA8E8E;
                        l_142 = ((p_86 < l_141) | g_3);
                        l_143 = g_80;
                        if (p_86)
                            continue;
                        l_144 = l_119;
                    }
                    if ((p_86 || p_86))
                    { /* block id: 72 */
                        int16_t l_149 = 3;
                        l_128 = ((uint16_t)((uint16_t)l_149 << (uint16_t)5) - (uint16_t)__builtin_bswap32(p_87));
                        l_142 = g_80.f2;
                        return g_80.f2;
                    }
                    else
                    { /* block id: 76 */
                        int16_t l_156 = (-1);
                        g_80.f1 = (((int16_t)((9U >= ((uint16_t)((((uint16_t)(((l_142 & l_128) <= ((g_3 & (((__builtin_ffsl(l_156) >= (~(((((4 >= ((uint16_t)((int16_t)((uint32_t)((p_86 && 0x8397) && l_156) - (uint32_t)4294967291U) - (int16_t)l_119) << (uint16_t)g_3)) <= p_86) < p_86) & 65535U) != l_119))) && 0x1D7E) || 0x3B8602F1)) <= 0x06A3)) || p_86) >> (uint16_t)12) > 0U) | g_3) >> (uint16_t)11)) < 0x79D12DC1) - (int16_t)l_143.f1) && p_86);
                        g_80.f2 = g_3;
                        if (p_87)
                            continue;
                        l_164 = g_80;
                    }
                }
                if ((g_80.f2 && 0x7632))
                { /* block id: 83 */
                    for (l_108 = 0; (l_108 < (-17)); l_108 -= 8)
                    { /* block id: 86 */
                        int32_t l_167 = 0x5DF1CAE4;
                        int32_t l_168 = 0;
                        g_80.f1 = g_80.f1;
                        l_164 = g_80;
                        l_143.f1 = p_87;
                        l_168 = l_167;
                    }
                    for (l_118 = 11; (l_118 <= 30); l_118 += 1)
                    { /* block id: 94 */
                        return p_86;
                    }
                    g_80.f2 = __builtin_ia32_crc32qi(p_87, l_128);
                }
                else
                { /* block id: 98 */
                    l_164.f1 = l_108;
                }
                if (p_86)
                    continue;
                g_80 = l_171;
            }
            else
            { /* block id: 103 */
                l_164 = l_143;
                return l_164.f0;
            }
            if (p_87)
                continue;
            g_80.f1 = (l_128 & (g_80.f2 != 0U));
        }
        else
        { /* block id: 109 */
            uint32_t l_184 = 0x899B1178;
            int32_t l_185 = (-7);
            g_80 = g_80;
            if ((-(int16_t)l_164.f0))
            { /* block id: 111 */
                uint32_t l_174 = 4294967287U;
                l_174 = (p_86 < (-(int32_t)(p_86 == 0xB52E)));
                l_184 = (-(uint16_t)((((g_80.f1 <= ((0xA99FBD2C < g_3) & 3)) != __builtin_ctz((__builtin_ctzl(g_3) || (((int16_t)((((uint32_t)((int16_t)(4294967290U >= (2 || ((int32_t)(g_3 > p_87) - (int32_t)p_87))) >> (int16_t)10) % (uint32_t)g_80.f1) > p_87) >= p_86) << (int16_t)g_80.f1) == g_80.f0)))) & g_3) & l_164.f0));
            }
            else
            { /* block id: 114 */
                g_80 = g_80;
                l_164.f2 = p_87;
            }
            if (l_184)
                break;
            l_185 = ((g_80.f2 ^ p_86) ^ g_80.f1);
        }
        l_164.f1 = l_108;
    }
    if ((p_86 >= p_87))
    { /* block id: 123 */
        struct S0 l_186 = {0,171,-227};
        g_80 = l_186;
        return l_108;
    }
    else
    { /* block id: 126 */
        uint32_t l_189 = 0x5C4DCCB4;
        g_80.f0 = (((((p_87 == (l_108 || (65534U | (((int16_t)0x7BB0 << (int16_t)l_189) || ((l_108 < l_189) & g_80.f0))))) & g_80.f0) == p_86) && l_189) <= p_87);
        l_190 = l_190;
    }
    return g_80.f0;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_80.f0, "g_80.f0", print_hash_value);
    transparent_crc(g_80.f1, "g_80.f1", print_hash_value);
    transparent_crc(g_80.f2, "g_80.f2", print_hash_value);
    transparent_crc(g_384, "g_384", print_hash_value);
    transparent_crc(g_385, "g_385", print_hash_value);
    transparent_crc(g_490.f0, "g_490.f0", print_hash_value);
    transparent_crc(g_490.f1, "g_490.f1", print_hash_value);
    transparent_crc(g_490.f2, "g_490.f2", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 95
   depth: 1, occurrence: 30
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 30
breakdown:
   indirect level: 0, occurrence: 30
XXX full-bitfields structs in the program: 30
breakdown:
   indirect level: 0, occurrence: 30
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 39
XXX times a bitfields struct on RHS: 55
XXX times a single bitfield on LHS: 54
XXX times a single bitfield on RHS: 246

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 258
   depth: 2, occurrence: 35
   depth: 3, occurrence: 12
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 3
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 5
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 5
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 3
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 716
XXX times a non-volatile is write: 160
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 222
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 40
   depth: 2, occurrence: 44
   depth: 3, occurrence: 32
   depth: 4, occurrence: 28
   depth: 5, occurrence: 41

XXX percentage a fresh-made variable is used: 15
XXX percentage an existing variable is used: 85
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

