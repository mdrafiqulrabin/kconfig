/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1257858072
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
   signed f1 : 7;
   signed f2 : 13;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_1(void);
inline static int32_t  func_2(uint32_t  p_3, int8_t  p_4, uint8_t  p_5, uint64_t  p_6);
inline static uint16_t  func_7(struct S0  p_8, uint16_t  p_9, int32_t  p_10, const float  p_11, uint64_t  p_12);
static int32_t * func_19(int32_t * p_20, int32_t * const  p_21);
static uint64_t  func_32(uint64_t  p_33, float  p_34, int32_t * const  p_35, uint16_t  p_36);
static float  func_39(float  p_40, uint8_t  p_41, struct S0  p_42, int8_t  p_43);
static float  func_44(int32_t * p_45, float  p_46, int32_t  p_47, uint64_t  p_48, int32_t * p_49);
static struct S0  func_54(int32_t * p_55, int32_t * p_56, const uint32_t  p_57, const int8_t  p_58, int32_t * p_59);
inline static int32_t * func_60(float  p_61);
static struct S0  func_62(float  p_63, int32_t * p_64, const uint16_t  p_65, int32_t * p_66, int32_t * p_67);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_1(void)
{ /* block id: 0 */
    struct S0 l_13 = {-7087,-4,70};
    const uint16_t l_455 = 0x0252L;
    uint8_t l_458 = 0x2AL;
    int32_t ** const l_465 = (void*)0;
    uint16_t l_466 = 0UL;
    int32_t l_467 = 0xE44C25FDL;
    float l_469 = 0xA.FE0149p-46;
    float *l_468 = &l_469;
    l_13.f0 = func_2((func_7(l_13, l_13.f1, l_13.f1, (safe_mul_func_float_f_f(0xC.DCC80Fp+68, (-0x1.Cp+1))), l_13.f2) != (safe_rshift_func_int8_t_s_s(((l_13.f1 | l_13.f1) ^ l_13.f0), l_13.f2))), l_13.f2, l_13.f1, l_13.f1);
    (*l_468) = (-(safe_sub_func_float_f_f((((safe_div_func_float_f_f((safe_sub_func_float_f_f(l_13.f0, (l_455 <= (safe_add_func_float_f_f(l_458, (l_13.f0 <= (safe_mul_func_float_f_f((l_458 != (l_455 == l_13.f2)), ((safe_sub_func_float_f_f(l_13.f2, (safe_sub_func_float_f_f(((void*)0 != l_465), l_466)))) != l_13.f1))))))))), l_467)) > l_467) != l_467), l_13.f2)));
    return l_13.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_2(uint32_t  p_3, int8_t  p_4, uint8_t  p_5, uint64_t  p_6)
{ /* block id: 3 */
    int32_t l_23[3];
    int32_t *l_22 = &l_23[1];
    const int32_t *l_184[7] = {&l_23[1],&l_23[1],&l_23[1],&l_23[1],&l_23[1],&l_23[1],&l_23[1]};
    const int32_t **l_183[6][3] = {{&l_184[4],&l_184[4],&l_184[4]},{&l_184[1],&l_184[1],&l_184[1]},{&l_184[4],&l_184[4],&l_184[4]},{&l_184[1],&l_184[1],&l_184[1]},{&l_184[4],&l_184[4],&l_184[4]},{&l_184[1],&l_184[1],&l_184[1]}};
    int32_t *l_185 = &l_23[1];
    int32_t *l_186 = &l_23[1];
    int32_t *l_187 = (void*)0;
    int32_t l_192 = 0x87E2E248L;
    struct S0 *l_207 = (void*)0;
    float l_208 = 0x0.24A69Dp+87;
    int32_t ****l_297 = (void*)0;
    struct S0 l_318 = {3317,9,-88};
    float *l_365 = &l_208;
    float **l_364 = &l_365;
    float ****l_397 = (void*)0;
    int i, j;
    for (i = 0; i < 3; i++)
        l_23[i] = (-1L);
    l_185 = func_19(l_22, &l_23[2]);
    /* statement id: 79 */
    assert ((l_185 >= &l_23[0] && l_185 <= &l_23[2]) || l_185 == 0);
    l_187 = l_186;
    /* statement id: 80 */
    assert ((l_187 >= &l_23[0] && l_187 <= &l_23[2]));
    for (p_4 = 6; (p_4 >= 0); p_4 -= 1)
    { /* block id: 83 */
        int16_t l_193 = 0xB97BL;
        int32_t *l_215 = &l_23[1];
        struct S0 l_218[7] = {{3744,8,-30},{3744,8,-30},{3744,8,-30},{3744,8,-30},{3744,8,-30},{3744,8,-30},{3744,8,-30}};
        struct S0 * const l_217 = &l_218[0];
        struct S0 **l_253 = (void*)0;
        struct S0 ***l_252 = &l_253;
        int32_t *l_257 = &l_192;
        uint16_t l_286 = 0x1EBBL;
        struct S0 *l_359 = &l_318;
        uint16_t l_443 = 0xC796L;
        int i;
        if (((safe_lshift_func_uint8_t_u_s((safe_mul_func_int16_t_s_s(l_192, l_193)), (safe_sub_func_uint32_t_u_u(((safe_sub_func_int32_t_s_s(p_5, (~((safe_div_func_uint16_t_u_u((safe_mod_func_int64_t_s_s(0x9A10EB1AB0853695LL, (safe_mod_func_int8_t_s_s((safe_rshift_func_uint8_t_u_s((((void*)0 == l_207) == ((p_6 || (safe_add_func_int64_t_s_s(0L, (safe_sub_func_uint8_t_u_u((safe_lshift_func_int8_t_s_u(((p_3 && 1L) == 0x32L), 1)), 0xF4L))))) && p_4)), p_5)), 0xB4L)))), p_6)) < p_4)))) | p_6), (*l_22))))) ^ 0xFDL))
        { /* block id: 84 */
            int32_t *l_216[5];
            struct S0 **l_226[1][2];
            int i, j;
            for (i = 0; i < 5; i++)
                l_216[i] = &l_23[1];
            for (i = 0; i < 1; i++)
            {
                for (j = 0; j < 2; j++)
                    l_226[i][j] = (void*)0;
            }
            for (p_6 = 0; (p_6 <= 2); p_6 += 1)
            { /* block id: 87 */
                uint8_t l_223 = 255UL;
                struct S0 **l_225 = &l_207;
                struct S0 ***l_224[3];
                int i, j;
                for (i = 0; i < 3; i++)
                    l_224[i] = &l_225;
                (*l_217) = func_54(l_215, l_216[3], (((void*)0 != l_217) != (safe_mod_func_int32_t_s_s(((safe_rshift_func_uint8_t_u_s(l_223, 5)) >= p_4), p_6))), p_6, l_215);
                l_226[0][1] = &l_207;
                for (p_3 = 0; (p_3 <= 2); p_3 += 1)
                { /* block id: 92 */
                    int32_t *l_227 = &l_23[2];
                    int32_t **l_235 = (void*)0;
                    l_216[3] = func_19(l_227, l_215);
                    if ((*l_227))
                    { /* block id: 94 */
                        int32_t **l_236 = (void*)0;
                        int16_t l_254 = 0x1DD9L;
                        l_184[p_4] = func_60((safe_mul_func_float_f_f((*l_227), (safe_sub_func_float_f_f((+(safe_add_func_float_f_f(((l_235 != l_236) > ((safe_add_func_float_f_f(p_5, (*l_227))) != (safe_sub_func_float_f_f(0x2.5p+1, (((safe_sub_func_float_f_f(((safe_div_func_float_f_f((+(safe_div_func_float_f_f(((safe_div_func_float_f_f((safe_mul_func_float_f_f(p_6, (l_252 == (void*)0))), 0x0.Cp+1)) < (*l_227)), (*l_187)))), 0x3.9p-1)) >= (-0x4.6p-1)), p_3)) == p_4) > p_4))))), (*l_186)))), l_254)))));
                        l_216[3] = l_227;
                        if (p_6)
                            break;
                    }
                    else
                    { /* block id: 98 */
                        int32_t ***l_255 = (void*)0;
                        int32_t ***l_256 = &l_235;
                        (*l_256) = &l_187;
                        /* statement id: 99 */
                        assert (l_235 == &l_187);
                    }
                    /* facts after branching */
                    assert (l_235 == &l_187 || l_235 == 0);
                    if (p_4)
                        continue;
                }
            }
            /* facts after for loop */
            //assert ((l_216[0] >= &l_23[0] && l_216[0] <= &l_23[2]) || l_216[0] == 0);
            //assert (l_226[0][0] == &l_207 || l_226[0][0] == 0);
            (*l_217) = (*l_217);
        }
        else
        { /* block id: 105 */
            int32_t *l_258 = &l_23[0];
            int32_t **l_261 = &l_215;
            int32_t *** const l_260 = &l_261;
            uint32_t l_348 = 0UL;
            struct S0 l_366 = {2973,4,-70};
            float l_380 = 0x1.24BA82p+4;
            struct S0 **l_391 = &l_359;
            int32_t l_400 = (-6L);
            l_257 = func_60(p_5);
            /* statement id: 106 */
            assert (l_257 == 0);
            l_258 = l_258;
            for (l_193 = 0; (l_193 <= 2); l_193 += 1)
            { /* block id: 110 */
                int64_t l_259 = 0x93A50B06DFE74754LL;
                int32_t ***l_263 = &l_261;
                int32_t ****l_262 = &l_263;
                float *l_285 = (void*)0;
                if (l_259)
                    break;
                (*l_262) = l_260;
                (**l_260) = l_257;
                /* statement id: 113 */
                assert (l_215 == 0);
            }
            /* facts after for loop */
            assert (l_215 == 0 || (l_215 >= &l_23[0] && l_215 <= &l_23[2]));
            for (l_192 = 2; (l_192 >= 0); l_192 -= 1)
            { /* block id: 117 */
                int32_t ***l_296[7] = {&l_261,&l_261,&l_261,&l_261,&l_261,&l_261,&l_261};
                int32_t ****l_295 = &l_296[2];
                uint64_t l_306[6] = {0x11AE36C6A78CF511LL,6UL,0x11AE36C6A78CF511LL,0x11AE36C6A78CF511LL,6UL,0x11AE36C6A78CF511LL};
                struct S0 **l_309 = &l_207;
                int16_t l_341[4];
                float *l_343[2][7] = {{&l_208,&l_208,&l_208,&l_208,&l_208,&l_208,&l_208},{&l_208,&l_208,&l_208,&l_208,&l_208,&l_208,&l_208}};
                float **l_342 = &l_343[1][4];
                struct S0 ** const l_390 = &l_359;
                int i, j;
                for (i = 0; i < 4; i++)
                    l_341[i] = 1L;
                for (l_193 = 0; (l_193 <= 6); l_193 += 1)
                { /* block id: 120 */
                    float *l_302[7][8] = {{(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208},{(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208},{(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208},{(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208},{(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208},{(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208},{(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208,(void*)0,&l_208}};
                    int32_t l_305 = 0L;
                    struct S0 ****l_345 = (void*)0;
                    struct S0 ** const *l_347[10] = {&l_253,&l_253,(void*)0,(void*)0,&l_253,&l_253,&l_253,(void*)0,(void*)0,&l_253};
                    struct S0 ** const **l_346 = &l_347[7];
                    int i, j;
                    if ((((((((safe_mul_func_int8_t_s_s((*l_187), (0x57L <= (safe_div_func_uint8_t_u_u(((safe_div_func_int64_t_s_s((((((safe_rshift_func_uint8_t_u_u(((l_295 == l_297) < (safe_mod_func_int8_t_s_s((((p_5 & (l_184[p_4] != l_302[6][6])) == ((safe_div_func_uint8_t_u_u((l_302[3][5] == l_302[3][4]), (*l_22))) <= 0x4DBD819F3F146284LL)) != p_6), l_305))), (*l_186))) & p_3) >= p_6) ^ 0xB29BL) ^ (*l_22)), 0x3AB3DB0E18812C0ALL)) < l_305), p_5))))) < p_3) > 0x2812L) != p_6) == (*l_258)) <= p_6) ^ l_306[1]))
                    { /* block id: 121 */
                        struct S0 *l_314 = &l_218[0];
                        int i;
                        l_184[l_193] = (***l_295);
                        l_305 = ((p_5 > (safe_mul_func_float_f_f((l_309 == (void*)0), ((safe_div_func_float_f_f(((safe_div_func_float_f_f(((l_314 == (*l_309)) == (safe_div_func_float_f_f(p_4, (p_4 <= 0x9.783CCCp+47)))), ((void*)0 != l_184[l_193]))) == p_3), (*l_258))) < 0x0.Fp+1)))) <= 0xE.A1B74Dp-66);
                        return p_5;
                    }
                    else
                    { /* block id: 125 */
                        struct S0 l_317 = {-7155,8,65};
                        float ***l_344 = &l_342;
                        l_318 = l_317;
                        (**l_260) = func_60((p_5 >= (safe_mul_func_float_f_f((((-(safe_sub_func_float_f_f((safe_add_func_float_f_f(((safe_mul_func_float_f_f((safe_add_func_float_f_f(0x0.700196p+25, (((*l_258) < p_5) < ((((0x9.0p+1 < ((safe_mul_func_float_f_f(((((safe_div_func_float_f_f(((safe_sub_func_float_f_f(0xA.071430p+22, (safe_mul_func_float_f_f((((&l_207 == (*l_252)) <= (safe_div_func_float_f_f(((((!(l_341[1] <= l_317.f0)) != p_6) != 0x1.Dp-1) >= p_5), p_5))) <= p_5), 0x1.7p-1)))) < p_5), p_5)) > 0x0.7p+1) == p_6) != p_6), p_4)) < p_4)) >= p_3) > p_4) <= 0x6.59088Ap-18)))), 0x1.7p+1)) > (*l_258)), (-0x1.Cp+1))), l_317.f1))) < (-0x7.8p+1)) >= 0x0.Cp+1), 0x1.8p+1))));
                        /* statement id: 127 */
                        assert (l_215 == 0);
                        (*l_186) = (-0x9.1p-1);
                        (*l_344) = l_342;
                    }
                    /* facts after branching */
                    assert (l_215 == 0);
                    (*l_346) = (void*)0;
                    if (((0xF319DCE2DD5305F2LL > (*l_22)) == (-1L)))
                    { /* block id: 132 */
                        (**l_260) = l_257;
                        return l_348;
                    }
                    else
                    { /* block id: 135 */
                        (**l_342) = 0x0.7p+1;
                        (**l_260) = func_60((safe_mul_func_float_f_f((p_3 == ((void*)0 != &l_302[5][4])), ((safe_add_func_float_f_f((safe_mul_func_float_f_f((safe_div_func_float_f_f(p_3, (safe_mul_func_float_f_f(p_5, ((-0x1.Bp+1) >= ((void*)0 == l_359)))))), (safe_sub_func_float_f_f((safe_mul_func_float_f_f((l_364 != &l_343[1][5]), p_4)), p_3)))), 0x1.0p-1)) <= p_3))));
                        (*l_22) = p_6;
                        if ((*l_258))
                            break;
                    }
                }
                for (l_193 = 0; (l_193 <= 1); l_193 += 1)
                { /* block id: 144 */
                    struct S0 ** const * const l_381 = (void*)0;
                    int32_t l_384[2];
                    int i;
                    for (i = 0; i < 2; i++)
                        l_384[i] = 0x7DBD5873L;
                    (*l_359) = l_366;
                    for (p_5 = 0; (p_5 <= 2); p_5 += 1)
                    { /* block id: 148 */
                        int i, j;
                        if (p_3)
                            break;
                    }
                    (*l_186) = (safe_mod_func_uint32_t_u_u(p_3, (0x3BL || (!(((safe_mod_func_uint16_t_u_u(0xE148L, (safe_div_func_int32_t_s_s(p_6, ((((safe_div_func_int8_t_s_s((safe_mul_func_uint16_t_u_u((safe_div_func_int64_t_s_s((p_4 < ((void*)0 != l_381)), 0x53ABEA12880A36DBLL)), (safe_div_func_int16_t_s_s((*l_258), p_6)))), p_4)) < p_6) | l_384[0]) ^ (-1L)))))) > p_3) ^ 0x7968L)))));
                }
                for (p_5 = 1; (p_5 <= 6); p_5 += 1)
                { /* block id: 155 */
                    const uint32_t l_393 = 1UL;
                    int32_t l_394 = (-1L);
                    int i, j;
                    l_394 = ((((safe_mul_func_float_f_f(((-((0x5.71F687p-51 == (*l_187)) >= (safe_div_func_float_f_f((l_390 != l_391), (+(l_393 >= (l_393 != p_5))))))) <= p_6), (l_183[l_192][l_192] != &l_184[p_4]))) > 0x8.6E97BBp-49) <= l_393) != p_6);
                    (*l_187) = (safe_div_func_uint8_t_u_u((p_4 == ((void*)0 != &l_252)), 0x64L));
                }
                for (p_6 = 0; (p_6 <= 6); p_6 += 1)
                { /* block id: 161 */
                    float *** const *l_399 = (void*)0;
                    float *** const **l_398 = &l_399;
                    int i, j;
                    (*l_398) = l_397;
                    if (l_400)
                        break;
                }
            }
        }
        /* facts after branching */
        assert (l_215 == 0 || (l_215 >= &l_23[0] && l_215 <= &l_23[2]));
        assert (l_257 == 0 || l_257 == &l_192);
        for (p_3 = 0; (p_3 <= 2); p_3 += 1)
        { /* block id: 169 */
            int32_t **l_417 = &l_186;
            int32_t ***l_416 = &l_417;
            int32_t ****l_415 = &l_416;
            const float *l_441 = &l_208;
            const float **l_440 = &l_441;
            const float ***l_439 = &l_440;
            const float ****l_438 = &l_439;
            int16_t l_442 = 0x9ED0L;
            for (l_192 = 2; (l_192 >= 0); l_192 -= 1)
            { /* block id: 172 */
                int32_t ****l_418[9][5][3] = {{{&l_416,(void*)0,&l_416},{&l_416,&l_416,(void*)0},{(void*)0,&l_416,(void*)0},{&l_416,&l_416,&l_416},{(void*)0,&l_416,&l_416}},{{&l_416,(void*)0,&l_416},{(void*)0,&l_416,&l_416},{&l_416,(void*)0,&l_416},{&l_416,&l_416,&l_416},{&l_416,&l_416,&l_416}},{{&l_416,&l_416,(void*)0},{&l_416,&l_416,(void*)0},{&l_416,&l_416,&l_416},{(void*)0,&l_416,&l_416},{&l_416,(void*)0,(void*)0}},{{(void*)0,&l_416,&l_416},{&l_416,(void*)0,(void*)0},{(void*)0,&l_416,(void*)0},{&l_416,&l_416,(void*)0},{&l_416,&l_416,&l_416}},{{&l_416,&l_416,(void*)0},{&l_416,(void*)0,&l_416},{&l_416,(void*)0,&l_416},{&l_416,&l_416,&l_416},{&l_416,&l_416,(void*)0}},{{(void*)0,&l_416,&l_416},{&l_416,(void*)0,(void*)0},{(void*)0,(void*)0,&l_416},{&l_416,&l_416,&l_416},{(void*)0,&l_416,&l_416}},{{&l_416,(void*)0,&l_416},{&l_416,&l_416,&l_416},{&l_416,(void*)0,&l_416},{&l_416,&l_416,&l_416},{&l_416,(void*)0,&l_416}},{{&l_416,&l_416,(void*)0},{(void*)0,&l_416,&l_416},{&l_416,&l_416,&l_416},{(void*)0,(void*)0,&l_416},{(void*)0,&l_416,(void*)0}},{{&l_416,(void*)0,&l_416},{&l_416,&l_416,&l_416},{&l_416,(void*)0,&l_416},{(void*)0,&l_416,&l_416},{&l_416,(void*)0,&l_416}}};
                int32_t l_444[10][9][2] = {{{0L,(-7L)},{0x18C485DBL,0x6C76C820L},{2L,0x75A83782L},{0x37EF3F9CL,7L},{0x4B684BF2L,1L},{0x242BAB7DL,0L},{0x512BAA61L,0xF00F302BL},{2L,0x602C31B2L},{0xD85DBEB4L,0xED56C7AFL}},{{0L,3L},{(-7L),0x6BB8693EL},{0x8343486BL,0L},{0x09184185L,0xB9E783FFL},{0x46CAE3DAL,0x08A865DEL},{0L,0xEA5E7D4BL},{(-1L),0x6BB8693EL},{0xED305FA5L,(-7L)},{0x8C5A75C8L,0x46CAE3DAL}},{{0xD85DBEB4L,0x6C76C820L},{0x1F87285BL,0xDFCF9E42L},{0x4D3B9400L,0L},{0x4B684BF2L,0x04A5D0BCL},{0x700F43A4L,2L},{0x37EF3F9CL,0xF00F302BL},{0x1F87285BL,0x405D193CL},{0L,(-7L)},{0L,(-7L)}},{{0xBFB27927L,0L},{9L,0L},{0L,(-9L)},{0xED56C7AFL,(-9L)},{0L,0L},{9L,0L},{0xBFB27927L,(-7L)},{0L,(-7L)},{0L,0x405D193CL}},{{0x1F87285BL,0xF00F302BL},{0x37EF3F9CL,2L},{0x700F43A4L,0x04A5D0BCL},{0x4B684BF2L,0L},{0x4D3B9400L,0xDFCF9E42L},{0x1F87285BL,0x6C76C820L},{0xD85DBEB4L,0x46CAE3DAL},{0x8C5A75C8L,(-7L)},{0xED305FA5L,0x6BB8693EL}},{{(-1L),0xEA5E7D4BL},{0L,0x08A865DEL},{0x46CAE3DAL,0xB9E783FFL},{0x09184185L,0L},{0x8343486BL,0x6BB8693EL},{(-7L),3L},{0L,0xED56C7AFL},{0xD85DBEB4L,0x602C31B2L},{2L,0xF00F302BL}},{{0x512BAA61L,0L},{0x242BAB7DL,1L},{0x4B684BF2L,7L},{0x37EF3F9CL,0x75A83782L},{2L,0x6C76C820L},{0x18C485DBL,(-7L)},{0L,3L},{0xED305FA5L,0x413676E2L},{9L,0x8C5A75C8L}},{{0x09184185L,0x08A865DEL},{4L,(-9L)},{0x04A5D0BCL,0xEA5E7D4BL},{0x8343486BL,0x413676E2L},{0xBFB27927L,0xBFB27927L},{0x8C5A75C8L,0xED56C7AFL},{0x18C485DBL,0x405D193CL},{7L,0xDFCF9E42L},{0x512BAA61L,7L}},{{0x700F43A4L,0x09184185L},{0x700F43A4L,7L},{0x512BAA61L,0xDFCF9E42L},{7L,0x405D193CL},{0x18C485DBL,0xED56C7AFL},{0x8C5A75C8L,0xBFB27927L},{0xBFB27927L,0x413676E2L},{0x8343486BL,0xEA5E7D4BL},{0x04A5D0BCL,(-9L)}},{{4L,0x08A865DEL},{0x09184185L,0x8C5A75C8L},{9L,0x60BC6B06L},{0L,0x700F43A4L},{1L,9L},{0x2D96D403L,0x4482857DL},{1L,(-7L)},{7L,0L},{0x6FC845DFL,0x75A83782L}}};
                int i, j, k;
                (*l_187) = (safe_mul_func_int8_t_s_s(p_4, (safe_rshift_func_int16_t_s_u(((((((safe_mul_func_uint16_t_u_u(((((safe_rshift_func_int8_t_s_s(((p_4 | (safe_rshift_func_uint8_t_u_s((p_6 || 0UL), 6))) > p_3), 0)) == (safe_add_func_int32_t_s_s(((safe_rshift_func_uint8_t_u_s(((void*)0 == &l_215), 2)) | 0xB5C6D15E0714F085LL), ((l_415 != l_418[2][3][1]) <= (**l_417))))) > 0xCDL) && p_5), p_4)) & p_3) > (***l_416)) || 0x27779FA1L) >= 1L) == p_3), 2))));
                (*l_186) = ((safe_add_func_uint16_t_u_u((****l_415), p_3)) | p_3);
                (***l_416) = (!((safe_sub_func_int64_t_s_s(p_4, (safe_add_func_int64_t_s_s((safe_mod_func_int16_t_s_s(((((safe_mul_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u(p_5, p_6)) || ((((safe_sub_func_uint64_t_u_u((safe_div_func_int64_t_s_s(((safe_sub_func_uint16_t_u_u(((l_438 == &l_439) | p_3), ((void*)0 == (*l_438)))) | 1UL), l_442)), p_4)) >= p_4) >= p_4) | (-1L))), l_443)) && (**l_417)) ^ l_444[2][3][0]) | p_4), (***l_416))), p_5)))) | 8UL));
            }
        }
        for (l_443 = 0; (l_443 <= 2); l_443 += 1)
        { /* block id: 180 */
            int i;
            l_184[p_4] = &l_23[l_443];
        }
        for (p_3 = 0; (p_3 <= 2); p_3 += 1)
        { /* block id: 185 */
            for (p_5 = 0; (p_5 <= 6); p_5 += 1)
            { /* block id: 188 */
                struct S0 *l_445 = &l_318;
                int32_t *l_446 = &l_23[1];
                for (l_286 = 0; (l_286 <= 6); l_286 += 1)
                { /* block id: 191 */
                    int32_t * const l_447 = &l_23[1];
                    int i;
                    l_445 = &l_218[(p_3 + 3)];
                    /* statement id: 192 */
                    assert ((l_445 >= &l_218[0] && l_445 <= &l_218[6]));
                }
                /* facts after for loop */
                assert ((l_445 >= &l_218[0] && l_445 <= &l_218[6]) || l_445 == &l_318);
            }
        }
    }
    return p_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_7(struct S0  p_8, uint16_t  p_9, int32_t  p_10, const float  p_11, uint64_t  p_12)
{ /* block id: 1 */
    uint64_t l_16 = 0xF5BFB66FEBFB2C41LL;
    return l_16;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_19(int32_t * p_20, int32_t * const  p_21)
{ /* block id: 4 */
    int32_t l_28[5];
    struct S0 l_31 = {4411,10,38};
    struct S0 l_135 = {-503,10,-9};
    int32_t l_138 = 0L;
    int32_t * const l_137[6][4] = {{(void*)0,&l_138,&l_138,&l_138},{&l_138,(void*)0,(void*)0,&l_138},{&l_138,(void*)0,(void*)0,&l_138},{(void*)0,&l_138,&l_138,(void*)0},{(void*)0,&l_138,(void*)0,(void*)0},{&l_138,(void*)0,(void*)0,(void*)0}};
    int64_t l_139 = 0xD76CE6111D5598A9LL;
    uint8_t l_163 = 9UL;
    int32_t ***l_173 = (void*)0;
    int32_t *l_176[6] = {(void*)0,&l_138,&l_138,(void*)0,&l_138,&l_138};
    int32_t **l_175[4][9][2] = {{{&l_176[2],(void*)0},{&l_176[0],&l_176[2]},{&l_176[2],&l_176[1]},{&l_176[2],&l_176[2]},{&l_176[0],(void*)0},{&l_176[2],&l_176[3]},{&l_176[3],&l_176[4]},{(void*)0,&l_176[1]},{&l_176[1],&l_176[3]}},{{&l_176[5],&l_176[3]},{&l_176[2],&l_176[1]},{(void*)0,&l_176[3]},{(void*)0,&l_176[1]},{&l_176[5],&l_176[2]},{&l_176[5],&l_176[4]},{&l_176[2],&l_176[4]},{&l_176[5],&l_176[2]},{&l_176[5],&l_176[1]}},{{(void*)0,&l_176[3]},{(void*)0,&l_176[1]},{&l_176[2],&l_176[3]},{&l_176[5],&l_176[3]},{&l_176[1],&l_176[1]},{(void*)0,&l_176[4]},{&l_176[3],&l_176[3]},{&l_176[2],(void*)0},{&l_176[0],&l_176[2]}},{{&l_176[2],&l_176[1]},{&l_176[2],&l_176[2]},{&l_176[0],(void*)0},{&l_176[2],&l_176[3]},{&l_176[3],&l_176[4]},{(void*)0,&l_176[1]},{&l_176[1],&l_176[3]},{&l_176[5],&l_176[3]},{&l_176[2],&l_176[1]}}};
    int32_t ***l_174[9][5][1] = {{{&l_175[0][2][1]},{&l_175[0][2][1]},{&l_175[0][1][1]},{(void*)0},{&l_175[0][1][1]}},{{&l_175[0][1][1]},{&l_175[0][4][0]},{&l_175[0][1][1]},{&l_175[0][4][0]},{&l_175[0][1][1]}},{{&l_175[0][1][1]},{(void*)0},{&l_175[0][1][1]},{&l_175[0][2][1]},{&l_175[0][2][1]}},{{&l_175[0][1][1]},{(void*)0},{&l_175[0][1][1]},{&l_175[0][1][1]},{&l_175[0][4][0]}},{{&l_175[0][1][1]},{&l_175[0][4][0]},{&l_175[0][1][1]},{&l_175[0][1][1]},{(void*)0}},{{&l_175[0][1][1]},{&l_175[0][2][1]},{&l_175[0][2][1]},{&l_175[0][1][1]},{(void*)0}},{{&l_175[0][1][1]},{&l_175[0][1][1]},{&l_175[0][4][0]},{&l_175[0][1][1]},{&l_175[0][4][0]}},{{&l_175[0][1][1]},{&l_175[0][1][1]},{(void*)0},{&l_175[0][1][1]},{&l_175[0][2][1]}},{{&l_175[0][2][1]},{&l_175[0][1][1]},{(void*)0},{&l_175[0][1][1]},{&l_175[0][1][1]}}};
    int32_t * const *l_178 = (void*)0;
    int32_t * const **l_177 = &l_178;
    struct S0 *l_179 = (void*)0;
    struct S0 *l_180 = (void*)0;
    struct S0 *l_181 = &l_31;
    int i, j, k;
    for (i = 0; i < 5; i++)
        l_28[i] = 6L;
    if ((safe_sub_func_uint8_t_u_u((safe_sub_func_int16_t_s_s(l_28[2], l_28[3])), (safe_add_func_uint16_t_u_u(func_7(l_31, (0x38L != l_28[3]), (*p_21), l_31.f0, func_32(l_28[4], (safe_div_func_float_f_f((func_39((func_44(p_20, l_31.f0, l_28[2], l_31.f2, p_20) <= 0xE.00665Bp+18), l_28[2], l_135, l_31.f1) > l_31.f1), 0x1.7p-1)), l_137[3][1], l_139)), l_163)))))
    { /* block id: 67 */
        int32_t *l_165 = (void*)0;
        int32_t **l_164[1][2];
        int i, j;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 2; j++)
                l_164[i][j] = &l_165;
        }
        p_20 = (void*)0;
        /* statement id: 68 */
        assert (p_20 == 0);
        if (l_135.f0)
            goto lbl_182;
        (*p_21) = 0xC5D88C53L;
    }
    else
    { /* block id: 70 */
        uint64_t l_168 = 0x28CD2B34E314DBE9LL;
        int32_t **l_169 = (void*)0;
        const int32_t *l_171 = &l_138;
        const int32_t **l_170 = &l_171;
        struct S0 *l_172 = &l_135;
        (*l_170) = func_60((safe_mul_func_float_f_f(l_168, l_168)));
        /* statement id: 71 */
        assert (l_171 == 0);
        (*l_172) = func_54(&l_138, func_60(l_168), l_168, l_168, &l_138);
    }
    /* facts after branching */
    //assert ((p_20 >= &l_23[0] && p_20 <= &l_23[2]) || p_20 == 0);
    (*l_177) = &l_137[2][3];
    /* statement id: 74 */
    assert ((l_178 >= &l_137[0][0] && l_178 <= &l_137[5][3]));
lbl_182:
    (*l_181) = l_31;
    p_20 = p_20;
    return p_20;
    /* statement id: 78 */
    //assert ((func_19_rv >= &l_23[0] && func_19_rv <= &l_23[2]) || func_19_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_32(uint64_t  p_33, float  p_34, int32_t * const  p_35, uint16_t  p_36)
{ /* block id: 53 */
    int32_t l_143[4];
    int32_t *l_142[3];
    int i;
    for (i = 0; i < 4; i++)
        l_143[i] = 1L;
    for (i = 0; i < 3; i++)
        l_142[i] = &l_143[0];
    for (p_33 = 24; (p_33 == 13); p_33 = safe_sub_func_uint32_t_u_u(p_33, 9))
    { /* block id: 56 */
        const uint32_t l_144[3] = {1UL,1UL,1UL};
        int32_t *l_145 = &l_143[0];
        struct S0 l_147 = {-8178,3,0};
        struct S0 *l_146 = &l_147;
        const int8_t l_156 = 0L;
        int i;
        (*l_146) = func_54(l_142[2], &l_143[2], l_144[2], p_33, l_145);
        if (p_33)
            continue;
        (*l_146) = func_54(&l_143[2], &l_143[0], p_33, (safe_rshift_func_int8_t_s_u((safe_div_func_uint16_t_u_u((safe_div_func_int16_t_s_s(p_33, ((safe_rshift_func_uint16_t_u_u(l_156, 0)) || ((*l_145) & (0xB9L == 0xFEL))))), (safe_mul_func_uint16_t_u_u(p_33, (*l_145))))), 2)), &l_143[0]);
    }
    for (p_36 = 17; (p_36 == 53); p_36 = safe_add_func_uint16_t_u_u(p_36, 5))
    { /* block id: 63 */
        int32_t **l_161[8][4] = {{&l_142[2],(void*)0,(void*)0,&l_142[2]},{(void*)0,&l_142[2],(void*)0,(void*)0},{&l_142[2],&l_142[2],&l_142[2],&l_142[2]},{&l_142[2],(void*)0,(void*)0,&l_142[2]},{(void*)0,&l_142[2],(void*)0,(void*)0},{&l_142[2],&l_142[2],&l_142[2],&l_142[2]},{&l_142[2],(void*)0,(void*)0,&l_142[2]},{&l_142[2],(void*)0,&l_142[2],&l_142[2]}};
        int32_t **l_162 = &l_142[2];
        int i, j;
        (*l_162) = p_35;
    }
    /* facts after for loop */
    //assert (l_142[0] == &l_138 || l_142[0] == 0 || (l_142[0] >= &l_143[0] && l_142[0] <= &l_143[3]));
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_39(float  p_40, uint8_t  p_41, struct S0  p_42, int8_t  p_43)
{ /* block id: 51 */
    int8_t l_136 = 0x8EL;
    return l_136;
}


/* ------------------------------------------ */
/* 
 * reads : l_23
 * writes:
 */
static float  func_44(int32_t * p_45, float  p_46, int32_t  p_47, uint64_t  p_48, int32_t * p_49)
{ /* block id: 5 */
    int16_t l_88[1];
    struct S0 l_109 = {-6247,-4,51};
    float l_134 = (-0x1.9p+1);
    float *l_133 = &l_134;
    int i;
    for (i = 0; i < 1; i++)
        l_88[i] = 0x9BCAL;
    for (p_47 = 0; (p_47 < (-5)); --p_47)
    { /* block id: 8 */
        struct S0 l_83 = {5018,-0,-7};
        struct S0 *l_82 = &l_83;
        if ((*p_49))
            break;
        for (p_48 = 27; (p_48 == 28); p_48++)
        { /* block id: 12 */
            int16_t l_89 = 0xECCDL;
            int32_t l_91 = 3L;
            int32_t *l_90 = &l_91;
            (*l_82) = func_54(p_45, func_60(p_46), (((p_47 ^ (safe_unary_minus_func_int32_t_s(1L))) <= (((~(((void*)0 == l_82) && (safe_mul_func_int16_t_s_s(l_83.f1, (safe_sub_func_int64_t_s_s((((((p_45 == (void*)0) <= p_47) < l_88[0]) && p_47) >= p_47), 7UL)))))) & p_47) && p_48)) >= l_89), p_47, l_90);
            for (l_89 = 0; (l_89 == (-25)); --l_89)
            { /* block id: 33 */
                uint16_t l_127[1][2][2];
                int i, j, k;
                for (i = 0; i < 1; i++)
                {
                    for (j = 0; j < 2; j++)
                    {
                        for (k = 0; k < 2; k++)
                            l_127[i][j][k] = 0UL;
                    }
                }
                for (l_91 = 18; (l_91 >= (-11)); --l_91)
                { /* block id: 36 */
                    int8_t l_120 = 0xAEL;
                    int32_t l_132[9][10] = {{0x2FD2206DL,0x885E37C3L,6L,0x0B25D924L,2L,(-1L),(-1L),0x885E37C3L,(-2L),0xA799B5C0L},{0x2FD2206DL,(-1L),0xA5B5AAB3L,(-7L),0L,0x21B6B7D2L,0xA799B5C0L,0L,0xEE9A1886L,(-4L)},{0x21B6B7D2L,0xA799B5C0L,0L,0xEE9A1886L,(-4L),(-1L),0x23AE71BBL,0x417BD2F3L,0x23AE71BBL,(-1L)},{(-1L),0x0B25D924L,(-1L),0x0B25D924L,(-1L),0x87C22977L,0x2FD2206DL,0xA799B5C0L,(-1L),0xEAEEF4A5L},{(-7L),0x21B6B7D2L,1L,0x6DEEB808L,(-1L),1L,0xA799B5C0L,0xEE9A1886L,0xD266E85BL,0xEAEEF4A5L},{(-10L),0x6DEEB808L,0x21B6B7D2L,0x5FDDB278L,(-1L),0x23AE71BBL,8L,0x26AF1C48L,0x21B6B7D2L,(-1L)},{(-1L),0x885E37C3L,0x5C1309E2L,(-1L),(-4L),0xC1A10FB8L,(-7L),(-7L),0xC1A10FB8L,(-4L)},{0xEAEEF4A5L,1L,1L,0xEAEEF4A5L,0L,0x5FDDB278L,0x417BD2F3L,0x21B6B7D2L,0xA5B5AAB3L,0xA799B5C0L},{1L,0x2FD2206DL,0xD266E85BL,0x21B6B7D2L,2L,0x23AE71BBL,1L,0x417BD2F3L,0xA5B5AAB3L,(-1L)}};
                    int i, j;
                    (*l_82) = l_109;
                    if ((safe_sub_func_int32_t_s_s((p_48 || (!(*p_49))), (*p_45))))
                    { /* block id: 38 */
                        return p_47;
                    }
                    else
                    { /* block id: 40 */
                        int32_t l_131 = 1L;
                        int32_t *l_130[2][1][1];
                        int i, j, k;
                        for (i = 0; i < 2; i++)
                        {
                            for (j = 0; j < 1; j++)
                            {
                                for (k = 0; k < 1; k++)
                                    l_130[i][j][k] = &l_131;
                            }
                        }
                        l_132[4][2] = (safe_mul_func_int16_t_s_s((p_48 == (safe_mod_func_uint32_t_u_u(((safe_unary_minus_func_uint64_t_u((safe_sub_func_int32_t_s_s(l_120, (safe_sub_func_int64_t_s_s(p_48, ((l_120 <= (0x1A1E6DEAL == (safe_add_func_int64_t_s_s(l_127[0][1][1], p_48)))) == (safe_lshift_func_int8_t_s_u(p_48, (*l_90)))))))))) != p_48), 0x346F960BL))), 0x6B6EL));
                    }
                    if (l_88[0])
                        break;
                }
            }
        }
    }
    (*l_133) = l_109.f1;
    (*l_133) = 0x0.1p+1;
    return l_88[0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_54(int32_t * p_55, int32_t * p_56, const uint32_t  p_57, const int8_t  p_58, int32_t * p_59)
{ /* block id: 20 */
    int32_t l_92 = 0x08C6EC2AL;
    int32_t *l_101[2];
    int32_t **l_100 = &l_101[1];
    float l_103 = 0x1.Cp-1;
    float *l_102 = &l_103;
    struct S0 l_104 = {2775,9,-15};
    int i;
    for (i = 0; i < 2; i++)
        l_101[i] = (void*)0;
    for (l_92 = 15; (l_92 <= 3); l_92 = safe_sub_func_uint16_t_u_u(l_92, 1))
    { /* block id: 23 */
        int32_t *l_96 = &l_92;
        int32_t ** const l_95 = &l_96;
        const int32_t **l_98 = (void*)0;
        const int32_t ***l_97[4];
        int32_t ***l_99 = (void*)0;
        int i;
        for (i = 0; i < 4; i++)
            l_97[i] = &l_98;
        l_100 = l_95;
        /* statement id: 24 */
        assert (l_100 == &l_96);
        (*l_100) = func_60((**l_95));
        /* statement id: 25 */
        assert (l_96 == 0);
        p_56 = p_59;
        /* statement id: 26 */
        //assert (p_56 == &l_91 || (p_56 >= &l_143[0] && p_56 <= &l_143[3]) || p_56 == &l_138 || (p_56 >= &l_23[0] && p_56 <= &l_23[2]));
    }
    /* facts after for loop */
    //assert (p_56 == &l_91 || p_56 == 0 || (p_56 >= &l_143[0] && p_56 <= &l_143[3]) || p_56 == &l_138 || (p_56 >= &l_23[0] && p_56 <= &l_23[2]));
    //assert (l_100 == dangling || (l_100 >= &l_101[0] && l_100 <= &l_101[1]));
    (*l_102) = 0xE.CFC9AAp+50;
    return l_104;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_60(float  p_61)
{ /* block id: 13 */
    int32_t l_68 = 0xBA8A7E8BL;
    int32_t *l_69 = &l_68;
    struct S0 l_75 = {-788,-1,-6};
    struct S0 *l_74 = &l_75;
    int32_t *l_76 = &l_68;
    int32_t *l_77 = &l_68;
    int32_t *l_78 = &l_68;
    int32_t *l_79 = (void*)0;
    (*l_74) = func_62(l_68, &l_68, l_68, &l_68, l_69);
    (*l_74) = (*l_74);
    return l_79;
    /* statement id: 19 */
    //assert (func_60_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_62(float  p_63, int32_t * p_64, const uint16_t  p_65, int32_t * p_66, int32_t * p_67)
{ /* block id: 14 */
    int32_t l_71 = 6L;
    int32_t *l_70 = &l_71;
    int32_t **l_72 = &l_70;
    struct S0 l_73 = {3060,7,-64};
    (*l_72) = l_70;
    return l_73;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 86
   depth: 1, occurrence: 9
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 9
breakdown:
   indirect level: 0, occurrence: 9
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 26

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 116
   depth: 2, occurrence: 25
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 115

XXX times a variable address is taken: 196
XXX times a pointer is dereferenced on RHS: 44
breakdown:
   depth: 1, occurrence: 36
   depth: 2, occurrence: 3
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 38
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 436

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 88
   level: 2, occurrence: 23
   level: 3, occurrence: 10
   level: 4, occurrence: 9
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 40
XXX average alias set size: 1.32

XXX times a non-volatile is read: 425
XXX times a non-volatile is write: 129
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 110
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 18
   depth: 2, occurrence: 11
   depth: 3, occurrence: 15
   depth: 4, occurrence: 17
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 14.6
XXX percentage an existing variable is used: 85.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

