/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1896886208
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   int32_t  f1;
   uint32_t  f2;
   uint16_t  f3;
   signed f4 : 26;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_26(void);
static int32_t * func_28(int32_t * p_29, uint16_t  p_30, int16_t  p_31, int32_t * p_32, uint16_t  p_33);
inline static uint32_t  func_35(union U0  p_36);
inline static union U0  func_37(uint32_t  p_38);
static int32_t  func_39(const int32_t * p_40, int16_t  p_41);
static int32_t * func_42(int32_t * p_43, uint32_t  p_44, int32_t * p_45);
static const uint32_t  func_51(int16_t  p_52, int32_t ** p_53, float  p_54, const int32_t ** p_55, int32_t ** p_56);
inline static const uint16_t  func_65(float * p_66, int32_t  p_67, int32_t ** p_68, int32_t  p_69);
static float * func_70(uint32_t  p_71, int32_t  p_72, uint32_t  p_73);
inline static int32_t  func_74(float * p_75, int32_t ** p_76, int32_t  p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_26(void)
{ /* block id: 36 */
    uint32_t l_27 = 0x5C8100C4;
    int32_t *l_47 = (void*)0;
    float l_162 = 0x1.0p+1;
    float *l_161 = &l_162;
    int32_t **l_204 = &l_47;
    int32_t ***l_203 = &l_204;
    int32_t ****l_202 = &l_203;
    int32_t *****l_201 = &l_202;
    if (l_27)
    { /* block id: 37 */
        int32_t *l_34 = (void*)0;
        uint32_t l_46 = 0x0C3F30B9;
        uint32_t l_165 = 4294967295U;
        uint32_t l_193 = 6U;
        int32_t **l_197 = &l_34;
        int32_t ***l_199 = &l_197;
        int32_t ****l_198 = &l_199;
        int32_t *****l_205 = &l_202;
lbl_200:
        (*l_197) = func_28(l_34, (func_35(func_37(((0x74CA7790 >= func_39(func_42(l_34, l_46, l_47), ((l_46 > l_46) && l_46))) || l_165))) < 0x86A01D58), l_165, l_47, l_193);
        (*l_198) = &l_197;
        if (l_27)
            goto lbl_200;
        l_205 = l_201;
    }
    else
    { /* block id: 132 */
        int16_t l_206 = 0x627D;
        return l_206;
    }
    return l_27;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_28(int32_t * p_29, uint16_t  p_30, int16_t  p_31, int32_t * p_32, uint16_t  p_33)
{ /* block id: 125 */
    int32_t l_196 = 0x385C65EB;
    int32_t *l_195 = &l_196;
    int32_t **l_194 = &l_195;
    (*l_194) = p_32;
    /* statement id: 126 */
    assert (l_195 == 0);
    return p_32;
    /* statement id: 127 */
    //assert (func_28_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_35(union U0  p_36)
{ /* block id: 121 */
    const int32_t l_189 = 0x60A43F84;
    const int32_t *l_188 = &l_189;
    int32_t l_191 = 0xCD9D43CF;
    int32_t *l_190 = &l_191;
    int32_t **l_192 = &l_190;
    (*l_190) = ((1 > p_36.f3) | func_39(l_188, p_36.f2));
    (*l_192) = func_42(&l_191, (((void*)0 == &l_191) & 0xE296), &l_191);
    return p_36.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_37(uint32_t  p_38)
{ /* block id: 109 */
    int32_t l_167 = 0x31A2D786;
    int32_t *l_166 = &l_167;
    uint32_t l_179 = 4294967287U;
    union U0 *l_180 = (void*)0;
    int32_t **l_184 = &l_166;
    union U0 l_186 = {0xA878ACAA};
    union U0 *l_185 = &l_186;
    union U0 l_187 = {0xACEBE310};
    if (p_38)
    { /* block id: 110 */
        int32_t *l_168 = &l_167;
        int32_t **l_169 = (void*)0;
        int32_t **l_170 = &l_166;
        float l_178 = 0x0.Bp-1;
        float *l_177 = &l_178;
        union U0 l_182 = {-3};
        union U0 *l_181 = &l_182;
        l_168 = l_166;
        (*l_170) = l_168;
        (*l_177) = ((float)((l_166 != l_168) >= (((void*)0 != l_166) <= (*l_166))) - (float)((float)((-0x1.3p+1) != ((float)((0x8.B285FAp-48 == (__builtin_ffsl(p_38) < 0x5.4EF14Fp+68)) > 0x3.84E0FFp-0) + (float)p_38)) - (float)p_38));
        (*l_168) = ((*l_166) > ((p_38 != (p_38 <= ((*l_166) <= (((p_38 != ((l_179 == p_38) > p_38)) == (l_180 == l_181)) <= (*l_166))))) <= 0xB.1248EFp-47));
    }
    else
    { /* block id: 115 */
        union U0 l_183 = {0x567A964C};
        return l_183;
        /* statement id: 116 */
            }
    (*l_184) = &l_167;
    (*l_166) = __builtin_popcountll(((void*)0 != l_185));
    return l_187;
    /* statement id: 120 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_39(const int32_t * p_40, int16_t  p_41)
{ /* block id: 106 */
    union U0 l_164 = {-1};
    union U0 *l_163 = &l_164;
    l_163 = l_163;
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_42(int32_t * p_43, uint32_t  p_44, int32_t * p_45)
{ /* block id: 38 */
    int32_t l_49 = (-1);
    int32_t *l_48 = &l_49;
    int32_t **l_50 = &l_48;
    int32_t **l_57 = &l_48;
    const int32_t **l_58 = (void*)0;
    int32_t l_159 = 0xEF7B85BF;
    int32_t *l_160 = &l_49;
    (*l_50) = l_48;
    (*l_160) = (func_51(p_44, l_57, (*l_48), l_58, &l_48) | (((int16_t)(((int16_t)((int16_t)((int16_t)l_159 << (int16_t)6) << (int16_t)(l_57 != &p_45)) + (int16_t)p_44) != 65535U) >> (int16_t)4) | p_44));
    /* statement id: 104 */
    //assert (l_48 == dangling || l_48 == 0);
    return p_43;
    /* statement id: 105 */
    //assert (func_42_rv == 0 || func_42_rv == &l_191);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_51(int16_t  p_52, int32_t ** p_53, float  p_54, const int32_t ** p_55, int32_t ** p_56)
{ /* block id: 40 */
    float l_60 = (-0x1.Bp-1);
    float *l_59 = &l_60;
    int32_t l_61 = (-2);
    float *l_78 = &l_60;
    uint16_t l_84 = 0U;
    union U0 l_149 = {1};
    union U0 *l_148 = &l_149;
lbl_135:
    (*l_59) = (-0x4.Bp+1);
    if (((l_61 == (+((l_61 | (((uint16_t)func_65(func_70(l_61, func_74(l_78, p_53, l_61), ((uint16_t)(0x1D57 | (l_84 != l_84)) >> (uint16_t)13)), l_61, p_53, l_61) << (uint16_t)p_52) | l_84)) ^ l_61))) != 4294967286U))
    { /* block id: 51 */
        int16_t l_95 = (-4);
        int32_t *l_96 = (void*)0;
        int32_t *l_97 = &l_61;
        union U0 l_99 = {0x72C66C3C};
        union U0 *l_98 = &l_99;
        (*p_53) = (void*)0;
        /* statement id: 52 */
        //assert (l_48 == 0);
        (*l_97) = ((0U >= p_52) == ((uint16_t)p_52 + (uint16_t)((+(l_95 >= l_84)) >= l_84)));
        l_98 = (void*)0;
        /* statement id: 54 */
        assert (l_98 == 0);
    }
    else
    { /* block id: 55 */
        uint16_t l_100 = 0x5CCC;
        float *l_103 = &l_60;
        int32_t l_142 = (-3);
        float *l_146 = &l_60;
        union U0 *l_150 = &l_149;
lbl_134:
        (*p_56) = func_70(l_100, (((uint16_t)func_65(l_103, l_84, p_53, l_84) << (uint16_t)(((int16_t)p_52 % (int16_t)((int32_t)p_52 + (int32_t)((l_100 < l_61) != l_61))) >= p_52)) != l_100), p_52);
        /* statement id: 56 */
        //assert (l_48 == 0);
        for (l_61 = (-19); (l_61 <= (-21)); l_61--)
        { /* block id: 59 */
            uint32_t l_114 = 0xB8AEA200;
            uint16_t l_115 = 1U;
            for (l_100 = 0; (l_100 > 1); l_100++)
            { /* block id: 62 */
                l_115 = ((int32_t)l_114 - (int32_t)p_52);
            }
            for (l_84 = (-11); (l_84 >= 27); l_84 += 1)
            { /* block id: 67 */
                float *l_122 = &l_60;
                int32_t l_123 = 0xCAF44556;
                int32_t *l_126 = &l_123;
                uint32_t l_127 = 1U;
                (*l_126) = (l_115 | (((int16_t)p_52 + (int16_t)(((int32_t)(l_122 != (void*)0) + (int32_t)__builtin_ffs(l_123)) & (((uint16_t)p_52 - (uint16_t)(1 < l_123)) != 0x8108B99C))) | l_100));
                if ((0x1065 && (l_114 <= (l_127 | (*l_126)))))
                { /* block id: 69 */
                    float l_130 = 0x9.DB7DE5p-70;
                    int32_t l_133 = 0x1744B85C;
                    for (l_114 = 0; (l_114 == 17); ++l_114)
                    { /* block id: 72 */
                        (*p_56) = func_70(l_114, func_74(func_70((*l_126), l_114, l_84), p_56, l_84), ((int16_t)(-10) - (int16_t)p_52));
                        /* statement id: 73 */
                        //assert (l_48 == 0);
                    }
                    if (l_84)
                    { /* block id: 75 */
                        (*l_126) = l_133;
                        if (l_100)
                            goto lbl_134;
                        return p_52;
                        /* statement id: 78 */
                        //assert (l_48 == dangling || l_48 == 0);
                    }
                    else
                    { /* block id: 79 */
                        if (l_114)
                            goto lbl_135;
                    }
                    (*l_103) = p_52;
                }
                else
                { /* block id: 83 */
                    (*l_126) = l_100;
                }
                (*p_56) = &l_61;
                /* statement id: 86 */
                //assert (l_48 == &l_61);
            }
            for (l_100 = (-22); (l_100 != 44); l_100 += 2)
            { /* block id: 90 */
                int16_t l_140 = 0;
                float *l_141 = (void*)0;
                int32_t *l_143 = &l_61;
                l_142 = ((uint16_t)l_140 >> (uint16_t)(l_141 == (void*)0));
                (*p_56) = l_143;
                /* statement id: 92 */
                //assert (l_48 == &l_61);
            }
            for (l_84 = 0; (l_84 <= 20); l_84++)
            { /* block id: 96 */
                int32_t *l_147 = &l_142;
                (*l_147) = (func_74(l_146, p_53, l_114) <= l_61);
                /* statement id: 97 */
                //assert (l_48 == dangling);
            }
        }
        /* facts after for loop */
        //assert (l_48 == dangling || l_48 == &l_61 || l_48 == 0);
        (*p_56) = &l_61;
        /* statement id: 100 */
        //assert (l_48 == &l_61);
        (**p_56) = ((l_148 == l_150) >= l_100);
    }
    /* facts after branching */
    //assert (l_48 == &l_61 || l_48 == 0);
    return p_52;
    /* statement id: 103 */
    //assert (l_48 == dangling || l_48 == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_65(float * p_66, int32_t  p_67, int32_t ** p_68, int32_t  p_69)
{ /* block id: 48 */
    int32_t **l_89 = (void*)0;
    int32_t l_90 = (-7);
    uint32_t l_91 = 4U;
    l_91 = l_90;
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_70(uint32_t  p_71, int32_t  p_72, uint32_t  p_73)
{ /* block id: 45 */
    int32_t l_87 = 0;
    int32_t *l_86 = &l_87;
    int32_t **l_85 = &l_86;
    float *l_88 = (void*)0;
    (*l_85) = &p_72;
    /* statement id: 46 */
    assert (l_86 == &p_72);
    return l_88;
    /* statement id: 47 */
    //assert (func_70_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_48
 */
inline static int32_t  func_74(float * p_75, int32_t ** p_76, int32_t  p_77)
{ /* block id: 42 */
    int32_t l_80 = 0x4AB19F88;
    int32_t *l_79 = &l_80;
    int32_t l_81 = 0xCEB2CFB1;
    (*p_76) = l_79;
    /* statement id: 43 */
    //assert (l_48 == &l_80);
    return l_81;
    /* statement id: 44 */
    //assert (l_48 == dangling);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 57
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 9
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 7
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1

XXX total number of pointers: 65

XXX times a variable address is taken: 52
XXX times a pointer is dereferenced on RHS: 7
breakdown:
   depth: 1, occurrence: 7
XXX times a pointer is dereferenced on LHS: 28
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 5
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 123

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 64
   level: 2, occurrence: 16
   level: 3, occurrence: 1
   level: 4, occurrence: 2
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 23
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 35.4
XXX average alias set size: 1.17

XXX times a non-volatile is read: 186
XXX times a non-volatile is write: 70
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 62
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 17
   depth: 2, occurrence: 4
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 19.3
XXX percentage an existing variable is used: 80.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

