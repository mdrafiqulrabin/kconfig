/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2411775712
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   int32_t  f1;
   int32_t  f2;
   signed f3 : 25;
   int8_t  f4;
};
#pragma pack(pop)

struct S1 {
   int8_t  f0;
   int32_t  f1;
   uint32_t  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static int32_t  func_31(int16_t  p_32, struct S1  p_33);
inline static struct S1  func_34(int16_t  p_35, uint16_t  p_36, int32_t  p_37, uint32_t  p_38);
static struct S0  func_61(uint32_t  p_62, int16_t  p_63);
inline static struct S1  func_65(int32_t  p_66, uint32_t  p_67, int32_t  p_68, int32_t  p_69);
static int16_t  func_70(int16_t  p_71, uint32_t  p_72, uint32_t  p_73, uint32_t  p_74);
inline static uint16_t  func_77(uint32_t  p_78, int16_t  p_79, int32_t  p_80, int32_t  p_81, int32_t  p_82);
static int16_t  func_98(int16_t  p_99);
static struct S0  func_101(int32_t  p_102, int32_t  p_103, struct S0  p_104);
static struct S0  func_125(uint32_t  p_126, int16_t  p_127, uint16_t  p_128, int16_t  p_129);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_30 = 4294967294U;
    int32_t l_53 = 1;
    int32_t l_54 = (-1);
    uint32_t l_55 = 1U;
    uint32_t l_720 = 0xDC3FD44F;
    int32_t l_721 = 0x20204D43;
    int32_t l_728 = 8;
    uint16_t l_729 = 0x221F;
    l_721 = ((((l_30 || ((func_31(l_30, func_34(l_30, (l_30 >= ((((int32_t)((uint16_t)(((((int32_t)((uint32_t)((((((uint16_t)((((0xDC068927 == (l_30 && ((int16_t)((l_54 &= ((((uint16_t)9U * (uint16_t)(l_53 ^= (-1))) || l_53) <= 1)) >= l_30) % (int16_t)65535U))) > 0U) <= l_30) , 0x60A3) * (uint16_t)l_30) >= l_30) | l_30) , 0x88DD0BB2) >= l_30) % (uint32_t)l_30) % (int32_t)l_30) > 8) <= l_30) || l_30) >> (uint16_t)l_30) + (int32_t)4294967290U) == l_30) || l_30)), l_30, l_55)) , l_55) | l_55)) && l_720) > l_720) , l_53);
    l_721 |= ((int16_t)((int16_t)((int16_t)(-8) >> (int16_t)5) % (int16_t)(l_54 ^= l_30)) - (int16_t)l_728);
    return l_729;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(int16_t  p_32, struct S1  p_33)
{ /* block id: 436 */
    struct S0 l_719 = {0,0x5BC93694,0xDF2B2CC2,5717,0xA6};
    l_719 = (((-1) >= p_33.f1) , (p_33.f3 , l_719));
    l_719.f2 = p_33.f0;
    l_719.f1 = 0x4F78D624;
    l_719 = l_719;
    return l_719.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_34(int16_t  p_35, uint16_t  p_36, int32_t  p_37, uint32_t  p_38)
{ /* block id: 39 */
    uint32_t l_64 = 4294967295U;
    int32_t l_618 = 0x4FE007C8;
    int32_t l_633 = (-7);
    int16_t l_638 = 0xFDDD;
    struct S1 l_639 = {0x7B,8,4294967295U,1U};
    int8_t l_661 = 0xE4;
    struct S0 l_687 = {0,0x02A17D2C,0,5481,1};
    uint32_t l_695 = 4294967295U;
    if (((int32_t)((uint16_t)((!(func_61(l_64, l_64) , p_37)) > (__builtin_parityl(((int32_t)(((l_618 = 0xCCE4382F) < (l_64 ^ p_35)) | (~((uint16_t)__builtin_bswap64((((uint32_t)(p_38 == l_64) + (uint32_t)4294967291U) > l_64)) >> (uint16_t)l_64))) + (int32_t)l_64)) > l_64)) << (uint16_t)l_64) - (int32_t)l_64))
    { /* block id: 378 */
        int8_t l_624 = 0x94;
        int32_t l_625 = 2;
        l_624 |= (-1);
        l_625 &= l_64;
    }
    else
    { /* block id: 381 */
        uint16_t l_630 = 0xFF9A;
        int32_t l_634 = 0;
        int32_t l_637 = (-10);
        int16_t l_662 = 0xCA00;
        l_639 = func_65((l_64 | ((int16_t)(func_77(__builtin_ctz(p_37), l_618, (l_630 &= ((int16_t)(-1) >> (int16_t)6)), ((uint16_t)(p_36 = ((l_634 = (l_633 |= l_64)) && (l_633 &= p_35))) * (uint16_t)((int16_t)p_38 << (int16_t)14)), l_637) <= l_618) >> (int16_t)13)), l_637, l_638, l_618);
        for (l_638 = (-1); (l_638 >= (-28)); l_638 -= 1)
        { /* block id: 390 */
            int16_t l_646 = 0xC68C;
            int32_t l_655 = 0x47E8BC91;
            if (((p_38 , ((uint16_t)((int16_t)(((-7) == l_646) && (-(int32_t)(l_637 <= 0x3539))) * (int16_t)((int16_t)((uint32_t)l_646 % (uint32_t)p_35) + (int16_t)0xEDA9)) % (uint16_t)0x5DE2)) && 0xF4396986))
            { /* block id: 391 */
                uint32_t l_654 = 4294967295U;
                struct S0 l_660 = {0xC1395983,0x51043381,0xA4A4E663,-5656,1};
                int32_t l_663 = 9;
                l_663 &= (l_637 & (-(uint32_t)((l_633 = (!((l_654 ^ 0x1111) <= (l_655 = l_637)))) ^ (p_35 , (((uint16_t)(p_35 , ((((p_36 && (((((((int32_t)func_98(((func_70(func_98((l_660 , l_661)), l_646, l_662, p_37) > 0x147B7374) == l_630)) + (int32_t)p_36) , l_646) & l_637) == p_38) > p_36) == 0x64565F4F)) < l_639.f2) , l_646) != p_35)) >> (uint16_t)2) && p_37)))));
            }
            else
            { /* block id: 395 */
                uint32_t l_666 = 0x52D6159C;
                int32_t l_676 = 3;
                int32_t l_679 = 6;
                l_666 ^= (p_35 > ((uint32_t)l_655 - (uint32_t)l_637));
                l_655 = (((int16_t)p_38 - (int16_t)((-(uint16_t)p_36) < (((((l_637 ^= p_38) ^ __builtin_clzll(((p_38 , p_38) >= ((((!((9U != (~((uint16_t)p_38 >> (uint16_t)((uint16_t)func_77(((((l_676 = p_35) | (l_679 = (((uint16_t)p_36 - (uint16_t)l_646) && (-2)))) | p_37) , l_646), l_634, p_35, l_639.f1, p_37) >> (uint16_t)0)))) , l_618)) , l_630) > l_634) , p_38)))) == l_666) , 0xC94D) , 0xEF7C))) , l_662);
            }
        }
    }
    if (((int32_t)__builtin_parity(l_639.f0) - (int32_t)p_35))
    { /* block id: 404 */
        int32_t l_684 = 0xCBCBA06C;
        struct S0 l_688 = {0xDD2BEBB7,0xCF79EFB9,0x7C4BCEF9,1824,4};
        int32_t l_696 = 0xBB0C34D6;
        l_696 &= ((int16_t)(l_684 < func_77((l_639.f1 |= p_35), (((p_38 | ((uint16_t)p_36 << (uint16_t)p_37)) , (l_688 = l_687)) , l_618), ((l_633 = ((int16_t)(0x0C5D6087 & ((uint32_t)((((int16_t)l_639.f0 >> (int16_t)11) || l_64) <= l_695) - (uint32_t)l_687.f0)) - (int16_t)0xDDBD)) & 4294967286U), l_684, p_36)) >> (int16_t)14);
        l_687 = l_688;
        for (p_37 = 0; (p_37 != (-15)); p_37 -= 5)
        { /* block id: 412 */
            l_688.f1 = p_36;
            l_688.f1 = ((l_688.f4 , 0xADFA) <= (l_639.f2 | 0x3C0CCDA5));
        }
    }
    else
    { /* block id: 416 */
        int16_t l_713 = 0;
        int32_t l_714 = 0x442C09D4;
        l_618 ^= p_36;
        l_618 |= 0;
        l_687.f2 = p_38;
        for (p_38 = (-28); (p_38 != 58); p_38 += 2)
        { /* block id: 422 */
            uint32_t l_707 = 0x1953091A;
            int32_t l_710 = 0x80D15548;
            l_714 = (((uint16_t)((p_38 & 0xF86416DF) > ((int16_t)p_37 >> (int16_t)((int16_t)(func_98(l_707) , (p_35 = (((int32_t)(p_35 < (__builtin_ffsll(((((l_710 = p_35) ^ l_639.f3) > ((l_713 = ((int32_t)p_35 - (int32_t)0x1E55C009)) == p_38)) >= l_714)) && l_633)) % (int32_t)0x6EA5022A) , p_37))) + (int16_t)p_37))) << (uint16_t)0) < (-1));
        }
    }
    for (l_639.f0 = 0; (l_639.f0 <= 5); l_639.f0 += 1)
    { /* block id: 431 */
        uint32_t l_717 = 1U;
        struct S1 l_718 = {0x04,0xC45A5D76,1U,0U};
        l_717 = (l_687.f3 >= (l_64 < p_38));
        return l_718;
    }
    return l_639;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_61(uint32_t  p_62, int16_t  p_63)
{ /* block id: 40 */
    int8_t l_87 = 1;
    uint32_t l_94 = 0xEF155D26;
    int32_t l_95 = 0x949E3B93;
    int32_t l_100 = 3;
    int32_t l_379 = 0x3EC817FD;
    int32_t l_380 = 1;
    uint32_t l_586 = 5U;
    int32_t l_610 = 0x13829420;
    uint32_t l_611 = 1U;
    uint32_t l_614 = 0x8EC6800D;
    struct S0 l_615 = {3,0xE36B844D,0x42B038F6,-2679,0x75};
    l_611 = ((l_610 = (func_65((func_70((((uint16_t)func_77((p_62 > ((l_380 = (((int32_t)(((uint16_t)(l_87 | __builtin_ctz(p_62)) << (uint16_t)11) , ((uint16_t)((int16_t)((uint16_t)(l_95 = l_94) << (uint16_t)__builtin_bswap32((l_379 = ((int16_t)(p_63 ^= func_98((l_100 = l_94))) << (int16_t)(4294967295U & 0x38FAC8F3))))) << (int16_t)4) >> (uint16_t)p_62)) + (int32_t)l_87) == p_62)) > 0xE8A2)), l_87, p_62, p_62, p_62) << (uint16_t)p_62) > l_94), p_62, l_94, l_586) || 2), l_94, l_87, l_94) , p_62)) & 0x0856);
    l_379 = (((l_610 = (((uint16_t)l_379 << (uint16_t)0) < p_62)) , __builtin_ffs(l_614)) , 0x7C87F6EF);
    return l_615;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_65(int32_t  p_66, uint32_t  p_67, int32_t  p_68, int32_t  p_69)
{ /* block id: 364 */
    struct S1 l_609 = {0x4D,-6,0x3FABB4CE,0x8A993158};
    for (p_67 = 0; (p_67 > 35); p_67 += 2)
    { /* block id: 367 */
        struct S1 l_608 = {0x54,0xCAE0C866,0xF916B209,0xC09C2AF8};
        return l_608;
    }
    p_66 &= p_69;
    return l_609;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_70(int16_t  p_71, uint32_t  p_72, uint32_t  p_73, uint32_t  p_74)
{ /* block id: 356 */
    uint16_t l_587 = 0xD21A;
    int32_t l_588 = (-10);
    struct S1 l_595 = {1,0x9E1C7512,1U,0x6749C67A};
    int32_t l_604 = 0x9BE8EEBD;
    int32_t l_605 = 0xB776CAAF;
    l_588 = ((p_73 , __builtin_ffs(p_74)) < l_587);
    l_605 = ((l_588 = ((int16_t)__builtin_popcountl((l_588 == ((((uint32_t)l_587 - (uint32_t)((uint16_t)((p_72 | ((l_595 = l_595) , l_595.f3)) , (((p_73 || ((((uint16_t)((p_71 & ((int16_t)(((int16_t)(l_604 = (((l_595.f1 = ((uint16_t)l_588 * (uint16_t)(p_71 ^ l_588))) , 4294967292U) && l_595.f1)) - (int16_t)p_72) == l_587) + (int16_t)p_74)) == p_74) - (uint16_t)(-2)) | 0x28D64A8C) < p_74)) , l_595.f1) && 0U)) + (uint16_t)l_588)) == l_587) && l_587))) << (int16_t)p_72)) == 1U);
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_77(uint32_t  p_78, int16_t  p_79, int32_t  p_80, int32_t  p_81, int32_t  p_82)
{ /* block id: 223 */
    uint32_t l_381 = 0x9EB90CB7;
    int32_t l_386 = 0x6B41BF8B;
    int32_t l_387 = 2;
    struct S0 l_392 = {0x22FE3B4D,-3,-2,-4582,0xA5};
    int32_t l_399 = 0xCC42CF14;
    uint16_t l_402 = 1U;
    struct S1 l_407 = {0x3B,0x61F2BE5E,4294967291U,0x5C299F0A};
    struct S0 l_424 = {0x2D3FBA25,0,1,184,0x74};
    uint16_t l_450 = 0x5C48;
    uint32_t l_454 = 0x55D9A9F4;
    struct S1 l_512 = {0xF3,0x68DA2B86,0xEBC6C22D,0x16344ADA};
    uint16_t l_567 = 65530U;
    uint32_t l_568 = 1U;
    int8_t l_585 = 3;
    l_387 = ((((p_78 && l_381) != (l_381 | (0xD166E642 == l_381))) < ((int16_t)((uint16_t)((l_381 == (((l_381 , __builtin_bswap64((l_386 = (l_381 , func_98(l_381))))) < 0x76D4) || l_381)) || p_80) >> (uint16_t)8) >> (int16_t)2)) >= l_381);
    if (((int16_t)(((l_386 |= p_80) | ((uint32_t)p_82 % (uint32_t)(l_392 , 0x2F1BEE13))) , l_386) >> (int16_t)(l_381 & (((l_399 ^= (((int32_t)p_79 - (int32_t)((((((uint32_t)((int16_t)p_78 % (int16_t)(l_392 , 65535U)) + (uint32_t)0x68BDAEAC) ^ 0xD959476D) <= 0x6D61) != l_387) ^ p_79)) | p_78)) < 6U) || 0xDC72))))
    { /* block id: 228 */
        int32_t l_400 = 2;
        struct S1 l_409 = {-9,0,0x5A2E80C1,4294967295U};
        l_400 = l_392.f0;
        p_80 = (-6);
        l_402 = (p_82 = ((p_79 && p_81) & (l_399 > ((!l_400) , p_81))));
        for (p_80 = 0; (p_80 == (-19)); p_80 -= 1)
        { /* block id: 235 */
            struct S0 l_408 = {1,0,0x63DC5F1F,-2734,0x27};
            struct S1 l_410 = {1,0,0x106A118B,0U};
            struct S1 l_411 = {0x09,0xCF3CF5C4,1U,0x9C4F5B09};
            p_82 = ((int16_t)0 >> (int16_t)2);
            l_407 = l_407;
            l_411 = (l_408 , (l_410 = l_409));
            if (p_82)
                continue;
        }
    }
    else
    { /* block id: 242 */
        return l_402;
    }
    if (((l_392.f1 = (((uint16_t)p_81 * (uint16_t)l_392.f2) || ((int32_t)l_407.f0 - (int32_t)(p_82 | (p_79 >= (((int16_t)__builtin_ctzll(l_392.f0) + (int16_t)((int16_t)((uint16_t)(l_386 = p_82) % (uint16_t)l_402) << (int16_t)15)) == 65535U)))))) > p_81))
    { /* block id: 247 */
        return p_81;
    }
    else
    { /* block id: 249 */
        struct S1 l_428 = {0x5C,0x03915363,0U,0x8637AB95};
        struct S1 l_429 = {0xFD,-10,0xA24AB212,0xE98BD8E4};
        struct S0 l_475 = {0x201F7759,0x872F0210,0,3593,-7};
        int32_t l_476 = (-6);
        uint16_t l_525 = 0U;
        for (l_392.f2 = 0; (l_392.f2 <= 28); l_392.f2 += 5)
        { /* block id: 252 */
            struct S0 l_425 = {-5,-9,0x311AFC6C,5262,0x4F};
            struct S1 l_426 = {-6,-1,0xCECA46E4,4294967290U};
            uint16_t l_458 = 0x0059;
            uint32_t l_513 = 8U;
            l_425 = l_424;
            if ((0x5F55AF59 && func_98(l_425.f2)))
            { /* block id: 254 */
                struct S1 l_427 = {4,0,0U,4294967295U};
                l_427 = l_426;
                l_429 = (l_428 = (l_426 = l_407));
            }
            else
            { /* block id: 259 */
                int8_t l_443 = 0xB5;
                struct S0 l_465 = {-6,0x7810A829,0,66,6};
                if (((!(!(-(int32_t)(p_82 <= ((((uint16_t)((1U | ((p_82 , p_81) ^ (0 | (((int16_t)p_79 % (int16_t)((int16_t)(l_399 ^= p_78) % (int16_t)(((int32_t)((l_443 < l_425.f1) != 0x678C) % (int32_t)p_82) | 0))) , l_429.f2)))) && 0xD264594D) - (uint16_t)l_443) <= p_81) && 4U))))) , l_387))
                { /* block id: 261 */
                    uint16_t l_452 = 8U;
                    int32_t l_453 = 0xCF5EBA1C;
                    for (l_429.f2 = 15; (l_429.f2 >= 17); l_429.f2 += 1)
                    { /* block id: 264 */
                        p_82 = ((int32_t)((int16_t)(65535U <= ((l_443 , ((l_428.f0 || func_98(p_78)) < l_450)) > ((((l_453 ^= ((-(uint16_t)(p_78 < l_452)) <= __builtin_bswap32(p_82))) | p_81) == 65529U) && 0xC51F))) + (int16_t)l_452) % (int32_t)l_443);
                    }
                    p_80 = l_443;
                    l_424.f3 = (-1);
                }
                else
                { /* block id: 270 */
                    uint32_t l_455 = 1U;
                    if (p_78)
                    { /* block id: 271 */
                        l_455 = (l_454 != (l_429.f1 ^ __builtin_ctz(p_79)));
                    }
                    else
                    { /* block id: 273 */
                        return p_79;
                    }
                }
                if (__builtin_clzl((p_78 = ((int16_t)l_458 % (int16_t)p_82))))
                { /* block id: 278 */
                    struct S0 l_466 = {0x2B35768B,0xA003838D,0xC2158B6C,-3707,-6};
                    l_465.f2 = ((int32_t)p_81 + (int32_t)(((uint16_t)65535U >> (uint16_t)2) <= ((uint16_t)((l_466 = l_465) , (((uint32_t)((l_465.f3 ^ (l_443 != l_428.f3)) > ((uint16_t)(((uint16_t)(5U || (-1)) * (uint16_t)(p_78 && p_79)) | p_80) - (uint16_t)p_80)) + (uint32_t)p_80) && (-8))) + (uint16_t)65535U)));
                    for (p_79 = (-10); (p_79 > 19); p_79 += 1)
                    { /* block id: 283 */
                        l_425 = l_475;
                        p_80 = l_465.f4;
                        p_80 = p_82;
                    }
                    if (p_80)
                        break;
                }
                else
                { /* block id: 289 */
                    p_82 &= p_78;
                }
                l_407.f1 = ((1U & l_428.f3) , (0x21C5DCD7 >= __builtin_ia32_crc32qi(l_476, ((int16_t)((((uint16_t)(l_387 = l_465.f2) >> (uint16_t)8) && ((p_80 < ((p_82 = (l_475.f1 &= l_407.f1)) < (l_424.f2 = p_80))) & func_98(((uint16_t)p_79 + (uint16_t)p_80)))) , p_80) * (int16_t)1))));
            }
            for (l_407.f3 = 0; (l_407.f3 >= 39); l_407.f3 += 3)
            { /* block id: 300 */
                uint32_t l_492 = 4294967295U;
                int32_t l_522 = 0;
                if ((-(int32_t)((l_475.f1 , ((0xFE5494DA | l_424.f0) == p_80)) , ((l_429 , (((int16_t)(((int32_t)(((l_425.f2 &= (((uint16_t)(0x65595804 <= 0x58D355F8) - (uint16_t)func_98(l_428.f1)) | 0)) && 0x8A81) , 0) % (int32_t)0x105CDAAA) <= 0) >> (int16_t)l_492) && l_399)) , p_78))))
                { /* block id: 302 */
                    p_80 = l_475.f0;
                }
                else
                { /* block id: 304 */
                    struct S0 l_501 = {1,-1,0xBFB7874E,5043,-1};
                    p_82 = ((uint32_t)(func_98(((int16_t)func_98(p_78) * (int16_t)0xDCFA)) >= (func_98(p_82) > (((int16_t)((uint32_t)(l_501 , (l_425.f3 = ((uint32_t)((int32_t)(((int16_t)(__builtin_ctzl(((int16_t)((int16_t)(l_407.f3 , (0xA13E <= p_81)) % (int16_t)0x79A9) - (int16_t)p_82)) < l_425.f4) >> (int16_t)p_78) == p_81) % (int32_t)4) - (uint32_t)p_82))) % (uint32_t)p_82) >> (int16_t)p_81) != l_501.f4))) + (uint32_t)4294967290U);
                }
                l_512 = l_426;
                l_513 = l_492;
                for (l_512.f0 = 0; (l_512.f0 > (-24)); l_512.f0 -= 5)
                { /* block id: 312 */
                    l_525 = (((uint16_t)((l_492 > p_82) , func_98((((l_428.f1 |= ((uint16_t)(p_79 > p_79) * (uint16_t)p_80)) > (0x20D47AE4 <= ((uint32_t)(l_522 = p_80) + (uint32_t)(((int16_t)(((l_492 <= ((l_426.f1 & l_512.f2) & l_513)) | l_426.f0) > 0x67AF) + (int16_t)l_429.f3) <= 2)))) , p_82))) >> (uint16_t)9) <= p_80);
                    if (p_82)
                        continue;
                }
            }
        }
        if (l_512.f1)
        { /* block id: 320 */
            return p_80;
        }
        else
        { /* block id: 322 */
            int16_t l_538 = 0;
            struct S1 l_539 = {0x2F,6,0x1604B60D,9U};
            struct S0 l_572 = {1,1,2,3928,0x4C};
            if (((uint32_t)((uint16_t)(((((l_407.f1 , (p_80 > ((p_79 < ((int16_t)((int32_t)(l_428.f1 |= (l_424.f2 = (-6))) * (int32_t)(((int32_t)l_407.f2 % (int32_t)(l_392.f2 ^= p_80)) != p_78)) + (int16_t)((uint16_t)(l_392.f0 != (5U <= 0x77BF)) % (uint16_t)p_82))) > p_78))) < 0x39A9A977) < p_82) || l_475.f2) & l_538) - (uint16_t)0xED38) - (uint32_t)(-1)))
            { /* block id: 326 */
                uint32_t l_546 = 0xA54E828D;
                int32_t l_547 = 0xD45CBE32;
                l_539 = l_407;
                for (l_429.f0 = 0; (l_429.f0 == 14); l_429.f0 += 1)
                { /* block id: 330 */
                    uint32_t l_542 = 0xA608220E;
                    return l_542;
                }
                for (p_82 = 0; (p_82 >= 28); p_82 += 3)
                { /* block id: 335 */
                    p_80 = 0xAC02156A;
                    p_80 = (-(int32_t)(l_546 == p_79));
                }
                l_407.f1 = (l_424.f0 == (l_547 ^= func_98(l_476)));
            }
            else
            { /* block id: 341 */
                uint32_t l_569 = 0U;
                l_429.f1 = ((int16_t)((1 & (!(p_79 ^ ((uint32_t)p_82 + (uint32_t)((int16_t)((int16_t)(((uint16_t)func_98(((l_568 = (!((((int16_t)l_429.f0 >> (int16_t)11) && (p_81 , (l_386 = (4294967291U > (l_525 & ((int16_t)((uint16_t)((-(int32_t)l_475.f4) | (p_81 || l_512.f2)) * (uint16_t)l_567) - (int16_t)0U)))))) < 0x13A0))) , l_525)) % (uint16_t)(-10)) && 1U) * (int16_t)l_569) * (int16_t)(-1)))))) != p_81) >> (int16_t)9);
                p_80 = ((int16_t)l_429.f2 << (int16_t)7);
                l_572 = l_392;
            }
            l_572.f2 &= (((uint16_t)(((((int16_t)(((l_392.f2 |= (((int16_t)l_572.f4 * (int16_t)0x43A9) || (-5))) , p_81) & ((uint16_t)((uint16_t)(l_475.f1 = l_407.f3) + (uint16_t)p_80) * (uint16_t)l_539.f1)) >> (int16_t)7) || ((int32_t)p_80 + (int32_t)(p_82 < 2))) && p_82) , 4U) << (uint16_t)6) && 0x7702A8D5);
        }
        p_82 = l_429.f1;
        l_475 = func_125(l_585, l_568, p_78, l_475.f4);
    }
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_98(int16_t  p_99)
{ /* block id: 43 */
    struct S0 l_112 = {-6,-8,0x3D1F0774,-3354,0x86};
    struct S0 l_124 = {0x469BA6CE,0,1,-561,0x4B};
    struct S1 l_149 = {0x29,0x6C84E0FF,0x89711EE9,0x90BC8DDD};
    struct S1 l_150 = {0xB5,-1,0U,0x4D5CE257};
    struct S0 l_218 = {-1,5,0x72DD7AA1,237,0xF8};
    int32_t l_221 = 0xC2149379;
    int8_t l_371 = 0x8E;
    int16_t l_378 = 0xD9C6;
    l_124 = func_101(((~((int32_t)((int16_t)p_99 % (int16_t)((uint16_t)(l_112.f3 = (l_112.f2 = ((l_112 , ((int16_t)((((((uint32_t)(-(int16_t)((uint16_t)((int16_t)p_99 + (int16_t)p_99) % (uint16_t)0x3511)) + (uint32_t)4294967290U) > ((((int16_t)(__builtin_clzl((l_112.f3 | ((l_112.f1 = 0x36B7) ^ p_99))) > l_112.f3) - (int16_t)l_112.f2) || l_112.f4) || p_99)) , p_99) >= 0xC626C480) , 0xEDB7) % (int16_t)l_112.f4)) < 0xF9B9B769))) - (uint16_t)l_112.f0)) % (int32_t)p_99)) <= l_112.f4), p_99, l_124);
    if ((l_112.f2 ^= 0xFEB662F6))
    { /* block id: 63 */
        uint32_t l_152 = 0x48EFB741;
        int32_t l_156 = 0xEB0A878A;
        int32_t l_210 = 2;
        struct S0 l_219 = {0x086A49EC,0x5FD91334,0xAA511DFB,4880,0x2D};
        uint16_t l_290 = 0xD3F0;
        int8_t l_349 = 0x4D;
        struct S1 l_352 = {0x90,0x15924B58,1U,0x31D84D61};
        for (l_124.f0 = 13; (l_124.f0 >= 23); l_124.f0 += 2)
        { /* block id: 66 */
            struct S1 l_148 = {0x17,0x50B285FA,4294967295U,0x7E4F0550};
            struct S0 l_184 = {0x16036A63,0x38755624,0x259ABB1F,-3255,0x5F};
            int32_t l_223 = 0;
            struct S1 l_240 = {0x04,4,4294967295U,1U};
            uint32_t l_268 = 0xB9750434;
            l_150 = (l_149 = l_148);
            if (((p_99 >= l_124.f3) & (p_99 > (-(uint32_t)0x79FF8A60))))
            { /* block id: 69 */
                uint16_t l_153 = 0U;
                int32_t l_154 = (-1);
                l_154 = (p_99 | (l_153 = l_152));
                if (l_112.f2)
                { /* block id: 72 */
                    l_156 = (0x3A861C21 > (!0xE3C26F71));
                }
                else
                { /* block id: 74 */
                    uint32_t l_169 = 0x2D68B998;
                    int32_t l_170 = 0xA0E29635;
                    struct S1 l_176 = {0x95,-9,4294967295U,3U};
                    if (p_99)
                    { /* block id: 75 */
                        uint16_t l_168 = 0U;
                        l_156 = ((int32_t)((uint16_t)((p_99 & p_99) != ((int16_t)(-(uint16_t)(((((uint16_t)((uint16_t)(l_168 , l_169) * (uint16_t)(l_170 ^= l_152)) + (uint16_t)l_168) > p_99) >= ((((uint16_t)(l_154 = p_99) * (uint16_t)(((uint32_t)l_168 % (uint32_t)3) <= 65534U)) , l_169) < 0x421460D0)) , 65535U)) + (int16_t)p_99)) + (uint16_t)l_168) - (int32_t)p_99);
                    }
                    else
                    { /* block id: 79 */
                        struct S1 l_175 = {0x5F,-5,0x961C1CC9,0x5B1D915A};
                        l_149 = l_175;
                        l_148 = l_176;
                    }
                }
                if (l_153)
                    break;
            }
            else
            { /* block id: 85 */
                uint16_t l_177 = 65528U;
                uint32_t l_180 = 8U;
                int32_t l_187 = 0xB46BF440;
                struct S0 l_208 = {0x14682580,0,0xC7C59C4C,-4988,-2};
                l_156 = p_99;
                l_148.f1 |= l_177;
                if (((int32_t)(((l_148.f1 = l_148.f3) , ((p_99 || ((p_99 >= ((l_148.f1 = p_99) > (l_180 == ((int16_t)p_99 >> (int16_t)3)))) & l_148.f0)) & __builtin_ctzll((((l_180 == (p_99 | 0x1A0BB31F)) && l_156) < 0x9DB0B106)))) > p_99) + (int32_t)l_148.f3))
                { /* block id: 90 */
                    struct S0 l_183 = {0xB615696D,0x24557DD3,0xD88E7D84,-2926,1};
                    if (l_152)
                        break;
                    l_184 = l_183;
                }
                else
                { /* block id: 93 */
                    if (l_148.f1)
                        break;
                    l_148.f1 = ((l_149.f1 = (p_99 & (((0x39C74932 && 0xC18A6757) ^ 0x4B59) , p_99))) , ((((l_184.f3 |= ((l_152 > __builtin_ctz((l_187 = ((uint16_t)l_148.f0 % (uint16_t)p_99)))) ^ l_180)) != l_148.f3) < 1) , l_152));
                    l_184.f2 = l_152;
                    if (p_99)
                        continue;
                }
                for (l_156 = 0; (l_156 != 8); l_156 += 2)
                { /* block id: 104 */
                    int32_t l_190 = (-9);
                    int32_t l_209 = 1;
                    l_190 = l_156;
                    if (l_190)
                        continue;
                    l_149.f1 |= l_152;
                    for (l_124.f2 = 0; (l_124.f2 > (-19)); l_124.f2 -= 5)
                    { /* block id: 110 */
                        int8_t l_201 = 0x26;
                        struct S0 l_207 = {0x76872175,0,0xC9419881,3908,0x70};
                        l_207.f1 = ((uint16_t)(l_209 = (((uint32_t)((((int16_t)((int32_t)p_99 - (int32_t)(p_99 || l_148.f2)) + (int16_t)l_201) & p_99) > (~((((int16_t)(-3) >> (int16_t)((l_187 = (((int16_t)(7 != (l_150.f1 <= (((l_208 = l_207) , l_190) , 0xBEE021B6))) % (int16_t)l_112.f0) <= l_207.f1)) < p_99)) && 65535U) , p_99))) % (uint32_t)p_99) || l_177)) << (uint16_t)l_148.f3);
                        l_208 = l_112;
                        l_210 = (l_209 < (((l_208.f2 = (0x5301 & (p_99 == p_99))) | (0U | (((((l_180 | l_184.f4) , __builtin_parityll(p_99)) != p_99) >= 1) > l_152))) <= p_99));
                    }
                }
            }
            if (l_149.f1)
            { /* block id: 121 */
                struct S0 l_222 = {-2,-1,0x61E81591,967,0x52};
                uint32_t l_228 = 4294967295U;
                int8_t l_271 = 7;
                for (l_112.f2 = 8; (l_112.f2 > (-6)); l_112.f2 -= 1)
                { /* block id: 124 */
                    struct S0 l_217 = {0x624ADBFC,-1,-10,797,1};
                    int16_t l_237 = 0x33B0;
                    if ((((((int16_t)0x7C09 >> (int16_t)1) | (l_184.f1 = (l_221 = ((uint16_t)(0U && __builtin_bswap64(((l_217 = (l_219 = (l_218 = l_217))) , (p_99 || (p_99 , (p_99 != l_148.f3)))))) >> (uint16_t)((-(int16_t)p_99) || 0x5A85F17F))))) && p_99) , l_219.f3))
                    { /* block id: 130 */
                        l_218.f3 ^= l_148.f0;
                        l_184 = l_222;
                    }
                    else
                    { /* block id: 133 */
                        l_222.f3 = (l_223 & (((uint16_t)(l_219.f2 | ((int32_t)((l_222.f2 |= l_228) && (((int16_t)(((int16_t)((int16_t)((int16_t)l_217.f4 - (int16_t)0xDFA0) % (int16_t)(l_222.f1 = l_222.f0)) + (int16_t)l_219.f3) ^ l_184.f1) * (int16_t)p_99) , p_99)) - (int32_t)l_237)) % (uint16_t)p_99) || 0x3A6FA7AC));
                    }
                    if (((((((int16_t)0 << (int16_t)(l_240 , l_228)) & (((uint16_t)__builtin_popcount(p_99) >> (uint16_t)((l_149.f0 & (!((l_184.f2 &= __builtin_bswap64((l_222.f3 = p_99))) > ((uint16_t)p_99 % (uint16_t)l_222.f1)))) <= 0x5F7AC17A)) < p_99)) & 4294967295U) && l_184.f4) == p_99))
                    { /* block id: 140 */
                        uint32_t l_252 = 0U;
                        struct S0 l_257 = {0x13937DDB,0x4655A230,0x5BDB629B,-3587,-1};
                        int32_t l_258 = 0xCFAA13AD;
                        l_258 ^= ((int32_t)((int16_t)(((uint32_t)p_99 % (uint32_t)l_219.f1) < (l_252 = 1)) >> (int16_t)4) + (int32_t)((int16_t)((int16_t)(func_101(l_222.f2, (p_99 , l_150.f0), (l_257 = func_101(l_237, p_99, l_217))) , p_99) << (int16_t)l_219.f1) + (int16_t)0xB4E1));
                        l_257 = func_125(((((((p_99 && (((((((((p_99 ^ ((uint16_t)p_99 * (uint16_t)((~(l_222.f2 = (((int32_t)(p_99 , 0xF82136C5) - (int32_t)p_99) < ((l_124.f3 < (p_99 , ((~((((uint16_t)p_99 % (uint16_t)l_219.f4) ^ l_219.f3) || 0x11491AB5)) || l_221))) >= 0x38D1871B)))) ^ 7U))) | 0xF694) | p_99) && p_99) == 0x8841) >= l_252) , 0x809B3B63) > 0x52BDFDB6) >= l_257.f0)) & l_258) ^ p_99) && 0x097F) != (-1)) < l_258), l_218.f0, p_99, l_184.f1);
                        return l_217.f0;
                    }
                    else
                    { /* block id: 147 */
                        int8_t l_267 = 0x15;
                        l_267 = (l_217.f3 , (p_99 , 0xDE8DAFFF));
                        return l_184.f2;
                    }
                }
                l_268 = (-1);
                l_218.f2 = ((uint16_t)p_99 - (uint16_t)l_271);
                l_124.f1 = __builtin_parity((0U && ((int16_t)((int32_t)(__builtin_parity(p_99) , ((uint16_t)p_99 % (uint16_t)l_124.f2)) - (int32_t)0x05FBDCC5) * (int16_t)p_99)));
            }
            else
            { /* block id: 155 */
                uint32_t l_293 = 1U;
                int32_t l_314 = (-1);
                struct S0 l_355 = {0xAF1C7367,0xBF128C11,0xF8ADE7CE,-1768,0xAF};
                struct S0 l_357 = {0x19842934,0x53AB809C,0xC71649D7,-2066,0xDB};
                if ((((l_148 = l_150) , (l_240.f1 = p_99)) & p_99))
                { /* block id: 158 */
                    uint32_t l_278 = 0x74EE3F9E;
                    int32_t l_289 = 5;
                    struct S0 l_291 = {-5,3,0x785CDD8E,-1721,0x11};
                    l_240.f1 ^= p_99;
                    if ((l_124 , p_99))
                    { /* block id: 160 */
                        struct S0 l_288 = {0x6846D414,9,-10,4909,0xC2};
                        l_112.f3 &= ((p_99 && (((l_278 ^= p_99) , p_99) != (((((uint32_t)p_99 - (uint32_t)((l_124.f2 ^= ((uint16_t)(((int16_t)l_240.f2 >> (int16_t)l_152) , ((!p_99) , (__builtin_popcountl((__builtin_ffsl(__builtin_bswap64((l_156 = ((((uint32_t)((l_288 , 0U) ^ l_149.f1) + (uint32_t)p_99) ^ p_99) < l_152)))) , p_99)) ^ p_99))) * (uint16_t)8U)) > l_289)) >= 1) , l_288.f3) <= 4294967295U))) || 1U);
                        l_290 = 0x0C5A6CC1;
                        l_293 ^= (l_291 , (0x317F & (((!p_99) > l_288.f2) , (p_99 < l_288.f3))));
                        l_156 = ((uint32_t)p_99 - (uint32_t)__builtin_clzll(l_219.f4));
                    }
                    else
                    { /* block id: 168 */
                        l_240.f1 = ((uint16_t)(((uint16_t)p_99 << (uint16_t)1) != (((uint16_t)p_99 * (uint16_t)l_184.f3) < (l_218.f3 = (p_99 || ((int32_t)(-8) + (int32_t)((int32_t)(p_99 ^ l_149.f0) - (int32_t)4294967295U)))))) % (uint16_t)((int16_t)((uint32_t)((((p_99 <= l_278) ^ p_99) ^ l_184.f1) , p_99) + (uint32_t)p_99) >> (int16_t)0));
                        l_291.f2 |= l_219.f1;
                    }
                    for (l_149.f0 = (-10); (l_149.f0 <= (-24)); l_149.f0 -= 1)
                    { /* block id: 175 */
                        l_223 = __builtin_parityll(l_218.f4);
                        l_223 = ((int16_t)(l_314 ^= 0) >> (int16_t)(l_291.f1 >= ((uint32_t)p_99 + (uint32_t)p_99)));
                    }
                }
                else
                { /* block id: 180 */
                    return p_99;
                }
                l_219.f2 &= p_99;
                if (((l_240.f0 > l_221) > __builtin_ctzll(p_99)))
                { /* block id: 184 */
                    int16_t l_322 = 0x247C;
                    l_184 = func_125((((int16_t)p_99 % (int16_t)(8U ^ (p_99 >= l_124.f0))) > (!((uint16_t)((l_322 , ((uint16_t)((l_314 = 4294967295U) > (((uint16_t)(p_99 <= (((p_99 < 5U) < 0x85AF14D8) , 65535U)) * (uint16_t)l_293) > p_99)) - (uint16_t)0x04A1)) | 65533U) >> (uint16_t)5))), l_293, p_99, l_293);
                    for (l_150.f3 = (-12); (l_150.f3 == 46); l_150.f3 += 1)
                    { /* block id: 189 */
                        l_314 &= ((uint32_t)(l_149.f1 = ((((uint16_t)__builtin_popcountll((-(int16_t)(((((p_99 & __builtin_ffsll((((uint16_t)l_322 << (uint16_t)((uint16_t)p_99 + (uint16_t)p_99)) , __builtin_popcount((l_293 , p_99))))) <= l_240.f0) , 65535U) ^ l_219.f4) < l_322))) - (uint16_t)l_322) < 0xF4550BB7) > 4294967286U)) + (uint32_t)l_322);
                    }
                }
                else
                { /* block id: 193 */
                    int8_t l_354 = 0xB0;
                    struct S0 l_356 = {1,0x86705CAA,0,-4521,0x2E};
                    struct S1 l_358 = {-1,0xEE5804FE,0U,4294967286U};
                    struct S1 l_359 = {0x9B,0,2U,0x5F8E6D0F};
                    for (l_149.f0 = (-27); (l_149.f0 < (-27)); l_149.f0 += 7)
                    { /* block id: 196 */
                        uint32_t l_348 = 0x1F4020B1;
                        int32_t l_353 = 0x2A01E9A5;
                        l_357 = (l_356 = (l_355 = (((int16_t)(((int32_t)((int32_t)p_99 - (int32_t)p_99) % (int32_t)((uint32_t)l_348 % (uint32_t)((((l_349 , p_99) ^ l_149.f0) & 0xA658) | p_99))) || ((uint16_t)(l_353 ^= (((((l_352 , 0xFDED5E2A) , 1) <= p_99) ^ 0xC0956980) == 0xA00EA8EF)) >> (uint16_t)13)) >> (int16_t)l_354) , l_355)));
                    }
                    l_359 = (l_358 = l_148);
                    if (l_210)
                        continue;
                }
            }
            l_218.f1 ^= ((uint16_t)l_124.f0 >> (uint16_t)(__builtin_popcountll(p_99) == (l_352.f2 >= p_99)));
        }
        l_221 &= 1;
    }
    else
    { /* block id: 210 */
        struct S0 l_362 = {0x4D21402C,0,0x61E3E17F,4385,3};
        l_362 = l_218;
    }
    l_124.f1 &= ((uint16_t)((int16_t)((uint16_t)((uint16_t)(l_149.f1 ^= 0U) + (uint16_t)l_371) * (uint16_t)((uint16_t)(l_218.f2 = p_99) * (uint16_t)((((l_150.f1 = p_99) && p_99) >= ((uint16_t)(l_218.f3 ^= (0x2F87 ^ (((l_112.f3 = (65535U != ((((uint32_t)l_149.f3 + (uint32_t)((p_99 , l_112) , 0xF688C6C9)) >= l_378) | l_112.f4))) , 1U) <= l_124.f3))) * (uint16_t)p_99)) | l_150.f2))) >> (int16_t)l_112.f0) + (uint16_t)0xF53C);
    return p_99;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_101(int32_t  p_102, int32_t  p_103, struct S0  p_104)
{ /* block id: 47 */
    int32_t l_130 = (-1);
    uint16_t l_131 = 65535U;
    int32_t l_140 = 0xA819422B;
    int32_t l_143 = 0x2B75F972;
    int32_t l_144 = 7;
    int32_t l_145 = 0x33A36175;
    p_104 = func_125(l_130, l_131, p_102, p_102);
    p_104.f1 = (((uint16_t)((((((l_131 | 1) ^ (((uint16_t)(p_104.f3 , (l_144 = (__builtin_ffsl(l_131) && (l_130 = (l_130 ^ (((l_140 &= (l_130 ^ l_130)) <= ((int16_t)(l_143 = (((0xF20BB848 || 0x6043366F) && 0x5813) , 0)) % (int16_t)l_130)) && p_104.f1)))))) % (uint16_t)p_102) || l_143)) == 0x4A936FBA) <= l_131) <= 0x7E7C5724) < 0x5FA5AF98) * (uint16_t)l_131) , l_143);
    l_140 |= l_145;
    return p_104;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_125(uint32_t  p_126, int16_t  p_127, uint16_t  p_128, int16_t  p_129)
{ /* block id: 48 */
    int16_t l_132 = 0xEEA4;
    int32_t l_133 = 0x4FC3DD16;
    struct S1 l_134 = {1,-9,0x879CFBC8,0x47EB4981};
    struct S0 l_135 = {0x8E951F22,8,1,-2954,0xC9};
    l_134 = ((l_133 ^= l_132) , l_134);
    l_133 = __builtin_ffs(l_134.f3);
    return l_135;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 126
   depth: 1, occurrence: 57
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 32
breakdown:
   indirect level: 0, occurrence: 32
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 25
XXX times a bitfields struct on RHS: 30
XXX times a single bitfield on LHS: 11
XXX times a single bitfield on RHS: 15

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 192
   depth: 2, occurrence: 31
   depth: 3, occurrence: 10
   depth: 4, occurrence: 8
   depth: 5, occurrence: 6
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 5
   depth: 18, occurrence: 5
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 3
   depth: 22, occurrence: 3
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 2
   depth: 33, occurrence: 1
   depth: 40, occurrence: 2

XXX total number of pointers: 0

XXX times a non-volatile is read: 724
XXX times a non-volatile is write: 242
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 182
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 27
   depth: 2, occurrence: 18
   depth: 3, occurrence: 33
   depth: 4, occurrence: 38
   depth: 5, occurrence: 30

XXX percentage a fresh-made variable is used: 19.4
XXX percentage an existing variable is used: 80.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

