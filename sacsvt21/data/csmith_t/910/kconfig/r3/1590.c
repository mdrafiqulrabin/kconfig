/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3370443856
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const union U0  func_31(void);
inline static int16_t  func_38(int64_t  p_39, uint16_t  p_40, float  p_41);
inline static float  func_47(uint32_t  p_48);
inline static int32_t ** func_53(int32_t * p_54, union U0  p_55, int16_t  p_56, float  p_57, int32_t  p_58);
static int32_t * func_59(const uint64_t  p_60, union U0  p_61, uint16_t  p_62);
static uint16_t  func_66(int32_t ** p_67);
inline static uint16_t  func_82(int32_t * p_83, int32_t  p_84, int16_t  p_85, uint32_t  p_86, int64_t  p_87);
static int32_t * func_88(int32_t * const * p_89);
inline static int32_t * const * func_90(int32_t * p_91, uint16_t  p_92, float  p_93, uint32_t  p_94);
static const int64_t  func_95(int32_t * p_96, int32_t * const  p_97);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const union U0  func_31(void)
{ /* block id: 36 */
    int32_t l_36 = 0xB58331C5L;
    uint8_t l_42 = 0x09L;
    int32_t l_245 = 8L;
    int32_t *l_244 = &l_245;
    const union U0 l_246 = {0xDD47E45AL};
    (*l_244) = ((int32_t)((uint16_t)l_36 / (uint16_t)(~((((func_38(l_42, l_42, ((((float)((float)0xB.8C84B7p+85 - (float)l_42) + (float)0x5.44F4CCp+29) < 0x1.Fp+1) > func_47(l_36))) <= l_42) || l_42) & 0xE0AD08EFL) && 0xF4D14C442B78B995LL))) / (int32_t)l_42);
    return l_246;
    /* statement id: 128 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_38(int64_t  p_39, uint16_t  p_40, float  p_41)
{ /* block id: 40 */
    int32_t l_65 = 0x1F6ED734L;
    int32_t *l_64 = &l_65;
    int32_t l_176 = (-2L);
    union U0 ***l_233 = (void*)0;
    for (p_39 = 0; (p_39 < 25); p_39 += 2)
    { /* block id: 43 */
        union U0 l_63 = {0xE8E548E0L};
        int32_t **l_68 = &l_64;
        const int32_t ***l_174 = (void*)0;
        int32_t ***l_175 = &l_68;
        int32_t *l_185 = (void*)0;
        const int32_t l_204 = 9L;
        const union U0 **l_228 = (void*)0;
        union U0 l_240 = {18446744073709551610UL};
        (*l_175) = func_53(func_59(p_40, l_63, (((l_63.f0 < (l_64 != (void*)0)) && (*l_64)) < func_66(l_68))), l_63, p_40, (*l_64), p_39);
        /* statement id: 87 */
        assert (l_68 == 0);
        if ((p_39 < (p_39 >= p_40)))
        { /* block id: 88 */
            int32_t l_184 = (-5L);
            union U0 *l_187 = &l_63;
            union U0 **l_186 = &l_187;
            if (l_176)
            { /* block id: 89 */
                int64_t l_179 = 0xB4DDF18D0889286ALL;
                int32_t *l_189 = &l_65;
                float l_193 = 0x0.Ep-1;
                float *l_192 = &l_193;
                if ((((p_39 <= ((0xCB70C1D3L >= __builtin_parityll(p_39)) | ((int16_t)(l_179 != (((uint32_t)((uint64_t)l_184 + (uint64_t)func_82(l_185, (l_184 ^ (p_39 ^ l_184)), p_40, p_39, p_39)) + (uint32_t)0x858CEDA5L) || l_179)) + (int16_t)p_39))) | 1L) > 0x35B14A6EL))
                { /* block id: 90 */
                    union U0 ***l_188 = &l_186;
                    (*l_188) = l_186;
                    (*l_189) = ((void*)0 == l_189);
                }
                else
                { /* block id: 93 */
                    l_189 = func_88(func_90(&l_184, (*l_189), func_66(&l_189), __builtin_ctzll(func_95(l_189, &l_65))));
                    /* statement id: 94 */
                    assert (l_189 == 0);
                }
                /* facts after branching */
                assert (l_189 == 0 || l_189 == &l_65);
                (*l_192) = ((float)(l_184 != (-0x4.2p-1)) + (float)(*l_64));
                (*l_64) = 0x44EC9471L;
            }
            else
            { /* block id: 98 */
                int16_t l_199 = 0x4C1BL;
                float l_201 = 0x5.Fp-1;
                float *l_200 = &l_201;
                for (l_65 = (-11); (l_65 > 16); l_65++)
                { /* block id: 101 */
                    for (l_63.f0 = 0; (l_63.f0 > 3); l_63.f0 += 2)
                    { /* block id: 104 */
                        int32_t **l_198 = &l_64;
                        (*l_198) = &l_65;
                        return p_39;
                    }
                }
                (*l_200) = __builtin_ctz(l_199);
            }
        }
        else
        { /* block id: 111 */
            int32_t * const *l_202 = &l_64;
            int32_t *l_203 = &l_65;
            l_203 = func_88(l_202);
            /* statement id: 112 */
            assert (l_203 == 0);
        }
        if ((p_39 & ((0x5EAAFD92L | l_204) & ((p_40 <= (p_40 < 1UL)) <= (((int32_t)(((*l_64) || ((uint16_t)((int64_t)(*l_64) / (int64_t)((uint16_t)__builtin_clzl((&l_63 == &l_63)) - (uint16_t)0UL)) + (uint16_t)p_40)) != p_39) + (int32_t)0L) | p_39)))))
        { /* block id: 114 */
            uint32_t l_216 = 7UL;
            int32_t *l_227 = &l_65;
            union U0 *l_243 = &l_240;
            for (l_176 = 0; (l_176 < (-7)); l_176 -= 6)
            { /* block id: 117 */
                int32_t l_215 = 0L;
                int32_t *l_226 = (void*)0;
                l_216 = l_215;
                (*l_64) = ((!p_39) > ((int64_t)l_215 / (int64_t)((int64_t)((((uint16_t)(l_226 == l_227) >> (uint16_t)4) <= (l_228 == l_228)) || ((((int16_t)((uint64_t)((void*)0 == l_233) / (uint64_t)((uint16_t)((uint16_t)((-9L) != 0x6C3776CDE9C46E93LL) >> (uint16_t)4) << (uint16_t)5)) >> (int16_t)1) == 0xA056DCA7L) == (*l_64))) / (int64_t)p_40)));
            }
            (*l_64) = ((p_39 | ((*l_64) == (*l_227))) >= p_39);
        }
        else
        { /* block id: 122 */
            return p_40;
        }
    }
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_47(uint32_t  p_48)
{ /* block id: 37 */
    int32_t l_50 = 0x4E55B65AL;
    int32_t *l_49 = &l_50;
    (*l_49) = 0x718B9628L;
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_53(int32_t * p_54, union U0  p_55, int16_t  p_56, float  p_57, int32_t  p_58)
{ /* block id: 77 */
    int32_t l_166 = 0x4E952D19L;
    int32_t *l_165 = &l_166;
    int32_t * const *l_164 = &l_165;
    float l_168 = 0x3.9AC067p-3;
    float *l_167 = &l_168;
    uint8_t l_169 = 253UL;
    int32_t *l_170 = &l_166;
    const int32_t *l_172 = &l_166;
    const int32_t **l_171 = &l_172;
    int32_t **l_173 = (void*)0;
    for (p_55.f0 = 0; (p_55.f0 <= 31); p_55.f0++)
    { /* block id: 80 */
        int32_t l_154 = 0x661A1834L;
        int32_t *l_153 = &l_154;
        int32_t **l_152 = &l_153;
        int32_t **l_155 = &l_153;
        int32_t **l_156 = (void*)0;
        return l_156;
        /* statement id: 81 */
        //assert (func_53_rv == 0);
    }
    (*l_167) = (p_57 == (-(float)(((float)(p_58 == ((float)(-0x1.0p+1) + (float)((float)0xA.2A06A2p+65 + (float)func_82(func_88(l_164), (*l_165), p_56, (*l_165), (**l_164))))) - (float)p_55.f0) >= (**l_164))));
    (*l_167) = l_169;
    (*l_171) = l_170;
    return l_173;
    /* statement id: 86 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_59(const uint64_t  p_60, union U0  p_61, uint16_t  p_62)
{ /* block id: 47 */
    int32_t l_75 = 0L;
    int32_t *l_77 = &l_75;
    int32_t **l_76 = &l_77;
    int32_t *l_142 = &l_75;
    int32_t *l_143 = &l_75;
    int32_t *l_144 = &l_75;
    int32_t *l_145 = &l_75;
    int32_t *l_146 = &l_75;
    int32_t *l_147 = &l_75;
    int32_t *l_148 = &l_75;
    int32_t *l_149 = (void*)0;
    for (p_62 = (-2); (p_62 > 29); p_62 += 4)
    { /* block id: 50 */
        if (p_61.f0)
            break;
        if (p_61.f0)
            continue;
    }
    (*l_77) = (p_61.f0 < ((__builtin_clzl(l_75) > ((void*)0 != l_76)) & ((-10L) == ((int32_t)0x5DFEA44EL / (int32_t)p_62))));
    (**l_76) = (((uint16_t)func_82(func_88(func_90((*l_76), (*l_77), p_61.f0, (*l_77))), ((uint16_t)__builtin_ffsll(p_60) << (uint16_t)p_60), p_60, p_61.f0, p_62) / (uint16_t)p_62) && 65531UL);
    return l_149;
    /* statement id: 76 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_66(int32_t ** p_67)
{ /* block id: 44 */
    int32_t l_69 = 0x9CD890F6L;
    int32_t l_71 = 0L;
    int32_t *l_70 = &l_71;
    int32_t l_72 = 0L;
    (*l_70) = l_69;
    return l_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_82(int32_t * p_83, int32_t  p_84, int16_t  p_85, uint32_t  p_86, int64_t  p_87)
{ /* block id: 73 */
    return p_86;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_88(int32_t * const * p_89)
{ /* block id: 63 */
    int32_t l_123 = 0x431463D9L;
    int32_t l_128 = 0x1A556116L;
    int32_t *l_134 = &l_123;
    int32_t *l_135 = &l_128;
    int32_t *l_136 = &l_128;
    int32_t *l_137 = &l_123;
    int32_t *l_138 = &l_123;
    int32_t *l_139 = (void*)0;
    for (l_123 = 0; (l_123 > 17); l_123 += 7)
    { /* block id: 66 */
        uint32_t l_126 = 9UL;
        float *l_127 = (void*)0;
        float l_130 = 0xD.3748AAp+40;
        float *l_129 = &l_130;
        union U0 l_132 = {0x8C059577L};
        union U0 *l_131 = &l_132;
        union U0 **l_133 = &l_131;
        l_128 = l_126;
        (*l_129) = l_126;
        (*l_133) = l_131;
        if (l_123)
            break;
    }
    return l_139;
    /* statement id: 72 */
    //assert (func_88_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const * func_90(int32_t * p_91, uint16_t  p_92, float  p_93, uint32_t  p_94)
{ /* block id: 55 */
    int32_t l_99 = 0x71356723L;
    int32_t *l_98 = &l_99;
    int32_t * const l_100 = (void*)0;
    uint64_t l_104 = 7UL;
    int16_t l_113 = 8L;
    int32_t * const *l_115 = &l_98;
    int32_t * const *l_116 = &l_98;
    int32_t * const *l_117 = &l_98;
    int32_t * const *l_118 = &l_98;
    int32_t * const *l_119 = &l_100;
    int32_t * const *l_120 = &l_98;
    int32_t * const *l_121 = &l_100;
    int32_t * const *l_122 = (void*)0;
lbl_114:
    (*l_98) = (func_95(l_98, l_100) & (p_92 < l_104));
    (*p_91) = (((int16_t)p_94 / (int16_t)((&l_99 != (void*)0) & 0x07A12536L)) != ((((int32_t)((p_92 | 0xB4BC07302220C99DLL) >= ((((int16_t)((int16_t)(l_113 ^ 1L) << (int16_t)14) << (int16_t)11) && (*l_98)) <= p_94)) + (int32_t)4294967290UL) && p_94) && p_92));
    if (l_99)
        goto lbl_114;
    return l_122;
    /* statement id: 62 */
    //assert (func_90_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int64_t  func_95(int32_t * p_96, int32_t * const  p_97)
{ /* block id: 56 */
    int32_t l_103 = 0L;
    int32_t *l_102 = &l_103;
    int32_t **l_101 = &l_102;
    (*l_101) = p_96;
    /* statement id: 57 */
    //assert (l_102 == &l_99 || l_102 == &l_65);
    return (*l_102);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 75
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 19
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1

XXX total number of pointers: 71

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 19
breakdown:
   depth: 1, occurrence: 17
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 22
breakdown:
   depth: 1, occurrence: 21
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 5
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 308

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 57
   level: 2, occurrence: 9
   level: 3, occurrence: 7
XXX number of pointers point to pointers: 27
XXX number of pointers point to scalars: 41
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.6
XXX average alias set size: 1.11

XXX times a non-volatile is read: 195
XXX times a non-volatile is write: 56
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 54
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 10
   depth: 2, occurrence: 5
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 11.7
XXX percentage an existing variable is used: 88.3
********************* end of statistics **********************/

