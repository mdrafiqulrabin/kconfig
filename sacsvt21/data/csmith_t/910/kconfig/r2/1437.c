/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      3670497896
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 2;
   const unsigned f1 : 15;
   signed f2 : 21;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_8[5] = {(-1),(-1),(-1),(-1),(-1)};
static int32_t *g_7 = &g_8[3];
static int32_t g_62 = 0x67A065BB;
static const struct S0 *g_76 = (void*)0;
static const int32_t *g_106 = (void*)0;
static struct S0 g_114 = {0,5,694};
static struct S0 *g_136 = &g_114;
static struct S0 **g_135 = &g_136;
static struct S0 ***g_134 = &g_135;
static const int32_t **g_218 = &g_106;
static const int32_t ** const *g_246[5] = {&g_218,&g_218,&g_218,&g_218,&g_218};
static const int32_t ** const **g_245 = &g_246[1];


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
inline static int8_t  func_5(uint32_t  p_6);
static const uint32_t  func_14(int32_t  p_15);
inline static int32_t * func_19(uint32_t  p_20, const int32_t * p_21, uint8_t  p_22, uint8_t  p_23, int32_t  p_24);
static const int32_t * func_25(uint32_t  p_26, int16_t  p_27, uint8_t  p_28, int8_t  p_29);
inline static uint8_t  func_33(uint16_t  p_34, uint16_t  p_35, int32_t * p_36, uint16_t  p_37);
inline static int32_t * func_42(uint16_t  p_43, struct S0  p_44, const int32_t ** const  p_45, uint32_t  p_46, int32_t ** p_47);
inline static struct S0  func_48(int32_t * p_49);
inline static int32_t ** func_56(int32_t * p_57);
inline static int32_t * func_65(uint8_t  p_66, int32_t  p_67);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_7 g_245 g_135 g_136 g_62 g_8 g_114.f1 g_114.f2
 * writes: g_7 g_246 g_136 g_62 g_8
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_4 = 0x56A9;
    if ((safe_sub_func_uint8_t_u_u(l_4, func_5((l_4 & 0)))))
    { /* block id: 3 */
        int32_t **l_9 = &g_7;
        (*l_9) = g_7;
        for (l_4 = (-8); (l_4 >= 33); l_4 = safe_add_func_int32_t_s_s(l_4, 1))
        { /* block id: 7 */
            int32_t ** const l_18 = &g_7;
            int32_t *l_292 = &g_62;
        }
        (*g_245) = (void*)0;
    }
    else
    { /* block id: 114 */
        uint32_t l_293 = 2U;
        return l_293;
    }
    for (l_4 = 0; (l_4 <= 15); l_4 = safe_add_func_int32_t_s_s(l_4, 1))
    { /* block id: 119 */
        (*g_135) = (*g_135);
    }
    for (l_4 = 1; (l_4 <= 4); l_4 += 1)
    { /* block id: 124 */
        uint32_t l_298 = 0U;
        for (g_62 = 0; (g_62 <= 4); g_62 += 1)
        { /* block id: 127 */
            int i;
            if (g_8[l_4])
                break;
            g_8[g_62] = (safe_rshift_func_uint16_t_u_u((4U != l_298), (((+(safe_sub_func_int16_t_s_s((safe_sub_func_int8_t_s_s((safe_rshift_func_uint16_t_u_s(0x9B9E, 7)), (1 & (g_8[4] != (g_8[l_4] != (safe_add_func_int16_t_s_s(((-8) ^ (((safe_rshift_func_uint8_t_u_u((l_4 ^ ((safe_mod_func_int32_t_s_s((safe_sub_func_uint8_t_u_u((((1U && (-4)) == 0xAB1B) != l_298), 1U)), g_114.f1)) & 65532U)), g_62)) <= g_114.f1) & 1U)), g_114.f1))))))), l_298))) != g_114.f2) != 0x70)));
        }
    }
    return l_4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_5(uint32_t  p_6)
{ /* block id: 1 */
    return p_6;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_7 g_62 g_76 g_114.f1 g_134 g_114.f0 g_114.f2 g_135 g_136 g_245
 * writes: g_62 g_76 g_106 g_134 g_7 g_114.f2 g_218
 */
static const uint32_t  func_14(int32_t  p_15)
{ /* block id: 8 */
    uint32_t l_32 = 0x881DDA8D;
    int8_t l_38 = 0x21;
    int32_t **l_286 = &g_7;
    int32_t *l_287 = (void*)0;
    (*l_286) = func_19(g_8[0], func_25((safe_add_func_uint8_t_u_u(l_32, func_33(l_32, l_32, &g_8[1], l_38))), g_8[3], l_38, l_32), l_38, p_15, l_32);
    /* statement id: 107 */
    assert (g_106 == 0 || (g_106 >= &g_8[0] && g_106 <= &g_8[4]) || g_106 == &g_62);
    //assert (g_218 == dangling || g_218 == &g_106);
    (*l_286) = l_287;
    /* statement id: 108 */
    assert (g_7 == 0);
    return g_8[3];
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_114.f2 g_245 g_62 g_76
 * writes: g_62 g_76
 */
inline static int32_t * func_19(uint32_t  p_20, const int32_t * p_21, uint8_t  p_22, uint8_t  p_23, int32_t  p_24)
{ /* block id: 85 */
    int32_t l_229[5][3];
    int32_t *l_240 = &g_62;
    int32_t * const *l_249 = &l_240;
    int32_t * const **l_248 = &l_249;
    int32_t * const ***l_247 = &l_248;
    struct S0 l_270 = {0,137,353};
    const int32_t ** const l_271 = &g_106;
    int i, j;
    for (i = 0; i < 5; i = i + 1)
    {
        for (j = 0; j < 3; j = j + 1)
            l_229[i][j] = (-1);
    }
    (*l_240) = (((safe_add_func_int16_t_s_s((safe_mod_func_int32_t_s_s((g_8[3] & (safe_add_func_int16_t_s_s(0, (safe_rshift_func_uint16_t_u_s((l_229[1][1] >= ((safe_lshift_func_int16_t_s_u(g_114.f2, 7)) && (safe_rshift_func_uint8_t_u_u(((safe_lshift_func_int8_t_s_u(((p_24 == p_23) & (((safe_lshift_func_uint8_t_u_s(0x32, p_22)) | (safe_rshift_func_int8_t_s_s((0x6C && 0x92), g_114.f2))) > g_8[3])), p_20)) && (-7)), l_229[1][1])))), 13))))), l_229[1][1])), p_22)) >= 8U) < g_114.f2);
    if ((255U != (!(((~((safe_sub_func_int8_t_s_s(((g_245 == l_247) && (safe_rshift_func_int16_t_s_s((((0x13F4F6D3 < (g_62 ^ (p_20 >= (safe_sub_func_int8_t_s_s((safe_rshift_func_int8_t_s_s((safe_lshift_func_uint16_t_u_s(0xE899, (g_8[3] >= (!p_24)))), 2)), 1))))) ^ p_20) == 65531U), 12))), p_23)) > (*l_240))) > p_24) && g_62))))
    { /* block id: 87 */
        int32_t **l_261 = &l_240;
        int32_t ** const **l_262 = (void*)0;
        struct S0 ** const *l_267 = &g_135;
        (*l_261) = (*l_249);
        (*l_261) = &p_24;
        /* statement id: 89 */
        assert (l_240 == &p_24);
        p_21 = &p_24;
        /* statement id: 90 */
        assert (p_21 == &p_24);
    }
    else
    { /* block id: 91 */
        int32_t l_285 = 0xF372E633;
        p_21 = func_65((safe_lshift_func_int8_t_s_u((g_8[3] && (-10)), 5)), (&p_21 == (void*)0));
        /* statement id: 92 */
        assert (p_21 == &g_62);
        for (p_24 = 29; (p_24 == 11); p_24--)
        { /* block id: 95 */
            (***l_248) = (((safe_mul_func_uint16_t_u_u(g_8[0], (1 > p_23))) <= g_62) || 1);
            (*l_240) = ((*l_248) != (void*)0);
        }
        for (p_20 = (-1); (p_20 <= 11); ++p_20)
        { /* block id: 101 */
            uint32_t l_282 = 4294967295U;
            l_285 = ((safe_sub_func_uint8_t_u_u((0x61 ^ l_282), (p_20 && (safe_rshift_func_uint8_t_u_u((1U && ((0x232ECD07 || (p_20 && p_22)) | (((((g_8[4] | ((((***l_248) || 0xAF) & 0x93D0) != 0x45E1)) ^ g_114.f2) && 0x6D5B) | l_282) == 65535U))), 1))))) <= 0x92BE);
            if (l_285)
                continue;
        }
    }
    /* facts after branching */
    assert (p_21 == &g_62 || p_21 == &p_24);
    assert (l_240 == &g_62 || l_240 == &p_24);
    return &g_8[3];
    /* statement id: 106 */
    //assert ((func_19_rv >= &g_8[0] && func_19_rv <= &g_8[4]));
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_7 g_62 g_76 g_114.f1 g_134 g_114.f0 g_114.f2 g_135 g_136
 * writes: g_62 g_76 g_106 g_134 g_7 g_114.f2 g_218
 */
static const int32_t * func_25(uint32_t  p_26, int16_t  p_27, uint8_t  p_28, int8_t  p_29)
{ /* block id: 11 */
    int32_t *l_50 = &g_8[3];
    int32_t *l_219 = &g_62;
    const int32_t *l_220[1][10] = {{&g_8[3],&g_8[3],&g_8[3],&g_8[3],&g_8[3],&g_8[3],&g_8[3],&g_8[3],&g_8[3],&g_8[3]}};
    int i, j;
    for (p_28 = 0; (p_28 != 27); ++p_28)
    { /* block id: 14 */
        const int32_t *l_55 = &g_8[3];
        const int32_t ** const l_54 = &l_55;
        (*l_54) = func_42(g_8[3], func_48(l_50), l_54, p_29, func_56(l_50));
        /* statement id: 70 */
        assert (l_55 == &g_62 || (l_55 >= &g_8[0] && l_55 <= &g_8[4]));
        for (p_26 = (-25); (p_26 <= 4); p_26 = safe_add_func_uint32_t_u_u(p_26, 8))
        { /* block id: 73 */
            if (p_27)
            { /* block id: 74 */
                int8_t l_216 = (-4);
                if (l_216)
                    break;
                return l_50;
                /* statement id: 76 */
                //assert ((func_25_rv >= &g_8[0] && func_25_rv <= &g_8[4]));
            }
            else
            { /* block id: 77 */
                const int32_t *l_217[8][4] = {{&g_8[3],&g_62,&g_62,&g_8[3]},{&g_8[3],&g_62,&g_62,&g_8[3]},{&g_8[3],&g_62,&g_62,&g_8[3]},{&g_8[3],&g_62,&g_62,&g_8[3]},{&g_8[3],&g_62,&g_62,&g_8[3]},{&g_8[3],&g_62,&g_62,&g_8[3]},{&g_8[3],&g_62,&g_62,&g_8[3]},{&g_8[3],&g_62,&g_62,&g_8[3]}};
                int i, j;
                return l_217[3][0];
                /* statement id: 78 */
                //assert ((func_25_rv >= &g_8[0] && func_25_rv <= &g_8[4]) || func_25_rv == 0 || func_25_rv == &g_62);
            }
        }
        g_218 = &l_55;
        /* statement id: 81 */
        assert (g_218 == &l_55);
    }
    /* facts after for loop */
    assert (g_7 == &g_62 || (g_7 >= &g_8[0] && g_7 <= &g_8[4]));
    assert (g_106 == 0 || (g_106 >= &g_8[0] && g_106 <= &g_8[4]) || g_106 == &g_62);
    //assert (g_218 == dangling || g_218 == &g_106);
    (*l_219) = (*l_50);
    return l_220[0][4];
    /* statement id: 84 */
    //assert (func_25_rv == &g_62 || func_25_rv == 0 || (func_25_rv >= &g_8[0] && func_25_rv <= &g_8[4]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_33(uint16_t  p_34, uint16_t  p_35, int32_t * p_36, uint16_t  p_37)
{ /* block id: 9 */
    uint32_t l_39 = 0xCFF29C21;
    return l_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_7 g_62 g_76 g_114.f1 g_134 g_114.f0 g_114.f2 g_135 g_136
 * writes: g_76 g_62 g_106 g_134 g_7 g_114.f2
 */
inline static int32_t * func_42(uint16_t  p_43, struct S0  p_44, const int32_t ** const  p_45, uint32_t  p_46, int32_t ** p_47)
{ /* block id: 21 */
    int32_t l_63 = 2;
    int32_t *l_74[5];
    int8_t l_107 = 0xAA;
    const uint16_t l_121 = 0x9823;
    int16_t l_160 = 4;
    struct S0 **l_165 = (void*)0;
    uint16_t l_172 = 65526U;
    int32_t **l_210 = &l_74[4];
    int32_t ***l_209[2][2][9] = {{{&l_210,&l_210,(void*)0,(void*)0,(void*)0,(void*)0,&l_210,&l_210,&l_210},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}},{{(void*)0,&l_210,&l_210,(void*)0,&l_210,(void*)0,&l_210,(void*)0,&l_210},{&l_210,&l_210,(void*)0,(void*)0,&l_210,(void*)0,(void*)0,&l_210,&l_210}}};
    int8_t l_212 = 0;
    int i, j, k;
    for (i = 0; i < 5; i = i + 1)
        l_74[i] = &g_62;
    if (((void*)0 == (*p_45)))
    { /* block id: 22 */
        int8_t l_64 = 0xEF;
        int32_t *l_68[2];
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_68[i] = (void*)0;
        if ((g_8[3] > l_63))
        { /* block id: 23 */
            int32_t l_75[3];
            int i;
            for (i = 0; i < 3; i = i + 1)
                l_75[i] = 0x7078C3FC;
            l_64 = (**p_47);
            if (l_63)
                goto lbl_99;
            (*p_45) = func_65(((void*)0 != l_68[0]), (0x27F1 & (safe_sub_func_int8_t_s_s((g_62 && (p_47 != &g_7)), (~(safe_lshift_func_int16_t_s_u((((p_46 <= ((void*)0 == l_74[3])) | l_75[0]) ^ p_43), p_44.f2)))))));
            /* statement id: 28 */
            //assert (l_55 == &g_62);
lbl_99:
            g_62 = (((safe_rshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s((safe_sub_func_int16_t_s_s((p_43 >= (0xC8A6 ^ 65526U)), p_43)), ((((0U > (safe_sub_func_uint32_t_u_u(((safe_sub_func_uint8_t_u_u((safe_lshift_func_int16_t_s_s(1, l_75[0])), p_43)) ^ (!((~(safe_lshift_func_int16_t_s_u((safe_lshift_func_int8_t_s_s(((safe_mod_func_uint16_t_u_u(l_75[0], g_8[3])) || g_8[1]), 4)), 2))) && 0xA7))), (**p_45)))) || p_44.f1) >= p_44.f0) || 0U))), p_43)) & g_8[1]) >= g_8[3]);
            (*p_45) = (*p_45);
        }
        else
        { /* block id: 32 */
            uint8_t l_104 = 1U;
            int32_t l_105 = 0x3046699C;
            (*p_45) = l_68[1];
            /* statement id: 33 */
            //assert (l_55 == 0);
            l_105 = (safe_unary_minus_func_int16_t_s((safe_add_func_uint8_t_u_u(g_62, (~l_104)))));
        }
        /* facts after branching */
        //assert (l_55 == 0 || (l_55 >= &g_8[0] && l_55 <= &g_8[4]) || l_55 == &g_62);
        g_106 = (*p_45);
    }
    else
    { /* block id: 37 */
        int32_t l_108 = 1;
        uint8_t l_164 = 0x98;
        int32_t ****l_213 = &l_209[0][0][1];
        l_108 = l_107;
        for (l_108 = 0; (l_108 == 20); ++l_108)
        { /* block id: 41 */
            int32_t **l_132 = &g_7;
            int16_t l_133 = 0xAE27;
            int32_t **l_166 = &l_74[1];
            for (l_63 = 0; (l_63 > (-22)); l_63--)
            { /* block id: 44 */
                struct S0 *l_113 = &g_114;
                struct S0 **l_115 = &l_113;
                int32_t l_161[7][1] = {{(-1)},{(-1)},{(-1)},{(-1)},{(-1)},{(-1)},{(-1)}};
                int i, j;
                (*l_115) = l_113;
                if (((safe_add_func_uint32_t_u_u((((**p_45) | 0x55DFC961) > (!(safe_lshift_func_int16_t_s_s(g_8[1], g_114.f1)))), l_121)) & ((safe_lshift_func_int8_t_s_s((safe_sub_func_int16_t_s_s((0x5C != (safe_lshift_func_int8_t_s_s(0x03, 0))), ((safe_rshift_func_int16_t_s_u((l_108 || (safe_add_func_int32_t_s_s((&g_7 == l_132), 1))), 1)) > p_44.f1))), l_133)) ^ (*g_7))))
                { /* block id: 46 */
                    g_134 = g_134;
                    l_161[6][0] = (safe_mod_func_uint8_t_u_u(((safe_mod_func_int8_t_s_s((safe_lshift_func_uint16_t_u_s(9U, 9)), ((safe_add_func_int16_t_s_s((safe_unary_minus_func_uint16_t_u(((safe_sub_func_uint16_t_u_u(p_46, p_46)) == 1))), g_62)) && (safe_lshift_func_uint16_t_u_s(((safe_rshift_func_uint16_t_u_u((((safe_lshift_func_uint16_t_u_u((safe_add_func_int32_t_s_s((safe_mod_func_int32_t_s_s((((safe_lshift_func_int16_t_s_s(g_8[4], 9)) != ((**p_45) & (*g_7))) >= (1U == 0x87)), (**l_132))), 4294967291U)), 14)) > l_160) ^ l_161[6][0]), (**l_132))) | 7), l_108))))) == g_114.f1), 1U));
                }
                else
                { /* block id: 49 */
                    (*p_45) = &l_161[6][0];
                    /* statement id: 50 */
                    //assert ((l_55 >= &l_161[0][0] && l_55 <= &l_161[6][0]));
                    l_164 = (safe_add_func_int16_t_s_s(1, 0x226F));
                    (**l_166) = (((0U >= (((l_165 == l_165) > p_44.f1) <= ((l_166 != &g_7) & 0x33))) & ((g_114.f0 && g_114.f1) > 0x114FAD7D)) == p_43);
                    return (*l_132);
                    /* statement id: 53 */
                    //assert (l_55 == dangling);
                    //assert (func_42_rv == &g_62 || (func_42_rv >= &g_8[0] && func_42_rv <= &g_8[4]));
                }
            }
            if ((**p_47))
                break;
            g_7 = &g_62;
            /* statement id: 57 */
            assert (g_7 == &g_62);
        }
        if (((safe_sub_func_int32_t_s_s((*g_7), (safe_add_func_int32_t_s_s((((g_114.f2 < (g_8[3] && (+(((l_172 && (((void*)0 == &g_106) && ((safe_mod_func_int8_t_s_s(((safe_add_func_int16_t_s_s(((!(+l_108)) == l_164), (safe_rshift_func_int8_t_s_u(p_44.f1, g_8[3])))) && 4294967295U), l_108)) != p_44.f2))) > g_114.f2) == p_44.f0)))) != l_108) == g_114.f0), l_108)))) && g_114.f2))
        { /* block id: 59 */
            (*p_47) = func_65(p_46, p_44.f2);
            /* statement id: 60 */
            assert (g_7 == &g_62);
        }
        else
        { /* block id: 61 */
            const int32_t ***l_181 = (void*)0;
            const int32_t **l_183[9][5] = {{&g_106,&g_106,&g_106,&g_106,&g_106},{&g_106,&g_106,&g_106,&g_106,&g_106},{&g_106,&g_106,&g_106,&g_106,&g_106},{&g_106,&g_106,&g_106,&g_106,&g_106},{&g_106,&g_106,&g_106,&g_106,&g_106},{&g_106,&g_106,&g_106,&g_106,&g_106},{&g_106,&g_106,&g_106,&g_106,&g_106},{&g_106,&g_106,&g_106,&g_106,&g_106},{&g_106,&g_106,&g_106,&g_106,&g_106}};
            const int32_t ***l_182 = &l_183[4][2];
            int8_t l_211 = 0;
            int i, j;
            (*l_182) = p_45;
            /* statement id: 62 */
            //assert (l_183[0][0] == &l_55 || l_183[0][0] == &g_106);
            g_114.f2 = (((((g_114.f1 >= (((safe_lshift_func_int16_t_s_u(((safe_mod_func_int32_t_s_s((0x519CD979 && (((safe_rshift_func_int8_t_s_s((safe_sub_func_uint32_t_u_u((65526U > (safe_mod_func_uint32_t_u_u((((safe_sub_func_uint8_t_u_u(((safe_rshift_func_int16_t_s_s((g_62 >= ((((((~(safe_mod_func_int16_t_s_s(((((**g_134) != (void*)0) & ((safe_add_func_int32_t_s_s(((safe_mod_func_uint16_t_u_u(((((safe_add_func_uint16_t_u_u((safe_rshift_func_int8_t_s_u(p_44.f0, (l_209[0][0][1] != (void*)0))), 0)) & (**p_45)) ^ p_46) != 0xBD), g_114.f2)) != g_62), 1)) | 0x36B7)) == l_164), g_8[3]))) == g_8[3]) && 0x3999) != l_211) >= g_114.f0) & l_108)), g_8[3])) < p_44.f1), p_44.f1)) || g_8[3]) || p_43), 4U))), g_114.f0)), 5)) == p_44.f0) ^ (**p_47))), (-1))) < p_44.f1), l_212)) <= (*g_7)) > p_44.f0)) <= p_43) <= g_8[3]) == 6U) || (**p_45));
        }
        (*l_213) = &p_47;
        /* statement id: 65 */
        //assert (l_209[0][0][0] == &p_47 || l_209[0][0][0] == &l_210 || l_209[0][0][0] == 0);
    }
    /* facts after branching */
    //assert (l_55 == 0 || (l_55 >= &g_8[0] && l_55 <= &g_8[4]) || l_55 == &g_62);
    //assert (l_209[0][0][0] == &p_47 || l_209[0][0][0] == &l_210 || l_209[0][0][0] == 0);
    (**l_210) = (**p_47);
    (**l_210) = ((void*)0 != p_47);
    return &g_62;
    /* statement id: 69 */
    //assert (func_42_rv == &g_62);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_48(int32_t * p_49)
{ /* block id: 15 */
    int32_t *l_51 = &g_8[3];
    int32_t **l_52 = &l_51;
    struct S0 l_53 = {-1,81,-217};
    (*l_52) = l_51;
    return l_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_8
 * writes: g_62
 */
inline static int32_t ** func_56(int32_t * p_57)
{ /* block id: 18 */
    uint32_t l_58[4][7][9] = {{{0x600AC80E,0xB167519B,0xB167519B,0x600AC80E,0x41911659,0x1E3C1DC0,4294967288U,0x132DC1B2,0xB167519B},{4294967288U,0x41911659,0xF559CDE8,0x2039CE85,4294967295U,0x1E3C1DC0,0x18101BC6,0x41911659,0x41911659},{0xC77ACAEC,0x132DC1B2,0x41911659,0x2039CE85,0x41911659,0x132DC1B2,0xC77ACAEC,0xB167519B,0x132DC1B2},{0x2039CE85,0x132DC1B2,0xF559CDE8,0x600AC80E,0x1E3C1DC0,0x7D051992,0xC674F989,0x1E3C1DC0,0x132DC1B2},{0xC77ACAEC,0x41911659,0xB167519B,0xC674F989,0xF559CDE8,0xF559CDE8,0xC674F989,0xB167519B,0x41911659},{4294967288U,0xB167519B,0x7D051992,0x18101BC6,0xF559CDE8,0x7D051992,0xC77ACAEC,0x41911659,0xB167519B},{0x600AC80E,0x1E3C1DC0,0x7D051992,0xC674F989,0x1E3C1DC0,0x132DC1B2,0x18101BC6,0x132DC1B2,0x1E3C1DC0}},{{0x600AC80E,0xB167519B,0xB167519B,0x600AC80E,0x41911659,0x1E3C1DC0,4294967288U,0x132DC1B2,0xB167519B},{4294967288U,0x41911659,0xF559CDE8,0x2039CE85,4294967295U,0x1E3C1DC0,0x18101BC6,0x41911659,0x41911659},{0xC77ACAEC,0x132DC1B2,0x41911659,0x2039CE85,0x41911659,0x132DC1B2,0xC77ACAEC,0xB167519B,0x132DC1B2},{0x2039CE85,0x132DC1B2,0xF559CDE8,0x600AC80E,0x1E3C1DC0,0x7D051992,0xC674F989,4294967295U,1U},{0x1E3C1DC0,0xBF554C62,7U,0xF559CDE8,4294967294U,4294967294U,0xF559CDE8,7U,0xBF554C62},{4294967295U,7U,0x14FF6A91,0x41911659,4294967294U,0x14FF6A91,0x1E3C1DC0,0xBF554C62,7U},{0xB167519B,4294967295U,0x14FF6A91,0xF559CDE8,4294967295U,1U,0x41911659,1U,4294967295U}},{{0xB167519B,7U,7U,0xB167519B,0xBF554C62,4294967295U,4294967295U,1U,7U},{4294967295U,0xBF554C62,4294967294U,0x7D051992,0xB2A8F302,4294967295U,0x41911659,0xBF554C62,0xBF554C62},{0x1E3C1DC0,1U,0xBF554C62,0x7D051992,0xBF554C62,1U,0x1E3C1DC0,7U,1U},{0x7D051992,1U,4294967294U,0xB167519B,4294967295U,0x14FF6A91,0xF559CDE8,4294967295U,1U},{0x1E3C1DC0,0xBF554C62,7U,0xF559CDE8,4294967294U,4294967294U,0xF559CDE8,7U,0xBF554C62},{4294967295U,7U,0x14FF6A91,0x41911659,4294967294U,0x14FF6A91,0x1E3C1DC0,0xBF554C62,7U},{0xB167519B,4294967295U,0x14FF6A91,0xF559CDE8,4294967295U,1U,0x41911659,1U,4294967295U}},{{0xB167519B,7U,7U,0xB167519B,0xBF554C62,4294967295U,4294967295U,1U,7U},{4294967295U,0xBF554C62,4294967294U,0x7D051992,0xB2A8F302,4294967295U,0x41911659,0xBF554C62,0xBF554C62},{0x1E3C1DC0,1U,0xBF554C62,0x7D051992,0xBF554C62,1U,0x1E3C1DC0,7U,1U},{0x7D051992,1U,4294967294U,0xB167519B,4294967295U,0x14FF6A91,0xF559CDE8,4294967295U,1U},{0x1E3C1DC0,0xBF554C62,7U,0xF559CDE8,4294967294U,4294967294U,0xF559CDE8,7U,0xBF554C62},{4294967295U,7U,0x14FF6A91,0x41911659,4294967294U,0x14FF6A91,0x1E3C1DC0,0xBF554C62,7U},{0xB167519B,4294967295U,0x14FF6A91,0xF559CDE8,4294967295U,1U,0x41911659,1U,4294967295U}}};
    int32_t *l_59 = (void*)0;
    int32_t *l_60 = (void*)0;
    int32_t *l_61 = &g_62;
    int i, j, k;
    (*l_61) = (g_8[0] >= l_58[0][3][0]);
    return &g_7;
    /* statement id: 20 */
    //assert (func_56_rv == &g_7);
}


/* ------------------------------------------ */
/* 
 * reads : g_76
 * writes: g_76
 */
inline static int32_t * func_65(uint8_t  p_66, int32_t  p_67)
{ /* block id: 25 */
    const struct S0 **l_77 = &g_76;
    int32_t *l_78 = &g_62;
    (*l_77) = g_76;
    return l_78;
    /* statement id: 27 */
    //assert (func_65_rv == &g_62);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    for (i = 0; i < 5; i = i + 1)
    {
        transparent_crc(g_8[i], "g_8[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_62, "g_62", print_hash_value);
    transparent_crc(g_114.f0, "g_114.f0", print_hash_value);
    transparent_crc(g_114.f1, "g_114.f1", print_hash_value);
    transparent_crc(g_114.f2, "g_114.f2", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 51
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 7
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 1
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 2
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 2
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 36

XXX max expression depth: 43
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 17
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 43, occurrence: 1

XXX total number of pointers: 57

XXX times a variable address is taken: 70
XXX times a pointer is dereferenced on RHS: 27
breakdown:
   depth: 1, occurrence: 14
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 27
breakdown:
   depth: 1, occurrence: 23
   depth: 2, occurrence: 3
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 186

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 81
   level: 2, occurrence: 49
   level: 3, occurrence: 5
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 31
XXX number of pointers point to scalars: 23
XXX number of pointers point to structs: 3
XXX percent of pointers has null in alias set: 28.1
XXX average alias set size: 1.4

XXX times a non-volatile is read: 274
XXX times a non-volatile is write: 84
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 77
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 21
   depth: 2, occurrence: 20
   depth: 3, occurrence: 5
   depth: 4, occurrence: 6

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

