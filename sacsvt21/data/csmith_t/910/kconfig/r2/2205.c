/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3701116792
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   int8_t  f1;
   int32_t  f2;
   int8_t  f3;
   int32_t  f4;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 7;
   signed f1 : 9;
   signed f2 : 26;
   int16_t  f3;
   signed f4 : 21;
   uint32_t  f5;
   unsigned f6 : 4;
   signed f7 : 10;
   uint32_t  f8;
};
#pragma pack(pop)

union U2 {
   struct S0  f0;
   uint16_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_32(void);
static int32_t  func_38(int32_t  p_39, int16_t  p_40);
static uint32_t  func_53(int32_t  p_54, struct S0  p_55, uint32_t  p_56, uint32_t  p_57);
static struct S0  func_58(union U2  p_59, int16_t  p_60, int16_t  p_61);
static union U2  func_62(uint32_t  p_63, int8_t  p_64, int16_t  p_65, struct S0  p_66, int32_t  p_67);
static int32_t  func_74(int16_t  p_75, uint32_t  p_76, int32_t  p_77);
static uint16_t  func_81(int8_t  p_82, uint32_t  p_83, struct S1  p_84, struct S1  p_85);
inline static uint16_t  func_88(uint16_t  p_89, uint32_t  p_90, struct S0  p_91);
inline static struct S0  func_94(struct S0  p_95, int32_t  p_96, uint16_t  p_97, uint32_t  p_98, union U2  p_99);
inline static struct S0  func_100(int8_t  p_101, uint16_t  p_102, int32_t  p_103, int16_t  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_32(void)
{ /* block id: 36 */
    uint32_t l_35 = 0x086335C0;
    int32_t l_41 = 0xBBD18838;
    int32_t l_42 = 0x8169C147;
    uint32_t l_350 = 0xF689F1D7;
    struct S1 l_365 = {2,-14,-3828,0x22C2,1345,0x5FA84D3B,1,-4,0xA60BC6B0};
    int16_t l_366 = 0;
    struct S0 l_383 = {0xE4CD29A4,0x53,0x699D0825,0xE9,0x7D38C6CD};
    int32_t l_386 = 0xD880E8BD;
    int32_t l_400 = 1;
    union U2 l_413 = {{0x40BD1DE4,-1,-1,0xBE,0xF94A6298}};
    union U2 l_414 = {{0x913B07E9,0xFE,0xCAD12B6D,1,-1}};
    int8_t l_417 = 0x3F;
    uint16_t l_462 = 1U;
    uint32_t l_513 = 0x01042804;
    if ((l_350 = (((int16_t)l_35 >> (int16_t)14) ^ (((((int32_t)func_38((l_41 &= l_35), (l_35 >= ((l_35 <= ((l_42 = l_35) != ((int16_t)l_35 >> (int16_t)9))) || ((int32_t)1 + (int32_t)0x5487972E)))) + (int32_t)l_35) >= l_35) != l_35) == 3))))
    { /* block id: 214 */
        int32_t l_353 = 0xAE959DB5;
        uint32_t l_359 = 0U;
        struct S1 l_364 = {-2,14,-5106,0x8285,191,0xF95C7958,2,7,4294967291U};
        union U2 l_393 = {{0x377881C6,0xC0,0x00E2A946,-1,-4}};
        uint16_t l_464 = 0xC320;
        uint32_t l_473 = 0xA282EDF9;
        int8_t l_514 = 0;
        for (l_35 = (-14); (l_35 != 21); l_35 += 7)
        { /* block id: 217 */
            l_353 = 1;
        }
        if ((l_353 &= ((int32_t)l_42 - (int32_t)4294967293U)))
        { /* block id: 221 */
            int16_t l_356 = (-4);
            struct S1 l_362 = {2,-17,-7441,2,1316,0x55B47B51,1,-15,0x4B0FBFB2};
            struct S0 l_363 = {0x9E425B9E,0x83,0xFCBA9512,0xAA,1};
            l_366 |= ((func_74(l_356, ((uint16_t)l_356 << (uint16_t)6), l_359) || (((func_81((((1U & ((uint16_t)func_53((l_362 , l_362.f5), l_363, ((l_42 &= (l_359 != l_41)) < l_356), l_353) % (uint16_t)1U)) && 0xD7E2D96D) , 0x27), l_356, l_364, l_365) != l_362.f5) , 0x3782908A) != 1U)) >= l_365.f4);
        }
        else
        { /* block id: 224 */
            int16_t l_367 = 2;
            int32_t l_375 = 0x55E920F6;
            int16_t l_380 = 8;
            int32_t l_389 = 0xD64F7357;
            union U2 l_396 = {{-1,3,-1,0xD4,-1}};
            struct S0 l_398 = {0xB9D86AEE,0x94,0x6C112730,6,0xA6AD1D73};
            uint16_t l_472 = 0xB718;
            int8_t l_480 = 0x99;
            uint16_t l_494 = 0x5AE7;
            l_365.f2 = l_367;
            if (l_364.f2)
            { /* block id: 226 */
                int32_t l_372 = 0x6BD332B8;
                struct S1 l_390 = {-3,-2,6934,0,-1232,4294967295U,0,-6,0xD8716D39};
                for (l_41 = 0; (l_41 != 16); l_41 += 1)
                { /* block id: 229 */
                    int8_t l_374 = 0x81;
                    for (l_350 = 0; (l_350 <= 16); l_350 += 1)
                    { /* block id: 232 */
                        uint16_t l_376 = 6U;
                        l_375 = ((l_372 = l_367) != ((0x7B85 != __builtin_bswap64(l_350)) <= (((l_364.f8 , (-(int16_t)func_38((8U <= l_374), l_365.f4))) > l_364.f7) ^ l_364.f5)));
                        l_375 &= l_376;
                        l_383.f4 = ((uint16_t)(l_376 <= (((l_372 ^ (l_364.f7 , (l_380 = (-(int32_t)l_367)))) > ((((int32_t)__builtin_popcount(l_372) - (int32_t)(l_383 , 0x4796A68E)) > ((int16_t)(-1) << (int16_t)l_372)) <= l_353)) , l_386)) >> (uint16_t)l_375);
                    }
                }
                l_365.f1 = ((int32_t)l_380 + (int32_t)((l_353 &= l_389) , l_375));
                l_390 = l_364;
            }
            else
            { /* block id: 243 */
                uint32_t l_397 = 3U;
                int32_t l_399 = 0x802A1468;
                int32_t l_470 = 0x4B571E88;
                int32_t l_471 = 1;
                int32_t l_481 = (-9);
                uint32_t l_486 = 4U;
                uint32_t l_495 = 0xE46297C2;
                struct S1 l_496 = {-9,-11,-7633,-7,680,1U,3,25,0U};
                struct S0 l_510 = {-1,0x8D,0,-2,0x2CB6419F};
                for (l_380 = (-22); (l_380 != (-20)); l_380 += 1)
                { /* block id: 246 */
                    uint32_t l_401 = 4294967293U;
                    int32_t l_406 = 0;
                    union U2 l_412 = {{0xF9A5ECCF,1,4,1,8}};
                    int32_t l_493 = 0x84C814A6;
                    struct S1 l_498 = {0,7,-3910,0x533C,1057,9U,3,16,0xD12D2698};
                    if ((((l_383.f4 &= __builtin_ffsll(l_365.f2)) < (l_401 = (((l_399 |= (func_53((l_393 , (l_365.f4 >= l_393.f0.f0)), (l_398 = (((int16_t)l_364.f2 >> (int16_t)2) , func_58(l_396, (((l_375 = 0xF41B) , l_364.f2) , l_397), l_383.f0))), l_397, l_364.f1) & 1)) , l_400) | 0x5D0A29AD))) >= 1U))
                    { /* block id: 252 */
                        int32_t l_418 = 0xAEBA5A67;
                        int32_t l_419 = 0x4A4F0EC5;
                        struct S0 l_433 = {0x121BC739,-3,0x0071A631,-1,0x4A4188C3};
                        int32_t l_434 = (-1);
                        uint16_t l_450 = 0x6B72;
                        union U2 l_463 = {{0xD603B305,0xB2,-1,0x0C,0x26FB0D8C}};
                        l_419 = ((((l_375 = (((int32_t)0xE78D6175 % (int32_t)((uint32_t)(l_412.f0.f0 = (((l_406 = 0x2E9FB76E) < ((uint16_t)((uint16_t)2U + (uint16_t)((((0xDA0429A4 ^ (-(int32_t)(((((l_414 = (l_413 = l_412)) , ((l_365.f5 , ((l_399 , ((uint16_t)func_74(l_412.f1, (l_417 >= 0xEDE7A547), l_393.f0.f2) << (uint16_t)l_398.f0)) , l_412.f0.f2)) , 0x2948)) ^ l_412.f0.f3) , (-6)) == 3U))) == 0x9316ED79) || 7) >= l_397)) << (uint16_t)8)) != 0x1D026599)) - (uint32_t)l_365.f5)) >= l_393.f1)) == 0x3B6C) , l_399) ^ l_418);
                        l_434 ^= ((func_88(((uint16_t)0x3D12 >> (uint16_t)(l_419 = ((l_364.f4 = ((uint16_t)(l_398.f0 = (l_396.f0.f1 , l_364.f5)) >> (uint16_t)l_380)) < ((int16_t)((uint16_t)(~((l_406 |= __builtin_ffsl(((((((l_418 | ((uint16_t)(l_399 && l_393.f0.f3) >> (uint16_t)((int16_t)(__builtin_ffsl(l_398.f4) , 0) >> (int16_t)l_397))) || l_412.f0.f3) > l_412.f0.f3) >= 0x4711) || l_414.f1) <= l_397))) > (-10))) >> (uint16_t)14) >> (int16_t)l_419)))), l_418, l_433) , l_396.f0.f4) <= l_364.f5);
                        l_406 = __builtin_popcountl((((int16_t)((((int16_t)((uint32_t)(0xA40F | l_350) % (uint32_t)l_396.f0.f4) % (int16_t)((l_414.f0.f0 = ((int32_t)0x1FFC74E9 % (int32_t)((uint16_t)(l_399 ^ __builtin_bswap64((l_399 && l_413.f0.f0))) + (uint16_t)(!(!(l_393.f0.f4 |= l_433.f2)))))) || l_375)) | l_434) < l_397) >> (int16_t)l_396.f0.f3) , l_433.f4));
                        l_463.f0.f0 = (l_393.f0.f2 | (l_414.f0.f0 >= (-(int32_t)(((l_365.f4 ^= func_38(l_365.f0, (l_41 &= (((int16_t)9 % (int16_t)((l_450 = 0) , ((uint16_t)(l_396.f0.f4 = ((uint16_t)(func_94(l_414.f0, ((int16_t)(((l_398.f0 &= (((uint16_t)l_397 << (uint16_t)((l_396.f0.f2 == ((uint16_t)(-(int32_t)(l_399 > 0x550F)) >> (uint16_t)l_397)) , 0x939B)) < 0)) , l_383.f4) || l_462) >> (int16_t)l_412.f0.f1), l_412.f0.f2, l_396.f1, l_463) , 0xC4EB) >> (uint16_t)4)) << (uint16_t)l_364.f3))) , 0x3ED2)))) && 0x58A54B1F) | l_398.f3))));
                    }
                    else
                    { /* block id: 273 */
                        int32_t l_469 = 0;
                        l_473 = ((l_353 = (func_74((l_401 <= l_353), l_464, ((uint32_t)(((int32_t)(l_401 != ((l_469 ^ 0xDB69) < (func_88(l_399, (l_471 ^= (l_470 >= ((__builtin_ffsll(l_406) < l_399) > l_412.f0.f4))), l_383) , l_367))) % (int32_t)l_397) >= 0x4E1A) - (uint32_t)l_472)) , 0xA983C523)) != 0xDB340037);
                        l_383.f4 = ((0x1E9E != (l_383.f1 || l_397)) != l_469);
                        l_399 = ((uint16_t)0xC73A << (uint16_t)0);
                        l_399 = (((uint16_t)0x1E37 - (uint16_t)(((6 <= ((l_470 = l_470) <= ((int32_t)l_398.f1 - (int32_t)l_480))) >= l_469) == (((l_413.f0.f1 != l_481) <= ((uint16_t)(l_393 , l_393.f0.f4) << (uint16_t)l_480)) >= l_413.f1))) == l_413.f0.f4);
                    }
                    l_393.f0.f4 = ((l_412.f0.f0 || (((int32_t)((__builtin_parityl(func_38(l_486, l_406)) | (l_464 > ((((int16_t)((((l_470 = l_412.f0.f3) > (l_364.f8 ^ ((l_481 &= (((((uint16_t)((l_493 = (((0xFC32 | l_396.f0.f2) , l_412.f0.f3) || l_399)) >= 0U) - (uint16_t)l_494) > l_414.f0.f4) , 4294967286U) > l_495)) && 1U))) , 0U) && l_470) << (int16_t)l_399) && l_406) & 4294967291U))) , l_398.f1) - (int32_t)0x690CB985) , l_464)) & 0x990B08B0);
                    if (l_412.f0.f3)
                    { /* block id: 286 */
                        struct S1 l_497 = {-10,3,4729,0,-200,4294967295U,1,-19,1U};
                        l_498 = (l_496 , l_497);
                        l_481 &= l_412.f0.f0;
                        l_496.f0 = l_498.f2;
                    }
                    else
                    { /* block id: 290 */
                        int32_t l_505 = (-7);
                        int32_t l_506 = 0x973A1E7B;
                        int32_t l_511 = (-2);
                        l_511 |= func_53(((int16_t)((int16_t)func_88(l_498.f0, (((l_364.f1 &= (l_506 &= (__builtin_ctzll(((l_496 , l_393.f0.f2) , l_505)) , l_505))) , (-6)) | (((uint32_t)(l_498.f5 & (-(uint16_t)(__builtin_bswap32(((func_62(((l_364.f0 = l_364.f8) != l_367), l_414.f0.f0, l_389, l_510, l_495) , 1U) & l_462)) , l_399))) % (uint32_t)l_413.f0.f3) > l_364.f5)), l_414.f0) << (int16_t)l_364.f3) + (int16_t)9), l_510, l_393.f0.f0, l_380);
                        l_412.f0.f0 ^= l_398.f1;
                        if (l_398.f1)
                            break;
                    }
                    return l_364.f6;
                }
            }
            l_393.f0.f0 ^= (-(uint16_t)65535U);
        }
        l_514 = l_513;
    }
    else
    { /* block id: 304 */
        struct S0 l_515 = {0x50D89CF8,0x96,0xDF6C1B85,0xF3,-7};
        struct S1 l_516 = {3,14,4574,1,-433,0xA0C7446E,1,16,4294967295U};
        l_383 = l_515;
        l_516 = l_516;
    }
    return l_386;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_38(int32_t  p_39, int16_t  p_40)
{ /* block id: 39 */
    uint16_t l_47 = 0xBE2F;
    struct S1 l_151 = {1,11,-5562,1,-113,0x1E1EA803,1,19,4294967295U};
    struct S0 l_168 = {-4,8,0x3DA66330,0x89,-1};
    uint32_t l_229 = 0x5C0E044A;
    int32_t l_297 = 0xE59CB8B0;
    struct S0 l_348 = {1,-1,5,0xB6,0x7779FA11};
    struct S0 l_349 = {0x09399532,0x93,0x63C9BB6D,0x10,-9};
    if ((__builtin_popcountl(l_47) || 1))
    { /* block id: 40 */
        uint32_t l_71 = 4294967295U;
        int32_t l_78 = 0x83ADAB8F;
        int32_t l_92 = 0xABB00F61;
        struct S0 l_93 = {7,0xFF,0xA4BDACAB,0x11,-8};
        struct S1 l_152 = {4,-1,-3456,0x044F,-784,0xE7157E95,3,-6,0xD8EDDB30};
        union U2 l_170 = {{0xF75C09CC,1,5,7,0x805FBE3F}};
        uint16_t l_233 = 0x1B36;
        p_39 = (((int32_t)((p_40 = (((!((((int16_t)(((l_151.f4 = func_53(p_40, (l_170.f0 = (l_93 = func_58((func_62((((uint16_t)(-(int32_t)l_47) << (uint16_t)p_39) == (__builtin_bswap32(((l_71 == l_71) , (((uint32_t)(func_74((((-2) & ((l_78 = l_47) ^ (((uint16_t)func_81(p_40, ((int32_t)(func_88(l_47, l_92, l_93) ^ 0x996B) + (int32_t)1U), l_151, l_152) >> (uint16_t)12) >= l_151.f8))) > p_39), l_151.f6, l_152.f8) <= p_40) % (uint32_t)1U) <= p_39))) , p_40)), l_151.f7, l_152.f4, l_168, l_151.f1) , l_170), l_152.f4, l_151.f1))), l_168.f4, l_168.f1)) <= p_39) , l_78) << (int16_t)6) , l_168) , p_39)) != l_229) & (-1))) <= p_39) % (int32_t)l_152.f0) > p_39);
        for (l_93.f4 = 0; (l_93.f4 < 11); l_93.f4 += 8)
        { /* block id: 133 */
            struct S1 l_232 = {6,-10,-5757,0x31C9,-916,1U,0,10,0xF4F0EBA9};
            l_232 = l_152;
            return l_232.f4;
        }
        l_170.f0.f0 = (l_93.f0 != (l_233 = l_152.f0));
        l_78 = ((l_93 , ((int16_t)(l_152 , (-5)) << (int16_t)15)) >= ((func_53((((uint16_t)__builtin_bswap32(p_39) << (uint16_t)((int16_t)((int16_t)(l_168.f4 = 0x0AAB) << (int16_t)8) - (int16_t)p_40)) , ((int32_t)__builtin_ctzl(l_152.f6) % (int32_t)l_152.f0)), l_93, p_40, l_170.f0.f4) & l_170.f0.f1) | l_151.f5));
    }
    else
    { /* block id: 141 */
        uint32_t l_244 = 4294967295U;
        l_151 = l_151;
        p_39 = p_40;
        return l_244;
    }
    l_151.f0 = (~(0xF69DBDDC < (-1)));
    for (p_39 = (-8); (p_39 >= (-7)); p_39 += 1)
    { /* block id: 149 */
        uint16_t l_255 = 0x1F7C;
        struct S1 l_265 = {3,-1,-2161,-3,910,0xA78CF511,1,-11,1U};
        union U2 l_266 = {{-7,4,6,-10,0x0DBB3CFD}};
        int32_t l_269 = 0;
        uint32_t l_274 = 0x2CF23584;
        int32_t l_331 = (-2);
        for (l_168.f3 = (-1); (l_168.f3 > (-1)); l_168.f3 += 1)
        { /* block id: 152 */
            int32_t l_252 = 0xF3F14628;
            l_252 &= ((int16_t)(-1) % (int16_t)(-10));
            if (l_151.f7)
                break;
            l_151.f0 |= ((uint16_t)l_255 << (uint16_t)13);
        }
        for (l_168.f1 = 0; (l_168.f1 < 2); l_168.f1 += 1)
        { /* block id: 159 */
            int32_t l_260 = 1;
            int32_t l_261 = (-9);
            int32_t l_267 = 9;
            struct S0 l_268 = {0xD87469C5,0,0x83CCC9B7,0,1};
            struct S1 l_270 = {-0,-12,-1433,0xDFF8,-178,4294967295U,3,-2,1U};
            struct S1 l_271 = {2,5,-2893,0x2EE9,-1137,4294967290U,3,13,0x2B098093};
            l_151 = (l_270 = (func_62((l_267 = (((int32_t)(l_168.f4 = ((l_260 == func_81((l_168 , ((l_261 = 0xC98E) || ((uint16_t)(~1) + (uint16_t)l_260))), p_39, l_265, (l_266 , l_151))) || l_261)) % (int32_t)l_260) <= l_151.f1)), l_260, l_260, l_268, l_269) , l_265));
            if (p_40)
                continue;
            l_151 = l_271;
            l_265 = l_271;
        }
        l_274 = ((int16_t)l_266.f0.f4 * (int16_t)p_39);
        if (l_151.f8)
        { /* block id: 170 */
            struct S1 l_283 = {-0,2,-113,5,-1374,0x8443DA25,1,11,4294967292U};
            struct S0 l_291 = {-2,-1,0,7,-10};
            l_265.f2 ^= __builtin_bswap32((l_266.f0 , (l_151.f4 <= ((int16_t)(func_88(p_40, (p_39 == ((((int16_t)(((int16_t)((uint32_t)(((p_39 , l_283) , ((uint16_t)(l_151.f1 = 0U) + (uint16_t)l_151.f7)) , (((uint16_t)(!0) * (uint16_t)l_283.f5) || 0xFD6CFE86)) + (uint32_t)l_168.f4) * (int16_t)l_168.f1) == p_39) << (int16_t)l_266.f1) >= l_168.f1) , l_265.f1)), l_168) == 1U) - (int16_t)p_39))));
            l_265.f1 = ((uint16_t)p_40 - (uint16_t)__builtin_popcount(l_283.f2));
            l_291 = l_291;
        }
        else
        { /* block id: 175 */
            int32_t l_294 = 0xA831BD17;
            uint16_t l_307 = 65535U;
            int32_t l_321 = (-4);
            struct S0 l_322 = {0xB2EEEA66,0xF6,1,0xB0,0};
            uint32_t l_332 = 0x2C8899B7;
            for (l_229 = 19; (l_229 != 45); l_229 += 2)
            { /* block id: 178 */
                uint32_t l_308 = 1U;
                struct S0 l_309 = {0x3A4CB9A5,0xB5,1,-2,0x0773055D};
                if (p_40)
                    break;
                l_294 = l_266.f1;
                for (l_168.f0 = 0; (l_168.f0 >= 7); l_168.f0 += 9)
                { /* block id: 183 */
                    struct S0 l_298 = {0x392BCE64,1,0,0x7B,0xCE8A82D6};
                    l_265.f2 = func_74(func_88(l_265.f0, (l_151.f7 = (func_53((l_151.f2 = func_53((l_297 ^= p_39), l_298, (0xBCBD8F18 < ((l_298.f1 & ((uint16_t)p_39 % (uint16_t)((int16_t)p_39 * (int16_t)((int16_t)0xE1AD - (int16_t)((uint16_t)((func_100((1 >= l_265.f7), l_265.f8, l_307, p_39) , l_308) , p_40) << (uint16_t)p_39))))) < 5U)), p_40)), l_168, p_39, l_298.f4) , p_40)), l_309), l_151.f8, l_298.f4);
                    l_151.f4 = func_88(p_39, __builtin_ctzl((l_321 |= (l_298.f4 = (1 < (l_298.f2 < (((l_168 , ((uint32_t)((~((int16_t)0x968A + (int16_t)(l_298.f4 , p_39))) > ((((uint16_t)p_40 - (uint16_t)((int16_t)(l_266.f0.f4 &= (((int32_t)func_88(((l_309 , l_298.f1) >= p_40), p_39, l_168) - (int32_t)l_265.f3) == 0x445802C0)) % (int16_t)p_40)) || p_39) < 0x939F94B3)) % (uint32_t)p_39)) | p_40) && l_298.f2)))))), l_322);
                }
            }
            for (l_168.f1 = 0; (l_168.f1 == (-22)); l_168.f1 -= 1)
            { /* block id: 196 */
                l_265.f1 = ((((int16_t)(l_266.f0 , 1) << (int16_t)1) , ((int16_t)l_47 << (int16_t)((int16_t)l_168.f1 >> (int16_t)(l_151.f7 ^= (l_331 != 65535U))))) > ((l_332 = (l_265.f4 = (((__builtin_clz(p_39) || 7) & 0x1F147763) < p_39))) != l_47));
            }
            l_297 = ((uint16_t)((uint16_t)(l_322.f4 = ((uint16_t)(l_322.f0 = p_39) << (uint16_t)6)) + (uint16_t)(!(l_265.f2 |= (p_40 = ((int16_t)__builtin_ffs(l_294) << (int16_t)9))))) - (uint16_t)7U);
            l_265.f7 = ((l_151.f3 , 0xF648C512) <= ((uint32_t)((int16_t)0x6CDA - (int16_t)(((int32_t)l_332 % (int32_t)__builtin_popcountl(l_151.f1)) && (l_266.f0.f4 != p_39))) - (uint32_t)l_294));
        }
    }
    l_348 = (l_349 = l_348);
    return l_151.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_53(int32_t  p_54, struct S0  p_55, uint32_t  p_56, uint32_t  p_57)
{ /* block id: 92 */
    uint32_t l_184 = 0U;
    int32_t l_187 = (-1);
    struct S1 l_194 = {0,-6,750,0x2487,-789,5U,3,-19,4U};
    struct S0 l_214 = {-1,0x2F,0x1FB7984C,0,0xE0697B8A};
    uint32_t l_225 = 0x91CD5F59;
    l_187 &= (p_57 | ((int16_t)p_55.f1 >> (int16_t)(((((((((uint16_t)0x5C3D + (uint16_t)(((uint16_t)((uint16_t)((int16_t)((0x3370 || ((int32_t)p_57 + (int32_t)l_184)) > p_57) - (int16_t)(p_55.f4 || ((uint16_t)__builtin_parityl(p_55.f1) << (uint16_t)13))) % (uint16_t)l_184) * (uint16_t)65529U) >= p_55.f0)) & l_184) != l_184) == l_184) && p_55.f0) & p_54) >= 0xC3F1057C) , p_55.f3)));
    for (p_55.f1 = (-27); (p_55.f1 == 6); p_55.f1 += 1)
    { /* block id: 96 */
        if (p_55.f3)
            break;
    }
    l_187 = l_184;
    if (((((uint16_t)__builtin_popcount(((uint32_t)((l_184 != (l_194 , p_55.f0)) | p_57) + (uint32_t)(0x9534 && (((((p_55 , ((p_55.f4 , p_57) != (p_55.f1 == (-8)))) != l_194.f5) >= l_194.f8) , l_194.f5) || 0x6A43)))) * (uint16_t)p_55.f3) >= p_56) , p_55.f1))
    { /* block id: 100 */
        struct S1 l_195 = {-1,-2,-2438,0x1257,-665,4294967290U,3,-14,0x17036850};
        l_194 = l_195;
    }
    else
    { /* block id: 102 */
        uint32_t l_201 = 0x26D5457A;
        int16_t l_204 = 9;
        int32_t l_210 = 0x9F08BABB;
        struct S0 l_224 = {1,-1,-1,0x5D,0xD01E5D37};
        struct S1 l_228 = {-5,14,-1800,0xB6CC,551,4294967295U,1,-3,4294967291U};
        for (p_56 = 0; (p_56 >= 17); p_56 += 1)
        { /* block id: 105 */
            uint32_t l_209 = 1U;
            int32_t l_212 = 0xCD871682;
            struct S0 l_213 = {0xB426B7B2,8,6,-1,0x0192FCFE};
            int32_t l_215 = 0x4C9FFC7C;
            if ((((((int32_t)p_54 + (int32_t)((-(uint32_t)(l_201 != __builtin_ffsl(p_55.f3))) <= ((((((int16_t)(-1) % (int16_t)p_55.f3) <= (l_204 || ((uint16_t)((int16_t)(l_210 = __builtin_parity(l_209)) - (int16_t)p_55.f4) >> (uint16_t)l_209))) != l_201) == 0x25B5E633) & l_209))) < l_194.f4) != 0x83ED) != 4294967295U))
            { /* block id: 107 */
                uint16_t l_211 = 5U;
                p_55 = func_100(p_56, (l_212 = l_211), p_54, l_194.f6);
                p_55 = (l_214 = l_213);
            }
            else
            { /* block id: 112 */
                return l_213.f1;
            }
            return l_215;
        }
        if ((((uint16_t)p_54 >> (uint16_t)0) & ((l_210 ^ ((uint16_t)((65533U > p_55.f2) , (((l_194.f4 = ((int32_t)((func_62(__builtin_popcountl(((uint16_t)(l_194.f7 , l_194.f8) << (uint16_t)((l_214 , __builtin_clzll((l_194.f2 > (func_62(((-4) > (-4)), p_56, p_55.f4, p_55, l_214.f3) , p_55.f1)))) == 0))), l_204, l_201, l_224, p_55.f3) , 1) < 0x830DA417) % (int32_t)p_55.f2)) , 0x24) , p_54)) >> (uint16_t)l_225)) < 0xC9FDBBE0)))
        { /* block id: 118 */
            l_194.f1 |= (p_55.f4 = p_55.f3);
            return l_194.f4;
        }
        else
        { /* block id: 122 */
            uint32_t l_226 = 0xDA0C8096;
            int32_t l_227 = 7;
            l_227 &= (p_55.f1 ^ l_226);
        }
        l_228 = l_228;
    }
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_58(union U2  p_59, int16_t  p_60, int16_t  p_61)
{ /* block id: 88 */
    struct S0 l_171 = {-1,-5,0x7FE557E6,0xCC,-3};
    return l_171;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_62(uint32_t  p_63, int8_t  p_64, int16_t  p_65, struct S0  p_66, int32_t  p_67)
{ /* block id: 85 */
    union U2 l_169 = {{4,0x71,0,0xA8,0xF3720B21}};
    p_66.f0 = p_66.f1;
    return l_169;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_74(int16_t  p_75, uint32_t  p_76, int32_t  p_77)
{ /* block id: 74 */
    uint32_t l_160 = 6U;
    struct S0 l_164 = {0x3F1638C0,-1,0x81410193,0x2E,0x19775E7F};
    int8_t l_166 = 0xDB;
    struct S1 l_167 = {2,-1,-1314,0xB26D,-952,4294967294U,1,24,7U};
    for (p_77 = 0; (p_77 >= (-29)); p_77 -= 4)
    { /* block id: 77 */
        uint32_t l_161 = 0U;
        int32_t l_165 = (-8);
        l_164.f0 = (((uint16_t)(l_161 = ((uint16_t)(~(l_160 = 0x34E314DB)) >> (uint16_t)8)) % (uint16_t)((int32_t)p_76 % (int32_t)p_75)) && (l_165 |= (0x579426CD <= func_88(l_160, p_75, l_164))));
    }
    l_167 = (l_166 , l_167);
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_81(int8_t  p_82, uint32_t  p_83, struct S1  p_84, struct S1  p_85)
{ /* block id: 72 */
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_88(uint16_t  p_89, uint32_t  p_90, struct S0  p_91)
{ /* block id: 42 */
    int8_t l_105 = (-1);
    int8_t l_110 = 1;
    int32_t l_122 = 0x3647B8CE;
    uint16_t l_123 = 0xDC04;
    int32_t l_124 = (-1);
    int8_t l_143 = 1;
    union U2 l_144 = {{0x65BEC774,0x4B,0xF72C0FF2,0,-1}};
    struct S1 l_150 = {-5,12,3060,0xABD0,1003,0xAAFE8A4A,3,-14,0x2840ACBB};
    l_144.f0 = func_94((p_91 = func_100(l_105, ((uint16_t)((int16_t)(((__builtin_clz(l_105) < (p_91.f3 >= ((l_124 = (l_110 , (p_91.f0 = ((-(int32_t)((int16_t)(4U ^ l_110) * (int16_t)((((uint16_t)(-(uint16_t)(-(int32_t)((l_105 , ((uint16_t)__builtin_ctz(((((uint16_t)((l_122 ^= (p_90 > 0x5760)) || p_90) << (uint16_t)l_123) != p_89) , 4U)) % (uint16_t)65533U)) < p_89))) + (uint16_t)l_105) , p_91.f1) , l_122))) > l_123)))) <= 4294967288U))) & l_110) , p_91.f4) * (int16_t)l_123) >> (uint16_t)p_91.f1), p_91.f3, p_91.f2)), l_110, l_143, l_110, l_144);
    for (l_122 = (-24); (l_122 < 21); l_122 += 7)
    { /* block id: 63 */
        int32_t l_149 = (-9);
        p_91.f0 = l_149;
        l_144.f0.f0 |= (-3);
        return p_91.f4;
    }
    l_150 = l_150;
    l_150.f0 = (l_124 = p_91.f2);
    return p_91.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_94(struct S0  p_95, int32_t  p_96, uint16_t  p_97, uint32_t  p_98, union U2  p_99)
{ /* block id: 56 */
    struct S1 l_145 = {7,20,4631,0xB53E,1403,0x8D033575,0,-29,0xC3A22099};
    struct S0 l_146 = {-1,0x71,-10,0x7E,0};
    l_145 = l_145;
    l_145.f0 = 0xE6111D55;
    return l_146;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_100(int8_t  p_101, uint16_t  p_102, int32_t  p_103, int16_t  p_104)
{ /* block id: 46 */
    int32_t l_133 = 0x1B5FDDB2;
    int32_t l_138 = 1;
    int32_t l_139 = 0x355696F0;
    int32_t l_140 = 0xE85BCF72;
    int32_t l_141 = (-8);
    struct S0 l_142 = {-1,0,0xD7079270,0xEC,0xAF5A799B};
    l_141 = (((((uint16_t)(p_104 == ((int16_t)(l_140 = (((l_139 |= ((int16_t)((((p_102 ^= ((uint16_t)p_103 << (uint16_t)7)) , (((l_138 = __builtin_ffs(((__builtin_parity((1 >= l_133)) | (((uint16_t)(p_102 = p_103) << (uint16_t)10) , (l_133 != (-1)))) > ((int16_t)p_104 - (int16_t)l_133)))) , (-4)) <= p_101)) || 1U) , 0xA708) + (int16_t)p_104)) == l_133) & p_101)) + (int16_t)1U)) - (uint16_t)0x2F2F) , l_133) & 1) , 0x5AAB3741);
    l_138 |= (p_103 && l_139);
    return l_142;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 115
   depth: 1, occurrence: 43
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 21
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 14
XXX times a bitfields struct on RHS: 25
XXX times a single bitfield on LHS: 26
XXX times a single bitfield on RHS: 40

XXX max expression depth: 55
breakdown:
   depth: 1, occurrence: 121
   depth: 2, occurrence: 28
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 3
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2
   depth: 32, occurrence: 2
   depth: 33, occurrence: 3
   depth: 38, occurrence: 1
   depth: 55, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 519
XXX times a non-volatile is write: 166
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 116
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 25
   depth: 2, occurrence: 26
   depth: 3, occurrence: 11
   depth: 4, occurrence: 7
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 23.8
XXX percentage an existing variable is used: 76.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

