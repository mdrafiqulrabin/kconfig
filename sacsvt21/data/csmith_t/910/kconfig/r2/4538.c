/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3723834600
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const signed f0 : 2;
};
#pragma pack(pop)

union U1 {
   uint16_t  f0;
   const unsigned f1 : 22;
   uint8_t  f2;
   signed f3 : 29;
};

union U2 {
   const uint32_t  f0;
   uint16_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_36(void);
static float  func_42(int32_t  p_43, uint32_t  p_44);
static const uint64_t  func_46(struct S0  p_47, int16_t  p_48, union U2  p_49, union U1  p_50, uint32_t  p_51);
inline static uint32_t  func_56(int16_t  p_57, int32_t  p_58);
static int32_t  func_62(union U1  p_63, uint32_t  p_64, struct S0  p_65);
inline static union U1  func_66(uint16_t  p_67, union U2  p_68, union U2  p_69, struct S0  p_70);
static uint16_t  func_71(int32_t  p_72, uint64_t  p_73, uint32_t  p_74);
inline static int32_t  func_75(uint32_t  p_76, union U1  p_77, float  p_78, const uint8_t  p_79);
inline static float  func_81(uint8_t  p_82, uint16_t  p_83, int64_t  p_84);
inline static const uint64_t  func_90(uint16_t  p_91, const uint32_t  p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_36(void)
{ /* block id: 36 */
    int32_t l_37 = 1L;
    struct S0 l_52 = {1};
    union U2 l_54 = {7UL};
    union U2 * const l_773 = &l_54;
    union U2 * const *l_772 = &l_773;
    uint64_t l_774 = 7UL;
    int32_t *l_775 = &l_37;
    int32_t l_776 = 7L;
    for (l_37 = 0; (l_37 != 14); l_37 += 7)
    { /* block id: 39 */
        uint8_t l_53 = 0x21L;
        union U1 l_55 = {1UL};
        float l_765 = 0x5.8F90EEp+71;
        float *l_764 = &l_765;
        (*l_764) = (((float)(func_42((-(int16_t)(func_46(l_52, l_53, l_54, l_55, func_56(l_54.f1, l_54.f1)) > l_55.f2)), l_55.f2) <= l_52.f0) + (float)l_55.f2) > l_52.f0);
    }
    (*l_775) = (l_54.f1 ^ ((int16_t)((((l_52.f0 || l_54.f1) <= (-9L)) ^ 0x8E1CB922EB87E373LL) > ((l_37 & ((int16_t)l_37 >> (int16_t)13)) < ((((uint32_t)l_54.f0 + (uint32_t)(l_772 != &l_773)) <= l_774) <= l_52.f0))) >> (int16_t)l_54.f1));
    return l_776;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_42(int32_t  p_43, uint32_t  p_44)
{ /* block id: 302 */
    int64_t l_549 = 0x729D3353B18B0854LL;
    union U1 l_551 = {0x9044L};
    union U1 *l_550 = &l_551;
    int32_t l_574 = 0x34E38E93L;
    int32_t l_580 = 0x8A4B93ACL;
    const int32_t *l_584 = &l_580;
    const int32_t **l_583 = &l_584;
    struct S0 l_604 = {1};
    struct S0 *l_603 = &l_604;
    union U1 ** const **l_657 = (void*)0;
    float l_677 = (-0x1.0p+1);
    float *l_676 = &l_677;
    union U2 l_763 = {0xDCD3B6ADL};
    if (l_549)
    { /* block id: 303 */
        union U1 **l_552 = &l_550;
        union U1 ***l_556 = &l_552;
        union U1 **** const l_555 = &l_556;
        int32_t l_579 = 0L;
        struct S0 l_582 = {-0};
        struct S0 *l_581 = &l_582;
        union U2 l_610 = {0xBDE517D6L};
        union U2 *l_609 = &l_610;
        uint32_t l_635 = 1UL;
        uint8_t l_650 = 0UL;
        float l_653 = 0x7.28F168p+48;
        float * const l_652 = &l_653;
        int64_t l_674 = 1L;
lbl_564:
        (*l_552) = l_550;
lbl_613:
        for (l_549 = (-11); (l_549 >= 22); l_549 += 3)
        { /* block id: 307 */
            int32_t *l_557 = (void*)0;
            int32_t *l_558 = (void*)0;
            l_551.f3 = ((l_555 != (void*)0) && p_44);
            /* statement id: 308 */
                        for (l_551.f2 = 0; (l_551.f2 != 48); l_551.f2 += 4)
            { /* block id: 311 */
                int32_t *l_561 = (void*)0;
                const int32_t **l_562 = (void*)0;
                int32_t **l_563 = &l_561;
                float *l_575 = (void*)0;
                float *l_576 = (void*)0;
                float l_578 = (-0x1.Fp-1);
                float *l_577 = &l_578;
                (*l_563) = l_561;
                if (l_549)
                    goto lbl_564;
                (*l_577) = (((0x1.5p+1 > (0xB.51E5C8p-66 >= ((((float)p_43 - (float)(((((float)func_56(((int16_t)(~l_551.f2) << (int16_t)14), ((uint64_t)(p_43 < l_549) + (uint64_t)(1UL != p_44))) / (float)0x2.A9C5D7p-88) < l_574) >= p_43) >= p_43)) != p_44) != p_43))) >= p_43) >= 0xF.8C5EABp+81);
                l_580 = l_579;
            }
            /* facts after for loop */
                    }
        if (l_549)
            goto lbl_564;
        if (l_551.f2)
        { /* block id: 319 */
            float l_586 = 0x0.3p+1;
            float *l_585 = &l_586;
            (*l_556) = &l_550;
            (*l_585) = (__builtin_clz((l_574 && (((void*)0 != l_581) || (l_583 == (void*)0)))) >= p_44);
        }
        else
        { /* block id: 322 */
            float l_589 = 0x1.Cp-1;
            struct S0 *l_596 = (void*)0;
            union U2 l_599 = {0UL};
            uint8_t l_612 = 9UL;
            for (l_551.f0 = 1; (l_551.f0 >= 16); l_551.f0++)
            { /* block id: 325 */
                uint8_t l_590 = 0xE9L;
                struct S0 l_593 = {1};
                int32_t *l_597 = &l_580;
                (*l_597) = (__builtin_popcount(((0L & (((l_590 <= ((int16_t)1L >> (int16_t)10)) & l_590) | func_62((**l_552), p_44, l_593))) != ((int16_t)(((void*)0 != l_596) && l_593.f0) << (int16_t)p_44))) <= 0xD1EB9EBAA9610F24LL);
                if (p_44)
                { /* block id: 327 */
                    struct S0 l_598 = {-1};
                    union U1 l_600 = {65535UL};
                    l_600.f3 = ((func_46(l_598, l_582.f0, l_599, l_600, ((uint32_t)p_43 - (uint32_t)(((p_44 > ((*l_597) > 0xDA832B1C84418ADALL)) | (l_603 != &l_604)) ^ l_582.f0))) ^ p_43) & 0L);
                    /* statement id: 328 */
                                        (*l_597) = ((uint64_t)p_44 + (uint64_t)18446744073709551613UL);
                    for (p_44 = 0; (p_44 >= 23); p_44 += 3)
                    { /* block id: 332 */
                        union U2 **l_611 = &l_609;
                        (*l_611) = l_609;
                        if ((*l_597))
                            continue;
                        if (p_43)
                            break;
                        if (l_612)
                            break;
                    }
                    if (l_600.f3)
                        goto lbl_613;
                }
                else
                { /* block id: 339 */
                    int32_t l_619 = 5L;
                    union U1 *l_662 = (void*)0;
                    (*l_583) = (void*)0;
                    /* statement id: 340 */
                    assert (l_584 == 0);
                    if (((((int16_t)(-(int64_t)(0L | ((l_619 | p_43) && l_612))) << (int16_t)4) >= ((-(uint32_t)0xB0F8DDCEL) != (((void*)0 != (*l_556)) || ((uint16_t)p_43 >> (uint16_t)(((l_619 || p_43) >= p_43) == p_43))))) == (*l_597)))
                    { /* block id: 341 */
                        (*l_597) = p_43;
                        return p_43;
                    }
                    else
                    { /* block id: 344 */
                        float *l_623 = &l_589;
                        const int32_t l_624 = 1L;
                        (*l_623) = (0x1.4p+1 == p_44);
                        (*l_583) = &l_579;
                        /* statement id: 346 */
                        assert (l_584 == &l_579);
                        if (l_624)
                            break;
                        l_635 = ((int64_t)(((uint64_t)((uint16_t)(l_610.f0 < ((int64_t)l_619 - (int64_t)((int16_t)1L << (int16_t)15))) >> (uint16_t)14) - (uint64_t)0xD9756EE14F3B51DBLL) < 0UL) - (int64_t)p_44);
                    }
                    /* facts after branching */
                    assert (l_584 == &l_579);
                    (*l_583) = (*l_583);
                    if (func_71(p_43, ((*l_597) || p_43), ((((uint32_t)l_612 % (uint32_t)(*l_597)) ^ ((!((uint32_t)l_610.f1 - (uint32_t)(p_44 < p_43))) || __builtin_popcountll((~l_619)))) != p_43)))
                    { /* block id: 351 */
                        uint32_t l_645 = 7UL;
                        float *l_651 = &l_589;
                        (*l_651) = (!(((float)l_645 / (float)(((float)__builtin_ffsll(((((int32_t)l_612 + (int32_t)p_43) >= func_71((0xA36871C2EA10CC8CLL <= p_44), p_44, l_619)) == (l_645 ^ p_43))) / (float)l_650) < l_610.f1)) != 0x1.BEFD94p-87));
                        if (l_610.f1)
                            continue;
                        (*l_597) = (l_652 != l_584);
                    }
                    else
                    { /* block id: 355 */
                        union U2 **l_654 = &l_609;
                        union U1 ****l_658 = &l_556;
                        int32_t l_659 = 0x02632D2EL;
                        (*l_597) = p_43;
                        (*l_652) = (l_654 == (void*)0);
                        l_619 = (((float)p_44 + (float)(((l_657 != l_658) == (l_659 >= (((float)((void*)0 == l_662) + (float)0x5.0E39DBp-94) > 0x9.FDBCB5p+52))) > p_44)) > l_619);
                        (*l_583) = (*l_583);
                    }
                }
                (*l_652) = ((float)l_599.f1 + (float)((float)(p_44 > l_579) / (float)((float)(*l_597) / (float)((p_44 == func_46((*l_603), (((void*)0 != &l_556) | ((uint16_t)((~((int16_t)func_90((__builtin_popcountll((*l_597)) < l_599.f0), (**l_583)) << (int16_t)l_674)) > l_674) << (uint16_t)l_599.f0)), (*l_609), (**l_552), (*l_597))) <= p_44))));
            }
            /* facts after for loop */
                    }
    }
    else
    { /* block id: 365 */
        int32_t *l_675 = &l_580;
        (*l_675) = p_43;
    }
    /* facts after branching */
        //assert (l_584 == dangling || l_584 == &l_580);
    (*l_583) = &l_580;
    /* statement id: 368 */
    assert (l_584 == &l_580);
    (*l_676) = (*l_584);
    if (((int64_t)((uint16_t)((uint64_t)(**l_583) + (uint64_t)1L) << (uint16_t)14) % (int64_t)((*l_584) ^ __builtin_popcount((*l_584)))))
    { /* block id: 370 */
        int32_t *l_684 = &l_580;
        const union U1 *l_695 = (void*)0;
        const union U1 **l_694 = &l_695;
        const union U1 *** const l_693 = &l_694;
lbl_697:
        (*l_684) = 0xDB388F92L;
        if (((uint64_t)__builtin_clzll((*l_584)) % (uint64_t)((uint64_t)8UL + (uint64_t)0xD3366A8991DED383LL)))
        { /* block id: 372 */
            union U1 **l_692 = &l_550;
            union U1 ***l_691 = &l_692;
            int32_t l_696 = 0x2932B401L;
            struct S0 **l_701 = &l_603;
            union U2 l_748 = {0x9C48C49CL};
            union U2 *l_747 = &l_748;
            union U2 **l_749 = &l_747;
            if (((((int64_t)p_43 / (int64_t)p_43) == (l_691 != l_693)) >= l_696))
            { /* block id: 373 */
                int32_t *l_712 = &l_580;
                (*l_684) = ((**l_583) <= l_696);
                if (l_580)
                    goto lbl_697;
                l_696 = (1UL < (-9L));
                if ((((int16_t)0L % (int16_t)__builtin_parityl((~(*l_684)))) == (l_701 != &l_603)))
                { /* block id: 377 */
                    union U2 ****l_702 = (void*)0;
                    union U2 *l_706 = (void*)0;
                    union U2 **l_705 = &l_706;
                    union U2 ***l_704 = &l_705;
                    union U2 ****l_703 = &l_704;
                    int32_t l_715 = 0x9972FAF3L;
                    (*l_703) = (void*)0;
                    /* statement id: 378 */
                    assert (l_704 == 0);
                    for (p_43 = (-6); (p_43 > (-7)); --p_43)
                    { /* block id: 381 */
                        const struct S0 **l_709 = (void*)0;
                        l_709 = (void*)0;
                        if (p_44)
                            continue;
                        return l_696;
                    }
                    for (l_551.f2 = 0; (l_551.f2 >= 54); l_551.f2++)
                    { /* block id: 388 */
                        const uint32_t l_718 = 3UL;
                        (*l_684) = 0L;
                        (*l_583) = l_712;
                        (*l_684) = ((float)(0x2.8B4A64p+54 > (l_715 > ((float)((l_718 >= ((void*)0 == &l_691)) > __builtin_bswap32(((int16_t)0x9AE7L >> (int16_t)11))) - (float)l_696))) / (float)((float)(((*l_684) >= 0x2.7p-1) > 0xE.AD30C9p+0) / (float)l_715));
                        (*l_712) = 0L;
                    }
                    (*l_684) = __builtin_popcountl(p_43);
                }
                else
                { /* block id: 395 */
                    int32_t * const l_727 = &l_696;
                    int32_t **l_741 = (void*)0;
                    l_684 = &l_696;
                    /* statement id: 396 */
                    assert (l_684 == &l_696);
                    for (l_551.f0 = 0; (l_551.f0 == 2); l_551.f0 += 3)
                    { /* block id: 399 */
                        const int64_t l_738 = (-1L);
                        (*l_684) = ((int64_t)(__builtin_ffsll(p_44) && ((&l_696 == l_727) > p_44)) - (int64_t)((uint32_t)__builtin_ffs(p_44) + (uint32_t)((*l_727) <= p_44)));
                        l_696 = 0x25F692CAL;
                        (*l_676) = ((float)__builtin_ffsl(p_43) + (float)((float)0x1.6p+1 + (float)((((float)(*l_684) + (float)p_43) >= 0x4.B07DB6p-17) <= ((float)l_738 / (float)(p_44 <= ((float)(l_696 == p_43) - (float)(*l_727)))))));
                        (*l_583) = l_712;
                    }
                    /* facts after for loop */
                                        l_712 = l_727;
                    /* statement id: 405 */
                    assert (l_712 == &l_696);
                }
                /* facts after branching */
                assert (l_684 == &l_696 || l_684 == &l_580);
                assert (l_712 == &l_696 || l_712 == &l_580);
            }
            else
            { /* block id: 407 */
                int32_t **l_744 = &l_684;
                (*l_684) = ((float)(&l_584 == l_744) / (float)((float)0x3.DBCD45p-70 - (float)(-0x7.9p-1)));
            }
            /* facts after branching */
            assert (l_684 == &l_696 || l_684 == &l_580);
            (*l_749) = l_747;
            (*l_684) = p_44;
            (*l_583) = (*l_583);
        }
        else
        { /* block id: 413 */
            for (l_574 = 0; (l_574 != 16); l_574 += 8)
            { /* block id: 416 */
                if (l_551.f2)
                    goto lbl_697;
            }
            return p_43;
        }
        /* facts after branching */
        //assert (l_684 == dangling || l_684 == &l_580);
    }
    else
    { /* block id: 421 */
        uint32_t l_755 = 0xC13CC2DEL;
        for (l_549 = 0; (l_549 <= (-20)); l_549--)
        { /* block id: 424 */
            struct S0 **l_754 = &l_603;
            const int32_t l_758 = (-1L);
            (*l_754) = &l_604;
            (*l_676) = ((((p_44 >= 0xA.D982A0p-27) <= l_755) == ((float)((l_758 < 0x9.8p+1) > ((-0x1.Cp+1) == (p_44 <= func_46((**l_754), (((uint16_t)((uint64_t)l_755 % (uint64_t)0xCB82769F14144C90LL) << (uint16_t)(**l_583)) <= (**l_583)), l_763, (*l_550), (**l_583))))) + (float)l_755)) <= l_758);
            return p_44;
        }
        (*l_676) = 0x8.620296p-85;
    }
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint64_t  func_46(struct S0  p_47, int16_t  p_48, union U2  p_49, union U1  p_50, uint32_t  p_51)
{ /* block id: 299 */
    int32_t l_546 = (-10L);
    int32_t *l_545 = &l_546;
    int32_t **l_547 = &l_545;
    const int64_t l_548 = 0xA0FE350B81658460LL;
    (*l_547) = l_545;
    return l_548;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_56(int16_t  p_57, int32_t  p_58)
{ /* block id: 40 */
    const uint32_t l_61 = 0x2D493814L;
    union U1 l_80 = {0xA4E7L};
    union U2 l_362 = {4294967288UL};
    struct S0 l_363 = {1};
    int32_t l_544 = (-6L);
    int32_t *l_543 = &l_544;
    (*l_543) = (((((p_58 < ((uint32_t)1UL - (uint32_t)l_61)) != func_62(func_66(func_71(func_75(l_61, l_80, func_81(p_57, ((p_58 != 8UL) > ((int16_t)((l_61 ^ 5L) && 0L) / (int16_t)p_58)), l_80.f2), l_80.f2), l_80.f2, p_57), l_362, l_362, l_363), p_58, l_363)) == p_57) >= 0xEF4DCC81675217F3LL) && (-1L));
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_62(union U1  p_63, uint32_t  p_64, struct S0  p_65)
{ /* block id: 214 */
    int32_t l_379 = 0xEEF02D27L;
    int32_t *l_378 = &l_379;
    int32_t **l_380 = (void*)0;
    int32_t **l_381 = &l_378;
    union U2 l_385 = {1UL};
    union U2 *l_384 = &l_385;
    struct S0 l_513 = {0};
    struct S0 *l_512 = &l_513;
    struct S0 **l_511 = &l_512;
    union U1 l_520 = {0xB2AEL};
    union U1 *l_519 = &l_520;
    const uint64_t l_539 = 0x5E8C950F7E01795FLL;
    float *l_540 = (void*)0;
    (*l_381) = l_378;
    if ((**l_381))
    { /* block id: 216 */
        int32_t l_397 = (-10L);
        int32_t *l_404 = &l_379;
        struct S0 l_416 = {-0};
        struct S0 *l_415 = &l_416;
        uint64_t l_418 = 7UL;
        uint64_t l_468 = 18446744073709551615UL;
        for (p_63.f0 = (-15); (p_63.f0 > 33); p_63.f0 += 7)
        { /* block id: 219 */
            union U2 **l_386 = &l_384;
            int32_t l_400 = (-1L);
            struct S0 **l_451 = &l_415;
            uint8_t l_473 = 253UL;
            (*l_386) = l_384;
        }
    }
    else
    { /* block id: 284 */
        uint8_t l_514 = 0x1EL;
        const int32_t *l_517 = &l_379;
        const int32_t **l_516 = &l_517;
        const int32_t ***l_515 = &l_516;
        uint64_t l_518 = 0x920E2189C1302005LL;
        union U1 **l_521 = &l_519;
        union U2 l_538 = {0xF02209DBL};
        (*l_378) = ((uint16_t)(~(((uint16_t)0xC077L + (uint16_t)(((int16_t)(**l_381) << (int16_t)((uint32_t)p_64 / (uint32_t)(((uint64_t)(((p_63.f0 || ((((void*)0 == l_511) & l_514) | ((void*)0 == l_515))) < 0x62ADL) != l_518) - (uint64_t)p_65.f0) || 0x9D68F9C780D751C8LL))) < p_65.f0)) == 0UL)) << (uint16_t)p_63.f2);
        (*l_521) = l_519;
        (*l_378) = (((int16_t)0L << (int16_t)2) <= p_63.f0);
        (*l_378) = (((int64_t)(~(**l_516)) % (int64_t)((((-1L) <= (!__builtin_ffsll((**l_516)))) <= ((((int16_t)((uint16_t)((uint16_t)0UL / (uint16_t)((uint16_t)func_75((0x8697EFC4L && p_65.f0), func_66(p_63.f0, l_538, (*l_384), p_65), (**l_516), l_539) + (uint16_t)p_63.f0)) / (uint16_t)(**l_381)) >> (int16_t)3) == 0xA8646D64L) >= p_65.f0)) ^ p_65.f0)) <= (-1L));
    }
    (**l_381) = 0x3.Fp-1;
    for (p_63.f0 = (-2); (p_63.f0 <= 55); p_63.f0 += 3)
    { /* block id: 293 */
        return p_65.f0;
    }
    return p_63.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_66(uint16_t  p_67, union U2  p_68, union U2  p_69, struct S0  p_70)
{ /* block id: 209 */
    int32_t l_365 = 1L;
    int32_t *l_364 = &l_365;
    int32_t **l_366 = &l_364;
    union U1 l_377 = {6UL};
    (*l_366) = l_364;
    (*l_364) = ((int16_t)((int32_t)((0x37EAL || p_70.f0) <= ((int16_t)((int16_t)((int16_t)func_90(p_68.f1, p_68.f1) % (int16_t)func_75(p_70.f0, l_377, (*l_364), (**l_366))) - (int16_t)(**l_366)) << (int16_t)13)) / (int32_t)p_68.f1) - (int16_t)p_68.f1);
    (*l_366) = (*l_366);
    return l_377;
    /* statement id: 213 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_71(int32_t  p_72, uint64_t  p_73, uint32_t  p_74)
{ /* block id: 119 */
    float l_219 = (-0x1.3p+1);
    float *l_218 = &l_219;
    union U1 * const **l_232 = (void*)0;
    uint8_t l_235 = 0xFDL;
    union U2 l_243 = {4294967290UL};
    union U2 * const l_242 = &l_243;
    int32_t l_278 = 0xBA27C460L;
    int32_t *l_277 = &l_278;
    int32_t **l_276 = &l_277;
    struct S0 l_357 = {-1};
    struct S0 *l_356 = &l_357;
    (*l_218) = p_73;
    if (p_74)
    { /* block id: 121 */
        struct S0 l_221 = {1};
        struct S0 *l_220 = &l_221;
        struct S0 **l_222 = (void*)0;
        struct S0 **l_223 = &l_220;
        union U1 l_231 = {65535UL};
        union U1 *l_230 = &l_231;
        union U1 **l_229 = &l_230;
        union U1 ***l_228 = &l_229;
        (*l_223) = l_220;
        (*l_218) = (((float)0x0.2p+1 - (float)((float)(l_228 != l_232) + (float)((float)l_235 - (float)l_231.f2))) >= l_235);
        for (l_231.f2 = (-12); (l_231.f2 <= 59); l_231.f2 += 1)
        { /* block id: 126 */
            int32_t l_253 = 1L;
            for (l_235 = (-24); (l_235 < 52); l_235 += 6)
            { /* block id: 129 */
                struct S0 *l_254 = &l_221;
                for (p_72 = 0; (p_72 <= 4); p_72 += 2)
                { /* block id: 132 */
                    union U2 *l_245 = &l_243;
                    union U2 **l_244 = &l_245;
                    const int32_t l_248 = 0x898B9DDCL;
                    (*l_244) = l_242;
                    (*l_218) = func_75(((int64_t)l_235 + (int64_t)((0xE25250D9L | l_248) <= ((uint16_t)(((int64_t)p_73 - (int64_t)(__builtin_ffs(l_253) != l_235)) & 0x5240L) << (uint16_t)p_74))), (*l_230), p_73, p_74);
                    (*l_218) = (l_254 != (void*)0);
                }
                if (p_73)
                    break;
            }
            for (l_235 = (-19); (l_235 <= 11); l_235 += 3)
            { /* block id: 141 */
                if (l_231.f2)
                    break;
            }
        }
        /* facts after for loop */
            }
    else
    { /* block id: 145 */
        int32_t l_258 = 6L;
        int32_t *l_257 = &l_258;
        int32_t **l_259 = &l_257;
        union U1 l_263 = {0xA66BL};
        (*l_257) = l_243.f1;
lbl_294:
        (*l_259) = &p_72;
        /* statement id: 147 */
        assert (l_257 == &p_72);
        (*l_259) = (void*)0;
        /* statement id: 148 */
        assert (l_257 == 0);
        for (p_73 = 0; (p_73 < 25); p_73 += 1)
        { /* block id: 151 */
            uint32_t l_262 = 4294967295UL;
            union U1 ** const *l_301 = (void*)0;
            uint32_t l_307 = 0UL;
            struct S0 *l_358 = &l_357;
            (*l_218) = (func_81(p_74, func_75(l_262, l_263, ((float)p_74 + (float)(((float)(((float)(-(float)__builtin_bswap32((!p_73))) / (float)(l_243.f0 >= 0x1.A59ADAp-43)) == ((float)((-0x1.8p+1) <= l_262) / (float)p_73)) / (float)p_72) <= l_262)), p_74), p_73) < 0x6.7CB99Ap+9);
            if (((((int64_t)((void*)0 == l_276) - (int64_t)p_72) ^ ((int64_t)(+(((int16_t)((uint16_t)((int32_t)((uint16_t)((((int32_t)((*l_277) & ((void*)0 != &p_72)) - (int32_t)(p_72 <= (__builtin_ffsl(p_74) & p_73))) > (-9L)) || p_73) << (uint16_t)10) - (int32_t)l_262) % (uint16_t)p_72) - (int16_t)p_73) | l_263.f0)) - (int64_t)0x0D40F6A6AC0F502BLL)) == p_72))
            { /* block id: 153 */
                const int32_t l_308 = 0L;
                int32_t l_318 = 0x5E293B49L;
                if (l_235)
                    goto lbl_294;
                for (l_262 = 19; (l_262 != 43); l_262 += 2)
                { /* block id: 157 */
                    uint16_t l_306 = 0UL;
                    uint32_t l_311 = 0x079E5195L;
                    int32_t l_314 = (-1L);
                    if ((p_73 == ((uint32_t)((65535UL == 0x2380L) != (**l_276)) - (uint32_t)((uint16_t)(((l_301 != l_301) >= (((uint32_t)__builtin_parity(l_262) + (uint32_t)((int16_t)((l_306 && l_307) || l_308) / (int16_t)7L)) == p_73)) >= p_73) >> (uint16_t)8))))
                    { /* block id: 158 */
                        (**l_276) = __builtin_ffs((((uint16_t)l_311 << (uint16_t)0) < ((!(+1UL)) != 0x34755115L)));
                        l_314 = l_308;
                        (*l_277) = (__builtin_popcountll(__builtin_clzl(l_262)) || (((int16_t)l_308 >> (int16_t)4) & ((((~__builtin_ffs(p_72)) >= p_74) | (p_73 <= p_74)) & (-9L))));
                        if (l_262)
                            continue;
                    }
                    else
                    { /* block id: 163 */
                        l_318 = p_73;
                    }
                    if (p_74)
                        break;
                }
            }
            else
            { /* block id: 168 */
                int32_t *l_319 = &l_278;
                struct S0 l_336 = {0};
                struct S0 *l_335 = &l_336;
                int16_t l_340 = (-10L);
                union U2 **l_341 = (void*)0;
                int32_t l_353 = (-1L);
                (**l_276) = (l_319 == &p_72);
                for (l_307 = 22; (l_307 > 49); l_307 += 5)
                { /* block id: 172 */
                    return p_72;
                }
                if (((uint16_t)p_72 + (uint16_t)l_307))
                { /* block id: 175 */
                    float l_332 = 0xF.C41774p+14;
                    if ((p_73 < (&l_263 != (void*)0)))
                    { /* block id: 176 */
                        (*l_259) = &p_72;
                        /* statement id: 177 */
                        assert (l_257 == &p_72);
                    }
                    else
                    { /* block id: 178 */
                        uint32_t l_325 = 18446744073709551608UL;
                        struct S0 l_334 = {0};
                        struct S0 *l_333 = &l_334;
                        p_72 = (-(int64_t)l_325);
                        (**l_276) = ((((((int16_t)0x39D7L << (int16_t)(((void*)0 == &l_257) && ((uint32_t)p_73 / (uint32_t)p_72))) & 0xBC78BEF385434852LL) & ((int64_t)(-4L) % (int64_t)p_72)) ^ __builtin_ffsl(p_72)) & 0xC2E1771478F816ECLL);
                        (**l_276) = (p_73 == 0UL);
                        l_335 = l_333;
                        /* statement id: 182 */
                        assert (l_335 == &l_334);
                    }
                    /* facts after branching */
                    assert (l_257 == 0 || l_257 == &p_72);
                    //assert (l_335 == dangling || l_335 == &l_336);
                    (*l_259) = (void*)0;
                    /* statement id: 184 */
                    assert (l_257 == 0);
                }
                else
                { /* block id: 185 */
                    int32_t *l_339 = &l_278;
                    for (l_262 = 0; (l_262 >= 22); l_262 += 8)
                    { /* block id: 188 */
                        union U2 ***l_342 = &l_341;
                        (*l_277) = (l_262 <= ((l_339 != (void*)0) >= l_340));
                        (*l_342) = l_341;
                        (*l_276) = &p_72;
                        /* statement id: 191 */
                        assert (l_277 == &p_72);
                        (*l_319) = ((int16_t)7L >> (int16_t)13);
                    }
                }
                /* facts after branching */
                //assert (l_335 == dangling || l_335 == &l_336);
                for (l_235 = (-28); (l_235 < 18); ++l_235)
                { /* block id: 197 */
                    for (p_72 = 19; (p_72 != (-16)); p_72 -= 5)
                    { /* block id: 200 */
                        uint32_t l_361 = 18446744073709551615UL;
                        (*l_218) = ((float)p_74 - (float)(((float)0x1.Ep+1 / (float)l_353) == (((**l_276) != ((float)(p_74 == (l_356 != l_358)) - (float)p_72)) < ((float)0x0.Cp-1 / (float)l_361))));
                        if ((**l_276))
                            break;
                    }
                }
            }
        }
    }
    /* facts after branching */
    assert (l_277 == &p_72 || l_277 == &l_278);
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_75(uint32_t  p_76, union U1  p_77, float  p_78, const uint8_t  p_79)
{ /* block id: 116 */
    union U1 l_217 = {0xD500L};
    union U1 *l_216 = &l_217;
    union U1 **l_215 = &l_216;
    union U1 ***l_214 = &l_215;
    union U1 ****l_213 = &l_214;
    (*l_213) = (void*)0;
    /* statement id: 117 */
    assert (l_214 == 0);
    return p_79;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_81(uint8_t  p_82, uint16_t  p_83, int64_t  p_84)
{ /* block id: 41 */
    uint16_t l_89 = 65535UL;
    const uint32_t l_98 = 0xE6AF5756L;
    int32_t l_101 = (-3L);
    int32_t *l_100 = &l_101;
    struct S0 l_156 = {-0};
    struct S0 *l_155 = &l_156;
    union U2 *l_158 = (void*)0;
    union U1 l_175 = {0x27D2L};
    union U1 *l_174 = &l_175;
    union U1 **l_173 = &l_174;
    int32_t *l_211 = &l_101;
    uint64_t l_212 = 1UL;
    l_89 = ((uint16_t)(65535UL < 0x0181L) << (uint16_t)1);
lbl_191:
    if (((func_90((+((l_89 & (18446744073709551614UL != (p_82 == ((4294967295UL <= p_84) == l_89)))) == (0xD09421A0E57C1F20LL < ((int32_t)p_84 + (int32_t)l_89)))), l_98) <= 0x88327BC4A6B1F15FLL) < l_98))
    { /* block id: 45 */
        int32_t **l_102 = (void*)0;
        const int32_t *l_104 = (void*)0;
        const int32_t **l_103 = &l_104;
        union U1 l_148 = {2UL};
        union U1 *l_147 = &l_148;
        union U1 * const *l_146 = &l_147;
        (*l_103) = l_100;
        /* statement id: 46 */
        assert (l_104 == &l_101);
        if (((((*l_100) ^ (((uint64_t)(0xCE79L != (((int16_t)func_90((&l_100 != (void*)0), p_84) >> (int16_t)((*l_103) == (void*)0)) & (*l_100))) - (uint64_t)0x82577C8A60B10F65LL) ^ (**l_103))) == 1UL) || 0x6835L))
        { /* block id: 47 */
            int32_t l_112 = 0x0880F5C6L;
            int32_t l_119 = 0x6A71534BL;
            float l_141 = 0x4.7123A7p-7;
            float *l_140 = &l_141;
            union U1 * const l_149 = &l_148;
            if (__builtin_clz(((int16_t)0x173BL >> (int16_t)(func_90((!0UL), (*l_100)) != func_90(l_112, (((int16_t)((int32_t)(p_82 > 0xBA90DD06L) % (int32_t)(+(!__builtin_clz(l_119)))) << (int16_t)8) ^ p_82))))))
            { /* block id: 48 */
                int32_t *l_122 = &l_112;
                for (l_101 = 0; (l_101 <= 2); l_101++)
                { /* block id: 51 */
                    return p_84;
                }
                l_122 = &l_101;
                /* statement id: 54 */
                assert (l_122 == &l_101);
            }
            else
            { /* block id: 55 */
                union U1 l_124 = {0x23BAL};
                union U1 *l_123 = &l_124;
                union U1 **l_125 = (void*)0;
                union U1 **l_126 = &l_123;
                (*l_126) = l_123;
                for (p_83 = 0; (p_83 <= 25); ++p_83)
                { /* block id: 59 */
                    int64_t l_131 = 0x5C78ED0E11B63BBBLL;
                    int32_t **l_132 = &l_100;
                    (*l_100) = func_90(((uint16_t)l_131 << (uint16_t)(p_83 != (&l_104 != l_132))), p_83);
                    (*l_103) = &l_101;
                    return p_82;
                }
            }
            (*l_140) = ((float)((__builtin_bswap32((*l_100)) <= ((float)((-(float)((float)0x0.2p+1 - (float)p_83)) >= p_82) - (float)(*l_100))) < (((*l_100) != (*l_100)) < p_83)) - (float)p_82);
            l_112 = ((float)((-0x1.Fp+1) == ((float)(l_146 != (void*)0) - (float)func_90(l_112, p_82))) / (float)(l_112 != ((void*)0 == l_149)));
        }
        else
        { /* block id: 67 */
            float *l_152 = (void*)0;
            float l_154 = (-0x5.0p+1);
            float *l_153 = &l_154;
            (*l_153) = ((float)p_82 / (float)p_83);
        }
    }
    else
    { /* block id: 70 */
        struct S0 **l_157 = &l_155;
        union U2 **l_159 = (void*)0;
        union U2 **l_160 = (void*)0;
        union U2 **l_161 = &l_158;
        const int32_t *l_162 = &l_101;
        int32_t **l_163 = &l_100;
        (*l_157) = l_155;
        if (l_101)
            goto lbl_164;
        (*l_161) = l_158;
lbl_164:
        (*l_163) = l_162;
        if (((**l_163) <= ((*l_100) ^ p_83)))
        { /* block id: 75 */
            float l_166 = 0xA.7FA911p+60;
            float *l_165 = &l_166;
            int32_t l_169 = 1L;
            (*l_163) = (*l_163);
            (*l_165) = p_83;
            for (l_89 = 29; (l_89 <= 3); l_89 -= 2)
            { /* block id: 80 */
                (*l_163) = (void*)0;
                /* statement id: 81 */
                assert (l_100 == 0);
                return l_169;
            }
        }
        else
        { /* block id: 84 */
            return p_83;
        }
    }
    if ((((int16_t)(+(*l_100)) << (int16_t)((void*)0 != l_173)) > ((*l_100) ^ ((((*l_100) ^ (l_158 != l_158)) ^ ((((uint16_t)p_82 << (uint16_t)0) == (((uint64_t)((int64_t)p_82 / (int64_t)p_84) - (uint64_t)p_83) | 0L)) > 18446744073709551606UL)) ^ 1L))))
    { /* block id: 88 */
        int32_t *l_194 = (void*)0;
        if (p_83)
        { /* block id: 89 */
            int32_t *l_184 = &l_101;
            int32_t **l_192 = &l_100;
            float *l_193 = (void*)0;
            for (l_89 = 0; (l_89 >= 47); l_89 += 3)
            { /* block id: 92 */
                int32_t **l_185 = &l_100;
                float *l_187 = (void*)0;
                float l_189 = 0x1.Ep-1;
                float *l_188 = &l_189;
                (*l_185) = l_184;
                (*l_188) = (-(float)p_84);
                (*l_100) = ((+__builtin_clzll(p_82)) | p_84);
                if (p_84)
                    goto lbl_191;
            }
            (*l_192) = &l_101;
            (*l_184) = p_83;
        }
        else
        { /* block id: 100 */
            int32_t **l_195 = (void*)0;
            int32_t **l_196 = &l_100;
            const int32_t **l_201 = (void*)0;
            int32_t l_202 = 0L;
            (*l_196) = l_194;
            /* statement id: 101 */
            assert (l_100 == 0);
            l_202 = (__builtin_ia32_crc32qi(p_84, ((int16_t)p_83 << (int16_t)5)) ^ func_90(((int64_t)(((void*)0 != l_201) != p_82) + (int64_t)(p_84 <= ((&l_158 == &l_158) >= 0x7BD3L))), p_83));
        }
        /* facts after branching */
        assert (l_100 == 0 || l_100 == &l_101);
    }
    else
    { /* block id: 104 */
        int32_t **l_203 = (void*)0;
        int32_t **l_204 = &l_100;
        union U2 l_206 = {0UL};
        const union U2 *l_205 = &l_206;
        float l_208 = 0x1.2p-1;
        float *l_207 = &l_208;
        (*l_204) = &l_101;
        (*l_207) = ((*l_100) != ((void*)0 != l_205));
        for (p_84 = 5; (p_84 == (-1)); p_84 -= 9)
        { /* block id: 109 */
            (*l_100) = p_84;
        }
        (*l_204) = (*l_204);
    }
    /* facts after branching */
    assert (l_100 == 0 || l_100 == &l_101);
    (*l_211) = 6L;
    return l_212;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint64_t  func_90(uint16_t  p_91, const uint32_t  p_92)
{ /* block id: 43 */
    const int32_t l_99 = (-7L);
    return l_99;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_36();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 159
   depth: 1, occurrence: 4
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 40
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 16
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 3
XXX full-bitfields structs in the program: 4
breakdown:
   indirect level: 0, occurrence: 4
XXX times a bitfields struct's address is taken: 23
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 36
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 30

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 233
   depth: 2, occurrence: 40
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 3
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 6
   depth: 14, occurrence: 6
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 161

XXX times a variable address is taken: 154
XXX times a pointer is dereferenced on RHS: 91
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 27
XXX times a pointer is dereferenced on LHS: 123
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 9
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 256

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 207
   level: 2, occurrence: 53
XXX number of pointers point to pointers: 75
XXX number of pointers point to scalars: 53
XXX number of pointers point to structs: 13
XXX percent of pointers has null in alias set: 26.1
XXX average alias set size: 1.1

XXX times a non-volatile is read: 790
XXX times a non-volatile is write: 303
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 7

XXX stmts: 205
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 35
   depth: 2, occurrence: 33
   depth: 3, occurrence: 32
   depth: 4, occurrence: 29
   depth: 5, occurrence: 44

XXX percentage a fresh-made variable is used: 23.5
XXX percentage an existing variable is used: 76.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

