/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      598055976
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint16_t  f1;
   int32_t  f2;
   const int64_t  f3;
   const uint8_t  f4;
};

union U1 {
   float  f0;
   int32_t  f1;
};

union U2 {
   const signed f0 : 21;
   int16_t  f1;
   float  f2;
   float  f3;
   const struct S0  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_28(void);
static int32_t  func_32(uint16_t  p_33);
inline static int32_t  func_36(int32_t  p_37, int32_t * p_38);
static int32_t * func_39(int32_t * const  p_40, int64_t  p_41, int16_t  p_42, int32_t * p_43);
static int32_t * func_44(int32_t * p_45, int32_t * p_46, uint32_t  p_47, uint32_t  p_48, int32_t * p_49);
inline static int64_t  func_56(union U2  p_57, int32_t * p_58, int32_t  p_59);
static int32_t * func_61(const uint16_t  p_62, uint32_t  p_63, int16_t  p_64);
inline static int32_t * func_65(int32_t * p_66, uint32_t  p_67);
static float  func_77(int32_t * p_78, int32_t * p_79, union U2  p_80, struct S0  p_81, const int32_t  p_82);
static int16_t  func_94(uint32_t  p_95, union U2  p_96, struct S0  p_97);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = (-4L);
    uint8_t l_779 = 1UL;
    int32_t l_804 = 1L;
    union U1 l_806 = {-0x3.6p-1};
    union U1 *l_805 = &l_806;
    int32_t *l_809 = &l_806.f1;
    uint32_t l_810 = 4294967291UL;
lbl_802:
    for (l_29 = 0; (l_29 < 5); l_29 += 1)
    { /* block id: 39 */
        int32_t l_736 = (-7L);
        int32_t *l_735 = &l_736;
        uint64_t l_737 = 0xD850147081E457E4LL;
        union U2 l_743 = {-2L};
        union U2 *l_742 = &l_743;
        union U2 * const *l_741 = &l_742;
        int64_t l_749 = 0xC0ADF977407307C6LL;
        struct S0 *l_764 = (void*)0;
        (*l_735) = func_32(l_29);
        if (l_737)
        { /* block id: 372 */
            union U2 l_740 = {1L};
            union U2 *l_739 = &l_740;
            union U2 **l_738 = &l_739;
            float *l_744 = &l_740.f3;
            int32_t **l_745 = &l_735;
            (*l_744) = (l_738 == l_741);
            /* statement id: 373 */
                        (*l_745) = l_744;
            /* statement id: 374 */
            assert (l_735 == &l_740.f3);
        }
        else
        { /* block id: 375 */
            union U2 l_746 = {0L};
            uint64_t l_787 = 0x3F6ED807253A289FLL;
            int32_t **l_792 = (void*)0;
            int32_t ***l_791 = &l_792;
            if (func_56(l_746, &l_736, ((uint16_t)(*l_735) + (uint16_t)l_749)))
            { /* block id: 376 */
                uint8_t l_753 = 0xD0L;
                for (l_737 = 0; (l_737 > 26); l_737 += 1)
                { /* block id: 379 */
                    uint32_t l_752 = 7UL;
                    (*l_735) = l_752;
                    return l_752;
                }
                l_735 = &l_736;
                return l_753;
            }
            else
            { /* block id: 385 */
                float *l_768 = &l_746.f3;
                int32_t l_786 = 6L;
                for (l_749 = 1; (l_749 == 1); l_749++)
                { /* block id: 388 */
                    float l_758 = 0x0.CFD4E7p+15;
                    int32_t l_762 = 0L;
                    for (l_736 = 17; (l_736 >= 20); l_736++)
                    { /* block id: 391 */
                        float *l_763 = &l_746.f3;
                        struct S0 **l_765 = &l_764;
                        float * const *l_767 = &l_763;
                        float * const **l_766 = &l_767;
                        (*l_763) = ((l_758 >= (-(float)(-0x1.2p+1))) == ((float)0x0.EE7278p-64 - (float)l_762));
                        /* statement id: 392 */
                                                (*l_765) = l_764;
                        (*l_766) = (void*)0;
                        /* statement id: 394 */
                        assert (l_767 == 0);
                    }
                }
                (*l_768) = 0x6.858815p-4;
                /* statement id: 397 */
                                if (((*l_735) <= ((int32_t)func_36(((uint64_t)((int64_t)(((uint16_t)(((int64_t)l_779 - (int64_t)(*l_735)) >= ((((((uint32_t)((l_779 > (((int16_t)(*l_735) << (int16_t)__builtin_clzl(__builtin_bswap64((((int16_t)(func_32((0L != ((l_29 ^ (*l_735)) < l_786))) ^ 0x3C6BA643E9282C6ELL) >> (int16_t)(*l_735)) & (-2L))))) == 0xE01946F3L)) ^ l_746.f1) % (uint32_t)(*l_735)) > l_746.f1) == (*l_735)) <= (*l_735)) | l_786)) >> (uint16_t)0) <= (*l_735)) - (int64_t)(*l_735)) % (uint64_t)1UL), &l_786) - (int32_t)l_787)))
                { /* block id: 398 */
                    if (l_786)
                        break;
                    if (l_746.f1)
                        break;
                    for (l_786 = 0; (l_786 > 7); l_786 += 7)
                    { /* block id: 403 */
                        struct S0 **l_790 = &l_764;
                        (*l_790) = (void*)0;
                        (*l_735) = ((void*)0 == l_791);
                    }
                }
                else
                { /* block id: 407 */
                    const struct S0 **l_795 = (void*)0;
                    int32_t l_796 = 1L;
                    (*l_735) = ((int32_t)(l_795 != l_795) - (int32_t)func_32(l_796));
                    (*l_768) = 0x4.1CD983p+10;
                }
            }
            /* facts after branching */
                        l_735 = &l_29;
            /* statement id: 412 */
            assert (l_735 == &l_29);
        }
        /* facts after branching */
        //assert (l_735 == &l_29 || l_735 == dangling);
    }
    for (l_29 = 18; (l_29 == 18); l_29 += 4)
    { /* block id: 417 */
        int32_t l_801 = 0xB92E3AF4L;
        const union U1 *l_808 = (void*)0;
        const union U1 **l_807 = &l_808;
        for (l_779 = 0; (l_779 < 38); ++l_779)
        { /* block id: 420 */
            if (l_801)
                break;
        }
        if (l_801)
            goto lbl_802;
        l_804 = (!0x1.Dp-1);
        (*l_807) = l_805;
        /* statement id: 425 */
        assert (l_808 == &l_806);
    }
    (*l_809) = (65529UL && 2L);
    /* statement id: 427 */
        return l_810;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_32(uint16_t  p_33)
{ /* block id: 40 */
    int32_t l_35 = (-1L);
    int32_t *l_34 = &l_35;
    uint64_t l_427 = 0x409158814E8A97BBLL;
    int32_t *l_616 = &l_35;
    union U2 l_628 = {1L};
    int64_t l_675 = 1L;
    struct S0 l_682 = {0xAA4664BDL,0xDBF2L,-1L,-9L,0xC9L};
    int32_t l_733 = (-1L);
    (*l_34) = p_33;
    if (p_33)
    { /* block id: 42 */
        int32_t *l_50 = &l_35;
        union U2 l_60 = {9L};
        int32_t **l_617 = (void*)0;
        int32_t **l_618 = &l_34;
        (*l_50) = func_36(p_33, func_39(func_44(l_50, &l_35, (*l_34), (-(uint64_t)(*l_34)), l_50), func_56(l_60, func_61(p_33, (*l_50), (*l_50)), p_33), l_427, &l_35));
        (*l_618) = func_61((((uint16_t)(p_33 | ((((*l_34) | 0xAE79BE78L) == (((uint16_t)((p_33 ^ (0x6CAAL != (func_56(l_60, l_616, (*l_616)) < 0UL))) >= (*l_50)) - (uint16_t)p_33) ^ (*l_50))) | 0xEFF9L)) << (uint16_t)6) < (*l_50)), p_33, p_33);
        /* statement id: 309 */
        assert (l_34 == 0);
    }
    else
    { /* block id: 310 */
        int32_t l_619 = 0xE1E5A442L;
        struct S0 l_629 = {0x5298B4E3L,0x47DFL,0xBA116024L,0x724FF903EC2F4BA8LL,255UL};
        float *l_630 = &l_628.f2;
        int16_t l_637 = 0x00C1L;
        int32_t **l_644 = &l_616;
        uint32_t l_649 = 4294967295UL;
        int16_t l_657 = 1L;
        struct S0 **l_665 = (void*)0;
        struct S0 ***l_664 = &l_665;
        struct S0 ****l_663 = &l_664;
        (*l_630) = ((l_619 <= (((float)0xF.D83AC8p-32 / (float)((float)(p_33 != (p_33 < 0x8.D66985p-64)) + (float)p_33)) > ((float)(((float)((void*)0 != l_34) / (float)func_94(p_33, l_628, l_629)) < p_33) + (float)l_629.f2))) != l_629.f4);
        /* statement id: 311 */
                (*l_644) = func_61(p_33, ((uint16_t)p_33 << (uint16_t)((uint16_t)0xBCD4L / (uint16_t)((int16_t)__builtin_ffs(l_637) - (int16_t)(0UL && (((uint16_t)((int16_t)(l_629.f2 > (p_33 < ((int16_t)(*l_34) >> (int16_t)p_33))) / (int16_t)p_33) << (uint16_t)6) == p_33))))), p_33);
        /* statement id: 312 */
        assert (l_616 == 0);
        for (l_628.f1 = 0; (l_628.f1 >= (-19)); l_628.f1 -= 1)
        { /* block id: 315 */
            int64_t l_652 = 0xFD5BAA61934FB258LL;
            float l_659 = 0xB.E8B36Fp-64;
            float *l_658 = &l_659;
            struct S0 **l_662 = (void*)0;
            struct S0 ***l_661 = &l_662;
            struct S0 ****l_660 = &l_661;
            int64_t l_687 = 0x9C2E319DAB429649LL;
            (*l_34) = p_33;
            (*l_658) = (p_33 > (((float)p_33 + (float)((p_33 != p_33) < (l_649 <= 0xD.8B4661p+43))) >= (((float)l_652 / (float)0xD.980F64p+5) <= (((float)(((float)0xE.6BF1FCp+49 / (float)p_33) != p_33) / (float)0x1.8p+1) >= l_657))));
            (*l_34) = ((l_660 != l_663) | ((uint16_t)p_33 + (uint16_t)p_33));
            if (l_652)
            { /* block id: 319 */
                union U2 *l_669 = &l_628;
                union U2 **l_668 = &l_669;
                int32_t l_672 = 0x730A7747L;
                (*l_668) = (void*)0;
                /* statement id: 320 */
                assert (l_669 == 0);
                (*l_34) = ((((int16_t)l_652 >> (int16_t)8) != func_94((l_652 & (((l_672 < l_672) != ((uint16_t)l_675 / (uint16_t)((int16_t)(((int16_t)p_33 - (int16_t)(18446744073709551612UL != (((int16_t)p_33 >> (int16_t)1) > p_33))) != l_672) % (int16_t)0xBCFEL))) | 1UL)), l_628, l_682)) && (*l_34));
            }
            else
            { /* block id: 322 */
                uint32_t l_692 = 0UL;
                for (l_427 = 0; (l_427 <= 38); l_427 += 8)
                { /* block id: 325 */
                    return p_33;
                }
                for (l_629.f2 = 0; (l_629.f2 > (-9)); l_629.f2 -= 1)
                { /* block id: 330 */
                    union U1 *l_688 = (void*)0;
                    const union U1 l_691 = {0x1.Ap-1};
                    const union U1 *l_690 = &l_691;
                    const union U1 **l_689 = &l_690;
                    if (l_687)
                        break;
                    (*l_689) = l_688;
                    /* statement id: 332 */
                    assert (l_690 == 0);
                    (*l_34) = l_692;
                }
                for (l_619 = (-21); (l_619 > 29); l_619 += 7)
                { /* block id: 337 */
                    if (p_33)
                    { /* block id: 338 */
                        (*l_644) = (void*)0;
                    }
                    else
                    { /* block id: 340 */
                        union U2 *l_695 = &l_628;
                        union U2 **l_696 = &l_695;
                        (*l_696) = l_695;
                        if (p_33)
                            break;
                    }
                }
                (*l_658) = p_33;
            }
        }
        /* facts after for loop */
            }
    /* facts after branching */
    assert (l_34 == &l_35 || l_34 == 0);
    assert (l_616 == 0 || l_616 == &l_35);
        if ((((((int32_t)(~(((int16_t)p_33 - (int16_t)(__builtin_bswap32(p_33) > p_33)) >= (((int32_t)(p_33 < p_33) + (int32_t)(&l_35 == (void*)0)) & ((uint32_t)l_427 % (uint32_t)7L)))) + (int32_t)0xE9B2C0ABL) || p_33) < 0x7D897F35L) && 2UL))
    { /* block id: 349 */
        int32_t **l_706 = &l_616;
        (*l_706) = &l_35;
        /* statement id: 350 */
        assert (l_616 == &l_35);
    }
    else
    { /* block id: 351 */
        const int32_t l_718 = (-1L);
        int32_t *l_726 = &l_35;
        if (l_682.f4)
        { /* block id: 352 */
            int32_t *l_715 = &l_35;
            union U2 l_716 = {3L};
            struct S0 l_717 = {-8L,0xE887L,0xB0AC0643L,0x3D630D455A48FA41LL,249UL};
            const union U2 *l_720 = &l_716;
            const union U2 * const *l_719 = &l_720;
            float *l_721 = (void*)0;
            float *l_722 = &l_628.f2;
            (*l_722) = ((float)((float)((float)((float)func_77(l_715, l_715, l_716, l_717, (*l_715)) + (float)(l_718 > p_33)) / (float)((void*)0 == l_719)) / (float)(-0x1.6p+1)) - (float)l_718);
            /* statement id: 353 */
                        return p_33;
        }
        else
        { /* block id: 355 */
            for (l_675 = 0; (l_675 > (-29)); l_675 -= 1)
            { /* block id: 358 */
                float *l_725 = &l_628.f3;
                (*l_725) = ((-0x3.Ep-1) <= (l_718 < l_718));
                /* statement id: 359 */
                            }
            (*l_726) = ((l_726 == &l_35) > 0x5477A54CL);
        }
    }
    if (p_33)
    { /* block id: 364 */
        return p_33;
    }
    else
    { /* block id: 366 */
        int32_t *l_727 = (void*)0;
        int32_t **l_728 = &l_616;
        struct S0 l_732 = {0L,65535UL,0x002BA7AAL,-9L,255UL};
        int32_t *l_734 = &l_35;
        (*l_728) = l_727;
        /* statement id: 367 */
        assert (l_616 == 0);
        (*l_734) = ((int64_t)(!0L) + (int64_t)(func_94(p_33, l_628, l_732) < ((0xAE6D1EB2E24CA425LL == (func_94(l_733, l_628, l_682) > p_33)) != (-4L))));
    }
    /* facts after branching */
    assert (l_616 == 0);
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_36(int32_t  p_37, int32_t * p_38)
{ /* block id: 246 */
    union U2 l_460 = {1L};
    int32_t *l_465 = (void*)0;
    int32_t **l_464 = &l_465;
    int32_t ***l_463 = &l_464;
    int32_t ****l_462 = &l_463;
    union U2 l_467 = {-1L};
    float **l_476 = (void*)0;
    int32_t l_514 = 0xC6DBBE11L;
    union U1 l_526 = {0x0.84EC2Ap+15};
    union U1 *l_525 = &l_526;
    union U1 **l_524 = &l_525;
    union U2 *l_600 = &l_467;
    uint16_t l_607 = 0x8103L;
    struct S0 l_609 = {0xC4297A5FL,0x6ADEL,0xE863DC85L,-8L,3UL};
    struct S0 *l_608 = &l_609;
    struct S0 **l_610 = &l_608;
    int64_t l_611 = 0x38500FCC9972FAF3LL;
    for (p_37 = 0; (p_37 != (-4)); --p_37)
    { /* block id: 249 */
        struct S0 l_461 = {-6L,0x209DL,0x0E4E1D57L,0x44C8F225E8C950F7LL,0x01L};
        struct S0 ***l_485 = (void*)0;
        int32_t l_494 = 0x67B714C4L;
        int32_t *l_493 = &l_494;
        union U2 *l_539 = &l_467;
        union U2 **l_538 = &l_539;
        union U2 ***l_537 = &l_538;
        int32_t *l_556 = &l_494;
        int32_t ***l_560 = &l_464;
        if ((((0L != ((uint16_t)((uint64_t)p_37 / (uint64_t)((p_37 >= ((int16_t)func_94(p_37, l_460, l_461) << (int16_t)(__builtin_parity((((void*)0 == l_462) > p_37)) & 0x1675217F3F56BA5DLL))) ^ l_461.f3)) << (uint16_t)l_461.f4)) != 0x6E82DC942D0C8C62LL) && l_461.f3))
        { /* block id: 250 */
            int32_t l_466 = (-3L);
            union U2 *l_472 = &l_467;
            if (l_466)
                break;
            if (((0x8915A19D07E729D3LL | (l_461.f4 > p_37)) || ((func_56(l_467, (**l_463), ((uint16_t)(p_37 && (l_466 != (p_37 <= ((((65529UL || p_37) < l_466) | p_37) == 0L)))) << (uint16_t)4)) ^ 65535UL) < l_461.f4)))
            { /* block id: 252 */
                union U2 * const l_473 = &l_460;
                const int32_t l_486 = 0x8B5F7B8FL;
                float *l_505 = &l_467.f2;
                (***l_462) = func_61(p_37, __builtin_clz((l_472 != l_473)), ((int32_t)(l_461.f0 < ((((((void*)0 == l_476) > ((uint16_t)((int16_t)p_37 + (int16_t)((uint32_t)((int16_t)((l_485 != (void*)0) < l_486) << (int16_t)7) - (uint32_t)p_37)) >> (uint16_t)l_461.f1)) && l_486) <= p_37) < (*p_38))) / (int32_t)0x0ED5610DL));
                (*l_505) = ((float)0x4.F15BD0p+45 / (float)((float)0x1.Ap+1 - (float)((l_466 == (((float)(((l_493 != (void*)0) >= p_37) < ((float)(+0x7.B158A9p+93) + (float)p_37)) + (float)((((float)((float)((float)(-(float)0x3.38C168p+25) - (float)l_466) / (float)0x0.8p+1) + (float)l_486) == 0x1.9p+1) == (-0x10.Ep-1))) == p_37)) < 0x1.Dp+1)));
                /* statement id: 254 */
                                if ((*p_38))
                    continue;
            }
            else
            { /* block id: 256 */
                union U2 **l_506 = &l_472;
                union U2 ***l_507 = &l_506;
                int32_t *l_512 = &l_494;
                struct S0 l_513 = {0xB7B6F859L,0UL,0xE01941D8L,1L,0UL};
                float *l_517 = &l_467.f3;
                (*l_507) = l_506;
                (*l_517) = ((float)((float)(*l_493) / (float)p_37) - (float)(l_514 >= ((float)((*l_493) >= (*l_512)) / (float)0x4.F3F254p-77)));
                /* statement id: 258 */
                                for (l_514 = 0; (l_514 < (-29)); l_514 -= 8)
                { /* block id: 261 */
                    uint64_t l_529 = 6UL;
                    int32_t *l_530 = &l_526.f1;
                    (*l_512) = ((int16_t)(((((((((&l_494 == (void*)0) < __builtin_parityll(l_466)) | (l_524 != (void*)0)) < (((uint32_t)l_529 % (uint32_t)l_529) > p_37)) ^ p_37) >= 8L) && 0UL) > l_466) != p_37) >> (int16_t)10);
                    if (__builtin_popcountl(p_37))
                    { /* block id: 263 */
                        uint8_t l_536 = 0x62L;
                        (*p_38) = (func_56((***l_507), func_65(l_530, (*l_512)), (*p_38)) != (__builtin_clzl(((int16_t)__builtin_ctzl((((uint16_t)l_466 << (uint16_t)12) && (-(uint64_t)l_536))) / (int16_t)p_37)) && 0L));
                        /* statement id: 264 */
                                                (*p_38) = (&l_506 == l_537);
                    }
                    else
                    { /* block id: 266 */
                        (*l_512) = (*p_38);
                    }
                    /* facts after branching */
                                    }
                return (*p_38);
            }
            /* facts after branching */
                    }
        else
        { /* block id: 272 */
            uint8_t l_542 = 9UL;
            (*l_464) = &l_494;
            /* statement id: 273 */
            assert (l_465 == &l_494);
        }
        /* facts after branching */
        assert (l_465 == &l_494 || l_465 == 0);
        for (l_526.f1 = (-9); (l_526.f1 != 2); l_526.f1++)
        { /* block id: 277 */
            union U2 l_553 = {1L};
            struct S0 l_554 = {0xEB235EAFL,1UL,-3L,0x256F05E9FD722CDDLL,0xEFL};
            int32_t *l_564 = (void*)0;
        }
        /* facts after for loop */
                if ((*p_38))
            break;
        //assert (l_465 == dangling || l_465 == 0);
        (**l_560) = func_61(((uint16_t)((p_37 >= p_37) | ((-1L) == (l_607 & p_37))) >> (uint16_t)12), p_37, p_37);
        /* statement id: 304 */
        assert (l_465 == 0);
    }
    /* facts after for loop */
    //assert (l_465 == dangling || l_465 == 0);
    (*l_610) = l_608;
    return l_611;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_39(int32_t * const  p_40, int64_t  p_41, int16_t  p_42, int32_t * p_43)
{ /* block id: 230 */
    int32_t l_430 = 0L;
    int32_t *l_429 = &l_430;
    int32_t **l_428 = &l_429;
    union U2 l_433 = {0x6C9D16F3L};
    struct S0 l_434 = {0xC25BE30FL,0x85DDL,-2L,-8L,247UL};
    float *l_435 = &l_433.f2;
    (*l_428) = p_40;
    /* statement id: 231 */
    //assert (l_429 == &l_35);
    (*l_435) = (((float)(**l_428) / (float)(p_41 < (p_42 == p_42))) < 0x8.Bp+1);
    /* statement id: 232 */
        for (l_433.f1 = 6; (l_433.f1 <= (-23)); l_433.f1--)
    { /* block id: 235 */
        int32_t ***l_451 = &l_428;
    }
    /* facts after for loop */
        return p_43;
    /* statement id: 245 */
    //assert (func_39_rv == &l_35);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_44(int32_t * p_45, int32_t * p_46, uint32_t  p_47, uint32_t  p_48, int32_t * p_49)
{ /* block id: 43 */
    float l_53 = 0x7.EB0A11p-96;
    int32_t l_54 = 0L;
    l_54 = (!__builtin_popcountl(((l_54 == p_48) ^ (+(p_48 | ((-1L) ^ p_48))))));
    return p_49;
    /* statement id: 45 */
    //assert (func_44_rv == &l_35 || func_44_rv == 0 || func_44_rv == &l_69 || func_44_rv == &l_178.f1 || func_44_rv == &l_104);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_56(union U2  p_57, int32_t * p_58, int32_t  p_59)
{ /* block id: 225 */
    int32_t l_405 = (-6L);
    int32_t *l_404 = &l_405;
    struct S0 l_418 = {-1L,5UL,0xEDD21812L,-1L,0xF6L};
    int32_t **l_419 = &l_404;
    struct S0 l_421 = {0x95FA7546L,0x8E59L,0x5FA5FF65L,-1L,1UL};
    struct S0 *l_420 = &l_421;
    float l_424 = (-0x6.8p+1);
    float *l_423 = &l_424;
    float **l_422 = &l_423;
    const float ***l_425 = (void*)0;
    float ***l_426 = &l_422;
    (*l_419) = func_65(l_404, ((int16_t)(+((+func_94(((int16_t)__builtin_popcountll((*l_404)) >> (int16_t)((uint16_t)((uint16_t)(18446744073709551609UL | (((int32_t)func_94(p_59, p_57, l_418) / (int32_t)(0x535DL & 1L)) < (*l_404))) << (uint16_t)p_59) % (uint16_t)1L)), p_57, l_418)) && p_59)) / (int16_t)(*l_404)));
    l_420 = &l_418;
    /* statement id: 227 */
    assert (l_420 == &l_418);
    (*l_426) = l_422;
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_61(const uint16_t  p_62, uint32_t  p_63, int16_t  p_64)
{ /* block id: 46 */
    int32_t *l_83 = (void*)0;
    union U2 l_293 = {0xA3EBE082L};
    union U2 *l_292 = &l_293;
    union U1 l_314 = {0x8.Cp+1};
    const union U1 *l_313 = &l_314;
    uint16_t l_355 = 65535UL;
    struct S0 l_363 = {0x3EA47ABDL,0xC997L,6L,0xA8F9CB82273D293ELL,0x43L};
    struct S0 *l_362 = &l_363;
    struct S0 **l_361 = &l_362;
    struct S0 ***l_360 = &l_361;
    union U2 **l_399 = &l_292;
    int32_t *l_400 = &l_314.f1;
    int32_t *l_401 = &l_314.f1;
    int32_t *l_402 = &l_314.f1;
    int32_t *l_403 = (void*)0;
    if (p_62)
    { /* block id: 47 */
        int32_t l_69 = 0xB2A93F04L;
        int32_t *l_68 = &l_69;
        int32_t **l_75 = (void*)0;
        int32_t **l_76 = &l_68;
        union U2 l_90 = {0x2307D3E6L};
        struct S0 l_91 = {-1L,0UL,1L,7L,255UL};
        float *l_291 = &l_90.f3;
        int32_t *l_305 = &l_69;
        int32_t *l_306 = (void*)0;
        int32_t ***l_337 = &l_75;
        int32_t **** const l_336 = &l_337;
        (*l_76) = func_65(l_68, p_64);
        (*l_291) = func_77(l_83, (*l_76), l_90, l_91, p_63);
        /* statement id: 166 */
                if (p_63)
        { /* block id: 167 */
            (**l_76) = p_63;
        }
        else
        { /* block id: 169 */
            uint32_t l_298 = 0x48576C49L;
            struct S0 l_299 = {-5L,0x0FD2L,0x321BD9B3L,7L,0xCBL};
            int32_t *l_300 = &l_69;
            (*l_76) = func_65((*l_76), (((l_292 == (void*)0) || (func_94(((int16_t)(p_64 <= ((uint16_t)0x868CL + (uint16_t)(*l_68))) << (int16_t)l_298), (*l_292), l_299) && p_64)) != p_64));
            l_83 = l_300;
            /* statement id: 171 */
            assert (l_83 == &l_69);
            if (((uint16_t)((uint16_t)0x307FL << (uint16_t)12) - (uint16_t)0x12EFL))
            { /* block id: 172 */
                (*l_291) = 0x0.9p+1;
                return l_306;
                /* statement id: 174 */
                //assert (func_61_rv == 0);
            }
            else
            { /* block id: 175 */
                float l_307 = (-0x10.2p+1);
                int32_t l_308 = 0x700EAA7CL;
                uint32_t l_319 = 4294967288UL;
                (*l_291) = ((__builtin_popcountll(p_63) != (**l_76)) > (__builtin_clz(p_64) != l_308));
                for (l_91.f0 = 9; (l_91.f0 != (-5)); --l_91.f0)
                { /* block id: 179 */
                    union U2 l_329 = {0L};
                    int32_t *l_339 = &l_314.f1;
                    for (l_298 = 0; (l_298 != 18); l_298 += 9)
                    { /* block id: 182 */
                        const union U1 **l_315 = (void*)0;
                        union U1 **l_316 = (void*)0;
                        union U1 *l_318 = (void*)0;
                        union U1 **l_317 = &l_318;
                        int16_t l_338 = 0x6AF2L;
                        (*l_317) = l_313;
                        /* statement id: 183 */
                        assert (l_318 == &l_314);
                        l_319 = p_63;
                        (*l_76) = func_44(func_65(l_300, ((uint16_t)(((uint16_t)((((((uint16_t)(!((int16_t)func_94(p_62, l_329, l_299) - (int16_t)(*l_83))) - (uint16_t)((uint16_t)(((int16_t)p_63 << (int16_t)5) && (p_64 >= ((int16_t)((l_336 != (void*)0) == 0x0765B23BL) / (int16_t)p_62))) - (uint16_t)p_64)) | l_338) && 0x79F3L) & (*l_300)) <= 0xB31E70AFL) / (uint16_t)(*l_68)) <= (*l_83)) >> (uint16_t)5)), l_339, l_338, l_338, l_300);
                    }
                }
                (*l_300) = 0xC7681339L;
            }
        }
        /* facts after branching */
        assert (l_83 == &l_69 || l_83 == 0);
    }
    else
    { /* block id: 191 */
        float *l_342 = (void*)0;
        int32_t l_343 = 3L;
        union U2 l_376 = {0L};
        struct S0 * const *l_388 = &l_362;
        int32_t **l_398 = &l_83;
        if ((((int16_t)(l_342 == l_83) << (int16_t)3) && l_343))
        { /* block id: 192 */
            struct S0 l_351 = {-3L,0UL,0xDB47CDA2L,0xB2F48B5C4B6020A7LL,1UL};
            struct S0 *l_350 = &l_351;
            struct S0 **l_349 = &l_350;
            struct S0 **l_352 = &l_350;
            int32_t *l_387 = &l_314.f1;
            if ((((p_63 != (!((uint16_t)(p_63 ^ 0xA71A296F131FA9AALL) - (uint16_t)((l_349 != l_352) ^ p_62)))) | ((((p_62 & ((uint16_t)l_343 + (uint16_t)((((__builtin_ffs(l_343) >= (-8L)) < (-8L)) != p_64) != 0xD6ACL))) ^ l_355) | 3L) | p_62)) && p_62))
            { /* block id: 193 */
                struct S0 ****l_364 = &l_360;
lbl_359:
                for (l_343 = 0; (l_343 >= (-22)); l_343 -= 8)
                { /* block id: 196 */
                    int32_t *l_358 = &l_314.f1;
                    (*l_358) = 6L;
                    /* statement id: 197 */
                                        if (l_355)
                        goto lbl_359;
                }
                (*l_364) = l_360;
                l_343 = __builtin_clzll((p_63 && 0x2EF746FDB34CF7A4LL));
            }
            else
            { /* block id: 202 */
                float *l_365 = &l_293.f3;
                int32_t l_368 = 4L;
                const struct S0 *l_381 = &l_363;
                int32_t **l_385 = (void*)0;
                union U2 l_386 = {0L};
                (*l_365) = 0x3.B5B071p-29;
                /* statement id: 203 */
                                if (((((((uint64_t)l_351.f0 + (uint64_t)l_368) & p_64) <= ((+((uint32_t)p_62 - (uint32_t)((uint16_t)(((int32_t)func_94(l_343, l_376, (***l_360)) % (int32_t)((((int16_t)(((uint16_t)((void*)0 == l_381) % (uint16_t)p_64) < p_62) % (int16_t)p_63) | 0x2C173402L) ^ l_351.f2)) > p_63) >> (uint16_t)6))) > l_368)) | 7UL) & (-9L)))
                { /* block id: 204 */
                    int32_t * const l_384 = &l_343;
                    (*l_384) = ((uint64_t)func_94(((l_384 == l_83) != (l_343 & ((l_385 != &l_384) ^ (-4L)))), l_386, (*l_381)) - (uint64_t)p_63);
                }
                else
                { /* block id: 206 */
                    return l_83;
                    /* statement id: 207 */
                    //assert (func_61_rv == 0);
                }
            }
            l_314.f1 = p_62;
            /* statement id: 210 */
                    }
        else
        { /* block id: 211 */
            struct S0 ***l_389 = &l_361;
            union U1 * const l_390 = &l_314;
            union U1 **l_391 = (void*)0;
            union U1 *l_393 = &l_314;
            union U1 **l_392 = &l_393;
            (*l_389) = l_388;
            (*l_392) = l_390;
        }
        /* facts after branching */
                for (l_343 = 26; (l_343 <= 17); l_343--)
        { /* block id: 217 */
            float *l_396 = (void*)0;
            float *l_397 = &l_293.f3;
            (*l_397) = p_63;
            /* statement id: 218 */
                    }
        (*l_398) = l_83;
    }
    /* facts after branching */
    //assert (l_83 == dangling || l_83 == 0);
    (*l_399) = &l_293;
    (*l_400) = p_63;
    /* statement id: 223 */
        return l_403;
    /* statement id: 224 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_69 l_35
 */
inline static int32_t * func_65(int32_t * p_66, uint32_t  p_67)
{ /* block id: 48 */
    uint32_t l_71 = 0UL;
    int32_t l_73 = (-1L);
    int32_t *l_72 = &l_73;
    int32_t *l_74 = &l_73;
    (*p_66) = (!l_71);
    return p_66;
    /* statement id: 50 */
    //assert (func_65_rv == &l_69 || func_65_rv == &l_405 || func_65_rv == &l_35 || func_65_rv == &l_526.f1);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_77(int32_t * p_78, int32_t * p_79, union U2  p_80, struct S0  p_81, const int32_t  p_82)
{ /* block id: 52 */
    uint32_t l_98 = 0xAE879CFDL;
    int32_t l_104 = (-8L);
    int32_t * const l_103 = &l_104;
    struct S0 *l_166 = (void*)0;
    union U1 l_178 = {-0x8.9p-1};
    union U1 *l_177 = &l_178;
    uint32_t l_201 = 0xCFDDCEC7L;
    int32_t **l_204 = (void*)0;
    int32_t ** const *l_203 = &l_204;
    union U1 *l_207 = (void*)0;
    int32_t l_210 = 5L;
    int16_t l_232 = 0x9BD9L;
    union U2 l_287 = {5L};
    union U2 *l_286 = &l_287;
    float l_290 = 0x1.969112p-2;
    if (((int16_t)(p_80.f0 >= func_94(l_98, p_80, p_81)) << (int16_t)12))
    { /* block id: 61 */
        int32_t *l_106 = &l_104;
        int32_t **l_105 = &l_106;
        struct S0 l_164 = {0x0E566308L,65532UL,1L,-1L,0x80L};
        struct S0 *l_163 = &l_164;
        uint16_t l_176 = 0xA4B2L;
        int32_t l_206 = 0x626EB52EL;
        (*l_105) = l_103;
        if (((-9L) < ((uint16_t)((uint64_t)0x577C8A60B10F657DLL % (uint64_t)(*l_106)) << (uint16_t)((int32_t)(((uint16_t)(**l_105) << (uint16_t)(**l_105)) >= (+(**l_105))) + (int32_t)((*l_103) < ((uint64_t)(*l_103) / (uint64_t)(+(p_79 != (void*)0))))))))
        { /* block id: 63 */
            int32_t l_121 = 0x04E64A2BL;
            float l_132 = 0x0.1p-1;
            float *l_131 = &l_132;
            (*l_131) = ((((float)(l_121 >= (p_81.f3 > (((float)p_82 + (float)l_121) > ((float)((float)p_81.f1 - (float)(*l_106)) / (float)((*l_106) <= ((float)(-(float)l_121) - (float)(**l_105))))))) - (float)(*l_103)) != p_81.f3) != (*l_103));
            return l_121;
        }
        else
        { /* block id: 66 */
            int32_t l_135 = 0L;
            union U2 l_151 = {-1L};
            float l_172 = 0x0.Cp-1;
            struct S0 l_202 = {0x1FFD6F7CL,0x0A92L,0xA6678658L,0x4148A961F3FAF8E6LL,253UL};
            (*p_79) = ((uint32_t)l_135 + (uint32_t)((-9L) & ((uint16_t)(*l_106) % (uint16_t)((int32_t)(*l_103) / (int32_t)(~(18446744073709551615UL ^ (**l_105)))))));
            for (p_81.f2 = 0; (p_81.f2 > (-1)); p_81.f2 -= 7)
            { /* block id: 70 */
                int32_t l_150 = 0xDC7DF631L;
                float *l_159 = &l_151.f3;
                int32_t *l_161 = &l_150;
                struct S0 *l_174 = &l_164;
                int32_t ***l_179 = &l_105;
                if (((int32_t)(((0x33AAL != (*l_103)) <= ((uint16_t)0x129DL >> (uint16_t)3)) > p_80.f0) + (int32_t)p_82))
                { /* block id: 71 */
                    const float l_149 = 0x4.6p-1;
                    struct S0 **l_165 = (void*)0;
                    (*p_79) = (((int16_t)(p_81.f2 != ((p_81.f2 <= 18446744073709551615UL) != (*l_106))) >> (int16_t)func_94(l_150, l_151, p_81)) ^ ((int16_t)((int32_t)((*p_79) || (*p_79)) - (int32_t)p_81.f2) / (int16_t)l_150));
                    for (l_135 = 2; (l_135 != 2); l_135 += 6)
                    { /* block id: 75 */
                        float *l_158 = &l_151.f2;
                        int32_t l_160 = 0x66612900L;
                        int32_t *l_162 = &l_104;
                        (*l_158) = func_94(p_81.f3, p_80, p_81);
                        /* statement id: 76 */
                                                l_161 = &l_150;
                        l_162 = &l_150;
                        /* statement id: 78 */
                        assert (l_162 == &l_150);
                        if ((*p_79))
                            continue;
                    }
                    l_166 = l_163;
                    /* statement id: 81 */
                    assert (l_166 == &l_164);
                }
                else
                { /* block id: 82 */
                    uint8_t l_173 = 0x49L;
                    if ((l_151.f0 >= (0x9A1ECA9F70EF1A53LL > ((uint32_t)(-(uint64_t)p_81.f1) - (uint32_t)((uint32_t)((p_81.f1 != l_173) ^ 0x1F153C6A96B58146LL) % (uint32_t)l_135)))))
                    { /* block id: 83 */
                        return p_81.f4;
                    }
                    else
                    { /* block id: 85 */
                        struct S0 **l_175 = &l_174;
                        (*l_105) = (void*)0;
                        /* statement id: 86 */
                        //assert (p_79 == 0 || p_79 == &l_69 || p_79 == &l_35);
                        assert (l_106 == 0 || l_106 == &l_104);
                        (*l_175) = l_174;
                        l_176 = (p_79 == (*l_105));
                        if ((*l_103))
                            break;
                    }
                    /* facts after branching */
                    //assert (p_79 == 0 || p_79 == &l_69 || p_79 == &l_35);
                    assert (l_106 == 0 || l_106 == &l_104);
                    (*l_161) = (p_80.f0 || p_81.f4);
                    return l_135;
                }
                /* facts after branching */
                assert (l_166 == &l_164);
                l_177 = l_177;
                (*l_179) = &p_79;
                /* statement id: 95 */
                assert (l_105 == &p_79);
            }
            /* facts after for loop */
            //assert (p_79 == 0 || p_79 == &l_69 || p_79 == &l_35);
            assert (l_106 == 0 || l_106 == &l_104);
            assert (l_105 == &p_79 || l_105 == &l_106);
            assert (l_166 == &l_164 || l_166 == 0);
            (*l_105) = func_44(&l_104, &l_135, p_81.f3, l_135, p_78);
            /* statement id: 97 */
            //assert (l_106 == 0 || l_106 == &l_104 || l_106 == &l_35);
            if (func_94(((int16_t)(p_81.f0 >= l_151.f0) - (int16_t)(((uint16_t)__builtin_bswap64(l_135) << (uint16_t)6) < (((-(int16_t)(l_135 != (((int64_t)__builtin_ffsl(((uint32_t)(((0UL ^ 0x82BA979DL) && ((void*)0 != (*l_105))) <= p_81.f2) - (uint32_t)4294967295UL)) + (int64_t)(*l_103)) < 0x031DE900L))) | (*l_103)) == 0x38C4D500L))), p_80, p_81))
            { /* block id: 98 */
                int32_t l_200 = 0x045A3BC6L;
                (*l_103) = (((int16_t)(l_200 < l_201) << (int16_t)9) && (p_82 | 1UL));
                (*l_103) = (((0xEEABL == (*l_103)) == func_94(p_82, p_80, l_202)) >= (p_79 == (void*)0));
            }
            else
            { /* block id: 101 */
                (*l_105) = p_79;
                /* statement id: 102 */
                //assert (l_106 == 0 || l_106 == &l_69 || l_106 == &l_104 || l_106 == &l_35);
            }
            /* facts after branching */
            //assert (l_106 == 0 || l_106 == &l_69 || l_106 == &l_104 || l_106 == &l_35);
        }
        /* facts after branching */
        //assert (p_79 == 0 || p_79 == &l_69 || p_79 == &l_35);
        //assert (l_106 == 0 || l_106 == &l_69 || l_106 == &l_104 || l_106 == &l_35);
        assert (l_105 == &p_79 || l_105 == &l_106);
        assert (l_166 == &l_164 || l_166 == 0);
        (*l_103) = (l_203 != &l_105);
        l_206 = (+l_164.f3);
    }
    else
    { /* block id: 107 */
        struct S0 l_211 = {-1L,0x72BBL,-3L,4L,255UL};
        int32_t * const l_223 = &l_104;
        int32_t l_230 = 0xB9BFD8F9L;
        struct S0 ***l_231 = (void*)0;
        int32_t l_235 = 0x4F6DA58DL;
        int32_t *l_268 = &l_104;
        union U1 *l_284 = &l_178;
        union U2 l_285 = {0xAC8DC0C5L};
lbl_225:
        (*l_103) = (__builtin_clzll(p_81.f0) > (l_207 == &l_178));
        (*p_79) = ((uint16_t)(p_82 || l_210) << (uint16_t)func_94(p_81.f4, p_80, l_211));
        if (l_211.f2)
        { /* block id: 110 */
            uint32_t l_227 = 4294967295UL;
            for (l_178.f1 = 0; (l_178.f1 <= (-16)); l_178.f1 -= 1)
            { /* block id: 113 */
                uint32_t l_228 = 1UL;
                int32_t *l_229 = &l_178.f1;
                for (l_201 = 28; (l_201 > 22); --l_201)
                { /* block id: 116 */
                    struct S0 **l_216 = &l_166;
                    struct S0 * const *l_218 = &l_166;
                    struct S0 * const **l_217 = &l_218;
                    int32_t *l_226 = &l_178.f1;
                    (*l_217) = l_216;
                    if ((*p_79))
                        continue;
                    for (p_81.f0 = 0; (p_81.f0 <= 25); p_81.f0 += 4)
                    { /* block id: 121 */
                        int32_t *l_221 = &l_178.f1;
                        uint16_t l_222 = 0xE662L;
                        int32_t **l_224 = &l_221;
                        (*l_224) = l_223;
                        /* statement id: 122 */
                        assert (l_221 == &l_104);
                        if (l_98)
                            goto lbl_225;
                    }
                    l_226 = p_78;
                    /* statement id: 125 */
                    //assert (l_226 == 0 || l_226 == &l_35);
                }
                l_228 = l_227;
                p_79 = func_44(l_229, p_78, (((*l_223) > l_230) && ((l_231 == (void*)0) > ((l_232 < p_82) || ((uint16_t)(func_94(p_81.f0, p_80, p_81) >= (*l_103)) >> (uint16_t)1)))), l_235, p_79);
            }
            /* facts after for loop */
                        (*l_103) = (__builtin_ctzll(p_81.f3) != ((int32_t)__builtin_bswap64(p_81.f2) + (int32_t)0x3B09B231L));
        }
        else
        { /* block id: 131 */
            int64_t l_242 = (-10L);
            union U2 l_252 = {1L};
            struct S0 l_253 = {2L,65529UL,0L,-1L,255UL};
            int32_t *l_257 = &l_178.f1;
            int32_t ***l_278 = &l_204;
            union U1 * const l_283 = &l_178;
            for (l_210 = 0; (l_210 != 6); l_210 += 6)
            { /* block id: 134 */
                float *l_240 = (void*)0;
                float *l_241 = &l_178.f0;
                int32_t l_251 = 0x35079E51L;
                union U2 l_254 = {0x61FC436AL};
                (*l_241) = 0x7.7DB1D5p-66;
                p_79 = func_65(p_79, __builtin_popcountl(l_242));
                (*l_241) = (0x7.7913BDp+1 == ((-0x4.6p-1) >= func_94((((int64_t)(((*l_103) & 8L) && p_81.f0) / (int64_t)((int32_t)((int32_t)(0xE5BDD16FL & ((((int16_t)(((func_94(((-1L) & l_251), l_252, l_253) ^ l_242) == l_253.f3) || (*l_223)) >> (int16_t)p_82) > 0x02BAL) || 0x1520A11C632E4EC8LL)) - (int32_t)p_81.f2) - (int32_t)(*p_79))) | 65535UL), l_254, l_253)));
                if ((*p_79))
                { /* block id: 138 */
                    int32_t *l_258 = &l_178.f1;
                    int32_t ***l_265 = &l_204;
                    int32_t **l_269 = &l_257;
                    for (l_230 = 0; (l_230 != 16); ++l_230)
                    { /* block id: 141 */
                        uint32_t l_266 = 0UL;
                        int32_t l_267 = (-2L);
                        l_268 = func_44(func_44(func_44(p_78, func_44(l_257, l_258, (*l_258), l_254.f0, l_257), ((uint16_t)((int64_t)(0x17803233C0C79DF2LL || ((uint16_t)((void*)0 == l_265) >> (uint16_t)p_80.f0)) - (int64_t)1L) << (uint16_t)4), l_266, p_79), p_79, p_81.f4, l_267, l_268), p_78, p_82, (*l_257), l_268);
                        (*p_79) = (*l_257);
                    }
                    (*l_269) = p_79;
                    /* statement id: 145 */
                    //assert (l_257 == &l_69 || l_257 == &l_35);
                    if (((int16_t)p_81.f1 >> (int16_t)4))
                    { /* block id: 146 */
                        const struct S0 *l_276 = (void*)0;
                        const struct S0 **l_275 = &l_276;
                        const struct S0 ***l_274 = &l_275;
                        (*l_223) = ((uint16_t)p_81.f0 + (uint16_t)((*l_257) == 0x852D9DEA42474D7ALL));
                        (*l_274) = &l_166;
                        /* statement id: 148 */
                        assert (l_275 == &l_166);
                    }
                    else
                    { /* block id: 149 */
                        struct S0 **l_277 = &l_166;
                        (*l_269) = p_78;
                        /* statement id: 150 */
                        //assert (l_257 == 0 || l_257 == &l_35);
                        (*l_277) = &l_253;
                        /* statement id: 151 */
                        assert (l_166 == &l_253);
                        (*l_103) = (*l_268);
                    }
                    /* facts after branching */
                    assert (l_166 == &l_253 || l_166 == 0);
                    //assert (l_257 == 0 || l_257 == &l_69 || l_257 == &l_35);
                    return p_81.f4;
                }
                else
                { /* block id: 155 */
                    int32_t ****l_279 = &l_278;
                    (*l_279) = l_278;
                    return p_81.f2;
                }
            }
            (*l_257) = (((0L <= ((*l_268) < ((*p_79) < (((!(&l_223 == (*l_278))) > ((*p_79) == (p_81.f2 == func_94(((p_82 < ((uint16_t)(l_283 != l_284) / (uint16_t)(*l_223))) ^ (*l_268)), l_285, p_81)))) && p_81.f0)))) ^ p_81.f1) >= 0x945D7D14L);
            /* statement id: 160 */
                        l_286 = &p_80;
            /* statement id: 161 */
            assert (l_286 == &p_80);
            (*l_257) = ((int16_t)((void*)0 == l_166) >> (int16_t)5);
        }
        /* facts after branching */
                assert (l_286 == &p_80 || l_286 == &l_287);
    }
    /* facts after branching */
    //assert (p_79 == 0 || p_79 == &l_69 || p_79 == &l_35);
    //assert (l_166 == dangling || l_166 == 0);
    assert (l_286 == &p_80 || l_286 == &l_287);
    return l_290;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_94(uint32_t  p_95, union U2  p_96, struct S0  p_97)
{ /* block id: 53 */
    int32_t l_100 = 8L;
    int32_t *l_99 = &l_100;
    (*l_99) = p_97.f1;
    for (p_96.f1 = (-21); (p_96.f1 >= (-13)); ++p_96.f1)
    { /* block id: 57 */
        if ((*l_99))
            break;
    }
    /* facts after for loop */
        return p_97.f4;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 179
   depth: 1, occurrence: 16
XXX total union variables: 17

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 28
breakdown:
   indirect level: 0, occurrence: 17
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 38
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 10

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 240
   depth: 2, occurrence: 38
   depth: 3, occurrence: 7
   depth: 4, occurrence: 7
   depth: 5, occurrence: 4
   depth: 6, occurrence: 9
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 4
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 4
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 207

XXX times a variable address is taken: 192
XXX times a pointer is dereferenced on RHS: 118
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 14
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 119
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 376

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 425
   level: 2, occurrence: 60
   level: 3, occurrence: 35
   level: 4, occurrence: 5
XXX number of pointers point to pointers: 86
XXX number of pointers point to scalars: 86
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 25.1
XXX average alias set size: 1.29

XXX times a non-volatile is read: 883
XXX times a non-volatile is write: 295
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 215
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 34
   depth: 2, occurrence: 37
   depth: 3, occurrence: 43
   depth: 4, occurrence: 36
   depth: 5, occurrence: 32

XXX percentage a fresh-made variable is used: 21
XXX percentage an existing variable is used: 79
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

