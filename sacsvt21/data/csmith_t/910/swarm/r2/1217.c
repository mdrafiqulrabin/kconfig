/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      497193674
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   int32_t  f1;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 10;
   signed f1 : 27;
};

union U2 {
   uint32_t  f0;
   float  f1;
   signed f2 : 22;
   struct S0  f3;
   int32_t  f4;
};

union U3 {
   signed f0 : 19;
};

union U4 {
   signed f0 : 11;
   float  f1;
};

union U5 {
   int32_t  f0;
   uint16_t  f1;
   int32_t  f2;
   unsigned f3 : 14;
   int64_t  f4;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0xDF1ADB2BL;
static union U5 g_18 = {-1L};
static union U5 *g_17 = &g_18;
static struct S0 g_19 = {0x77E815F8L,-1L};
static union U3 g_20 = {4L};
static struct S1 g_61 = {17,4158};
static int32_t *g_70 = &g_18.f2;
static int32_t **g_69 = &g_70;
static int32_t ***g_68 = &g_69;
static union U5 **g_111 = &g_17;
static union U5 ***g_110 = &g_111;
static union U2 g_114 = {0x0E9B690CL};
static union U4 g_168 = {0xCF297919L};
static union U4 *g_217 = (void*)0;
static uint32_t g_222 = 0xA76F27FDL;
static struct S1 *g_235 = &g_61;
static struct S1 **g_234 = &g_235;
static struct S1 ***g_233 = &g_234;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_1(void);
static union U5 * func_5(uint16_t  p_6, int32_t  p_7, int32_t  p_8, union U5 * p_9, int16_t  p_10);
static union U5 * func_13(union U5 * p_14, struct S0  p_15, union U3  p_16);
static int32_t  func_23(union U5 * p_24, union U3  p_25, int64_t  p_26);
static union U3  func_27(union U5 * p_28);
static union U5 * func_29(union U5 * p_30, int64_t  p_31, uint32_t  p_32);
static union U5 * func_33(union U5 * p_34, int64_t  p_35, union U5 * p_36, uint64_t  p_37);
static uint32_t  func_41(union U4  p_42, union U5 * p_43);
static struct S1  func_49(union U5 ** p_50, union U5 ** p_51, union U5 ** p_52);
static union U5 ** func_54(int32_t  p_55, union U5  p_56);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_114.f3
 * writes: g_2 g_114.f3
 */
static struct S0  func_1(void)
{ /* block id: 0 */
    uint64_t l_12 = 0xB44CF592758E92EDLL;
    struct S0 l_490 = {-5L,4L};
    struct S0 *l_491 = &g_114.f3;
    for (g_2 = (-30); (g_2 > (-2)); g_2 += 9)
    { /* block id: 3 */
        int64_t l_11 = 1L;
    }
    (*l_491) = l_490;
    /* statement id: 199 */
    return (*l_491);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_18.f0 g_18.f2 g_61.f1 g_114.f4 g_18.f1 g_114.f3.f1 g_69 g_70 g_17
 * writes: g_114.f4 g_114.f3.f1 g_70 g_217
 */
static union U5 * func_5(uint16_t  p_6, int32_t  p_7, int32_t  p_8, union U5 * p_9, int16_t  p_10)
{ /* block id: 186 */
    int32_t *l_459 = &g_2;
    int32_t l_460 = 0x952EC49BL;
    int16_t l_469 = 0x58EDL;
    union U5 **l_474 = &g_17;
    int32_t ***l_475 = &g_69;
    int32_t *l_476 = &g_114.f4;
    union U2 *l_479 = &g_114;
    int32_t l_487 = (-3L);
    l_460 = (l_459 != l_459);
    (*l_476) = ((uint32_t)(((int64_t)((((((uint64_t)(((uint16_t)l_469 >> (uint16_t)1) ^ (*l_459)) - (uint64_t)(((uint16_t)(0L ^ ((*l_459) && ((uint16_t)(g_18.f0 != ((void*)0 != l_474)) << (uint16_t)((((void*)0 == l_475) | g_18.f2) | 65530UL)))) >> (uint16_t)14) == p_6)) <= g_61.f1) >= 18446744073709551613UL) || 0xE8F4L) > g_2) / (int64_t)(-1L)) >= 7UL) + (uint32_t)(*l_459));
    /* statement id: 188 */
    (*l_476) = ((((*l_476) == ((((((uint16_t)g_18.f1 << (uint16_t)7) ^ (l_479 != l_479)) >= ((uint16_t)(((int64_t)(!(*l_476)) + (int64_t)p_10) < g_18.f0) << (uint16_t)(((p_8 | ((int16_t)(-5L) >> (int16_t)7)) & l_487) > 0x8735L))) || (*l_476)) | 7L)) < p_7) != 0xD23ED539L);
    for (g_114.f3.f1 = 0; (g_114.f3.f1 == 10); g_114.f3.f1 += 5)
    { /* block id: 192 */
        (**l_475) = (*g_69);
        g_217 = &g_168;
        /* statement id: 194 */
        assert (g_217 == &g_168);
    }
    return (*l_474);
    /* statement id: 196 */
    //assert (func_5_rv == &g_18);
}


/* ------------------------------------------ */
/* 
 * reads : g_19.f1 g_18.f3 g_18.f0 g_17 g_18 g_18.f2 g_70 g_69 g_20.f0 g_61.f1 g_110 g_2 g_114.f2 g_19.f0 g_61.f0 g_111 g_114.f0 g_61 g_18.f1 g_114.f4 g_222 g_233 g_168.f0 g_234 g_235 g_19
 * writes: g_18.f0 g_61 g_18.f2 g_68 g_70 g_114.f0 g_114.f1 g_114.f3.f1 g_110 g_19.f0 g_217 g_17 g_114.f3 g_114.f2
 */
static union U5 * func_13(union U5 * p_14, struct S0  p_15, union U3  p_16)
{ /* block id: 4 */
    union U5 *l_38 = &g_18;
    union U4 l_44 = {0x35E45DB0L};
    struct S1 *l_457 = &g_61;
    if (((int64_t)p_15.f0 - (int64_t)((g_19.f1 != 0x5984L) != func_23(&g_18, func_27(func_29(func_33(l_38, ((int16_t)p_16.f0 + (int16_t)(func_41(l_44, l_38) <= l_44.f0)), p_14, g_20.f0), l_44.f0, p_15.f0)), g_19.f1))))
    { /* block id: 179 */
        int32_t *l_438 = (void*)0;
        (*g_69) = l_438;
    }
    else
    { /* block id: 181 */
        uint32_t l_445 = 0xD217DB60L;
        float *l_458 = &l_44.f1;
        (*l_458) = ((((float)((float)((float)l_445 / (float)(!((float)((((float)((float)((g_19.f0 == (p_16.f0 == (((p_15.f1 <= ((float)((l_44.f0 > ((void*)0 != (**g_110))) < ((float)(l_457 != l_457) + (float)g_222)) / (float)l_44.f0)) != p_16.f0) > 0x2.412F7Cp+7))) < (-0x1.8p+1)) - (float)g_18.f3) + (float)0xF.C744DAp-48) <= 0x0.2p-1) != 0xE.6F13B8p-43) + (float)l_44.f0))) + (float)l_44.f0) / (float)g_2) < g_18.f2) > 0xB.E8D606p+48);
        /* statement id: 182 */
                return (**g_110);
        /* statement id: 183 */
        //assert (func_13_rv == &g_18);
    }
    /* facts after branching */
        assert (g_70 == 0);
    assert (g_68 == 0 || g_68 == &g_69);
    assert (g_217 == &g_168 || g_217 == 0);
    return (**g_110);
    /* statement id: 185 */
    //assert (func_13_rv == &g_18);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_23(union U5 * p_24, union U3  p_25, int64_t  p_26)
{ /* block id: 177 */
    int16_t l_437 = 0x0E12L;
    return l_437;
}


/* ------------------------------------------ */
/* 
 * reads : g_69 g_19.f0 g_18.f2 g_2 g_168.f0 g_18.f1 g_114.f2 g_20.f0 g_19.f1 g_61.f1 g_70
 * writes: g_114.f3 g_70 g_114.f2
 */
static union U3  func_27(union U5 * p_28)
{ /* block id: 151 */
    struct S0 l_345 = {0x79EB5DBAL,0x204E7C17L};
    struct S0 *l_346 = (void*)0;
    struct S0 *l_347 = &g_114.f3;
    int32_t *l_348 = (void*)0;
    uint64_t l_356 = 0x0B2586082183CB46LL;
    uint64_t l_359 = 18446744073709551615UL;
    int32_t l_385 = (-1L);
    uint32_t l_391 = 0x7E57FD0BL;
    union U2 *l_421 = &g_114;
    union U2 **l_420 = &l_421;
    struct S1 ***l_429 = &g_234;
    union U3 l_436 = {0L};
    (*l_347) = l_345;
    /* statement id: 152 */
    (*g_69) = l_348;
    /* statement id: 153 */
    assert (g_70 == 0);
    g_114.f2 = (1L >= ((int16_t)((0xA656AFC290DDE9A8LL && ((int16_t)(l_345.f1 & l_345.f0) << (int16_t)(!((int16_t)(&g_19 == (void*)0) << (int16_t)g_19.f0)))) <= ((l_356 & (((((((((((int16_t)g_19.f0 + (int16_t)l_356) <= 0xF018L) > l_356) && 0xE3C08EB28AE3A1A5LL) && 18446744073709551615UL) != l_356) < (-1L)) & l_345.f0) || l_359) == l_356)) ^ l_345.f1)) << (int16_t)g_18.f2));
    /* statement id: 154 */
    if ((((((uint16_t)((int16_t)((uint32_t)((uint16_t)((((uint16_t)(((int64_t)(((int16_t)(((int16_t)((uint32_t)(((uint64_t)(((uint16_t)(!((((((uint16_t)((l_385 < (~g_2)) < 0x23C6L) + (uint16_t)((l_345.f0 <= (((uint16_t)((int16_t)g_168.f0 - (int16_t)((((0x0078894FL | (l_356 >= g_18.f1)) ^ 1UL) & g_19.f0) > l_385)) << (uint16_t)l_391) && l_345.f0)) | l_356)) ^ 0xB94147C4392019EFLL) >= l_385) > 0x945D36D0909EED68LL) != g_168.f0)) % (uint16_t)g_114.f2) < 1UL) / (uint64_t)g_20.f0) <= g_168.f0) % (uint32_t)g_19.f1) << (int16_t)g_20.f0) != l_391) - (int16_t)l_359) < (-2L)) % (int64_t)l_345.f1) < l_345.f0) / (uint16_t)l_345.f1) > l_359) > (-1L)) << (uint16_t)7) / (uint32_t)g_61.f1) << (int16_t)6) >> (uint16_t)8) && 0xC64FL) == 0x7B3EL) >= (-1L)))
    { /* block id: 155 */
        int16_t l_392 = (-7L);
        int32_t l_393 = 0xB0DBF972L;
        union U4 *l_415 = &g_168;
        l_393 = (((0x5580L == l_392) < l_393) & l_392);
        for (l_359 = 6; (l_359 < 32); l_359 += 8)
        { /* block id: 159 */
            union U4 *l_414 = &g_168;
            int32_t l_422 = 0x150A7E5CL;
            for (l_393 = 3; (l_393 < (-30)); l_393 -= 1)
            { /* block id: 162 */
                int32_t l_431 = (-2L);
            }
        }
    }
    else
    { /* block id: 173 */
        int32_t *l_435 = &g_18.f2;
        l_435 = (*g_69);
        /* statement id: 174 */
        assert (l_435 == 0);
    }
    return l_436;
    /* statement id: 176 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_2 g_18.f1 g_18.f3 g_19.f1 g_114.f0 g_114.f4 g_18.f2 g_61.f1 g_114.f2 g_110 g_111 g_19.f0 g_69 g_222 g_233 g_168.f0 g_61.f0 g_234 g_235 g_19 g_61 g_20.f0 g_17
 * writes: g_114.f3.f1 g_110 g_61 g_19.f0 g_217 g_70 g_17 g_114.f1 g_114.f3
 */
static union U5 * func_29(union U5 * p_30, int64_t  p_31, uint32_t  p_32)
{ /* block id: 79 */
    union U4 *l_167 = &g_168;
    union U4 *l_169 = &g_168;
    union U2 *l_171 = (void*)0;
    union U2 **l_170 = &l_171;
    struct S1 *l_174 = &g_61;
    int32_t l_175 = 0x4ECD3A2BL;
    int32_t *l_180 = &g_114.f3.f1;
    int32_t l_207 = 0L;
    struct S1 *l_214 = &g_61;
    union U5 *l_232 = &g_18;
    struct S1 ***l_249 = &g_234;
    int32_t l_292 = (-1L);
    struct S0 *l_313 = (void*)0;
    float *l_344 = &g_114.f1;
    l_169 = l_167;
    (*l_180) = ((g_2 | (l_170 != &l_171)) >= (((uint64_t)((void*)0 != l_174) - (uint64_t)((l_175 & g_18.f1) | (((int64_t)(((p_32 & ((uint16_t)l_175 % (uint16_t)g_18.f3)) > (-8L)) == (-7L)) - (int64_t)l_175) | 0xF1995C1DL))) ^ p_31));
    if (p_32)
    { /* block id: 82 */
        int16_t l_181 = 0L;
        int32_t *l_193 = (void*)0;
        union U5 ***l_212 = &g_111;
        struct S0 *l_329 = &g_19;
        if (l_181)
        { /* block id: 83 */
            int32_t *l_192 = &g_19.f1;
            uint64_t l_203 = 0x3C7C5A92DAE4FB37LL;
            int32_t ***l_315 = &g_69;
            struct S0 *l_317 = &g_19;
            if (((int16_t)((int32_t)((uint32_t)((int16_t)((int16_t)((l_192 == l_193) <= ((int16_t)p_31 + (int16_t)((((uint16_t)((((int16_t)0xDF11L + (int16_t)((uint32_t)(g_19.f1 > (p_32 < (0x2B42L == (~18446744073709551607UL)))) % (uint32_t)(g_114.f0 ^ p_32))) > g_114.f4) ^ g_18.f2) - (uint16_t)l_203) ^ g_114.f0) || p_31))) / (int16_t)g_61.f1) + (int16_t)0x3921L) - (uint32_t)0xA3A44C34L) / (int32_t)g_114.f2) / (int16_t)g_18.f2))
            { /* block id: 84 */
                union U5 ****l_204 = &g_110;
                float l_223 = (-0x1.0p-1);
                struct S1 ***l_236 = (void*)0;
                int32_t l_250 = 1L;
                union U4 *l_258 = &g_168;
                (*l_204) = &g_111;
                (*l_174) = func_49((*g_110), (**l_204), (*g_110));
                for (g_19.f0 = 19; (g_19.f0 <= 0); g_19.f0 -= 7)
                { /* block id: 89 */
                    uint16_t l_213 = 0UL;
                    int16_t l_224 = 0L;
                    uint32_t l_231 = 0x65C56C76L;
                    int32_t l_251 = 0x694F7BBAL;
                    if ((l_207 < ((p_32 >= 0UL) >= (*l_192))))
                    { /* block id: 90 */
                        struct S1 **l_215 = (void*)0;
                        struct S1 **l_216 = &l_214;
                        (*l_180) = ((g_18.f2 | ((*l_204) == (void*)0)) || ((int16_t)((uint64_t)(((0x3FA6EFE3CF7B5A89LL <= ((void*)0 != l_212)) >= g_19.f1) && l_213) - (uint64_t)((l_192 != (void*)0) < 4294967286UL)) >> (int16_t)6));
                        (*l_216) = l_214;
                    }
                    else
                    { /* block id: 93 */
                        g_217 = &g_168;
                        /* statement id: 94 */
                        assert (g_217 == &g_168);
                        (*g_69) = (void*)0;
                        /* statement id: 95 */
                        assert (g_70 == 0);
                    }
                    if (((uint64_t)((l_213 == ((((((int32_t)p_32 - (int32_t)g_222) == l_224) ^ (p_32 || (((uint64_t)((int32_t)((&g_110 != &g_110) >= ((int32_t)(p_32 != (l_213 >= p_32)) + (int32_t)0x7BCD1F54L)) % (int32_t)p_31) / (uint64_t)l_231) | 0UL))) && 0xE58EL) == g_18.f3)) < g_19.f1) + (uint64_t)0x31148879A0F3CD20LL))
                    { /* block id: 97 */
                        (**g_110) = l_232;
                        if (p_32)
                            continue;
                        l_236 = g_233;
                        /* statement id: 100 */
                        assert (l_236 == &g_234);
                        l_251 = (((int16_t)((uint32_t)4294967295UL % (uint32_t)(p_32 ^ (((int16_t)((int16_t)(-(int64_t)(~(((((int16_t)1L % (int16_t)0xE7F4L) & (l_249 != (void*)0)) == (p_31 != p_31)) | p_31))) >> (int16_t)p_31) >> (int16_t)g_18.f2) <= g_168.f0))) << (int16_t)g_18.f2) >= l_250);
                    }
                    else
                    { /* block id: 102 */
                        union U3 *l_253 = (void*)0;
                        union U3 **l_252 = &l_253;
                        int32_t l_277 = 1L;
                        (*l_252) = &g_20;
                        /* statement id: 103 */
                        assert (l_253 == &g_20);
                        (*l_180) = ((int16_t)((((uint32_t)p_32 / (uint32_t)p_31) >= ((-1L) < (l_258 == (void*)0))) <= ((uint16_t)(-(uint64_t)((uint32_t)((((((((int64_t)(((uint32_t)((int16_t)g_18.f2 >> (int16_t)1) - (uint32_t)((!((uint16_t)(p_32 & ((uint16_t)(1L == ((int64_t)((p_31 | p_31) ^ l_277) - (int64_t)p_32)) << (uint16_t)4)) >> (uint16_t)4)) >= p_32)) & l_277) - (int64_t)p_32) & l_231) >= 0xAEFDAD2A3BAFCB35LL) >= g_61.f1) != 0UL) | g_61.f0) > 9L) / (uint32_t)4294967288UL)) << (uint16_t)7)) >> (int16_t)p_32);
                        l_277 = ((g_19.f1 || (g_61.f1 > p_32)) & 0xC27BL);
                        (*l_180) = l_231;
                    }
                    (*l_180) = (((uint32_t)g_222 - (uint32_t)((uint16_t)p_32 % (uint16_t)g_114.f2)) != 3L);
                }
                /* facts after for loop */
                assert (g_217 == &g_168 || g_217 == 0);
                assert (l_236 == 0 || l_236 == &g_234);
                return p_30;
                /* statement id: 110 */
                //assert (func_29_rv == &g_18);
            }
            else
            { /* block id: 111 */
                union U3 *l_294 = &g_20;
                int32_t l_306 = (-1L);
                int32_t l_309 = 0x58A89B08L;
                for (p_31 = 25; (p_31 > 18); p_31 -= 1)
                { /* block id: 114 */
                    uint32_t l_293 = 0x32489128L;
                    struct S0 *l_314 = &g_114.f3;
                    uint32_t l_316 = 0xD34EA4AFL;
                    float *l_323 = (void*)0;
                    if (((uint16_t)(&g_111 != (void*)0) << (uint16_t)((p_32 != (0x80E9152DCB3132CCLL & ((p_31 & g_114.f0) != (l_192 != (void*)0)))) & ((int64_t)(((uint16_t)((int64_t)(g_18.f1 ^ 0x67B5BB632E5C04B2LL) + (int64_t)p_32) + (uint16_t)65535UL) | p_32) / (int64_t)(-2L)))))
                    { /* block id: 115 */
                        if (l_292)
                            break;
                        if (p_32)
                            continue;
                    }
                    else
                    { /* block id: 118 */
                        union U3 **l_295 = &l_294;
                        float *l_310 = &g_114.f1;
                        (*l_180) = l_293;
                        (*l_295) = l_294;
                        l_306 = ((uint64_t)((uint64_t)((uint64_t)((*l_192) && (0x457212886F20A964LL > 0xB77E2E7F7A6C36F7LL)) + (uint64_t)((uint16_t)((uint16_t)((void*)0 != &l_180) >> (uint16_t)(g_19.f1 != 0xD7EBL)) << (uint16_t)(((void*)0 == (**g_233)) >= 0xACEA78EDL))) - (uint64_t)l_306) % (uint64_t)p_31);
                        (*l_310) = (0x2.E296A0p+84 < (g_19.f0 <= ((float)(p_31 < l_309) / (float)(0x6.06361Ep+96 <= (&g_20 == &g_20)))));
                        /* statement id: 122 */
                    }
                    for (l_293 = 0; (l_293 == 27); l_293 += 9)
                    { /* block id: 126 */
                        l_314 = l_313;
                        /* statement id: 127 */
                        assert (l_314 == 0);
                        (*l_180) = (&g_69 == l_315);
                    }
                    /* facts after for loop */
                    assert (l_314 == 0 || l_314 == &g_114.f3);
                    if ((l_316 < 18446744073709551612UL))
                    { /* block id: 130 */
                        struct S0 **l_318 = &l_317;
                        (*l_318) = l_317;
                        (*g_69) = &l_175;
                        /* statement id: 132 */
                        assert (g_70 == &l_175);
                    }
                    else
                    { /* block id: 133 */
                        int32_t l_321 = 1L;
                        l_321 = ((uint32_t)g_18.f2 + (uint32_t)0xB2B69162L);
                        if (l_306)
                            break;
                    }
                    g_114.f1 = (((!(g_18.f2 <= (0x0.Bp-1 == 0x5.A4172Fp+83))) != 0x1.9p+1) < l_309);
                    /* statement id: 137 */
                }
                /* facts after for loop */
                //assert (g_70 == &g_18.f2 || g_70 == dangling || g_70 == &g_2 || g_70 == 0 || g_70 == &l_175);
            }
            /* facts after branching */
            //assert (g_70 == &g_18.f2 || g_70 == dangling || g_70 == &g_2 || g_70 == 0 || g_70 == &l_175);
            return p_30;
            /* statement id: 140 */
            //assert (g_70 == &g_18.f2 || g_70 == dangling || g_70 == &g_2 || g_70 == 0);
            //assert (func_29_rv == &g_18);
        }
        else
        { /* block id: 141 */
            union U5 ****l_326 = &g_110;
            int32_t l_327 = (-8L);
            struct S0 *l_328 = &g_114.f3;
            l_327 = ((float)(0xC.B3F61Fp+26 > (((l_326 != (void*)0) != (0x8.7F5302p-42 > l_181)) != p_32)) / (float)0x1.3p-1);
            (*l_328) = g_19;
            /* statement id: 143 */
        }
        /* facts after branching */
        (*l_180) = (l_313 == l_329);
    }
    else
    { /* block id: 146 */
        (***g_233) = (*l_174);
    }
    (*l_344) = (0xF.F204F4p-64 <= (((((g_20.f0 >= (((-(float)((p_31 < (-0x1.8p+1)) >= ((!((float)(((float)g_222 + (float)(((((float)(((float)(((l_207 < ((float)((float)((void*)0 == (*g_233)) - (float)(&g_111 != &g_111)) + (float)p_31)) >= p_32) >= g_19.f0) / (float)0x8.2DFD22p+1) != g_19.f0) + (float)0x0.8p+1) > 0x0.Ep-1) < 0x1.0p-1) == 0x0.968E2Cp+65)) >= p_31) - (float)l_207)) == 0x7.FB7263p-48))) <= 0x9.Ep+1) <= g_168.f0)) <= p_32) <= 0x5.0304A4p-74) >= l_175) <= g_168.f0));
    /* statement id: 149 */
    return (**g_110);
    /* statement id: 150 */
    //assert (func_29_rv == &g_18);
}


/* ------------------------------------------ */
/* 
 * reads : g_61.f1 g_18.f2 g_18.f0 g_110 g_2 g_114.f2 g_69 g_70 g_19.f0 g_61.f0 g_18.f3 g_111 g_17 g_114.f0 g_61 g_19.f1
 * writes: g_18.f2 g_70 g_114.f0 g_61 g_114.f1
 */
static union U5 * func_33(union U5 * p_34, int64_t  p_35, union U5 * p_36, uint64_t  p_37)
{ /* block id: 36 */
    union U5 **l_96 = &g_17;
    union U5 ***l_95 = &l_96;
    int32_t ****l_104 = &g_68;
    int32_t *l_112 = &g_18.f2;
    union U2 *l_113 = &g_114;
    struct S0 l_115 = {-3L,0x2330F086L};
    int32_t *l_122 = &g_19.f1;
    (*l_112) = ((~(l_95 != &l_96)) == (((int64_t)g_61.f1 + (int64_t)((-(uint32_t)(((uint16_t)(((int32_t)(((&g_68 == l_104) & (-(int16_t)g_18.f2)) >= g_18.f0) / (int32_t)((int32_t)((int32_t)0x706CD8FDL + (int32_t)((g_110 != (void*)0) || p_37)) % (int32_t)4294967295UL)) >= p_35) << (uint16_t)g_61.f1) & p_37)) > 0xFBB161CAL)) || g_2));
    /* statement id: 37 */
    l_113 = l_113;
    l_115 = l_115;
    if (((uint64_t)(p_35 > ((int16_t)(*l_112) + (int16_t)g_114.f2)) / (uint64_t)(((&l_112 != &l_112) || (l_112 == l_122)) & (-(uint32_t)(4294967295UL || 0xB10B9BD4L)))))
    { /* block id: 40 */
        uint16_t l_132 = 0x9EF3L;
        int32_t *l_139 = &l_115.f1;
        union U2 *l_142 = (void*)0;
        struct S0 l_146 = {0xBBF6EB6FL,-4L};
        (*g_69) = &g_2;
        /* statement id: 41 */
        assert (g_70 == &g_2);
        for (g_18.f2 = 0; (g_18.f2 >= (-27)); g_18.f2 -= 1)
        { /* block id: 44 */
            uint64_t l_138 = 0x5F2FB4D153B42EBALL;
            int32_t *l_161 = (void*)0;
            float *l_162 = &g_114.f1;
            for (l_115.f0 = 0; (l_115.f0 != 24); l_115.f0 += 2)
            { /* block id: 47 */
                uint16_t l_133 = 0xA43FL;
                (*g_69) = (*g_69);
                if (((0xB0934BFCL & (((((uint32_t)(((l_132 | (((((l_133 || l_133) <= (p_35 == (((int16_t)g_19.f0 % (int16_t)g_61.f0) | ((uint64_t)g_18.f3 % (uint64_t)l_132)))) || l_138) < (**g_69)) > 0x0C0AL)) | l_133) ^ g_2) % (uint32_t)(-1L)) ^ p_35) != 0xB6C3L) | (-7L))) <= g_18.f3))
                { /* block id: 49 */
                    return (*g_111);
                    /* statement id: 50 */
                    //assert (g_70 == &g_18.f2 || g_70 == dangling || g_70 == &g_2);
                    //assert (func_33_rv == &g_18);
                }
                else
                { /* block id: 51 */
                    int16_t l_148 = 1L;
                    (*g_69) = l_139;
                    /* statement id: 52 */
                    assert (g_70 == &l_115.f1);
                    for (g_114.f0 = 0; (g_114.f0 <= 25); g_114.f0++)
                    { /* block id: 55 */
                        union U2 **l_143 = &l_142;
                        struct S1 *l_144 = (void*)0;
                        struct S1 *l_145 = &g_61;
                        struct S0 *l_147 = &l_146;
                        (*l_143) = l_142;
                        (*l_145) = g_61;
                        (*l_147) = l_146;
                        if (l_148)
                            break;
                    }
                }
                /* facts after branching */
                assert (g_70 == &l_115.f1);
            }
            (*l_162) = (((float)((*g_110) != (void*)0) / (float)(*l_139)) <= (((float)((float)(-0x5.Ap+1) - (float)((float)(((float)((g_61.f0 <= ((void*)0 == &l_142)) != (((float)p_37 - (float)(l_161 == l_161)) != g_61.f1)) / (float)g_61.f0) == p_37) + (float)(*l_122))) - (float)0x1.7p+1) == g_61.f0));
            /* statement id: 63 */
            for (g_114.f0 = 0; (g_114.f0 >= 31); ++g_114.f0)
            { /* block id: 66 */
                (*g_69) = l_112;
                /* statement id: 67 */
                assert (g_70 == &g_18.f2);
            }
            /* facts after for loop */
        }
        /* facts after for loop */
        assert (g_70 == &g_18.f2 || g_70 == &l_115.f1 || g_70 == &g_2);
        (*g_69) = (void*)0;
        /* statement id: 70 */
        assert (g_70 == 0);
    }
    else
    { /* block id: 71 */
        for (l_115.f0 = 15; (l_115.f0 >= (-29)); l_115.f0 -= 1)
        { /* block id: 74 */
            (*l_112) = p_37;
        }
    }
    /* facts after branching */
    //assert (g_70 == dangling || g_70 == &g_18.f2 || g_70 == 0);
    return p_34;
    /* statement id: 78 */
    //assert (func_33_rv == &g_18);
}


/* ------------------------------------------ */
/* 
 * reads : g_18.f3 g_18.f0 g_17 g_18 g_18.f2 g_70 g_69
 * writes: g_18.f0 g_61 g_18.f2 g_68 g_70
 */
static uint32_t  func_41(union U4  p_42, union U5 * p_43)
{ /* block id: 5 */
    union U5 **l_53 = &g_17;
    int32_t l_82 = 0xCCE65120L;
    if (g_18.f3)
    { /* block id: 6 */
        union U5 **l_46 = &g_17;
        union U5 ***l_45 = &l_46;
        int32_t l_57 = 0L;
        (*l_45) = (void*)0;
        /* statement id: 7 */
        assert (l_46 == 0);
        for (g_18.f0 = 0; (g_18.f0 >= 29); ++g_18.f0)
        { /* block id: 10 */
            struct S1 *l_60 = &g_61;
            (*l_60) = func_49(l_53, l_53, func_54(l_57, (*g_17)));
        }
    }
    else
    { /* block id: 18 */
        int32_t *l_64 = &g_18.f2;
        int32_t ***l_81 = (void*)0;
        int32_t ****l_93 = &g_68;
        for (g_18.f2 = 0; (g_18.f2 == (-29)); g_18.f2 -= 1)
        { /* block id: 21 */
            int32_t **l_65 = (void*)0;
            int32_t **l_66 = (void*)0;
            int32_t **l_67 = &l_64;
            uint32_t l_89 = 0xAF40839CL;
            (*l_67) = l_64;
            g_68 = (void*)0;
            /* statement id: 23 */
            assert (g_68 == 0);
            l_89 = ((int32_t)((uint64_t)((int16_t)(p_42.f0 && ((((int16_t)((uint64_t)p_42.f0 - (uint64_t)18446744073709551615UL) >> (int16_t)5) < (&g_69 == l_81)) ^ l_82)) >> (int16_t)((((((((((uint16_t)(p_43 == p_43) % (uint16_t)((uint64_t)(((uint64_t)(0x86B686461D90BCC9LL < 0xA42286E0DAEE2552LL) - (uint64_t)(**l_67)) >= g_18.f3) - (uint64_t)(*l_64))) > l_82) != 65535UL) > (-9L)) == 0x2733L) | 65527UL) != 0UL) ^ 0x14C5L) <= (-1L))) % (uint64_t)p_42.f0) + (int32_t)(*g_70));
            for (l_82 = (-3); (l_82 > (-30)); l_82 -= 8)
            { /* block id: 27 */
                int32_t *l_92 = &g_18.f2;
                (*g_69) = l_92;
                return (*l_64);
            }
        }
        /* facts after for loop */
                assert (g_68 == 0 || g_68 == &g_69);
        (*g_69) = &l_82;
        /* statement id: 32 */
        assert (g_70 == &l_82);
        (*l_93) = l_81;
        /* statement id: 33 */
        assert (g_68 == 0);
    }
    /* facts after branching */
    assert (g_70 == &l_82 || g_70 == &g_18.f2);
    assert (g_68 == 0 || g_68 == &g_69);
    return p_42.f0;
    /* statement id: 35 */
    //assert (g_70 == dangling || g_70 == &g_18.f2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_49(union U5 ** p_50, union U5 ** p_51, union U5 ** p_52)
{ /* block id: 14 */
    struct S1 l_59 = {6,9175};
    return l_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U5 ** func_54(int32_t  p_55, union U5  p_56)
{ /* block id: 11 */
    union U5 **l_58 = &g_17;
    l_58 = &g_17;
    return l_58;
    /* statement id: 13 */
    //assert (func_54_rv == &g_17);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_18.f0, "g_18.f0", print_hash_value);
    transparent_crc(g_18.f1, "g_18.f1", print_hash_value);
    transparent_crc(g_18.f2, "g_18.f2", print_hash_value);
    transparent_crc(g_18.f3, "g_18.f3", print_hash_value);
    transparent_crc(g_19.f0, "g_19.f0", print_hash_value);
    transparent_crc(g_19.f1, "g_19.f1", print_hash_value);
    transparent_crc(g_20.f0, "g_20.f0", print_hash_value);
    transparent_crc(g_61.f0, "g_61.f0", print_hash_value);
    transparent_crc(g_61.f1, "g_61.f1", print_hash_value);
    transparent_crc(g_114.f0, "g_114.f0", print_hash_value);
    transparent_crc_bytes (&g_114.f1, sizeof(g_114.f1), "g_114.f1", print_hash_value);
    transparent_crc(g_114.f2, "g_114.f2", print_hash_value);
    transparent_crc(g_114.f3.f0, "g_114.f3.f0", print_hash_value);
    transparent_crc(g_114.f3.f1, "g_114.f3.f1", print_hash_value);
    transparent_crc(g_114.f4, "g_114.f4", print_hash_value);
    transparent_crc(g_168.f0, "g_168.f0", print_hash_value);
    transparent_crc(g_222, "g_222", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 94
   depth: 1, occurrence: 6
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 33
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 16
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 1
XXX full-bitfields structs in the program: 1
breakdown:
   indirect level: 0, occurrence: 1
XXX times a bitfields struct's address is taken: 24
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 49

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 130
   depth: 2, occurrence: 20
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 102

XXX times a variable address is taken: 99
XXX times a pointer is dereferenced on RHS: 36
breakdown:
   depth: 1, occurrence: 28
   depth: 2, occurrence: 8
XXX times a pointer is dereferenced on LHS: 50
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 217

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 137
   level: 2, occurrence: 41
   level: 3, occurrence: 10
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 36
XXX number of pointers point to scalars: 23
XXX number of pointers point to structs: 16
XXX percent of pointers has null in alias set: 22.5
XXX average alias set size: 1.11

XXX times a non-volatile is read: 410
XXX times a non-volatile is write: 141
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 113
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 20
   depth: 2, occurrence: 14
   depth: 3, occurrence: 10
   depth: 4, occurrence: 10
   depth: 5, occurrence: 28

XXX percentage a fresh-made variable is used: 19.6
XXX percentage an existing variable is used: 80.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

