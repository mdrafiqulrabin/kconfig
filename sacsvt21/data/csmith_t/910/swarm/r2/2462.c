/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2955333446
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const uint32_t  func_28(void);
static int32_t  func_36(int16_t  p_37, uint32_t  p_38, uint64_t  p_39, int16_t  p_40);
static int64_t  func_42(const int32_t  p_43, uint32_t  p_44, int16_t  p_45, uint64_t  p_46, int64_t  p_47);
static int32_t  func_52(int32_t  p_53, int64_t  p_54, uint64_t  p_55, const uint64_t  p_56, uint32_t  p_57);
static int16_t  func_65(int16_t  p_66, int16_t  p_67);
static int32_t  func_79(int16_t  p_80);
static uint32_t  func_87(uint32_t  p_88);
static int64_t  func_91(int64_t  p_92);
static int32_t  func_96(uint32_t  p_97, int32_t  p_98, int32_t  p_99, uint64_t  p_100, uint16_t  p_101);
static int32_t  func_105(uint64_t  p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_28(void)
{ /* block id: 36 */
    uint32_t l_35 = 9UL;
    uint16_t l_41 = 65535UL;
    uint32_t l_459 = 18446744073709551615UL;
    int32_t l_464 = 6L;
    const int32_t *l_463 = &l_464;
    int32_t **l_484 = (void*)0;
    int32_t ** const *l_483 = &l_484;
    int32_t ****l_494 = (void*)0;
    int32_t *****l_493 = &l_494;
    uint16_t l_499 = 1UL;
    const uint64_t l_507 = 0xED09D8D0A3ED33E6LL;
    int32_t *l_508 = &l_464;
    int16_t l_517 = 0x2756L;
    const int64_t l_518 = 0x43443872AEA804FDLL;
    if ((safe_rshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s((safe_mod_func_int64_t_s_s(l_35, l_35)), func_36((l_41 ^ func_42(l_35, l_35, l_41, l_41, (safe_sub_func_uint64_t_u_u((safe_add_func_uint32_t_u_u(4294967291UL, 1UL)), 0x46E74A6E8F59172DLL)))), l_35, l_35, l_35))), 10)))
    { /* block id: 306 */
        int16_t l_456 = 0xE6A9L;
        int32_t l_460 = (-10L);
        int32_t *l_461 = (void*)0;
        int32_t *l_462 = &l_460;
        l_460 = ((0x854735E3E4F86FADLL < l_41) | ((!(__builtin_ia32_crc32qi(((safe_mod_func_uint32_t_u_u(func_105(l_456), __builtin_bswap32(l_456))) > (safe_mod_func_uint64_t_u_u((func_105(l_456) >= ((l_41 && l_35) <= l_41)), 0xC4DA238A6FDFDF90LL))), l_459) <= 0x2F53L)) == 18446744073709551610UL));
        (*l_462) = l_35;
    }
    else
    { /* block id: 309 */
        int32_t *l_466 = (void*)0;
        int32_t **l_465 = &l_466;
        const uint16_t l_482 = 0UL;
        (*l_465) = l_463;
        /* statement id: 310 */
        assert (l_466 == &l_464);
        for (l_459 = (-10); (l_459 == 31); l_459 = safe_add_func_int64_t_s_s(l_459, 6))
        { /* block id: 313 */
            for (l_41 = (-5); (l_41 >= 19); l_41++)
            { /* block id: 316 */
                const int64_t l_471 = 7L;
                int32_t *l_472 = &l_464;
                (*l_465) = &l_464;
                if (l_471)
                { /* block id: 318 */
                    (*l_465) = l_472;
                    (*l_465) = &l_464;
                }
                else
                { /* block id: 321 */
                    if ((*l_463))
                        break;
                    for (l_35 = (-30); (l_35 > 3); l_35 = safe_add_func_int64_t_s_s(l_35, 5))
                    { /* block id: 325 */
                        (*l_466) = 0xD8C9AC73L;
                    }
                }
                (*l_466) = (safe_div_func_int64_t_s_s((!(*l_472)), (safe_lshift_func_int16_t_s_u((*l_463), 9))));
            }
            (*l_465) = (*l_465);
        }
        for (l_464 = 6; (l_464 == 6); l_464 = safe_add_func_int32_t_s_s(l_464, 9))
        { /* block id: 337 */
            if ((*l_466))
                break;
        }
        return l_482;
    }
    if ((l_483 != &l_484))
    { /* block id: 342 */
        int32_t *l_489 = (void*)0;
        int32_t **l_488 = &l_489;
        int32_t ***l_490 = &l_488;
        for (l_464 = 0; (l_464 == 11); l_464 = safe_add_func_int16_t_s_s(l_464, 1))
        { /* block id: 345 */
            const uint32_t l_487 = 4294967295UL;
            return l_487;
        }
        (*l_490) = l_488;
    }
    else
    { /* block id: 349 */
        uint64_t l_495 = 0x6D1853BCCBEA5B0ALL;
        const int32_t *****l_496 = (void*)0;
        uint64_t l_497 = 0x63D94BE712EA60D0LL;
        int16_t l_498 = 0xE90FL;
        int32_t l_500 = 1L;
        l_500 = (((safe_mod_func_int32_t_s_s(((((func_42((*l_463), ((*l_463) != (l_493 != (void*)0)), l_495, (l_496 != &l_494), func_96(l_497, l_498, (*l_463), l_495, l_495)) ^ 7L) > l_498) && l_497) && l_495), l_497)) || l_499) > l_495);
        l_500 = ((__builtin_ffsl((*l_463)) | ((safe_sub_func_int32_t_s_s(((void*)0 != (*l_493)), (l_500 ^ ((safe_sub_func_uint16_t_u_u((((*l_483) != (void*)0) & ((((safe_add_func_int64_t_s_s((-1L), ((void*)0 != &l_494))) > (*l_463)) >= (*l_463)) || l_500)), (*l_463))) >= (-1L))))) == 0x283B7F0CE31EFFF4LL)) <= l_498);
        return l_507;
    }
    l_508 = &l_464;
    (*l_508) = (((safe_mul_func_uint16_t_u_u(((void*)0 == (*l_493)), (*l_463))) || ((safe_add_func_uint16_t_u_u((__builtin_parityll((*l_463)) ^ ((func_96((*l_508), (*l_463), ((safe_rshift_func_uint16_t_u_u((safe_mod_func_int64_t_s_s((*l_463), func_96(l_517, (*l_508), (*l_463), (*l_508), (*l_508)))), (*l_463))) > (*l_508)), (*l_463), (*l_463)) ^ (*l_463)) != (*l_508))), (*l_508))) != (*l_508))) >= 0UL);
    return l_518;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_36(int16_t  p_37, uint32_t  p_38, uint64_t  p_39, int16_t  p_40)
{ /* block id: 303 */
    int32_t l_452 = 0x08CCA986L;
    int32_t *l_451 = &l_452;
    int32_t **l_450 = &l_451;
    l_450 = l_450;
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_42(const int32_t  p_43, uint32_t  p_44, int16_t  p_45, uint64_t  p_46, int64_t  p_47)
{ /* block id: 37 */
    uint64_t l_60 = 3UL;
    int32_t l_68 = (-9L);
    int32_t * const l_287 = &l_68;
    int32_t * const *l_286 = &l_287;
    int32_t * const **l_285 = &l_286;
    int32_t ****l_436 = (void*)0;
    int32_t *****l_435 = &l_436;
lbl_320:
    (*l_287) = func_52((safe_mod_func_int32_t_s_s(p_46, (l_60 || (__builtin_ctzl(l_60) || p_44)))), (safe_lshift_func_uint16_t_u_u(((safe_add_func_int16_t_s_s(func_65(p_44, l_68), ((void*)0 != l_285))) <= p_44), p_44)), (*l_287), p_44, (**l_286));
    if (((*l_286) == (void*)0))
    { /* block id: 170 */
        int32_t *l_308 = &l_68;
        int32_t **l_307 = &l_308;
        int32_t ***l_306 = &l_307;
        int32_t l_393 = (-1L);
        int32_t ***l_407 = &l_307;
        if ((!(safe_rshift_func_uint16_t_u_u(func_96((**l_286), (*l_287), (safe_sub_func_uint16_t_u_u(p_45, p_44)), ((void*)0 == l_306), (**l_286)), (**l_286)))))
        { /* block id: 171 */
            int32_t **l_356 = (void*)0;
            for (p_47 = 0; (p_47 >= (-13)); p_47 = safe_sub_func_uint32_t_u_u(p_47, 1))
            { /* block id: 174 */
                uint16_t l_321 = 0x8E71L;
                int32_t * const l_336 = &l_68;
                for (l_60 = 14; (l_60 != 57); l_60++)
                { /* block id: 177 */
                    int32_t * const *l_323 = &l_287;
                    if ((safe_sub_func_int32_t_s_s(p_44, p_46)))
                    { /* block id: 178 */
                        int16_t l_315 = 0x3CF7L;
                        (***l_306) = (l_315 > (safe_sub_func_uint32_t_u_u((safe_mod_func_uint64_t_u_u(p_43, 0x240F40E8074C4DBCLL)), 0L)));
                        if (l_315)
                            goto lbl_320;
                        l_321 = 1L;
                        (**l_307) = p_44;
                    }
                    else
                    { /* block id: 183 */
                        int32_t **l_322 = &l_308;
                        (*l_307) = (void*)0;
                        /* statement id: 184 */
                        assert (l_308 == 0);
                        (*l_307) = (**l_306);
                        (*l_322) = (**l_285);
                        /* statement id: 186 */
                        assert (l_308 == &l_68);
                    }
                    if ((0UL >= (l_323 != (void*)0)))
                    { /* block id: 188 */
                        return p_43;
                    }
                    else
                    { /* block id: 190 */
                        (*l_287) = p_46;
                        return p_44;
                    }
                }
                if ((p_43 != (safe_sub_func_int16_t_s_s(0x3FD8L, 65535UL))))
                { /* block id: 195 */
                    const int32_t l_340 = 0x91E7AC14L;
                    int32_t l_341 = 1L;
                    for (l_60 = (-26); (l_60 > 57); l_60 = safe_add_func_uint32_t_u_u(l_60, 5))
                    { /* block id: 198 */
                        int64_t l_339 = 0x02758DB9AF29F7BDLL;
                        l_341 = (safe_mul_func_int16_t_s_s(((safe_div_func_uint64_t_u_u((safe_sub_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((-7L), (func_65(((void*)0 != l_336), (*l_336)) && (safe_add_func_uint64_t_u_u(l_339, (l_340 >= p_46)))))), __builtin_ctzll((***l_306)))), 0x012672E03B3499E8LL)) < 0x16C94C7D9CDFD70ELL), 0x70A1L));
                        return p_46;
                    }
                }
                else
                { /* block id: 202 */
                    int32_t **l_342 = &l_308;
                    (*l_342) = l_336;
                }
                (***l_306) = (safe_lshift_func_int16_t_s_u((safe_sub_func_int64_t_s_s(((safe_rshift_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s((*l_336), 9)) | (safe_lshift_func_uint16_t_u_s(((safe_mod_func_uint64_t_u_u((~((void*)0 == l_356)), (((!(func_52(((*l_336) || ((*l_287) || (!func_87((*l_336))))), (safe_mod_func_uint32_t_u_u(p_46, (p_47 ^ (-8L)))), (**l_307), (***l_285), (*l_336)) || p_46)) & p_43) ^ 1UL))) || p_44), (*l_287)))), 15)) | p_45), (**l_286))), 2));
            }
        }
        else
        { /* block id: 207 */
            int32_t *l_364 = &l_68;
            for (p_46 = 0; (p_46 == 32); p_46++)
            { /* block id: 210 */
                int32_t l_363 = (-10L);
                if (p_45)
                    goto lbl_320;
                if (l_363)
                { /* block id: 212 */
                    (*l_307) = l_364;
                    if (p_44)
                        goto lbl_320;
                }
                else
                { /* block id: 215 */
                    uint32_t l_373 = 0UL;
                    const int32_t *l_384 = &l_68;
                    int32_t ***l_387 = &l_307;
                    if ((safe_lshift_func_uint16_t_u_s((safe_sub_func_int64_t_s_s((*l_308), (safe_rshift_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s(__builtin_ffsll((*l_364)), 1)) & l_373), (safe_add_func_uint64_t_u_u(__builtin_bswap64(l_363), ((safe_sub_func_uint16_t_u_u(p_46, ((safe_mod_func_int64_t_s_s((safe_add_func_uint64_t_u_u(18446744073709551610UL, ((~3L) ^ l_373))), p_46)) <= (-9L)))) | p_46))))))), 10)))
                    { /* block id: 216 */
                        uint32_t l_383 = 0x8FE129A4L;
                        (*l_364) = ((void*)0 != &l_286);
                        if (l_68)
                            goto lbl_320;
                        (**l_307) = l_383;
                    }
                    else
                    { /* block id: 220 */
                        int32_t **l_385 = &l_308;
                        const int32_t *l_386 = (void*)0;
                        (*l_385) = l_384;
                        (*l_364) = __builtin_clz((&l_364 == &l_364));
                        if (p_44)
                            break;
                        l_386 = l_384;
                        /* statement id: 224 */
                        assert (l_386 == &l_68);
                    }
                    (*l_308) = 0xC4580800L;
                    if (p_44)
                        goto lbl_320;
                    (***l_387) = (l_387 != (void*)0);
                }
                if (p_47)
                    continue;
            }
        }
        if ((0x11A4CF9EB957AB5BLL >= (safe_mod_func_int32_t_s_s((safe_unary_minus_func_uint16_t_u((safe_mul_func_uint16_t_u_u(l_393, (((safe_add_func_uint16_t_u_u(((**l_286) && (*l_308)), (safe_sub_func_int64_t_s_s(p_46, (p_43 ^ __builtin_ctzll((**l_307))))))) > (***l_306)) != (**l_307)))))), p_46))))
        { /* block id: 233 */
            uint16_t l_401 = 0UL;
            uint64_t l_408 = 0x07992E37C5671B14LL;
            int32_t *l_410 = &l_68;
            for (l_60 = 0; (l_60 < 21); l_60 = safe_add_func_uint32_t_u_u(l_60, 8))
            { /* block id: 236 */
                (**l_286) = (p_43 > (p_46 <= p_47));
            }
            if ((**l_286))
            { /* block id: 239 */
                const int32_t l_400 = (-7L);
                l_401 = l_400;
                for (p_47 = 0; (p_47 <= 4); p_47++)
                { /* block id: 243 */
                    int32_t ***l_409 = &l_307;
                }
                for (p_46 = 0; (p_46 == 2); p_46 = safe_add_func_uint32_t_u_u(p_46, 7))
                { /* block id: 266 */
                    int32_t * const **l_420 = &l_286;
                    for (p_45 = 0; (p_45 <= 8); p_45 = safe_add_func_uint64_t_u_u(p_45, 5))
                    { /* block id: 269 */
                        int32_t * const l_415 = &l_68;
                        int32_t **l_416 = (void*)0;
                        int32_t **l_417 = &l_410;
                        (*l_417) = l_415;
                    }
                    (**l_307) = (((safe_div_func_int32_t_s_s(((&l_285 == (void*)0) != ((p_46 || 1UL) != l_400)), ((*l_410) || (((void*)0 != l_420) >= 0L)))) < p_45) <= 0x25D5551144C929BBLL);
                }
            }
            else
            { /* block id: 274 */
                const int32_t *l_421 = &l_68;
                int32_t **l_422 = &l_410;
                (*l_422) = l_421;
            }
        }
        else
        { /* block id: 277 */
            int64_t l_427 = 1L;
            int32_t *l_432 = &l_68;
            int32_t *l_439 = &l_68;
            (**l_286) = 3L;
            if ((safe_div_func_int64_t_s_s((!(safe_unary_minus_func_uint16_t_u(((func_52(p_43, p_44, p_47, (*l_287), l_427) > ((*l_407) != (void*)0)) || ((&l_307 == (void*)0) | p_46))))), p_44)))
            { /* block id: 279 */
                int32_t * const l_430 = &l_68;
                int32_t ****l_434 = (void*)0;
                int32_t *****l_433 = &l_434;
                for (l_68 = 0; (l_68 == 25); l_68++)
                { /* block id: 282 */
                    int32_t **l_431 = &l_308;
                    (*l_431) = l_430;
                }
                l_432 = (**l_285);
                (*l_433) = &l_285;
                /* statement id: 286 */
                assert (l_434 == &l_285);
                l_433 = l_435;
                /* statement id: 287 */
                assert (l_433 == &l_436);
            }
            else
            { /* block id: 288 */
                (**l_407) = (**l_306);
                for (l_393 = (-30); (l_393 <= 16); l_393 = safe_add_func_uint64_t_u_u(l_393, 6))
                { /* block id: 292 */
                    (*l_307) = (**l_306);
                }
            }
            (**l_407) = l_432;
            l_439 = l_432;
        }
    }
    else
    { /* block id: 299 */
        int32_t *l_447 = &l_68;
        int32_t **l_449 = &l_447;
        int32_t ***l_448 = &l_449;
        (**l_449) = (safe_div_func_int16_t_s_s((safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((+p_47) | (p_45 ^ (p_46 <= p_45))), p_43)), ((((void*)0 == l_447) == __builtin_parityl((l_448 == (void*)0))) | 0xFFCAE45B15ACA5EFLL))), p_47));
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_52(int32_t  p_53, int64_t  p_54, uint64_t  p_55, const uint64_t  p_56, uint32_t  p_57)
{ /* block id: 164 */
    uint32_t l_292 = 0x0E1A3B80L;
    int32_t *l_293 = (void*)0;
    int32_t l_295 = 0xCC242C42L;
    int32_t *l_294 = &l_295;
    uint64_t l_300 = 0UL;
    (*l_294) = func_105((safe_add_func_int16_t_s_s((-8L), (safe_sub_func_int16_t_s_s(0x9D5EL, l_292)))));
    (*l_294) = p_54;
    (*l_294) = (((safe_mod_func_uint64_t_u_u(((safe_rshift_func_uint16_t_u_u((0x86DC195B6DF9734ELL | p_56), (func_87((0x1319C18CBA6210C8LL < (0xB9CACC8E27A5988CLL >= (*l_294)))) < ((-6L) || func_91((*l_294)))))) ^ p_54), (*l_294))) ^ (*l_294)) < p_57);
    return l_300;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_65(int16_t  p_66, int16_t  p_67)
{ /* block id: 38 */
    uint16_t l_261 = 65535UL;
    int32_t l_283 = (-7L);
    int32_t *l_282 = &l_283;
    if ((safe_rshift_func_int16_t_s_u(0xA339L, 13)))
    { /* block id: 39 */
        int16_t l_95 = 0x4B05L;
        int32_t *l_279 = (void*)0;
        int32_t l_280 = 9L;
        int32_t *l_281 = &l_280;
        l_280 = (safe_mod_func_int32_t_s_s((safe_add_func_int16_t_s_s(((safe_add_func_int16_t_s_s(p_66, (safe_sub_func_int32_t_s_s(func_79((safe_lshift_func_uint16_t_u_s((safe_div_func_int32_t_s_s(__builtin_bswap64(__builtin_ffs((safe_mul_func_uint16_t_u_u((((0x4F2D89188B9ABC19LL ^ 0L) < (1UL | 0x1FDA6603FA8B742DLL)) == func_87((((safe_sub_func_uint64_t_u_u(p_67, func_91((!(!l_95))))) > (-7L)) == 0x3DD4L))), l_261)))), p_67)), l_95))), l_261)))) | 0UL), 7L)), 0x8AB03692L));
        (*l_281) = p_67;
    }
    else
    { /* block id: 159 */
        int32_t **l_284 = &l_282;
        (*l_284) = l_282;
        (*l_284) = (void*)0;
        /* statement id: 161 */
        assert (l_282 == 0);
    }
    /* facts after branching */
    assert (l_282 == 0 || l_282 == &l_283);
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_79(int16_t  p_80)
{ /* block id: 145 */
    int32_t l_264 = 0x4C63FC51L;
    int32_t ***l_267 = (void*)0;
    int32_t l_277 = 0xA332A192L;
    int32_t *l_276 = &l_277;
    int32_t **l_278 = (void*)0;
    for (p_80 = 0; (p_80 == 24); p_80 = safe_add_func_int32_t_s_s(p_80, 1))
    { /* block id: 148 */
        int32_t l_266 = (-1L);
        int32_t *l_265 = &l_266;
        int32_t ****l_268 = &l_267;
        (*l_265) = l_264;
        if (p_80)
            break;
        if (p_80)
            break;
        (*l_268) = l_267;
    }
    (*l_276) = (~((l_264 < (safe_sub_func_int64_t_s_s(p_80, (safe_div_func_uint32_t_u_u(l_264, p_80))))) >= (__builtin_clz((~(~0x1C8B06D9L))) == p_80)));
    l_276 = &l_277;
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_87(uint32_t  p_88)
{ /* block id: 142 */
    int32_t *l_258 = (void*)0;
    int32_t **l_259 = &l_258;
    int32_t l_260 = 0x82C1F301L;
    (*l_259) = l_258;
    return l_260;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_91(int64_t  p_92)
{ /* block id: 40 */
    int16_t l_102 = 0x99D4L;
    int32_t l_255 = (-1L);
    int32_t *l_257 = (void*)0;
    int32_t **l_256 = &l_257;
    l_255 = ((func_96(p_92, l_102, (((safe_div_func_uint64_t_u_u(l_102, l_102)) && (0x1C5AB2A44BF8E16DLL < (func_105((p_92 | 0xF8F643D9D76C132DLL)) < ((l_102 == p_92) && 0x1A6CL)))) || p_92), p_92, l_102) > l_102) | l_102);
    (*l_256) = &l_255;
    /* statement id: 138 */
    assert (l_257 == &l_255);
    (**l_256) = p_92;
    (*l_257) = 0xAAEB0DE8L;
    return p_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_96(uint32_t  p_97, int32_t  p_98, int32_t  p_99, uint64_t  p_100, uint16_t  p_101)
{ /* block id: 44 */
    int32_t l_112 = 0xC40B387EL;
    int32_t *l_111 = &l_112;
    int32_t **l_113 = &l_111;
    int16_t l_148 = 0L;
    int32_t l_149 = (-8L);
    int32_t *l_163 = &l_112;
    l_111 = &p_99;
    /* statement id: 45 */
    assert (l_111 == &p_99);
    (*l_113) = &l_112;
    /* statement id: 46 */
    assert (l_111 == &l_112);
    for (p_98 = 23; (p_98 <= 2); p_98 = safe_sub_func_int64_t_s_s(p_98, 1))
    { /* block id: 49 */
        uint64_t l_125 = 0x77DDBA47A58E81D8LL;
        int32_t **l_128 = &l_111;
        int32_t l_206 = (-1L);
        int16_t l_207 = 1L;
        int16_t l_250 = 1L;
    }
    return p_100;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_105(uint64_t  p_106)
{ /* block id: 41 */
    int32_t * const l_107 = (void*)0;
    int32_t l_110 = 0x41BD8E70L;
    int32_t *l_109 = &l_110;
    int32_t **l_108 = &l_109;
    (*l_108) = l_107;
    /* statement id: 42 */
    assert (l_109 == 0);
    return p_106;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 103
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 146
   depth: 2, occurrence: 23
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 21, occurrence: 2
   depth: 24, occurrence: 2

XXX total number of pointers: 79

XXX times a variable address is taken: 96
XXX times a pointer is dereferenced on RHS: 108
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 31
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 92
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 16
   depth: 3, occurrence: 6
XXX times a pointer is compared with null: 27
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 320

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 161
   level: 2, occurrence: 58
   level: 3, occurrence: 22
   level: 4, occurrence: 3
   level: 5, occurrence: 11
XXX number of pointers point to pointers: 41
XXX number of pointers point to scalars: 38
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.1
XXX average alias set size: 1.13

XXX times a non-volatile is read: 585
XXX times a non-volatile is write: 256
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 7

XXX stmts: 126
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 22
   depth: 2, occurrence: 12
   depth: 3, occurrence: 20
   depth: 4, occurrence: 18
   depth: 5, occurrence: 21

XXX percentage a fresh-made variable is used: 18.3
XXX percentage an existing variable is used: 81.7
********************* end of statistics **********************/

