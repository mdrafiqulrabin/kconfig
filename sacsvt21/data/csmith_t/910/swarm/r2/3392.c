/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3619223728
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 6;
   const unsigned f1 : 3;
   signed f2 : 25;
   const signed f3 : 1;
   signed f4 : 12;
   unsigned f5 : 19;
   int32_t  f6;
   const unsigned f7 : 29;
   int32_t  f8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_28(void);
static int16_t  func_40(uint16_t  p_41, int32_t  p_42, uint32_t  p_43, uint32_t  p_44);
static uint16_t  func_54(uint32_t  p_55);
static uint32_t  func_56(const uint32_t  p_57);
static int32_t  func_60(struct S0  p_61, struct S0  p_62, uint32_t  p_63, struct S0  p_64);
static struct S0  func_66(uint32_t  p_67, struct S0  p_68);
static uint32_t  func_70(uint16_t  p_71, uint16_t  p_72);
static const uint16_t  func_76(uint32_t  p_77, const int16_t  p_78, int16_t  p_79, int32_t  p_80);
static int32_t  func_87(struct S0  p_88, int32_t  p_89, int16_t  p_90, uint32_t  p_91, uint32_t  p_92);
static int32_t  func_97(uint16_t  p_98, int32_t  p_99, const int32_t  p_100, const int16_t  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = (-4);
    int32_t l_30 = (-6);
    int32_t l_50 = 0x6ED73489;
    struct S0 l_388 = {2,1,681,0,12,550,0xA1822A15,10800,-1};
    l_30 = (l_29 = l_29);
    for (l_30 = 18; (l_30 == (-21)); l_30 -= 8)
    { /* block id: 41 */
        int16_t l_48 = 1;
        int32_t l_381 = 0x582CEDBF;
        int32_t l_382 = (-1);
        struct S0 l_389 = {0,0,-5748,-0,-3,186,0xD2992FD4,17212,-9};
        uint32_t l_392 = 0U;
        int32_t l_405 = 0x5AB965B3;
        uint32_t l_426 = 1U;
        int32_t l_427 = (-5);
        for (l_29 = 25; (l_29 >= (-22)); l_29 -= 1)
        { /* block id: 44 */
            uint16_t l_35 = 1U;
            int32_t l_49 = 3;
            l_382 = ((l_35 ^ (l_381 ^= ((int16_t)((uint16_t)0x268F - (uint16_t)func_40((l_50 = ((((l_49 ^= ((uint32_t)(l_30 || __builtin_bswap32(((-(uint32_t)l_29) <= 0x5A527720))) + (uint32_t)((((l_48 | 0x8E01) & l_35) ^ l_48) | l_48))) || l_48) && 0x5618D7C5) == l_30)), l_35, l_29, l_48)) >> (int16_t)l_35))) > (-8));
            l_382 = func_70(l_29, l_48);
        }
        if ((((int16_t)((uint16_t)l_48 << (uint16_t)(l_29 < ((l_29 <= (-(uint16_t)(l_389.f4 = (0U & (((0xBC03DAD8 | (l_50 > (0xBB46 > func_60(l_388, l_389, l_388.f3, l_389)))) <= l_388.f6) > l_388.f6))))) >= 4U))) << (int16_t)5) <= 0x65D6))
        { /* block id: 225 */
            int32_t l_390 = 0;
            uint16_t l_395 = 0xCA1B;
            l_390 = l_388.f5;
            l_50 = ((((-7) || (+l_390)) & l_390) | l_390);
            l_389.f2 = ((l_29 = ((((0x2A97 > l_392) | l_382) & (l_390 && ((uint32_t)l_392 % (uint32_t)l_395))) < l_388.f1)) & ((uint16_t)0U << (uint16_t)13));
        }
        else
        { /* block id: 230 */
            uint32_t l_400 = 4294967295U;
            for (l_381 = 0; (l_381 != (-29)); --l_381)
            { /* block id: 233 */
                int32_t l_422 = 5;
                const int32_t l_425 = (-1);
                l_50 = (l_400 > ((l_427 &= ((uint16_t)((func_70(((int16_t)(l_389.f6 == (l_382 |= l_405)) << (int16_t)14), __builtin_ffsll(((uint32_t)l_400 % (uint32_t)((uint16_t)((int16_t)((uint32_t)((((uint16_t)((((((int16_t)((int16_t)l_388.f4 >> (int16_t)l_422) >> (int16_t)func_97(l_400, ((int16_t)(l_389.f4 |= l_392) >> (int16_t)9), l_425, l_400)) || l_388.f8) && 1) != 65535U) == 0) << (uint16_t)13) ^ l_426) < l_400) % (uint32_t)l_425) << (int16_t)l_422) % (uint16_t)l_388.f4)))) > l_422) && l_389.f3) << (uint16_t)1)) < l_422));
                if (l_48)
                    break;
            }
        }
    }
    return l_388.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_40(uint16_t  p_41, int32_t  p_42, uint32_t  p_43, uint32_t  p_44)
{ /* block id: 47 */
    uint32_t l_53 = 0xCD890F6D;
    int32_t l_59 = 0x33AED5EB;
    p_42 = ((int16_t)l_53 >> (int16_t)func_54((l_59 = func_56(l_53))));
    l_59 = 0x42A22D07;
    return l_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_54(uint32_t  p_55)
{ /* block id: 52 */
    struct S0 l_65 = {6,1,-182,0,-48,710,0,520,1};
    uint16_t l_69 = 65527U;
    uint32_t l_73 = 0xB7607968;
    int32_t l_356 = 0xF3CD9F60;
    int32_t l_359 = 1;
    uint16_t l_360 = 9U;
    int32_t l_362 = 8;
    uint16_t l_373 = 0U;
    l_65.f2 = (p_55 ^ (l_362 &= func_60(l_65, func_66(((l_359 = (l_69 > (p_55 < ((func_70(l_65.f6, l_73) ^ (l_356 = p_55)) > (((int16_t)p_55 + (int16_t)l_65.f0) <= l_65.f7))))) < l_360), l_65), p_55, l_65)));
    l_362 = ((uint16_t)(((uint16_t)((int32_t)(((int32_t)p_55 - (int32_t)((uint16_t)__builtin_clzll((l_373 ^= l_360)) % (uint16_t)p_55)) == ((int16_t)p_55 % (int16_t)(+((uint16_t)l_65.f6 + (uint16_t)p_55)))) % (int32_t)l_356) - (uint16_t)(l_362 | l_360)) || 0xB786) << (uint16_t)l_65.f1);
    for (l_65.f6 = (-9); (l_65.f6 >= 26); l_65.f6 += 1)
    { /* block id: 213 */
        return l_65.f5;
    }
    return l_362;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_56(const uint32_t  p_57)
{ /* block id: 48 */
    uint32_t l_58 = 0x7E3C2391;
    l_58 = 7;
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_60(struct S0  p_61, struct S0  p_62, uint32_t  p_63, struct S0  p_64)
{ /* block id: 204 */
    uint32_t l_361 = 0x812A1256;
    l_361 = p_62.f4;
    return p_61.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_66(uint32_t  p_67, struct S0  p_68)
{ /* block id: 202 */
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_70(uint16_t  p_71, uint16_t  p_72)
{ /* block id: 53 */
    uint16_t l_81 = 4U;
    int16_t l_86 = (-1);
    int32_t l_349 = 2;
    int32_t l_350 = 1;
    int32_t l_355 = 0x00E15890;
    l_350 = (((l_349 = ((uint16_t)p_71 - (uint16_t)func_76(l_81, __builtin_popcount(p_71), (((((uint32_t)p_71 - (uint32_t)(p_72 != ((0U >= (l_81 < ((int16_t)(0xE6F95D92 || l_81) >> (int16_t)11))) && (-2)))) >= l_81) <= l_81) >= l_86), l_86))) >= 0xCEDB) || p_71);
    l_350 = ((l_355 = func_97(__builtin_bswap32(((int16_t)(l_349 & ((((uint16_t)p_71 >> (uint16_t)l_355) && __builtin_clzl(l_349)) || 4U)) - (int16_t)p_72)), l_350, l_349, p_71)) <= l_86);
    l_350 = l_355;
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_76(uint32_t  p_77, const int16_t  p_78, int16_t  p_79, int32_t  p_80)
{ /* block id: 54 */
    struct S0 l_93 = {5,0,-3707,0,-26,690,6,7657,0x03114314};
    int32_t l_96 = (-1);
    int32_t l_108 = 0xEB876032;
    int32_t l_109 = 0;
    int32_t l_110 = 0xA910B13A;
    int32_t l_113 = 0x74272ABD;
    int32_t l_116 = 0xB2FD71B9;
    int16_t l_312 = 2;
    if (func_87(l_93, (((uint16_t)(p_77 | (p_79 = ((l_96 >= func_97((((uint32_t)((uint32_t)((uint32_t)(l_110 = (l_109 &= (l_108 = 0xD4DDF0F5))) % (uint32_t)__builtin_parityl((l_116 = ((int16_t)(0x38A40F94 | (((l_113 = l_93.f0) | l_96) || ((0 && func_56(((int16_t)l_113 >> (int16_t)4))) != 0xF63C109E))) - (int16_t)8U)))) + (uint32_t)p_80) - (uint32_t)l_93.f1) != p_77), p_79, p_77, l_93.f8)) | (-5)))) + (uint16_t)p_80) ^ l_93.f0), l_93.f5, p_77, l_93.f6))
    { /* block id: 143 */
        int32_t l_287 = 0x5D1AB092;
        int32_t l_292 = 0xA4C053BF;
        int32_t l_311 = 0x464EB96B;
        for (p_77 = 0; (p_77 != 30); p_77 += 1)
        { /* block id: 146 */
            int32_t l_286 = 0x368CCABF;
            l_287 ^= (1 == l_286);
            l_292 = (((uint16_t)(l_109 ^= (((int16_t)(1 != 0x249F298B) % (int16_t)(l_287 = __builtin_clz(l_93.f5))) || (p_79 && p_78))) << (uint16_t)8) && (((l_110 = ((l_108 = ((-9) ^ (((l_286 && (l_286 <= 0U)) | l_286) > l_287))) >= p_78)) != p_78) != 0x080ABBFA));
        }
        for (l_292 = (-1); (l_292 == (-29)); l_292 -= 1)
        { /* block id: 156 */
            uint32_t l_295 = 0x21AC2331;
            l_287 = func_97((0x6D78 > l_295), ((int32_t)((uint32_t)0U + (uint32_t)(l_93.f0 | ((l_295 & (65530U | l_295)) == ((func_97((+func_56((((l_109 ^= __builtin_clzl(l_295)) | l_116) && l_108))), l_287, l_93.f8, p_79) || p_79) < p_80)))) + (int32_t)0x3854A16A), l_93.f1, p_78);
        }
        if (((l_93.f1 < (p_80 || ((((uint16_t)l_93.f4 % (uint16_t)(__builtin_popcountl((l_93.f7 >= ((uint16_t)(p_78 || (l_292 = ((uint16_t)((int16_t)l_292 + (int16_t)((l_287 = l_93.f1) > (65529U > ((int16_t)(l_116 = l_292) - (int16_t)0x3A59)))) - (uint16_t)p_77))) - (uint16_t)p_80))) | l_311)) <= l_312) <= 0x52159D9B))) ^ p_80))
        { /* block id: 163 */
            uint32_t l_313 = 2U;
            struct S0 l_318 = {4,1,-4015,-0,-48,600,-1,21505,-10};
            l_287 ^= (l_313 = l_292);
            l_292 = ((uint16_t)((int16_t)(l_93.f5 == (((l_318.f2 = ((func_87(l_318, (p_78 ^ ((uint32_t)(((uint16_t)p_78 << (uint16_t)((uint16_t)l_312 + (uint16_t)func_87(l_93, l_292, l_318.f6, l_108, l_318.f6))) > p_80) % (uint32_t)2)), p_79, p_78, p_77) > p_77) && p_80)) <= p_77) ^ p_80)) << (int16_t)6) << (uint16_t)p_77);
            if (l_93.f1)
            { /* block id: 168 */
                return p_77;
            }
            else
            { /* block id: 170 */
                return l_318.f7;
            }
        }
        else
        { /* block id: 173 */
            int16_t l_331 = 0x8768;
            int32_t l_344 = (-1);
            uint32_t l_345 = 4294967295U;
            if (((int16_t)(p_79 = __builtin_bswap32((l_292 == ((l_113 = ((((uint16_t)((uint16_t)(l_331 || (((uint16_t)((uint16_t)(((l_344 = ((uint32_t)__builtin_bswap32((l_331 >= (((int16_t)0x4D2E >> (int16_t)4) > (0x5B78 || (l_93.f1 > l_116))))) % (uint32_t)(((uint16_t)((((int16_t)__builtin_bswap64(((l_110 = l_93.f8) == l_93.f7)) % (int16_t)p_80) && l_292) != p_80) - (uint16_t)l_312) && l_331))) != 1U) > l_345) - (uint16_t)p_79) % (uint16_t)l_292) ^ 5)) >> (uint16_t)p_78) >> (uint16_t)12) <= 1U) && p_77)) | 1)))) >> (int16_t)l_331))
            { /* block id: 178 */
                return p_80;
            }
            else
            { /* block id: 180 */
                uint16_t l_348 = 1U;
                for (l_331 = 24; (l_331 < 12); l_331 -= 5)
                { /* block id: 183 */
                    l_348 = ((-10) || p_80);
                }
                return l_93.f0;
            }
        }
    }
    else
    { /* block id: 189 */
        l_116 = p_78;
    }
    l_93.f2 = l_108;
    return l_110;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_87(struct S0  p_88, int32_t  p_89, int16_t  p_90, uint32_t  p_91, uint32_t  p_92)
{ /* block id: 77 */
    int32_t l_168 = 0x9286A1EB;
    int32_t l_171 = 1;
    uint32_t l_182 = 0xE2D54445;
    int16_t l_183 = 0xFA69;
    int32_t l_184 = (-1);
    uint32_t l_269 = 4294967287U;
    l_184 &= (func_56(((uint16_t)((((uint16_t)(p_88.f2 & (l_168 |= (p_90 = p_88.f4))) << (uint16_t)8) <= ((((uint16_t)(l_171 && (((p_88.f0 = ((l_171 && (p_91 = ((int16_t)(0x08B6 < (((int16_t)(l_171 != l_171) << (int16_t)l_171) != ((uint32_t)(((int16_t)1 >> (int16_t)p_91) < l_182) + (uint32_t)p_89))) << (int16_t)p_88.f7))) && l_183)) & 8) <= l_182)) << (uint16_t)l_171) || l_182) < (-5))) == 1) << (uint16_t)l_182)) <= 0x2F66);
    for (l_168 = 0; (l_168 == 5); l_168 += 8)
    { /* block id: 85 */
        const int16_t l_203 = 0xFC1B;
        int32_t l_232 = (-1);
        int32_t l_237 = 0xBDD47E45;
        int32_t l_279 = 1;
        int32_t l_280 = (-1);
        uint32_t l_281 = 6U;
        p_89 = (-3);
        for (p_88.f8 = 0; (p_88.f8 == 7); p_88.f8 += 9)
        { /* block id: 89 */
            int32_t l_200 = 0x60D7D18F;
            int32_t l_204 = 0x24888C0F;
            int32_t l_227 = 0x4BB7FEAD;
            l_184 = ((((uint16_t)((int32_t)(func_56(p_88.f2) ^ (p_89 = p_92)) - (int32_t)0xFA8AF15E) - (uint16_t)((int32_t)((uint16_t)(((p_90 || ((((int32_t)p_88.f2 + (int32_t)(-(int32_t)l_200)) ^ ((((int16_t)((-1) ^ (p_88.f8 ^ p_88.f5)) + (int16_t)l_200) > l_200) || p_88.f0)) >= (-9))) && p_88.f3) | p_88.f0) >> (uint16_t)p_88.f2) % (int32_t)p_88.f7)) || l_203) >= l_184);
            l_184 = (p_89 ^= l_203);
            p_89 = ((l_204 ^ l_203) && ((uint16_t)(p_88.f6 != ((int32_t)((int16_t)((int16_t)((uint16_t)((l_171 = p_88.f5) || l_200) + (uint16_t)l_168) + (int16_t)(p_88.f8 || (l_204 &= (((0xB090 == (p_88.f7 != l_203)) | l_203) || 0x19B726C3)))) % (int16_t)p_88.f3) + (int32_t)p_88.f7)) << (uint16_t)1));
            p_88.f4 = func_97(((uint32_t)(((int16_t)((l_232 = ((uint32_t)(l_204 = ((-6) | ((l_203 == l_203) ^ ((uint16_t)((int32_t)p_88.f3 - (int32_t)((uint16_t)l_171 >> (uint16_t)2)) + (uint16_t)(l_227 = 7))))) + (uint32_t)((uint32_t)l_168 + (uint32_t)((int16_t)p_90 % (int16_t)0x241C)))) && p_91) - (int16_t)0x73B6) || 0x295D) % (uint32_t)4294967295U), l_200, l_203, l_203);
        }
        for (l_184 = (-3); (l_184 <= (-14)); l_184 -= 4)
        { /* block id: 104 */
            uint16_t l_249 = 0xC18A;
            int32_t l_270 = 7;
            p_89 |= ((uint16_t)l_237 - (uint16_t)(p_90 = p_88.f6));
            if ((+(+1U)))
            { /* block id: 107 */
                uint16_t l_267 = 0xA68F;
                int32_t l_273 = (-1);
                for (l_183 = (-10); (l_183 < (-30)); --l_183)
                { /* block id: 110 */
                    int32_t l_246 = 0xAC8D5ACD;
                    if ((__builtin_parityll((l_246 ^= ((int16_t)l_203 << (int16_t)9))) && (p_88.f3 < (((uint16_t)(l_249 > 0xF2620083) << (uint16_t)l_184) > l_232))))
                    { /* block id: 112 */
                        uint32_t l_250 = 1U;
                        return l_250;
                    }
                    else
                    { /* block id: 114 */
                        uint16_t l_257 = 65532U;
                        int32_t l_262 = 0xBE9AE68F;
                        int32_t l_268 = 1;
                        l_270 = ((int32_t)(l_249 && ((((int16_t)(((int32_t)((0x60F2 >= (l_268 |= (l_267 = (l_257 & ((int16_t)((((p_88.f2 |= (((((int16_t)(l_262 = (p_90 ^= l_249)) << (int16_t)0) && l_182) < p_89) < ((func_97((((int32_t)(((uint16_t)l_249 + (uint16_t)l_246) & 3) + (int32_t)l_168) != 0x35C5DC2C), p_88.f6, p_91, p_88.f3) < (-7)) | p_88.f7))) ^ 0xA6676201) && l_257) && p_88.f4) >> (int16_t)l_203))))) != l_257) - (int32_t)0xB60EE2D5) == 9) % (int16_t)0xA610) == l_249) | l_269)) - (int32_t)p_88.f6);
                    }
                    for (l_267 = (-17); (l_267 <= 31); l_267 += 1)
                    { /* block id: 124 */
                        p_89 &= (0 > p_88.f4);
                        p_88.f2 |= (p_88.f6 != l_267);
                    }
                }
                p_88.f4 = p_89;
                l_273 = (p_88.f6 <= p_88.f0);
            }
            else
            { /* block id: 131 */
                int32_t l_275 = 1;
                int32_t l_276 = 0xE72F24C6;
                p_88.f2 = ((+1U) != (func_97(p_88.f0, p_91, p_88.f7, p_88.f3) <= ((((p_91 > p_88.f8) && __builtin_popcountll((l_270 = p_90))) ^ 1U) | 0x1B90)));
                l_237 &= ((--p_91) != l_183);
            }
        }
        --l_281;
    }
    l_184 = p_88.f5;
    p_88.f4 = func_56(l_183);
    return l_171;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_97(uint16_t  p_98, int32_t  p_99, const int32_t  p_100, const int16_t  p_101)
{ /* block id: 60 */
    int32_t l_123 = 0x3ED55ED5;
    int32_t l_143 = 0x9FDC9EDE;
    int32_t l_144 = 3;
    int32_t l_163 = 0xF92F1956;
    for (p_99 = 23; (p_99 < 6); p_99 -= 7)
    { /* block id: 63 */
        int32_t l_119 = 0;
        int32_t l_120 = (-10);
        int16_t l_124 = 0xEBEB;
        uint32_t l_145 = 6U;
        l_120 = __builtin_ffsll(l_119);
        l_120 = ((((uint16_t)l_123 >> (uint16_t)0) == l_124) ^ ((int16_t)(0x1667F30D && ((uint32_t)(((((int16_t)p_98 - (int16_t)func_56((((((int16_t)l_123 << (int16_t)((uint16_t)((int16_t)(l_144 = ((uint32_t)0xBBEE733D % (uint32_t)__builtin_parityl((l_143 |= ((~((((~(4294967289U == l_123)) ^ ((int16_t)(l_120 != 0U) >> (int16_t)p_98)) && p_99) && p_100)) || 0xC33A66A3))))) >> (int16_t)6) << (uint16_t)14)) ^ p_101) >= 9U) && l_124))) <= 0x2609) == l_145) <= p_101) - (uint32_t)p_101)) >> (int16_t)p_101));
        l_163 = ((int16_t)(~((int32_t)(((int16_t)0x8637 >> (int16_t)p_99) != ((__builtin_ctzll(p_98) <= (((uint32_t)__builtin_popcountll(((int16_t)((uint16_t)p_99 >> (uint16_t)(+(((l_144 = (l_143 = ((uint16_t)l_120 >> (uint16_t)l_145))) <= (-(uint32_t)0xFC91578A)) | l_120))) >> (int16_t)15)) + (uint32_t)p_100) != p_99)) > 0U)) + (int32_t)4294967295U)) % (int16_t)0x997F);
    }
    l_144 = (l_163 |= p_100);
    l_144 = p_100;
    return p_98;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 92
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 10
XXX times a single bitfield on LHS: 13
XXX times a single bitfield on RHS: 56

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 24
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 4
   depth: 21, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 2

XXX total number of pointers: 0

XXX times a non-volatile is read: 371
XXX times a non-volatile is write: 120
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 83
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 14
   depth: 2, occurrence: 19
   depth: 3, occurrence: 12
   depth: 4, occurrence: 3
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 19.9
XXX percentage an existing variable is used: 80.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

