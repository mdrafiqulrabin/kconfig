/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      322652120
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   volatile uint16_t  f1;
   uint32_t  f2;
   uint32_t  f3;
   uint32_t  f4;
};

union U1 {
   const int8_t  f0;
   const volatile int8_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 4294967295UL;
static int32_t *g_38 = (void*)0;
static int32_t g_40 = (-1L);
static volatile int32_t g_79 = 4L;/* VOLATILE GLOBAL g_79 */
static int32_t g_92 = (-1L);
static const union U0 g_120 = {18446744073709551608UL};/* VOLATILE GLOBAL g_120 */
static union U0 g_122 = {0x4A170516L};/* VOLATILE GLOBAL g_122 */
static const uint16_t g_138 = 65531UL;
static union U0 g_158 = {1UL};/* VOLATILE GLOBAL g_158 */
static volatile union U1 *g_201 = (void*)0;
static int32_t **g_207 = (void*)0;
static int32_t ***g_206 = &g_207;
static int32_t ****g_205 = &g_206;
static union U1 g_218 = {0x01L};/* VOLATILE GLOBAL g_218 */
static const int32_t *g_266 = (void*)0;
static const int32_t **g_265 = &g_266;
static union U1 *g_465 = &g_218;
static union U1 **g_464 = &g_465;
static union U1 ***g_463 = &g_464;
static volatile union U1 g_471 = {-7L};/* VOLATILE GLOBAL g_471 */
static volatile union U1 *g_470 = &g_471;
static int32_t *g_488 = &g_40;
static const volatile union U0 *g_589 = (void*)0;
static const volatile union U0 **g_588 = &g_589;
static int32_t *g_601 = &g_92;
static int32_t *g_629 = &g_92;
static const volatile union U0 ***g_748 = &g_588;
static const volatile union U0 ****g_747 = &g_748;
static union U0 *g_799 = &g_158;
static union U0 **g_798 = &g_799;
static union U0 ***g_797 = &g_798;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_26(void);
static int32_t * func_27(int64_t  p_28, int16_t  p_29);
static int32_t * func_32(uint64_t  p_33, int64_t  p_34);
static uint32_t  func_54(int32_t * const * p_55, int8_t  p_56, int32_t ** p_57, int32_t  p_58);
static int32_t ** func_59(int32_t  p_60);
static int32_t * func_61(int64_t  p_62, int8_t  p_63, int32_t * p_64, int32_t * p_65);
static const int32_t ** func_85(int64_t  p_86, uint32_t  p_87);
static int32_t * func_95(uint32_t  p_96, int8_t  p_97, int64_t  p_98, int32_t ** p_99);
static int64_t  func_106(int32_t * p_107);
static const union U0 * func_108(int32_t ** p_109, int32_t ** p_110, uint16_t  p_111, uint16_t  p_112);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_38 g_40 g_265 g_206 g_207 g_629 g_122.f3 g_158.f4 g_120.f1 g_601 g_92 g_122.f2 g_122.f4 g_120.f0 g_471.f1 g_120.f4 g_205 g_158.f0 g_138 g_122.f1 g_158.f2 g_201 g_158.f3 g_218.f1 g_218.f0
 * writes: g_40 g_38 g_79 g_266 g_92 g_122.f3 g_122.f4 g_158.f4 g_158.f3 g_797 g_122.f0 g_201 g_205 g_158.f0
 */
static uint32_t  func_26(void)
{ /* block id: 36 */
    int64_t l_31 = 0x8F4F823AAF5BFB66LL;
    int32_t *l_801 = &g_40;
    l_801 = func_27((+g_5), l_31);
    /* statement id: 597 */
    //assert (g_38 == 0 || g_38 == &g_92 || g_38 == dangling || g_38 == &g_40);
    assert (g_266 == 0 || g_266 == &g_40 || g_266 == &g_92);
    //assert (g_797 == &g_798 || g_797 == dangling);
    assert (l_801 == &g_92);
    return (*l_801);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_38 g_40 g_265 g_206 g_207 g_629 g_122.f3 g_158.f4 g_120.f1 g_601 g_92 g_122.f2 g_122.f4 g_120.f0 g_471.f1 g_120.f4 g_205 g_158.f0 g_138 g_122.f1 g_158.f2 g_201 g_158.f3 g_218.f1 g_218.f0
 * writes: g_40 g_38 g_79 g_266 g_92 g_122.f3 g_122.f4 g_158.f4 g_158.f3 g_797 g_122.f0 g_201 g_205 g_158.f0
 */
static int32_t * func_27(int64_t  p_28, int16_t  p_29)
{ /* block id: 37 */
    uint16_t l_37 = 0x3D6CL;
    int32_t * const l_39 = &g_40;
    int32_t **l_43 = &g_38;
    union U1 **l_726 = &g_465;
    int64_t l_800 = 0xA09FC66C6BABE01ELL;
    (*l_43) = func_32(((uint16_t)g_5 << (uint16_t)l_37), (g_38 != l_39));
    /* statement id: 41 */
    assert (g_38 == &g_40);
    (*l_39) = 0x27F355C0L;
    (*l_39) = ((uint64_t)(*l_39) + (uint64_t)(+((int32_t)(((int64_t)((uint16_t)(!0xC638299FA9EF8169LL) << (uint16_t)p_29) + (int64_t)g_40) < 0x9C79EBEFL) / (int32_t)func_54(&l_39, (*l_39), func_59((**l_43)), p_29))));
    /* statement id: 505 */
    if (__builtin_parityll(g_122.f4))
    { /* block id: 506 */
        union U1 ***l_691 = &g_464;
        int32_t l_693 = 0x46ED0206L;
        uint32_t l_700 = 18446744073709551606UL;
        int32_t *l_720 = &l_693;
lbl_727:
        if ((*g_38))
        { /* block id: 507 */
            union U1 ***l_690 = &g_464;
            int32_t l_692 = 3L;
            (**l_43) = ((l_690 == l_691) != (l_692 >= (l_693 > (((*g_601) || (*g_38)) >= g_40))));
        }
        else
        { /* block id: 509 */
            (*g_629) = ((int16_t)p_29 << (int16_t)((int16_t)(((uint16_t)((**l_43) ^ (0x55694AB10429B1DELL != 0x237769C58AD98EB3LL)) >> (uint16_t)1) || l_700) >> (int16_t)l_700));
        }
        for (g_122.f4 = 0; (g_122.f4 <= 50); g_122.f4 += 3)
        { /* block id: 514 */
            int32_t *l_734 = &g_92;
            for (p_29 = 0; (p_29 < (-15)); p_29 -= 1)
            { /* block id: 517 */
                union U1 *l_709 = &g_218;
                int32_t l_721 = (-1L);
                if ((**l_43))
                    break;
                (*g_38) = 1L;
                if (((int64_t)g_120.f0 % (int64_t)((uint64_t)g_122.f2 + (uint64_t)((l_709 != (void*)0) != g_120.f0))))
                { /* block id: 520 */
                    int32_t *l_718 = (void*)0;
                    for (g_40 = (-29); (g_40 > 21); g_40 += 1)
                    { /* block id: 523 */
                        int32_t *l_719 = &g_92;
                    }
                    l_720 = l_718;
                    /* statement id: 527 */
                    assert (l_720 == 0);
                    (*g_265) = func_32(l_721, l_721);
                    /* statement id: 528 */
                    assert (g_266 == &g_40);
                }
                else
                { /* block id: 529 */
                    for (g_158.f4 = 0; (g_158.f4 != 2); g_158.f4 += 1)
                    { /* block id: 532 */
                        (**l_43) = (((uint64_t)0xCC52C69E44E8891ALL / (uint64_t)p_29) & ((((void*)0 == l_726) >= (__builtin_ffsll(p_28) != ((void*)0 != &g_588))) & l_721));
                        if (p_28)
                            goto lbl_727;
                    }
                    /* facts after for loop */
                    if ((&l_693 != (void*)0))
                    { /* block id: 536 */
                        (*g_38) = ((uint16_t)(**l_43) << (uint16_t)1);
                        (*g_38) = func_106(func_61(g_471.f1, (((uint16_t)p_28 - (uint16_t)p_28) & (*g_38)), (*l_43), &l_721));
                        if (p_28)
                            continue;
                    }
                    else
                    { /* block id: 540 */
                        (*g_38) = (*g_601);
                    }
                    for (g_158.f3 = 7; (g_158.f3 > 29); g_158.f3 += 1)
                    { /* block id: 545 */
                        return l_734;
                        /* statement id: 546 */
                        //assert (func_27_rv == &g_92);
                    }
                    /* facts after for loop */
                }
            }
        }
        /* facts after for loop */
    }
    else
    { /* block id: 551 */
        int32_t * const *l_737 = &g_629;
        int32_t l_740 = 1L;
        int32_t *l_752 = &g_40;
        union U0 *l_794 = &g_158;
        union U0 **l_793 = &l_794;
        union U0 ***l_792 = &l_793;
        (*g_265) = func_61(p_28, ((uint16_t)__builtin_popcount(((*l_39) <= func_54(l_737, ((g_5 > 65535UL) ^ ((uint16_t)(**l_737) + (uint16_t)(g_120.f4 | ((void*)0 == (*g_205))))), l_43, (*g_38)))) << (uint16_t)l_740), (*l_43), &l_740);
        /* statement id: 552 */
        assert (g_266 == &l_740);
        if ((**l_737))
        { /* block id: 553 */
            int32_t *l_754 = &g_40;
            union U0 ****l_795 = (void*)0;
            union U0 ****l_796 = (void*)0;
            for (p_28 = (-12); (p_28 < (-3)); p_28 += 1)
            { /* block id: 556 */
                uint16_t l_753 = 0x331EL;
                int32_t ***l_760 = (void*)0;
                int32_t *l_765 = (void*)0;
            }
            g_797 = l_792;
            /* statement id: 589 */
            assert (g_797 == &l_793);
        }
        else
        { /* block id: 590 */
            (*l_39) = ((void*)0 == &l_43);
        }
        /* facts after branching */
        assert (g_797 == &g_798 || g_797 == &l_793);
        (*g_265) = func_95(g_158.f0, l_800, p_29, &l_752);
        /* statement id: 593 */
        //assert (g_38 == 0 || g_38 == &g_92 || g_38 == dangling || g_38 == &g_40);
        assert (g_266 == 0 || g_266 == &g_40 || g_266 == &g_92);
        (*l_39) = (*l_39);
    }
    /* facts after branching */
    //assert (g_38 == 0 || g_38 == &g_92 || g_38 == dangling || g_38 == &g_40);
    assert (g_266 == 0 || g_266 == &g_40 || g_266 == &g_92);
    //assert (g_797 == &g_798 || g_797 == dangling);
    return &g_92;
    /* statement id: 596 */
    //assert (func_27_rv == &g_92);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_40
 */
static int32_t * func_32(uint64_t  p_33, int64_t  p_34)
{ /* block id: 38 */
    int32_t *l_42 = &g_40;
    (*l_42) = (+__builtin_ia32_crc32qi(p_34, p_33));
    return l_42;
    /* statement id: 40 */
    //assert (func_32_rv == &g_40);
}


/* ------------------------------------------ */
/* 
 * reads : g_629 g_265 g_122.f3 g_40 g_158.f4 g_38 g_5 g_120.f1 g_601 g_92 g_122.f2
 * writes: g_92 g_266 g_122.f3 g_79
 */
static uint32_t  func_54(int32_t * const * p_55, int8_t  p_56, int32_t ** p_57, int32_t  p_58)
{ /* block id: 487 */
    uint32_t l_677 = 0x357E33C8L;
    int32_t *l_678 = (void*)0;
    int32_t *l_679 = (void*)0;
    (*g_629) = l_677;
    l_678 = (*p_55);
    /* statement id: 489 */
    assert (l_678 == &g_40 || l_678 == &g_92);
    (*g_265) = l_679;
    /* statement id: 490 */
    assert (g_266 == 0);
    for (g_122.f3 = 0; (g_122.f3 != 8); g_122.f3 += 8)
    { /* block id: 493 */
        int32_t *l_685 = &g_40;
        if ((**p_55))
        { /* block id: 494 */
            int32_t *l_684 = &g_92;
            (*g_601) = __builtin_ffsl((((int32_t)((0xB207A452E01F9268LL > func_106(func_61(p_58, g_158.f4, l_684, l_685))) | (((uint32_t)__builtin_ffsll(p_58) + (uint32_t)(*l_685)) || 0x79373BE726E5963ALL)) % (int32_t)(*g_38)) <= 0UL));
            (*l_684) = ((int32_t)(*l_684) - (int32_t)(*l_684));
            (*l_684) = (*l_685);
            return p_58;
        }
        else
        { /* block id: 499 */
            (*g_265) = (void*)0;
            return g_122.f2;
        }
    }
    /* facts after for loop */
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_40 g_265 g_206 g_207
 * writes: g_79 g_266
 */
static int32_t ** func_59(int32_t  p_60)
{ /* block id: 43 */
    uint16_t l_70 = 0xDEDBL;
    int32_t * const * const l_315 = (void*)0;
    const int32_t **l_316 = &g_266;
    int32_t *****l_323 = &g_205;
    union U1 *l_363 = &g_218;
    union U0 *l_380 = &g_122;
    int32_t *l_413 = &g_40;
    int16_t l_435 = 0xE3FEL;
    int8_t l_480 = (-9L);
    int32_t *l_489 = &g_92;
    int32_t l_615 = 7L;
    int32_t *l_659 = &g_40;
    int32_t l_676 = 0L;
    (*g_265) = func_61(__builtin_parity(((uint64_t)((uint16_t)((-3L) == __builtin_clz(l_70)) >> (uint16_t)g_40) / (uint64_t)p_60)), __builtin_ctz(((uint16_t)(((int16_t)(-1L) << (int16_t)10) > (p_60 < ((uint16_t)(&g_40 == (void*)0) * (uint16_t)l_70))) << (uint16_t)2)), &g_40, &g_40);
    /* statement id: 231 */
    assert (g_266 == &g_40);
    return (*g_206);
    /* statement id: 486 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_79
 */
static int32_t * func_61(int64_t  p_62, int8_t  p_63, int32_t * p_64, int32_t * p_65)
{ /* block id: 44 */
    int32_t l_82 = 0x1010F193L;
    uint16_t l_90 = 0x264AL;
    const int32_t *l_276 = &g_92;
    union U1 *l_284 = &g_218;
    union U1 **l_283 = &l_284;
    union U1 ***l_282 = &l_283;
    g_79 = 0xD911ACA8L;
    return p_65;
    /* statement id: 230 */
    //assert (func_61_rv == &g_40 || func_61_rv == 0 || func_61_rv == &g_92 || func_61_rv == &l_472 || func_61_rv == &l_374 || func_61_rv == &p_60 || func_61_rv == &l_721 || func_61_rv == &l_740);
}


/* ------------------------------------------ */
/* 
 * reads : g_38 g_40 g_265
 * writes: g_92
 */
static const int32_t ** func_85(int64_t  p_86, uint32_t  p_87)
{ /* block id: 50 */
    int32_t *l_91 = &g_92;
    (*l_91) = 0x36206CBCL;
    (*l_91) = (*g_38);
    (*l_91) = (0x7048L | (-1L));
    for (p_87 = 0; (p_87 != 37); p_87 += 1)
    { /* block id: 56 */
        uint32_t l_100 = 0xAF792179L;
        int32_t **l_101 = (void*)0;
        int32_t *l_264 = (void*)0;
    }
    return g_265;
    /* statement id: 183 */
    //assert (func_85_rv == &g_266);
}


/* ------------------------------------------ */
/* 
 * reads : g_38 g_40 g_5 g_120.f1 g_122.f2 g_138 g_122.f3 g_122.f0 g_122.f1 g_122.f4 g_158.f2 g_158.f0 g_92 g_158.f3 g_201 g_205 g_218.f1 g_218.f0 g_158.f4
 * writes: g_122.f0 g_38 g_92 g_158.f3 g_122.f3 g_201 g_205 g_158.f0
 */
static int32_t * func_95(uint32_t  p_96, int8_t  p_97, int64_t  p_98, int32_t ** p_99)
{ /* block id: 57 */
    union U0 *l_123 = (void*)0;
    int32_t l_126 = 0xBD28F7D0L;
    int32_t l_127 = 0x18558EF1L;
    int32_t **l_161 = &g_38;
    int8_t l_172 = (-8L);
    uint16_t l_221 = 6UL;
    int32_t l_222 = 9L;
    if (((int32_t)(*g_38) - (int32_t)(p_96 != ((func_106(&g_92) <= (l_123 != l_123)) == ((p_98 > l_126) ^ ((p_98 && l_127) != g_122.f2))))))
    { /* block id: 64 */
        int32_t *l_130 = &g_40;
        union U0 *l_157 = &g_158;
        for (l_126 = (-5); (l_126 != (-21)); l_126 -= 4)
        { /* block id: 67 */
            int32_t *l_131 = &l_127;
            int32_t **l_133 = &l_131;
            int32_t ***l_132 = &l_133;
            int16_t l_152 = 0xFF45L;
            (*l_131) = (g_122.f2 || ((void*)0 == l_130));
            (*l_132) = (void*)0;
            /* statement id: 69 */
            assert (l_133 == 0);
            if (func_106(&l_126))
            { /* block id: 70 */
                const uint16_t l_145 = 2UL;
                if ((((uint16_t)((int16_t)g_138 + (int16_t)(0x8758A71D4F065869LL < ((int16_t)p_96 << (int16_t)(0x8564F5E9L != (*g_38))))) >> (uint16_t)(l_127 < ((p_98 < (((int16_t)((int32_t)l_145 % (int32_t)(*g_38)) >> (int16_t)p_97) < g_120.f1)) >= p_97))) >= 65535UL))
                { /* block id: 71 */
                    int32_t l_146 = 1L;
                    (*l_131) = (*g_38);
                    (*l_131) = p_97;
                    l_146 = (&l_127 == l_130);
                }
                else
                { /* block id: 75 */
                    int32_t *l_147 = &g_92;
                    return l_147;
                    /* statement id: 76 */
                    //assert (func_95_rv == &g_92);
                }
                return &g_92;
                /* statement id: 78 */
                //assert (func_95_rv == &g_92);
            }
            else
            { /* block id: 79 */
                int32_t *l_148 = (void*)0;
                int32_t l_149 = (-1L);
                if (((g_122.f3 & (func_106(&l_126) && func_106(l_148))) < (((l_149 & (((int16_t)(l_126 > p_97) * (int16_t)(*l_130)) <= 18446744073709551615UL)) <= 0xCF631B5FL) >= l_152)))
                { /* block id: 80 */
                    (*l_131) = (*g_38);
                    for (g_122.f0 = (-10); (g_122.f0 != 54); g_122.f0 += 8)
                    { /* block id: 84 */
                        return &g_40;
                        /* statement id: 85 */
                        //assert (func_95_rv == &g_40);
                    }
                }
                else
                { /* block id: 87 */
                    (*l_131) = (l_127 || ((int16_t)(g_138 <= __builtin_popcountl((*l_130))) * (int16_t)((func_106(&g_40) <= (l_157 == (void*)0)) <= ((int16_t)g_40 << (int16_t)1))));
                }
                l_148 = (void*)0;
                if ((*l_131))
                    break;
            }
            return &g_92;
            /* statement id: 93 */
            //assert (func_95_rv == &g_92);
        }
        l_126 = l_127;
    }
    else
    { /* block id: 96 */
        l_126 = (*g_38);
    }
    (*l_161) = (void*)0;
    /* statement id: 99 */
    assert (g_38 == 0);
    if (((uint32_t)(((int16_t)((((int64_t)l_127 + (int64_t)(((uint64_t)((uint16_t)(l_172 == l_126) * (uint16_t)(g_122.f1 && (g_122.f4 ^ (g_158.f2 == (&g_92 != (void*)0))))) - (uint64_t)p_97) >= g_40)) <= 0xA95DAA2CA7106077LL) != l_127) / (int16_t)0xD310L) >= g_40) % (uint32_t)1L))
    { /* block id: 100 */
        uint32_t l_179 = 0x840ACBBFL;
        int32_t *l_180 = &g_40;
        if ((0x29FA7991L & ((uint16_t)(((((uint32_t)(((int64_t)l_179 + (int64_t)p_98) == (l_180 == l_180)) - (uint32_t)(((int64_t)(0x8C6BL && (&g_158 != l_123)) - (int64_t)p_98) == g_158.f0)) > p_96) <= 1UL) >= p_98) << (uint16_t)(*l_180))))
        { /* block id: 101 */
            uint16_t l_187 = 0UL;
            int32_t *l_188 = &l_127;
            (*l_188) = (((uint32_t)(&g_158 != &g_120) - (uint32_t)(p_98 == ((void*)0 == l_161))) != ((((((uint16_t)(g_138 && p_96) >> (uint16_t)1) >= 0x0A321F15L) < g_40) > l_187) != l_187));
        }
        else
        { /* block id: 103 */
            for (p_96 = (-21); (p_96 == 58); p_96 += 6)
            { /* block id: 106 */
                int32_t ***l_191 = &l_161;
                if ((*l_180))
                    break;
                (*l_191) = &l_180;
                /* statement id: 108 */
                assert (l_161 == &l_180);
            }
            /* facts after for loop */
            assert (l_161 == &l_180 || l_161 == &g_38);
        }
        /* facts after branching */
        assert (l_161 == &l_180 || l_161 == &g_38);
    }
    else
    { /* block id: 111 */
        int32_t l_209 = 0xD02C9C02L;
        int16_t l_210 = 1L;
        union U1 *l_217 = &g_218;
        int32_t *l_223 = &l_127;
        int32_t *l_235 = &l_222;
        for (g_92 = (-28); (g_92 > 19); g_92 += 1)
        { /* block id: 114 */
            int32_t *l_200 = (void*)0;
            for (g_158.f3 = 24; (g_158.f3 == 44); g_158.f3 += 6)
            { /* block id: 117 */
                int32_t ***l_198 = &l_161;
                volatile union U1 **l_202 = (void*)0;
                volatile union U1 **l_203 = (void*)0;
                volatile union U1 **l_204 = &g_201;
                int32_t *****l_208 = &g_205;
                for (g_122.f3 = 0; (g_122.f3 <= 5); g_122.f3 += 1)
                { /* block id: 120 */
                    int32_t ****l_199 = &l_198;
                    (*l_161) = (void*)0;
                    (*l_199) = l_198;
                }
                /* facts after for loop */
                l_200 = (*l_161);
                (*l_204) = g_201;
                (*l_208) = g_205;
            }
            /* facts after for loop */
            l_210 = l_209;
            return l_200;
            /* statement id: 129 */
            //assert (func_95_rv == 0);
        }
        for (l_209 = (-26); (l_209 >= 14); l_209 += 5)
        { /* block id: 133 */
            uint64_t l_224 = 1UL;
            int32_t *l_229 = &g_92;
            for (l_127 = (-7); (l_127 <= (-9)); l_127 -= 1)
            { /* block id: 136 */
                int32_t *l_220 = &g_92;
                (*l_220) = (0xA8BF02E390C49C4BLL <= ((int64_t)(l_217 == l_217) + (int64_t)(-(int32_t)__builtin_ia32_crc32qi(p_98, p_98))));
                (*l_220) = ((l_221 < 1L) < ((*l_220) ^ (l_222 || l_209)));
            }
            (*l_161) = l_223;
            /* statement id: 140 */
            assert (g_38 == &l_127);
            (*g_38) = ((void*)0 == &l_217);
            if (__builtin_ffs(l_224))
            { /* block id: 142 */
                int32_t *l_236 = &g_92;
                volatile union U1 **l_238 = &g_201;
                volatile union U1 ***l_237 = &l_238;
                if (((int64_t)((uint32_t)(*l_223) + (uint32_t)func_106((*l_161))) % (int64_t)p_98))
                { /* block id: 143 */
                    int64_t l_232 = 6L;
                    (**l_161) = func_106(l_229);
                    for (l_172 = 0; (l_172 == (-15)); l_172 -= 1)
                    { /* block id: 147 */
                        (*l_223) = 0x514DC0AAL;
                        l_223 = (*l_161);
                        (**l_161) = (l_232 < ((0x3DA0L < ((uint16_t)0x6B0DL << (uint16_t)13)) && (p_97 <= func_106(l_235))));
                        (*l_229) = func_106(l_236);
                    }
                    l_229 = &g_40;
                    /* statement id: 153 */
                    assert (l_229 == &g_40);
                }
                else
                { /* block id: 154 */
                    (*l_223) = func_106(l_236);
                }
                /* facts after branching */
                assert (l_229 == &g_92 || l_229 == &g_40);
                (*l_237) = &g_201;
                if (((int16_t)(*l_236) / (int16_t)p_98))
                { /* block id: 158 */
                    l_236 = (*l_161);
                    /* statement id: 159 */
                    assert (l_236 == &l_127);
                }
                else
                { /* block id: 160 */
                    uint16_t l_247 = 0x8269L;
                    int32_t *l_256 = &l_127;
                    (*l_223) = ((((uint64_t)((int64_t)(((int16_t)((*g_38) && 0x3844FDB9L) >> (int16_t)13) > g_122.f4) % (int64_t)l_247) * (uint64_t)(g_158.f3 <= ((((uint16_t)((uint64_t)0xE2487D8A3BB3813ALL + (uint64_t)(0x6962B2ED70B56FAFLL ^ (*l_235))) << (uint16_t)((uint64_t)((int32_t)((((-7L) | g_218.f1) >= (**l_161)) <= 9UL) / (int32_t)(*l_223)) + (uint64_t)g_40)) > (*l_229)) <= g_138))) > 0L) < p_96);
                    return l_229;
                    /* statement id: 162 */
                    //assert (g_38 == dangling);
                    //assert (func_95_rv == &g_92 || func_95_rv == &g_40);
                }
                /* facts after branching */
                assert (l_236 == &l_127);
                l_229 = l_236;
                /* statement id: 164 */
                assert (l_229 == &l_127);
            }
            else
            { /* block id: 165 */
                int32_t *l_259 = (void*)0;
                (*l_161) = l_229;
                /* statement id: 166 */
                assert (g_38 == &g_92);
                (*l_161) = &l_209;
                /* statement id: 167 */
                assert (g_38 == &l_209);
                (*l_161) = l_229;
                /* statement id: 168 */
                assert (g_38 == &g_92);
                for (g_158.f0 = 0; (g_158.f0 == 59); g_158.f0 += 4)
                { /* block id: 171 */
                    (*l_161) = l_259;
                    /* statement id: 172 */
                    assert (g_38 == 0);
                    if (p_96)
                        continue;
                    (*l_161) = (*l_161);
                }
                /* facts after for loop */
                assert (g_38 == 0 || g_38 == &g_92);
            }
            /* facts after branching */
            assert (g_38 == 0 || g_38 == &g_92 || g_38 == &l_127);
            assert (l_229 == &g_92 || l_229 == &l_127);
        }
        /* facts after for loop */
        assert (g_38 == 0 || g_38 == &g_92 || g_38 == &l_127);
    }
    /* facts after branching */
    assert (g_38 == 0 || g_38 == &g_92 || g_38 == &l_127);
    //assert (l_161 == dangling || l_161 == &g_38);
    l_127 = (((uint64_t)(0xCFDD99D9L >= (((&p_99 != (void*)0) < g_138) > (g_218.f0 & (g_218.f0 <= ((int16_t)g_92 << (int16_t)g_40))))) % (uint64_t)18446744073709551615UL) < g_158.f4);
    return &g_40;
    /* statement id: 180 */
    //assert (g_38 == 0 || g_38 == &g_92 || g_38 == dangling);
    //assert (func_95_rv == &g_40);
}


/* ------------------------------------------ */
/* 
 * reads : g_38 g_40 g_5 g_120.f1
 * writes:
 */
static int64_t  func_106(int32_t * p_107)
{ /* block id: 58 */
    int32_t **l_113 = &g_38;
    const union U0 *l_121 = &g_122;
    l_121 = func_108(l_113, &g_38, (((int16_t)(**l_113) << (int16_t)9) == g_5), (**l_113));
    /* statement id: 62 */
    assert (l_121 == &g_120);
    return g_120.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const union U0 * func_108(int32_t ** p_109, int32_t ** p_110, uint16_t  p_111, uint16_t  p_112)
{ /* block id: 59 */
    int32_t *l_116 = &g_40;
    int32_t **l_117 = (void*)0;
    int32_t **l_118 = &l_116;
    const union U0 *l_119 = &g_120;
    (*l_118) = l_116;
    return l_119;
    /* statement id: 61 */
    //assert (func_108_rv == &g_120);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_40, "g_40", print_hash_value);
    transparent_crc(g_79, "g_79", print_hash_value);
    transparent_crc(g_92, "g_92", print_hash_value);
    transparent_crc(g_120.f0, "g_120.f0", print_hash_value);
    transparent_crc(g_120.f1, "g_120.f1", print_hash_value);
    transparent_crc(g_120.f2, "g_120.f2", print_hash_value);
    transparent_crc(g_120.f3, "g_120.f3", print_hash_value);
    transparent_crc(g_120.f4, "g_120.f4", print_hash_value);
    transparent_crc(g_122.f0, "g_122.f0", print_hash_value);
    transparent_crc(g_122.f1, "g_122.f1", print_hash_value);
    transparent_crc(g_122.f2, "g_122.f2", print_hash_value);
    transparent_crc(g_122.f3, "g_122.f3", print_hash_value);
    transparent_crc(g_122.f4, "g_122.f4", print_hash_value);
    transparent_crc(g_138, "g_138", print_hash_value);
    transparent_crc(g_158.f0, "g_158.f0", print_hash_value);
    transparent_crc(g_158.f1, "g_158.f1", print_hash_value);
    transparent_crc(g_158.f2, "g_158.f2", print_hash_value);
    transparent_crc(g_158.f3, "g_158.f3", print_hash_value);
    transparent_crc(g_158.f4, "g_158.f4", print_hash_value);
    transparent_crc(g_218.f0, "g_218.f0", print_hash_value);
    transparent_crc(g_218.f1, "g_218.f1", print_hash_value);
    transparent_crc(g_471.f0, "g_471.f0", print_hash_value);
    transparent_crc(g_471.f1, "g_471.f1", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 187
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 19
breakdown:
   depth: 1, occurrence: 143
   depth: 2, occurrence: 32
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 4
   depth: 6, occurrence: 1
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1

XXX total number of pointers: 186

XXX times a variable address is taken: 198
XXX times a pointer is dereferenced on RHS: 139
breakdown:
   depth: 1, occurrence: 110
   depth: 2, occurrence: 28
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 139
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 7
XXX times a pointer is compared with null: 35
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 934

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 559
   level: 2, occurrence: 235
   level: 3, occurrence: 127
   level: 4, occurrence: 72
   level: 5, occurrence: 29
XXX number of pointers point to pointers: 84
XXX number of pointers point to scalars: 77
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.6
XXX average alias set size: 1.4

XXX times a non-volatile is read: 892
XXX times a non-volatile is write: 385
XXX times a volatile is read: 18
XXX    times read thru a pointer: 0
XXX times a volatile is write: 2
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 575
XXX percentage of non-volatile access: 98.5

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 131
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 13
   depth: 2, occurrence: 25
   depth: 3, occurrence: 24
   depth: 4, occurrence: 25
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 15.8
XXX percentage an existing variable is used: 84.2
********************* end of statistics **********************/

