/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2038480020
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 24;
   const int16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   int32_t  f4;
   uint16_t  f5;
   int32_t  f6;
   int16_t  f7;
   const int32_t  f8;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_30(void);
static int16_t  func_34(struct S0  p_35, uint32_t  p_36, uint32_t  p_37, int32_t  p_38);
static uint32_t  func_39(int32_t  p_40, int16_t  p_41, int32_t  p_42, uint16_t  p_43, uint16_t  p_44);
static uint16_t  func_46(int32_t  p_47);
static int32_t * func_61(struct S0  p_62, uint32_t  p_63, uint32_t  p_64);
static struct S0  func_65(int32_t * p_66, uint16_t  p_67, int32_t ** p_68);
static int32_t * func_73(uint32_t  p_74, int32_t ** p_75, int32_t * p_76);
static uint32_t  func_77(uint32_t  p_78, int32_t ** p_79, int32_t * p_80, uint16_t  p_81, int32_t ** p_82);
static int32_t ** func_84(const int32_t ** p_85, int32_t * p_86, int32_t * p_87, const int32_t  p_88);
static const int32_t ** func_89(int32_t  p_90, uint16_t  p_91, int32_t * p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 0xAF0A9B27L;
    for (l_31 = 0; (l_31 != (-4)); --l_31)
    { /* block id: 39 */
        uint32_t l_45 = 0x639E6A41L;
        struct S0 l_52 = {2649,0x4374L,0xC914A3A6L,0x7D04549CL,2L,65535UL,0x3550E352L,-1L,0x8D535DD2L};
        uint16_t l_970 = 65531UL;
        int32_t *l_1218 = &l_52.f3;
        uint16_t l_1228 = 65535UL;
        (*l_1218) = (func_34((func_39(l_31, l_45, l_31, func_46(((((uint16_t)l_31 >> (uint16_t)6) < ((int16_t)2L << (int16_t)10)) != (l_52 , l_52.f0))), __builtin_bswap64(l_970)) , l_52), l_52.f2, l_31, l_52.f7) | 1L);
        (*l_1218) = (!__builtin_ctzll((l_31 , (l_31 & ((l_31 ^ ((0xA8AE6BB1L != ((((((int16_t)((int16_t)(*l_1218) << (int16_t)(((((((int16_t)(*l_1218) + (int16_t)(*l_1218)) < l_31) && ((l_31 > (*l_1218)) && 65535UL)) , (*l_1218)) <= l_1228) | 4294967295UL)) - (int16_t)0xA1EBL) || (*l_1218)) ^ (*l_1218)) < l_31) < (*l_1218))) , l_31)) != l_31)))));
    }
    for (l_31 = 0; (l_31 >= 6); l_31 += 1)
    { /* block id: 747 */
        int16_t l_1231 = 0x084BL;
        return l_1231;
    }
    return l_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_34(struct S0  p_35, uint32_t  p_36, uint32_t  p_37, int32_t  p_38)
{ /* block id: 563 */
    int32_t l_981 = 0L;
    struct S0 l_984 = {72,0xE89CL,0x8BAC1A91L,0xE3BB9BAAL,-1L,0xC50FL,1L,0x7045L,0xA5F53979L};
    struct S0 *l_983 = &l_984;
    struct S0 **l_982 = &l_983;
    struct S0 l_994 = {742,0L,0xFD2EADCBL,-2L,0x39C8899CL,0xB9A2L,0L,0xBAC2L,8L};
    const int32_t *l_999 = &l_981;
    const int32_t **l_998 = &l_999;
    int32_t ****l_1011 = (void*)0;
    int32_t *l_1021 = &l_981;
    int32_t **l_1020 = &l_1021;
    uint32_t l_1022 = 1UL;
    uint32_t l_1173 = 1UL;
    struct S0 *l_1204 = &l_994;
    struct S0 *****l_1214 = (void*)0;
    for (p_38 = 8; (p_38 == (-4)); p_38--)
    { /* block id: 566 */
        struct S0 **l_985 = (void*)0;
        int32_t l_992 = 1L;
        int32_t ***l_1007 = (void*)0;
        int32_t ****l_1006 = &l_1007;
        const struct S0 *l_1041 = (void*)0;
        const struct S0 **l_1040 = &l_1041;
        const struct S0 ***l_1039 = &l_1040;
        const struct S0 ****l_1038 = &l_1039;
        int32_t **l_1071 = (void*)0;
        struct S0 ***l_1155 = &l_985;
        struct S0 ****l_1154 = &l_1155;
        uint32_t l_1190 = 0x8F316D2CL;
        int32_t *l_1194 = &l_984.f3;
        p_35.f3 = p_35.f6;
    }
    (*l_1021) = (-(int32_t)((uint32_t)__builtin_parity((((*l_999) < (p_35.f7 && p_35.f1)) < (*l_999))) - (uint32_t)((p_38 <= p_35.f6) >= ((0x5C2699FFL ^ (l_1011 != l_1011)) < (**l_998)))));
    return p_35.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_39(int32_t  p_40, int16_t  p_41, int32_t  p_42, uint16_t  p_43, uint16_t  p_44)
{ /* block id: 559 */
    int32_t l_971 = 0xBAEE4264L;
    int32_t *l_972 = (void*)0;
    int32_t *l_973 = (void*)0;
    int32_t l_975 = 0x58D5AA53L;
    int32_t *l_974 = &l_975;
    int32_t **l_976 = &l_973;
    (*l_974) = l_971;
    (*l_976) = (p_42 , &l_975);
    /* statement id: 561 */
    assert (l_973 == &l_975);
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_46(int32_t  p_47)
{ /* block id: 40 */
    int32_t *l_59 = (void*)0;
    int32_t l_70 = 0x3B22489AL;
    int32_t *l_69 = &l_70;
    int32_t **l_969 = &l_59;
    for (p_47 = (-9); (p_47 == 23); p_47 += 1)
    { /* block id: 43 */
        int32_t l_55 = 0xF54AB100L;
        int32_t **l_60 = &l_59;
        for (l_55 = 0; (l_55 >= (-13)); l_55--)
        { /* block id: 46 */
            uint16_t l_58 = 1UL;
            l_58 = p_47;
        }
        (*l_60) = l_59;
        if (p_47)
            continue;
    }
    (*l_969) = func_61(func_65(l_69, (*l_69), &l_59), p_47, __builtin_ctzll(__builtin_parityl(((int16_t)(((p_47 != p_47) && p_47) && (&p_47 != (void*)0)) << (int16_t)(*l_69)))));
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_61(struct S0  p_62, uint32_t  p_63, uint32_t  p_64)
{ /* block id: 471 */
    uint16_t l_742 = 0x961BL;
    int32_t l_759 = 0x2DF8A49EL;
    int32_t *l_758 = &l_759;
    int32_t **l_757 = &l_758;
    const uint32_t l_762 = 0x06AA32E5L;
    int32_t ***l_804 = &l_757;
    int32_t ****l_803 = &l_804;
    int32_t *l_848 = &l_759;
    int32_t *l_852 = (void*)0;
    int32_t *l_854 = (void*)0;
    struct S0 l_868 = {2899,0L,0x1C486C4AL,0L,0xA599F174L,0xFD50L,0x9E4BE71DL,0xE5C2L,0x21D435B5L};
    struct S0 *l_867 = &l_868;
    struct S0 **l_866 = &l_867;
    struct S0 ***l_872 = (void*)0;
    struct S0 ****l_871 = &l_872;
    uint32_t l_888 = 0x2CDBB00FL;
    int32_t **l_906 = &l_848;
    struct S0 *l_939 = &l_868;
    int32_t *l_946 = &l_868.f3;
    int32_t *l_951 = &l_759;
    int32_t *l_952 = &l_868.f3;
    int32_t *l_954 = (void*)0;
    int32_t *l_958 = &l_759;
    int32_t *l_962 = (void*)0;
    int32_t *l_963 = &l_759;
    int32_t *l_964 = &l_868.f3;
    int32_t *l_965 = &l_759;
    int32_t *l_966 = &l_868.f3;
    int32_t *l_967 = &l_868.f3;
    int32_t *l_968 = (void*)0;
lbl_924:
    if (__builtin_popcount(((l_742 ^ p_62.f5) , ((int32_t)(p_62 , ((uint16_t)p_62.f3 % (uint16_t)(l_742 , p_64))) + (int32_t)l_742))))
    { /* block id: 472 */
        struct S0 **l_755 = (void*)0;
        struct S0 ***l_754 = &l_755;
        struct S0 ****l_753 = &l_754;
        int32_t l_756 = 0x83A32D90L;
        int32_t **l_760 = &l_758;
        int32_t l_761 = 0x1BDB505DL;
        int32_t *l_845 = &l_761;
        int32_t *l_849 = &l_756;
    }
    else
    { /* block id: 505 */
        int32_t **l_853 = &l_848;
        (*l_848) = ((*l_848) , (l_853 == (void*)0));
        return l_854;
        /* statement id: 507 */
        //assert (func_61_rv == 0);
    }
    if (((*l_757) != (void*)0))
    { /* block id: 509 */
        const uint32_t l_858 = 18446744073709551615UL;
        int32_t *****l_859 = (void*)0;
        int32_t *l_860 = &l_759;
        const uint32_t l_863 = 0x62958B64L;
        struct S0 ****l_873 = &l_872;
        if (((uint16_t)((**l_757) , (4L <= ((!l_858) < ((void*)0 == l_859)))) - (uint16_t)0x2AAAL))
        { /* block id: 510 */
            int32_t *l_861 = (void*)0;
            return l_861;
            /* statement id: 511 */
            //assert (func_61_rv == 0);
        }
        else
        { /* block id: 512 */
            int32_t l_865 = 0x020A1549L;
            p_62.f3 = p_63;
            (*l_860) = (((!(l_863 , func_77((((((p_62.f3 , (!((l_865 , (l_865 < (l_866 == &l_867))) || (__builtin_bswap32(((uint16_t)((((l_871 != l_873) == __builtin_parityll(((((void*)0 != l_873) , 5L) , (***l_804)))) ^ 0xDBCFL) , 0x5082L) << (uint16_t)p_62.f8)) , l_865)))) != p_62.f6) > 0xFC9CL) , (void*)0) == l_860), (**l_803), (**l_804), p_62.f3, (*l_804)))) | p_62.f1) | p_62.f2);
        }
    }
    else
    { /* block id: 516 */
        uint32_t l_876 = 0xB169BE2FL;
        int32_t ****l_886 = &l_804;
        struct S0 *l_899 = &l_868;
        int32_t *l_925 = &l_759;
        int32_t *l_947 = &l_868.f3;
        int32_t *l_949 = &l_759;
        int32_t *l_955 = &l_868.f3;
        int32_t *l_956 = &l_868.f3;
        int32_t *l_957 = &l_759;
        int32_t *l_959 = &l_868.f3;
        int32_t *l_960 = &l_759;
        int32_t *l_961 = &l_868.f3;
        for (p_62.f5 = 0; (p_62.f5 == 27); p_62.f5 += 1)
        { /* block id: 519 */
            int32_t **l_877 = &l_854;
            const int32_t l_887 = 0xB91D2134L;
            int32_t ****l_900 = (void*)0;
            struct S0 **l_916 = &l_867;
            int32_t *l_950 = (void*)0;
            int32_t *l_953 = &l_759;
            (*l_877) = (*l_877);
            l_888 = ((int16_t)__builtin_parity(((uint32_t)0x40043BFAL % (uint32_t)((uint16_t)((0x509F4633L || ((int16_t)__builtin_clzl(p_62.f1) >> (int16_t)l_876)) == (((void*)0 != l_886) || l_887)) + (uint16_t)p_62.f8))) >> (int16_t)p_62.f6);
            if ((****l_886))
                break;
            for (l_868.f3 = 0; (l_868.f3 > 28); l_868.f3 += 4)
            { /* block id: 525 */
                const int32_t l_905 = 0xE5BF9467L;
                int32_t l_909 = 0x9DFC0C5AL;
                int32_t **l_923 = &l_854;
                uint32_t l_940 = 0xAC7140C8L;
                int32_t *****l_941 = &l_900;
                int32_t *l_948 = &l_868.f3;
                if ((((uint16_t)p_63 << (uint16_t)((int16_t)((uint16_t)0x239FL - (uint16_t)((int16_t)(((l_899 != (void*)0) ^ (((void*)0 == l_900) >= ((func_77(p_63, func_84(func_89(p_62.f6, ((int16_t)((int16_t)(0UL == 0x33F1L) >> (int16_t)0) >> (int16_t)p_62.f8), (***l_886)), (*l_757), (**l_804), l_905), (***l_886), (**l_757), l_906) > p_62.f4) , (-1L)))) != p_62.f1) + (int16_t)p_62.f2)) << (int16_t)p_62.f4)) && p_64))
                { /* block id: 526 */
                    struct S0 **l_917 = &l_867;
                    if (((__builtin_clzl(((uint32_t)l_909 + (uint32_t)(****l_886))) , p_62.f2) & ((****l_886) > (((uint16_t)p_62.f0 >> (uint16_t)((uint16_t)(p_64 > ((uint16_t)((**l_757) , (((l_916 != l_917) , l_909) , 7UL)) >> (uint16_t)p_62.f4)) << (uint16_t)p_62.f7)) > 0xBBA76EF4L))))
                    { /* block id: 527 */
                        int32_t **l_918 = (void*)0;
                        int32_t **l_919 = &l_854;
                        (**l_757) = (0x48FA1FE9L >= p_62.f1);
                        (*l_919) = &l_905;
                        /* statement id: 529 */
                        assert (l_854 == &l_905);
                    }
                    else
                    { /* block id: 530 */
                        int32_t *l_920 = &l_759;
                        (*l_877) = l_920;
                        /* statement id: 531 */
                        assert (l_854 == &l_759);
                        (***l_886) = (**l_804);
                    }
                    /* facts after branching */
                    assert (l_854 == &l_759 || l_854 == &l_905);
                }
                else
                { /* block id: 534 */
                    int32_t **l_921 = (void*)0;
                    int32_t *l_922 = &l_759;
                    if (func_77(p_62.f2, l_921, l_922, p_63, l_923))
                    { /* block id: 535 */
                        (**l_906) = (*l_922);
                        if (l_905)
                            goto lbl_924;
                    }
                    else
                    { /* block id: 538 */
                        (***l_803) = l_925;
                    }
                    if (__builtin_ctzl((((!((int16_t)p_62.f0 % (int16_t)((*l_922) , (*l_925)))) >= ((int16_t)((int32_t)(1UL || ((int16_t)__builtin_clzll(((uint16_t)1UL >> (uint16_t)(((uint16_t)(*l_758) << (uint16_t)12) & ((*l_922) > 1L)))) << (int16_t)p_62.f5)) % (int32_t)p_62.f8) + (int16_t)0xF5D1L)) == (****l_803))))
                    { /* block id: 541 */
                        (*l_916) = l_939;
                        if (p_62.f8)
                            continue;
                    }
                    else
                    { /* block id: 544 */
                        uint32_t l_945 = 0xCD59DD36L;
                        if (p_62.f7)
                            break;
                        (*l_922) = l_940;
                        (*l_758) = (((((&l_900 == l_941) == p_62.f8) >= p_62.f3) && ((__builtin_parityll(p_62.f3) , (((int16_t)(***l_804) + (int16_t)(((p_63 , (!((**l_886) == (**l_803)))) > (****l_886)) , p_62.f4)) >= l_945)) || (-8L))) ^ p_62.f0);
                    }
                    return l_950;
                    /* statement id: 549 */
                    //assert (func_61_rv == 0);
                }
                /* facts after branching */
                assert (l_854 == &l_759 || l_854 == &l_905);
                return l_954;
                /* statement id: 551 */
                //assert (func_61_rv == 0);
            }
        }
        return l_962;
        /* statement id: 554 */
        //assert (func_61_rv == 0);
    }
    return l_968;
    /* statement id: 556 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_65(int32_t * p_66, uint16_t  p_67, int32_t ** p_68)
{ /* block id: 52 */
    int32_t l_83 = 0x851AA8C9L;
    int32_t l_326 = (-5L);
    struct S0 l_618 = {3943,0L,0xFB6DB4E2L,8L,0L,0x6435L,-1L,-1L,0x744423EFL};
    int32_t ****l_648 = (void*)0;
    int32_t *****l_647 = &l_648;
    struct S0 *l_656 = &l_618;
    struct S0 **l_655 = &l_656;
    struct S0 ***l_723 = &l_655;
    struct S0 ****l_722 = &l_723;
    struct S0 *****l_730 = &l_722;
    struct S0 l_739 = {3483,0x1EBDL,18446744073709551610UL,0x110AB602L,0L,65533UL,0xF406E2E8L,0x8196L,9L};
    for (p_67 = 16; (p_67 != 8); p_67 -= 2)
    { /* block id: 55 */
        int32_t *l_112 = &l_83;
        int32_t l_325 = 1L;
        (*p_68) = func_73(((65535UL == (((p_67 != p_67) & ((((((func_77(l_83, func_84(func_89(((p_67 | 2L) , ((&l_83 == (void*)0) | ((void*)0 != (*p_68)))), p_67, &l_83), (*p_68), l_112, (*l_112)), l_112, l_83, &l_112) , (void*)0) == l_112) , &l_112) != &l_112) & p_67) & p_67)) | l_325)) | l_326), &l_112, &l_326);
        /* statement id: 345 */
        //assert (l_59 == &l_83);
        (**p_68) = (*l_112);
    }
    /* facts after for loop */
    //assert (l_59 == &l_83 || l_59 == 0);
    (*p_68) = (*p_68);
    (*p_68) = &l_326;
    /* statement id: 349 */
    //assert (l_59 == &l_326);
    for (p_67 = 0; (p_67 != 0); p_67 += 9)
    { /* block id: 352 */
        int32_t **l_623 = (void*)0;
        int32_t ***l_622 = &l_623;
        int32_t ****l_621 = &l_622;
        int32_t *l_659 = &l_326;
        int32_t *l_674 = &l_326;
        struct S0 l_677 = {2745,-10L,0UL,-5L,0x84BFC3E4L,0xAE83L,0xD2AB7805L,0xE1DEL,0x375E350BL};
        struct S0 ***l_689 = &l_655;
        int32_t *****l_698 = &l_621;
    }
    return l_739;
    /* statement id: 470 */
    //assert (l_59 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_73(uint32_t  p_74, int32_t ** p_75, int32_t * p_76)
{ /* block id: 171 */
    struct S0 *l_327 = (void*)0;
    int32_t l_330 = (-2L);
    int32_t l_336 = 0L;
    int32_t *l_335 = &l_336;
    uint32_t l_364 = 0xD3C510A3L;
    int32_t **l_409 = &l_335;
    const int32_t *l_412 = &l_330;
    const int32_t **l_411 = &l_412;
    const int32_t ***l_410 = &l_411;
    int32_t *****l_434 = (void*)0;
    uint16_t l_445 = 1UL;
    struct S0 l_502 = {1979,0x4582L,1UL,0L,-1L,0x941AL,0x067A1E52L,0L,0xCD879DCAL};
    int32_t l_537 = 0xF5D2659EL;
    const uint32_t l_591 = 0xC0FBD897L;
    (**p_75) = ((l_327 == l_327) , (((int32_t)l_330 % (int32_t)0x725EE35BL) > (**p_75)));
    for (l_330 = 0; (l_330 >= (-1)); l_330 -= 1)
    { /* block id: 175 */
        int32_t **l_337 = (void*)0;
        const int32_t ****l_339 = (void*)0;
        uint32_t l_356 = 0xF65F1031L;
        struct S0 l_361 = {212,4L,18446744073709551610UL,0x23B8CB17L,-8L,1UL,1L,4L,0xBABB2D71L};
        int32_t *l_363 = &l_336;
        int32_t *****l_370 = (void*)0;
        int32_t *l_394 = (void*)0;
        uint16_t l_439 = 0xF3C3L;
        struct S0 **l_462 = &l_327;
        int32_t *l_499 = (void*)0;
        struct S0 ***l_588 = &l_462;
        struct S0 ****l_587 = &l_588;
    }
    (*p_76) = (l_591 ^ (func_77(p_74, &l_335, (((((uint32_t)(((*l_412) <= (~p_74)) & (***l_410)) + (uint32_t)(&p_75 != (((void*)0 == &l_411) , (void*)0))) , p_74) != p_74) , (*p_75)), (*l_335), &l_335) != p_74));
    return (*p_75);
    /* statement id: 344 */
    //assert (func_73_rv == &l_83 || func_73_rv == &l_618.f3);
}


/* ------------------------------------------ */
/* 
 * reads : l_83 l_70 l_618.f3
 * writes: l_83 l_70 l_618.f3
 */
static uint32_t  func_77(uint32_t  p_78, int32_t ** p_79, int32_t * p_80, uint16_t  p_81, int32_t ** p_82)
{ /* block id: 156 */
    int32_t l_309 = 0L;
    if (l_309)
    { /* block id: 157 */
        struct S0 l_311 = {2631,8L,0x724607D9L,5L,0xCF519E8AL,8UL,0L,5L,0x04C48C4EL};
        struct S0 *l_310 = &l_311;
        struct S0 **l_312 = &l_310;
        int32_t *l_321 = &l_311.f3;
        int32_t **l_320 = &l_321;
        int32_t ***l_319 = &l_320;
        int32_t ****l_318 = &l_319;
        int32_t *****l_317 = &l_318;
lbl_322:
        (*l_312) = l_310;
        for (l_311.f6 = 0; (l_311.f6 != (-14)); --l_311.f6)
        { /* block id: 161 */
            uint32_t l_315 = 0x131A39DEL;
            (***l_319) = (l_315 < (~((l_317 == &l_318) ^ l_309)));
        }
        if (l_309)
            goto lbl_322;
        (*p_80) = ((p_81 <= (*****l_317)) , (****l_318));
    }
    else
    { /* block id: 166 */
        (*p_80) = (*p_80);
    }
    (*p_80) = ((uint16_t)1UL >> (uint16_t)l_309);
    return l_309;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_84(const int32_t ** p_85, int32_t * p_86, int32_t * p_87, const int32_t  p_88)
{ /* block id: 58 */
    int32_t l_116 = 0x33D27CF1L;
    int32_t *l_118 = (void*)0;
    int32_t **l_117 = &l_118;
    uint16_t l_186 = 0x300DL;
    struct S0 l_192 = {2957,-1L,1UL,0x2EFA2A6CL,0xB9D5BE66L,65531UL,0x15C78119L,4L,1L};
    uint32_t l_215 = 0xC865190EL;
    int32_t ***l_230 = &l_117;
    int32_t ****l_229 = &l_230;
    int32_t **l_241 = &l_118;
    int32_t **l_242 = &l_118;
    int32_t **l_245 = &l_118;
    int32_t **l_257 = &l_118;
    int32_t **l_258 = &l_118;
    int32_t **l_259 = &l_118;
    int32_t **l_260 = &l_118;
    int32_t **l_263 = &l_118;
    int32_t **l_264 = &l_118;
    int32_t **l_265 = &l_118;
    int32_t **l_266 = &l_118;
    int32_t **l_267 = &l_118;
    int32_t **l_269 = &l_118;
    int32_t *l_296 = &l_116;
    int32_t **l_297 = &l_118;
    int32_t **l_298 = &l_296;
    int32_t **l_299 = &l_296;
    int32_t **l_300 = &l_118;
    int32_t **l_301 = &l_118;
    int32_t **l_302 = &l_296;
    int32_t **l_303 = &l_296;
    int32_t **l_304 = &l_296;
    int32_t **l_305 = &l_118;
    int32_t **l_306 = &l_296;
    int32_t **l_307 = &l_118;
    int32_t **l_308 = (void*)0;
    l_116 = (((~(p_88 | ((uint16_t)l_116 >> (uint16_t)4))) , l_117) != &p_86);
    return l_308;
    /* statement id: 155 */
    //assert (func_84_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t ** func_89(int32_t  p_90, uint16_t  p_91, int32_t * p_92)
{ /* block id: 56 */
    const int32_t l_95 = 0x5D18A938L;
    const int32_t *l_94 = &l_95;
    const int32_t **l_93 = &l_94;
    const int32_t **l_96 = &l_94;
    const int32_t **l_97 = &l_94;
    const int32_t **l_98 = &l_94;
    const int32_t **l_99 = &l_94;
    const int32_t **l_100 = &l_94;
    const int32_t **l_101 = &l_94;
    const int32_t **l_102 = &l_94;
    const int32_t **l_103 = &l_94;
    const int32_t **l_104 = &l_94;
    const int32_t **l_105 = &l_94;
    const int32_t **l_106 = &l_94;
    const int32_t **l_107 = &l_94;
    const int32_t **l_108 = &l_94;
    const int32_t **l_109 = &l_94;
    const int32_t **l_110 = &l_94;
    const int32_t **l_111 = (void*)0;
    return l_111;
    /* statement id: 57 */
    //assert (func_89_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 400
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 66
breakdown:
   indirect level: 0, occurrence: 20
   indirect level: 1, occurrence: 16
   indirect level: 2, occurrence: 11
   indirect level: 3, occurrence: 6
   indirect level: 4, occurrence: 10
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 28
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 45
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 22

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 339

XXX times a variable address is taken: 393
XXX times a pointer is dereferenced on RHS: 363
breakdown:
   depth: 1, occurrence: 256
   depth: 2, occurrence: 83
   depth: 3, occurrence: 14
   depth: 4, occurrence: 9
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 185
breakdown:
   depth: 1, occurrence: 156
   depth: 2, occurrence: 26
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 46
XXX times a pointer is compared with address of another variable: 18
XXX times a pointer is compared with another pointer: 22
XXX times a pointer is qualified to be dereferenced: 2195

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 768
   level: 2, occurrence: 269
   level: 3, occurrence: 126
   level: 4, occurrence: 93
   level: 5, occurrence: 60
XXX number of pointers point to pointers: 210
XXX number of pointers point to scalars: 106
XXX number of pointers point to structs: 23
XXX percent of pointers has null in alias set: 24.2
XXX average alias set size: 1.31

XXX times a non-volatile is read: 1931
XXX times a non-volatile is write: 513
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 8

XXX stmts: 76
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 19
   depth: 2, occurrence: 9
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 11.1
XXX percentage an existing variable is used: 88.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

