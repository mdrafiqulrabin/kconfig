/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3547502896
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 6;
   unsigned f1 : 3;
   signed f2 : 25;
   signed f3 : 1;
   unsigned f4 : 12;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_1(void);
static int32_t * func_2(int16_t  p_3, int32_t * p_4, int32_t * p_5, uint32_t  p_6, int32_t  p_7);
static int32_t  func_13(int32_t  p_14, int32_t  p_15, int32_t * p_16);
static struct S0  func_18(int32_t * p_19, struct S0  p_20, const uint16_t  p_21, struct S0  p_22, int32_t * p_23);
static int32_t * func_24(int32_t * p_25, int64_t  p_26, uint32_t  p_27, uint64_t  p_28);
static int32_t  func_31(int32_t * p_32, int32_t * p_33, int32_t * const  p_34, int32_t * p_35);
static int32_t * func_36(const int32_t  p_37, int32_t * p_38, int16_t  p_39);
static uint64_t  func_42(uint16_t  p_43, int16_t  p_44, int32_t  p_45);
static uint32_t  func_46(int32_t  p_47, int32_t * p_48, int32_t * const  p_49, float  p_50, const uint8_t  p_51);
static struct S0  func_52(int32_t * p_53, int32_t  p_54, int32_t * p_55);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_1(void)
{ /* block id: 0 */
    int16_t l_8 = (-5L);
    int32_t l_10 = 0xCDDD1D8FL;
    int32_t *l_9 = &l_10;
    int32_t l_17 = 0xB8F6C218L;
    int32_t l_621 = 0xF6A7CA8EL;
    struct S0 l_662 = {4,0,1152,0,8};
    struct S0 *l_677 = &l_662;
    struct S0 **l_676 = &l_677;
    struct S0 *** const l_675 = &l_676;
    struct S0 *** const *l_674 = &l_675;
    struct S0 *** const **l_673 = &l_674;
    uint8_t l_678 = 255UL;
    const int32_t l_679 = 0x24F423F1L;
    int32_t *l_680 = (void*)0;
    int32_t *l_681 = &l_10;
    uint64_t l_684 = 8UL;
    const int16_t l_685 = 0x950DL;
    int16_t l_691 = 0xCC62L;
    int32_t **l_764 = &l_680;
    int32_t ***l_763 = &l_764;
    const int32_t *l_858 = &l_10;
    const int32_t **l_857 = &l_858;
    const int32_t ***l_856 = &l_857;
    int32_t l_865 = 0x589F6186L;
    int32_t *l_900 = &l_10;
    struct S0 l_955 = {0,0,-1143,-0,14};
    int32_t l_1010 = (-1L);
    int64_t l_1023 = 9L;
    float l_1040 = 0x5.6049A1p-93;
    float *l_1039 = &l_1040;
    int32_t ***l_1100 = &l_764;
    int16_t l_1134 = 0x1776L;
    uint8_t l_1136 = 0x8FL;
    float * const *l_1147 = &l_1039;
    float * const **l_1146 = &l_1147;
    float l_1156 = 0xA.DF9659p-88;
    l_9 = func_2(l_8, l_9, &l_10, ((safe_sub_func_int32_t_s_s(0xB2906C90L, (func_13((*l_9), l_17, &l_10) | ((((safe_lshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s(((0xDE99L < l_17) < l_17), l_8)), 8)) & 0xAA15771CL) > l_8) | l_8)))) < l_17), l_621);
    /* statement id: 234 */
    assert (l_9 == 0);
    (*l_681) = (((+((safe_sub_func_int64_t_s_s((l_17 == 0x6918533BF5915918LL), ((l_8 , l_662) , l_621))) | ((((((safe_rshift_func_int16_t_s_s(7L, 11)) && ((safe_mod_func_uint64_t_u_u(((((((l_621 , (0x04CF2802B0BE02D0LL == (safe_lshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s((((void*)0 != l_673) ^ 1L), l_10)), l_8)), l_662.f4)))) & l_662.f4) <= l_662.f2) , (-10L)) != l_662.f1) == 7L), l_678)) >= 18446744073709551614UL)) >= l_662.f4) != 65533UL) , l_662.f2) && l_679))) ^ l_621) && l_662.f2);
    (****l_674) = func_18(&l_10, func_18(&l_10, func_18(&l_10, (*l_677), (*l_681), (*l_677), &l_10), l_662.f3, (**l_676), l_680), l_685, (*****l_673), l_680);
    if ((*l_681))
    { /* block id: 237 */
        int32_t l_690 = 0xE521611CL;
        struct S0 l_700 = {0,0,2164,-0,22};
        int32_t l_713 = 0xBB32C386L;
        const int32_t *l_715 = (void*)0;
        const int32_t **l_714 = &l_715;
        int32_t **l_722 = &l_681;
        int32_t ***l_721 = &l_722;
        int32_t ****l_720 = &l_721;
        uint16_t l_740 = 65532UL;
        uint8_t l_810 = 0xCBL;
        int32_t l_826 = 0xE2734614L;
        int32_t l_828 = 0x090691D5L;
        int64_t l_842 = (-1L);
        uint16_t l_844 = 0UL;
        uint8_t l_845 = 0xA7L;
        struct S0 **l_855 = (void*)0;
        int32_t l_863 = 0x52AF9D10L;
        uint32_t l_864 = 0x797A891BL;
        uint64_t l_896 = 0x80C4BD6F10CAE1B0LL;
        uint8_t l_912 = 1UL;
        struct S0 ** const ** const l_948 = (void*)0;
        int32_t l_953 = (-1L);
        const int32_t l_957 = 9L;
        uint32_t l_981 = 0x1FBCB653L;
        struct S0 ***l_1003 = &l_676;
        struct S0 ****l_1002 = &l_1003;
        float l_1009 = (-0x1.1p-1);
        float *l_1008 = &l_1009;
        uint16_t l_1012 = 6UL;
        float l_1045 = 0xF.55FD87p-2;
        const uint8_t l_1049 = 0x8AL;
        int32_t l_1056 = 1L;
        uint64_t l_1059 = 0x9764365142E6EF41LL;
        const uint64_t l_1061 = 0xC3DB8D05D317F5D3LL;
        int64_t l_1062 = (-1L);
        float l_1070 = 0x1.Cp-1;
        int32_t l_1106 = (-1L);
        if ((safe_rshift_func_int16_t_s_s((((((safe_mod_func_uint64_t_u_u(l_690, (-1L))) != (l_691 && 1UL)) >= ((l_690 & 0xE376L) > l_690)) , ((*l_681) > (*l_681))) , 1L), l_690)))
        { /* block id: 238 */
            struct S0 l_692 = {0,0,2900,-0,22};
            if (l_690)
            { /* block id: 239 */
                l_692 = (***l_675);
            }
            else
            { /* block id: 241 */
                int32_t **l_693 = &l_9;
                (*l_693) = &l_679;
                /* statement id: 242 */
                assert (l_9 == &l_679);
            }
            /* facts after branching */
            assert (l_9 == &l_679 || l_9 == 0);
        }
        else
        { /* block id: 244 */
            uint64_t l_694 = 0UL;
            struct S0 *l_695 = &l_662;
            float l_697 = (-0x1.8p+1);
            float *l_696 = &l_697;
            int64_t l_703 = 0xDE7D91D2207AF5C8LL;
            (*l_681) = (l_694 < (l_695 != l_695));
            (*l_696) = l_694;
            (*l_681) = ((safe_add_func_int32_t_s_s(((-1L) > ((l_694 , ((l_700 , ((safe_lshift_func_int16_t_s_u(l_703, ((safe_rshift_func_uint16_t_u_s((~l_700.f1), (((((safe_add_func_uint16_t_u_u((l_700.f2 >= ((safe_sub_func_int16_t_s_s(l_703, ((l_700.f0 , ((safe_add_func_float_f_f(((l_713 >= 0xC.5639A2p+39) <= 0x0.70399Dp-25), l_700.f3)) , l_714)) != &l_715))) >= 18446744073709551615UL)), 65535UL)) , &l_679) != (void*)0) & l_694) , 9L))) && l_694))) > l_694)) != 6L)) & 7UL)), (*l_681))) > l_694);
        }
        /* facts after branching */
        assert (l_9 == &l_679 || l_9 == 0);
        if (((safe_lshift_func_int16_t_s_u((((((-1L) || (safe_add_func_uint32_t_u_u((l_690 >= ((-6L) == (((((((&l_715 == &l_9) , l_720) != &l_721) , (((*l_681) <= (*l_681)) & (*l_681))) >= (***l_721)) == 0x5BD3L) & 0x77B8L))), (****l_720)))) , (void*)0) == &l_721) == (*l_681)), 4)) || (**l_722)))
        { /* block id: 249 */
            int16_t l_723 = 8L;
            struct S0 ***l_733 = (void*)0;
            struct S0 ****l_732 = &l_733;
            struct S0 *****l_731 = &l_732;
            int32_t *l_750 = (void*)0;
            int32_t *l_789 = (void*)0;
            uint32_t l_881 = 0x05DDBB96L;
            int32_t l_971 = 3L;
            int32_t * const ***l_972 = (void*)0;
            uint16_t l_974 = 0x5E29L;
            uint32_t l_982 = 0xA038B8A8L;
            uint32_t l_995 = 1UL;
            struct S0 l_997 = {4,1,5145,-0,24};
            uint16_t l_1001 = 1UL;
            uint32_t l_1011 = 0x2117CD21L;
            uint64_t l_1060 = 0x326AA5D2B5ACBE07LL;
            if (l_723)
            { /* block id: 250 */
                float l_730 = 0x4.F77219p+32;
                struct S0 *****l_734 = &l_732;
                int32_t *l_735 = &l_10;
                int32_t l_786 = 0xEC81587EL;
                int32_t ***l_790 = &l_722;
                (*l_714) = &l_679;
                /* statement id: 251 */
                assert (l_715 == &l_679);
                if ((***l_721))
                { /* block id: 252 */
                    struct S0 ***l_751 = &l_676;
                    int32_t *l_752 = &l_10;
                    int32_t *l_753 = &l_10;
                    float l_754 = 0xC.574D30p-70;
                    float *l_756 = (void*)0;
                    uint64_t l_757 = 18446744073709551608UL;
                    int32_t ***l_765 = &l_722;
                    struct S0 l_788 = {6,1,3489,-0,40};
                    for (l_723 = 3; (l_723 >= (-9)); l_723 = safe_sub_func_int16_t_s_s(l_723, 1))
                    { /* block id: 255 */
                        int32_t l_741 = 0x02E25721L;
                        uint64_t l_755 = 0x02D7B55DFAFFE4F2LL;
                        (*l_722) = func_36(((safe_lshift_func_uint16_t_u_u(((l_740 , (l_741 <= (&l_735 == (void*)0))) , (safe_lshift_func_int16_t_s_s((safe_sub_func_int64_t_s_s(((safe_add_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((l_700 , 0UL), (-7L))), (*l_753))) == (-3L)), (*l_753))), l_741))), l_755)) & l_741), &l_10, (*l_752));
                        (*l_735) = (((l_756 == (void*)0) != (*l_735)) > 0xD4881F49L);
                        if (l_757)
                            break;
                    }
                    for (l_690 = 0; (l_690 < 28); l_690 = safe_add_func_uint16_t_u_u(l_690, 3))
                    { /* block id: 262 */
                        int16_t l_762 = (-1L);
                        uint16_t l_768 = 0UL;
                        struct S0 l_787 = {3,1,2447,-0,52};
                        l_788 = (((safe_rshift_func_uint16_t_u_s(((l_762 , l_763) != l_765), (safe_rshift_func_int16_t_s_s(((l_768 >= ((((*l_735) | ((((safe_rshift_func_int16_t_s_u((((!(safe_rshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s((safe_mod_func_uint64_t_u_u(0UL, (safe_mod_func_uint32_t_u_u((safe_add_func_uint64_t_u_u(((***l_721) , ((((safe_lshift_func_int16_t_s_u(0x30F5L, ((***l_721) , (*l_715)))) , (****l_673)) == (void*)0) != l_786)), 0L)), (*l_753))))), 1)), l_723)), (*l_735)))) && l_768) ^ (*l_752)), 5)) != 65535UL) && l_762) , (*l_681))) || (*l_735)) < (*l_715))) == (***l_765)), (*l_715))))) != 6L) , l_787);
                        if (l_787.f1)
                            continue;
                    }
                    (**l_763) = l_789;
                }
                else
                { /* block id: 267 */
                    (*l_720) = (((***l_720) == l_750) , l_790);
                }
            }
            else
            { /* block id: 270 */
                const uint32_t l_796 = 0xB0BB96BEL;
                float l_805 = 0x4.7p-1;
                float *l_804 = &l_805;
                uint32_t l_843 = 18446744073709551615UL;
                int32_t l_866 = (-1L);
                for (l_10 = 0; (l_10 > 11); l_10 = safe_add_func_uint16_t_u_u(l_10, 1))
                { /* block id: 273 */
                    int16_t l_793 = 4L;
                    int32_t l_811 = 5L;
                    struct S0 ***** const l_825 = &l_732;
                    uint32_t l_827 = 0xB39B1AE5L;
                    int32_t * const * const l_841 = &l_681;
                    int32_t * const * const *l_840 = &l_841;
                    int32_t * const * const **l_839 = &l_840;
                    (*l_804) = ((***l_721) < ((((((0x56F24E4E0D5EBDCELL && l_793) && (safe_add_func_int16_t_s_s((-4L), (l_796 > (~(~(safe_sub_func_int64_t_s_s((((safe_unary_minus_func_int64_t_s((safe_sub_func_int16_t_s_s(((((0xDBE7C7E0L > (((l_804 == l_715) & (safe_rshift_func_int16_t_s_s((((safe_sub_func_uint32_t_u_u(((l_796 >= l_793) , l_810), l_793)) > 65535UL) , 1L), 7))) | l_793)) & (***l_721)) > 0x4661L) <= (-1L)), l_793)))) != l_796) || 0xEB44E3DDL), l_796)))))))) >= 0x0125A1B0L) , l_796) , l_793) >= l_793));
                    if (l_811)
                        break;
                    if (((0xE0624C9F412388EALL < ((safe_add_func_uint64_t_u_u((l_811 < ((((!((safe_lshift_func_uint16_t_u_u(((****l_720) ^ (safe_sub_func_uint64_t_u_u((safe_mod_func_uint32_t_u_u(4294967287UL, (-8L))), ((safe_mod_func_int16_t_s_s(l_796, (((((((void*)0 == l_825) , l_796) < 0UL) , l_826) >= 9L) , 0x4FD9L))) && 0xDA4DE453L)))), 9)) > l_827)) , l_796) == 0x8812L) > l_793)), l_796)) , l_828)) < 0xB8FDL))
                    { /* block id: 276 */
                        (*l_714) = (void*)0;
                        (*l_804) = l_796;
                    }
                    else
                    { /* block id: 279 */
                        int32_t * const l_829 = &l_10;
                        int32_t **l_830 = &l_750;
                        (*l_830) = l_829;
                        /* statement id: 280 */
                        assert (l_750 == &l_10);
                        l_844 = ((safe_sub_func_uint16_t_u_u(((((l_796 ^ (**l_830)) ^ ((safe_sub_func_uint64_t_u_u((safe_lshift_func_uint16_t_u_s(((0xEA22L && ((**l_830) >= (*l_750))) == (**l_830)), ((safe_lshift_func_uint16_t_u_s((((l_796 && ((void*)0 != (*l_674))) > l_796) , (**l_830)), (*l_829))) | (**l_830)))), 0x4FF47284CB379C12LL)) >= l_811)) , l_839) != (void*)0), l_842)) ^ l_843);
                        if ((**l_830))
                            continue;
                    }
                    return l_845;
                }
                /* facts after for loop */
                assert (l_750 == &l_10 || l_750 == 0);
                (**l_721) = (((safe_mod_func_int64_t_s_s((!(***l_721)), ((safe_rshift_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((((void*)0 == l_855) , ((l_843 & 1UL) && ((((((l_856 != (void*)0) >= ((((safe_add_func_int32_t_s_s(((safe_rshift_func_int16_t_s_s((((l_9 != (void*)0) <= 0x40761FC8L) , l_863), 9)) <= (-2L)), (**l_722))) && (-1L)) ^ l_796) != l_843)) ^ l_864) <= 6UL) , l_865) && l_843))), 3)), (***l_721))) & (*l_858)), l_866)) & (**l_857)))) , (**l_722)) , (*l_764));
                /* statement id: 286 */
                assert (l_681 == 0);
            }
            /* facts after branching */
            assert (l_681 == 0 || l_681 == &l_10);
            assert (l_715 == 0 || l_715 == &l_679);
            assert (l_750 == &l_10 || l_750 == 0);
            if ((0xA15B5A56L == 0xF72968CBL))
            { /* block id: 288 */
                int32_t l_869 = 0L;
                const uint64_t l_884 = 5UL;
                const int16_t l_898 = 0xA97EL;
                int16_t l_906 = (-1L);
                uint64_t l_908 = 0x44587FF6B5C7D88DLL;
                struct S0 l_921 = {5,1,-1557,0,53};
                uint8_t l_954 = 0xDFL;
                uint32_t l_956 = 1UL;
                for (l_740 = 19; (l_740 <= 42); l_740 = safe_add_func_int16_t_s_s(l_740, 1))
                { /* block id: 291 */
                    uint16_t l_870 = 65535UL;
                    float l_873 = (-0x7.9p-1);
                    float *l_872 = &l_873;
                    struct S0 *****l_880 = &l_732;
                    uint16_t l_897 = 0x6F20L;
                    int32_t ****l_905 = &l_763;
                    const int16_t l_922 = 0xFEADL;
                    l_870 = l_869;
                    (*l_872) = (0x5.8CAAA9p-73 <= (+(**l_857)));
                    if (((safe_lshift_func_uint16_t_u_s(l_870, 9)) || ((((((safe_sub_func_float_f_f((((safe_sub_func_float_f_f(((((((l_869 >= ((void*)0 != l_880)) , l_881) >= (safe_sub_func_float_f_f((((l_884 != (safe_sub_func_float_f_f((((safe_lshift_func_int16_t_s_u((safe_add_func_uint64_t_u_u((l_869 != (((+(safe_sub_func_uint64_t_u_u(l_870, (safe_rshift_func_int16_t_s_u(l_870, 11))))) , (*l_674)) != (void*)0)), 1UL)), 1)) <= l_881) , l_870), l_870))) >= (**l_857)) < l_884), l_870))) != (-0x1.9p-1)) <= 0x8.1CC0AEp+37) > l_896), l_870)) >= 0x8.9F7A9Fp-71) != (**l_857)), l_870)) == 0x5.A3F33Ep+73) <= l_884) <= l_897) , l_869) & l_870)))
                    { /* block id: 294 */
                        uint64_t l_899 = 0x1F2E29313742ED8DLL;
                        struct S0 **l_907 = &l_677;
                        const int32_t ***l_911 = &l_714;
                        uint64_t l_915 = 18446744073709551612UL;
                        (**l_856) = func_24(l_900, ((safe_mod_func_uint32_t_u_u(((((((safe_add_func_float_f_f(((((l_870 > (((l_899 != ((l_897 , l_905) != l_905)) >= l_906) > 0xE.A46DF9p-40)) > l_906) <= l_899) <= (*l_858)), l_899)) < l_899) , (void*)0) != l_907) , 18446744073709551609UL) , l_908), 0x1B4368FAL)) , l_897), l_899, l_899);
                        (*l_900) = (safe_add_func_int16_t_s_s(((((void*)0 == l_911) && (**l_857)) != (l_912 <= (((*l_900) > (safe_lshift_func_int16_t_s_u((l_915 == (l_897 , ((!0x50DCE35199C0B3D3LL) , ((safe_lshift_func_int16_t_s_s(((safe_mod_func_uint64_t_u_u((((l_921 , l_922) , 0x7.769F63p-53) , l_921.f3), l_869)) , (-7L)), l_906)) & l_723)))), (***l_856)))) | l_921.f1))), l_921.f1));
                        l_789 = l_789;
                    }
                    else
                    { /* block id: 298 */
                        int32_t l_930 = 0x5071890EL;
                        uint64_t l_942 = 0x8D58179D24AA2698LL;
                        int32_t l_943 = 0L;
                        l_943 = (safe_rshift_func_uint16_t_u_u(((((safe_add_func_int32_t_s_s((~(safe_sub_func_int16_t_s_s(l_930, ((((((*l_900) < (((safe_rshift_func_int16_t_s_s((safe_sub_func_int16_t_s_s((l_921.f0 == ((safe_add_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((l_884 || (-1L)), 7)), (l_930 & (safe_mod_func_uint64_t_u_u(l_921.f2, (safe_unary_minus_func_int64_t_s(((0xB96CL & ((**l_721) == (void*)0)) >= 0xF19CL)))))))) | l_869)), l_869)), 11)) , &l_855) == &l_855)) <= l_921.f1) >= 1UL) , l_942) <= l_869)))), l_869)) || 0x8B493F9349C6B201LL) , (***l_856)) , l_897), 5));
                        if (l_930)
                            continue;
                        (**l_763) = (void*)0;
                    }
                    (*l_900) = l_921.f3;
                }
                (*l_764) = func_2((safe_lshift_func_int16_t_s_u((((safe_add_func_int64_t_s_s(((l_948 != (*l_673)) , 0xEBF3ADF16D9DCE8BLL), (((((l_955 , (void*)0) != (***l_673)) | l_921.f4) < l_956) & l_957))) < (***l_856)) & (**l_857)), (*l_900))), (*l_764), &l_869, l_921.f2, l_921.f3);
            }
            else
            { /* block id: 306 */
                int16_t l_958 = 0x224EL;
                uint16_t l_969 = 1UL;
                float l_975 = 0xB.6616DDp+91;
                int32_t ****l_994 = &l_721;
                struct S0 l_996 = {4,0,3532,0,12};
                struct S0 ****l_1000 = (void*)0;
                if (l_958)
                { /* block id: 307 */
                    uint32_t l_970 = 4294967291UL;
                    int32_t *l_976 = &l_863;
                    float *l_978 = (void*)0;
                    float *l_979 = (void*)0;
                    float *l_980 = &l_975;
                    if (l_958)
                    { /* block id: 308 */
                        const int32_t ****l_973 = &l_856;
                        (***l_720) = (void*)0;
                        /* statement id: 309 */
                        assert (l_681 == 0);
                        (*l_714) = (***l_973);
                        /* statement id: 310 */
                        assert (l_715 == &l_10);
                    }
                    else
                    { /* block id: 311 */
                        (*l_857) = (*l_764);
                        /* statement id: 312 */
                        assert (l_858 == 0);
                        (*l_722) = l_976;
                        /* statement id: 313 */
                        assert (l_681 == &l_863);
                    }
                    /* facts after branching */
                    assert (l_681 == &l_863 || l_681 == 0);
                    assert (l_715 == 0 || l_715 == &l_679 || l_715 == &l_10);
                    assert (l_858 == 0 || l_858 == &l_10);
                    (*l_980) = (-l_969);
                    return l_981;
                }
                else
                { /* block id: 317 */
                    int32_t l_987 = 0x3E4E7249L;
                    (*l_763) = (*l_721);
                    /* statement id: 318 */
                    assert (l_764 == &l_681);
                    l_997 = l_996;
                }
                /* facts after branching */
                assert (l_764 == &l_681);
                l_1012 = ((l_1000 == (l_1001 , l_1002)) == ((l_958 > (l_996.f2 == (safe_mod_func_uint16_t_u_u(((~((~(((void*)0 == l_1008) <= ((((0UL ^ 0x3ED354AD07874B1ALL) > l_1010) ^ l_958) | 0xE964L))) > l_1011)) | l_969), (*l_858))))) < (*l_900)));
            }
            /* facts after branching */
            assert (l_764 == &l_681 || l_764 == &l_680);
            if ((((((safe_mod_func_int32_t_s_s((safe_add_func_int64_t_s_s(((((***l_856) , l_1001) ^ (0x5EC4EF69L >= (((9L != (((**l_720) != (((((!(safe_lshift_func_int16_t_s_s((safe_add_func_int16_t_s_s(((***l_674) == (***l_1002)), 65527UL)), ((+0xFD5930A4ABC9718CLL) < (*l_900))))) , 0xA031948BL) > l_1011) , 0xF2L) , (*l_763))) & 1UL)) , (void*)0) == (void*)0))) & l_1023), (*l_900))), 0x4D41CBE8L)) ^ (-3L)) , (void*)0) != (*l_732)) > 0xF07E964CL))
            { /* block id: 323 */
                uint64_t l_1028 = 0x303E02B66C125AB9LL;
                uint16_t l_1031 = 3UL;
                int16_t l_1034 = (-9L);
                const float *l_1041 = &l_1040;
                uint32_t l_1042 = 0xB1A7483BL;
                int32_t l_1043 = (-1L);
                struct S0 l_1044 = {2,0,2104,-0,44};
                (*l_764) = (*l_764);
                /* statement id: 324 */
                assert (l_680 == 0 || l_680 == &l_10);
                (*l_714) = (((((+((safe_lshift_func_uint16_t_u_u((l_1049 > (((safe_lshift_func_int16_t_s_u((l_1044.f0 && (safe_mod_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u(0x7AE9L, (l_1056 == ((l_1044 , (void*)0) != (****l_673))))), l_1031))), 10)) , l_1061) > (-1L))), 10)) & l_1062)) | l_1042) > 5L) >= l_1044.f2) , (*l_857));
                /* statement id: 325 */
                assert (l_715 == &l_10);
            }
            else
            { /* block id: 326 */
                (*l_764) = (void*)0;
            }
            /* facts after branching */
            assert (l_680 == 0 || l_680 == &l_10);
            assert (l_715 == 0 || l_715 == &l_679 || l_715 == &l_10);
        }
        else
        { /* block id: 329 */
            uint32_t l_1063 = 0xF423E416L;
            float *l_1066 = &l_1009;
            struct S0 l_1105 = {3,0,232,-0,58};
            float l_1107 = (-0x4.Ep+1);
            (****l_720) = ((l_1063 && ((safe_sub_func_int32_t_s_s((((((void*)0 != l_1066) , ((((0x82764C60094DAB36LL <= (0x3A8DE1ECBB455AFELL && ((((safe_mod_func_uint16_t_u_u((((!0x0675L) || ((((*l_714) != l_1066) < 4294967290UL) < (***l_721))) < (*l_681)), l_1063)) , l_1063) | (***l_721)) || (***l_856)))) != 0xF6FCL) > (*l_681)) , 0UL)) < l_1063) , (***l_721)), 0x4B8EA386L)) >= l_1063)) , l_1063);
            for (l_1062 = 0; (l_1062 <= (-2)); l_1062 = safe_sub_func_uint16_t_u_u(l_1062, 1))
            { /* block id: 333 */
                int32_t l_1075 = 1L;
                int32_t *l_1078 = &l_10;
                for (l_842 = 0; (l_842 <= 6); l_842 = safe_add_func_int32_t_s_s(l_842, 5))
                { /* block id: 336 */
                    if (l_1063)
                        break;
                }
                (**l_722) = (l_1075 & ((safe_mod_func_int64_t_s_s(((void*)0 != l_1078), (((l_1063 | (safe_rshift_func_int16_t_s_u(0x7EBBL, (safe_lshift_func_int16_t_s_u(0x64CDL, 9))))) ^ ((-4L) | (((safe_add_func_int64_t_s_s((***l_721), (safe_mod_func_int64_t_s_s(0x26A777413969F66ALL, (***l_856))))) >= (**l_857)) & 0x0F680810B6A786CFLL))) , (***l_721)))) >= 0x6C193078A125FA2ELL));
                for (l_8 = 0; (l_8 > (-24)); l_8 = safe_sub_func_int16_t_s_s(l_8, 1))
                { /* block id: 342 */
                    float ***l_1089 = (void*)0;
                    float **l_1091 = (void*)0;
                    float ***l_1090 = &l_1091;
                    (*l_1090) = &l_1039;
                    /* statement id: 343 */
                    assert (l_1091 == &l_1039);
                }
            }
            (****l_720) = ((safe_add_func_int64_t_s_s((((safe_add_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(8UL, (((safe_add_func_uint16_t_u_u((((l_1063 != ((((void*)0 == l_1100) , &l_674) == (((safe_sub_func_float_f_f((safe_add_func_float_f_f((l_1105 , (l_1106 > (0xF.E2EEFEp-14 >= l_1105.f4))), l_1107)), (**l_857))) < 0x5.947985p+75) , (void*)0))) <= (*l_681)) != (-7L)), (***l_721))) , 0xC3CB2F1BD90C4284LL) != 0x535C63B1BA3982F4LL))), 9L)) , 5UL) & (***l_721)), (****l_720))) & 1L);
        }
        /* facts after branching */
        assert (l_680 == 0 || l_680 == &l_10);
        assert (l_681 == 0 || l_681 == &l_10);
        assert (l_715 == 0 || l_715 == &l_679 || l_715 == &l_10);
        assert (l_764 == &l_681 || l_764 == &l_680);
    }
    else
    { /* block id: 348 */
        int64_t l_1110 = 1L;
        struct S0 ***l_1123 = &l_676;
        struct S0 ****l_1122 = &l_1123;
        struct S0 ***** const l_1121 = &l_1122;
        uint64_t l_1137 = 1UL;
        int32_t *l_1138 = &l_10;
        float l_1155 = 0xD.BED8F7p-71;
        for (l_621 = 0; (l_621 != 9); l_621 = safe_add_func_uint64_t_u_u(l_621, 1))
        { /* block id: 351 */
            int64_t l_1125 = 0xEC5FBE9C707C3D5CLL;
            int32_t ***l_1133 = &l_764;
            int32_t l_1154 = 1L;
            if (l_1110)
                break;
            for (l_1110 = 0; (l_1110 >= (-11)); l_1110 = safe_sub_func_uint32_t_u_u(l_1110, 1))
            { /* block id: 355 */
                uint32_t l_1118 = 0x3986ACE7L;
                struct S0 ****l_1120 = (void*)0;
                struct S0 ***** const l_1119 = &l_1120;
                uint32_t l_1135 = 1UL;
                struct S0 l_1145 = {4,0,-3853,-0,47};
                (**l_763) = l_1138;
                /* statement id: 356 */
                assert (l_680 == &l_10);
                (*l_680) = (safe_lshift_func_uint16_t_u_u((((safe_sub_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(((l_1145 , l_1146) == &l_1147), ((safe_mod_func_uint32_t_u_u((((**l_1133) != l_1138) , ((l_1145.f0 > ((*l_858) & (safe_sub_func_int64_t_s_s((***l_856), ((safe_sub_func_uint32_t_u_u((***l_1133), (*l_1138))) && 7L))))) != 9UL)), l_1135)) , l_1145.f2))), (***l_1133))) || l_1154) , l_1145.f1), 11));
                (*l_681) = (***l_1100);
                if (l_1145.f3)
                    continue;
            }
            if (l_1125)
                continue;
        }
        /* facts after for loop */
        assert (l_680 == &l_10 || l_680 == 0);
    }
    /* facts after branching */
    assert (l_9 == &l_679 || l_9 == 0);
    assert (l_680 == 0 || l_680 == &l_10);
    assert (l_681 == 0 || l_681 == &l_10);
    assert (l_764 == &l_681 || l_764 == &l_680);
    return l_1156;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_2(int16_t  p_3, int32_t * p_4, int32_t * p_5, uint32_t  p_6, int32_t  p_7)
{ /* block id: 231 */
    int32_t l_622 = 0L;
    struct S0 l_625 = {4,0,2761,-0,3};
    struct S0 *l_629 = &l_625;
    struct S0 **l_628 = &l_629;
    const int32_t l_637 = (-5L);
    const int32_t *l_636 = &l_637;
    const int32_t **l_635 = &l_636;
    const int32_t ***l_634 = &l_635;
    int32_t **l_639 = (void*)0;
    int32_t ***l_638 = &l_639;
    int32_t l_641 = 1L;
    int32_t *l_640 = &l_641;
    int32_t *l_642 = &l_641;
    int32_t *l_643 = &l_641;
    int32_t *l_644 = &l_641;
    int32_t *l_645 = &l_641;
    int32_t *l_646 = &l_641;
    int32_t *l_647 = &l_641;
    int32_t *l_648 = &l_641;
    int32_t *l_649 = &l_641;
    int32_t *l_650 = &l_641;
    int32_t *l_651 = &l_641;
    int32_t *l_652 = &l_641;
    int32_t *l_653 = &l_641;
    int32_t *l_654 = &l_641;
    int32_t *l_655 = &l_641;
    int32_t *l_656 = &l_641;
    int32_t *l_657 = &l_641;
    int32_t *l_658 = (void*)0;
    (*l_629) = func_52(((((l_622 | (safe_rshift_func_uint16_t_u_u(((((l_625 , ((safe_add_func_uint16_t_u_u((p_7 , l_625.f2), (((((8L >= (0x954AL != (((void*)0 == l_628) > (safe_rshift_func_int16_t_s_u(((safe_add_func_int64_t_s_s(((p_3 == p_3) != 0x56DFL), l_625.f3)) || 0x6BC46E08E0208544LL), 0))))) , 0xB6751E6EL) < p_3) , l_634) != l_638))) , (void*)0)) != (*l_628)) <= p_3) == (***l_634)), 11))) != 0xF6EA48A7L) != p_3) , &p_7), (*p_5), l_640);
    return l_658;
    /* statement id: 233 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_13(int32_t  p_14, int32_t  p_15, int32_t * p_16)
{ /* block id: 1 */
    int32_t l_30 = (-2L);
    int32_t *l_29 = &l_30;
    int32_t l_172 = 0x0EBF16E3L;
    struct S0 l_302 = {5,1,5025,0,48};
    struct S0 *l_605 = (void*)0;
    struct S0 *l_606 = &l_302;
    struct S0 **l_612 = &l_605;
    struct S0 ***l_611 = &l_612;
    float *l_616 = (void*)0;
    (*l_606) = func_18(func_24(l_29, ((func_31(&l_30, &l_30, func_36(p_15, &l_30, (safe_sub_func_uint64_t_u_u(func_42(((func_46(p_15, &l_30, &l_30, p_14, (*l_29)) , (*l_29)) && (*l_29)), p_14, (*l_29)), p_14))), l_29) < 4294967295UL) != 0xA6E1C48DL), l_172, l_172), l_302, p_14, l_302, &l_172);
    for (l_30 = 22; (l_30 < 25); l_30 = safe_add_func_uint32_t_u_u(l_30, 1))
    { /* block id: 225 */
        struct S0 **l_610 = &l_606;
        struct S0 ***l_609 = &l_610;
        uint32_t l_613 = 0UL;
        (*p_16) = ((l_609 != l_611) & l_613);
    }
    (*l_611) = (*l_611);
    (*l_29) = (safe_add_func_float_f_f(p_14, (*l_29)));
    return (*p_16);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_18(int32_t * p_19, struct S0  p_20, const uint16_t  p_21, struct S0  p_22, int32_t * p_23)
{ /* block id: 122 */
    int32_t l_303 = 0xD48113C8L;
    struct S0 l_325 = {4,0,-5441,0,14};
    const int64_t l_326 = 1L;
    float l_339 = 0x5.764ED3p-20;
    float *l_338 = &l_339;
    uint64_t l_340 = 18446744073709551615UL;
    uint32_t l_363 = 1UL;
    int16_t l_415 = 0x4197L;
    int32_t **l_426 = (void*)0;
    struct S0 *l_482 = &l_325;
    struct S0 **l_481 = &l_482;
    struct S0 *** const l_480 = &l_481;
    const struct S0 **l_492 = (void*)0;
    const struct S0 ***l_491 = &l_492;
    const struct S0 ****l_490 = &l_491;
    const struct S0 *****l_489 = &l_490;
    const int16_t l_521 = 0xD783L;
    int64_t l_552 = 0x82778B136FE55A46LL;
    int64_t l_594 = (-1L);
    uint8_t l_604 = 8UL;
    (*p_19) = (*p_19);
    for (l_303 = 0; (l_303 == (-7)); l_303 = safe_sub_func_int32_t_s_s(l_303, 8))
    { /* block id: 126 */
        uint32_t l_306 = 18446744073709551612UL;
        int32_t ****l_307 = (void*)0;
        float l_337 = 0x2.0p-1;
        float *l_336 = &l_337;
        struct S0 **l_369 = (void*)0;
        int32_t *l_393 = &l_303;
        int32_t **l_392 = &l_393;
        int32_t l_445 = 0L;
        int32_t * const *l_502 = (void*)0;
    }
    (*l_338) = ((((func_52(p_23, ((void*)0 != l_426), func_24(p_19, p_22.f1, p_22.f0, p_22.f0)) , 0x57629461080B7E39LL) < l_521) == (-1L)) , l_552);
    return p_22;
}


/* ------------------------------------------ */
/* 
 * reads : l_172 l_30 l_10
 * writes: l_172 l_30 l_10
 */
static int32_t * func_24(int32_t * p_25, int64_t  p_26, uint32_t  p_27, uint64_t  p_28)
{ /* block id: 37 */
    int32_t l_177 = 0x7A342696L;
    int32_t *l_176 = &l_177;
    int32_t **l_185 = &l_176;
    int32_t ***l_184 = &l_185;
    float l_186 = 0x1.Fp+1;
    int32_t l_187 = (-1L);
    struct S0 l_198 = {5,1,917,-0,21};
    struct S0 *l_197 = &l_198;
    struct S0 l_204 = {2,0,-1535,-0,33};
    uint32_t l_276 = 0x45E133C6L;
    int32_t *l_301 = &l_177;
    if ((safe_unary_minus_func_int16_t_s((safe_lshift_func_int16_t_s_s(((func_52(p_25, ((void*)0 != l_176), &l_177) , (*l_176)) >= (safe_mod_func_int64_t_s_s((safe_mod_func_int32_t_s_s((((safe_sub_func_float_f_f(((((l_184 != ((**l_185) , &l_185)) > p_27) , p_25) == (void*)0), p_26)) >= (***l_184)) , (*p_25)), l_187)), 0x18C5888CA29FBB94LL))), 12)))))
    { /* block id: 38 */
        uint32_t l_195 = 0x538398E1L;
        struct S0 **l_199 = &l_197;
        if ((safe_lshift_func_uint16_t_u_s(0xEB6FL, 14)))
        { /* block id: 39 */
            for (p_28 = (-12); (p_28 != 56); p_28 = safe_add_func_int64_t_s_s(p_28, 1))
            { /* block id: 42 */
                for (p_26 = 13; (p_26 != 16); p_26 = safe_add_func_uint16_t_u_u(p_26, 1))
                { /* block id: 45 */
                    float *l_194 = &l_186;
                    if ((*p_25))
                        break;
                    (*l_194) = 0x1.DFA8AFp+78;
                    (**l_184) = func_36(p_26, p_25, p_28);
                    /* statement id: 48 */
                    //assert (l_176 == &l_30 || l_176 == &l_172 || l_176 == &l_10);
                }
                if ((*p_25))
                    break;
                if (l_195)
                    break;
            }
            /* facts after for loop */
            //assert (l_176 == &l_30 || l_176 == &l_177 || l_176 == &l_172 || l_176 == &l_10);
            (**l_184) = p_25;
            /* statement id: 53 */
            //assert (l_176 == &l_30 || l_176 == &l_172 || l_176 == &l_10);
        }
        else
        { /* block id: 54 */
            float *l_196 = &l_186;
            (*l_196) = (***l_184);
        }
        /* facts after branching */
        //assert (l_176 == &l_177 || l_176 == &l_30 || l_176 == &l_172 || l_176 == &l_10);
        (*l_199) = l_197;
    }
    else
    { /* block id: 58 */
        int32_t *l_200 = (void*)0;
        int32_t l_203 = 0L;
        int32_t l_228 = 0xA9FD3CF2L;
        struct S0 l_244 = {3,0,31,0,31};
        const int32_t *l_252 = &l_203;
        const int32_t ** const l_251 = &l_252;
        const int32_t ** const *l_250 = &l_251;
        struct S0 l_265 = {5,0,1084,0,16};
        uint32_t l_281 = 0x50E86C6BL;
        uint16_t l_282 = 0x219AL;
        if (((((((void*)0 == l_200) , ((((safe_rshift_func_uint16_t_u_s((l_203 ^ 0x8AB0B14FL), (l_204 , (safe_sub_func_uint64_t_u_u((safe_sub_func_uint16_t_u_u((*l_176), (*l_176))), ((~(safe_add_func_uint64_t_u_u((*l_176), ((((***l_184) , 0x59969081L) <= 0xE2514E94L) || p_27)))) , l_203)))))) , (***l_184)) != (-0x1.Ap+1)) > 0x6.5C0E47p-92)) >= (**l_185)) >= l_203) , (*p_25)))
        { /* block id: 59 */
            int32_t l_240 = 0x74629640L;
            int32_t ****l_253 = (void*)0;
            int32_t ** const *l_255 = &l_185;
            int32_t ** const **l_254 = &l_255;
            for (l_187 = (-20); (l_187 != (-2)); l_187 = safe_add_func_int32_t_s_s(l_187, 9))
            { /* block id: 62 */
                uint16_t l_214 = 0x6B1FL;
                int32_t l_241 = 0x878C961DL;
            }
            for (p_28 = 6; (p_28 == 55); p_28 = safe_add_func_int32_t_s_s(p_28, 1))
            { /* block id: 81 */
                (*l_197) = l_244;
            }
            (**l_184) = func_36((safe_lshift_func_int16_t_s_s(((((((safe_sub_func_int16_t_s_s((&l_244 != (void*)0), p_26)) || (!4294967295UL)) >= (p_28 ^ (0xEFDE07D20D79F787LL | ((p_28 < ((*p_25) , ((((((&l_185 == &l_185) | l_244.f0) ^ p_27) ^ 0x51E0E9ADL) | (*p_25)) < (**l_185)))) , p_28)))) ^ p_28) > 0x399AF9C28862E0C1LL) | 0x9340L), p_26)), p_25, (*l_176));
            /* statement id: 84 */
            //assert (l_176 == &l_30 || l_176 == &l_172 || l_176 == &l_10);
            (*l_254) = l_250;
            /* statement id: 85 */
            assert (l_255 == &l_251);
        }
        else
        { /* block id: 86 */
            int32_t ***l_260 = (void*)0;
            struct S0 * const *l_271 = &l_197;
            for (p_27 = 0; (p_27 >= 42); p_27 = safe_add_func_int16_t_s_s(p_27, 1))
            { /* block id: 89 */
                uint16_t l_266 = 0x656AL;
                float *l_272 = &l_186;
                (**l_250) = p_25;
                /* statement id: 90 */
                //assert (l_252 == &l_30 || l_252 == &l_172 || l_252 == &l_10);
                (**l_184) = p_25;
                /* statement id: 91 */
                //assert (l_176 == &l_30 || l_176 == &l_172 || l_176 == &l_10);
                (*l_272) = ((((l_260 != &l_251) > ((((((safe_add_func_float_f_f((safe_add_func_float_f_f(((((p_28 != (**l_185)) | ((((l_265 , 0x2346L) & l_266) != (((safe_rshift_func_uint16_t_u_u((((((safe_sub_func_uint64_t_u_u(7UL, 0x8562396B67929D46LL)) < 0L) >= l_266) >= 0x9B1DL) > 0xB46675EFL), 5)) , l_271) == &l_197)) | p_26)) , (void*)0) != (void*)0), (***l_250))), p_27)) <= (**l_185)) , p_28) || (***l_184)) < p_27) == 0xDF76FED9L)) , 0x4.78C474p+98) < p_26);
            }
            /* facts after for loop */
            //assert (l_176 == &l_30 || l_176 == &l_177 || l_176 == &l_172 || l_176 == &l_10);
            //assert (l_252 == &l_30 || l_252 == &l_203 || l_252 == &l_172 || l_252 == &l_10);
            for (p_26 = 0; (p_26 < 29); p_26 = safe_add_func_int64_t_s_s(p_26, 1))
            { /* block id: 96 */
                int32_t *l_275 = &l_203;
                const int32_t **l_285 = &l_252;
                const int32_t ***l_284 = &l_285;
                const int32_t ****l_283 = &l_284;
                (**l_250) = l_275;
                /* statement id: 97 */
                assert (l_252 == &l_203);
                if ((*l_275))
                    break;
                (***l_184) = (((0x053BF6E9L < l_276) || ((l_265 , &l_197) != (void*)0)) > (safe_lshift_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u((p_27 > 0x03F4EF0FF0162682LL), (((((*l_176) >= (((((***l_250) >= l_281) >= l_282) , (*l_252)) | 0x74C6L)) , (void*)0) == l_283) | 0xD44DL))), (****l_283))));
            }
        }
        /* facts after branching */
        //assert (l_176 == &l_30 || l_176 == &l_177 || l_176 == &l_172 || l_176 == &l_10);
        //assert (l_252 == &l_30 || l_252 == &l_203 || l_252 == &l_172 || l_252 == &l_10);
        for (l_187 = 0; (l_187 >= 29); l_187 = safe_add_func_uint16_t_u_u(l_187, 3))
        { /* block id: 104 */
            struct S0 **l_288 = (void*)0;
            (**l_250) = p_25;
            /* statement id: 105 */
            //assert (l_252 == &l_30 || l_252 == &l_172 || l_252 == &l_10);
            (*p_25) = 0x54A16A10L;
            (*l_251) = func_36((l_288 == (void*)0), func_36((***l_250), p_25, ((void*)0 != (*l_250))), ((safe_lshift_func_uint16_t_u_s(p_28, p_28)) == p_26));
        }
        (*l_197) = l_265;
        if ((0x947EL <= ((((&l_251 != ((safe_add_func_float_f_f((((((safe_sub_func_float_f_f((safe_sub_func_float_f_f((((((*l_252) < (0x9F63L < p_27)) , (void*)0) != (*l_251)) > (&l_244 != &l_265)), p_26)), p_26)) == (***l_184)) <= (***l_184)) <= p_26) != (**l_185)), p_26)) , &l_251)) & p_26) == (***l_250)) <= (**l_251))))
        { /* block id: 110 */
            int16_t l_299 = (-2L);
            float *l_300 = &l_186;
            for (p_28 = 0; (p_28 != 19); p_28 = safe_add_func_uint32_t_u_u(p_28, 1))
            { /* block id: 113 */
                (**l_185) = l_299;
            }
            (*l_300) = ((void*)0 == &l_251);
        }
        else
        { /* block id: 117 */
            return p_25;
            /* statement id: 118 */
            //assert (func_24_rv == &l_30 || func_24_rv == &l_172 || func_24_rv == &l_10);
        }
    }
    /* facts after branching */
    //assert (l_176 == &l_177 || l_176 == &l_30 || l_176 == &l_172 || l_176 == &l_10);
    return p_25;
    /* statement id: 121 */
    //assert (func_24_rv == &l_30 || func_24_rv == &l_172 || func_24_rv == &l_10);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(int32_t * p_32, int32_t * p_33, int32_t * const  p_34, int32_t * p_35)
{ /* block id: 33 */
    uint32_t l_127 = 8UL;
    const int32_t l_130 = 0xF441AF38L;
    int32_t *l_146 = (void*)0;
    int32_t **l_145 = &l_146;
    int32_t ***l_144 = &l_145;
    int32_t **** const l_143 = &l_144;
    uint16_t l_147 = 0xC221L;
    float *l_148 = (void*)0;
    float *l_149 = (void*)0;
    float *l_150 = (void*)0;
    float l_152 = (-0x1.2p+1);
    float *l_151 = &l_152;
    const struct S0 l_167 = {6,0,4828,0,4};
    uint64_t l_168 = 0x5D7C08194481F50DLL;
    uint16_t l_169 = 0UL;
    uint16_t l_170 = 65535UL;
    uint32_t l_171 = 4294967295UL;
    (*l_151) = (l_127 >= ((safe_add_func_float_f_f(l_130, ((l_130 >= 0xF.C5AECEp-39) > (safe_sub_func_float_f_f(((((safe_add_func_float_f_f((safe_add_func_float_f_f(((l_130 == (safe_add_func_float_f_f((safe_sub_func_float_f_f((p_35 == p_34), (safe_add_func_float_f_f((l_130 , (((l_143 == (void*)0) != l_130) < 0xD.5E0419p+65)), l_130)))), l_130))) != 0x3.091CAAp+54), 0x3.E8D535p+73)), l_147)) <= l_130) >= 0xF.A3FD71p+0) <= l_130), l_147))))) < l_127));
    (*l_145) = func_36(l_130, p_35, l_147);
    /* statement id: 35 */
    //assert (l_146 == &l_30);
    return (*p_34);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_30 l_172 l_10
 */
static int32_t * func_36(const int32_t  p_37, int32_t * p_38, int16_t  p_39)
{ /* block id: 24 */
    int32_t *l_121 = (void*)0;
    int32_t **l_120 = &l_121;
    int32_t l_126 = 0x9E68FEE3L;
    int32_t *l_125 = &l_126;
    (*l_120) = p_38;
    /* statement id: 25 */
    //assert (l_121 == &l_30 || l_121 == &l_522 || l_121 == &l_172 || l_121 == &l_10);
    (**l_120) = (~(&l_120 != &l_120));
    for (p_39 = 0; (p_39 <= 11); p_39 = safe_add_func_int16_t_s_s(p_39, 8))
    { /* block id: 29 */
        (*l_120) = p_38;
    }
    return p_38;
    /* statement id: 32 */
    //assert (func_36_rv == &l_30 || func_36_rv == &l_522 || func_36_rv == &l_172 || func_36_rv == &l_10);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_42(uint16_t  p_43, int16_t  p_44, int32_t  p_45)
{ /* block id: 10 */
    struct S0 l_89 = {0,0,4807,0,42};
    struct S0 *l_90 = &l_89;
    int32_t l_110 = 4L;
    int32_t *l_109 = &l_110;
    uint8_t l_111 = 0x08L;
    (*l_90) = l_89;
    if (((safe_rshift_func_int16_t_s_s((safe_unary_minus_func_int32_t_s((+l_89.f3))), 9)) != (safe_add_func_int64_t_s_s(p_43, ((((safe_sub_func_float_f_f((((((((void*)0 == &p_45) , (((safe_add_func_float_f_f((0x5.B2A14Dp-26 <= (((!((safe_mod_func_uint16_t_u_u(p_43, (l_89.f0 & (l_89.f2 , (safe_mod_func_int32_t_s_s((safe_lshift_func_int16_t_s_s((safe_unary_minus_func_int32_t_s((func_52(l_109, p_44, &l_110) , p_45))), (*l_109))), p_45)))))) , (-1L))) , p_45) >= p_45)), (*l_109))) <= 0x7.C05957p-76) >= l_111)) < 0x7.F56D1Bp-71) >= (*l_109)) >= p_44) < (-0x1.5p+1)), 0x1.1p+1)) , (*l_109)) != (*l_109)) && p_43)))))
    { /* block id: 12 */
        int32_t *l_112 = &l_110;
        (*l_90) = func_52(l_112, (*l_109), l_112);
    }
    else
    { /* block id: 14 */
        int32_t l_116 = 0x6A910B13L;
        int32_t *l_115 = &l_116;
        int32_t **l_118 = &l_115;
        int32_t ***l_117 = &l_118;
        int32_t ****l_119 = &l_117;
        for (l_110 = 0; (l_110 >= 29); l_110 = safe_add_func_int64_t_s_s(l_110, 1))
        { /* block id: 17 */
            l_115 = &l_110;
            /* statement id: 18 */
            assert (l_115 == &l_110);
            return p_43;
        }
        (*l_119) = l_117;
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_46(int32_t  p_47, int32_t * p_48, int32_t * const  p_49, float  p_50, const uint8_t  p_51)
{ /* block id: 2 */
    uint8_t l_60 = 0UL;
    uint16_t l_70 = 0x8622L;
    int32_t l_72 = 0x04290900L;
    int32_t *l_71 = &l_72;
    struct S0 l_88 = {5,1,-1665,-0,11};
    struct S0 *l_87 = &l_88;
    p_50 = (func_52(p_48, ((safe_add_func_uint32_t_u_u((((0xDE2FD17BL && (((safe_sub_func_uint64_t_u_u(0x39170055833AED5ELL, (l_60 != l_60))) | ((safe_sub_func_uint32_t_u_u(p_51, ((safe_sub_func_int32_t_s_s(((safe_unary_minus_func_int64_t_s((l_60 == p_47))) <= (safe_add_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u(l_60, l_60)), (-1L)))), l_70)) ^ l_60))) ^ 4294967292UL)) < l_60)) != l_60) < 0xEC28L), (-1L))) <= 0xAB8BF51449BABE4ALL), l_71) , (*l_71));
    (*l_87) = func_52(&l_72, (*p_48), &l_72);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : l_30 l_172 l_10
 * writes:
 */
static struct S0  func_52(int32_t * p_53, int32_t  p_54, int32_t * p_55)
{ /* block id: 3 */
    int32_t l_75 = (-10L);
    int32_t *l_74 = &l_75;
    int32_t **l_73 = &l_74;
    uint32_t l_76 = 1UL;
    uint32_t l_83 = 0x6BF08EAFL;
    struct S0 l_86 = {0,1,-4121,0,55};
    (*l_73) = &p_54;
    /* statement id: 4 */
    assert (l_74 == &p_54);
    (**l_73) = (l_76 || ((safe_add_func_uint16_t_u_u(0x403AL, (safe_mod_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u(p_54, ((l_83 > (&p_55 != (void*)0)) >= (((**l_73) == (safe_lshift_func_int16_t_s_u((0xE7EBAC3F408375F0LL && (((1L != p_54) , 0xBC073022L) || (**l_73))), (*l_74)))) , (**l_73))))), (**l_73))))) | (*p_55)));
    return l_86;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 277
   depth: 1, occurrence: 22
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 51
breakdown:
   indirect level: 0, occurrence: 22
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 7
   indirect level: 5, occurrence: 8
XXX full-bitfields structs in the program: 22
breakdown:
   indirect level: 0, occurrence: 22
XXX times a bitfields struct's address is taken: 18
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 37
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 159

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 164
   depth: 2, occurrence: 27
   depth: 3, occurrence: 3
   depth: 4, occurrence: 5
   depth: 11, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 19, occurrence: 5
   depth: 20, occurrence: 1
   depth: 22, occurrence: 4
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 3
   depth: 29, occurrence: 1
   depth: 30, occurrence: 3
   depth: 33, occurrence: 1

XXX total number of pointers: 222

XXX times a variable address is taken: 239
XXX times a pointer is dereferenced on RHS: 274
breakdown:
   depth: 1, occurrence: 167
   depth: 2, occurrence: 46
   depth: 3, occurrence: 52
   depth: 4, occurrence: 8
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 99
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 41
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 1127

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 498
   level: 2, occurrence: 348
   level: 3, occurrence: 179
   level: 4, occurrence: 84
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 110
XXX number of pointers point to scalars: 100
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 20.3
XXX average alias set size: 1.27

XXX times a non-volatile is read: 1634
XXX times a non-volatile is write: 280
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 151
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 14
   depth: 2, occurrence: 30
   depth: 3, occurrence: 31
   depth: 4, occurrence: 22
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 13.6
XXX percentage an existing variable is used: 86.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

