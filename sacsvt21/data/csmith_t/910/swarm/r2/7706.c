/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3469822904
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   float  f0;
   uint8_t  f1;
   const signed f2 : 2;
   uint32_t  f3;
};

union U1 {
   int32_t  f0;
   uint8_t  f1;
   uint32_t  f2;
   int32_t  f3;
   const uint32_t  f4;
};

union U2 {
   const int16_t  f0;
   int16_t  f1;
   int16_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U0  func_30(void);
inline static union U0 * func_38(int32_t  p_39, float  p_40, uint32_t  p_41, union U0 * p_42, int32_t * p_43);
static uint16_t  func_53(int32_t * p_54);
static int16_t  func_55(int16_t  p_56, int32_t * p_57, int32_t  p_58, uint32_t  p_59, int32_t * p_60);
inline static int32_t * func_62(int32_t  p_63, const union U0 * p_64, uint8_t  p_65);
inline static const union U0 * func_66(uint8_t  p_67, const int32_t * p_68, int32_t * p_69, const union U0 * p_70);
static const int32_t  func_72(int32_t * p_73, union U0  p_74, union U0  p_75, union U0 * p_76);
inline static int32_t * func_77(union U0 * p_78, union U0  p_79, union U1  p_80);
inline static union U0 * func_81(uint32_t  p_82, uint16_t  p_83, int16_t  p_84);
static union U0 * func_110(const int32_t * p_111, int16_t  p_112, const union U0 ** p_113);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_30(void)
{ /* block id: 36 */
    uint32_t l_33 = 0x7509CB0B;
    int32_t l_35 = (-8);
    int32_t *l_34 = &l_35;
    union U0 l_49 = {-0x1.5p-1};
    union U0 *l_48 = &l_49;
    union U0 **l_717 = &l_48;
    union U1 l_718 = {-3};
    int32_t **l_719 = &l_34;
    union U0 l_720 = {0x1.4p-1};
    (*l_34) = (safe_sub_func_int16_t_s_s(l_33, l_33));
    (*l_34) = ((safe_rshift_func_int16_t_s_s(((*l_34) || ((*l_34) >= (&l_35 != &l_35))), 3)) | ((-1) | ((void*)0 != &l_35)));
    (*l_717) = func_38((*l_34), (*l_34), ((((*l_34) < (safe_add_func_uint32_t_u_u((safe_sub_func_int32_t_s_s((*l_34), ((*l_34) && (&l_35 == (void*)0)))), (*l_34)))) && (*l_34)) || 0x2C29), l_48, &l_35);
    (*l_719) = func_77((*l_717), ((*l_34) , (**l_717)), l_718);
    /* statement id: 340 */
    assert (l_34 == 0);
    return l_720;
    /* statement id: 341 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0 * func_38(int32_t  p_39, float  p_40, uint32_t  p_41, union U0 * p_42, int32_t * p_43)
{ /* block id: 39 */
    int32_t l_52 = (-1);
    union U2 l_516 = {0x43D1};
    union U1 l_533 = {-6};
    union U1 *l_532 = &l_533;
    union U2 ***l_537 = (void*)0;
    const float *l_552 = (void*)0;
    union U0 l_575 = {0xC.E032BEp-22};
    const int32_t *l_646 = &l_52;
    const union U0 *l_648 = &l_575;
    const union U0 **l_647 = &l_648;
    uint32_t l_650 = 0x01F92683;
    union U1 ***l_654 = (void*)0;
    union U1 ****l_653 = &l_654;
    if (((safe_sub_func_int16_t_s_s(0xC1B0, ((((void*)0 != &p_39) > __builtin_popcountll(l_52)) ^ func_53(&l_52)))) || ((safe_lshift_func_int16_t_s_s(p_39, (l_516 , l_52))) ^ l_516.f1)))
    { /* block id: 241 */
        union U2 l_525 = {0x0AC3};
        union U1 *l_534 = &l_533;
        for (p_41 = 0; (p_41 == 52); ++p_41)
        { /* block id: 244 */
            int32_t *l_520 = &l_52;
            int32_t **l_519 = &l_520;
            float l_536 = 0xA.DB7756p+21;
            float *l_535 = &l_536;
            (*l_519) = &p_39;
            /* statement id: 245 */
            assert (l_520 == &p_39);
            (*l_535) = ((safe_mul_func_float_f_f(0x9.CBE8DEp+99, (**l_519))) <= (0xC.3F15AAp-97 <= (safe_add_func_float_f_f(((l_525 , (void*)0) != &l_525), (safe_sub_func_float_f_f((safe_sub_func_float_f_f((((((safe_sub_func_uint32_t_u_u(((l_525 , l_532) != l_534), p_41)) == (*l_520)) , l_52) == p_39) >= p_40), 0x0.2p-1)), (-0x1.6p-1)))))));
            (**l_519) = 0x2B8BD812;
        }
        p_43 = &p_39;
        /* statement id: 249 */
        assert (p_43 == &p_39);
    }
    else
    { /* block id: 250 */
        union U2 ****l_538 = &l_537;
        union U0 ***l_540 = (void*)0;
        union U0 ****l_539 = &l_540;
        int32_t l_541 = 0xA1E9AED6;
        float l_551 = 0x1.49C8EDp+51;
        float *l_550 = &l_551;
        uint32_t l_553 = 0xFE64C09C;
        union U1 **l_595 = &l_532;
        union U1 ***l_594 = &l_595;
        int32_t *l_613 = &l_52;
        union U2 l_658 = {-10};
lbl_632:
        (*l_538) = l_537;
        (*l_539) = ((&l_516 == &l_516) , (void*)0);
        if (l_541)
        { /* block id: 253 */
            float l_543 = (-0x5.Ep+1);
            float *l_542 = &l_543;
            int32_t l_546 = (-1);
            union U0 l_591 = {0x0.76F351p+31};
            union U2 *l_611 = &l_516;
            int32_t *l_612 = &l_541;
            union U1 l_626 = {-7};
            int32_t **l_631 = &l_613;
            (*l_542) = p_41;
            if (func_55(p_39, l_542, (((safe_add_func_uint32_t_u_u(l_546, func_55((~((l_52 && ((safe_lshift_func_uint16_t_u_s(0x9E84, (((*p_42) , l_550) != l_552))) && p_39)) , l_553)), &l_546, l_553, l_546, &l_546))) || p_41) == (-3)), l_546, &l_52))
            { /* block id: 255 */
                int32_t *l_555 = (void*)0;
                int32_t **l_554 = &l_555;
                const float l_561 = 0xA.52DA7Ep-25;
                union U1 **l_569 = &l_532;
                union U1 ***l_568 = &l_569;
                union U1 ****l_567 = &l_568;
                (*l_554) = &p_39;
                /* statement id: 256 */
                assert (l_555 == &p_39);
                if ((safe_mod_func_uint16_t_u_u(((__builtin_clzl(l_533.f4) , (p_39 && (!(safe_lshift_func_uint16_t_u_u(65535U, ((__builtin_ctz(l_52) , p_39) >= (**l_554))))))) <= l_52), l_533.f0)))
                { /* block id: 257 */
                    uint32_t l_571 = 0xB6406CD2;
                    float *l_572 = &l_543;
                    for (l_533.f0 = (-30); (l_533.f0 == (-16)); ++l_533.f0)
                    { /* block id: 260 */
                        union U1 ****l_570 = &l_568;
                        (*p_43) = ((p_41 , l_552) != ((!(p_41 > (safe_add_func_int16_t_s_s(((l_567 == l_570) >= l_571), l_516.f0)))) , l_572));
                        return p_42;
                        /* statement id: 262 */
                        //assert (func_38_rv == &l_49);
                    }
                    (*l_569) = (*l_569);
                }
                else
                { /* block id: 265 */
lbl_573:
                    (*l_569) = (p_39 , (**l_568));
                }
                if (l_541)
                    goto lbl_573;
                (*l_554) = &p_39;
            }
            else
            { /* block id: 270 */
                int32_t l_576 = (-1);
                union U0 l_582 = {0xE.03DB69p+95};
                int32_t l_620 = 0x1CE60648;
                union U2 *l_622 = &l_516;
                if (func_55(l_553, (((!func_72(&l_52, l_575, l_575, p_42)) >= l_576) , ((safe_mul_func_int16_t_s_s(((!p_39) > p_41), p_41)) , (void*)0)), p_41, p_41, &l_546))
                { /* block id: 271 */
                    int32_t *l_585 = &l_546;
                    if (((*p_43) >= ((safe_rshift_func_int16_t_s_s((l_582 , p_41), 4)) >= l_582.f2)))
                    { /* block id: 272 */
                        union U2 *l_583 = &l_516;
                        union U2 **l_584 = &l_583;
                        int32_t **l_586 = &l_585;
                        (*l_584) = l_583;
                        (*l_586) = l_585;
                    }
                    else
                    { /* block id: 275 */
                        return p_42;
                        /* statement id: 276 */
                        //assert (func_38_rv == &l_49);
                    }
                    (*l_542) = (safe_mul_func_float_f_f(((safe_mul_func_float_f_f(0x0.1464DAp+66, p_39)) , __builtin_ffs(((1U < func_55(p_41, &l_52, (*l_585), ((func_72(&l_541, (*p_42), l_591, p_42) | l_546) >= 2U), &l_52)) == 0xE9E2))), (-0x1.6p-1)));
                    (*l_550) = l_541;
                    p_42 = p_42;
                }
                else
                { /* block id: 281 */
                    int32_t l_609 = 0x074DED6C;
                    uint32_t l_610 = 0x2496E742;
                    for (l_52 = 0; (l_52 < 2); l_52 = safe_add_func_uint32_t_u_u(l_52, 6))
                    { /* block id: 284 */
                        union U1 ****l_596 = &l_594;
                        (*l_596) = l_594;
                        (*p_43) = ((__builtin_ffs((p_39 , ((safe_add_func_int16_t_s_s((safe_mul_func_int16_t_s_s((-3), l_546)), ((((safe_lshift_func_uint16_t_u_u((((void*)0 == (*l_594)) && (p_41 == (safe_lshift_func_uint16_t_u_s(l_591.f3, 5)))), ((((safe_add_func_int16_t_s_s((safe_add_func_int32_t_s_s(l_609, (l_610 == l_610))), l_609)) , (void*)0) != l_611) == 1U))) == 1) , 0x12CF) & p_39))) | l_533.f3))) >= p_41) <= l_541);
                    }
                    l_612 = func_62(p_41, (l_575 , p_42), l_575.f3);
                    /* statement id: 288 */
                    assert (l_612 == 0);
                }
                /* facts after branching */
                assert (l_612 == 0 || l_612 == &l_541);
                l_613 = &l_52;
                for (l_575.f3 = 0; (l_575.f3 >= 5); ++l_575.f3)
                { /* block id: 293 */
                    int16_t l_621 = 1;
                    int32_t **l_629 = &l_612;
                    for (l_516.f2 = 0; (l_516.f2 > (-14)); l_516.f2 = safe_sub_func_uint16_t_u_u(l_516.f2, 1))
                    { /* block id: 296 */
                        union U2 **l_623 = &l_611;
                        (*l_623) = (((safe_sub_func_int16_t_s_s((func_72(&l_541, ((l_620 && 0x5998) , (*p_42)), l_575, p_42) , p_39), (0xC198CED1 >= l_621))) , (-3)) , l_622);
                        if (l_516.f1)
                            break;
                        return p_42;
                        /* statement id: 299 */
                        //assert (func_38_rv == &l_49);
                    }
                    /* facts after for loop */
                                        for (p_39 = (-27); (p_39 >= (-1)); ++p_39)
                    { /* block id: 303 */
                        (*p_43) = (l_626 , ((4294967286U >= (__builtin_bswap64(l_516.f1) & p_39)) , __builtin_ffsl(((safe_add_func_int32_t_s_s((*p_43), __builtin_ffsl(p_39))) , l_582.f2))));
                        (*l_542) = (__builtin_popcount(l_621) == p_39);
                        return p_42;
                        /* statement id: 306 */
                        //assert (func_38_rv == &l_49);
                    }
                    (*l_629) = &l_52;
                    /* statement id: 308 */
                    assert (l_612 == &l_52);
                }
                /* facts after for loop */
                                assert (l_612 == &l_52 || l_612 == 0 || l_612 == &l_541);
            }
            /* facts after branching */
            assert (l_612 == &l_52 || l_612 == 0 || l_612 == &l_541);
            (*l_631) = func_62(p_41, func_81(p_39, l_533.f0, p_39), ((!p_39) < func_55((0xF501 != (1U & (*p_43))), &l_546, (*l_613), p_39, &l_546)));
            /* statement id: 311 */
            assert (l_613 == 0);
            (*l_631) = ((&p_42 != (void*)0) , &p_39);
            /* statement id: 312 */
            assert (l_613 == &p_39);
        }
        else
        { /* block id: 313 */
            float l_641 = (-0x9.9p+1);
            int32_t l_643 = 0xA54C4FB2;
            const union U0 **l_651 = (void*)0;
            union U1 ****l_657 = &l_594;
            const union U2 l_659 = {-4};
            union U0 *l_660 = &l_575;
            if (l_516.f0)
                goto lbl_632;
            if ((1U != ((p_41 != ((-((safe_add_func_float_f_f(((safe_mul_func_float_f_f((0x0.Ap+1 == ((*l_532) , __builtin_clzll((&p_43 == &p_43)))), (((safe_add_func_float_f_f((-(p_40 >= l_52)), 0x2.ED126Dp-48)) > (*l_613)) < p_40))) == p_39), 0x0.0p+1)) == 0x4.7p+1)) != 0x6.9D3782p-76)) , (*p_43))))
            { /* block id: 315 */
                int32_t l_642 = 0xC890187A;
                const union U0 *l_649 = &l_575;
                int32_t **l_652 = &l_613;
                union U1 l_662 = {0x146A0C74};
                union U1 l_678 = {0xD1830DB0};
                uint16_t l_693 = 0x7830;
                union U1 ****l_706 = &l_594;
                (*l_652) = func_62(l_642, func_110(func_62(l_643, ((((safe_add_func_int32_t_s_s((*p_43), (*p_43))) <= (*p_43)) <= (*p_43)) , l_649), l_650), p_39, l_651), (*l_613));
                /* statement id: 316 */
                assert (l_613 == 0);
                (*l_652) = &l_52;
                /* statement id: 317 */
                assert (l_613 == &l_52);
                if (((((l_653 != ((safe_rshift_func_uint16_t_u_u((__builtin_ctzll(p_39) && p_39), 14)) , l_657)) , ((l_658 , &p_43) == &l_613)) , ((l_659 , (void*)0) == (*l_653))) < l_659.f2))
                { /* block id: 318 */
                    union U0 l_661 = {0xB.A11204p+45};
                    (*l_652) = func_77(l_660, l_661, l_662);
                    /* statement id: 319 */
                    assert (l_613 == 0);
                }
                else
                { /* block id: 320 */
                    uint8_t l_665 = 254U;
                    union U0 l_677 = {0x6.8p-1};
                    float *l_684 = (void*)0;
                    (*l_613) = (safe_mod_func_uint32_t_u_u(l_665, ((safe_rshift_func_int16_t_s_u((((p_41 ^ (safe_rshift_func_int16_t_s_s(((-1) != ((safe_lshift_func_uint16_t_u_u((*l_646), (*l_613))) , (((*l_613) , (((safe_lshift_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((!func_72(&l_541, (*p_42), l_677, l_660)), 4294967288U)), (*l_613))) & (*p_43)) >= (-10))) | 0x4C98))), 8))) , (*l_613)) > (*p_43)), 10)) , p_39)));
                    p_43 = (l_678 , func_77(p_42, (*p_42), (****l_657)));
                    /* statement id: 322 */
                    assert (p_43 == 0);
                    for (l_553 = 27; (l_553 <= 30); ++l_553)
                    { /* block id: 325 */
                        uint16_t l_696 = 65535U;
                        union U0 *l_701 = &l_575;
                    }
                }
                /* facts after branching */
                //assert (p_43 == 0 || p_43 == &l_35);
                assert (l_613 == &l_52 || l_613 == 0);
                p_39 = (0 < __builtin_ctz((((*l_646) != func_55((((l_659.f1 , l_706) != l_706) > (!0xC977F39D)), (((__builtin_bswap64((((safe_rshift_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((((*l_646) && p_39) <= p_39), (*l_646))), p_39)) <= 0x259331DF) | p_41)) >= l_659.f2) != (-0x8.2p+1)) , &p_39), p_41, p_39, (*l_652))) ^ (*l_646))));
            }
            else
            { /* block id: 333 */
                int32_t l_712 = 0x46142985;
                int32_t **l_716 = &l_613;
                (*l_716) = func_62((__builtin_ffsl(l_712) , (p_39 & (!(*l_613)))), l_660, (((((safe_rshift_func_uint16_t_u_u(((*p_43) , __builtin_parityl((*l_613))), __builtin_clzll(((&p_39 == (void*)0) , l_712)))) , (*l_646)) ^ l_712) | p_39) > p_39));
                /* statement id: 334 */
                assert (l_613 == 0);
            }
            /* facts after branching */
            //assert (p_43 == 0 || p_43 == &l_35);
            assert (l_613 == &l_52 || l_613 == 0);
        }
        /* facts after branching */
        //assert (p_43 == 0 || p_43 == &l_35);
        assert (l_613 == &l_52 || l_613 == 0 || l_613 == &p_39);
    }
    /* facts after branching */
    //assert (p_43 == 0 || p_43 == &l_35 || p_43 == &p_39);
    return p_42;
    /* statement id: 338 */
    //assert (func_38_rv == &l_49);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_53(int32_t * p_54)
{ /* block id: 40 */
    uint32_t l_61 = 0x99C77E21;
    int32_t l_88 = 1;
    int32_t *l_87 = &l_88;
    union U2 l_89 = {0};
    union U0 l_173 = {0xC.8C1DB4p-28};
    union U1 l_174 = {-7};
    if (((func_55(l_61, func_62(l_61, func_66((((+((func_72(func_77(func_81(((((safe_mod_func_uint32_t_u_u((l_87 == (void*)0), (*l_87))) > __builtin_clzl((*l_87))) > ((l_89 , ((safe_add_func_uint32_t_u_u((*l_87), 0U)) & 0U)) < 8U)) <= (*l_87)), (*l_87), (*l_87)), l_173, l_174), l_173, l_173, &l_173) != (*l_87)) > (*l_87))) , 65535U) , (*l_87)), &l_88, &l_88, &l_173), (*l_87)), (*l_87), (*l_87), &l_88) != (*l_87)) || (*p_54)))
    { /* block id: 234 */
        float l_508 = 0x5.C2D764p-10;
        int32_t l_509 = 0x59E94AA8;
        return l_509;
    }
    else
    { /* block id: 236 */
        union U0 *l_510 = &l_173;
        union U0 **l_511 = (void*)0;
        union U0 **l_512 = &l_510;
        int32_t **l_513 = &l_87;
        (*l_512) = l_510;
        (*l_513) = p_54;
        /* statement id: 238 */
        //assert (l_87 == &l_52 || l_87 == &p_39);
    }
    /* facts after branching */
    //assert (l_87 == &l_52 || l_87 == &p_39);
    return (*l_87);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_55(int16_t  p_56, int32_t * p_57, int32_t  p_58, uint32_t  p_59, int32_t * p_60)
{ /* block id: 231 */
    int32_t l_507 = (-3);
    int32_t *l_506 = &l_507;
    int32_t **l_505 = &l_506;
    (*l_505) = p_57;
    /* statement id: 232 */
    //assert (l_506 == 0 || l_506 == &l_546 || l_506 == &l_543 || l_506 == &l_52 || l_506 == &l_541 || l_506 == &p_39);
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_62(int32_t  p_63, const union U0 * p_64, uint8_t  p_65)
{ /* block id: 229 */
    int32_t l_503 = 0xEDE7A547;
    int32_t *l_502 = &l_503;
    int32_t *l_504 = (void*)0;
    return l_504;
    /* statement id: 230 */
    //assert (func_62_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const union U0 * func_66(uint8_t  p_67, const int32_t * p_68, int32_t * p_69, const union U0 * p_70)
{ /* block id: 225 */
    float l_494 = 0x0.6p+1;
    int32_t l_495 = 0xFB32BE0F;
    const union U1 l_496 = {1};
    float *l_497 = &l_494;
    union U0 l_499 = {0x1.Fp-1};
    union U0 *l_498 = &l_499;
    const union U0 *l_501 = &l_499;
    const union U0 **l_500 = &l_501;
    (*l_497) = (safe_add_func_float_f_f((l_494 == p_67), (l_495 < (l_496 , (-0x3.Ep+1)))));
    (*l_500) = func_110(func_77(l_498, (__builtin_parityl(l_499.f1) , (*l_498)), l_496), l_496.f1, l_500);
    /* statement id: 227 */
    assert (l_501 == 0);
    return p_70;
    /* statement id: 228 */
    //assert (func_66_rv == &l_173);
}


/* ------------------------------------------ */
/* 
 * reads : l_49
 * writes:
 */
static const int32_t  func_72(int32_t * p_73, union U0  p_74, union U0  p_75, union U0 * p_76)
{ /* block id: 86 */
    int32_t l_213 = 0x3243ED31;
    float l_223 = (-0x1.7p+1);
    float *l_222 = &l_223;
    union U0 *l_252 = (void*)0;
    union U0 **l_251 = &l_252;
    union U0 ***l_250 = &l_251;
    uint16_t l_278 = 0xFE40;
    int32_t l_302 = (-1);
    union U1 l_307 = {0x03D4C3E8};
    uint16_t l_317 = 1U;
    uint32_t l_321 = 4294967289U;
    uint16_t l_329 = 7U;
    int32_t *l_333 = &l_213;
    union U2 l_339 = {1};
    uint8_t l_442 = 0xD3;
    int32_t *l_489 = &l_213;
    const float l_490 = 0xB.8AEB0Bp-82;
    const uint8_t l_491 = 249U;
    (*l_222) = (((void*)0 != &p_75) != (safe_sub_func_float_f_f(((safe_mul_func_float_f_f(l_213, (safe_sub_func_float_f_f(p_75.f1, p_75.f1)))) <= ((safe_add_func_float_f_f(0xB.B7C7E5p+1, (((p_75.f1 == ((safe_sub_func_int16_t_s_s(((p_75.f1 , (safe_rshift_func_uint16_t_u_s((l_213 == p_74.f1), 1))) <= (-10)), 0xA6C6)) > 1U)) , (-0x1.3p+1)) == p_75.f1))) == l_213)), 0x1.Ep-1)));
lbl_486:
    if ((__builtin_popcountl(p_75.f1) | __builtin_bswap32(l_213)))
    { /* block id: 88 */
        uint32_t l_226 = 4294967295U;
        int32_t *l_227 = &l_213;
        (*l_227) = ((safe_add_func_uint16_t_u_u(0x4D08, 0xCDCB)) ^ l_226);
    }
    else
    { /* block id: 90 */
        union U2 l_228 = {0xF157};
        int32_t *l_233 = (void*)0;
        union U0 *l_235 = (void*)0;
        union U0 **l_234 = &l_235;
        const union U1 l_240 = {0x917E9C42};
        union U1 l_266 = {3};
        union U1 *l_265 = &l_266;
        union U1 **l_264 = &l_265;
        uint8_t l_310 = 0U;
        uint32_t l_330 = 0x59E138D6;
        float *l_337 = &l_223;
        const union U0 *l_341 = (void*)0;
        const union U0 **l_340 = &l_341;
        uint8_t l_343 = 253U;
        l_213 = __builtin_ffsll((((l_228 , (l_228.f0 >= ((safe_lshift_func_int16_t_s_u(p_75.f2, l_213)) > (safe_rshift_func_int16_t_s_u(((p_73 != (void*)0) , p_75.f2), 10))))) & p_74.f3) , ((l_228.f0 ^ l_213) & 65529U)));
        if ((((p_74.f2 || ((void*)0 == l_234)) > (((l_213 < l_213) , (p_74.f3 & ((safe_mul_func_int16_t_s_s(p_75.f1, (safe_add_func_uint32_t_u_u((l_240 , (safe_rshift_func_uint16_t_u_u(l_213, l_213))), 0x9FB79091)))) ^ p_74.f1))) && (-1))) < l_213))
        { /* block id: 92 */
            uint8_t l_243 = 5U;
            union U0 ***l_249 = &l_234;
            float *l_253 = &l_223;
            int32_t **l_303 = &l_233;
            union U2 l_305 = {5};
            union U1 *l_324 = &l_266;
            if (((((((l_243 && 0U) & p_74.f2) < (~((p_75.f1 ^ (safe_mul_func_int16_t_s_s(p_74.f1, (safe_lshift_func_uint16_t_u_s((l_249 != l_250), 5))))) , (l_253 != l_233)))) | l_213) , l_213) > l_228.f2))
            { /* block id: 93 */
                union U1 *l_254 = (void*)0;
                union U1 **l_255 = (void*)0;
                union U1 **l_256 = &l_254;
                (*l_256) = l_254;
            }
            else
            { /* block id: 95 */
                int32_t **l_257 = &l_233;
                uint32_t l_263 = 0x1827553D;
                (*l_257) = p_73;
                /* statement id: 96 */
                //assert (l_233 == 0 || l_233 == &l_213 || l_233 == &l_52 || l_233 == &l_541 || l_233 == &p_39);
                for (p_74.f3 = 0; (p_74.f3 >= 35); ++p_74.f3)
                { /* block id: 99 */
                    int32_t l_277 = 0xDCF8AAB9;
                    int32_t *l_279 = &l_213;
                    union U0 l_306 = {0x2.53CF45p+63};
                    union U1 l_309 = {-8};
                    p_75.f0 = ((__builtin_ctzll((safe_lshift_func_uint16_t_u_s((p_75.f3 & (p_75.f1 != l_243)), 3))) , (((p_74.f2 , ((p_75.f3 , ((((!(l_263 < __builtin_ffsll(p_74.f1))) | 0) >= p_74.f2) , p_75.f1)) , (void*)0)) == l_264) <= 0xF.FE4C1Cp-53)) != 0x1.EA1316p-45);
                    (*l_279) = ((((safe_rshift_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u(((safe_mod_func_int16_t_s_s(((p_74.f3 != ((safe_lshift_func_int16_t_s_u((l_243 < (p_75.f1 <= l_243)), (safe_mul_func_int16_t_s_s(l_277, p_74.f1)))) & p_75.f2)) > (0xF465C114 ^ (p_75.f2 && (-4)))), p_75.f1)) & l_213), p_74.f1)) > p_75.f1), 3)) >= (-1)) >= l_278) | p_75.f3);
                    (*l_279) = (p_74.f2 , __builtin_popcountll(((safe_mod_func_uint32_t_u_u(1U, (__builtin_ctz(p_75.f2) || ((~p_74.f3) & ((0xBC2A < ((((~(safe_add_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u(l_243, 65533U)), __builtin_ctz((safe_lshift_func_uint16_t_u_s((safe_rshift_func_int16_t_s_u((l_243 ^ p_75.f2), 10)), 4)))))) || p_74.f1) > p_75.f1) == l_243)) ^ 0xAD8F))))) && p_74.f3)));
                    if (l_213)
                    { /* block id: 103 */
                        int32_t l_304 = 0;
                        (*l_222) = ((*l_250) != (void*)0);
                        (*l_303) = (((safe_rshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_u((*l_279), 14)), ((safe_rshift_func_uint16_t_u_s(((safe_lshift_func_uint16_t_u_s((l_228 , ((safe_rshift_func_int16_t_s_s((0x3D75 == l_213), 6)) , p_74.f2)), l_302)) , p_75.f3), (l_257 != l_303))) && l_228.f0))) != l_304) , l_279);
                        /* statement id: 105 */
                        assert (l_233 == &l_213);
                        (*l_257) = (l_305 , func_77((**l_250), l_306, l_307));
                        /* statement id: 106 */
                        assert (l_233 == 0);
                    }
                    else
                    { /* block id: 107 */
                        union U0 *l_308 = &l_306;
                        (*l_303) = func_77(l_308, (*l_308), ((*p_76) , ((&l_235 == (void*)0) , l_309)));
                        /* statement id: 108 */
                        assert (l_233 == 0);
                        p_73 = (*l_257);
                        /* statement id: 109 */
                        assert (p_73 == 0);
                        (*l_303) = (void*)0;
                    }
                    /* facts after branching */
                    assert (l_233 == 0);
                }
                /* facts after for loop */
                            }
            /* facts after branching */
            //assert (l_233 == 0 || l_233 == &l_213 || l_233 == &l_52 || l_233 == &l_541 || l_233 == &p_39);
            (*l_303) = func_77((*l_251), (*p_76), (((__builtin_clzl(p_74.f3) ^ 0x2D3B933D) > l_310) , l_307));
            /* statement id: 114 */
            assert (l_233 == 0);
            if (((((~(p_75.f2 != (safe_add_func_int16_t_s_s(l_213, (safe_mul_func_uint16_t_u_u(l_278, l_307.f2)))))) || (+3U)) & p_74.f2) | (l_317 && p_75.f3)))
            { /* block id: 115 */
                int32_t *l_318 = &l_213;
                p_73 = l_318;
                /* statement id: 116 */
                assert (p_73 == &l_213);
            }
            else
            { /* block id: 117 */
                uint32_t l_319 = 0xA67FCE75;
                (*l_303) = ((p_75.f3 , (((0U | (l_305 , l_319)) , (+l_321)) >= (safe_sub_func_uint16_t_u_u(((void*)0 == &p_74), p_74.f1)))) , (void*)0);
                (*l_264) = l_324;
                for (l_266.f0 = 0; (l_266.f0 != 14); l_266.f0 = safe_add_func_int32_t_s_s(l_266.f0, 1))
                { /* block id: 122 */
                    union U2 *l_332 = &l_228;
                    union U2 **l_331 = &l_332;
                    (*l_253) = ((0xD0EAF788 > (1 & (0xF3E3 || p_74.f3))) , ((safe_add_func_float_f_f(((void*)0 != &l_235), l_329)) > l_330));
                    (*l_331) = &l_305;
                    /* statement id: 124 */
                    assert (l_332 == &l_305);
                }
                l_333 = (*l_303);
                /* statement id: 126 */
                assert (l_333 == 0);
            }
        }
        else
        { /* block id: 128 */
            const union U1 *l_336 = &l_240;
            const union U1 **l_335 = &l_336;
            const union U1 ***l_334 = &l_335;
            int32_t l_351 = 0x64A5F262;
            union U1 ***l_396 = &l_264;
            union U1 ****l_395 = &l_396;
            union U0 l_411 = {0x1.Dp+1};
            const union U0 ***l_439 = &l_340;
            const union U0 ****l_438 = &l_439;
            union U2 *l_483 = &l_339;
            union U2 **l_482 = &l_483;
            (*l_334) = (void*)0;
            /* statement id: 129 */
            assert (l_335 == 0);
        }
    }
    for (p_74.f3 = 0; (p_74.f3 != 10); p_74.f3 = safe_add_func_uint32_t_u_u(p_74.f3, 1))
    { /* block id: 219 */
        const union U1 l_487 = {1};
        union U1 *l_488 = &l_307;
        if (l_329)
            goto lbl_486;
        l_213 = ((l_487 , &l_307) != (p_75.f1 , l_488));
    }
    /* facts after for loop */
        (*l_489) = p_74.f2;
    return l_491;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_77(union U0 * p_78, union U0  p_79, union U1  p_80)
{ /* block id: 76 */
    int32_t l_179 = (-8);
    union U2 l_180 = {-1};
    union U0 l_183 = {0x8.C8820Dp-62};
    union U1 l_190 = {-1};
    float *l_191 = (void*)0;
    int32_t *l_197 = &l_179;
    int32_t *l_198 = &l_179;
    int32_t *l_199 = &l_179;
    l_179 = (p_80.f1 <= (((safe_add_func_float_f_f(p_79.f3, (safe_add_func_float_f_f((l_179 , p_79.f2), l_179)))) != (l_180 , ((safe_sub_func_float_f_f(((l_180.f0 >= l_180.f1) != ((l_183 , (void*)0) == (void*)0)), 0xE.AD63A6p-93)) != p_79.f3))) == l_180.f1));
    if (l_180.f1)
    { /* block id: 78 */
        uint32_t l_186 = 0U;
        float *l_187 = &l_183.f0;
        int32_t *l_192 = &l_179;
        int32_t *l_193 = &l_179;
        int32_t *l_194 = &l_179;
        int32_t *l_195 = &l_179;
        int32_t *l_196 = &l_179;
        int32_t *l_200 = &l_179;
        int32_t *l_201 = (void*)0;
        (*l_192) = ((safe_sub_func_uint16_t_u_u((l_186 < ((l_187 != ((l_180 , ((safe_add_func_int32_t_s_s(((l_190 , (0xEE31 & ((void*)0 == l_191))) || (0 == (0xAA95 == l_190.f4))), p_80.f3)) | l_186)) , l_187)) , p_80.f4)), l_190.f1)) < p_80.f3);
        return l_201;
        /* statement id: 80 */
        //assert (func_77_rv == 0);
    }
    else
    { /* block id: 81 */
        uint32_t l_204 = 2U;
        union U2 l_205 = {0xD7D7};
        union U0 *l_207 = &l_183;
        union U0 **l_206 = &l_207;
        float *l_208 = (void*)0;
        p_79.f0 = __builtin_popcountll((safe_mul_func_int16_t_s_s(((l_204 , (((*l_199) , &p_78) != (p_79.f2 , &p_78))) , (*l_198)), (*l_199))));
        p_79.f0 = (p_79.f3 <= (l_204 != (((l_205 , l_206) != &p_78) >= l_205.f2)));
        return l_208;
        /* statement id: 84 */
        //assert (func_77_rv == 0);
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0 * func_81(uint32_t  p_82, uint16_t  p_83, int16_t  p_84)
{ /* block id: 41 */
    const union U0 *l_116 = (void*)0;
    const union U0 **l_115 = &l_116;
    int32_t l_142 = 0x996BB96E;
    const uint32_t l_158 = 6U;
    union U0 l_169 = {0x1.2p-1};
    union U0 *l_168 = &l_169;
    union U0 *l_170 = &l_169;
    union U0 *l_171 = &l_169;
    union U0 *l_172 = (void*)0;
    for (p_82 = 0; (p_82 < 7); p_82 = safe_add_func_uint16_t_u_u(p_82, 1))
    { /* block id: 44 */
        int32_t l_95 = 6;
        int32_t *l_94 = &l_95;
        union U0 *l_107 = (void*)0;
        const uint16_t l_136 = 0U;
        union U0 **l_148 = &l_107;
        union U0 ***l_147 = &l_148;
        l_94 = (void*)0;
        /* statement id: 45 */
        assert (l_94 == 0);
        for (l_95 = 0; (l_95 < (-30)); l_95 = safe_sub_func_int32_t_s_s(l_95, 9))
        { /* block id: 48 */
            uint32_t l_98 = 0x8F8F04B7;
            int32_t l_141 = (-2);
            union U0 *l_163 = (void*)0;
            if (p_83)
                break;
            if (l_98)
                continue;
            for (l_98 = (-12); (l_98 == 53); l_98 = safe_add_func_int32_t_s_s(l_98, 3))
            { /* block id: 53 */
                union U0 **l_101 = (void*)0;
                union U0 l_104 = {0x0.D4DC45p-66};
                union U0 *l_103 = &l_104;
                union U0 **l_102 = &l_103;
                int32_t l_146 = (-1);
                (*l_102) = (void*)0;
                /* statement id: 54 */
                assert (l_103 == 0);
                for (l_104.f3 = 0; (l_104.f3 <= 38); l_104.f3 = safe_add_func_uint32_t_u_u(l_104.f3, 5))
                { /* block id: 57 */
                    int32_t l_109 = 0x4A170516;
                    union U0 *l_164 = &l_104;
                    float *l_165 = (void*)0;
                    float l_167 = 0x1.2p+1;
                    float *l_166 = &l_167;
                    if (p_82)
                    { /* block id: 58 */
                        const int32_t *l_114 = &l_109;
                        float *l_137 = (void*)0;
                        float *l_138 = (void*)0;
                        float l_140 = 0x1.2p-1;
                        float *l_139 = &l_140;
                        int32_t *l_144 = (void*)0;
                        int32_t *l_145 = &l_142;
                        (*l_139) = (((l_107 != ((~l_109) , func_110((p_82 , l_114), l_109, l_115))) < p_82) != ((safe_mul_func_float_f_f((&l_116 != &l_116), l_136)) < p_84));
                        l_141 = (l_109 != p_84);
                        if (l_142)
                            continue;
                        (*l_145) = ((((safe_unary_minus_func_int16_t_s(p_82)) & l_142) & p_83) >= l_98);
                    }
                    else
                    { /* block id: 66 */
                        union U0 ****l_149 = &l_147;
                        l_146 = p_82;
                        (*l_149) = l_147;
                    }
                    (*l_166) = (safe_sub_func_float_f_f(((((safe_rshift_func_uint16_t_u_u((((0x159A5490 & (safe_mul_func_uint16_t_u_u((safe_mul_func_int16_t_s_s((-2), (p_83 >= l_158))), (l_109 != (safe_sub_func_int32_t_s_s((p_82 , ((safe_mod_func_int32_t_s_s(p_83, l_158)) , (l_163 == l_164))), p_83)))))) || 1U) ^ p_83), 11)) , p_83) == p_83) , 0x1.91451Fp-73), p_82));
                }
                /* facts after for loop */
                            }
        }
    }
    return l_172;
    /* statement id: 75 */
    //assert (func_81_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_110(const int32_t * p_111, int16_t  p_112, const union U0 ** p_113)
{ /* block id: 59 */
    union U0 l_120 = {0x1.4p+1};
    union U0 *l_119 = &l_120;
    union U0 **l_118 = &l_119;
    union U0 ***l_117 = &l_118;
    union U0 ****l_121 = &l_117;
    union U0 *l_122 = &l_120;
    union U0 *l_123 = &l_120;
    union U0 *l_124 = &l_120;
    union U0 *l_125 = &l_120;
    union U0 *l_126 = &l_120;
    union U0 *l_127 = &l_120;
    union U0 *l_128 = &l_120;
    union U0 *l_129 = &l_120;
    union U0 *l_130 = &l_120;
    union U0 *l_131 = &l_120;
    union U0 *l_132 = &l_120;
    union U0 *l_133 = (void*)0;
    (*l_121) = l_117;
    return l_133;
    /* statement id: 61 */
    //assert (func_110_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 211
XXX total union variables: 38

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 56
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 26
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 6
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 34
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 30
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 33

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 141
   depth: 2, occurrence: 18
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 6
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 6
   depth: 9, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 4
   depth: 14, occurrence: 4
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 3
   depth: 18, occurrence: 4
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 201

XXX times a variable address is taken: 219
XXX times a pointer is dereferenced on RHS: 111
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 9
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 97
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 832

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 886
   level: 2, occurrence: 43
   level: 3, occurrence: 6
   level: 4, occurrence: 5
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 60
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.4
XXX average alias set size: 1.29

XXX times a non-volatile is read: 861
XXX times a non-volatile is write: 237
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 7

XXX stmts: 133
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 20
   depth: 2, occurrence: 16
   depth: 3, occurrence: 22
   depth: 4, occurrence: 24
   depth: 5, occurrence: 25

XXX percentage a fresh-made variable is used: 14.3
XXX percentage an existing variable is used: 85.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

