/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --math64 --inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3735137614
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint8_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   const uint32_t  f3;
   const int64_t  f4;
   uint8_t  f5;
   const uint32_t  f6;
   uint32_t  f7;
   int16_t  f8;
   const uint8_t  f9;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   struct S0  f0;
   int32_t  f1;
   struct S0  f2;
   uint8_t  f3;
   int32_t  f4;
   uint8_t  f5;
   const uint8_t  f6;
   uint16_t  f7;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_1(void);
inline static int32_t * func_4(int16_t  p_5, int32_t * p_6);
inline static int16_t  func_7(uint16_t  p_8, int32_t * p_9, uint64_t  p_10, int64_t  p_11);
static uint64_t  func_17(struct S0  p_18, uint32_t  p_19, int32_t  p_20);
static const uint64_t  func_43(int32_t * p_44, int32_t * p_45, int32_t * p_46, int32_t * p_47, const struct S0  p_48);
inline static int32_t * func_49(const int16_t  p_50, int16_t  p_51, int32_t * p_52);
inline static int16_t  func_53(int32_t * p_54);
static int64_t  func_56(int32_t * p_57, int32_t * p_58, int32_t * p_59, int32_t  p_60);
static int32_t * func_61(uint32_t  p_62, int32_t  p_63, int64_t  p_64, uint16_t  p_65);
static int64_t  func_72(int16_t  p_73, uint8_t  p_74);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_1(void)
{ /* block id: 0 */
    uint32_t l_3 = 0x1FB8EB5EL;
    int32_t l_15 = (-1L);
    int32_t *l_14 = &l_15;
    struct S0 l_21 = {0x55L,0x4826422FL,0xDC70E74BL,0x9CEC02DFL,0xE95866B3883FAA05LL,0xA1L,0xC444C9CAL,0xCDA6A44FL,0L,1UL};
    int32_t l_22 = 0x04BAE914L;
    int32_t *l_782 = &l_22;
    struct S0 *l_810 = &l_21;
    struct S0 **l_809 = &l_810;
    struct S1 l_844 = {{0x63L,18446744073709551614UL,18446744073709551615UL,1UL,-1L,0x59L,0x58F3E15FL,1UL,-1L,0UL},-1L,{0xDEL,0x234D509EL,0x46868658L,0UL,0x18C0D2EDD572C92CLL,0x67L,18446744073709551607UL,8UL,0L,255UL},1UL,0xBF019CC4L,255UL,0x9CL,0UL};
    struct S1 *l_843 = &l_844;
    struct S1 **l_842 = &l_843;
    struct S1 ***l_841 = &l_842;
    struct S1 ****l_840 = &l_841;
    struct S1 *****l_839 = &l_840;
    uint8_t l_860 = 0x80L;
    uint32_t l_861 = 4294967295UL;
    uint8_t l_862 = 248UL;
    int32_t *l_863 = &l_15;
    int32_t **l_864 = &l_782;
    struct S1 l_866 = {{1UL,1UL,0x362A0705L,0x7C94E506L,0x3AC8BF81D0E2BF87LL,249UL,0xEA6B1524L,4294967287UL,0x3999L,0UL},4L,{1UL,5UL,1UL,0xCAF74087L,0xB4A246E9D4E433F6LL,0xE6L,0x9630B3F9L,0x9D12604DL,0x991AL,0x34L},249UL,0x7B76EADFL,0x63L,0x8AL,65535UL};
    if ((+l_3))
    { /* block id: 1 */
        int32_t *l_16 = &l_15;
        const int32_t *l_785 = &l_15;
        const int32_t **l_784 = &l_785;
        uint32_t l_808 = 0x06B6752CL;
        (*l_784) = func_4(func_7((safe_rshift_func_int16_t_s_u(((l_14 == (void*)0) | ((void*)0 != l_16)), 10)), l_16, func_17(l_21, (*l_16), l_22), (*l_14)), l_782);
        for (l_21.f7 = 0; (l_21.f7 < 33); l_21.f7 = safe_add_func_int32_t_s_s(l_21.f7, 9))
        { /* block id: 359 */
            uint32_t l_790 = 0UL;
            struct S0 *l_792 = &l_21;
            for (l_15 = 0; (l_15 != 8); l_15 = safe_add_func_uint64_t_u_u(l_15, 1))
            { /* block id: 362 */
                uint32_t l_791 = 0x3827218AL;
                struct S0 **l_793 = (void*)0;
                struct S0 **l_794 = &l_792;
                (*l_782) = ((*l_782) && 0x3EB1L);
                (*l_782) = ((l_790 <= l_791) && (-1L));
                if ((*l_14))
                    continue;
                (*l_794) = l_792;
            }
        }
        (*l_14) = ((*l_14) > ((0xCEFC858AL > (((((safe_add_func_int64_t_s_s(((safe_mul_func_int16_t_s_s(0x1EE4L, (safe_add_func_uint16_t_u_u((safe_mul_func_int16_t_s_s((*l_14), ((safe_mul_func_int16_t_s_s((!65529UL), (l_808 == (*l_14)))) & (((65535UL || ((void*)0 == l_809)) || (*l_785)) > (-1L))))), (-1L))))) == (*l_14)), (*l_14))) > (*l_785)) & 0x8F13L) <= (**l_784)) != (*l_782))) & 0xDB383F4DL));
    }
    else
    { /* block id: 370 */
        int32_t *l_811 = &l_22;
        int32_t **l_812 = &l_14;
        struct S0 **l_820 = &l_810;
        struct S1 *****l_845 = &l_840;
        (*l_812) = l_811;
        for (l_21.f7 = (-23); (l_21.f7 != 17); l_21.f7 = safe_add_func_uint16_t_u_u(l_21.f7, 4))
        { /* block id: 374 */
            uint8_t l_819 = 0x82L;
            int32_t *l_827 = (void*)0;
            (*l_14) = (safe_sub_func_int16_t_s_s(((safe_sub_func_int16_t_s_s(l_819, (**l_812))) | ((*l_811) & (&l_810 == l_820))), (safe_sub_func_int64_t_s_s((safe_mul_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u((**l_812), l_819)) == (((l_819 || l_819) && 0L) | 0x8E647224L)), l_819)), (*l_811)))));
            (*l_782) = 0xCD6A3BBEL;
            l_827 = &l_22;
        }
        for (l_21.f5 = 0; (l_21.f5 > 28); l_21.f5 = safe_add_func_uint64_t_u_u(l_21.f5, 1))
        { /* block id: 381 */
            struct S1 l_836 = {{255UL,1UL,0xAFDE37BCL,0xD85D54D6L,0x97E77390D1AF4779LL,1UL,0xBCFD3315L,0UL,0xB6F8L,0xF5L},0x29FA86CBL,{0xAFL,0xC20A3100L,18446744073709551612UL,4294967288UL,0x99B50FA0B01F97FBLL,0x10L,18446744073709551615UL,0UL,1L,0x6FL},0x03L,-1L,255UL,0xFDL,65535UL};
            struct S1 *l_835 = &l_836;
            struct S1 **l_834 = &l_835;
            struct S1 ***l_833 = &l_834;
            struct S1 ****l_832 = &l_833;
            (*l_14) = 0L;
            (*l_14) = (((**l_812) | ((safe_mod_func_uint64_t_u_u((((18446744073709551615UL == ((void*)0 == l_832)) | (safe_sub_func_int16_t_s_s(((((l_839 == (void*)0) < (l_845 != (void*)0)) <= (safe_rshift_func_uint16_t_u_s((safe_mul_func_uint16_t_u_u((0xC585L <= 6UL), 65535UL)), 0))) >= (**l_812)), l_836.f2.f8))) | (*l_811)), 0xDC3925C4F63EBACCLL)) > 0UL)) <= l_836.f2.f0);
            for (l_836.f0.f0 = 0; (l_836.f0.f0 >= 37); l_836.f0.f0 = safe_add_func_int64_t_s_s(l_836.f0.f0, 1))
            { /* block id: 386 */
                int16_t l_852 = 1L;
                if (l_852)
                    break;
                if (l_836.f2.f8)
                    goto lbl_865;
            }
        }
    }
lbl_865:
    (*l_864) = func_49((((*l_14) | (safe_rshift_func_uint16_t_u_s((+65535UL), 4))) && (((*l_14) <= ((safe_add_func_int64_t_s_s(((((*l_782) & ((*l_14) < ((safe_mul_func_int16_t_s_s(l_860, ((void*)0 == &l_22))) || (((*l_782) >= 4L) <= (*l_782))))) != 0xEECFL) >= (*l_14)), (*l_782))) != l_861)) | (*l_782))), l_862, l_863);
    (*l_864) = (*l_864);
    return l_866;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_4(int16_t  p_5, int32_t * p_6)
{ /* block id: 353 */
    int16_t l_783 = 0x93C6L;
    (*p_6) = l_783;
    return p_6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_7(uint16_t  p_8, int32_t * p_9, uint64_t  p_10, int64_t  p_11)
{ /* block id: 296 */
    int32_t l_655 = 0x2C6D27BCL;
    int32_t *l_654 = &l_655;
    int32_t **l_680 = &l_654;
    int32_t ***l_679 = &l_680;
    struct S0 l_682 = {255UL,1UL,0UL,1UL,0L,0x57L,18446744073709551614UL,3UL,0x9509L,6UL};
    struct S0 *l_681 = &l_682;
    const struct S1 *l_687 = (void*)0;
    const struct S1 **l_686 = &l_687;
    const struct S1 ***l_685 = &l_686;
    struct S1 l_695 = {{0x4BL,0UL,18446744073709551615UL,0x5EB5CC27L,-8L,1UL,5UL,0xC0C90F44L,-7L,0xC4L},-9L,{0xE7L,18446744073709551615UL,0xDF371472L,0UL,0x7E7917779D9EC81ALL,1UL,1UL,0xB51A79EFL,0L,247UL},0xB1L,-5L,2UL,0x92L,0x6F1EL};
    struct S1 *l_694 = &l_695;
    struct S1 **l_693 = &l_694;
    struct S1 ***l_692 = &l_693;
    struct S1 ****l_691 = &l_692;
    struct S1 *****l_690 = &l_691;
    uint32_t l_737 = 0x72203BE5L;
    struct S1 *l_738 = &l_695;
    for (p_8 = 0; (p_8 < 21); p_8 = safe_add_func_int16_t_s_s(p_8, 9))
    { /* block id: 299 */
        const int32_t *l_657 = &l_655;
        const int32_t **l_656 = &l_657;
        uint32_t l_704 = 0x64FED14BL;
        struct S1 *l_718 = &l_695;
        const struct S1 ****l_724 = &l_685;
        (*l_656) = l_654;
    }
    (*l_686) = l_738;
lbl_780:
    for (l_695.f2.f5 = 21; (l_695.f2.f5 != 45); l_695.f2.f5 = safe_add_func_uint32_t_u_u(l_695.f2.f5, 1))
    { /* block id: 331 */
        uint32_t l_743 = 0xC77157C1L;
        struct S0 l_745 = {250UL,0x501F7D38L,18446744073709551607UL,1UL,-1L,255UL,0xB9D7A5E7L,0x34BBF4C2L,6L,0xABL};
        struct S0 *l_744 = &l_745;
        if ((*p_9))
            break;
    }
    for (l_655 = 0; (l_655 != (-15)); --l_655)
    { /* block id: 346 */
        int16_t l_755 = (-1L);
        struct S1 *****l_777 = &l_691;
        int32_t l_781 = 0xCC2F6187L;
        (*p_9) = ((safe_sub_func_uint16_t_u_u(((~l_755) < (((safe_add_func_uint64_t_u_u((0x2BD5820EL & (safe_sub_func_int32_t_s_s((safe_rshift_func_int16_t_s_u((safe_add_func_int64_t_s_s((safe_add_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(((((safe_rshift_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(l_755, 6)) > (((((((!0xF5A3L) >= (l_777 == (void*)0)) && 0x7EA09EE0L) | (safe_lshift_func_uint16_t_u_s(l_755, (l_755 == (*p_9))))) != 0x0EF8L) ^ p_11) > p_8)), p_11)), p_10)) >= 0x9E785B6265843A4FLL) ^ p_8) && p_11), p_8)), l_755)), l_755)), p_10)), 0L))), (*l_654))) ^ p_10) & (-1L))), 0xBE16L)) > p_10);
        if (l_755)
            goto lbl_780;
        l_781 = (0x5240BB2418FCA682LL >= ((void*)0 == &p_9));
        (****l_690) = (****l_690);
    }
    return p_10;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_17(struct S0  p_18, uint32_t  p_19, int32_t  p_20)
{ /* block id: 2 */
    int32_t l_24 = (-1L);
    const int32_t *l_23 = &l_24;
    int32_t l_179 = (-1L);
    int32_t *l_178 = &l_179;
    struct S1 l_237 = {{0x4FL,0x48EBBB27L,0x3A31FFB4L,0x10920946L,0x8A997E5A0778CE08LL,0x95L,0x207AB9D6L,0x4D865936L,0x6416L,0x31L},6L,{0x2AL,18446744073709551615UL,0xB46EA5D3L,0x2AA08900L,0xF36BC50D1068E37ELL,247UL,0x2DD2EF52L,0x6273A6DBL,0x308CL,1UL},0x4EL,9L,0x8EL,1UL,1UL};
    struct S1 *l_236 = &l_237;
    struct S1 **l_235 = &l_236;
    struct S1 ***l_254 = &l_235;
    struct S1 ****l_253 = &l_254;
    struct S1 ****l_327 = &l_254;
    const uint32_t l_353 = 0xE9650826L;
    int32_t **l_430 = &l_178;
    int32_t ***l_429 = &l_430;
    int32_t *l_443 = &l_179;
    uint16_t l_504 = 0UL;
    int32_t *l_549 = &l_24;
    uint16_t l_618 = 0x8B72L;
    if (((p_20 & ((l_23 == &l_24) ^ 0xF2842C5AL)) < (!p_18.f7)))
    { /* block id: 3 */
        uint32_t l_26 = 1UL;
        int32_t *l_27 = (void*)0;
        int32_t *l_28 = &l_24;
        int64_t l_40 = 0xD91A4AC155EA0D0ALL;
        struct S1 l_201 = {{255UL,18446744073709551615UL,9UL,0UL,0L,249UL,0UL,0x7BD82A38L,0x1637L,251UL},-3L,{0x4AL,0x420E7F85L,0x730D747AL,0x6EE4DCE9L,0xA6969CC8024315AFLL,0x3AL,0xF98AFAD7L,0xC293D81AL,1L,1UL},0x04L,0L,2UL,0x9EL,0xEC6CL};
        struct S1 *l_200 = &l_201;
        struct S1 **l_199 = &l_200;
        l_24 = l_26;
        (*l_28) = ((void*)0 != &l_24);
        (*l_28) = (safe_mul_func_uint16_t_u_u((safe_mul_func_int16_t_s_s(0x09EFL, p_18.f6)), (((*l_23) & (safe_sub_func_uint64_t_u_u((*l_23), p_18.f8))) || p_20)));
        for (p_18.f0 = 7; (p_18.f0 < 24); p_18.f0 = safe_add_func_int16_t_s_s(p_18.f0, 1))
        { /* block id: 9 */
            uint64_t l_39 = 0x46DFF61739BB5F37LL;
            int32_t *l_55 = &l_24;
            const struct S0 l_180 = {5UL,9UL,0x58410184L,6UL,-1L,0xE2L,0UL,1UL,9L,252UL};
            int16_t l_207 = (-6L);
            struct S1 **l_261 = &l_200;
            int32_t **l_269 = (void*)0;
        }
    }
    else
    { /* block id: 121 */
        int32_t **l_278 = &l_178;
        struct S1 *****l_282 = &l_253;
        const int32_t *l_300 = &l_179;
        int32_t ***l_460 = &l_278;
        uint32_t l_476 = 0x58DEC75BL;
        uint32_t l_527 = 0UL;
        struct S0 *l_595 = &l_237.f0;
        struct S0 **l_594 = &l_595;
        uint8_t l_627 = 0x60L;
        for (l_24 = (-19); (l_24 == 14); l_24 = safe_add_func_uint32_t_u_u(l_24, 6))
        { /* block id: 124 */
            uint32_t l_276 = 0UL;
            int32_t *l_367 = (void*)0;
        }
        for (l_237.f2.f2 = (-5); (l_237.f2.f2 != 46); l_237.f2.f2 = safe_add_func_uint32_t_u_u(l_237.f2.f2, 1))
        { /* block id: 193 */
            int32_t l_397 = 1L;
            for (l_237.f3 = 0; (l_237.f3 <= 32); l_237.f3 = safe_add_func_int64_t_s_s(l_237.f3, 1))
            { /* block id: 196 */
                uint8_t l_398 = 251UL;
                struct S1 ****l_400 = &l_254;
                int32_t *l_409 = (void*)0;
                int32_t l_410 = 0x1D7B26AEL;
                int32_t ***l_428 = &l_278;
                uint8_t l_441 = 0x60L;
                uint32_t l_442 = 0x8F5B7B2CL;
            }
            return p_18.f4;
        }
        (*l_460) = &l_300;
    }
    return p_18.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint64_t  func_43(int32_t * p_44, int32_t * p_45, int32_t * p_46, int32_t * p_47, const struct S0  p_48)
{ /* block id: 54 */
    int32_t *l_181 = (void*)0;
    int32_t **l_182 = &l_181;
    int32_t l_183 = (-3L);
    (*l_182) = l_181;
    for (l_183 = 0; (l_183 > 3); l_183 = safe_add_func_int64_t_s_s(l_183, 7))
    { /* block id: 58 */
        if ((*p_47))
            break;
    }
    return p_48.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_49(const int16_t  p_50, int16_t  p_51, int32_t * p_52)
{ /* block id: 44 */
    const int32_t l_163 = 3L;
    const int32_t *l_162 = &l_163;
    int32_t **l_164 = (void*)0;
    struct S1 l_167 = {{7UL,0xE5E4B7D5L,0xDD5D1929L,0UL,0L,0UL,0x5E7FC4C3L,0xC8567E17L,0x4CC0L,255UL},0x086E3D5BL,{0xD4L,0xF5650222L,5UL,4294967295UL,-1L,2UL,18446744073709551613UL,0x50133C60L,0L,1UL},1UL,0x36B34544L,0x11L,0x17L,65530UL};
    struct S1 *l_166 = &l_167;
    struct S1 **l_165 = &l_166;
    struct S1 **l_168 = &l_166;
    int32_t *l_177 = &l_167.f4;
    l_162 = l_162;
    if ((((p_50 | (((l_165 != l_168) != p_51) > p_51)) || (safe_add_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u(0UL, 65534UL)), (0x6EEAL < (p_51 & 0x04B5586E65512604LL))))) != p_50))
    { /* block id: 46 */
        int32_t *l_173 = &l_167.f4;
        (*l_173) = 0x0492071BL;
        return p_52;
    }
    else
    { /* block id: 49 */
        int32_t *l_175 = &l_167.f4;
        int32_t **l_174 = &l_175;
        int32_t *l_176 = &l_167.f4;
        (*l_174) = (void*)0;
        (*l_176) = (*l_162);
    }
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_53(int32_t * p_54)
{ /* block id: 10 */
    uint32_t l_75 = 0xD6691A67L;
    int32_t l_77 = 3L;
    int32_t *l_76 = &l_77;
    int64_t l_160 = 1L;
    (*l_76) = (((func_56(func_61((safe_sub_func_int64_t_s_s((((safe_add_func_uint32_t_u_u((safe_mod_func_int64_t_s_s(((-7L) == func_72(l_75, ((((l_76 == &l_77) & (*l_76)) | ((safe_rshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((*l_76) && (((safe_rshift_func_int16_t_s_s((*l_76), 15)) & (*l_76)) | (safe_add_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((*l_76), 15)), (*l_76))))), 4)), (*l_76))) >= (*l_76))) ^ (*l_76)))), 0xBB3763735208E988LL)), (*l_76))) & (*l_76)) < (*l_76)), (*l_76))), (*l_76), (*l_76), (*l_76)), p_54, &l_77, (*l_76)) <= 18446744073709551606UL) & l_75) == l_75);
    return l_160;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_24
 */
static int64_t  func_56(int32_t * p_57, int32_t * p_58, int32_t * p_59, int32_t  p_60)
{ /* block id: 31 */
    struct S1 l_124 = {{247UL,0x0CF37CF8L,0xE1070539L,0UL,0x61F4025DD5120115LL,0xABL,18446744073709551615UL,0x8655CF95L,1L,0xBBL},1L,{252UL,1UL,0x5C959C00L,0x0DE99574L,0x338B79B9A59BD7B0LL,0x86L,0x58D21332L,0UL,0x2D04L,255UL},0UL,0xBE7C8CA6L,255UL,0xF3L,65527UL};
    struct S1 *l_123 = &l_124;
    struct S1 **l_125 = &l_123;
    struct S1 *l_153 = &l_124;
    uint32_t l_154 = 4UL;
    struct S1 ***l_156 = &l_125;
    struct S1 ****l_155 = &l_156;
    struct S1 *****l_157 = &l_155;
    const int32_t *l_159 = &l_124.f4;
    const int32_t **l_158 = &l_159;
    (*l_125) = l_123;
    for (l_124.f1 = 12; (l_124.f1 < 24); l_124.f1 = safe_add_func_uint64_t_u_u(l_124.f1, 3))
    { /* block id: 35 */
        struct S1 *l_128 = (void*)0;
        (*p_58) = ((((((l_128 != l_128) | p_60) || (!0UL)) == p_60) & (safe_mul_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u(l_124.f5, p_60)) <= (~((((((safe_lshift_func_uint16_t_u_s((~(l_124.f2.f3 <= p_60)), 11)) | p_60) == p_60) == 1L) > l_124.f2.f4) <= 0xDB70B35F69D68153LL))), p_60))) ^ 0UL);
        (*p_59) = (((((safe_add_func_uint32_t_u_u((~(safe_rshift_func_uint16_t_u_s(((safe_sub_func_uint64_t_u_u(((safe_rshift_func_uint16_t_u_s((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_s((p_60 < ((((safe_sub_func_uint16_t_u_u(((-6L) > l_124.f2.f6), (-1L))) < l_124.f0.f6) != ((*p_59) > (l_128 != l_153))) | p_60)), 15)), 14)), p_60)) & 7UL), p_60)) > l_124.f0.f7), p_60))), l_154)) && 4294967292UL) || l_124.f0.f5) == l_124.f0.f3) || 0xB175C3F9L);
    }
    (*l_157) = l_155;
    (*l_158) = p_59;
    return (*l_159);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_61(uint32_t  p_62, int32_t  p_63, int64_t  p_64, uint16_t  p_65)
{ /* block id: 28 */
    int32_t l_116 = 0xD02808DCL;
    int32_t *l_115 = &l_116;
    const int32_t **l_117 = (void*)0;
    int32_t *l_118 = &l_116;
    int32_t *l_119 = &l_116;
    int32_t *l_120 = &l_116;
    int32_t *l_121 = &l_116;
    int32_t *l_122 = (void*)0;
    l_115 = l_115;
    return l_122;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_72(int16_t  p_73, uint8_t  p_74)
{ /* block id: 11 */
    const int32_t l_91 = 0L;
    const int32_t *l_90 = &l_91;
    struct S1 l_102 = {{251UL,0UL,18446744073709551613UL,0xE9465D98L,1L,0x30L,1UL,0xED58CDB4L,0x28A0L,0xA7L},0xD01A8FC3L,{0xF9L,0xB59C6DFEL,0x33B6E2EDL,0x36A15226L,0xB8EAE7A24857036BLL,0x22L,0x2021A1DBL,0UL,0L,0x74L},0x1FL,0x51574812L,0x85L,0UL,0UL};
    struct S1 *l_101 = &l_102;
    struct S1 **l_100 = &l_101;
    uint16_t l_111 = 0xE4E2L;
    if ((safe_sub_func_uint32_t_u_u(0x06A03D0BL, (l_90 == &l_91))))
    { /* block id: 12 */
        struct S1 l_93 = {{0UL,0x34167AD2L,0x03B3C44AL,0x9DA5FDE2L,0xB755D73B7D9658AALL,0x94L,0UL,1UL,2L,7UL},0x50F45F4DL,{0x8BL,18446744073709551612UL,18446744073709551608UL,0x8766912EL,0x1EF5C255F5DB90C3LL,1UL,18446744073709551609UL,4294967294UL,-7L,0UL},0x05L,0x567ADB25L,253UL,0x41L,0xD949L};
        struct S1 *l_92 = &l_93;
        struct S1 **l_94 = &l_92;
        int32_t *l_112 = &l_93.f4;
        (*l_94) = l_92;
        for (l_93.f0.f7 = 0; (l_93.f0.f7 > 2); l_93.f0.f7 = safe_add_func_uint32_t_u_u(l_93.f0.f7, 9))
        { /* block id: 16 */
            struct S1 ***l_97 = &l_94;
            (*l_97) = (void*)0;
        }
        (*l_112) = (((*l_90) > (*l_90)) | ((((((0xC62FL | p_73) || (safe_add_func_uint16_t_u_u((l_100 != (void*)0), (safe_mul_func_int16_t_s_s(((((safe_add_func_uint16_t_u_u((((safe_sub_func_int32_t_s_s(0xB4E2EDBCL, (p_74 | (safe_lshift_func_int16_t_s_s(0xD51DL, p_74))))) == (*l_90)) != (*l_90)), p_74)) & 18446744073709551612UL) <= 7L) < l_111), 0xDE48L))))) >= (*l_90)) || 0UL) || p_73) != p_74));
    }
    else
    { /* block id: 20 */
        for (l_102.f7 = 0; (l_102.f7 > 22); l_102.f7 = safe_add_func_uint16_t_u_u(l_102.f7, 1))
        { /* block id: 23 */
            if (p_74)
                break;
        }
    }
    return p_73;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 161
   depth: 1, occurrence: 2
   depth: 2, occurrence: 1
XXX total union variables: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 18
   depth: 3, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 175

XXX times a variable address is taken: 175
XXX times a pointer is dereferenced on RHS: 198
breakdown:
   depth: 1, occurrence: 152
   depth: 2, occurrence: 25
   depth: 3, occurrence: 16
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 112
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 15
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 40
XXX times a pointer is compared with address of another variable: 22
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 435

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 292
   level: 2, occurrence: 54
   level: 3, occurrence: 30
   level: 4, occurrence: 7
XXX number of pointers point to pointers: 88
XXX number of pointers point to scalars: 59
XXX number of pointers point to structs: 28
XXX percent of pointers has null in alias set: 19.4
XXX average alias set size: 1.19

XXX times a non-volatile is read: 976
XXX times a non-volatile is write: 304
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 77
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 30
   depth: 2, occurrence: 11
   depth: 3, occurrence: 6

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
********************* end of statistics **********************/

