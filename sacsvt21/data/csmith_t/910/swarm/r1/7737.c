/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3480909858
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   uint32_t  f1;
   unsigned f2 : 26;
   uint8_t  f3;
   uint32_t  f4;
};

union U1 {
   uint32_t  f0;
   uint32_t  f1;
   int32_t  f2;
   int32_t  f3;
   uint8_t  f4;
};

union U2 {
   uint16_t  f0;
   signed f1 : 12;
   uint32_t  f2;
   int32_t  f3;
};

union U3 {
   signed f0 : 26;
   uint8_t  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_31(void);
static int32_t  func_32(union U1  p_33, int32_t  p_34, int32_t  p_35, uint32_t  p_36, uint8_t  p_37);
static union U1  func_38(uint32_t  p_39, int16_t  p_40, uint8_t  p_41, int16_t  p_42, union U0  p_43);
static uint8_t  func_45(uint8_t  p_46, uint32_t  p_47, union U1  p_48);
static union U1  func_49(uint32_t  p_50);
static int32_t  func_54(int32_t * p_55, union U2  p_56);
static int32_t * func_57(union U2  p_58, int32_t  p_59, union U1  p_60);
static union U2  func_72(uint32_t  p_73);
static int32_t * func_80(union U1  p_81);
static union U1  func_82(uint32_t  p_83, int32_t * p_84, uint16_t  p_85, int16_t * p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(void)
{ /* block id: 36 */
    uint32_t l_44 = 0xC3D21462;
    union U1 l_179 = {4294967286U};
    union U1 *l_178 = &l_179;
    int16_t l_235 = (-3);
    int16_t *l_234 = &l_235;
    union U0 l_236 = {4};
    int32_t *l_238 = &l_179.f2;
    uint32_t l_261 = 4294967287U;
    uint32_t l_294 = 0xB8499186;
    (*l_238) = func_32(func_38(l_44, l_44, func_45(l_44, l_44, ((*l_178) = func_49(__builtin_ctz(l_44)))), ((*l_234) = l_44), l_236), l_44, l_236.f1, l_236.f3, l_236.f0);
    /* statement id: 148 */
        for (l_179.f4 = 0; (l_179.f4 != 3); l_179.f4 += 1)
    { /* block id: 151 */
        int32_t *l_241 = (void*)0;
        int32_t l_243 = 8;
        int32_t *l_242 = &l_243;
        union U1 **l_246 = &l_178;
        union U2 l_253 = {0x40CA};
        int32_t l_266 = 0xA46E208F;
        union U0 *l_275 = &l_236;
        int32_t *l_278 = &l_243;
        int32_t **l_280 = (void*)0;
        int32_t **l_281 = &l_238;
        if (((*l_242) = 0x02FEEB18))
        { /* block id: 153 */
            union U1 **l_247 = &l_178;
            int32_t **l_252 = &l_241;
            uint16_t *l_254 = (void*)0;
            uint16_t *l_255 = (void*)0;
            uint16_t *l_256 = &l_253.f0;
            int32_t l_262 = 0x18BE7EDE;
            uint32_t *l_263 = &l_236.f1;
            int16_t l_265 = 0;
            int16_t *l_264 = &l_265;
            if ((((*l_264) &= ((int32_t)((l_246 != l_247) && ((*l_242) = ((*l_263) = ((uint32_t)((uint16_t)((*l_256) = func_54(((*l_252) = l_238), l_253)) + (uint16_t)((*l_234) &= ((int16_t)(1U <= (l_262 && (*l_242))) >> (int16_t)13))) % (uint32_t)0x7823F575)))) - (int32_t)l_262)) ^ l_266))
            { /* block id: 160 */
                for (l_261 = 0; (l_261 <= 13); l_261 += 1)
                { /* block id: 163 */
                    int32_t *l_269 = &l_236.f0;
                    int32_t l_272 = (-5);
                    if ((l_269 == l_263))
                    { /* block id: 164 */
                        int32_t l_270 = (-10);
                        return l_270;
                    }
                    else
                    { /* block id: 166 */
                        int16_t l_271 = (-5);
                        (*l_242) &= 1;
                        (*l_242) = l_271;
                    }
                    return l_272;
                }
                if ((*l_242))
                    continue;
                (*l_246) = &l_179;
                for (l_44 = 7; (l_44 < 48); l_44 += 1)
                { /* block id: 176 */
                    l_275 = l_275;
                }
            }
            else
            { /* block id: 179 */
                for (l_265 = 22; (l_265 < (-13)); l_265 -= 2)
                { /* block id: 182 */
                    (*l_242) = ((void*)0 == l_275);
                }
            }
            /* facts after branching */
                        assert (l_241 == 0 || l_241 == &l_179.f2);
            (*l_252) = l_278;
            /* statement id: 186 */
            assert (l_241 == &l_243);
        }
        else
        { /* block id: 187 */
            int32_t l_279 = 0x5867A26E;
            (*l_278) = l_279;
        }
        /* facts after branching */
                assert (l_241 == 0 || l_241 == &l_243);
        (*l_281) = l_238;
    }
    /* facts after for loop */
        for (l_179.f0 = 0; (l_179.f0 >= 41); l_179.f0 += 7)
    { /* block id: 194 */
        union U3 l_285 = {1};
        union U3 *l_284 = &l_285;
        union U3 **l_286 = &l_284;
        int32_t **l_292 = &l_238;
        int32_t ****l_293 = (void*)0;
        (*l_286) = l_284;
        for (l_285.f1 = 0; (l_285.f1 < 31); l_285.f1 += 9)
        { /* block id: 198 */
            int32_t *l_289 = &l_179.f3;
            int32_t **l_290 = (void*)0;
            int32_t **l_291 = &l_238;
            (*l_291) = l_289;
            /* statement id: 199 */
            assert (l_238 == &l_179.f3);
            return l_285.f1;
        }
        /* facts after for loop */
                (*l_292) = l_238;
        l_293 = l_293;
    }
    /* facts after for loop */
        return l_294;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_32(union U1  p_33, int32_t  p_34, int32_t  p_35, uint32_t  p_36, uint8_t  p_37)
{ /* block id: 146 */
    return p_33.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_38(uint32_t  p_39, int16_t  p_40, uint8_t  p_41, int16_t  p_42, union U0  p_43)
{ /* block id: 144 */
    union U1 l_237 = {0x64B53422};
    return l_237;
    /* statement id: 145 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_45(uint8_t  p_46, uint32_t  p_47, union U1  p_48)
{ /* block id: 111 */
    int32_t **l_183 = (void*)0;
    int32_t ***l_182 = &l_183;
    int32_t *l_186 = (void*)0;
    union U2 l_187 = {0xF0C6};
    int32_t l_189 = 0;
    int32_t *l_188 = &l_189;
    uint32_t l_200 = 0xC72CAAA7;
    uint32_t *l_199 = &l_200;
    int32_t *l_201 = &l_189;
    union U1 **l_211 = (void*)0;
    int32_t *l_212 = (void*)0;
    int32_t *l_213 = (void*)0;
    int32_t l_214 = 0;
    union U0 l_230 = {0};
    union U0 *l_229 = &l_230;
    if (((uint16_t)__builtin_clzll(((void*)0 == l_182)) / (uint16_t)((uint16_t)(((*l_188) = func_54(l_186, l_187)) < ((uint16_t)((uint32_t)((uint16_t)((((!(0U == ((*l_199) ^= (((uint16_t)(p_46 | (p_48.f3 | p_46)) * (uint16_t)p_46) != p_48.f3)))) < p_48.f2) != 0x1DCD) & p_47) - (uint16_t)p_46) / (uint32_t)l_187.f0) << (uint16_t)p_48.f2)) * (uint16_t)p_48.f2)))
    { /* block id: 114 */
        int32_t **l_202 = &l_186;
        (*l_202) = l_201;
        /* statement id: 115 */
        assert (l_186 == &l_189);
    }
    else
    { /* block id: 116 */
        int32_t *l_203 = &l_189;
        l_203 = l_203;
        for (l_187.f2 = 0; (l_187.f2 >= 58); l_187.f2 += 4)
        { /* block id: 120 */
            return p_48.f1;
        }
        /* facts after for loop */
            }
    /* facts after branching */
    assert (l_186 == 0 || l_186 == &l_189);
    l_214 &= ((uint16_t)((p_48.f2 <= ((*l_201) |= ((int16_t)(!(-3)) >> (int16_t)14))) != p_48.f0) + (uint16_t)((void*)0 == l_211));
    if (((*l_188) = (~1U)))
    { /* block id: 127 */
        uint16_t l_216 = 0x6BF5;
        return l_216;
    }
    else
    { /* block id: 129 */
        union U1 l_219 = {1U};
        union U1 *l_218 = &l_219;
        union U1 **l_217 = &l_218;
        int32_t *l_228 = &l_214;
        union U0 **l_231 = &l_229;
        (*l_217) = &p_48;
        /* statement id: 130 */
        assert (l_218 == &p_48);
        (*l_188) = 0xB261D961;
        p_48.f2 = ((int32_t)((*l_188) = ((uint32_t)((uint32_t)((uint16_t)p_48.f1 << (uint16_t)6) / (uint32_t)p_47) - (uint32_t)(l_219.f3 = (p_46 ^ l_219.f4)))) / (int32_t)func_54(l_228, func_72(p_48.f3)));
        /* statement id: 134 */
                        (*l_231) = l_229;
    }
    /* facts after branching */
        for (l_230.f0 = 0; (l_230.f0 < 1); l_230.f0 += 1)
    { /* block id: 139 */
        if (p_48.f3)
            break;
    }
    return p_48.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_49(uint32_t  p_50)
{ /* block id: 37 */
    int16_t l_51 = 0x9984;
    int32_t l_53 = 9;
    int32_t *l_52 = &l_53;
    union U2 l_61 = {0x0136};
    union U1 l_62 = {0U};
    (*l_52) ^= (0x8E60 < l_51);
    (*l_52) = func_54(func_57(l_61, p_50, l_62), func_72(p_50));
    return l_62;
    /* statement id: 109 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_54(int32_t * p_55, union U2  p_56)
{ /* block id: 46 */
    int16_t l_75 = 0xDD31;
    uint16_t l_79 = 0x36B8;
    uint32_t l_90 = 0x68021436;
    uint32_t *l_89 = &l_90;
    int32_t **l_174 = (void*)0;
    int32_t l_177 = (-1);
    int32_t *l_176 = &l_177;
    int32_t **l_175 = &l_176;
    if (l_75)
    { /* block id: 47 */
        uint32_t l_76 = 0x3D0097E4;
        return l_76;
    }
    else
    { /* block id: 49 */
        int32_t l_78 = 0x988A21DE;
        int32_t *l_77 = &l_78;
        (*l_77) |= p_56.f0;
        p_56.f1 = l_79;
        /* statement id: 51 */
            }
    /* facts after branching */
        (*l_175) = func_80(func_82((((uint16_t)p_56.f1 % (uint16_t)(p_56.f1 ^ (((l_79 && (-2)) > l_75) || l_75))) >= (((*l_89) |= p_56.f1) && p_56.f1)), l_89, l_75, &l_75));
    /* statement id: 106 */
    assert (l_176 == 0);
    return p_56.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_57(union U2  p_58, int32_t  p_59, union U1  p_60)
{ /* block id: 39 */
    int16_t l_64 = 0;
    int16_t *l_63 = &l_64;
    int32_t l_65 = 0x84CBF776;
    int32_t l_67 = (-5);
    int32_t *l_66 = &l_67;
    int32_t *l_68 = &l_65;
    int32_t *l_69 = &l_65;
    int32_t *l_70 = &l_67;
    int32_t *l_71 = (void*)0;
    (*l_66) ^= (((7U && (((*l_63) = p_60.f1) <= l_65)) != p_60.f0) & l_65);
    (*l_68) |= (((*l_66) != __builtin_ctzl((&p_59 == &p_59))) <= p_60.f3);
    return l_71;
    /* statement id: 43 */
    //assert (func_57_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_72(uint32_t  p_73)
{ /* block id: 44 */
    union U2 l_74 = {65529U};
    return l_74;
    /* statement id: 45 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_80(union U1  p_81)
{ /* block id: 104 */
    int32_t l_170 = 0x7B2EA262;
    int32_t *l_169 = &l_170;
    int32_t *l_171 = &l_170;
    int32_t *l_172 = &l_170;
    int32_t *l_173 = (void*)0;
    return l_173;
    /* statement id: 105 */
    //assert (func_80_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_82(uint32_t  p_83, int32_t * p_84, uint16_t  p_85, int16_t * p_86)
{ /* block id: 54 */
    int32_t l_99 = 0xECEF36AA;
    int32_t *l_98 = &l_99;
    int32_t **l_97 = &l_98;
    int32_t l_157 = 0x3F4C8ED2;
    union U2 l_166 = {0x64B9};
    union U2 *l_165 = &l_166;
    union U1 l_168 = {0U};
    if ((*p_84))
    { /* block id: 55 */
        int32_t l_91 = 0x4B17358D;
        int32_t l_95 = 0x0C4F586F;
        int32_t *l_94 = &l_95;
        int32_t **l_96 = &l_94;
        uint8_t l_109 = 0x96;
        (*p_84) = (l_91 | (((uint32_t)(((*l_96) = l_94) != p_84) - (uint32_t)(p_84 == (void*)0)) || ((*l_98) = (&p_84 != l_97))));
        for (l_99 = 29; (l_99 > 15); l_99 -= 1)
        { /* block id: 61 */
            uint16_t l_104 = 0x1B59;
            int32_t **l_107 = &l_94;
            int32_t **l_108 = &l_94;
            uint32_t l_116 = 0U;
            uint32_t *l_115 = &l_116;
            int16_t l_119 = 6;
            int16_t *l_118 = &l_119;
            int16_t **l_117 = &l_118;
            (*p_84) = (((int32_t)((*l_94) = (l_104 & l_104)) / (int32_t)(*l_98)) || ((int16_t)((*p_86) = (l_104 ^ 0x0B69)) << (int16_t)13));
            l_108 = l_107;
            (**l_96) = ((*l_98) >= (l_109 <= (((int16_t)(((~((**l_97) < ((uint16_t)(((*l_115) = p_85) && (((*l_117) = (void*)0) == (void*)0)) + (uint16_t)((uint16_t)p_85 << (uint16_t)14)))) || (**l_108)) <= (*l_94)) >> (int16_t)p_85) && 0x21CC8E03)));
            /* statement id: 68 */
            assert (l_118 == &l_119 || l_118 == 0);
        }
    }
    else
    { /* block id: 70 */
        int16_t l_122 = (-4);
        uint16_t l_124 = 0x7C9E;
        uint16_t *l_123 = &l_124;
        uint16_t l_126 = 0x0C38;
        uint16_t *l_125 = &l_126;
        uint32_t l_132 = 0x5F07B865;
        uint32_t *l_131 = &l_132;
        int32_t l_153 = 1;
        int32_t *l_152 = &l_153;
        int32_t **l_151 = &l_152;
        union U1 l_167 = {4294967295U};
        if ((4 > (__builtin_popcount(l_122) & ((*l_125) = ((*l_123) = (p_85 != p_83))))))
        { /* block id: 73 */
            int32_t l_128 = 0x8F5B2801;
            int32_t *l_127 = &l_128;
            uint32_t *l_134 = &l_132;
            uint32_t **l_133 = &l_134;
            uint32_t *l_141 = &l_132;
            (*l_98) = ((((__builtin_bswap64((__builtin_ffsl(((*l_127) |= 0x84F164E9)) ^ ((int16_t)(p_84 == ((*l_133) = (l_131 = p_84))) * (int16_t)0xC85B))) >= ((int16_t)(*l_98) * (int16_t)0x2311)) > ((*l_141) = (((int16_t)(__builtin_popcountll(((uint32_t)p_83 + (uint32_t)(*p_84))) == (-4)) >> (int16_t)(**l_97)) && 4))) | l_126) && 6);
            /* statement id: 78 */
            //assert (l_131 == &l_90);
            //assert (l_134 == &l_90);
            for (l_99 = 0; (l_99 != 10); l_99 += 1)
            { /* block id: 81 */
                union U0 l_145 = {-7};
                union U0 *l_144 = &l_145;
                union U0 **l_146 = &l_144;
                (*l_146) = l_144;
                (*p_84) &= ((int16_t)0x70EA / (int16_t)l_145.f4);
            }
        }
        else
        { /* block id: 96 */
            int32_t ***l_160 = &l_151;
            int32_t ****l_159 = &l_160;
            int32_t *****l_158 = &l_159;
            union U1 l_162 = {1U};
            union U1 *l_161 = &l_162;
            union U1 **l_163 = &l_161;
            union U2 *l_164 = (void*)0;
            (*l_158) = (void*)0;
            /* statement id: 97 */
            assert (l_159 == 0);
            (*l_163) = l_161;
            l_165 = l_164;
            /* statement id: 99 */
            assert (l_165 == 0);
        }
        /* facts after branching */
        //assert (l_131 == &l_132 || l_131 == &l_90);
        assert (l_165 == 0 || l_165 == &l_166);
        return l_167;
        /* statement id: 101 */
            }
    return l_168;
    /* statement id: 103 */
    }




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 74
XXX total union variables: 9

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 11
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 6
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 5
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 10
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 5

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 16
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 2
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1

XXX total number of pointers: 87

XXX times a variable address is taken: 79
XXX times a pointer is dereferenced on RHS: 23
breakdown:
   depth: 1, occurrence: 18
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 62
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 5
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 182

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 140
   level: 2, occurrence: 20
   level: 3, occurrence: 14
XXX number of pointers point to pointers: 32
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.3
XXX average alias set size: 1.14

XXX times a non-volatile is read: 245
XXX times a non-volatile is write: 147
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 74
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 22
   depth: 2, occurrence: 14
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 19.8
XXX percentage an existing variable is used: 80.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

