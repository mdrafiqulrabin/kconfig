/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --no-paranoid --pointers --no-structs --unions --no-volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      602479748
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const float  f0;
   int16_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_6 = 0xDB505206;
static int32_t g_52 = 1;
static int32_t *g_51 = &g_52;
static union U0 g_55 = {-0x1.4p-1};
static int32_t ** const g_174 = &g_51;
static int32_t ** const *g_173 = &g_174;
static int32_t ** const **g_172 = &g_173;
static union U0 *g_211 = &g_55;
static union U0 **g_210 = &g_211;
static union U0 ***g_209 = &g_210;
static const union U0 *g_307 = &g_55;
static const union U0 **g_306 = &g_307;
static const union U0 ***g_305 = &g_306;
static const union U0 ****g_304 = &g_305;
static const union U0 *****g_303 = &g_304;
static float g_329 = 0x7.Dp-1;
static int32_t g_346 = (-1);
static int32_t *g_345 = &g_346;
static const union U0 g_406 = {0x9.80F114p-57};
static int32_t g_412 = 1;
static uint32_t g_417 = 9U;
static float **g_460 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
static const union U0  func_26(void);
static int32_t * func_27(float  p_28, int32_t * p_29, int32_t  p_30);
static float  func_32(int32_t  p_33, const union U0  p_34, int32_t  p_35, int32_t * p_36);
static union U0  func_37(const int32_t * p_38, int32_t  p_39, int32_t  p_40);
inline static const int32_t * func_41(uint16_t  p_42, int32_t  p_43, const int16_t  p_44, union U0  p_45);
inline static union U0  func_47(int8_t  p_48, uint16_t  p_49, int32_t * p_50);
inline static const union U0  func_56(uint16_t  p_57, int32_t * p_58);
static int32_t * func_60(int32_t  p_61);
static int32_t  func_62(int32_t * const  p_63, uint32_t  p_64);
static int8_t  func_66(int32_t ** p_67, int32_t * p_68, int32_t ** const  p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_51 g_55 g_55.f1 g_52 g_172 g_173 g_174 g_209 g_345 g_346 g_307 g_210 g_211 g_306 g_305 g_417 g_406.f1 g_412 g_460
 * writes: g_51 g_52 g_55.f1 g_210 g_303 g_329 g_346 g_412 g_6
 */
static const union U0  func_26(void)
{ /* block id: 36 */
    uint32_t l_31 = 0xCB4E76AB;
    int32_t l_46 = 0x3D47941C;
    int32_t *l_411 = &g_412;
    (***g_172) = func_27((l_31 , func_32(l_31, func_37(func_41(l_46, (l_46 != g_6), l_46, func_47((((g_6 , (g_6 ^ l_31)) , g_6) , l_31), g_6, g_51)), g_346, l_46), g_6, l_411)), l_411, g_406.f1);
    return (*g_211);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_174 g_346 g_52 g_55.f1 g_412 g_417 g_172 g_173 g_460
 * writes: g_6 g_51 g_329 g_346 g_52 g_55.f1 g_412
 */
static int32_t * func_27(float  p_28, int32_t * p_29, int32_t  p_30)
{ /* block id: 240 */
    int32_t l_436 = (-1);
    union U0 ***l_461 = &g_210;
    float *l_462 = (void*)0;
    float *l_463 = &g_329;
    for (g_6 = (-27); (g_6 <= 11); g_6 = safe_add_func_int32_t_s_s(g_6, 6))
    { /* block id: 243 */
        int32_t *l_420 = &g_412;
        float *l_421 = &g_329;
        (*g_174) = l_420;
        (*l_421) = p_30;
        for (g_346 = 0; (g_346 <= (-2)); g_346 = safe_sub_func_uint32_t_u_u(g_346, 1))
        { /* block id: 248 */
            uint32_t l_432 = 0x354037CB;
            float * const l_435 = &g_329;
        }
        if (l_436)
            continue;
    }
    for (g_52 = (-11); (g_52 > (-14)); g_52 = safe_sub_func_int16_t_s_s(g_52, 2))
    { /* block id: 256 */
        int16_t l_446 = 0;
        for (g_55.f1 = 0; (g_55.f1 != 10); g_55.f1 = safe_add_func_uint16_t_u_u(g_55.f1, 5))
        { /* block id: 259 */
            if ((*p_29))
            { /* block id: 260 */
                int16_t l_442 = (-7);
                l_442 = ((+p_30) <= g_417);
            }
            else
            { /* block id: 262 */
                int32_t **l_443 = &g_345;
                l_443 = (**g_172);
                (*p_29) = (__builtin_clzll(g_417) >= 0x522CE8A9);
            }
        }
        (**g_173) = p_29;
        l_446 = (safe_lshift_func_int16_t_s_s(p_30, __builtin_ctzl(p_30)));
    }
    (*l_463) = (l_436 != __builtin_parityll(((*p_29) < (safe_sub_func_uint32_t_u_u(((safe_add_func_uint32_t_u_u(((safe_mod_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(0x5AF9, (safe_add_func_int32_t_s_s(((0x088E7B70 < (safe_rshift_func_int16_t_s_s((~(g_460 == (void*)0)), ((l_436 , l_461) != l_461)))) || 8), g_346)))), l_436)) < 0x3CC1), (*p_29))) ^ p_30), p_30)))));
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads : g_52 g_172 g_173 g_174 g_417
 * writes: g_412 g_51
 */
static float  func_32(int32_t  p_33, const union U0  p_34, int32_t  p_35, int32_t * p_36)
{ /* block id: 234 */
    int32_t *l_413 = &g_412;
    union U0 **l_416 = &g_211;
    l_413 = &p_33;
    (*p_36) = (safe_unary_minus_func_uint16_t_u(g_52));
    (*l_413) = (+((void*)0 == l_416));
    (***g_172) = &p_33;
    return g_417;
}


/* ------------------------------------------ */
/* 
 * reads : g_345 g_52 g_346 g_6 g_55.f1 g_172 g_173 g_174 g_307 g_55 g_209 g_210 g_211 g_306 g_51 g_305
 * writes: g_346 g_329 g_51
 */
static union U0  func_37(const int32_t * p_38, int32_t  p_39, int32_t  p_40)
{ /* block id: 198 */
    int8_t l_367 = 0x8C;
    float *l_378 = (void*)0;
    float **l_377 = &l_378;
    float ***l_376 = &l_377;
    uint16_t l_379 = 0x5A51;
    union U0 l_394 = {0xA.4976ADp-25};
    union U0 **** const l_396 = &g_209;
    int32_t l_397 = (-7);
    (*g_345) = 0xA143310F;
    if ((((((*p_38) == (((((void*)0 != &g_304) != (safe_sub_func_int32_t_s_s(((7U > (safe_sub_func_uint32_t_u_u((((((p_40 < g_52) , ((safe_add_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(l_367, g_346)), __builtin_clzll(l_367))), g_55.f1)) && g_346)) < 0x78902750) != 0xFED3E9F7) & g_52), g_346))) , l_367), l_367))) >= (*g_345)) || 0x2C2ECB7F)) & 0xBD54) , 1) > (*p_38)))
    { /* block id: 200 */
        int32_t **l_369 = &g_345;
        int32_t ***l_368 = &l_369;
        float *l_372 = &g_329;
        float **l_371 = &l_372;
        float ***l_370 = &l_371;
        (*l_368) = (**g_172);
        (*g_345) = ((void*)0 != l_370);
    }
    else
    { /* block id: 203 */
        float l_380 = 0x4.AC20B9p+68;
        const int32_t l_388 = (-1);
        const int32_t *l_390 = &g_346;
        const int32_t **l_389 = &l_390;
        union U0 ****l_395 = &g_209;
        int32_t l_410 = (-1);
        (*l_389) = ((safe_mod_func_uint32_t_u_u((p_40 > (!(((void*)0 == l_376) || ((l_379 && ((p_40 , (*p_38)) == (safe_lshift_func_uint16_t_u_u((~l_367), 0)))) <= ((((safe_add_func_int16_t_s_s((safe_add_func_int16_t_s_s(4, 8U)), p_40)) == p_39) < p_40) , l_388))))), g_6)) , p_38);
        if ((+p_40))
        { /* block id: 205 */
            int32_t *l_399 = &g_346;
            if ((safe_lshift_func_int16_t_s_u(((l_394 , l_395) != l_396), 14)))
            { /* block id: 206 */
                l_397 = l_379;
            }
            else
            { /* block id: 208 */
                float *l_398 = &g_329;
                (*l_398) = 0x8.E26554p-42;
            }
            if (((((*g_307) , func_56(g_52, l_399)) , (((safe_unary_minus_func_int16_t_s(((*l_390) >= g_6))) , g_55.f1) , (l_397 <= (p_39 >= 0x9DBF)))) >= l_367))
            { /* block id: 211 */
                union U0 l_401 = {0x9.F30463p-57};
                return l_401;
            }
            else
            { /* block id: 213 */
                int32_t l_404 = 0xD5FD0F74;
                const union U0 *l_405 = &g_406;
                for (l_367 = 0; (l_367 < 26); l_367 = safe_add_func_int32_t_s_s(l_367, 2))
                { /* block id: 216 */
                    if ((g_55.f1 >= ((**g_209) != (void*)0)))
                    { /* block id: 217 */
                        (*g_345) = (*g_345);
                        l_404 = (*p_38);
                    }
                    else
                    { /* block id: 220 */
                        (*g_174) = &l_397;
                    }
                    l_405 = (*g_306);
                }
            }
            (*l_389) = (**g_173);
            l_399 = ((***g_305) , (*g_174));
        }
        else
        { /* block id: 228 */
            return (****l_395);
        }
        l_410 = g_52;
    }
    return (*g_307);
}


/* ------------------------------------------ */
/* 
 * reads : g_55.f1 g_6 g_52 g_51 g_172 g_173 g_174 g_209 g_55 g_345
 * writes: g_51 g_52 g_55.f1 g_210 g_303 g_329
 */
inline static const int32_t * func_41(uint16_t  p_42, int32_t  p_43, const int16_t  p_44, union U0  p_45)
{ /* block id: 40 */
    int8_t l_59 = 8;
    int32_t * const l_65 = &g_52;
    const int32_t *l_356 = &g_52;
    (*l_65) = __builtin_ctz((p_45.f1 < (func_56((p_45 , (func_47(p_45.f1, l_59, func_60(((l_59 | ((g_55.f1 || func_62(l_65, p_45.f1)) <= g_6)) < g_6))) , p_43)), g_345) , p_44)));
    return l_356;
}


/* ------------------------------------------ */
/* 
 * reads : g_55
 * writes: g_51
 */
inline static union U0  func_47(int8_t  p_48, uint16_t  p_49, int32_t * p_50)
{ /* block id: 37 */
    int32_t **l_53 = (void*)0;
    int32_t **l_54 = &g_51;
    (*l_54) = p_50;
    return g_55;
}


/* ------------------------------------------ */
/* 
 * reads : g_55.f1
 * writes: g_329
 */
inline static const union U0  func_56(uint16_t  p_57, int32_t * p_58)
{ /* block id: 192 */
    int16_t l_351 = 0xAF06;
    float *l_354 = &g_329;
    const union U0 l_355 = {0x0.2p-1};
    (*l_354) = ((((0x9668B059 < __builtin_ffsl(p_57)) & (+((safe_sub_func_int16_t_s_s(((0xEED1 & ((((safe_unary_minus_func_int32_t_s((-1))) <= (l_351 && (p_57 > g_55.f1))) , (safe_lshift_func_uint16_t_u_u(l_351, 1))) & p_57)) , p_57), l_351)) <= 0x5F08C032))) , l_351) <= l_351);
    (*l_354) = 0x9.026740p-11;
    return l_355;
}


/* ------------------------------------------ */
/* 
 * reads : g_173 g_174 g_51
 * writes:
 */
static int32_t * func_60(int32_t  p_61)
{ /* block id: 186 */
    const int32_t *l_342 = &g_52;
    const int32_t **l_343 = &l_342;
    int32_t *l_344 = (void*)0;
    (*l_343) = l_342;
    (*l_343) = (*l_343);
    (*l_343) = (**g_173);
    (*l_343) = (*l_343);
    return l_344;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_52 g_51 g_55.f1 g_172 g_173 g_174 g_209
 * writes: g_51 g_52 g_55.f1 g_210 g_303 g_329
 */
static int32_t  func_62(int32_t * const  p_63, uint32_t  p_64)
{ /* block id: 41 */
    int32_t *l_70 = &g_52;
    int32_t **l_327 = &g_51;
    int32_t ***l_326 = &l_327;
    int32_t ****l_325 = &l_326;
    float *l_328 = &g_329;
    (*l_328) = ((func_66(&g_51, l_70, &g_51) , ((safe_sub_func_float_f_f(__builtin_bswap32(__builtin_bswap32((p_64 >= (safe_lshift_func_int16_t_s_u(((safe_lshift_func_int16_t_s_u(((*p_63) > ((p_64 & (safe_unary_minus_func_int32_t_s((4 > ((void*)0 != l_325))))) >= 0U)), p_64)) , p_64), 4))))), 0x5.CF7F31p+17)) < 0x3.883B9Dp+3)) <= 0x0.ED40AFp-37);
    if ((((((safe_rshift_func_uint16_t_u_u(g_6, (safe_sub_func_uint32_t_u_u(7U, (p_64 , ((*p_63) | ((7U <= (safe_lshift_func_int16_t_s_u(((**l_326) == (void*)0), (*l_70)))) > p_64))))))) , g_6) , g_55.f1) >= g_52) || (*p_63)))
    { /* block id: 169 */
        int8_t l_340 = (-9);
        for (p_64 = 0; (p_64 > 42); p_64++)
        { /* block id: 172 */
            int32_t *l_341 = &g_52;
            (*g_174) = (void*)0;
            for (g_52 = 0; (g_52 == (-3)); g_52--)
            { /* block id: 176 */
                return (*p_63);
            }
            if (l_340)
                break;
            l_341 = p_63;
        }
    }
    else
    { /* block id: 182 */
        return (*p_63);
    }
    return (*p_63);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_52 g_51 g_55.f1 g_172 g_173 g_174 g_209
 * writes: g_51 g_52 g_55.f1 g_210 g_303
 */
static int8_t  func_66(int32_t ** p_67, int32_t * p_68, int32_t ** const  p_69)
{ /* block id: 42 */
    int16_t l_71 = 7;
    union U0 l_94 = {0x3.1B0A09p+26};
    int32_t *l_125 = &g_52;
    int32_t l_135 = 0xDB8D7F9B;
    float l_164 = 0x6.A6B3F7p-1;
    uint16_t l_189 = 65535U;
    const union U0 **l_240 = (void*)0;
    const union U0 ***l_239 = &l_240;
    const union U0 ****l_238 = &l_239;
    const union U0 *****l_237 = &l_238;
    float *l_298 = &l_164;
    float ** const l_297 = &l_298;
    float l_316 = 0x6.7623B5p-75;
    int32_t l_317 = 6;
    if (l_71)
    { /* block id: 43 */
        int16_t l_72 = 0xF849;
        union U0 l_78 = {0x7.937DA8p-93};
        int32_t *l_87 = &g_52;
        int32_t l_95 = (-9);
        int32_t *l_126 = &l_95;
        int32_t **l_228 = (void*)0;
        int32_t ***l_227 = &l_228;
        int32_t ****l_226 = &l_227;
        int32_t ** const ***l_229 = &g_172;
        union U0 **l_302 = &g_211;
        if (((l_72 , ((__builtin_bswap32(g_6) , (*p_68)) ^ (l_71 <= ((l_71 >= (+(((safe_add_func_float_f_f(l_71, ((*p_67) == ((**p_67) , &g_52)))) == g_55.f1) > l_71))) , l_72)))) != g_6))
        { /* block id: 44 */
            (*p_67) = &g_52;
            return g_52;
        }
        else
        { /* block id: 47 */
            (*p_69) = (*p_69);
            (*g_51) = (**p_69);
        }
        for (g_55.f1 = 0; (g_55.f1 == (-17)); g_55.f1 = safe_sub_func_uint32_t_u_u(g_55.f1, 1))
        { /* block id: 53 */
            int32_t l_85 = 0xB52F506A;
            const int32_t * const l_86 = &g_52;
            (*p_68) = (0x48EC >= (g_6 & (l_78 , (((!((safe_rshift_func_uint16_t_u_u(l_78.f1, 3)) , (safe_unary_minus_func_int16_t_s((safe_lshift_func_uint16_t_u_s(((l_85 , (((l_86 == ((&l_86 != &g_51) , l_87)) , (**p_67)) < g_6)) == 5), 13)))))) , l_71) <= 0x105C6596))));
        }
        if (((g_52 ^ __builtin_parity((safe_rshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s((l_94 , ((0xDD35930C | l_95) , (safe_mod_func_int16_t_s_s((((safe_mod_func_int32_t_s_s((*g_51), ((&g_52 == (void*)0) , l_71))) , 0x00FF6CFD) > l_71), (*l_87))))), 1)), l_94.f1)), 13)))) ^ 0xE9E85C28))
        { /* block id: 56 */
            union U0 l_119 = {-0x10.3p-1};
            int32_t *l_120 = &g_52;
            uint32_t l_134 = 1U;
            int32_t l_166 = 0xAB1F273F;
            int32_t ****l_171 = (void*)0;
            float l_212 = 0x1.Cp+1;
            (*p_69) = (*p_69);
        }
        else
        { /* block id: 115 */
            uint16_t l_230 = 0x2E5F;
            const union U0 ***l_236 = (void*)0;
            const union U0 ****l_235 = &l_236;
            const union U0 *****l_234 = &l_235;
            float l_250 = 0xD.8D0F59p-46;
            int32_t *****l_251 = &l_226;
            for (l_71 = 0; (l_71 <= (-4)); l_71 = safe_sub_func_int32_t_s_s(l_71, 4))
            { /* block id: 118 */
                int32_t l_241 = 0xE3028313;
                union U0 *l_244 = &g_55;
                l_226 = (void*)0;
                if ((****g_172))
                { /* block id: 120 */
                    l_229 = &g_172;
                }
                else
                { /* block id: 122 */
                    const union U0 l_231 = {0x3.A1C89Ep+58};
                    float *l_245 = &l_164;
                    if ((l_230 ^ __builtin_ctzll((l_231 , l_230))))
                    { /* block id: 123 */
                        float *l_232 = (void*)0;
                        float *l_233 = &l_164;
                        (*l_233) = ((void*)0 == (***g_172));
                        (*l_233) = (*l_126);
                    }
                    else
                    { /* block id: 126 */
                        (**g_174) = (0x290D | l_230);
                        l_237 = (g_6 , l_234);
                    }
                    (*l_245) = (l_241 >= ((__builtin_popcountl((0xA72F ^ (safe_lshift_func_uint16_t_u_u(0x3561, 8)))) , l_244) != (void*)0));
                }
            }
            if ((((safe_mod_func_uint16_t_u_u(((safe_sub_func_int32_t_s_s(l_230, (*l_125))) ^ g_6), g_55.f1)) <= ((((*l_229) == (void*)0) , l_251) != ((((__builtin_ctz(g_6) | 0xE111) | (**g_174)) | g_55.f1) , l_251))) & (*l_126)))
            { /* block id: 133 */
                int32_t l_255 = (-1);
                int32_t ***l_258 = &l_228;
                float *l_259 = &l_164;
                (*l_259) = ((((!(safe_lshift_func_uint16_t_u_s(l_255, (((*g_172) == &p_67) , ((safe_mod_func_uint32_t_u_u(((g_6 != g_52) == (*l_125)), l_255)) == (**p_67)))))) , 1) , l_258) != (*g_172));
                for (g_55.f1 = 0; (g_55.f1 == (-27)); g_55.f1 = safe_sub_func_uint32_t_u_u(g_55.f1, 5))
                { /* block id: 137 */
                    union U0 l_262 = {-0x1.Bp+1};
                    union U0 **l_293 = &g_211;
                    (*p_69) = (void*)0;
                }
            }
            else
            { /* block id: 156 */
                float l_301 = 0x8.DD0578p+57;
                return g_52;
            }
        }
        (*g_209) = l_302;
    }
    else
    { /* block id: 161 */
        int32_t **l_315 = &g_51;
        int32_t ***l_314 = &l_315;
        g_303 = &l_238;
        (*p_67) = (*p_69);
        (*p_67) = (***g_172);
        (***g_173) = (g_52 != (safe_mod_func_int16_t_s_s(g_52, (((0x0DAD == (((((safe_lshift_func_uint16_t_u_u((__builtin_ctz(g_6) > (safe_add_func_int32_t_s_s((g_55.f1 <= g_55.f1), (l_314 == &p_69)))), (*l_125))) && (*l_125)) < 0x4662) < (*l_125)) && 1)) || (**l_315)) , 0xF74A))));
    }
    return l_317;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_52, "g_52", print_hash_value);
    transparent_crc(g_55.f1, "g_55.f1", print_hash_value);
    transparent_crc_bytes (&g_329, sizeof(g_329), "g_329", print_hash_value);
    transparent_crc(g_346, "g_346", print_hash_value);
    transparent_crc_bytes (&g_406.f0, sizeof(g_406.f0), "g_406.f0", print_hash_value);
    transparent_crc(g_406.f1, "g_406.f1", print_hash_value);
    transparent_crc(g_412, "g_412", print_hash_value);
    transparent_crc(g_417, "g_417", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 111
XXX total union variables: 9

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 17
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 7, occurrence: 1
   depth: 11, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 5
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 115

XXX times a variable address is taken: 120
XXX times a pointer is dereferenced on RHS: 127
breakdown:
   depth: 1, occurrence: 107
   depth: 2, occurrence: 15
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 71
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 2
   depth: 3, occurrence: 5
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 320

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 205
   level: 2, occurrence: 54
   level: 3, occurrence: 27
   level: 4, occurrence: 14
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 59
XXX number of pointers point to scalars: 48
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.7
XXX average alias set size: 1.2

XXX times a non-volatile is read: 647
XXX times a non-volatile is write: 187
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 97
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 22
   depth: 2, occurrence: 18
   depth: 3, occurrence: 13
   depth: 4, occurrence: 6
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 18.5
XXX percentage an existing variable is used: 81.5
********************* end of statistics **********************/

