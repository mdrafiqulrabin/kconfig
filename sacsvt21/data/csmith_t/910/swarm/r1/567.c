/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3383894430
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint32_t  f1;
};

struct S1 {
   int16_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   int32_t  f3;
   int16_t  f4;
};

union U2 {
   int16_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U2  func_26(void);
static struct S0  func_31(int32_t  p_32, uint32_t  p_33, struct S0 ** p_34, int32_t  p_35);
static int32_t  func_40(int32_t  p_41);
inline static struct S1  func_42(uint32_t  p_43, uint32_t  p_44);
inline static uint16_t  func_47(int16_t  p_48, uint32_t  p_49);
inline static int16_t  func_50(struct S0 * p_51, uint16_t  p_52);
inline static struct S1  func_61(int32_t  p_62, union U2 * p_63, int32_t  p_64, uint32_t  p_65);
static int32_t  func_69(union U2 * p_70, struct S0  p_71, union U2 * p_72, uint16_t  p_73, int32_t  p_74);
static union U2 * func_75(union U2 * p_76, union U2 * p_77);
inline static union U2 * func_79(union U2  p_80, struct S1  p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_26(void)
{ /* block id: 36 */
    struct S0 *l_27 = (void*)0;
    struct S0 **l_28 = &l_27;
    int32_t l_29 = 1;
    int32_t *l_30 = &l_29;
    struct S0 l_54 = {0,0x1DD5C0AE};
    struct S0 *l_53 = &l_54;
    uint32_t *l_60 = &l_54.f1;
    int32_t *l_442 = &l_54.f0;
    union U2 l_508 = {9};
    (*l_28) = l_27;
    (*l_30) = __builtin_parityll(l_29);
    (*l_53) = func_31((*l_30), (((uint16_t)65532U << (uint16_t)8) , (((int32_t)0xB15D3E99 / (int32_t)0x063D62A0) && ((((*l_442) = (0x2377 > ((func_40(((func_42((*l_30), ((int32_t)(((func_47(func_50(l_53, (((~(*l_30)) && (((uint32_t)((*l_60) = ((int32_t)0x407CB0BE % (int32_t)(*l_30))) - (uint32_t)(*l_30)) != (*l_30))) <= (*l_30))), (*l_30)) || 0U) > (*l_30)) & (*l_30)) - (int32_t)(*l_30))) , (void*)0) != (void*)0)) & (*l_30)) <= (*l_30)))) , 0xD7451FDC) | (*l_30)))), &l_27, (*l_30));
    /* statement id: 285 */
    //assert (l_27 == 0 || l_27 == dangling);
    return l_508;
    /* statement id: 286 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_31(int32_t  p_32, uint32_t  p_33, struct S0 ** p_34, int32_t  p_35)
{ /* block id: 248 */
    uint16_t l_445 = 0xC7E7;
    struct S0 l_449 = {0x2BEE661A,0xD667F984};
    union U2 l_498 = {0x1B7C};
    union U2 *l_497 = &l_498;
    struct S0 *****l_499 = (void*)0;
    struct S1 l_506 = {-2,0x87ED909E,0x5608A17A,0x3AFFDF95,8};
    int32_t *l_507 = &l_449.f0;
    for (p_33 = 8; (p_33 > 25); p_33 += 5)
    { /* block id: 251 */
        uint32_t l_463 = 0U;
        uint16_t ***l_482 = (void*)0;
        uint16_t ****l_481 = &l_482;
        if ((l_445 = (-1)))
        { /* block id: 253 */
            int32_t l_446 = 9;
            int32_t l_448 = (-1);
            int32_t *l_447 = &l_448;
            struct S0 *l_462 = &l_449;
            uint32_t l_465 = 1U;
            uint32_t *l_464 = &l_465;
            int16_t l_466 = 0x8657;
            uint32_t **l_469 = &l_464;
            uint32_t ***l_468 = &l_469;
            uint32_t ****l_467 = &l_468;
            struct S0 l_471 = {0xD9578E5A,4294967287U};
            struct S1 l_472 = {0,0x1C739BD0,0x10346A92,-4,1};
            (*l_447) = l_446;
            l_449 = l_449;
            if (((int16_t)p_33 * (int16_t)(((int16_t)((int16_t)l_449.f1 >> (int16_t)3) * (int16_t)0U) == (((uint32_t)p_32 % (uint32_t)((int16_t)(0x933C80CA > (p_35 , ((*l_464) = (((int32_t)((((l_462 == &l_449) > (l_445 > (*l_447))) & l_463) , (*l_447)) + (int32_t)p_33) < 0xE235)))) * (int16_t)l_466)) & (*l_447)))))
            { /* block id: 257 */
                uint32_t *****l_470 = &l_467;
                (*l_470) = l_467;
                return l_471;
            }
            else
            { /* block id: 260 */
                struct S1 *l_473 = &l_472;
                int32_t *l_474 = (void*)0;
                int32_t *l_475 = &l_449.f0;
                (*l_473) = l_472;
                if (p_35)
                    break;
                (*l_475) = ((*l_447) = func_40(p_32));
            }
            l_449.f0 = ((*l_447) = 0);
        }
        else
        { /* block id: 268 */
            struct S1 l_479 = {0xBE31,0U,0xC6ADAB05,1,0x1BCE};
            struct S1 *l_478 = &l_479;
            struct S1 **l_477 = &l_478;
            struct S1 ***l_476 = &l_477;
            struct S1 ****l_480 = &l_476;
            uint16_t *****l_483 = &l_481;
            (*l_480) = l_476;
            (*l_483) = l_481;
            if (l_479.f1)
                break;
        }
    }
    (*p_34) = &l_449;
    /* statement id: 274 */
    //assert (l_27 == &l_449);
    if ((((-(int32_t)(((uint16_t)0xF25E >> (uint16_t)5) || (((int16_t)p_35 * (int16_t)(l_449.f1 < p_35)) != ((((uint32_t)((uint16_t)((p_33 >= func_40(l_449.f0)) > ((void*)0 != l_497)) % (uint16_t)p_32) % (uint32_t)p_32) , l_499) != l_499)))) , p_32) ^ l_449.f1))
    { /* block id: 275 */
        int32_t *l_501 = &l_449.f0;
        int32_t **l_500 = &l_501;
        int32_t *l_503 = &l_449.f0;
        int32_t **l_502 = &l_503;
        int32_t *l_504 = &l_449.f0;
        (*l_502) = ((*l_500) = (void*)0);
        /* statement id: 277 */
        assert (l_501 == 0);
        assert (l_503 == 0);
        (*l_504) = (p_35 || p_33);
        (*l_500) = (void*)0;
    }
    else
    { /* block id: 280 */
        struct S0 l_505 = {1,0x9018FD3F};
        return l_505;
        /* statement id: 281 */
        //assert (l_27 == dangling);
    }
    (*l_507) = (l_506 , (-3));
    return l_449;
    /* statement id: 284 */
    //assert (l_27 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_40(int32_t  p_41)
{ /* block id: 244 */
    uint32_t l_440 = 0x9FE2A5CB;
    uint32_t *l_439 = &l_440;
    uint32_t **l_438 = &l_439;
    uint32_t ***l_441 = &l_438;
    (*l_441) = l_438;
    return l_440;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_42(uint32_t  p_43, uint32_t  p_44)
{ /* block id: 240 */
    int32_t l_433 = 0x0C287B77;
    int32_t *l_432 = &l_433;
    int32_t **l_434 = &l_432;
    int32_t *l_436 = &l_433;
    int32_t **l_435 = &l_436;
    struct S1 l_437 = {0xB764,0x594B7FE1,4294967295U,1,0xC9B8};
    (*l_435) = ((*l_434) = l_432);
    return l_437;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_47(int16_t  p_48, uint32_t  p_49)
{ /* block id: 226 */
    union U2 l_398 = {0x0FBF};
    union U2 *l_397 = &l_398;
    uint16_t l_402 = 0xC31F;
    int32_t l_403 = 1;
    struct S0 l_412 = {0,0xC2F6E37E};
    struct S0 *l_411 = &l_412;
    int32_t l_418 = 2;
    int32_t *l_417 = &l_418;
    int32_t **l_416 = &l_417;
    int32_t *l_421 = &l_412.f0;
    int32_t *l_422 = (void*)0;
    uint32_t l_430 = 4294967294U;
    l_397 = (void*)0;
    /* statement id: 227 */
    assert (l_397 == 0);
    if ((((uint16_t)(p_49 & ((l_403 = (~l_402)) & ((uint16_t)(l_398 , (l_398.f0 , l_398.f0)) >> (uint16_t)7))) - (uint16_t)p_48) , (!(l_412.f0 = ((int32_t)p_48 / (int32_t)((int16_t)(func_50((((p_48 ^ (2U != l_402)) <= 0xA291E3C1) , l_411), p_49) < (-7)) << (int16_t)p_49))))))
    { /* block id: 230 */
        union U2 *l_415 = (void*)0;
        int32_t *l_420 = (void*)0;
        int32_t **l_419 = &l_420;
        l_422 = (l_421 = ((*l_419) = (func_61((((int16_t)p_49 << (int16_t)l_403) , p_49), func_75(l_415, &l_398), l_403, ((void*)0 == l_416)) , (void*)0)));
        /* statement id: 233 */
        assert (l_421 == 0);
        (*l_419) = (void*)0;
    }
    else
    { /* block id: 235 */
        struct S0 l_423 = {-9,4294967295U};
        int32_t *l_426 = &l_418;
        union U2 *l_429 = &l_398;
        int32_t *l_431 = &l_423.f0;
        (*l_431) = ((l_423 , ((*l_421) = (((uint32_t)0x86887741 / (uint32_t)(((0x2D91 <= ((1 != ((*l_416) == l_426)) , ((0x766D | ((uint16_t)func_69(&l_398, l_423, l_429, p_48, p_49) * (uint16_t)l_423.f0)) , (*l_421)))) | l_423.f1) & l_430)) != p_48))) || p_49);
    }
    /* facts after branching */
    assert (l_421 == &l_412.f0 || l_421 == 0);
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_50(struct S0 * p_51, uint16_t  p_52)
{ /* block id: 40 */
    uint32_t l_66 = 4294967288U;
    union U2 l_68 = {-2};
    union U2 *l_67 = &l_68;
    union U2 *l_78 = &l_68;
    struct S1 l_82 = {1,0x2B4B20F9,0U,-9,7};
    int32_t l_168 = 0x60892C68;
    int32_t *l_224 = &l_168;
    int32_t l_226 = 0x446BF52A;
    int32_t *l_225 = &l_226;
    int32_t l_227 = 1;
    union U2 **l_380 = &l_78;
    struct S0 l_381 = {-1,0xEF8C8917};
    int32_t *l_383 = &l_82.f3;
    int32_t **l_382 = &l_383;
    union U2 **l_388 = &l_67;
    int16_t *l_389 = &l_68.f0;
    struct S1 *l_390 = (void*)0;
    struct S1 *l_391 = &l_82;
    struct S0 ***l_392 = (void*)0;
    struct S0 *l_394 = &l_381;
    struct S0 **l_393 = &l_394;
    struct S0 **l_395 = &l_394;
    struct S1 **l_396 = &l_391;
    (*l_380) = (func_61(l_66, l_67, ((*l_225) = ((*l_224) = ((func_69(func_75(l_78, func_79((*l_67), l_82)), (*p_51), &l_68, l_168, p_52) || p_52) < l_168))), l_227) , &l_68);
    (*l_391) = func_61((func_69((*l_380), l_381, (*l_380), (((*l_382) = (void*)0) == &l_227), ((int16_t)((*l_389) = ((int16_t)(l_82 , ((*l_224) , (*l_225))) >> (int16_t)func_69(((*l_388) = func_75((*l_380), (*l_380))), l_381, (*l_380), p_52, (*l_224)))) >> (int16_t)3)) >= 5), (*l_380), p_52, p_52);
    /* statement id: 221 */
    assert (l_383 == 0);
    l_395 = (l_393 = &p_51);
    /* statement id: 223 */
    assert (l_393 == &p_51);
    assert (l_395 == &p_51);
    (*l_396) = &l_82;
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_61(int32_t  p_62, union U2 * p_63, int32_t  p_64, uint32_t  p_65)
{ /* block id: 108 */
    int32_t **l_228 = (void*)0;
    int32_t l_231 = 0x9A4742CA;
    int32_t *l_230 = &l_231;
    int32_t **l_229 = &l_230;
    struct S0 l_233 = {0x71268E89,0x66197A97};
    struct S0 *l_232 = &l_233;
    struct S1 l_238 = {0xE476,0U,4294967288U,0xA7E5BCBC,0xBFC3};
    struct S1 **l_243 = (void*)0;
    int16_t l_257 = 0x8D08;
    uint32_t l_259 = 4294967295U;
    union U2 l_266 = {-5};
    union U2 *l_265 = &l_266;
    uint16_t l_269 = 2U;
    uint16_t *l_268 = &l_269;
    union U2 *l_278 = (void*)0;
    uint32_t l_281 = 0x4A3DAAC6;
    uint32_t *l_301 = (void*)0;
    struct S0 **l_328 = &l_232;
    struct S0 ***l_327 = &l_328;
    struct S0 ****l_326 = &l_327;
    int32_t *l_379 = &l_231;
lbl_323:
    (*l_229) = &p_64;
    /* statement id: 109 */
    assert (l_230 == &p_64);
    if (__builtin_clz(p_62))
    { /* block id: 110 */
        struct S0 **l_234 = (void*)0;
        struct S0 **l_235 = &l_232;
        uint32_t *l_239 = &l_233.f1;
        int32_t l_242 = 0xE483A5F4;
        uint16_t *l_244 = (void*)0;
        uint16_t *l_245 = (void*)0;
        int32_t l_246 = 0xEF9C45FB;
        int16_t *l_258 = (void*)0;
        struct S1 l_262 = {0,0x4E8AFE3A,4U,0x8BE3BCDC,1};
lbl_272:
        (*l_235) = l_232;
        for (p_62 = 4; (p_62 <= 16); p_62 += 2)
        { /* block id: 114 */
            return l_238;
        }
        (**l_229) = ((void*)0 == l_239);
        if (((int32_t)(l_242 < (l_246 = ((((void*)0 == l_239) != p_62) ^ ((void*)0 == l_243)))) + (int32_t)(((l_259 = ((int32_t)((*l_230) = ((__builtin_ffsll(((int16_t)(l_242 & ((((int32_t)(((uint16_t)p_65 >> (uint16_t)((uint16_t)((p_64 == l_257) <= 0xAC30) * (uint16_t)p_64)) , 1) + (int32_t)l_242) < l_242) != (*l_230))) >> (int16_t)3)) , p_62) > (**l_229))) - (int32_t)1)) ^ 4) <= p_65)))
        { /* block id: 121 */
            int32_t *l_260 = &l_246;
            int32_t **l_261 = &l_260;
            struct S1 l_263 = {0x29D8,4294967289U,0x3DD4E207,-1,-5};
            struct S1 *l_264 = &l_238;
            (*l_261) = ((*l_229) = l_260);
            /* statement id: 123 */
            assert (l_230 == &l_246);
            (*l_264) = (l_263 = l_262);
        }
        else
        { /* block id: 126 */
            uint32_t l_267 = 0x57210762;
            int32_t *l_270 = (void*)0;
            int32_t *l_271 = &l_238.f3;
            int32_t l_282 = 2;
            int32_t l_283 = 0x4F598933;
            struct S0 l_287 = {0x52129FB9,3U};
            if (((func_69(l_265, (*l_232), ((*l_232) , func_79((*l_265), l_262)), l_267, ((*l_271) = ((**l_229) , (((**l_229) , (void*)0) == l_268)))) < 65529U) != l_267))
            { /* block id: 128 */
                int16_t *l_275 = &l_262.f0;
                union U2 *l_279 = &l_266;
                union U2 **l_280 = &l_265;
                int32_t *l_285 = &l_242;
                int32_t **l_284 = &l_285;
                if (l_238.f1)
                    goto lbl_272;
                l_232 = &l_233;
                (*l_284) = ((*l_229) = ((0x8D41 & (((**l_229) = (l_283 = (l_282 = ((int16_t)((*l_275) = 0x4534) * (int16_t)(p_62 && ((uint16_t)func_69((l_278 = p_63), (*l_232), ((*l_280) = l_279), p_64, l_281) << (uint16_t)10)))))) && 0x0586)) , &p_64));
                /* statement id: 138 */
                //assert (l_278 == 0 || l_278 == &l_266 || l_278 == &l_68 || l_278 == &l_398);
                assert (l_285 == &p_64);
            }
            else
            { /* block id: 139 */
                union U2 **l_286 = &l_265;
                (*l_286) = p_63;
                /* statement id: 140 */
                //assert (l_265 == &l_68 || l_265 == &l_398);
                (**l_229) = l_262.f2;
                (**l_235) = l_287;
            }
            /* facts after branching */
            //assert (l_265 == &l_68 || l_265 == &l_266 || l_265 == &l_398);
            //assert (l_278 == 0 || l_278 == &l_266 || l_278 == &l_68 || l_278 == &l_398);
        }
        /* facts after branching */
        assert (l_230 == &p_64 || l_230 == &l_246);
        //assert (l_265 == &l_68 || l_265 == &l_266 || l_265 == &l_398);
        //assert (l_278 == 0 || l_278 == &l_266 || l_278 == &l_68 || l_278 == &l_398);
    }
    else
    { /* block id: 145 */
        int32_t *l_288 = &l_231;
        struct S0 l_306 = {0x5472B14F,0U};
        struct S1 l_339 = {1,0x7E284695,8U,0x399CC179,-10};
        union U2 *l_371 = &l_266;
        int32_t *l_377 = &l_266.f1;
        uint32_t *l_378 = &l_233.f1;
        l_288 = l_288;
        for (p_64 = 0; (p_64 != 5); p_64 += 1)
        { /* block id: 149 */
            int16_t l_293 = 0x30D1;
            struct S1 l_318 = {1,1U,0x820CEA30,0,0xACBD};
            int32_t l_338 = 0;
            for (l_238.f2 = (-2); (l_238.f2 >= 52); ++l_238.f2)
            { /* block id: 152 */
                int16_t *l_298 = &l_257;
                uint32_t *l_299 = &l_233.f1;
                uint32_t **l_300 = &l_299;
                uint16_t l_303 = 4U;
                uint16_t *l_302 = &l_303;
                if ((l_293 < ((((uint16_t)((*l_302) = ((&l_257 != (l_298 = &l_257)) ^ ((*l_268) = (((*l_300) = l_299) != l_301)))) << (uint16_t)p_64) , ((((int16_t)(l_306 , p_65) * (int16_t)0x79C2) & p_65) || l_303)) >= 0x66C5461C)))
                { /* block id: 157 */
                    int32_t *l_307 = &l_233.f0;
                    struct S1 l_324 = {0x7CE6,0x80BECAC8,0x9975634F,-1,0x5CBA};
                    struct S0 *l_325 = &l_306;
                    (*l_232) = (*l_232);
                    if ((0xF4A1B509 > 0x98E86E8C))
                    { /* block id: 159 */
                        union U2 **l_319 = &l_265;
                        union U2 **l_320 = &l_278;
                        int32_t l_321 = (-1);
                        (*l_288) = p_65;
                        (*l_229) = l_307;
                        /* statement id: 161 */
                        assert (l_230 == &l_233.f0);
                        (*l_288) = ((uint32_t)((int16_t)p_65 * (int16_t)((uint16_t)__builtin_clzll(p_64) + (uint16_t)(func_69(p_63, (*l_232), ((*l_320) = ((*l_319) = (((int16_t)((p_62 > (((-6) < p_65) != ((int16_t)(l_318 , (-1)) - (int16_t)2U))) & 7) / (int16_t)p_65) , &l_266))), p_65, l_293) == l_321))) + (uint32_t)p_62);
                        /* statement id: 164 */
                        assert (l_278 == &l_266);
                    }
                    else
                    { /* block id: 165 */
                        (*l_288) = ((-(uint32_t)p_64) <= (*l_307));
                        if (p_62)
                            goto lbl_323;
                        if (p_64)
                            continue;
                        (*l_307) = __builtin_clzll((*l_307));
                    }
                    if ((*l_307))
                    { /* block id: 171 */
                        (*l_229) = (void*)0;
                        /* statement id: 172 */
                        assert (l_230 == 0);
                        return l_324;
                    }
                    else
                    { /* block id: 174 */
                        struct S0 *****l_329 = &l_326;
                        struct S1 *l_330 = &l_318;
                        int32_t *l_331 = &l_231;
                        (*l_307) = (l_325 != (void*)0);
                        (*l_329) = l_326;
                        (*l_330) = l_238;
                        l_331 = &p_64;
                        /* statement id: 178 */
                        assert (l_331 == &p_64);
                    }
                }
                else
                { /* block id: 180 */
                    uint32_t l_335 = 4294967291U;
                    l_338 = ((uint16_t)(0 && (-(int16_t)(l_335 | p_64))) / (uint16_t)((uint16_t)(*l_288) * (uint16_t)6));
                    return l_339;
                }
            }
        }
        /* facts after for loop */
        assert (l_230 == &p_64 || l_230 == &l_233.f0);
        for (l_339.f4 = 0; (l_339.f4 < (-30)); l_339.f4 -= 1)
        { /* block id: 188 */
            struct S1 l_351 = {-8,0x1BE1EC9E,3U,0x208A202F,-2};
            struct S0 l_355 = {0xBE3D9C35,0x3B32C04D};
            int32_t l_366 = (-1);
            union U2 *l_372 = (void*)0;
            for (l_266.f1 = 0; (l_266.f1 > (-12)); l_266.f1 -= 5)
            { /* block id: 191 */
                union U2 l_350 = {-4};
                union U2 **l_352 = &l_265;
                (**l_229) = ((((int16_t)0xC57C / (int16_t)((int32_t)((uint16_t)((*l_268) = func_69(((func_69(func_79(l_350, l_351), l_306, ((*l_352) = &l_266), l_351.f0, ((int32_t)(-1) + (int32_t)(p_64 = p_64))) || p_62) , &l_266), l_355, p_63, p_62, l_355.f1)) << (uint16_t)13) / (int32_t)l_355.f0)) && (-5)) && l_350.f0);
                /* statement id: 195 */
                assert (l_265 == &l_266);
                if (((int32_t)__builtin_parity((~(p_64 ^ l_351.f3))) + (int32_t)(!((uint16_t)((uint16_t)(*l_288) % (uint16_t)((int16_t)l_366 - (int16_t)p_64)) >> (uint16_t)0))))
                { /* block id: 196 */
                    (**l_229) = p_62;
                }
                else
                { /* block id: 198 */
                    struct S1 *l_367 = &l_351;
                    struct S1 l_368 = {0xBC7C,0xF9884C09,0x0837F9A2,4,0x225A};
                    (*l_367) = l_351;
                    (**l_229) = func_69(p_63, l_355, ((*l_352) = p_63), (l_368 , p_65), (((*l_367) , p_62) || l_350.f0));
                    /* statement id: 201 */
                    //assert (l_265 == &l_68 || l_265 == &l_398);
                    (*l_230) = ((0U > (**l_229)) || (l_350.f0 >= p_64));
                }
                /* facts after branching */
                //assert (l_265 == &l_68 || l_265 == &l_266 || l_265 == &l_398);
            }
            /* facts after for loop */
                        (*l_288) = ((int16_t)func_69(func_75(func_75(func_75(p_63, &l_266), l_371), &l_266), l_306, l_372, (*l_288), p_62) >> (int16_t)15);
            if ((*l_288))
                break;
        }
        /* facts after for loop */
        //assert (l_265 == &l_68 || l_265 == &l_266 || l_265 == &l_398);
        (**l_229) = (((-5) | p_64) & __builtin_parity(((*l_378) = (p_65 = (p_65 < __builtin_ffsl(((*l_377) = ((((*l_288) <= ((l_233.f0 = ((uint16_t)__builtin_bswap64((*l_230)) - (uint16_t)((l_339 , ((uint16_t)((*l_268) = ((*l_288) | 7U)) >> (uint16_t)p_64)) , 0))) && 0x8682BDF8)) , (-6)) , (*l_288)))))))));
        /* statement id: 213 */
            }
    /* facts after branching */
    //assert (l_230 == &p_64 || l_230 == &l_233.f0 || l_230 == dangling);
    //assert (l_265 == &l_68 || l_265 == &l_266 || l_265 == &l_398);
    //assert (l_278 == 0 || l_278 == &l_266 || l_278 == &l_68 || l_278 == &l_398);
    (*l_379) = 0xDB5D7710;
    return l_238;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_69(union U2 * p_70, struct S0  p_71, union U2 * p_72, uint16_t  p_73, int32_t  p_74)
{ /* block id: 75 */
    int32_t l_169 = (-9);
    uint16_t l_179 = 2U;
    uint16_t *l_178 = &l_179;
    int32_t l_180 = 0x10CE241E;
    int32_t l_182 = 6;
    int32_t *l_181 = &l_182;
    struct S0 l_192 = {5,0x3870EDD4};
    struct S1 l_200 = {0xA19B,0xF5435085,0U,-1,-1};
    struct S1 *l_199 = &l_200;
    union U2 l_209 = {0xBD43};
    union U2 *l_208 = &l_209;
    if ((__builtin_ia32_crc32qi((((((p_74 , (l_180 = (p_74 | (l_169 , (l_169 , ((*l_178) = (l_169 >= ((uint16_t)p_71.f1 - (uint16_t)((int32_t)(((uint16_t)l_169 >> (uint16_t)11) & l_169) % (int32_t)((int16_t)(((((l_169 != p_74) & p_74) || (-9)) ^ l_169) < 0x69599E22) * (int16_t)l_169)))))))))) , (void*)0) != l_181) >= 0x1454) == p_71.f1), p_74) <= p_73))
    { /* block id: 78 */
        int32_t l_185 = (-9);
        struct S1 *l_202 = &l_200;
        struct S1 **l_201 = &l_202;
        int32_t **l_212 = &l_181;
        struct S0 *l_213 = &l_192;
        struct S0 **l_214 = &l_213;
lbl_210:
        p_71 = (((uint16_t)l_185 - (uint16_t)(((uint32_t)((uint16_t)(*l_181) >> (uint16_t)((uint16_t)(65535U || (*l_181)) - (uint16_t)((*l_181) != ((l_185 >= (*l_181)) && (l_192 , ((p_74 | l_185) && (-2))))))) % (uint32_t)l_185) >= 4294967295U)) , p_71);
        if (p_73)
            goto lbl_211;
        if (((int16_t)((((*l_178) = 0xE0F3) || ((uint16_t)((int16_t)4 >> (int16_t)(l_199 != ((*l_201) = &l_200))) + (uint16_t)((((uint16_t)p_74 - (uint16_t)(!((((uint32_t)__builtin_ctzll((((p_70 == l_208) > p_74) & ((l_185 <= p_71.f0) <= p_71.f0))) - (uint32_t)l_185) | (*l_181)) == p_73))) <= (*l_181)) >= (-10)))) != 0) >> (int16_t)p_71.f1))
        { /* block id: 82 */
            (**l_201) = (**l_201);
lbl_211:
            if (p_73)
                goto lbl_210;
            (*l_212) = &l_185;
            /* statement id: 86 */
            assert (l_181 == &l_185);
            (*l_214) = l_213;
        }
        else
        { /* block id: 88 */
            struct S0 **l_215 = &l_213;
            struct S0 ***l_216 = &l_214;
            (*l_216) = l_215;
        }
        /* facts after branching */
        assert (l_181 == &l_182 || l_181 == &l_185);
        return p_71.f0;
    }
    else
    { /* block id: 92 */
        uint16_t **l_218 = &l_178;
        uint16_t ***l_217 = &l_218;
        int32_t **l_219 = (void*)0;
        int32_t *l_220 = &l_192.f0;
        int32_t **l_221 = &l_220;
        (*l_217) = &l_178;
        l_220 = &l_182;
        /* statement id: 94 */
        assert (l_220 == &l_182);
        (*l_221) = (void*)0;
        /* statement id: 95 */
        assert (l_220 == 0);
        for (l_209.f0 = 28; (l_209.f0 == (-28)); l_209.f0 -= 6)
        { /* block id: 98 */
            (*l_221) = (l_181 = (*l_221));
            /* statement id: 100 */
            assert (l_181 == 0);
            return p_71.f0;
        }
    }
    l_181 = &l_182;
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2 * func_75(union U2 * p_76, union U2 * p_77)
{ /* block id: 56 */
    int32_t l_113 = 0xAB39D48F;
    int32_t l_130 = 1;
    struct S1 l_131 = {0xDC1C,0xBDE7BC92,0x3EDA01CD,0x25BC7067,0xD57D};
    struct S1 *l_132 = &l_131;
    if ((((*l_132) = ((((int32_t)((uint16_t)(l_113 < ((uint16_t)((uint32_t)(!((l_113 >= ((-4) | __builtin_parity((((0xFEE19A6A ^ (-(int32_t)l_113)) | (l_113 , ((int32_t)(((uint16_t)(((int16_t)l_113 * (int16_t)((uint32_t)((int16_t)(-8) * (int16_t)(((l_130 = (l_113 ^ l_113)) <= 0xAB64809F) ^ l_113)) + (uint32_t)l_113)) , 65534U) / (uint16_t)6U) <= 0x6BB0F612) * (int32_t)0))) , l_113)))) , l_113)) + (uint32_t)8) % (uint16_t)l_113)) / (uint16_t)l_113) - (int32_t)l_113) < l_113) , l_131)) , 1))
    { /* block id: 59 */
        int32_t l_134 = (-10);
        int32_t *l_135 = &l_130;
        (*l_135) = ((l_134 = (l_131.f2 | (~l_134))) & l_131.f4);
    }
    else
    { /* block id: 62 */
        uint16_t l_138 = 0x2AFE;
        int32_t l_150 = (-7);
        struct S0 l_151 = {0xD7A0FECA,0x7D98C00C};
        struct S0 l_167 = {0x1899B7E0,1U};
        for (l_131.f2 = (-1); (l_131.f2 > 31); ++l_131.f2)
        { /* block id: 65 */
            int32_t *l_139 = &l_130;
            uint16_t *l_142 = &l_138;
            struct S0 l_143 = {0x71F3D14E,8U};
            union U2 l_149 = {0x20D7};
            union U2 *l_148 = &l_149;
            struct S0 *l_152 = (void*)0;
            struct S0 *l_153 = &l_143;
            uint32_t *l_163 = (void*)0;
            uint32_t *l_164 = (void*)0;
            uint32_t *l_165 = &l_151.f1;
            int32_t l_166 = 7;
            (*l_139) = __builtin_parityll(l_138);
            (*l_153) = ((((uint32_t)(((*l_142) = (__builtin_ffsl(l_138) , 0x5965)) == __builtin_bswap32(((*l_139) = (l_143 , l_131.f0)))) + (uint32_t)(((int16_t)((uint32_t)(l_148 != p_76) % (uint32_t)l_131.f4) >> (int16_t)l_143.f0) , l_150)) < l_150) , l_151);
            (*l_153) = (((int32_t)l_150 % (int32_t)((int16_t)((!((((int32_t)((void*)0 == &l_150) - (int32_t)l_151.f0) <= 0xE1F53DE9) ^ ((((int16_t)(((*l_165) = (*l_139)) || l_151.f1) - (int16_t)__builtin_clzl(l_138)) != l_131.f0) > l_166))) ^ l_150) % (int16_t)0x6E99)) , l_167);
        }
    }
    return p_77;
    /* statement id: 74 */
    //assert (func_75_rv == 0 || func_75_rv == &l_266 || func_75_rv == &l_68 || func_75_rv == &l_398);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * func_79(union U2  p_80, struct S1  p_81)
{ /* block id: 41 */
    struct S0 *l_85 = (void*)0;
    struct S0 l_88 = {0x827C80C7,1U};
    struct S0 *l_87 = &l_88;
    union U2 l_95 = {5};
    union U2 *l_94 = &l_95;
    union U2 *l_98 = &l_95;
    union U2 *l_100 = &l_95;
    union U2 *l_104 = (void*)0;
    struct S1 l_105 = {-4,7U,0x480A87E9,1,0x217C};
    struct S1 *l_106 = &l_105;
    union U2 *l_107 = &l_95;
    union U2 *l_108 = (void*)0;
    for (p_81.f1 = (-11); (p_81.f1 != 37); ++p_81.f1)
    { /* block id: 44 */
        struct S0 *l_86 = (void*)0;
        int16_t l_90 = 0x732A;
        int16_t *l_89 = &l_90;
        int32_t l_92 = 4;
        union U2 *l_96 = &l_95;
        union U2 *l_97 = &l_95;
        union U2 *l_99 = &l_95;
        union U2 *l_101 = &l_95;
        union U2 *l_102 = &l_95;
        union U2 *l_103 = &l_95;
        if ((((l_85 == (l_87 = l_86)) ^ p_80.f0) | ((*l_89) = l_88.f1)))
        { /* block id: 47 */
            uint16_t l_91 = 0x6C3A;
            l_92 = l_91;
        }
        else
        { /* block id: 49 */
            int32_t *l_93 = &l_88.f0;
            (*l_93) = l_92;
        }
        /* facts after branching */
        assert (l_87 == 0);
        return l_104;
        /* statement id: 52 */
        //assert (func_79_rv == 0);
    }
    (*l_106) = l_105;
    return l_108;
    /* statement id: 55 */
    //assert (func_79_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 105
   depth: 1, occurrence: 26
XXX total union variables: 2

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 27
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 29, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 167

XXX times a variable address is taken: 158
XXX times a pointer is dereferenced on RHS: 63
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 101
breakdown:
   depth: 1, occurrence: 92
   depth: 2, occurrence: 9
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 224

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 778
   level: 2, occurrence: 96
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 56
XXX number of pointers point to structs: 25
XXX percent of pointers has null in alias set: 25.1
XXX average alias set size: 1.23

XXX times a non-volatile is read: 480
XXX times a non-volatile is write: 253
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 124
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 28
   depth: 2, occurrence: 27
   depth: 3, occurrence: 14
   depth: 4, occurrence: 9
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 20.8
XXX percentage an existing variable is used: 79.2
********************* end of statistics **********************/

