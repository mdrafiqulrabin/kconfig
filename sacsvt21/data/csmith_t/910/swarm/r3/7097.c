/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2862851412
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   uint32_t  f1;
   float  f2;
   float  f3;
   uint16_t  f4;
   int32_t  f5;
   float  f6;
   int16_t  f7;
   uint32_t  f8;
};

struct S1 {
   struct S0  f0;
   struct S0  f1;
   uint32_t  f2;
   float  f3;
   uint32_t  f4;
   const struct S0  f5;
   int32_t  f6;
   uint16_t  f7;
   const struct S0  f8;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_5 = 0x07D7C118L;
static struct S1 g_66 = {{0x94B0L,4294967293UL,0x6.CAEA25p-82,-0x1.7p-1,0xCF35L,0L,-0x10.Bp-1,0x9E46L,5UL},{0L,0x01134933L,0x3.2p+1,0x6.A4E4CFp-17,8UL,0L,0xF.73F8B2p+37,0xE92EL,5UL},0xEC2A52D8L,0x4.8D85B2p-18,18446744073709551615UL,{-3L,0xCFE62557L,-0x7.Fp-1,-0x8.Bp-1,0x6239L,-7L,0x4.7p+1,0L,4294967289UL},2L,0UL,{0x6375L,0x40D4900EL,0x0.6p-1,0x3.Ap-1,65533UL,0L,-0x1.7p-1,0x9478L,0UL}};
static struct S0 *g_115 = &g_66.f1;
static float *g_166 = &g_66.f0.f3;
static struct S0 *g_167 = &g_66.f1;
static const uint32_t g_235 = 0xC3ACC7FAL;
static int32_t *g_240 = &g_66.f6;
static int32_t **g_239 = &g_240;
static struct S1 **g_256 = (void*)0;
static int16_t g_290 = 0x1620L;
static int32_t ***g_320 = (void*)0;
static int32_t ****g_319 = &g_320;
static float **g_395 = &g_166;
static float ***g_394 = &g_395;
static const uint16_t g_438 = 0x73CFL;


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_28(void);
inline static int32_t  func_39(uint16_t  p_40, struct S0  p_41, uint16_t  p_42, const struct S1  p_43);
static struct S0  func_44(struct S0  p_45, float  p_46);
inline static struct S0  func_47(const uint32_t  p_48, uint32_t  p_49, float  p_50, float  p_51, int32_t  p_52);
static int16_t  func_53(uint16_t  p_54, int32_t  p_55, int32_t  p_56, struct S1  p_57);
inline static struct S0  func_60(struct S1  p_61, int16_t  p_62, int16_t  p_63, int32_t  p_64, const struct S1  p_65);
inline static struct S0  func_68(struct S1  p_69, float  p_70);
static struct S1  func_71(struct S1  p_72, int32_t  p_73, uint16_t  p_74, uint32_t  p_75);
inline static struct S1  func_76(struct S1  p_77, uint32_t  p_78, struct S1  p_79, int16_t  p_80, struct S0  p_81);
inline static struct S0  func_90(uint32_t  p_91, uint32_t  p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_115 g_66.f1
 * writes:
 */
inline static struct S0  func_28(void)
{ /* block id: 36 */
    uint32_t l_29 = 0xEE491BA6L;
    const struct S1 l_67 = {{0xF04CL,4294967295UL,-0x4.Cp+1,0x3.Ep+1,0x25DDL,0x928CDBBAL,-0x1.Fp+1,9L,0x83723A68L},{0x7BAAL,1UL,0xF.B5C891p+6,0x6.Ap+1,65535UL,2L,0x7.C6F71Fp+64,0xF2A8L,4294967288UL},0x044C0279L,0x8.1p+1,0x6D8F9DEAL,{0x75BCL,5UL,0x5.8A50C0p+11,-0x9.Fp-1,0x4EBCL,0L,0x9.B116D7p-45,0xBEC0L,1UL},1L,3UL,{-1L,0x836DD0C6L,0x0.0p-1,0x8.B4A031p-97,0x22CEL,0L,0x9.1B5690p+9,0xC525L,4294967295UL}};
    if (l_29)
    { /* block id: 37 */
        uint32_t l_30 = 1UL;
        struct S1 l_420 = {{0x670AL,9UL,0x0.EB3A32p+12,0xD.2DBC67p-93,65528UL,0x33D87356L,0x9.5FD45Dp-21,3L,0x3F783A70L},{3L,0xF68491F0L,0x4.B8E8CCp-54,0xA.B83A0Dp+43,0x5AD2L,0x04DD959BL,0xB.0ACB52p-29,1L,4UL},0xE80A3945L,0xA.E49DB6p-87,0xD5C6F17EL,{0xF132L,0xDFDE9B95L,0x1.0p+1,0x1.3p-1,1UL,0x4D32BBDDL,0x1.668369p+13,0xCAEEL,0x51B63CE6L},0x0FD871C6L,65533UL,{0x6300L,0x91E6367EL,0xD.111A4Cp+12,-0x6.4p-1,0x483AL,-1L,0xD.B1D5A6p-63,0xF1A6L,0x73602F95L}};
        l_30 = 0x0.4p+1;
        for (l_29 = (-20); (l_29 == 9); l_29 += 1)
        { /* block id: 41 */
            uint16_t l_33 = 1UL;
            uint16_t l_421 = 0x8861L;
            const struct S1 l_441 = {{-1L,0x97F2B74AL,-0x5.Ap-1,0x5.1p-1,0x8797L,0L,0x1.AB3A7Cp+89,3L,0x13434845L},{0x020DL,4UL,0x6.0p+1,0x9.C75034p+64,0x09F9L,0xB98D9061L,-0x1.Bp+1,0xEE81L,0xC729AD73L},0x1001FB11L,0xD.D78F50p+90,0xD31EB6A3L,{1L,0x8ECBBAE2L,0x6.Bp+1,0x6.47206Fp-36,0x85B5L,-1L,0x2.5702E7p-14,1L,2UL},0x2338958DL,0x8B28L,{0xA8B9L,0x1A1922F8L,0x9.E10541p-59,0xA.8A4CF7p-54,0xFFA2L,0L,0x0.9p-1,0x1266L,0x1D17CA8DL}};
            int32_t *l_451 = (void*)0;
            int32_t *l_452 = &g_66.f6;
        }
        return (*g_115);
    }
    else
    { /* block id: 320 */
        return l_67.f1;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_319 g_66.f1.f7 g_66.f5.f0 g_239 g_66.f6
 * writes: g_320 g_66.f6 g_240
 */
inline static int32_t  func_39(uint16_t  p_40, struct S0  p_41, uint16_t  p_42, const struct S1  p_43)
{ /* block id: 304 */
    int32_t ***l_442 = (void*)0;
    int32_t *l_445 = &g_66.f6;
    struct S1 l_447 = {{0x0881L,4294967295UL,0x0.5p-1,0x1.5p+1,0UL,0x86CC52ADL,0x6.D82CE5p+80,0x04D4L,4294967295UL},{7L,0x3D0863DDL,-0x1.Fp-1,0xA.750BF2p-28,0xB789L,0x66F2C806L,0x7.359B96p+12,0x9CABL,0x569D390AL},7UL,0x0.2p+1,18446744073709551615UL,{1L,0UL,0x4.FC7346p+8,-0x10.4p-1,2UL,-1L,-0x1.Dp+1,0x582BL,0xFDB56B7FL},0x61678846L,0xE873L,{4L,4294967295UL,0xB.AA6E1Bp+60,-0x9.Fp-1,0xD1AFL,0xE396A497L,0x8.8p+1,-5L,0x41AB5D04L}};
    int32_t *l_449 = &l_447.f6;
lbl_448:
    (*g_319) = l_442;
    (*l_445) = ((int16_t)0xC782L >> (int16_t)10);
    if ((~((l_447.f1 , g_66.f1.f7) , g_66.f5.f0)))
    { /* block id: 307 */
        if (l_447.f1.f0)
            goto lbl_448;
        (*l_445) = 0x10363CBBL;
    }
    else
    { /* block id: 310 */
        uint32_t l_450 = 0xE30E6A18L;
        (*l_445) = p_43.f5.f5;
        (*g_239) = l_449;
        /* statement id: 312 */
        assert (g_240 == &l_447.f6);
        l_450 = p_41.f0;
    }
    /* facts after branching */
    //assert (g_240 == &l_447.f6 || g_240 == dangling || g_240 == 0 || g_240 == &g_5 || g_240 == &g_66.f6);
    return (*l_445);
    /* statement id: 315 */
    //assert (g_240 == dangling || g_240 == 0 || g_240 == &g_5 || g_240 == &g_66.f6);
}


/* ------------------------------------------ */
/* 
 * reads : g_66.f5.f1 g_438 g_66.f8.f8 g_66.f8.f1 g_66.f7 g_66.f0.f4 g_5 g_395 g_166
 * writes: g_66.f0.f3
 */
static struct S0  func_44(struct S0  p_45, float  p_46)
{ /* block id: 300 */
    float l_428 = 0x5.876B2Ep-5;
    int32_t l_433 = (-4L);
    struct S1 l_439 = {{0xFC43L,1UL,0xC.D5A7DFp+27,0x3.5AB81Fp+15,0xE786L,0xA6D23058L,0x1.1p-1,0x70BCL,4294967293UL},{0x9336L,0UL,0x1.4050B6p+74,0x1.FF49CDp+65,0x5226L,-1L,-0x1.2p-1,5L,0UL},18446744073709551613UL,0x1.9p+1,5UL,{0L,0x994B9A3DL,-0x2.Fp-1,0x5.5E59EDp-78,4UL,-1L,0x9.587BD2p-17,0L,4UL},0x8F0894A7L,0x4762L,{0x0538L,0x00F602FFL,0x8.901437p-54,0x9.4ECCDDp+38,0UL,0x976835E9L,0xA.980058p+15,0x2EFBL,0UL}};
    int32_t *l_440 = &l_433;
    (**g_395) = ((l_428 <= ((0xA.7F1079p+41 >= (((float)func_53((((int16_t)(g_66.f5.f1 > func_53(p_45.f8, (func_53(((l_433 > func_53((((int32_t)(p_45.f7 < ((int16_t)(p_45.f8 , (8UL <= 1UL)) << (int16_t)0)) - (int32_t)g_438) >= 0x840495FCL), g_66.f8.f8, g_66.f8.f1, l_439)) && 0xF8EDL), l_439.f0.f7, g_66.f0.f4, l_439) > 0xBFA84412L), l_439.f5.f1, l_439)) << (int16_t)g_5) != p_45.f5), p_45.f0, l_439.f0.f4, l_439) / (float)(-0x4.Bp-1)) > l_439.f0.f4)) == 0x5.33B625p+35)) > l_439.f0.f4);
    l_440 = &l_433;
    return l_439.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_66.f0.f7
 * writes: g_66.f0.f7
 */
inline static struct S0  func_47(const uint32_t  p_48, uint32_t  p_49, float  p_50, float  p_51, int32_t  p_52)
{ /* block id: 291 */
    float ****l_422 = (void*)0;
    float ***l_423 = &g_395;
    struct S0 l_427 = {1L,0UL,0x2.3p-1,-0x2.2p-1,2UL,0xBA522576L,0x0.7p+1,2L,0xF70D2491L};
    l_423 = &g_395;
    p_51 = (0x1.6p+1 < p_50);
    for (g_66.f0.f7 = 0; (g_66.f0.f7 == 25); ++g_66.f0.f7)
    { /* block id: 296 */
        struct S0 l_426 = {0xEB97L,3UL,-0x9.3p-1,0x4.Cp-1,0x7594L,0x82ADCDCDL,0x1.E68023p+22,-8L,0xB9B6017DL};
        return l_426;
    }
    return l_427;
}


/* ------------------------------------------ */
/* 
 * reads : g_66.f7
 * writes:
 */
static int16_t  func_53(uint16_t  p_54, int32_t  p_55, int32_t  p_56, struct S1  p_57)
{ /* block id: 289 */
    return g_66.f7;
}


/* ------------------------------------------ */
/* 
 * reads : g_66 g_5 g_115 g_166 g_167 g_235 g_239 g_240 g_394 g_395 g_290
 * writes: g_66.f1 g_66.f0.f6 g_115 g_66.f0 g_167 g_66.f6 g_66.f7 g_66.f4 g_240
 */
inline static struct S0  func_60(struct S1  p_61, int16_t  p_62, int16_t  p_63, int32_t  p_64, const struct S1  p_65)
{ /* block id: 42 */
    int32_t l_84 = (-2L);
    struct S1 l_94 = {{-1L,0xEE368F01L,0x7.FD80EDp+66,0x1.617F0Dp-59,1UL,-1L,0x0.Cp+1,1L,4294967295UL},{-2L,0x3A4A643FL,0x3.D035DCp-39,0x1.54E5BDp-63,0x25D2L,0xD311D72EL,0x0.3p+1,7L,0x5FEBDA90L},0xAA7AA2B6L,0x4.2E2CF9p-36,0x7F9D6CCCL,{0L,0xF4F38DF0L,0x2.757A99p+21,0x1.3p-1,1UL,0x607D9147L,0x1.5p+1,0L,0x7EA4D04EL},0x104C48C4L,65535UL,{1L,0x96B21A96L,0x0.4p-1,-0x1.2p+1,65535UL,0xE35F7F73L,-0x7.4p+1,0x3FCDL,1UL}};
    l_94.f1 = func_68(func_71(func_76(p_61, ((g_66 , ((((uint16_t)(((l_84 , ((uint16_t)p_65.f8.f8 + (uint16_t)((uint16_t)0x7085L << (uint16_t)6))) | (((-(int32_t)(func_90(g_66.f4, l_84) , 0x94392299L)) , 0x012BB54EL) == 0x916B4659L)) ^ 0x9871A9B2L) << (uint16_t)1) & 0UL) >= l_84)) || l_84), l_94, l_94.f5.f8, p_61.f5), l_94.f8.f0, p_61.f4, l_84), p_65.f7);
    /* statement id: 287 */
    assert (g_115 == 0 || g_115 == &g_66.f1);
    //assert (g_240 == dangling || g_240 == 0 || g_240 == &g_5 || g_240 == &g_66.f6);
    return p_61.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_66.f8.f8 g_115 g_66.f6 g_66.f8.f1 g_66.f8.f0 g_66.f0.f1 g_66.f0.f7 g_66.f8.f5 g_66.f1.f8 g_66.f0.f8 g_66.f1 g_66.f5.f7 g_66.f8.f4 g_66.f0.f4 g_5 g_66.f5.f5 g_66.f5.f8 g_166 g_66.f8.f7 g_167 g_66.f0.f3 g_66.f0.f5 g_66.f5.f0 g_66.f2 g_66 g_235 g_239 g_240 g_394 g_395 g_290
 * writes: g_66.f1.f8 g_66.f0 g_66.f1 g_167 g_115 g_66.f6 g_66.f7 g_66.f4 g_240
 */
inline static struct S0  func_68(struct S1  p_69, float  p_70)
{ /* block id: 58 */
    float l_121 = 0x7.Dp-1;
    int32_t *l_132 = &g_66.f6;
    struct S0 l_196 = {0x1CD1L,2UL,0x6.0FA9D2p+67,-0x3.4p+1,0x87C6L,0x852F216AL,0x0.2p+1,-6L,0x3681FFCAL};
    int32_t *l_222 = &g_5;
    uint32_t l_230 = 0xA73AD7BEL;
    int32_t l_250 = 0x118F731AL;
    struct S1 *l_258 = &g_66;
    struct S1 **l_257 = &l_258;
    int32_t ***l_325 = &g_239;
    uint16_t l_342 = 0UL;
    if (g_66.f8.f8)
    { /* block id: 59 */
        const int16_t l_133 = 1L;
        float *l_134 = &l_121;
        const uint32_t l_181 = 0UL;
        struct S0 l_219 = {0L,1UL,0x8.7626E8p-68,-0x8.Cp-1,0x8430L,0x5D0A279AL,0xC.06FC63p-31,0xD10FL,1UL};
        int32_t **l_227 = &l_132;
lbl_145:
        (*l_134) = (((float)((((p_69.f0.f4 , (((float)0x2.E0B147p-6 / (float)((g_115 == (((uint16_t)(((int32_t)0x70DE6C0FL - (int32_t)((4294967295UL <= ((uint16_t)(&g_5 != l_132) << (uint16_t)(((*l_132) < 4UL) == 0x9893017CL))) , g_66.f8.f1)) == 4294967290UL) >> (uint16_t)3) , (void*)0)) < (-0x1.Ap+1))) <= (*l_132))) < g_66.f8.f1) > g_66.f8.f0) >= (*l_132)) / (float)l_133) , 0x3.6p+1);
        if (((int16_t)((int32_t)0L - (int32_t)((uint16_t)((((-8L) == (((uint16_t)p_69.f4 + (uint16_t)0x5905L) & ((uint32_t)g_66.f0.f1 - (uint32_t)1UL))) | 1UL) , ((9UL > g_66.f0.f7) == l_133)) % (uint16_t)g_66.f8.f5)) / (int16_t)65532UL))
        { /* block id: 61 */
            uint32_t l_150 = 0x681FD754L;
            struct S1 l_159 = {{1L,0x67DC849FL,0x1.C6302Bp-45,0x6.1p-1,65526UL,0x1E190E94L,0x1.0p-1,-1L,1UL},{0x076BL,1UL,0xF.8AD327p+99,0xF.E25CFBp+89,2UL,0xFB1205E5L,0x5.3p+1,0x53F3L,4294967295UL},0xDF8BC2A5L,0x8.0p-1,0xE8864CA1L,{0L,7UL,0xD.B4221Dp-83,0x3.4p+1,0x7A8CL,-4L,0x0.2p+1,1L,0x965478D4L},-2L,65534UL,{0xCBE3L,1UL,0x6.673017p-88,0x0.3p+1,0x05D9L,-1L,0xF.94D37Ap-25,6L,0UL}};
            struct S1 l_161 = {{1L,0x136CE826L,0x3.E760F3p+78,0x8.73E7C0p+7,0x4603L,-1L,-0x3.Dp+1,0x4FE2L,0xF70743EEL},{0x78D4L,0x6807E973L,0xD.C97C41p+14,0x1.Cp+1,1UL,0L,-0x1.3p-1,0x3B89L,0x93670792L},18446744073709551615UL,0x0.996EDFp+3,18446744073709551615UL,{0xD6A8L,0UL,0xF.1D3B27p-26,-0x1.5p-1,0UL,0x519BC063L,0xF.4C8E7Fp-17,-9L,0x116E1489L},0xD1DF2674L,65532UL,{2L,4294967287UL,0x4.D17722p+80,0xF.28787Cp-24,0xBC5BL,0L,0xB.278A2Fp-85,0L,0UL}};
            struct S0 **l_185 = &g_115;
            if (g_66.f6)
                goto lbl_145;
            if (g_66.f6)
                goto lbl_145;
            if (p_69.f5.f4)
            { /* block id: 64 */
lbl_165:
                for (g_66.f1.f8 = (-12); (g_66.f1.f8 >= 33); g_66.f1.f8 += 5)
                { /* block id: 67 */
                    float l_153 = 0x0.7p+1;
                    int32_t *l_162 = &l_159.f6;
                    if (((((g_66.f0.f8 || ((*g_115) , g_66.f5.f7)) < (g_66.f0.f7 >= p_69.f1.f0)) <= (0x232AL && ((uint32_t)((p_69.f1.f8 | (l_150 != ((int16_t)(__builtin_ffsl(g_66.f8.f4) < l_150) - (int16_t)9L))) | g_66.f1.f8) / (uint32_t)g_66.f1.f7))) | 0xEE31L))
                    { /* block id: 68 */
                        (*l_134) = (!g_66.f8.f5);
                    }
                    else
                    { /* block id: 70 */
                        int16_t l_160 = 1L;
                        g_66.f0 = (((((int32_t)((__builtin_clz(((uint32_t)__builtin_ia32_crc32qi(p_69.f0.f1, (g_66.f8.f1 , p_69.f0.f8)) - (uint32_t)(9L || (((func_76(l_159, l_160, l_161, l_133, l_161.f0) , l_162) == l_132) , g_66.f0.f4)))) && g_66.f5.f5) ^ g_66.f5.f8) + (int32_t)p_69.f1.f5) , g_66.f1.f1) >= g_66.f6) , (*g_115));
                    }
                }
                for (g_66.f0.f8 = 0; (g_66.f0.f8 <= 13); g_66.f0.f8 += 1)
                { /* block id: 76 */
                    if (p_69.f0.f4)
                        goto lbl_165;
                    (*l_134) = (-0x10.7p+1);
                    if (p_69.f4)
                        break;
                    (*g_115) = (*g_115);
                }
            }
            else
            { /* block id: 82 */
                uint32_t l_174 = 1UL;
                const struct S0 l_206 = {0x6044L,4294967295UL,0x3.791FE4p-8,0x5.1p-1,4UL,0L,0xE.38CFB7p-60,-1L,0UL};
                if ((func_90((g_166 != g_166), g_66.f8.f7) , (1UL || g_66.f0.f7)))
                { /* block id: 83 */
                    struct S0 **l_168 = &g_167;
                    int32_t l_182 = 2L;
                    (*l_168) = g_167;
                    for (g_66.f1.f4 = 0; (g_66.f1.f4 > 55); g_66.f1.f4 += 3)
                    { /* block id: 87 */
                        int32_t **l_171 = &l_132;
                        (*l_171) = l_132;
                        (*l_134) = (p_69.f1 , ((*g_166) < (p_69.f8.f5 , (((float)l_174 + (float)(((int16_t)g_66.f0.f5 << (int16_t)5) , (*g_166))) > ((*g_166) != ((float)(l_161.f8.f4 >= __builtin_popcount((((int32_t)(g_66.f8.f1 && l_181) - (int32_t)p_69.f0.f5) != p_69.f0.f8))) + (float)l_182))))));
                        (*l_171) = l_134;
                        /* statement id: 90 */
                        assert (l_132 == &l_121);
                    }
                    /* facts after for loop */
                    assert (l_132 == &l_121 || l_132 == &g_66.f6);
                    if (((uint16_t)((void*)0 == l_185) >> (uint16_t)10))
                    { /* block id: 92 */
                        struct S1 *l_187 = &l_161;
                        struct S1 **l_186 = &l_187;
                        int32_t **l_188 = &l_132;
                        (*l_186) = &g_66;
                        /* statement id: 93 */
                        assert (l_187 == &g_66);
                        (*l_188) = l_132;
                        (**l_188) = (p_69.f8.f7 > ((((uint32_t)(g_66.f5.f0 >= ((uint16_t)0xF688L + (uint16_t)65529UL)) + (uint32_t)((g_66.f0.f5 <= 0xB1FF4740L) && (!g_66.f2))) != p_69.f4) == (((int32_t)((((func_71(g_66, l_174, l_161.f1.f8, p_69.f2) , 0x766F41D7L) >= l_174) == 65530UL) && p_69.f4) % (int32_t)0x103A3114L) , l_174)));
                        return l_196;
                    }
                    else
                    { /* block id: 97 */
                        struct S1 *l_198 = &l_161;
                        struct S1 **l_197 = &l_198;
                        (*l_197) = &g_66;
                        /* statement id: 98 */
                        assert (l_198 == &g_66);
                        return (*g_167);
                    }
                }
                else
                { /* block id: 101 */
                    uint32_t l_203 = 4UL;
                    (*l_132) = ((uint32_t)((p_69.f1.f8 & ((p_69.f0.f7 | (__builtin_ctzl(((uint16_t)l_203 >> (uint16_t)9)) | (l_159.f5.f1 < p_69.f6))) != ((uint32_t)1UL / (uint32_t)(l_206 , l_203)))) , 0x12E59073L) % (uint32_t)p_69.f0.f7);
                    return l_196;
                }
            }
        }
        else
        { /* block id: 106 */
            int32_t *l_209 = &g_5;
            for (g_66.f6 = 0; (g_66.f6 <= 10); g_66.f6 += 7)
            { /* block id: 109 */
                int32_t **l_210 = &l_209;
                struct S0 l_218 = {0x77CFL,0x8A681D73L,0xB.36F551p+41,0x0.8p-1,65535UL,0x0B150522L,0xE.91D92Dp-31,0xB770L,0xC6EDD253L};
                (*l_210) = l_209;
                if (g_66.f5.f8)
                { /* block id: 111 */
                    (*g_167) = func_90(((int16_t)(((((-2L) && ((void*)0 != l_134)) || 0x6CB6L) ^ 4294967292UL) & (p_69.f1.f7 & (((p_69.f0.f5 & ((4294967288UL <= g_66.f0.f7) & g_66.f0.f7)) == g_66.f0.f8) && p_69.f0.f7))) >> (int16_t)p_69.f1.f5), (**l_210));
                }
                else
                { /* block id: 113 */
                    for (l_196.f0 = 3; (l_196.f0 >= (-9)); l_196.f0 -= 7)
                    { /* block id: 116 */
                        return p_69.f1;
                    }
                    (*g_115) = ((p_69.f8.f1 , ((int16_t)(~(((*g_166) , g_66.f2) > p_69.f2)) >> (int16_t)((l_218 , &p_69) == &p_69))) , func_90(((0xAF55515DL | (**l_210)) ^ (-3L)), p_69.f5.f8));
                    (*l_210) = l_134;
                    /* statement id: 120 */
                    assert (l_209 == &l_121);
                    (*l_210) = ((g_66.f0.f5 , 0L) , &g_5);
                    /* statement id: 121 */
                    assert (l_209 == &g_5);
                }
            }
            p_69.f0 = l_219;
            for (g_66.f7 = (-27); (g_66.f7 != 39); g_66.f7 += 1)
            { /* block id: 127 */
                if ((*l_209))
                    break;
            }
        }
        if ((g_166 != (void*)0))
        { /* block id: 131 */
            int32_t **l_223 = &l_132;
            struct S0 **l_226 = &g_115;
            (*l_223) = l_222;
            /* statement id: 132 */
            assert (l_132 == &g_5);
            (*g_115) = func_90(((uint16_t)l_219.f1 - (uint16_t)l_219.f7), g_66.f0.f5);
            (*l_226) = g_115;
        }
        else
        { /* block id: 135 */
            p_69.f1.f2 = ((*l_222) < p_69.f8.f6);
        }
        /* facts after branching */
        assert (l_132 == &g_66.f6 || l_132 == &g_5);
        (*l_227) = (void*)0;
        /* statement id: 138 */
        assert (l_132 == 0);
    }
    else
    { /* block id: 139 */
        uint32_t l_236 = 0x7A8213EFL;
        struct S0 *l_251 = &g_66.f0;
        int32_t *l_269 = &g_66.f6;
        if (((*g_167) , ((p_69.f0.f5 == ((uint16_t)(l_230 , ((((uint16_t)g_66.f0.f1 >> (uint16_t)((int16_t)g_235 + (int16_t)g_66.f0.f7)) | l_236) > (((int32_t)g_66.f8.f0 + (int32_t)((((void*)0 == g_239) && p_69.f8.f5) <= g_235)) | 1L))) % (uint16_t)p_69.f2)) && 0x5BF9L)))
        { /* block id: 140 */
            for (l_196.f1 = 0; (l_196.f1 <= 50); l_196.f1 += 2)
            { /* block id: 143 */
                for (g_66.f4 = 29; (g_66.f4 > 35); g_66.f4 += 8)
                { /* block id: 146 */
                    return p_69.f8;
                }
            }
            (*g_167) = func_90(g_66.f8.f0, ((uint32_t)g_66.f1.f5 - (uint32_t)1L));
        }
        else
        { /* block id: 151 */
            int32_t l_249 = 4L;
            const struct S1 *l_276 = &g_66;
        }
        return l_196;
    }
    /* facts after branching */
    assert (l_132 == 0);
    (*g_166) = (((float)(p_69.f0.f1 == ((float)(!(*g_166)) / (float)(*l_222))) + (float)(*g_166)) >= p_69.f1.f4);
    if ((((((int32_t)((((uint16_t)65526UL << (uint16_t)13) >= (((((((int16_t)(&g_167 != (void*)0) >> (int16_t)p_69.f6) , l_342) > p_69.f8.f1) , (func_71(p_69, (***l_325), (***l_325), g_235) , g_66.f5.f1)) >= p_69.f8.f0) && (***l_325))) , p_69.f1.f4) + (int32_t)(***l_325)) == 0x6E7CF2B3L) | 0x49A2L) , 0xF3284EDEL))
    { /* block id: 233 */
        float l_347 = 0xF.658399p+81;
        int32_t l_348 = 0x28E30F9EL;
        p_69.f6 = ((int32_t)((uint16_t)(p_69.f1.f7 > (p_69.f8 , g_66.f0.f0)) % (uint16_t)l_348) % (int32_t)0x261E3F99L);
    }
    else
    { /* block id: 235 */
        int32_t *l_349 = &g_5;
        (**l_325) = l_349;
        /* statement id: 236 */
        assert (g_240 == &g_5);
        (*g_167) = p_69.f1;
        p_69.f6 = (-(int32_t)((int32_t)((((int16_t)(*l_349) - (int16_t)(((((uint16_t)(***l_325) + (uint16_t)(***l_325)) & (((p_69.f8.f8 , (!((*g_166) , ((int16_t)(((uint32_t)g_66.f5.f4 - (uint32_t)(p_69.f0.f1 > 0xABFF320EL)) || 0x9DE71AADL) >> (int16_t)(***l_325))))) != (***l_325)) && 0xC9D1L)) & 0x79F2L) ^ p_69.f1.f0)) != p_69.f5.f4) ^ p_69.f0.f8) / (int32_t)4294967295UL));
    }
    /* facts after branching */
    assert (g_240 == &g_5 || g_240 == &g_66.f6);
    if (p_69.f1.f7)
    { /* block id: 240 */
        int16_t l_362 = 0xCD6EL;
        float **l_363 = &g_166;
        int32_t l_366 = 4L;
        if ((l_362 , (**g_239)))
        { /* block id: 241 */
            const float *l_365 = (void*)0;
            const float **l_364 = &l_365;
            l_366 = (0x3.984BFCp-57 < (((*g_166) < (l_362 != __builtin_parity((*l_222)))) < ((l_362 != ((l_363 == l_364) <= p_69.f5.f3)) <= (*g_166))));
            (*g_239) = &l_366;
            /* statement id: 243 */
            assert (g_240 == &l_366);
        }
        else
        { /* block id: 244 */
            return p_69.f5;
        }
        /* facts after branching */
        assert (g_240 == &l_366);
lbl_374:
        (*g_167) = func_90(g_66.f1.f4, __builtin_ffsll((((((uint16_t)0x2294L - (uint16_t)((((((!((p_69 , 0x0.2p+1) , l_366)) | ((int32_t)(**g_239) - (int32_t)((p_69.f8.f1 > g_66.f0.f4) && (***l_325)))) && 1UL) != (**g_239)) , (void*)0) == (void*)0)) , p_69) , (-10L)) , 0x5375E05E6E3ACBC8LL)));
        if (p_69.f5.f7)
        { /* block id: 248 */
            for (g_66.f0.f4 = (-24); (g_66.f0.f4 <= 9); g_66.f0.f4 += 4)
            { /* block id: 251 */
                (*g_239) = (**l_325);
                return p_69.f8;
                /* statement id: 253 */
                //assert (g_240 == dangling);
            }
            if (g_66.f1.f1)
                goto lbl_374;
            (*g_239) = (*g_239);
        }
        else
        { /* block id: 257 */
            struct S0 **l_377 = (void*)0;
            struct S0 **l_378 = &g_115;
            for (g_66.f1.f0 = 0; (g_66.f1.f0 < 21); ++g_66.f1.f0)
            { /* block id: 260 */
                (*l_257) = (void*)0;
                /* statement id: 261 */
                assert (l_258 == 0);
            }
            /* facts after for loop */
            assert (l_258 == 0 || l_258 == &g_66);
            (*l_378) = (void*)0;
            /* statement id: 263 */
            assert (g_115 == 0);
            p_69.f0 = p_69.f0;
        }
        /* facts after branching */
        assert (g_115 == 0 || g_115 == &g_66.f1);
        assert (l_258 == 0 || l_258 == &g_66);
        return (*g_167);
        /* statement id: 266 */
        //assert (g_240 == dangling);
    }
    else
    { /* block id: 267 */
        uint32_t l_389 = 0UL;
        float ***l_396 = &g_395;
        struct S1 *l_400 = (void*)0;
        struct S0 l_406 = {6L,0xC22469E6L,-0x1.Dp+1,0xE.6A61EAp-94,8UL,7L,0xE.F8204Ep-38,0L,8UL};
        uint32_t l_413 = 18446744073709551615UL;
        const int32_t *l_416 = &g_66.f6;
        const int32_t **l_415 = &l_416;
        const int32_t ***l_414 = &l_415;
        (*g_166) = (g_240 == g_166);
        if ((g_66.f1.f1 >= (*l_222)))
        { /* block id: 269 */
            uint32_t l_397 = 0x6D2AF94CL;
            p_69.f6 = ((int32_t)(((int16_t)(((uint32_t)p_69.f8.f8 / (uint32_t)p_69.f5.f1) && p_69.f8.f8) - (int16_t)((int16_t)((uint32_t)l_389 - (uint32_t)(((int16_t)((0x8A5B6AFDL <= (3UL | (g_66.f0.f4 && (p_69.f0.f7 , ((p_69.f0.f5 , g_394) != l_396))))) , l_389) % (int16_t)g_66.f8.f1) & p_69.f5.f1)) << (int16_t)l_397)) > g_66.f0.f0) + (int32_t)p_69.f2);
            for (p_69.f0.f7 = 0; (p_69.f0.f7 > (-14)); --p_69.f0.f7)
            { /* block id: 273 */
                int32_t *l_401 = (void*)0;
                (*l_257) = l_400;
                /* statement id: 274 */
                assert (l_258 == 0);
                (**l_325) = (*g_239);
                (***g_394) = l_389;
                (**l_325) = l_401;
                /* statement id: 277 */
                assert (g_240 == 0);
            }
            /* facts after for loop */
            assert (g_240 == 0 || g_240 == &g_5 || g_240 == &g_66.f6);
            assert (l_258 == 0 || l_258 == &g_66);
        }
        else
        { /* block id: 279 */
            const int32_t ****l_417 = &l_414;
            (*l_417) = ((((int16_t)((uint32_t)(l_406 , g_66.f0.f7) - (uint32_t)((int32_t)(((uint16_t)65535UL + (uint16_t)((uint16_t)p_69.f0.f5 << (uint16_t)11)) , (*g_240)) - (int32_t)p_69.f0.f4)) - (int16_t)((((l_413 || (((*l_222) , (g_66.f5.f7 > 0UL)) , g_66.f6)) ^ p_69.f8.f8) & g_5) < p_69.f0.f8)) < g_66.f5.f1) , l_414);
            (***g_394) = p_69.f5.f1;
            p_69.f6 = ((((uint16_t)(*l_222) << (uint16_t)p_69.f1.f0) & (*g_240)) >= g_290);
            (***l_396) = (-0x1.Ep+1);
        }
        /* facts after branching */
        assert (g_240 == 0 || g_240 == &g_5 || g_240 == &g_66.f6);
        assert (l_258 == 0 || l_258 == &g_66);
    }
    /* facts after branching */
    assert (g_240 == 0 || g_240 == &g_5 || g_240 == &g_66.f6);
    assert (l_258 == 0 || l_258 == &g_66);
    return l_196;
}


/* ------------------------------------------ */
/* 
 * reads : g_66.f0.f8 g_5 g_66.f8.f1 g_66.f5.f0 g_66.f0.f1 g_66.f8.f0 g_66.f5.f7 g_115 g_66.f1
 * writes: g_66.f1 g_66.f0.f6 g_115
 */
static struct S1  func_71(struct S1  p_72, int32_t  p_73, uint16_t  p_74, uint32_t  p_75)
{ /* block id: 47 */
    uint16_t l_97 = 3UL;
    struct S0 *l_111 = &g_66.f1;
    int32_t *l_118 = &g_66.f6;
    struct S1 l_120 = {{0x1A6CL,4294967295UL,0xA.3D2DFCp+7,0x5.FCD69Dp-45,65533UL,0x70180479L,-0x1.8p-1,2L,4294967286UL},{-1L,0x21536BB1L,0x4.9p-1,0x4.CAD855p+47,0xEBD0L,1L,0xA.CB17CCp-40,0xB779L,0xB6EBABB2L},0x718FBDC8L,0x2.3p-1,0x1D0B0DE6L,{3L,4294967288UL,0x0.5p+1,0x3.0p-1,0xE0E3L,0xBFDF325FL,0x1.Dp+1,5L,0x925FEAA6L},0xB1ACD26AL,0x3D7DL,{0L,0x76AFE394L,-0x1.Ap+1,-0x5.7p+1,0x586BL,1L,-0x1.9p+1,0xC79CL,4294967294UL}};
    (*l_111) = func_90(((l_97 & ((__builtin_clz(g_66.f0.f8) ^ ((uint32_t)((uint16_t)(p_72.f0.f8 > (l_97 || (-(uint32_t)((int32_t)p_72.f1.f5 / (int32_t)(((int16_t)((int16_t)(((((uint32_t)g_66.f8.f1 + (uint32_t)(g_66.f5.f0 <= __builtin_parity((g_66.f0.f1 < 0xB2AEL)))) >= 0x5B07L) | g_66.f0.f8) & 1UL) >> (int16_t)1) - (int16_t)p_72.f5.f4) && g_66.f8.f0))))) + (uint16_t)0UL) - (uint32_t)l_97)) != 0xC3ADL)) , l_97), g_66.f5.f7);
    for (p_72.f1.f0 = 16; (p_72.f1.f0 >= 15); --p_72.f1.f0)
    { /* block id: 51 */
        struct S0 *l_114 = &g_66.f0;
        float *l_116 = (void*)0;
        float *l_117 = &g_66.f0.f6;
        int32_t **l_119 = &l_118;
        (*l_117) = __builtin_parity((((p_72.f8.f7 , p_72.f1.f6) , l_114) != g_115));
        (*l_111) = (*l_111);
        g_115 = g_115;
        (*l_119) = l_118;
    }
    return l_120;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_76(struct S1  p_77, uint32_t  p_78, struct S1  p_79, int16_t  p_80, struct S0  p_81)
{ /* block id: 45 */
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_90(uint32_t  p_91, uint32_t  p_92)
{ /* block id: 43 */
    struct S0 l_93 = {0L,0xB98AA170L,0x0.Bp+1,-0x1.5p-1,0x65D1L,0L,-0x2.6p-1,0x2EE7L,0x45276D52L};
    return l_93;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_66.f0.f0, "g_66.f0.f0", print_hash_value);
    transparent_crc(g_66.f0.f1, "g_66.f0.f1", print_hash_value);
    transparent_crc_bytes (&g_66.f0.f2, sizeof(g_66.f0.f2), "g_66.f0.f2", print_hash_value);
    transparent_crc_bytes (&g_66.f0.f3, sizeof(g_66.f0.f3), "g_66.f0.f3", print_hash_value);
    transparent_crc(g_66.f0.f4, "g_66.f0.f4", print_hash_value);
    transparent_crc(g_66.f0.f5, "g_66.f0.f5", print_hash_value);
    transparent_crc_bytes (&g_66.f0.f6, sizeof(g_66.f0.f6), "g_66.f0.f6", print_hash_value);
    transparent_crc(g_66.f0.f7, "g_66.f0.f7", print_hash_value);
    transparent_crc(g_66.f0.f8, "g_66.f0.f8", print_hash_value);
    transparent_crc(g_66.f1.f0, "g_66.f1.f0", print_hash_value);
    transparent_crc(g_66.f1.f1, "g_66.f1.f1", print_hash_value);
    transparent_crc_bytes (&g_66.f1.f2, sizeof(g_66.f1.f2), "g_66.f1.f2", print_hash_value);
    transparent_crc_bytes (&g_66.f1.f3, sizeof(g_66.f1.f3), "g_66.f1.f3", print_hash_value);
    transparent_crc(g_66.f1.f4, "g_66.f1.f4", print_hash_value);
    transparent_crc(g_66.f1.f5, "g_66.f1.f5", print_hash_value);
    transparent_crc_bytes (&g_66.f1.f6, sizeof(g_66.f1.f6), "g_66.f1.f6", print_hash_value);
    transparent_crc(g_66.f1.f7, "g_66.f1.f7", print_hash_value);
    transparent_crc(g_66.f1.f8, "g_66.f1.f8", print_hash_value);
    transparent_crc(g_66.f2, "g_66.f2", print_hash_value);
    transparent_crc_bytes (&g_66.f3, sizeof(g_66.f3), "g_66.f3", print_hash_value);
    transparent_crc(g_66.f4, "g_66.f4", print_hash_value);
    transparent_crc(g_66.f5.f0, "g_66.f5.f0", print_hash_value);
    transparent_crc(g_66.f5.f1, "g_66.f5.f1", print_hash_value);
    transparent_crc_bytes (&g_66.f5.f2, sizeof(g_66.f5.f2), "g_66.f5.f2", print_hash_value);
    transparent_crc_bytes (&g_66.f5.f3, sizeof(g_66.f5.f3), "g_66.f5.f3", print_hash_value);
    transparent_crc(g_66.f5.f4, "g_66.f5.f4", print_hash_value);
    transparent_crc(g_66.f5.f5, "g_66.f5.f5", print_hash_value);
    transparent_crc_bytes (&g_66.f5.f6, sizeof(g_66.f5.f6), "g_66.f5.f6", print_hash_value);
    transparent_crc(g_66.f5.f7, "g_66.f5.f7", print_hash_value);
    transparent_crc(g_66.f5.f8, "g_66.f5.f8", print_hash_value);
    transparent_crc(g_66.f6, "g_66.f6", print_hash_value);
    transparent_crc(g_66.f7, "g_66.f7", print_hash_value);
    transparent_crc(g_66.f8.f0, "g_66.f8.f0", print_hash_value);
    transparent_crc(g_66.f8.f1, "g_66.f8.f1", print_hash_value);
    transparent_crc_bytes (&g_66.f8.f2, sizeof(g_66.f8.f2), "g_66.f8.f2", print_hash_value);
    transparent_crc_bytes (&g_66.f8.f3, sizeof(g_66.f8.f3), "g_66.f8.f3", print_hash_value);
    transparent_crc(g_66.f8.f4, "g_66.f8.f4", print_hash_value);
    transparent_crc(g_66.f8.f5, "g_66.f8.f5", print_hash_value);
    transparent_crc_bytes (&g_66.f8.f6, sizeof(g_66.f8.f6), "g_66.f8.f6", print_hash_value);
    transparent_crc(g_66.f8.f7, "g_66.f8.f7", print_hash_value);
    transparent_crc(g_66.f8.f8, "g_66.f8.f8", print_hash_value);
    transparent_crc(g_235, "g_235", print_hash_value);
    transparent_crc(g_290, "g_290", print_hash_value);
    transparent_crc(g_438, "g_438", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 80
   depth: 1, occurrence: 9
   depth: 2, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 140
   depth: 2, occurrence: 21
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 15, occurrence: 4
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 27, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 64

XXX times a variable address is taken: 72
XXX times a pointer is dereferenced on RHS: 74
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 10
   depth: 3, occurrence: 9
XXX times a pointer is dereferenced on LHS: 73
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 222

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 161
   level: 2, occurrence: 27
   level: 3, occurrence: 18
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 32
XXX number of pointers point to scalars: 21
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 21.9
XXX average alias set size: 1.2

XXX times a non-volatile is read: 611
XXX times a non-volatile is write: 196
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 8

XXX stmts: 124
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 30
   depth: 2, occurrence: 27
   depth: 3, occurrence: 14
   depth: 4, occurrence: 16
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 17.8
XXX percentage an existing variable is used: 82.2
********************* end of statistics **********************/

