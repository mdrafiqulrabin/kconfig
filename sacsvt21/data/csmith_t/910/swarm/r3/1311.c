/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --no-structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2521843158
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U1 {
   int8_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 0x19C5A654L;
static uint16_t g_30 = 0xA32FL;
static int32_t g_132 = 1L;
static uint32_t g_159 = 18446744073709551606UL;
static volatile int32_t g_163 = 0x8E649E9AL;/* VOLATILE GLOBAL g_163 */
static volatile int8_t g_164 = 0xF9L;/* VOLATILE GLOBAL g_164 */
static int32_t g_166 = 0x4FAE1B8EL;
static int32_t g_167 = 1L;
static int8_t g_168 = 0x22L;
static volatile int16_t g_171 = 0x1EF1L;/* VOLATILE GLOBAL g_171 */
static int8_t g_172 = 0x7DL;
static volatile uint32_t g_178 = 0xA43B2DE0L;/* VOLATILE GLOBAL g_178 */
static uint32_t g_235 = 0x43F7002FL;
static union U1 g_283 = {0x07L};
static int32_t g_309 = 1L;
static uint32_t g_340 = 0x0C468759L;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_28(void);
static const uint16_t  func_45(uint16_t  p_46);
inline static uint64_t  func_47(uint32_t  p_48, int32_t  p_49, int16_t  p_50, int8_t  p_51, int32_t  p_52);
inline static uint32_t  func_53(int32_t  p_54, uint16_t  p_55, uint32_t  p_56, int32_t  p_57, const int32_t  p_58);
inline static uint16_t  func_69(uint32_t  p_70, int32_t  p_71);
static uint16_t  func_74(const uint32_t  p_75, int16_t  p_76, union U1  p_77, int32_t  p_78, int16_t  p_79);
static uint16_t  func_83(int32_t  p_84, const uint32_t  p_85, uint16_t  p_86);
inline static int32_t  func_92(uint32_t  p_93, int32_t  p_94);
static uint32_t  func_95(uint32_t  p_96, uint32_t  p_97, int16_t  p_98, int32_t  p_99, int8_t  p_100);
inline static int32_t  func_109(uint32_t  p_110);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_30 g_5 g_132 g_159 g_178 g_168 g_164 g_172 g_171 g_167 g_163 g_166 g_283 g_283.f0 g_309 g_235 g_340
 * writes: g_30 g_132 g_159 g_178 g_172 g_235 g_5 g_309 g_283.f0 g_340
 */
static uint32_t  func_28(void)
{ /* block id: 36 */
    int16_t l_29 = 0xD714L;
    int32_t l_33 = 1L;
    int32_t l_44 = (-1L);
    uint16_t l_80 = 0xCA5EL;
    int16_t l_282 = (-10L);
    int32_t l_333 = 0x2586CC2EL;
    int32_t l_367 = 0x69A12CBEL;
    g_30++;
    l_33 ^= g_5;
    l_333 = ((int32_t)((uint16_t)((((((uint16_t)(((0x7D19FA55L > ((uint32_t)(((int16_t)l_44 >> (int16_t)func_45((__builtin_ctzll(func_47((g_5 && func_53(((uint16_t)((int32_t)((int16_t)((((int16_t)6L % (int16_t)((uint16_t)l_33 % (uint16_t)func_69((((((uint16_t)func_74((__builtin_ctz(l_80) ^ (((int16_t)(func_83((g_30 == 0x04C3L), g_30, l_29) > g_167) - (int16_t)l_282) <= 4294967289UL)), l_80, g_283, g_166, l_80) + (uint16_t)g_166) | g_166) & 0x3BF9L) && l_29), l_44))) ^ l_333) >= g_166) << (int16_t)l_80) + (int32_t)l_80) + (uint16_t)g_167), g_168, l_44, g_168, l_33)), l_333, l_29, l_282, g_168)) & g_167))) >= g_168) / (uint32_t)g_168)) >= l_367) == g_168) >> (uint16_t)0) && 0UL) && g_235) ^ l_367) < l_33) >> (uint16_t)15) - (int32_t)g_166);
    l_333 = g_163;
    return l_282;
}


/* ------------------------------------------ */
/* 
 * reads : g_159 g_166 g_167 g_340
 * writes: g_340
 */
static const uint16_t  func_45(uint16_t  p_46)
{ /* block id: 136 */
    const int32_t l_360 = 0xAFACD925L;
    int8_t l_362 = 0xF0L;
    int32_t l_363 = 0x6E4D6C61L;
    const int32_t l_366 = 0L;
    l_363 = ((uint32_t)0x46CB84E6L - (uint32_t)(((uint16_t)(((0xD816DE6DL & 7UL) >= (!((uint16_t)((p_46 >= ((((int16_t)(((uint16_t)l_360 / (uint16_t)0x25B8L) && (-(uint32_t)p_46)) - (int16_t)g_159) ^ 0x488A8A09L) || 3L)) ^ g_166) % (uint16_t)l_360))) && l_360) >> (uint16_t)l_362) == g_167));
    for (g_340 = 0; (g_340 <= 46); g_340++)
    { /* block id: 140 */
        l_363 = l_363;
    }
    return l_366;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_30 g_132 g_159 g_178 g_168 g_164 g_172 g_171 g_167 g_163 g_166 g_309 g_283.f0 g_235 g_340
 * writes: g_132 g_159 g_178 g_30 g_172 g_235 g_283.f0 g_340
 */
inline static uint64_t  func_47(uint32_t  p_48, int32_t  p_49, int16_t  p_50, int8_t  p_51, int32_t  p_52)
{ /* block id: 133 */
    int32_t l_347 = 0x3A947ED1L;
    p_52 = (!(p_52 & ((int16_t)func_53((__builtin_parityll((l_347 ^ func_83(p_48, l_347, l_347))) == (!l_347)), l_347, l_347, p_52, g_309) % (int16_t)g_166)));
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads : g_283.f0 g_166 g_171 g_235 g_340
 * writes: g_283.f0 g_340
 */
inline static uint32_t  func_53(int32_t  p_54, uint16_t  p_55, uint32_t  p_56, int32_t  p_57, const int32_t  p_58)
{ /* block id: 124 */
    int8_t l_338 = 5L;
    int32_t l_339 = 0x741B8BEBL;
    int32_t l_343 = 0xE1BB06D7L;
    for (g_283.f0 = 0; (g_283.f0 == (-30)); g_283.f0 -= 9)
    { /* block id: 127 */
        return g_166;
    }
    l_339 &= (0UL | ((((uint16_t)l_338 << (uint16_t)0) > ((p_54 < (l_338 ^ l_338)) && g_171)) <= ((func_69(p_55, g_235) < p_58) & p_58)));
    g_340++;
    return l_343;
}


/* ------------------------------------------ */
/* 
 * reads : g_166
 * writes:
 */
inline static uint16_t  func_69(uint32_t  p_70, int32_t  p_71)
{ /* block id: 121 */
    uint32_t l_332 = 0UL;
    l_332 = g_166;
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_167 g_163 g_30 g_172 g_164 g_168 g_166 g_132 g_159 g_178 g_283.f0 g_171 g_309
 * writes: g_5 g_172 g_132 g_159 g_178 g_30 g_235 g_309
 */
static uint16_t  func_74(const uint32_t  p_75, int16_t  p_76, union U1  p_77, int32_t  p_78, int16_t  p_79)
{ /* block id: 108 */
    int32_t l_294 = 0L;
    int32_t l_310 = 0x9D19914BL;
    for (g_5 = 0; (g_5 >= 28); g_5 += 9)
    { /* block id: 111 */
        uint32_t l_293 = 0x5DF4781FL;
        int32_t l_295 = 0xE1387A81L;
        l_295 = (((-(int16_t)(4294967295UL && g_167)) > (((((uint32_t)((uint32_t)((((__builtin_parity(((uint16_t)((p_76 >= func_95(g_163, g_30, p_78, g_167, p_77.f0)) >= (-3L)) >> (uint16_t)g_283.f0)) < g_166) == l_293) == p_79) <= 0L) + (uint32_t)p_76) % (uint32_t)l_293) & p_75) > 0x75BA9C81L) | l_294)) >= (-3L));
        if (g_5)
            break;
        g_309 |= ((uint16_t)func_92(p_75, ((((int16_t)l_294 + (int16_t)p_77.f0) <= (!(((l_295 > ((int16_t)((uint32_t)func_95(g_164, l_293, ((int16_t)(l_294 == (((uint16_t)0xAEC3L >> (uint16_t)15) | __builtin_popcountll(p_76))) << (int16_t)g_166), l_294, g_159) % (uint32_t)1L) << (int16_t)p_77.f0)) == g_168) ^ 0x222830CFL))) && 0x334A1C84L)) >> (uint16_t)g_283.f0);
        l_310 |= l_294;
    }
    g_132 = ((uint16_t)65531UL >> (uint16_t)14);
    l_310 &= g_132;
    g_132 |= ((int32_t)(((~__builtin_ffsll(g_166)) != ((((int16_t)(((((uint16_t)((((((uint16_t)(l_294 & 0UL) % (uint16_t)l_310) <= ((uint16_t)(((uint32_t)l_294 / (uint32_t)(p_76 | ((int16_t)((int16_t)((uint16_t)p_75 / (uint16_t)p_77.f0) + (int16_t)0UL) / (int16_t)0x526AL))) != 0xFE8ED7BAL) >> (uint16_t)p_75)) | 0x41C1L) ^ g_168) < 65535UL) + (uint16_t)0x6956L) & l_294) <= p_78) <= p_76) << (int16_t)8) ^ p_75) != (-9L))) == p_76) % (int32_t)g_171);
    return g_164;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_30 g_132 g_159 g_178 g_168 g_164 g_172 g_171 g_167 g_163 g_166
 * writes: g_132 g_159 g_178 g_30 g_172 g_235
 */
static uint16_t  func_83(int32_t  p_84, const uint32_t  p_85, uint16_t  p_86)
{ /* block id: 39 */
    const uint16_t l_87 = 0x4C7CL;
    uint32_t l_251 = 0UL;
    uint32_t l_252 = 0x42C4FA89L;
    uint16_t l_272 = 0x9119L;
    int8_t l_273 = 0x20L;
    uint16_t l_274 = 65535UL;
    l_252 = (0x75BBL & (l_87 || (((int16_t)((uint16_t)(func_92(func_95(l_87, ((int32_t)((uint16_t)p_85 + (uint16_t)((((uint16_t)((((7L && p_86) == p_85) < (((int32_t)func_109(g_5) + (int32_t)g_5) || g_171)) >= g_168) + (uint16_t)g_168) == g_168) && l_87)) % (int32_t)6L), p_85, l_87, l_87), g_168) < 0x8E196A49L) << (uint16_t)p_85) % (int16_t)l_251) <= g_168)));
    g_132 = (-3L);
    l_274 = ((int16_t)g_172 / (int16_t)(((uint16_t)((0x0F2ED5B9L < (l_252 & (g_172 > ((p_85 == ((((uint16_t)p_84 + (uint16_t)(!p_84)) < ((uint32_t)((int16_t)(g_164 ^ ((((int16_t)((uint32_t)(((int32_t)g_168 / (int32_t)(-6L)) < 0xBF5BA501L) / (uint32_t)p_84) - (int16_t)l_87) ^ p_85) >= p_85)) / (int16_t)g_30) % (uint32_t)3UL)) <= l_272)) >= 6UL)))) == (-1L)) >> (uint16_t)l_273) & p_85));
    for (g_132 = 0; (g_132 <= 28); g_132 += 4)
    { /* block id: 98 */
        int16_t l_277 = 0x027BL;
        int8_t l_279 = 1L;
        p_84 = l_274;
        if (l_277)
        { /* block id: 100 */
            p_84 = (((p_85 > ((l_277 < p_85) < 0xD3BFD25BL)) != ((-(int16_t)(g_168 & (p_84 || l_279))) ^ (((uint16_t)p_84 + (uint16_t)(func_92(p_85, g_132) < g_167)) == g_172))) & l_277);
            return l_279;
        }
        else
        { /* block id: 103 */
            return l_274;
        }
    }
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads : g_171
 * writes:
 */
inline static int32_t  func_92(uint32_t  p_93, int32_t  p_94)
{ /* block id: 91 */
    return g_171;
}


/* ------------------------------------------ */
/* 
 * reads : g_172 g_164 g_168 g_30 g_167 g_163 g_166 g_5 g_132 g_159 g_178
 * writes: g_172 g_132 g_159 g_178 g_30 g_235
 */
static uint32_t  func_95(uint32_t  p_96, uint32_t  p_97, int16_t  p_98, int32_t  p_99, int8_t  p_100)
{ /* block id: 73 */
    uint16_t l_215 = 65527UL;
    int32_t l_216 = (-3L);
    uint16_t l_226 = 0x757AL;
    uint16_t l_246 = 0x37B3L;
    for (g_172 = 13; (g_172 <= (-1)); g_172 -= 4)
    { /* block id: 76 */
        uint32_t l_203 = 0x15DA6A52L;
        int32_t l_227 = 0xE146C4C1L;
        uint32_t l_238 = 0x33F8FB61L;
        ++l_203;
        if ((g_172 && (__builtin_bswap32(((((int16_t)g_164 / (int16_t)__builtin_ia32_crc32qi(p_99, (((uint16_t)((0x0F5FL && g_168) > (((int16_t)l_203 - (int16_t)(~((int16_t)l_215 + (int16_t)l_203))) != (0x2621F027L | p_97))) + (uint16_t)l_215) | g_30))) == g_167) < p_97)) && p_98)))
        { /* block id: 78 */
            uint32_t l_223 = 3UL;
            l_216 = (-1L);
            l_226 = ((int16_t)((int16_t)((g_163 <= l_203) || ((uint16_t)l_223 >> (uint16_t)4)) + (int16_t)(((uint16_t)65535UL + (uint16_t)g_166) && (g_167 || l_216))) % (int16_t)l_215);
            l_227 = p_98;
        }
        else
        { /* block id: 82 */
            int16_t l_229 = 0x5012L;
            l_227 = ((0x2475L & ((l_227 < l_216) | ((1UL ^ (((~p_96) >= (((-8L) ^ l_229) <= ((uint16_t)g_172 << (uint16_t)p_97))) || p_96)) & g_30))) & p_97);
        }
        g_235 = ((-(uint32_t)0xDA6F0B9CL) > (func_109(l_227) >= ((uint16_t)p_99 >> (uint16_t)1)));
        l_216 = ((uint16_t)((func_109(p_96) | p_96) >= l_238) + (uint16_t)(((l_215 && ((((uint16_t)g_167 + (uint16_t)(!(((int16_t)((uint16_t)(p_98 ^ (0xE9DFL || (p_99 ^ 65535UL))) >> (uint16_t)g_5) << (int16_t)8) != 1UL))) >= l_246) & p_100)) == l_216) >= p_96));
    }
    l_216 = ((((int16_t)((int16_t)(l_216 <= p_98) >> (int16_t)10) + (int16_t)func_109(l_215)) | l_216) & p_96);
    l_216 = 3L;
    return l_246;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_30 g_132 g_159 g_178 g_168 g_164 g_172
 * writes: g_132 g_159 g_178 g_30
 */
inline static int32_t  func_109(uint32_t  p_110)
{ /* block id: 40 */
    int32_t l_111 = (-1L);
    uint16_t l_112 = 0x8A80L;
    int32_t l_113 = 6L;
    int32_t l_162 = 0xFD407823L;
    int32_t l_165 = 1L;
    int32_t l_169 = (-1L);
    if (l_111)
    { /* block id: 41 */
        uint16_t l_131 = 0xE23FL;
        int32_t l_151 = 0x66C25309L;
        int32_t l_153 = 0xBE6A82D7L;
        int32_t l_158 = 0xE0669094L;
        int32_t l_173 = 0x253E6AFDL;
        int32_t l_174 = 1L;
        int32_t l_175 = 0xC5B336EBL;
        l_113 &= l_112;
        g_132 = ((uint16_t)((int32_t)p_110 / (int32_t)0x2882C653L) >> (uint16_t)(p_110 == ((uint16_t)((uint32_t)(p_110 | ((uint16_t)((uint16_t)0xFCFBL << (uint16_t)15) >> (uint16_t)g_5)) - (uint32_t)(((int32_t)((int16_t)(!(l_131 ^ (l_113 > 7UL))) >> (int16_t)11) + (int32_t)0x0CF10AA6L) > g_30)) >> (uint16_t)0)));
        g_132 = (g_132 & (((int16_t)((uint16_t)(g_30 ^ g_30) - (uint16_t)l_131) % (int16_t)l_113) ^ (0xFB31L || l_112)));
        if (((int16_t)p_110 >> (int16_t)0))
        { /* block id: 45 */
            uint16_t l_149 = 65531UL;
            int32_t l_150 = (-1L);
            int32_t l_152 = 4L;
            int32_t l_154 = 0x6947F708L;
            int32_t l_155 = (-1L);
            int32_t l_156 = 0x991B7FB1L;
            int32_t l_157 = (-1L);
            int32_t l_170 = (-2L);
            int32_t l_176 = 0x6BE4B227L;
            int32_t l_177 = 2L;
            if (((int16_t)((uint16_t)g_132 + (uint16_t)65531UL) / (int16_t)((int32_t)(0x403EC6B4L != g_5) + (int32_t)(p_110 >= l_111))))
            { /* block id: 46 */
                int32_t l_145 = (-7L);
                uint32_t l_146 = 0xFE3D0790L;
                g_132 |= (5L < __builtin_parityll(l_145));
                g_132 = 0x004931B7L;
                ++l_146;
                l_149 |= 0x6E4AE471L;
            }
            else
            { /* block id: 51 */
                g_159--;
            }
            ++g_178;
            l_154 = ((((0x785EL ^ (l_158 || ((uint16_t)((uint32_t)(((uint32_t)l_151 / (uint32_t)l_154) == l_174) - (uint32_t)((uint16_t)(__builtin_ffsl(l_112) < g_168) - (uint16_t)((g_164 ^ 0UL) | l_111))) << (uint16_t)4))) == g_168) | 65530UL) < l_174);
        }
        else
        { /* block id: 56 */
            g_132 = 0xA635A0DCL;
        }
    }
    else
    { /* block id: 59 */
        uint16_t l_189 = 0x7F2DL;
        int32_t l_200 = 0x86465E51L;
        g_132 ^= (g_168 >= 2L);
        l_189--;
        for (g_30 = 26; (g_30 >= 49); g_30 += 7)
        { /* block id: 64 */
            g_132 = ((int16_t)((uint16_t)g_132 - (uint16_t)1UL) - (int16_t)((int16_t)8L % (int16_t)g_172));
            l_200 = 0xBE68C9B4L;
            if (p_110)
                break;
            l_200 = l_169;
        }
        l_165 ^= __builtin_ctzll(p_110);
    }
    return g_159;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_30, "g_30", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_159, "g_159", print_hash_value);
    transparent_crc(g_163, "g_163", print_hash_value);
    transparent_crc(g_164, "g_164", print_hash_value);
    transparent_crc(g_166, "g_166", print_hash_value);
    transparent_crc(g_167, "g_167", print_hash_value);
    transparent_crc(g_168, "g_168", print_hash_value);
    transparent_crc(g_171, "g_171", print_hash_value);
    transparent_crc(g_172, "g_172", print_hash_value);
    transparent_crc(g_178, "g_178", print_hash_value);
    transparent_crc(g_235, "g_235", print_hash_value);
    transparent_crc(g_283.f0, "g_283.f0", print_hash_value);
    transparent_crc(g_309, "g_309", print_hash_value);
    transparent_crc(g_340, "g_340", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 87
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 55
breakdown:
   depth: 1, occurrence: 88
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 2
   depth: 17, occurrence: 2
   depth: 22, occurrence: 3
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 55, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 279
XXX times a non-volatile is write: 52
XXX times a volatile is read: 12
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 58
XXX percentage of non-volatile access: 96.2

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 73
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 20
   depth: 2, occurrence: 15
   depth: 3, occurrence: 5

XXX percentage a fresh-made variable is used: 23.1
XXX percentage an existing variable is used: 76.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

