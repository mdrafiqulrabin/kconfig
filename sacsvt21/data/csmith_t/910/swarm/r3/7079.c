/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      435533548
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   int64_t  f1;
   uint16_t  f2;
   int32_t  f3;
   uint64_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_34(void);
static uint16_t  func_41(float  p_42);
static struct S0 * func_47(float  p_48, uint64_t  p_49, uint32_t  p_50, struct S0 * p_51, struct S0 * p_52);
inline static struct S0 * func_55(int64_t  p_56);
static struct S0 ** func_62(int64_t  p_63, int32_t  p_64, int32_t * p_65);
inline static int32_t * func_68(uint32_t  p_69, struct S0 ** p_70, uint16_t  p_71, int32_t * p_72);
static struct S0 ** func_73(int8_t  p_74, struct S0 ** p_75, struct S0 * p_76);
static uint64_t  func_83(float  p_84, int32_t * p_85);
static int32_t * func_86(int32_t * p_87, int16_t  p_88, int32_t * p_89, struct S0 ** p_90);
inline static int32_t * func_91(uint16_t  p_92, struct S0 ** p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_34(void)
{ /* block id: 36 */
    uint64_t l_35 = 0x17AB6DAD816F93BDLL;
    int64_t l_821 = 0L;
    struct S0 ***l_822 = (void*)0;
    uint32_t l_823 = 0x1370E1E1L;
    int32_t l_824 = 0L;
    int32_t *l_827 = (void*)0;
    l_824 = (l_35 <= ((~(safe_div_func_int64_t_s_s(0x9E3D3B0CF5AA05D7LL, 0x70E7AD53A38D0672LL))) >= ((1L & 0xDEC995F7L) ^ ((safe_add_func_uint16_t_u_u((((func_41(l_35) > (l_821 && ((l_822 == (void*)0) <= l_823))) != l_823) != l_823), l_821)) > 0x022F84A9L))));
    for (l_821 = 11; (l_821 == (-19)); l_821 = safe_sub_func_uint32_t_u_u(l_821, 2))
    { /* block id: 469 */
        int32_t *l_828 = (void*)0;
        int32_t **l_829 = &l_827;
        l_827 = &l_824;
        /* statement id: 470 */
        assert (l_827 == &l_824);
        (*l_829) = l_828;
        /* statement id: 471 */
        assert (l_827 == 0);
    }
    return l_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_41(float  p_42)
{ /* block id: 37 */
    int32_t l_43 = 0L;
    int32_t *l_44 = (void*)0;
    int32_t l_46 = 0L;
    int32_t *l_45 = &l_46;
    struct S0 l_54 = {0x91F1L,-8L,0xF953L,0xDEFCECB2L,0xC6F0D4A7C769867FLL};
    struct S0 *l_53 = &l_54;
    struct S0 **l_819 = &l_53;
    int32_t l_820 = 0x83BA73F4L;
    (*l_45) = l_43;
    (*l_819) = func_47(((void*)0 == l_53), (*l_45), (((void*)0 == &l_54) >= (*l_45)), func_55((*l_45)), func_55((((__builtin_clzll(func_83(p_42, &l_46)) & 0x7BCCL) > (*l_45)) != 4294967288UL)));
    /* statement id: 464 */
    assert (l_53 == 0);
    return l_820;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_47(float  p_48, uint64_t  p_49, uint32_t  p_50, struct S0 * p_51, struct S0 * p_52)
{ /* block id: 461 */
    int32_t *l_814 = (void*)0;
    int32_t **l_815 = (void*)0;
    int32_t **l_816 = (void*)0;
    int32_t **l_817 = &l_814;
    struct S0 *l_818 = (void*)0;
    (*l_817) = l_814;
    return l_818;
    /* statement id: 463 */
    //assert (func_47_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_55(int64_t  p_56)
{ /* block id: 39 */
    uint32_t l_66 = 0x547A0585L;
    int32_t *l_499 = (void*)0;
    struct S0 **l_503 = (void*)0;
    float l_514 = 0x8.086D09p-6;
    float *l_513 = &l_514;
    float **l_512 = &l_513;
    float ***l_511 = &l_512;
    float ****l_510 = &l_511;
    struct S0 l_539 = {0x0BAEL,1L,0UL,0xAA53490FL,0UL};
    struct S0 *l_538 = &l_539;
    struct S0 *l_543 = &l_539;
    struct S0 *l_554 = &l_539;
    struct S0 *l_556 = &l_539;
    struct S0 *l_559 = &l_539;
    struct S0 *l_564 = &l_539;
    int32_t **l_588 = &l_499;
    int32_t ***l_587 = &l_588;
    int32_t ****l_586 = &l_587;
    struct S0 *l_620 = &l_539;
    struct S0 *l_621 = &l_539;
    struct S0 *l_643 = &l_539;
    struct S0 *l_649 = &l_539;
    struct S0 *l_650 = &l_539;
    int32_t l_671 = 0x5FB3C2A4L;
    int64_t l_683 = 0x88CB7945341E6EC3LL;
    struct S0 *l_688 = &l_539;
    struct S0 *l_690 = &l_539;
    struct S0 *l_782 = &l_539;
    int32_t l_786 = 0x8AD2AC95L;
    int32_t *l_807 = &l_671;
    struct S0 *l_811 = &l_539;
    struct S0 *l_812 = &l_539;
    struct S0 *l_813 = (void*)0;
    for (p_56 = 0; (p_56 != 13); p_56 = safe_add_func_int32_t_s_s(p_56, 1))
    { /* block id: 42 */
        int8_t l_60 = 0xB2L;
        int32_t *l_190 = (void*)0;
        struct S0 l_507 = {0xB9D1L,0x83289688EA05A778LL,0x1DCCL,0x8D195F23L,18446744073709551615UL};
        struct S0 *l_506 = &l_507;
        struct S0 **l_505 = &l_506;
        int32_t l_515 = 0x50A13648L;
        uint32_t l_536 = 4294967295UL;
        struct S0 *l_542 = &l_507;
        struct S0 *l_560 = &l_507;
        struct S0 *l_562 = &l_539;
        struct S0 *l_566 = &l_507;
        struct S0 *l_568 = (void*)0;
        uint32_t l_603 = 4294967293UL;
        struct S0 *l_618 = &l_539;
        struct S0 *l_622 = &l_507;
        struct S0 *l_623 = (void*)0;
        struct S0 *l_642 = &l_539;
        struct S0 *l_648 = &l_507;
        float ***l_658 = (void*)0;
        struct S0 *l_689 = &l_539;
        int32_t *l_716 = (void*)0;
        int32_t ****l_746 = &l_587;
        struct S0 *l_783 = &l_539;
        struct S0 *l_785 = (void*)0;
        int16_t l_797 = 7L;
        if ((!l_60))
        { /* block id: 43 */
            int8_t l_67 = 0xD1L;
            struct S0 l_98 = {-8L,0x1DC0BF288841F9F8LL,3UL,0xBC31B53AL,0xAD41D66485393F1BLL};
            struct S0 *l_97 = &l_98;
            struct S0 **l_96 = &l_97;
            float **l_494 = (void*)0;
            float ***l_493 = &l_494;
            float ****l_492 = &l_493;
            float *****l_491 = &l_492;
            int32_t **l_502 = (void*)0;
            int32_t l_518 = 0x413DF532L;
            struct S0 *l_541 = &l_507;
            struct S0 *l_545 = &l_507;
            struct S0 *l_553 = &l_98;
            struct S0 *l_565 = &l_507;
            struct S0 *l_641 = &l_507;
            struct S0 *l_644 = &l_539;
            struct S0 *l_645 = &l_507;
            struct S0 *l_646 = &l_98;
            struct S0 *l_647 = &l_539;
            struct S0 *l_651 = (void*)0;
            struct S0 *l_667 = &l_98;
            if (p_56)
            { /* block id: 44 */
                uint32_t l_61 = 4294967295UL;
                struct S0 **l_191 = &l_97;
                int32_t *l_478 = (void*)0;
                float *l_496 = (void*)0;
                float **l_495 = &l_496;
                float ****l_521 = &l_511;
                struct S0 *l_548 = &l_539;
                struct S0 *l_551 = &l_539;
                struct S0 *l_555 = &l_539;
                struct S0 *l_558 = &l_98;
                if (__builtin_popcount(l_61))
                { /* block id: 45 */
                    struct S0 l_383 = {-8L,0x7E7D97D7729DA96ALL,0UL,0xBEE4B267L,0x1B0A4C5BDC9EAAF2LL};
                    struct S0 *l_382 = &l_383;
                    struct S0 ***l_490 = &l_191;
                    (*l_490) = func_62(l_66, l_67, func_68(p_56, func_73(((safe_mul_func_uint16_t_u_u((1L != (safe_mul_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(((func_83(p_56, func_86(func_91((safe_lshift_func_int16_t_s_u(l_67, 10)), l_96), l_66, l_190, l_191)) ^ l_66) >= 0x3CDEL), 7)), p_56))), p_56)) == l_66), &l_97, l_382), p_56, l_478));
                    /* statement id: 288 */
                    assert (l_97 == 0 || l_97 == &l_98);
                    assert (l_191 == 0);
                }
                else
                { /* block id: 289 */
                    int64_t l_504 = (-1L);
                    struct S0 *l_508 = &l_98;
                    int32_t **l_509 = &l_478;
                    l_491 = l_491;
                    l_495 = l_495;
                    (*l_509) = l_478;
                }
                /* facts after branching */
                assert (l_97 == 0 || l_97 == &l_98);
                assert (l_191 == &l_97 || l_191 == 0);
                if (__builtin_ffsl(p_56))
                { /* block id: 294 */
                    float *****l_520 = &l_510;
                    uint16_t l_524 = 0x0919L;
                    struct S0 **l_529 = &l_97;
                    int32_t l_532 = 1L;
                    l_515 = ((void*)0 != l_510);
                    if ((p_56 <= func_83(p_56, l_496)))
                    { /* block id: 296 */
                        int64_t l_519 = 0xE2882098F8947E93LL;
                        l_518 = (safe_add_func_int32_t_s_s(p_56, (p_56 | 0xE6E4L)));
                        if (l_519)
                            break;
                        l_491 = l_520;
                        /* statement id: 299 */
                        assert (l_491 == &l_510);
                        (*l_520) = l_521;
                    }
                    else
                    { /* block id: 301 */
                        uint16_t l_522 = 2UL;
                        int32_t l_523 = 0x630AA088L;
                        (*l_513) = __builtin_popcountll(__builtin_clzll(func_83(p_56, l_496)));
                        if (l_67)
                            continue;
                        l_523 = l_522;
                        (*****l_520) = (l_524 == (func_83((safe_add_func_float_f_f(((p_56 >= (safe_add_func_float_f_f(l_523, ((*l_96) != (void*)0)))) < p_56), l_524)), &l_515) >= l_524));
                    }
                    /* facts after branching */
                    assert (l_491 == &l_492 || l_491 == &l_510);
                    if ((&l_96 != &l_191))
                    { /* block id: 307 */
                        float ****l_535 = &l_511;
                        if (p_56)
                            break;
                        l_532 = (safe_add_func_uint64_t_u_u(l_518, (0UL <= p_56)));
                        (***l_511) = (safe_mul_func_float_f_f(((0x6.AB81B0p+1 > ((void*)0 != l_535)) >= p_56), l_536));
                    }
                    else
                    { /* block id: 311 */
                        if (p_56)
                            break;
                    }
                    (****l_510) = p_56;
                }
                else
                { /* block id: 315 */
                    struct S0 *l_537 = &l_98;
                    struct S0 *l_540 = &l_507;
                    struct S0 *l_544 = &l_539;
                    struct S0 *l_546 = &l_98;
                    struct S0 *l_547 = &l_539;
                    struct S0 *l_549 = &l_98;
                    struct S0 *l_550 = &l_507;
                    struct S0 *l_552 = &l_98;
                    struct S0 *l_557 = &l_507;
                    struct S0 *l_561 = &l_539;
                    struct S0 *l_563 = &l_507;
                    struct S0 *l_567 = &l_507;
                    return l_568;
                    /* statement id: 316 */
                    //assert (func_55_rv == 0);
                }
                /* facts after branching */
                assert (l_491 == &l_492 || l_491 == &l_510);
            }
            else
            { /* block id: 318 */
                int8_t l_573 = (-6L);
                struct S0 *l_578 = &l_507;
                if (((safe_lshift_func_int16_t_s_s((safe_div_func_int32_t_s_s(l_573, (p_56 ^ 0xF0EA836DL))), (safe_mod_func_int16_t_s_s(l_573, __builtin_clzl(p_56))))) < 6L))
                { /* block id: 319 */
                    int32_t ***l_576 = &l_502;
                    int32_t ****l_577 = &l_576;
                    struct S0 *l_579 = (void*)0;
                    (*l_577) = l_576;
                    return l_579;
                    /* statement id: 321 */
                    //assert (func_55_rv == 0);
                }
                else
                { /* block id: 322 */
                    int32_t *l_580 = &l_515;
                    int32_t **l_581 = &l_580;
                    (*l_581) = l_580;
                }
                (*l_578) = (*l_578);
            }
            /* facts after branching */
            assert (l_97 == 0 || l_97 == &l_98);
            assert (l_491 == &l_492 || l_491 == &l_510);
            if (((safe_add_func_int32_t_s_s((safe_div_func_int64_t_s_s((-1L), func_83(p_56, l_513))), (p_56 ^ __builtin_bswap64((((void*)0 == l_586) < (&l_505 == (void*)0)))))) >= p_56))
            { /* block id: 327 */
                uint32_t l_614 = 0x466806CDL;
                int32_t *l_615 = &l_518;
                struct S0 *l_617 = &l_539;
                if (((safe_mul_func_uint16_t_u_u((18446744073709551615UL ^ p_56), (p_56 > (!(((-4L) <= (p_56 && 6UL)) > (safe_div_func_int32_t_s_s(((0x1D343A2DC479FAC9LL < ((p_56 && __builtin_parity((((void*)0 == (*l_510)) != l_507.f4))) > 9UL)) != p_56), p_56))))))) ^ 0x2B8C5BE1L))
                { /* block id: 328 */
                    float l_594 = 0xD.64A99Cp+10;
                    float **l_606 = (void*)0;
                    struct S0 **l_609 = &l_542;
                    struct S0 *l_619 = &l_539;
                    if (((p_56 < (safe_mod_func_uint64_t_u_u(((safe_mod_func_int64_t_s_s(__builtin_popcount((safe_lshift_func_int16_t_s_s(((p_56 == (func_83(func_83(((safe_sub_func_float_f_f((__builtin_popcount(l_603) <= (safe_sub_func_float_f_f(((((void*)0 == l_606) < (safe_div_func_float_f_f((l_609 != (void*)0), (safe_sub_func_float_f_f((safe_div_func_float_f_f(0xC.253970p+22, p_56)), p_56))))) < p_56), p_56))), l_614)) <= p_56), &l_515), l_615) < p_56)) && p_56), 7))), 0x5677C2B82F8239DCLL)) & p_56), 0x8B246863FD92401ALL))) > p_56))
                    { /* block id: 329 */
                        struct S0 *l_616 = &l_507;
                        return l_623;
                        /* statement id: 330 */
                        //assert (func_55_rv == 0);
                    }
                    else
                    { /* block id: 331 */
                        int32_t *l_629 = &l_515;
                        (***l_586) = func_68(p_56, &l_619, (*l_615), &l_515);
                        /* statement id: 332 */
                        assert (l_499 == &l_515);
                        (*l_499) = (safe_mod_func_int32_t_s_s(p_56, (safe_sub_func_int16_t_s_s((p_56 ^ (!p_56)), (***l_587)))));
                        (***l_586) = l_629;
                    }
                    /* facts after branching */
                    assert (l_499 == &l_515);
                    (****l_586) = (func_83((*l_615), l_615) == (safe_mod_func_int64_t_s_s((****l_586), p_56)));
                    for (l_98.f4 = 0; (l_98.f4 == 51); l_98.f4++)
                    { /* block id: 339 */
                        int32_t *l_634 = (void*)0;
                        struct S0 *l_635 = &l_539;
                        (***l_586) = l_634;
                        /* statement id: 340 */
                        assert (l_499 == 0);
                        l_635 = l_617;
                    }
                    /* facts after for loop */
                    assert (l_499 == 0 || l_499 == &l_515);
                }
                else
                { /* block id: 343 */
                    float **l_637 = &l_513;
                    (**l_587) = &l_515;
                    /* statement id: 344 */
                    assert (l_499 == &l_515);
                    if ((*l_615))
                    { /* block id: 345 */
                        struct S0 l_636 = {0x94D6L,7L,65535UL,0xE89EDA9AL,0x46A753CD6C4EFCDELL};
                        (**l_587) = l_615;
                        /* statement id: 346 */
                        assert (l_499 == &l_518);
                        if ((***l_587))
                            continue;
                        //assert (l_499 == dangling);
                        if ((****l_586))
                            break;
                        //assert (l_499 == dangling);
                        (*l_564) = l_636;
                    }
                    else
                    { /* block id: 350 */
                        (**l_492) = l_637;
                        /* statement id: 351 */
                        assert (l_494 == &l_513);
                    }
                    /* facts after branching */
                    assert (l_494 == &l_513 || l_494 == 0);
                    assert (l_499 == &l_515 || l_499 == &l_518);
                    (**l_587) = (***l_586);
                }
                /* facts after branching */
                assert (l_494 == &l_513 || l_494 == 0);
                assert (l_499 == &l_515 || l_499 == &l_518 || l_499 == 0);
                (*l_615) = p_56;
            }
            else
            { /* block id: 356 */
                struct S0 *l_638 = &l_507;
                struct S0 *l_639 = &l_98;
                struct S0 *l_640 = &l_539;
                return l_651;
                /* statement id: 357 */
                //assert (func_55_rv == 0);
            }
            /* facts after branching */
            assert (l_494 == &l_513 || l_494 == 0);
            assert (l_499 == &l_515 || l_499 == &l_518 || l_499 == 0);
            if (p_56)
            { /* block id: 359 */
                struct S0 l_654 = {5L,0L,3UL,6L,1UL};
                float ***l_659 = &l_494;
                struct S0 ***l_666 = &l_505;
                struct S0 ****l_665 = &l_666;
                for (l_536 = (-28); (l_536 < 15); l_536++)
                { /* block id: 362 */
                    int32_t l_655 = 0x741067DAL;
                    struct S0 *l_668 = &l_654;
                    (*l_588) = (void*)0;
                    /* statement id: 363 */
                    assert (l_499 == 0);
                    (*l_562) = l_654;
                    (****l_510) = l_655;
                    if ((safe_sub_func_int64_t_s_s(p_56, (p_56 <= ((l_658 != l_659) == ((safe_div_func_int16_t_s_s((((__builtin_popcount(p_56) | (safe_rshift_func_uint16_t_u_s(func_83(func_83(p_56, (*l_588)), &l_515), p_56))) && p_56) && p_56), l_655)) & 0xFECDL))))))
                    { /* block id: 366 */
                        struct S0 ****l_664 = (void*)0;
                        l_665 = l_664;
                        /* statement id: 367 */
                        assert (l_665 == 0);
                    }
                    else
                    { /* block id: 368 */
                        struct S0 *l_669 = (void*)0;
                        return l_669;
                        /* statement id: 369 */
                        //assert (func_55_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_665 == 0);
                }
                /* facts after for loop */
                assert (l_665 == 0 || l_665 == &l_666);
                (**l_587) = (***l_586);
            }
            else
            { /* block id: 373 */
                int32_t *l_670 = &l_515;
                (**l_587) = l_670;
                /* statement id: 374 */
                assert (l_499 == &l_515);
            }
        }
        else
        { /* block id: 376 */
            struct S0 *l_672 = &l_507;
            struct S0 *l_673 = (void*)0;
            (*l_588) = func_91(l_671, &l_643);
            /* statement id: 377 */
            assert (l_499 == 0);
            return l_673;
            /* statement id: 378 */
            //assert (func_55_rv == 0);
        }
        /* facts after branching */
        //assert (l_499 == &l_515 || l_499 == dangling || l_499 == 0);
        if ((((safe_rshift_func_int16_t_s_u((!(((safe_add_func_uint32_t_u_u((__builtin_clz(p_56) < p_56), (((p_56 && (((safe_mul_func_uint16_t_u_u(((void*)0 == &l_510), __builtin_clzll(p_56))) && (safe_mod_func_uint32_t_u_u(l_683, p_56))) && p_56)) <= p_56) != p_56))) | 0xEE6556627892624ELL) & p_56)), l_536)) || l_603) | 0x90EEA8E05967D65ALL))
        { /* block id: 380 */
            struct S0 *l_687 = &l_539;
            for (l_539.f0 = 0; (l_539.f0 <= 14); ++l_539.f0)
            { /* block id: 383 */
                struct S0 *l_686 = &l_507;
                struct S0 *l_691 = (void*)0;
                return l_691;
                /* statement id: 384 */
                //assert (func_55_rv == 0);
            }
        }
        else
        { /* block id: 386 */
            int32_t *l_696 = &l_671;
            struct S0 *l_731 = &l_539;
            int32_t ****l_747 = &l_587;
            for (l_507.f2 = 0; (l_507.f2 == 2); l_507.f2++)
            { /* block id: 389 */
                float l_709 = (-0x1.Dp-1);
                float **l_711 = &l_513;
                int32_t l_712 = (-1L);
                float l_713 = 0x1.Ap+1;
                for (l_60 = 0; (l_60 > (-7)); l_60 = safe_sub_func_int32_t_s_s(l_60, 1))
                { /* block id: 392 */
                    int16_t l_710 = 1L;
                    struct S0 **l_714 = &l_506;
                    int32_t ****l_724 = &l_587;
                    (*l_588) = l_696;
                    /* statement id: 393 */
                    assert (l_499 == &l_671);
                    if (p_56)
                        break;
                    if ((safe_mul_func_uint16_t_u_u(__builtin_ffsl((*l_696)), (safe_mul_func_uint16_t_u_u((safe_mod_func_int64_t_s_s(((safe_div_func_int32_t_s_s((safe_sub_func_int64_t_s_s((p_56 <= (-9L)), (safe_rshift_func_uint16_t_u_u(l_710, 5)))), __builtin_ffsl(((((l_710 == ((void*)0 == l_711)) || ((((*l_696) >= 0x244C1E1BL) < 0xCB401ACFA66510CDLL) || p_56)) == l_712) >= p_56)))) | l_712), 18446744073709551615UL)), (-2L))))))
                    { /* block id: 395 */
                        int32_t *l_715 = &l_671;
                        if ((*l_696))
                            break;
                        (***l_586) = l_715;
                        (*l_588) = &l_515;
                        /* statement id: 398 */
                        assert (l_499 == &l_515);
                        (**l_587) = l_716;
                        /* statement id: 399 */
                        assert (l_499 == 0);
                    }
                    else
                    { /* block id: 400 */
                        int32_t l_721 = 0x8BCFB729L;
                        uint64_t l_725 = 18446744073709551607UL;
                        (****l_724) = ((safe_mod_func_int64_t_s_s((safe_rshift_func_uint16_t_u_s(((4294967295UL && 0x9BD16E02L) > 0L), l_721)), (p_56 | (__builtin_clzll(((void*)0 != l_724)) == (&l_696 != &l_696))))) | l_725);
                        (**l_587) = (void*)0;
                        /* statement id: 402 */
                        assert (l_499 == 0);
                        if (l_725)
                            continue;
                    }
                    /* facts after branching */
                    assert (l_499 == 0);
                }
                (*l_588) = &l_712;
                /* statement id: 406 */
                assert (l_499 == &l_712);
                (**l_587) = l_696;
                /* statement id: 407 */
                assert (l_499 == &l_671);
            }
            /* facts after for loop */
            //assert (l_499 == &l_671 || l_499 == &l_515 || l_499 == dangling || l_499 == 0);
            for (l_539.f1 = 0; (l_539.f1 <= 4); l_539.f1++)
            { /* block id: 411 */
                struct S0 *l_730 = &l_539;
                (*l_696) = (*l_696);
                for (l_539.f3 = 0; (l_539.f3 <= 17); l_539.f3 = safe_add_func_uint32_t_u_u(l_539.f3, 2))
                { /* block id: 415 */
                    struct S0 *l_732 = (void*)0;
                    return l_732;
                    /* statement id: 416 */
                    //assert (func_55_rv == 0);
                }
            }
            (*l_696) = (__builtin_bswap64((safe_rshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((*l_696), (safe_mul_func_uint16_t_u_u(((safe_unary_minus_func_int64_t_s(p_56)) ^ (((-10L) | (func_83(((safe_div_func_float_f_f((p_56 >= 0xC.ECA2DBp-84), (safe_add_func_float_f_f((*l_696), (((l_746 == l_747) > func_83(p_56, &l_515)) >= p_56))))) < p_56), &l_515) <= p_56)) >= (*l_696))), (*l_696))))), 10))) || 1UL);
        }
        /* facts after branching */
        //assert (l_499 == &l_671 || l_499 == &l_515 || l_499 == dangling || l_499 == 0);
        for (l_507.f3 = 0; (l_507.f3 >= 10); l_507.f3++)
        { /* block id: 423 */
            int32_t l_773 = 0xBFE40A9AL;
            struct S0 **l_777 = &l_554;
            struct S0 *l_778 = &l_539;
            int32_t ***l_801 = (void*)0;
            int32_t *l_808 = &l_515;
            (*l_505) = &l_539;
            /* statement id: 424 */
            assert (l_506 == &l_539);
            for (l_507.f2 = 0; (l_507.f2 < 58); ++l_507.f2)
            { /* block id: 427 */
                int32_t *l_756 = (void*)0;
                struct S0 **l_776 = (void*)0;
                struct S0 *l_779 = &l_539;
                (*l_505) = (void*)0;
                /* statement id: 428 */
                assert (l_506 == 0);
                for (l_603 = (-28); (l_603 == 15); l_603++)
                { /* block id: 431 */
                    int32_t l_755 = 0xF708151EL;
                    float l_764 = (-0x6.7p-1);
                    int64_t l_774 = 0xF4E20D18AD95ED0ALL;
                    struct S0 *l_780 = &l_539;
                }
            }
            /* facts after for loop */
            assert (l_506 == 0 || l_506 == &l_539);
            l_808 = &l_515;
            for (l_773 = 12; (l_773 == (-2)); l_773 = safe_sub_func_int64_t_s_s(l_773, 3))
            { /* block id: 454 */
                (***l_746) = &l_515;
                /* statement id: 455 */
                assert (l_499 == &l_515);
                if ((***l_587))
                    continue;
            }
        }
        /* facts after for loop */
        assert (l_506 == 0 || l_506 == &l_539 || l_506 == &l_507);
    }
    /* facts after for loop */
    //assert (l_499 == &l_671 || l_499 == dangling || l_499 == 0);
    return l_813;
    /* statement id: 460 */
    //assert (func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 ** func_62(int64_t  p_63, int32_t  p_64, int32_t * p_65)
{ /* block id: 284 */
    int32_t l_485 = 4L;
    int32_t *l_484 = &l_485;
    int32_t **l_483 = &l_484;
    struct S0 l_488 = {0x01E4L,2L,65529UL,-1L,18446744073709551615UL};
    struct S0 *l_487 = &l_488;
    struct S0 **l_486 = &l_487;
    struct S0 **l_489 = (void*)0;
    (*l_483) = &p_64;
    /* statement id: 285 */
    assert (l_484 == &p_64);
    (*l_483) = func_68(p_63, l_486, p_64, &p_64);
    return l_489;
    /* statement id: 287 */
    //assert (func_62_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_68(uint32_t  p_69, struct S0 ** p_70, uint16_t  p_71, int32_t * p_72)
{ /* block id: 281 */
    struct S0 l_479 = {0xFCD3L,1L,1UL,9L,0xD4C1FB1C6D6E9268LL};
    struct S0 *l_480 = &l_479;
    int32_t l_482 = 0xF31F02A5L;
    int32_t *l_481 = &l_482;
    (*l_480) = l_479;
    return p_72;
    /* statement id: 283 */
    //assert (func_68_rv == 0 || func_68_rv == &p_64 || func_68_rv == &l_515 || func_68_rv == &l_671);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 ** func_73(int8_t  p_74, struct S0 ** p_75, struct S0 * p_76)
{ /* block id: 212 */
    float l_386 = 0xE.179D6Cp+94;
    float *l_385 = &l_386;
    float **l_384 = &l_385;
    int32_t l_387 = 0xDD93EADBL;
    int32_t *l_402 = &l_387;
    int32_t **l_401 = &l_402;
    int32_t ***l_400 = &l_401;
    struct S0 *l_404 = (void*)0;
    struct S0 **l_403 = &l_404;
    uint32_t l_408 = 4294967295UL;
    uint32_t l_457 = 4294967295UL;
    struct S0 **l_468 = (void*)0;
    uint16_t l_471 = 0x9D47L;
    int32_t *l_472 = &l_387;
    struct S0 **l_473 = &l_404;
    struct S0 **l_474 = &l_404;
    struct S0 **l_475 = &l_404;
    struct S0 **l_476 = &l_404;
    struct S0 **l_477 = (void*)0;
    l_387 = ((void*)0 == l_384);
    if ((safe_lshift_func_int16_t_s_u(func_83(((p_74 < p_74) < (safe_div_func_float_f_f(p_74, 0xF.3EDB0Bp-56))), &l_387), 5)))
    { /* block id: 214 */
        struct S0 l_392 = {0x3E02L,0L,0xD038L,0L,18446744073709551608UL};
        int32_t *l_394 = &l_387;
        int32_t **l_393 = &l_394;
        int64_t l_439 = 6L;
        float ***l_443 = &l_384;
        (*p_76) = l_392;
        (*l_393) = &l_387;
        if ((safe_mul_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(((*l_394) || ((safe_unary_minus_func_int32_t_s(0xB352B369L)) < 0x950CD63C0136F621LL)), (0x0D181D2BL != func_83(((l_400 != (void*)0) != 0x5.0E0FF5p-27), (*l_401))))), p_74)))
        { /* block id: 217 */
            struct S0 l_407 = {0xA8C3L,0xF78D322387CC2112LL,0xC3E5L,-1L,18446744073709551610UL};
            for (l_392.f0 = (-13); (l_392.f0 >= 14); l_392.f0 = safe_add_func_uint16_t_u_u(l_392.f0, 2))
            { /* block id: 220 */
                (**p_75) = l_407;
            }
            (**p_75) = l_407;
        }
        else
        { /* block id: 224 */
            (*l_402) = (*l_402);
        }
        if (l_408)
        { /* block id: 227 */
            int32_t *l_413 = (void*)0;
            struct S0 **l_440 = (void*)0;
            for (l_392.f4 = 0; (l_392.f4 > 9); ++l_392.f4)
            { /* block id: 230 */
                int32_t *l_426 = &l_387;
                (*l_393) = (*l_393);
                for (l_392.f0 = (-11); (l_392.f0 < 25); l_392.f0 = safe_add_func_int32_t_s_s(l_392.f0, 2))
                { /* block id: 234 */
                    int32_t *l_414 = &l_387;
                    (*l_393) = l_414;
                }
                if ((safe_mul_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(p_74, 9)), (***l_400))))
                { /* block id: 237 */
                    int8_t l_421 = 0x00L;
                    (***l_400) = func_83(p_74, l_426);
                    (*l_393) = (*l_393);
                    (*l_403) = (*p_75);
                    /* statement id: 240 */
                    //assert (l_404 == &l_98 || l_404 == &l_507 || l_404 == &l_539);
                    (*l_385) = p_74;
                }
                else
                { /* block id: 242 */
                    float ***l_429 = &l_384;
                    float ****l_428 = &l_429;
                    float *****l_427 = &l_428;
                    struct S0 l_430 = {4L,7L,1UL,-1L,18446744073709551609UL};
                    l_427 = l_427;
                    (**p_75) = l_430;
                    (*l_393) = (**l_400);
                }
                (**l_384) = (safe_sub_func_float_f_f((safe_add_func_float_f_f(__builtin_parityll((l_413 == l_413)), __builtin_parityll((safe_sub_func_uint32_t_u_u((**l_393), (p_74 || ((((p_74 ^ p_74) == p_74) >= (safe_lshift_func_uint16_t_u_u(__builtin_ctzl(p_74), (*l_426)))) & (*l_426)))))))), l_439));
            }
            /* facts after for loop */
            //assert (l_404 == 0 || l_404 == &l_98 || l_404 == &l_507 || l_404 == &l_539);
            return l_440;
            /* statement id: 249 */
            //assert (func_73_rv == 0);
        }
        else
        { /* block id: 250 */
            int8_t l_441 = 7L;
            float ***l_442 = &l_384;
            struct S0 **l_444 = &l_404;
            (*l_401) = (*l_393);
            for (l_392.f4 = (-4); (l_392.f4 != 42); l_392.f4 = safe_add_func_int16_t_s_s(l_392.f4, 2))
            { /* block id: 254 */
                int64_t l_447 = 0L;
                (**l_384) = ((-0x1.9p-1) != ((0x7.672A76p-81 >= l_447) <= p_74));
            }
        }
    }
    else
    { /* block id: 258 */
        uint32_t l_455 = 4294967291UL;
        int16_t l_456 = 1L;
        struct S0 **l_460 = &l_404;
        struct S0 l_464 = {-5L,0x75FA6749FE29DAE9LL,2UL,-1L,0x602CED354EF3FC44LL};
        for (l_408 = 0; (l_408 <= 45); l_408 = safe_add_func_int32_t_s_s(l_408, 3))
        { /* block id: 261 */
            struct S0 **l_458 = &l_404;
            struct S0 **l_459 = (void*)0;
            (*l_402) = (safe_mul_func_uint16_t_u_u((((safe_unary_minus_func_int32_t_s(__builtin_popcountll(((safe_sub_func_uint64_t_u_u(l_455, l_455)) || (l_455 >= (((void*)0 == &l_401) == l_456)))))) || ((0x51A9EF4CL <= l_455) | 4294967287UL)) >= (-3L)), l_457));
            return l_459;
            /* statement id: 263 */
            //assert (func_73_rv == 0);
        }
        if (p_74)
        { /* block id: 265 */
            struct S0 **l_461 = (void*)0;
            return l_461;
            /* statement id: 266 */
            //assert (func_73_rv == 0);
        }
        else
        { /* block id: 267 */
            int64_t l_465 = 0x5E85FD5CD2B4CA8ELL;
            struct S0 **l_467 = &l_404;
            for (l_455 = 0; (l_455 <= 49); l_455 = safe_add_func_int64_t_s_s(l_455, 2))
            { /* block id: 270 */
                int32_t *l_466 = &l_387;
                (*p_76) = l_464;
                (**l_400) = (void*)0;
                /* statement id: 272 */
                assert (l_402 == 0);
                (*l_466) = func_83(func_83(l_465, l_466), (**l_400));
            }
            /* facts after for loop */
            assert (l_402 == 0 || l_402 == &l_387);
            return l_468;
            /* statement id: 275 */
            //assert (func_73_rv == 0);
        }
    }
    (*p_75) = (void*)0;
    /* statement id: 278 */
    //assert (l_97 == 0);
    (*l_401) = (*l_401);
    return l_477;
    /* statement id: 280 */
    //assert (func_73_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_83(float  p_84, int32_t * p_85)
{ /* block id: 209 */
    int32_t l_381 = 0L;
    int32_t *l_380 = &l_381;
    l_380 = p_85;
    /* statement id: 210 */
    //assert (l_380 == 0 || l_380 == &l_387 || l_380 == &l_515 || l_380 == &l_514 || l_380 == &l_518 || l_380 == &l_773 || l_380 == &l_46);
    return l_381;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_86(int32_t * p_87, int16_t  p_88, int32_t * p_89, struct S0 ** p_90)
{ /* block id: 99 */
    struct S0 l_194 = {-2L,0x11968FDB46EF48D8LL,0x5F73L,0x16EBDA91L,0x5C0BBC23E960850BLL};
    struct S0 *l_193 = &l_194;
    struct S0 **l_192 = &l_193;
    struct S0 *l_263 = &l_194;
    int32_t **l_277 = (void*)0;
    int32_t l_378 = 3L;
    int32_t *l_377 = &l_378;
    int32_t *l_379 = &l_378;
    if (((l_192 == (void*)0) < 4294967292UL))
    { /* block id: 100 */
        float l_203 = 0x6.5p+1;
        int32_t l_215 = (-9L);
        int32_t **l_249 = (void*)0;
        float *l_301 = &l_203;
        float **l_300 = &l_301;
        (*l_192) = (void*)0;
        /* statement id: 101 */
        assert (l_193 == 0);
        for (l_194.f3 = (-20); (l_194.f3 <= 22); l_194.f3++)
        { /* block id: 104 */
            int32_t l_205 = (-2L);
            int32_t *l_204 = &l_205;
            int8_t l_226 = 0x8BL;
            struct S0 l_251 = {0x833BL,-1L,0x1CD5L,-3L,0xEC26253D0E69D747LL};
            float ***l_303 = (void*)0;
            (*l_204) = (0xF3958A3B0749740BLL != (safe_sub_func_uint32_t_u_u((0x38A45CE233F4ACB3LL <= ((safe_rshift_func_int16_t_s_u(1L, 14)) < ((p_88 ^ 0x73866EE0L) <= 0x88FC330AL))), 0UL)));
            if ((*l_204))
                continue;
        }
    }
    else
    { /* block id: 171 */
        uint16_t l_321 = 65531UL;
        float l_327 = 0x8.A238ECp+3;
        float *l_326 = &l_327;
        float **l_325 = &l_326;
        float ***l_324 = &l_325;
        float ****l_323 = &l_324;
        float *****l_322 = &l_323;
        struct S0 *l_363 = &l_194;
        for (l_194.f0 = 19; (l_194.f0 < (-12)); l_194.f0 = safe_sub_func_int64_t_s_s(l_194.f0, 1))
        { /* block id: 174 */
            float ***l_312 = (void*)0;
            float ****l_311 = &l_312;
            float *****l_310 = &l_311;
            int32_t ***l_315 = (void*)0;
            struct S0 *l_330 = &l_194;
            uint32_t l_331 = 0x2D6AA524L;
            l_310 = (void*)0;
            /* statement id: 175 */
            assert (l_310 == 0);
        }
        (**l_323) = (void*)0;
        /* statement id: 205 */
        assert (l_325 == 0);
    }
    /* facts after branching */
    assert (l_193 == &l_194 || l_193 == 0);
    (*l_263) = (**p_90);
    return p_89;
    /* statement id: 208 */
    //assert (func_86_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_97
 * writes: l_98
 */
inline static int32_t * func_91(uint16_t  p_92, struct S0 ** p_93)
{ /* block id: 46 */
    uint32_t l_103 = 0x298B2365L;
    struct S0 l_105 = {-6L,0L,0xEE7AL,0x41179D74L,0xF48B4F12B152D5F2LL};
    struct S0 *l_104 = &l_105;
    int32_t l_107 = 0x33A03155L;
    int32_t *l_106 = &l_107;
    int32_t *l_116 = &l_107;
    struct S0 **l_117 = &l_104;
    int32_t l_130 = (-1L);
    int8_t l_131 = 0xACL;
    int32_t *l_146 = &l_107;
    int32_t *l_150 = &l_107;
    int32_t *l_151 = &l_107;
    int32_t *l_155 = &l_107;
    int32_t *l_165 = &l_107;
    int32_t *l_185 = &l_107;
    int32_t *l_188 = (void*)0;
    int32_t *l_189 = (void*)0;
    for (p_92 = (-26); (p_92 < 44); p_92 = safe_add_func_int32_t_s_s(p_92, 6))
    { /* block id: 49 */
        int32_t *l_101 = (void*)0;
        int32_t l_102 = 0xC42121A6L;
        l_101 = l_101;
        if (l_102)
            continue;
    }
    (*l_106) = (__builtin_ctzll(l_103) | (l_104 != (void*)0));
    for (l_107 = 0; (l_107 >= 2); l_107++)
    { /* block id: 56 */
        int32_t l_114 = (-3L);
        for (l_103 = 27; (l_103 >= 48); l_103++)
        { /* block id: 59 */
            int16_t l_115 = 0x90C9L;
            l_115 = (safe_div_func_uint32_t_u_u(p_92, l_114));
        }
        l_106 = l_116;
    }
    if ((p_93 == l_117))
    { /* block id: 64 */
        int8_t l_120 = 0xF4L;
        struct S0 l_132 = {3L,1L,65535UL,0x15C7436FL,0x2B88B27CD67D5F25LL};
        int32_t *l_143 = &l_107;
        int32_t *l_147 = &l_107;
        int32_t *l_149 = &l_107;
        int32_t *l_152 = &l_107;
        int32_t *l_160 = &l_107;
        int32_t *l_167 = &l_107;
        int32_t *l_168 = &l_107;
        int32_t **l_182 = &l_146;
        for (l_105.f2 = 16; (l_105.f2 != 4); l_105.f2 = safe_sub_func_int16_t_s_s(l_105.f2, 2))
        { /* block id: 67 */
            int32_t *l_121 = &l_107;
            int32_t **l_122 = (void*)0;
            int32_t **l_123 = (void*)0;
            int32_t **l_124 = &l_106;
            uint32_t l_127 = 1UL;
            l_120 = p_92;
            (*l_124) = l_121;
            (*l_121) = ((safe_mul_func_uint16_t_u_u((((l_127 | (p_92 & (((safe_div_func_uint64_t_u_u(0x7EC325DF25B48F27LL, __builtin_ctz(p_92))) < (__builtin_parityll(p_92) & 0x61D2L)) | (l_130 == p_92)))) == p_92) > l_131), 0xDAACL)) | l_120);
        }
        (**p_93) = l_132;
        for (l_105.f2 = (-17); (l_105.f2 >= 11); l_105.f2++)
        { /* block id: 75 */
            struct S0 *l_137 = &l_105;
            int32_t *l_142 = &l_107;
            int32_t *l_144 = &l_107;
            int32_t *l_153 = &l_107;
            int32_t *l_154 = &l_107;
            int32_t *l_157 = &l_107;
            int32_t *l_161 = &l_107;
            int32_t *l_163 = &l_107;
            int32_t *l_164 = &l_107;
            int32_t *l_166 = &l_107;
            if (((safe_mul_func_uint16_t_u_u((((&l_132 == &l_132) & ((*l_117) == l_137)) | (*l_106)), (l_120 <= p_92))) | ((safe_add_func_uint32_t_u_u(0xB74EAE51L, p_92)) <= 9UL)))
            { /* block id: 76 */
                int32_t *l_140 = &l_107;
                int32_t **l_141 = &l_140;
                int32_t *l_145 = &l_107;
                int32_t *l_148 = &l_107;
                int32_t *l_156 = &l_107;
                int32_t *l_158 = &l_107;
                int32_t *l_159 = &l_107;
                int32_t *l_162 = &l_107;
                int32_t *l_169 = (void*)0;
                (*l_141) = l_140;
                return l_169;
                /* statement id: 78 */
                //assert (func_91_rv == 0);
            }
            else
            { /* block id: 79 */
                uint32_t l_181 = 3UL;
                if (((safe_mul_func_int16_t_s_s((*l_163), (&l_155 != (void*)0))) >= p_92))
                { /* block id: 80 */
                    int32_t l_178 = 0L;
                    for (l_120 = 0; (l_120 != 15); ++l_120)
                    { /* block id: 83 */
                        int32_t **l_174 = (void*)0;
                        int32_t **l_175 = &l_153;
                        (*l_157) = (p_92 & (l_168 == &l_107));
                        (*l_175) = l_157;
                        (*l_154) = (4294967295UL || ((p_92 != (safe_div_func_int32_t_s_s(l_178, (p_92 && (safe_add_func_uint16_t_u_u(((void*)0 != p_93), (p_92 != p_92))))))) | l_181));
                        (*l_175) = l_168;
                    }
                }
                else
                { /* block id: 89 */
                    (*l_146) = p_92;
                }
            }
        }
        (*l_182) = (void*)0;
        /* statement id: 94 */
        assert (l_146 == 0);
    }
    else
    { /* block id: 95 */
        int32_t *l_183 = &l_107;
        int32_t *l_184 = &l_107;
        int32_t *l_186 = &l_107;
        int32_t *l_187 = &l_107;
        return l_188;
        /* statement id: 96 */
        //assert (func_91_rv == 0);
    }
    /* facts after branching */
    assert (l_146 == 0);
    return l_189;
    /* statement id: 98 */
    //assert (func_91_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 315
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 222
   depth: 2, occurrence: 34
   depth: 3, occurrence: 7
   depth: 4, occurrence: 5
   depth: 5, occurrence: 6
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 27, occurrence: 2

XXX total number of pointers: 291

XXX times a variable address is taken: 289
XXX times a pointer is dereferenced on RHS: 70
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 10
   depth: 3, occurrence: 8
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 116
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 22
   depth: 3, occurrence: 10
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 1067

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 375
   level: 2, occurrence: 128
   level: 3, occurrence: 52
   level: 4, occurrence: 22
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 115
XXX number of pointers point to scalars: 92
XXX number of pointers point to structs: 84
XXX percent of pointers has null in alias set: 29.6
XXX average alias set size: 1.2

XXX times a non-volatile is read: 723
XXX times a non-volatile is write: 353
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 191
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 24
   depth: 2, occurrence: 33
   depth: 3, occurrence: 32
   depth: 4, occurrence: 36
   depth: 5, occurrence: 36

XXX percentage a fresh-made variable is used: 11.2
XXX percentage an existing variable is used: 88.8
********************* end of statistics **********************/

