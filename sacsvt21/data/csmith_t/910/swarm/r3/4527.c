/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1336784370
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U0  func_25(void);
static union U0 * func_26(uint16_t  p_27, uint8_t  p_28, union U0 * p_29, union U0 * p_30);
static union U0 * func_35(union U0  p_36, union U0 * p_37, uint32_t  p_38, union U0 * p_39, union U0 * p_40);
static union U0 * func_41(union U0 * p_42, uint8_t  p_43, uint32_t  p_44, uint32_t  p_45);
static int32_t  func_62(int16_t  p_63);
static uint16_t  func_65(union U0 * p_66, union U0 * p_67);
static union U0 * func_68(int32_t  p_69, uint8_t  p_70, int32_t  p_71);
static int32_t  func_79(uint32_t  p_80, int16_t  p_81, union U0 * p_82);
static float  func_94(int16_t  p_95, union U0 * p_96);
static float  func_99(union U0 * p_100, union U0 * p_101, uint32_t  p_102);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_25(void)
{ /* block id: 36 */
    int32_t l_31 = 0xBEB96916;
    uint32_t l_32 = 0U;
    union U0 l_34 = {0x0D01};
    union U0 *l_33 = &l_34;
    union U0 **l_338 = (void*)0;
    union U0 **l_339 = &l_33;
    uint32_t l_346 = 0x791ECBDF;
    int32_t l_361 = 0x6D7D79F0;
    int32_t *l_364 = (void*)0;
    int32_t **l_363 = &l_364;
    int32_t ***l_362 = &l_363;
    uint16_t l_365 = 0U;
    float l_366 = 0x0.5BB411p-23;
    float *l_367 = &l_366;
    uint16_t l_373 = 0U;
    int32_t l_378 = (-5);
    int16_t l_379 = 0x526F;
    union U0 l_380 = {0xED3D};
    (*l_339) = func_26(l_31, l_32, l_33, func_35((*l_33), func_41(&l_34, __builtin_ctzl(l_31), (l_32 , ((l_31 > (-1)) , l_32)), l_32), l_34.f0, &l_34, &l_34));
    (*l_367) = ((float)((float)(((float)((__builtin_clz(l_34.f0) != l_346) < ((float)l_34.f0 + (float)(0x8.0E8F7Ap-26 <= l_346))) * (float)((((float)((float)0x6.A488BFp+17 / (float)(((float)((float)((-0x1.Ap+1) > ((((uint16_t)((((int16_t)(l_34.f0 , l_31) >> (int16_t)2) && l_346) ^ 1) * (uint16_t)l_31) & l_361) , 0x1.2p+1)) * (float)l_361) + (float)l_346) != l_34.f0)) - (float)0x9.304BBAp-86) , l_362) != &l_363)) <= 0x3.3p+1) / (float)l_365) / (float)l_366);
    (**l_362) = (((0x1E889AAD & ((int16_t)((l_32 && 3U) , 0x0498) >> (int16_t)((((uint16_t)((((!func_62(((((**l_339) , &l_362) != (l_373 , &l_362)) , ((uint16_t)((uint16_t)l_31 * (uint16_t)(-1)) % (uint16_t)l_373)))) , l_378) != l_378) > (-8)) * (uint16_t)0xFB2E) == l_361) >= 1U))) == l_379) , (*l_363));
    return l_380;
    /* statement id: 155 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_26(uint16_t  p_27, uint8_t  p_28, union U0 * p_29, union U0 * p_30)
{ /* block id: 148 */
    int16_t l_309 = 0x2DD5;
    int32_t l_327 = 0x1B9957DA;
    float l_329 = 0x0.Cp+1;
    float *l_328 = &l_329;
    int32_t *l_336 = &l_327;
    int32_t **l_335 = &l_336;
    int32_t ***l_334 = &l_335;
    union U0 l_337 = {0xADBF};
    (*l_328) = ((((float)(+(((float)l_309 * (float)l_309) < (((float)(p_27 > (((+((int32_t)((uint16_t)((int32_t)l_309 - (int32_t)((uint16_t)l_309 % (uint16_t)p_28)) >> (uint16_t)(((int16_t)(p_27 && (((uint32_t)l_309 % (uint32_t)p_28) <= p_28)) * (int16_t)p_27) == l_309)) / (int32_t)0x315BE178)) | 1U) , 0x3.8D9F72p-26)) / (float)l_309) >= p_28))) + (float)l_327) != l_327) != 0xC.4F156Dp+90);
    (*l_336) = (p_27 , (l_309 > ((int16_t)((((int16_t)p_28 - (int16_t)((l_309 , l_334) == &l_335)) , ((l_337 , &p_30) != (((__builtin_popcount((***l_334)) == 0x1FB82741) || p_28) , &p_30))) >= (-1)) >> (int16_t)13)));
    return p_29;
    /* statement id: 151 */
    //assert (func_26_rv == &l_34);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_35(union U0  p_36, union U0 * p_37, uint32_t  p_38, union U0 * p_39, union U0 * p_40)
{ /* block id: 142 */
    int32_t l_290 = 9;
    int32_t *l_289 = &l_290;
    int32_t **l_291 = &l_289;
    int32_t ****l_292 = (void*)0;
    int32_t ***l_293 = (void*)0;
    int32_t l_296 = 0xA00DFFD0;
    union U0 *l_303 = (void*)0;
    (*l_291) = l_289;
    l_293 = &l_291;
    /* statement id: 144 */
    assert (l_293 == &l_291);
    (*l_289) = (func_62(((&l_293 == &l_293) , ((((((uint16_t)((*l_289) >= p_36.f0) >> (uint16_t)l_296) >= (**l_291)) , &p_39) != &p_40) <= ((int16_t)(__builtin_clzl(((void*)0 != (**l_293))) >= (***l_293)) * (int16_t)p_36.f0)))) , p_38);
    (*l_289) = __builtin_popcount(((int16_t)(***l_293) >> (int16_t)((p_38 || ((int16_t)2 % (int16_t)p_36.f0)) != func_65(((p_36.f0 & ((func_65(l_303, l_303) ^ ((((((**l_291) < 0x4.Bp-1) < (***l_293)) <= (**l_291)) , (*l_291)) != (void*)0)) <= p_38)) , l_303), l_303))));
    return l_303;
    /* statement id: 147 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_41(union U0 * p_42, uint8_t  p_43, uint32_t  p_44, uint32_t  p_45)
{ /* block id: 37 */
    int32_t l_273 = 0x5E5E2D9E;
    float l_280 = 0xD.150FF4p-20;
    float *l_279 = &l_280;
    int32_t *l_285 = &l_273;
    int32_t **l_284 = &l_285;
    for (p_43 = 0; (p_43 <= 26); ++p_43)
    { /* block id: 40 */
        uint32_t l_64 = 0xC437FFEA;
        int32_t l_278 = 7;
        int32_t *l_288 = &l_278;
        for (p_45 = 19; (p_45 < 45); p_45 += 1)
        { /* block id: 43 */
            int16_t l_274 = 0xBCC4;
            union U0 l_283 = {0xE79D};
            union U0 *l_282 = &l_283;
            union U0 **l_281 = &l_282;
            int32_t ***l_286 = (void*)0;
            int32_t ***l_287 = &l_284;
            for (p_44 = 0; (p_44 <= 50); p_44 += 8)
            { /* block id: 46 */
                int32_t l_52 = 0;
                for (l_52 = (-7); (l_52 != 18); l_52 += 1)
                { /* block id: 49 */
                    return p_42;
                    /* statement id: 50 */
                    //assert (func_41_rv == &l_34);
                }
                l_278 = (((!((int16_t)p_43 * (int16_t)((((uint16_t)__builtin_ffsl(l_52) >> (uint16_t)((uint16_t)((func_62(((l_64 != (p_43 || __builtin_popcountll(((__builtin_clzl(l_64) ^ (func_65(func_68(((int16_t)0xDDD5 << (int16_t)5), l_52, l_64), p_42) < l_273)) , 6U)))) && l_274)) < l_274) < l_273) * (uint16_t)l_274)) , 0x10EA) , 0x1EF6))) > 0x728FA397) , p_44);
            }
            (*l_281) = func_68(((void*)0 != l_279), l_274, p_43);
            /* statement id: 135 */
            assert (l_282 == 0);
            (*l_287) = l_284;
        }
        (**l_284) = p_43;
        l_288 = l_288;
    }
    return p_42;
    /* statement id: 141 */
    //assert (func_41_rv == &l_34);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_62(int16_t  p_63)
{ /* block id: 130 */
    uint32_t l_275 = 0x6D0EF2AE;
    int32_t l_277 = 1;
    int32_t *l_276 = &l_277;
    (*l_276) = l_275;
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_65(union U0 * p_66, union U0 * p_67)
{ /* block id: 109 */
    int32_t l_204 = 0xFA4222F6;
    int32_t *l_203 = &l_204;
    int32_t **l_205 = (void*)0;
    int32_t **l_206 = (void*)0;
    int32_t **l_207 = &l_203;
    uint32_t l_236 = 6U;
    union U0 l_268 = {1U};
    union U0 *l_267 = &l_268;
    float l_270 = (-0x5.Ap+1);
    float *l_269 = &l_270;
    float l_271 = 0xA.804F76p+32;
    uint32_t l_272 = 0x20E90B94;
    (*l_207) = l_203;
    if (((int16_t)((uint32_t)((*l_203) && (*l_203)) % (uint32_t)((uint16_t)((uint16_t)1U >> (uint16_t)((**l_207) <= ((**l_207) , ((uint16_t)((((int16_t)(**l_207) >> (int16_t)((*l_203) , __builtin_ia32_crc32qi((*l_203), (*l_203)))) >= (**l_207)) , (**l_207)) % (uint16_t)(*l_203))))) + (uint16_t)9)) * (int16_t)65531U))
    { /* block id: 111 */
        int32_t *l_220 = &l_204;
        (*l_207) = l_220;
        for (l_204 = 0; (l_204 == (-28)); --l_204)
        { /* block id: 115 */
            int32_t ***l_223 = &l_206;
            (*l_223) = (void*)0;
        }
        (*l_220) = (((((uint16_t)(*l_220) - (uint16_t)__builtin_clz((*l_220))) & __builtin_bswap64(((uint16_t)(((((((((int16_t)((*l_220) , ((uint16_t)((uint32_t)(*l_220) % (uint32_t)(**l_207)) >> (uint16_t)13)) + (int16_t)(((uint16_t)((void*)0 == &l_220) << (uint16_t)__builtin_bswap64((**l_207))) ^ 1U)) , l_236) >= (*l_220)) > 4294967289U) , 0x8.0A1D12p+40) , (**l_207)) && 3) & (**l_207)) + (uint16_t)(*l_220)))) , 1) || (*l_220));
    }
    else
    { /* block id: 119 */
        int16_t l_237 = 1;
        if (l_237)
        { /* block id: 120 */
            int32_t *l_238 = &l_204;
            float *l_239 = (void*)0;
            float *l_240 = (void*)0;
            float *l_241 = (void*)0;
            float l_243 = 0x4.9p+1;
            float *l_242 = &l_243;
            (*l_207) = l_238;
            (*l_242) = (*l_238);
        }
        else
        { /* block id: 123 */
            uint32_t l_246 = 0x685A1DF4;
            (*l_203) = ((uint16_t)0xEEBA << (uint16_t)l_246);
            return l_237;
        }
    }
    (*l_269) = (((*l_203) >= ((int16_t)((int16_t)((uint32_t)(((int16_t)(*l_203) * (int16_t)5) || (func_79((((int16_t)((uint16_t)((int32_t)((((int16_t)0xCCBD - (int16_t)((((0 <= (((int32_t)(((int16_t)(0x0195 || func_79((*l_203), __builtin_parity((**l_207)), l_267)) % (int16_t)(**l_207)) && (*l_203)) - (int32_t)(*l_203)) != (*l_203))) , (*l_203)) , (*l_207)) != (void*)0)) != 65535U) ^ (*l_203)) - (int32_t)(**l_207)) << (uint16_t)8) * (int16_t)(**l_207)) , (**l_207)), (**l_207), p_66) & 0)) / (uint32_t)(*l_203)) * (int16_t)(*l_203)) / (int16_t)(*l_203))) , 0x1.8E54D3p+25);
    return l_272;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_68(int32_t  p_69, uint8_t  p_70, int32_t  p_71)
{ /* block id: 52 */
    uint8_t l_78 = 0U;
    union U0 l_84 = {65534U};
    union U0 *l_83 = &l_84;
    int32_t l_170 = 0;
    int32_t *l_169 = &l_170;
    int32_t **l_168 = &l_169;
    union U0 *l_202 = (void*)0;
    if (((int16_t)p_69 % (int16_t)((uint16_t)((((l_78 & func_79(p_69, p_70, l_83)) == ((((uint16_t)(((__builtin_parityl(((uint16_t)((uint16_t)((uint16_t)l_78 * (uint16_t)p_69) * (uint16_t)((uint16_t)(p_71 | p_69) / (uint16_t)65535U)) - (uint16_t)(-4))) || 4294967294U) | 0xAA49FFA3) != p_70) + (uint16_t)0xB9B1) ^ 0x687184D5) != l_84.f0)) , (-1)) != l_78) >> (uint16_t)0)))
    { /* block id: 94 */
        int32_t ***l_171 = &l_168;
        union U0 *l_178 = (void*)0;
        (*l_171) = l_168;
        for (p_69 = 0; (p_69 == (-13)); p_69 -= 6)
        { /* block id: 98 */
            float l_175 = (-0x1.0p+1);
            float *l_174 = &l_175;
            (*l_174) = p_69;
            (*l_174) = (((float)(((-0x1.Ap+1) < p_70) != 0x1.Ap-1) * (float)(l_178 == (void*)0)) > (**l_168));
            (**l_171) = l_174;
            /* statement id: 101 */
            assert (l_169 == &l_175);
            return l_178;
            /* statement id: 102 */
            //assert (func_68_rv == 0);
        }
    }
    else
    { /* block id: 104 */
        float l_180 = 0x2.06111Ep+87;
        float *l_179 = &l_180;
        (*l_179) = 0xC.E23460p+98;
    }
    (**l_168) = ((func_79((**l_168), ((int16_t)((int16_t)(*l_169) << (int16_t)((-(uint16_t)(*l_169)) & (~(((int16_t)(6U & (((int16_t)((int16_t)p_69 * (int16_t)(**l_168)) / (int16_t)(~p_69)) >= ((int16_t)((int16_t)((((int16_t)((int16_t)(*l_169) * (int16_t)(*l_169)) + (int16_t)p_69) ^ (**l_168)) >= 6U) * (int16_t)(-1)) / (int16_t)p_70))) * (int16_t)p_69) != p_71)))) % (int16_t)p_71), &l_84) < (-1)) , p_71);
    return l_202;
    /* statement id: 108 */
    //assert (func_68_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_79(uint32_t  p_80, int16_t  p_81, union U0 * p_82)
{ /* block id: 53 */
    int16_t l_87 = (-1);
    union U0 l_91 = {0x4FCB};
    union U0 *l_90 = &l_91;
    uint32_t l_129 = 0xADCC66F1;
    int32_t l_131 = (-2);
    int32_t *l_130 = &l_131;
    uint32_t l_153 = 0x8B4E4A0A;
    uint32_t l_155 = 4294967290U;
    if (((uint32_t)((((p_81 , l_87) ^ l_87) , ((uint16_t)l_87 - (uint16_t)(((void*)0 != l_90) < (((&l_91 != (((uint16_t)(((func_94((l_87 < (-2)), &l_91) , 0x83E1A657) , &l_91) != &l_91) - (uint16_t)p_81) , p_82)) < p_80) , l_129)))) >= p_80) - (uint32_t)p_80))
    { /* block id: 68 */
        float l_138 = 0x0.Dp-1;
        int32_t l_139 = (-9);
        (*l_130) = (l_130 == (((((int16_t)p_81 % (int16_t)p_80) & (*l_130)) != ((*l_130) && ((uint16_t)(0U && (4294967294U & (__builtin_ctzll(((int32_t)((l_139 && ((int16_t)((((((p_82 == p_82) && (-1)) , (*l_130)) >= l_139) || l_139) < (*l_130)) >> (int16_t)p_81)) & (*l_130)) % (int32_t)(*l_130))) || p_80))) << (uint16_t)9))) , &l_131));
    }
    else
    { /* block id: 70 */
        int32_t *l_144 = &l_131;
        float l_148 = 0x0.8p+1;
        float *l_147 = &l_148;
        if (p_81)
        { /* block id: 71 */
            for (l_87 = (-19); (l_87 != (-12)); l_87 += 7)
            { /* block id: 74 */
                return p_81;
            }
        }
        else
        { /* block id: 77 */
            int32_t **l_145 = (void*)0;
            int32_t **l_146 = &l_130;
            l_130 = l_144;
            (*l_146) = &l_131;
        }
        (*l_147) = p_80;
    }
    for (p_80 = 0; (p_80 >= 6); p_80 += 1)
    { /* block id: 85 */
        int32_t *l_154 = (void*)0;
        float l_157 = 0x3.7C2843p-87;
        float *l_156 = &l_157;
        (*l_156) = ((float)(*l_130) - (float)((0x0.6p+1 >= ((((*l_130) , p_81) > l_153) < (l_154 == ((l_155 & (*l_130)) , l_154)))) == (*l_130)));
        (*l_130) = p_80;
        l_154 = l_154;
        (*l_130) = 0xFE7C9D89;
    }
    (*l_130) = p_81;
    (*l_130) = (*l_130);
    return p_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_94(int16_t  p_95, union U0 * p_96)
{ /* block id: 54 */
    uint16_t l_97 = 0x63F7;
    union U0 l_104 = {65531U};
    union U0 *l_103 = &l_104;
    int16_t l_128 = 0x679F;
    l_97 = ((void*)0 == p_96);
    l_128 = (!func_99(l_103, &l_104, l_104.f0));
    return l_104.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_99(union U0 * p_100, union U0 * p_101, uint32_t  p_102)
{ /* block id: 56 */
    float *l_105 = (void*)0;
    int32_t l_106 = 0x638B4FD0;
    int32_t *l_126 = &l_106;
    int32_t **l_125 = &l_126;
    uint16_t l_127 = 0xBC09;
    l_106 = p_102;
    for (l_106 = 10; (l_106 < 26); l_106 += 3)
    { /* block id: 60 */
        int32_t *l_110 = &l_106;
        int32_t **l_109 = &l_110;
        float l_124 = 0xD.534F93p-60;
        float *l_123 = &l_124;
        (*l_109) = &l_106;
        (*l_123) = __builtin_clzll(((p_102 >= ((((uint32_t)(((int32_t)(l_106 | p_102) / (int32_t)p_102) != ((uint16_t)(2 == p_102) - (uint16_t)(**l_109))) / (uint32_t)p_102) > ((int16_t)((uint16_t)((int32_t)p_102 - (int32_t)l_106) << (uint16_t)(*l_110)) - (int16_t)l_106)) , l_106)) == p_102));
    }
    l_125 = l_125;
    return l_127;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 63
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 11
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 10, occurrence: 1
   depth: 15, occurrence: 4
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 77

XXX times a variable address is taken: 69
XXX times a pointer is dereferenced on RHS: 75
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 25
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 36
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 184

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 188
   level: 2, occurrence: 52
   level: 3, occurrence: 11
XXX number of pointers point to pointers: 23
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.9
XXX average alias set size: 1.09

XXX times a non-volatile is read: 424
XXX times a non-volatile is write: 94
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 73
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 19
   depth: 2, occurrence: 15
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 15.3
XXX percentage an existing variable is used: 84.7
********************* end of statistics **********************/

