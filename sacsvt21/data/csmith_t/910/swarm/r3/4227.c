/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3024004758
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int64_t  f0;
   uint64_t  f1;
};

union U1 {
   int16_t  f0;
   uint64_t  f1;
   signed f2 : 1;
};

union U2 {
   unsigned f0 : 3;
   uint32_t  f1;
   float  f2;
   int32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U0  func_1(void);
static int32_t * func_2(union U0  p_3, union U0  p_4, int32_t * p_5, union U2  p_6, int32_t * p_7);
static union U0  func_8(uint64_t  p_9, int64_t  p_10, int32_t * p_11, int16_t  p_12, int32_t * p_13);
static uint32_t  func_17(int32_t * p_18, union U0  p_19);
static int32_t * func_21(int64_t  p_22, int32_t * p_23);
static int32_t  func_30(uint16_t  p_31, int64_t  p_32, float  p_33, uint16_t  p_34);
static uint64_t  func_46(uint32_t  p_47, uint16_t  p_48, int32_t * p_49);
static int64_t  func_51(uint64_t  p_52);
static uint64_t  func_63(int32_t * p_64, int32_t * p_65, int64_t  p_66, int32_t * p_67, float  p_68);
static int32_t * func_69(int16_t  p_70);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_1(void)
{ /* block id: 0 */
    uint16_t l_14 = 0x7839L;
    int32_t l_16 = 0xB6BC3EC3L;
    int32_t *l_15 = &l_16;
    union U0 l_20 = {2L};
    union U2 l_491 = {4294967295UL};
    int32_t **l_499 = (void*)0;
    int32_t **l_500 = &l_15;
    float *l_510 = &l_491.f2;
    (*l_500) = func_2(func_8(l_14, l_14, l_15, (((((0xFD2D1A4EL & func_17(&l_16, l_20)) <= l_14) && ((((*l_15) > 0xE50DL) && (*l_15)) >= (*l_15))) , (void*)0) != l_15), l_15), l_20, l_15, l_491, l_15);
    (*l_510) = (((((**l_500) == ((*l_15) < (safe_div_func_float_f_f((-((*l_15) == (0x6.CCF0DEp+6 <= (**l_500)))), (0x7.A5A220p-98 <= ((safe_sub_func_float_f_f((safe_add_func_float_f_f((*l_15), ((safe_add_func_uint64_t_u_u((((*l_15) >= 0xC5C1L) < (**l_500)), (*l_15))) , (-0x6.Dp-1)))), (**l_500))) != (**l_500))))))) == 0xA.1395B3p-57) > (**l_500)) >= (**l_500));
    /* statement id: 158 */
        return l_20;
    /* statement id: 159 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_2(union U0  p_3, union U0  p_4, int32_t * p_5, union U2  p_6, int32_t * p_7)
{ /* block id: 148 */
    int32_t l_493 = 0L;
    int32_t *l_492 = &l_493;
    int32_t **l_494 = &l_492;
    int32_t *l_498 = &l_493;
lbl_497:
    (*l_494) = l_492;
    for (p_3.f0 = 22; (p_3.f0 == (-11)); p_3.f0 = safe_sub_func_uint16_t_u_u(p_3.f0, 1))
    { /* block id: 152 */
        if (p_3.f0)
            goto lbl_497;
        if ((**l_494))
            continue;
    }
    return p_7;
    /* statement id: 156 */
    //assert (func_2_rv == &l_16);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_8(uint64_t  p_9, int64_t  p_10, int32_t * p_11, int16_t  p_12, int32_t * p_13)
{ /* block id: 142 */
    union U2 l_467 = {0UL};
    union U0 l_474 = {6L};
    int32_t l_479 = (-7L);
    int32_t *l_478 = &l_479;
    int32_t **l_477 = &l_478;
    int32_t ***l_476 = &l_477;
    int32_t ****l_475 = &l_476;
    float *l_482 = &l_467.f2;
    (*l_482) = (0xA.7AD6CBp-49 < (((0x4.5C628Fp+38 == ((l_467 , ((safe_sub_func_float_f_f((safe_sub_func_float_f_f(((safe_lshift_func_uint16_t_u_s((((l_474 , l_475) == &l_476) & (safe_mod_func_uint16_t_u_u((p_9 && p_9), p_10))), 1)) , (-0x1.1p-1)), (****l_475))), (****l_475))) < (-0x1.1p-1))) <= (***l_476))) != p_12) >= 0x1.6p-1));
    /* statement id: 143 */
        p_11 = (**l_476);
    /* statement id: 144 */
    assert (p_11 == &l_479);
    (***l_476) = (****l_475);
    (***l_476) = 0xA6877B99L;
    return l_474;
    /* statement id: 147 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_17(int32_t * p_18, union U0  p_19)
{ /* block id: 1 */
    uint32_t l_45 = 0x4D4B4B26L;
    int32_t l_126 = (-7L);
    int32_t *l_125 = &l_126;
    int16_t l_356 = (-1L);
    int32_t **l_383 = &l_125;
    int32_t ***l_382 = &l_383;
    int32_t ****l_422 = &l_382;
    int32_t *****l_421 = &l_422;
    union U1 l_437 = {0x64BDL};
    union U1 *l_436 = &l_437;
    union U1 **l_438 = (void*)0;
    union U0 l_461 = {2L};
    union U2 l_462 = {4294967295UL};
    int32_t l_463 = 0x51461E7FL;
    uint32_t l_464 = 0x6118430EL;
    int16_t l_465 = (-1L);
    float *l_466 = &l_462.f2;
    if ((*p_18))
    { /* block id: 2 */
        uint32_t l_80 = 0xAFF79C94L;
        int32_t *l_187 = &l_126;
        int32_t **l_355 = &l_187;
lbl_357:
        (*l_355) = func_21((((safe_mul_func_uint16_t_u_u(0x7356L, ((safe_mul_func_uint16_t_u_u((safe_mod_func_int32_t_s_s(func_30((safe_sub_func_int32_t_s_s(((safe_add_func_uint64_t_u_u(((safe_lshift_func_int16_t_s_u((safe_mul_func_uint16_t_u_u((((safe_div_func_int32_t_s_s(l_45, ((func_46((+(p_19.f1 & func_51((((safe_sub_func_int64_t_s_s((safe_add_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s(((safe_add_func_uint64_t_u_u((safe_add_func_uint64_t_u_u(l_45, p_19.f0)), func_63(((p_19.f1 , (*p_18)) , (void*)0), func_69(l_45), l_80, p_18, l_45))) ^ 0x50A8E06690943893LL), 1)), 0L)), l_45)) | p_19.f1) != l_45)))), l_80, l_125) < (*l_125)) || p_19.f1))) <= p_19.f0) , l_80), p_19.f1)), p_19.f1)) & p_19.f1), 0L)) <= 4L), 1UL)), l_80, l_80, p_19.f1), 1L)), p_19.f1)) || l_80))) , (void*)0) == l_187), p_18);
        /* statement id: 117 */
        //assert (l_187 == 0 || l_187 == &l_16);
        (*l_125) = (*p_18);
        (*l_355) = func_69(l_356);
        /* statement id: 119 */
        assert (l_187 == 0);
        if (p_19.f0)
            goto lbl_357;
    }
    else
    { /* block id: 121 */
        int64_t l_358 = 0L;
        int32_t ***l_363 = (void*)0;
        int32_t **l_366 = &l_125;
        float l_405 = 0x6.Ap-1;
        float *l_404 = &l_405;
        int32_t ****l_420 = &l_363;
        int32_t *****l_419 = &l_420;
        int16_t l_423 = 0x9C96L;
        int32_t l_424 = 0x154B6018L;
        (*l_125) = l_358;
        (*l_366) = func_69((safe_mod_func_uint64_t_u_u(((safe_sub_func_uint32_t_u_u(p_19.f1, ((p_19 , (l_363 != (void*)0)) | ((*p_18) < (safe_div_func_int32_t_s_s((*p_18), p_19.f0)))))) > p_19.f1), ((*l_125) ^ (*p_18)))));
        /* statement id: 123 */
        assert (l_125 == 0);
        if ((*p_18))
        { /* block id: 124 */
            int32_t ***l_367 = &l_366;
            float l_369 = 0x3.EBE60Dp+39;
            float *l_368 = &l_369;
            int32_t *l_372 = &l_126;
            (*l_368) = (&l_366 != l_367);
            (**l_367) = p_18;
            /* statement id: 126 */
            //assert (l_125 == &l_16);
            for (l_358 = 0; (l_358 == (-17)); l_358 = safe_sub_func_int16_t_s_s(l_358, 9))
            { /* block id: 129 */
                l_372 = p_18;
                /* statement id: 130 */
                //assert (l_372 == &l_16);
            }
            /* facts after for loop */
            //assert (l_372 == &l_16 || l_372 == &l_126);
            (*p_18) = ((**l_366) < (safe_mod_func_int32_t_s_s(((*l_372) < ((p_19 , func_69((safe_div_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(((*l_125) , ((void*)0 == (*l_367))), (*l_372))), ((((((((!(p_19.f1 ^ (safe_rshift_func_uint16_t_u_s((***l_367), 1)))) ^ 0xEEF1L) , l_382) == (void*)0) & 1UL) < 0L) & 18446744073709551609UL) , 0xEF7CL))))) != p_18)), (***l_382))));
        }
        else
        { /* block id: 133 */
            union U2 l_401 = {4294967287UL};
            float l_403 = 0x5.Cp+1;
            float *l_402 = &l_403;
            int32_t l_425 = (-1L);
            l_425 = ((safe_add_func_float_f_f((safe_sub_func_float_f_f((((p_19.f0 <= (safe_add_func_float_f_f((safe_mul_func_float_f_f((safe_div_func_float_f_f(((((safe_div_func_int64_t_s_s((safe_sub_func_uint16_t_u_u(((+(safe_sub_func_uint32_t_u_u(((l_401 , l_402) != l_404), (safe_rshift_func_uint16_t_u_u((safe_add_func_uint64_t_u_u(((safe_mod_func_int64_t_s_s((!65529UL), (-1L))) , (safe_lshift_func_int16_t_s_s((((p_19.f0 > (safe_mul_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((((l_419 != l_421) > (-1L)) <= p_19.f1), l_423)), p_19.f1))) || p_19.f0) > 8L), 7))), p_19.f0)), p_19.f0))))) >= p_19.f1), p_19.f1)), p_19.f0)) , 0xBAEF624EA28F760DLL) , 0x7.B6C70Ep+10) >= p_19.f0), (-0x1.7p-1))), p_19.f1)), l_424))) , p_18) == p_18), 0x4.B8FDB1p+7)), l_401.f0)) , (*p_18));
        }
        /* facts after branching */
        //assert (l_125 == 0 || l_125 == &l_16);
        (*p_18) = ((safe_rshift_func_uint16_t_u_s((p_19.f0 >= ((***l_422) != (*l_366))), 1)) ^ (safe_add_func_uint64_t_u_u((safe_add_func_uint64_t_u_u((safe_add_func_int32_t_s_s(((safe_div_func_uint32_t_u_u(((*l_421) != (void*)0), p_19.f0)) < 0xCF726698EB2AF3A1LL), 0xD2AB0D9BL)), (p_19 , p_19.f1))), p_19.f0)));
    }
    /* facts after branching */
    //assert (l_125 == 0 || l_125 == &l_16 || l_125 == &l_126);
    l_436 = l_436;
    (*p_18) = 0xE8A339BAL;
    (*l_466) = (safe_sub_func_float_f_f(((safe_div_func_float_f_f(((safe_add_func_float_f_f(p_19.f1, ((safe_mul_func_float_f_f(((safe_mul_func_float_f_f(((((safe_add_func_float_f_f((-0x5.0p+1), (safe_mul_func_float_f_f((((safe_div_func_float_f_f(((safe_mul_func_float_f_f((safe_add_func_float_f_f((safe_div_func_float_f_f(p_19.f1, (l_461 , ((((p_19.f0 >= ((void*)0 == &l_437)) == ((((l_462 , (p_19.f0 <= p_19.f0)) > p_19.f1) >= 0xE.02F5C1p-24) < 0x6.2B466Fp+45)) , l_125) != l_125)))), p_19.f0)), l_463)) <= l_464), 0x8.1p+1)) < l_465) > p_19.f1), 0x1.3p-1)))) == p_19.f1) < p_19.f0) , p_19.f1), 0x8.62D382p-19)) <= p_19.f0), (-0x1.3p-1))) >= p_19.f1))) < p_19.f1), p_19.f0)) < p_19.f0), 0x1.Ep-1));
    /* statement id: 140 */
        return p_19.f0;
}


/* ------------------------------------------ */
/* 
 * reads : l_16
 * writes: l_16
 */
static int32_t * func_21(int64_t  p_22, int32_t * p_23)
{ /* block id: 40 */
    uint64_t l_188 = 7UL;
    union U2 l_195 = {4294967286UL};
    uint16_t l_197 = 65535UL;
    int32_t **l_198 = (void*)0;
    int32_t ***l_228 = &l_198;
    int32_t ****l_227 = &l_228;
    int32_t l_231 = 0x63E790F2L;
    int16_t l_286 = (-10L);
    uint32_t l_287 = 0UL;
    int64_t l_295 = 0xDE611EDE5B750B92LL;
    int32_t l_324 = 1L;
    uint16_t l_339 = 65532UL;
    int32_t *l_354 = &l_324;
    int32_t **l_353 = &l_354;
    (*p_23) = (0xE7FB8437L >= l_188);
    for (p_22 = 0; (p_22 > 3); ++p_22)
    { /* block id: 44 */
        uint32_t l_205 = 18446744073709551607UL;
        int32_t ***l_209 = &l_198;
        union U1 l_257 = {0x85A3L};
        union U0 l_264 = {-10L};
        int32_t l_274 = 0x78988055L;
        int32_t *l_273 = &l_274;
        int32_t **l_311 = (void*)0;
        int32_t **l_312 = &l_273;
        int16_t l_323 = 0xA65DL;
        for (l_188 = 0; (l_188 >= 31); l_188 = safe_add_func_uint64_t_u_u(l_188, 7))
        { /* block id: 47 */
            float *l_206 = &l_195.f2;
            int32_t ***l_210 = (void*)0;
            int32_t l_222 = 0xFD6A48C6L;
            int32_t *l_275 = (void*)0;
            (*l_206) = (safe_div_func_float_f_f((p_22 , (((l_195 , (~(l_197 | (p_22 && 18446744073709551610UL)))) , (l_198 == (void*)0)) <= (safe_div_func_float_f_f(((safe_mul_func_float_f_f(((safe_add_func_float_f_f(l_205, 0x7.9p-1)) >= 0xD.3978F7p+48), 0x0.9p-1)) > (-0x1.Fp-1)), p_22)))), (-0x7.2p-1)));
            /* statement id: 48 */
                        if ((p_22 , (safe_mul_func_int16_t_s_s(1L, ((l_205 , l_209) == l_210)))))
            { /* block id: 49 */
                uint32_t l_218 = 4294967288UL;
                int32_t l_221 = 0x51C66ACBL;
                int32_t ****l_223 = (void*)0;
                int32_t ****l_224 = &l_209;
                (*p_23) = (((safe_mul_func_uint16_t_u_u((((((!p_22) , (((safe_div_func_uint16_t_u_u(((((*p_23) <= p_22) , p_23) != p_23), 0xBDFDL)) > ((safe_mod_func_int16_t_s_s(l_218, (safe_add_func_int16_t_s_s(p_22, (l_221 , 0x2922L))))) ^ p_22)) && l_222)) , p_22) | l_221) | p_22), p_22)) , p_22) != p_22);
                (*l_224) = l_209;
            }
            else
            { /* block id: 52 */
                uint32_t l_229 = 0x5342C4FAL;
                int32_t l_230 = 1L;
                l_230 = ((safe_mul_func_int16_t_s_s(((void*)0 == l_227), p_22)) == l_229);
            }
            if (((((p_22 <= (&l_210 == (void*)0)) | l_231) , &l_210) == &l_210))
            { /* block id: 55 */
                uint32_t l_244 = 1UL;
                int32_t ****l_260 = &l_209;
                float *l_310 = &l_195.f2;
                if (((safe_add_func_float_f_f(p_22, (safe_mul_func_float_f_f(p_22, 0x4.7p-1)))) , (*p_23)))
                { /* block id: 56 */
                    int32_t *l_238 = &l_222;
                    int32_t *l_239 = &l_222;
                    int32_t ***l_241 = &l_198;
                    for (l_205 = 0; (l_205 > 4); ++l_205)
                    { /* block id: 59 */
                        int32_t ***l_240 = &l_198;
                        l_239 = l_238;
                        l_241 = l_240;
                        return p_23;
                        /* statement id: 62 */
                        //assert (func_21_rv == &l_16);
                    }
                    (*l_239) = (((safe_lshift_func_uint16_t_u_u(l_244, 3)) <= ((safe_mod_func_uint64_t_u_u((p_22 || (p_22 > (~(((((!(safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_mod_func_uint32_t_u_u((l_244 <= ((((safe_mul_func_int16_t_s_s(((((*p_23) , ((l_257 , (*l_239)) , ((safe_mod_func_uint32_t_u_u((((((l_260 == ((p_22 | (*l_238)) , l_260)) , p_22) , &l_210) != &l_241) , p_22), p_22)) , (void*)0))) != (void*)0) & p_22), 65535UL)) > p_22) <= p_22) , p_22)), 0x2FE5E662L)), (*l_238))), 10))) == 0x0FA09440013EB68FLL) != 0x73D2L) != p_22) & p_22)))), p_22)) | p_22)) , (-3L));
                    for (l_195.f1 = 0; (l_195.f1 < 21); l_195.f1 = safe_add_func_int64_t_s_s(l_195.f1, 9))
                    { /* block id: 67 */
                        int32_t **l_263 = &l_239;
                        (*l_263) = p_23;
                        /* statement id: 68 */
                        //assert (l_239 == &l_16);
                        (*p_23) = (((l_209 == ((l_264 , ((l_222 <= (safe_unary_minus_func_uint32_t_u(p_22))) , p_22)) , l_209)) , 0xEE80L) | (safe_lshift_func_uint16_t_u_s((*l_239), 9)));
                    }
                    /* facts after for loop */
                                        //assert (l_239 == &l_16 || l_239 == &l_222);
                }
                else
                { /* block id: 71 */
                    int32_t l_270 = 0xE3DBFE5EL;
                    union U1 l_284 = {8L};
                    int32_t *l_296 = (void*)0;
                    if ((((((-1L) || p_22) ^ p_22) >= 0x5883D10087D275BALL) ^ (safe_sub_func_uint64_t_u_u(l_270, (((p_22 | (safe_lshift_func_int16_t_s_s((&p_23 != (*l_209)), 2))) >= 0x0807B0C9AB25B980LL) == 4294967295UL)))))
                    { /* block id: 72 */
                        (*p_23) = l_244;
                    }
                    else
                    { /* block id: 74 */
                        (*p_23) = (*p_23);
                    }
                    l_275 = l_273;
                    /* statement id: 77 */
                    assert (l_275 == &l_274);
                    if (((*l_260) == (void*)0))
                    { /* block id: 78 */
                        (*p_23) = (safe_mod_func_uint16_t_u_u(p_22, p_22));
                        if ((*p_23))
                            continue;
                        if ((*p_23))
                            break;
                    }
                    else
                    { /* block id: 82 */
                        union U2 l_285 = {0x38FA4262L};
                        (*p_23) = ((safe_div_func_int64_t_s_s((safe_div_func_int32_t_s_s((safe_lshift_func_int16_t_s_u(((p_22 ^ p_22) & (l_284 , ((void*)0 != (*l_260)))), (l_285 , p_22))), ((((((l_270 , l_285.f0) >= p_22) ^ 0x4554L) && l_286) <= p_22) && p_22))), 0xE4385C5DCDB8084ELL)) < l_287);
                        (*p_23) = (p_22 > 0x956A48319FEF01F0LL);
                    }
                    (*p_23) = (safe_unary_minus_func_uint64_t_u((((0x077B5E051AC87C86LL ^ (((((-7L) ^ (0x8DB606F9L ^ 0x829673AEL)) , (p_22 , p_22)) , 9UL) != (safe_lshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((((safe_sub_func_float_f_f((((((-1L) > (*l_275)) <= 1L) , l_270) , p_22), l_295)) , p_23) != l_296), p_22)), p_22)))) | (*p_23)) , p_22)));
                }
                /* facts after branching */
                                assert (l_275 == &l_274 || l_275 == 0);
                (*l_273) = ((safe_mod_func_int64_t_s_s((p_22 , (p_22 >= (safe_mul_func_int16_t_s_s(((safe_div_func_uint16_t_u_u((safe_mul_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s(((4294967293UL > ((0UL > (((safe_unary_minus_func_int32_t_s((*p_23))) & (((safe_sub_func_int16_t_s_s((p_22 != 0x4447L), (p_22 | ((void*)0 == l_260)))) , l_310) != (void*)0)) | (*p_23))) , (*p_23))) != 0x741B8BEBL), 2)) == p_22), 0UL)), p_22)) ^ 0x468759E3L), p_22)))), p_22)) && (*p_23));
                if ((*p_23))
                    break;
            }
            else
            { /* block id: 90 */
                (*l_206) = p_22;
            }
            /* facts after branching */
                        assert (l_275 == &l_274 || l_275 == 0);
        }
        (*l_312) = p_23;
        /* statement id: 94 */
        //assert (l_273 == &l_16);
        for (l_257.f1 = 0; (l_257.f1 == 41); l_257.f1 = safe_add_func_int16_t_s_s(l_257.f1, 1))
        { /* block id: 97 */
            uint16_t l_315 = 0x47EDL;
            union U2 l_326 = {0xC0D5E5FDL};
            uint16_t l_338 = 0x3A38L;
            if (l_315)
            { /* block id: 98 */
                int32_t ***l_318 = &l_311;
                (*p_23) = ((safe_mul_func_uint16_t_u_u(((l_318 == l_318) & (((safe_mod_func_uint32_t_u_u(((((*l_227) == (*l_227)) , p_23) == (void*)0), ((p_22 <= (*l_273)) , ((safe_rshift_func_int16_t_s_u(l_315, 14)) , 4294967293UL)))) == (*p_23)) > 9L)), l_323)) <= p_22);
                if (l_324)
                { /* block id: 100 */
                    uint32_t l_331 = 18446744073709551613UL;
                    float *l_340 = (void*)0;
                    float *l_341 = &l_195.f2;
                    (*l_341) = ((((~((((l_326 , ((safe_sub_func_uint32_t_u_u(0x78C3C85AL, (safe_lshift_func_int16_t_s_s((p_22 , p_22), l_331)))) && (p_22 != (((safe_sub_func_int32_t_s_s((safe_add_func_uint64_t_u_u(((l_195 , (((safe_mul_func_uint16_t_u_u(((&l_209 == &l_228) , p_22), 4L)) != l_338) || 65530UL)) & (**l_312)), (-7L))), 0x4223055EL)) ^ 1L) <= l_331)))) <= p_22) & (-8L)) | l_339)) , (void*)0) != p_23) > p_22);
                    /* statement id: 101 */
                                        (*p_23) = ((!1UL) <= p_22);
                }
                else
                { /* block id: 103 */
                    int32_t *****l_343 = &l_227;
                    if ((*p_23))
                        break;
                    (*l_343) = &l_228;
                }
            }
            else
            { /* block id: 107 */
                union U1 l_351 = {-4L};
                int32_t *l_352 = (void*)0;
                (*l_227) = (*l_227);
                (*l_312) = (p_22 , func_69((0xB3CAA037457197BDLL < ((~((&l_312 != (*l_227)) == ((safe_mod_func_int64_t_s_s((p_22 | (4294967288UL >= ((safe_div_func_int32_t_s_s((safe_sub_func_int32_t_s_s(((((l_351 , (p_22 && l_351.f0)) && l_338) ^ 1UL) , l_326.f0), l_338)), l_315)) && 0UL))), l_338)) & (*l_273)))) < l_326.f0))));
                /* statement id: 109 */
                assert (l_273 == 0);
                return l_352;
                /* statement id: 110 */
                //assert (func_21_rv == 0);
            }
        }
        /* facts after for loop */
            }
    (*l_353) = p_23;
    /* statement id: 114 */
    //assert (l_354 == &l_16);
    (*l_353) = p_23;
    return p_23;
    /* statement id: 116 */
    //assert (func_21_rv == &l_16);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_30(uint16_t  p_31, int64_t  p_32, float  p_33, uint16_t  p_34)
{ /* block id: 22 */
    uint16_t l_130 = 1UL;
    int32_t **l_150 = (void*)0;
    float *l_157 = (void*)0;
    float *l_158 = (void*)0;
    int32_t l_160 = 0x47936CBAL;
    uint32_t l_173 = 4294967292UL;
    int32_t *l_186 = &l_160;
    if (l_130)
    { /* block id: 23 */
        uint32_t l_131 = 18446744073709551613UL;
        return l_131;
    }
    else
    { /* block id: 25 */
        float l_138 = 0xF.3785E6p+66;
        float *l_137 = &l_138;
        int32_t l_163 = (-1L);
        int32_t ***l_185 = &l_150;
        int32_t ****l_184 = &l_185;
        if ((~((((safe_lshift_func_uint16_t_u_s(65533UL, 13)) , (safe_div_func_uint64_t_u_u((p_34 , (p_34 != p_34)), (p_32 ^ ((void*)0 != l_137))))) <= (((p_31 == (p_31 | p_32)) | (-5L)) ^ 0x5059AB73L)) != l_130)))
        { /* block id: 26 */
            int32_t l_151 = 0x40F15219L;
            int16_t l_152 = 0xA132L;
            uint64_t l_153 = 1UL;
            (*l_137) = ((((safe_sub_func_float_f_f((safe_add_func_float_f_f(((safe_sub_func_float_f_f((p_31 == ((!(safe_div_func_float_f_f(l_130, (safe_mul_func_float_f_f((l_150 == ((0L >= 4L) , l_150)), 0x0.Bp+1))))) <= p_31)), ((p_32 >= 0x9.2p+1) >= l_151))) == 0x0.6p-1), p_31)), l_152)) < l_153) > (-0x1.9p+1)) > p_31);
        }
        else
        { /* block id: 28 */
            uint32_t l_156 = 18446744073709551609UL;
            int32_t *l_159 = (void*)0;
            l_160 = (safe_add_func_uint64_t_u_u((l_156 >= p_32), (0x59B8C56EC938AAB9LL < (l_157 != l_158))));
        }
        l_163 = (safe_mul_func_uint16_t_u_u(p_34, 0xDBDEL));
        for (l_160 = 4; (l_160 < 8); ++l_160)
        { /* block id: 34 */
            int32_t l_169 = 1L;
            int32_t *l_181 = &l_163;
            int32_t **l_180 = &l_181;
            int32_t ***l_183 = &l_180;
            int32_t ****l_182 = &l_183;
            (**l_180) = (safe_mul_func_uint16_t_u_u((((((+(l_169 , (!(safe_mul_func_uint16_t_u_u(l_173, (0x5FFFL > ((p_31 | ((safe_add_func_uint32_t_u_u(0xE8D41E4DL, 0xECE45356L)) && (safe_add_func_uint16_t_u_u(((p_32 >= l_163) != ((safe_div_func_uint16_t_u_u((((l_180 == l_150) <= p_34) | p_34), l_163)) | p_31)), p_31)))) || p_34))))))) || l_163) , l_182) == l_184) , (*l_181)), 0xC88DL));
        }
    }
    l_186 = func_69(l_130);
    /* statement id: 38 */
    assert (l_186 == 0);
    return l_130;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_46(uint32_t  p_47, uint16_t  p_48, int32_t * p_49)
{ /* block id: 19 */
    float *l_127 = (void*)0;
    float l_129 = 0x4.760612p+84;
    float *l_128 = &l_129;
    (*l_128) = (&p_49 == (void*)0);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_51(uint64_t  p_52)
{ /* block id: 17 */
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads : l_16
 * writes:
 */
static uint64_t  func_63(int32_t * p_64, int32_t * p_65, int64_t  p_66, int32_t * p_67, float  p_68)
{ /* block id: 7 */
    float l_83 = 0x8.C74F34p-5;
    int32_t l_84 = 0L;
    int32_t **l_104 = (void*)0;
    union U0 l_110 = {0L};
    union U2 l_113 = {0x716CFB31L};
    int32_t ***l_116 = &l_104;
    int32_t ****l_115 = &l_116;
    int32_t ****l_123 = &l_116;
    int16_t l_124 = 0xE169L;
    if ((safe_mod_func_uint32_t_u_u(l_84, l_84)))
    { /* block id: 8 */
        int32_t *l_92 = &l_84;
        int32_t **l_91 = &l_92;
        uint32_t l_99 = 0UL;
        int32_t ***l_106 = &l_104;
        int32_t ****l_105 = &l_106;
        (*l_92) = (safe_mod_func_int16_t_s_s(((safe_mul_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(((&p_67 == l_91) != (-6L)), 0)) < 0x92E414E4A47BFE1ALL), (safe_sub_func_int32_t_s_s((safe_add_func_int64_t_s_s((safe_add_func_int64_t_s_s(l_99, (safe_mul_func_uint16_t_u_u(l_84, ((((&l_92 == &p_65) < (safe_sub_func_uint64_t_u_u(((((p_66 , l_104) == l_104) ^ (**l_91)) > (**l_91)), p_66))) <= 9L) && (*p_67)))))), 18446744073709551615UL)), p_66)))) < p_66), 0x0F30L));
        (*l_105) = &l_104;
    }
    else
    { /* block id: 11 */
        int32_t ****l_107 = (void*)0;
        int32_t ***l_109 = &l_104;
        int32_t ****l_108 = &l_109;
        (*l_108) = &l_104;
        return p_66;
    }
    p_68 = (((l_110 , (safe_div_func_float_f_f((((((((l_113 , ((!(l_115 != &l_116)) == p_66)) && (0xC6A5050E7A76403ELL | ((safe_mod_func_int16_t_s_s((p_66 & (l_110 , (safe_lshift_func_int16_t_s_s((safe_div_func_uint16_t_u_u(((((l_123 != (void*)0) , 4UL) | 8L) && p_66), p_66)), p_66)))), 6UL)) != p_66))) >= 0x6C25L) && p_66) > p_66) || 18446744073709551615UL) , l_124), (-0x5.3p-1)))) > 0x1.Bp-1) != (-0x6.Ep+1));
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(int16_t  p_70)
{ /* block id: 3 */
    int32_t l_72 = 9L;
    int32_t *l_71 = &l_72;
    int32_t **l_73 = &l_71;
    int32_t *l_74 = &l_72;
    int32_t *l_75 = &l_72;
    int32_t *l_76 = &l_72;
    int32_t *l_77 = &l_72;
    int32_t *l_78 = &l_72;
    int32_t *l_79 = (void*)0;
    (*l_73) = l_71;
    (*l_73) = (*l_73);
    return l_79;
    /* statement id: 6 */
    //assert (func_69_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 110
XXX total union variables: 16

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 12
breakdown:
   indirect level: 0, occurrence: 11
   indirect level: 1, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 2
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 14
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 4

XXX max expression depth: 45
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 19
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 45, occurrence: 1

XXX total number of pointers: 104

XXX times a variable address is taken: 93
XXX times a pointer is dereferenced on RHS: 81
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 14
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 49
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 381

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 107
   level: 2, occurrence: 36
   level: 3, occurrence: 74
   level: 4, occurrence: 44
   level: 5, occurrence: 9
XXX number of pointers point to pointers: 50
XXX number of pointers point to scalars: 53
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26
XXX average alias set size: 1.12

XXX times a non-volatile is read: 573
XXX times a non-volatile is write: 124
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 102
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 21
   depth: 2, occurrence: 12
   depth: 3, occurrence: 13
   depth: 4, occurrence: 11
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 16
XXX percentage an existing variable is used: 84
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

