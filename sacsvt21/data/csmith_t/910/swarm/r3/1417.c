/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --math64 --inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      522378606
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const uint32_t  f0;
   signed f1 : 6;
   int16_t  f2;
   uint32_t  f3;
};

struct S1 {
   signed f0 : 8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const int32_t  func_1(void);
static uint16_t  func_2(int32_t  p_3, uint8_t  p_4, uint32_t  p_5, uint8_t  p_6, uint32_t  p_7);
static uint16_t  func_20(uint16_t  p_21, const struct S0  p_22, const int16_t  p_23, uint16_t * p_24);
inline static uint16_t * func_26(uint16_t * p_27);
inline static uint16_t * func_28(uint32_t  p_29, int32_t  p_30, uint16_t * p_31, uint16_t * p_32);
inline static uint32_t  func_33(uint8_t  p_34, const uint32_t  p_35);
static uint8_t  func_37(int32_t  p_38, uint16_t * p_39, int16_t  p_40);
static uint32_t  func_41(uint16_t * p_42, uint16_t * p_43, uint16_t * p_44, uint16_t * p_45);
static uint16_t * func_46(struct S1  p_47, uint16_t * p_48, uint32_t  p_49, int32_t  p_50, uint8_t  p_51);
inline static struct S1  func_52(uint16_t * p_53);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_8 = 0x85B7;
    uint16_t l_17 = 6U;
    uint16_t *l_16 = &l_17;
    const struct S0 l_25 = {0x1720348F,-4,0xFE24,0U};
    uint8_t l_405 = 247U;
    uint8_t *l_404 = &l_405;
    int32_t l_419 = 0;
    int32_t *l_418 = &l_419;
    const int16_t l_466 = 0x06DE;
    struct S1 l_504 = {-1};
    int32_t * const *l_633 = &l_418;
    int32_t * const ** const l_632 = &l_633;
    const uint32_t l_654 = 0x85B302C4;
    int32_t l_665 = (-1);
    uint32_t l_666 = 0x1BD85010;
    const uint32_t l_669 = 4294967295U;
    const uint32_t l_670 = 7U;
    int32_t l_686 = 3;
    int32_t l_688 = 0xDB756D7C;
    uint32_t l_701 = 1U;
    int16_t l_717 = 0x4368;
    uint16_t **l_730 = &l_16;
    uint16_t ***l_729 = &l_730;
    uint16_t **** const l_728 = &l_729;
    uint32_t *l_743 = &l_666;
    uint32_t **l_742 = &l_743;
    uint32_t ***l_741 = &l_742;
    uint8_t l_776 = 5U;
    uint16_t l_800 = 0xDE8D;
    uint16_t l_820 = 0U;
    uint16_t l_843 = 0x1C20;
    struct S1 *l_849 = &l_504;
    struct S1 **l_848 = &l_849;
    struct S1 ***l_847 = &l_848;
    int16_t l_857 = 1;
    uint16_t *l_880 = &l_17;
    int32_t l_896 = 0x68D2591F;
    const uint32_t l_903 = 4294967295U;
    if ((func_2(l_8, ((*l_404) = ((safe_lshift_func_int16_t_s_u((safe_mul_func_int16_t_s_s((+(safe_mod_func_uint16_t_u_u(((*l_16) = l_8), 9U))), (safe_rshift_func_uint16_t_u_s(func_20(l_8, l_25, l_25.f0, func_26(&l_8)), l_25.f1)))), l_25.f3)) < l_25.f0)), l_25.f3, l_25.f3, l_25.f0) & l_25.f3))
    { /* block id: 237 */
        const int16_t l_417 = (-3);
        struct S0 l_439 = {0U,-2,0x5BE3,0x966DBC2B};
        uint32_t l_444 = 0xA2C9F24E;
        uint32_t *l_443 = &l_444;
        uint16_t **l_462 = &l_16;
        struct S1 l_489 = {3};
        struct S1 *l_491 = &l_489;
        const uint8_t l_519 = 0xD4;
        uint16_t l_545 = 0xB408;
        uint16_t * const l_544 = &l_545;
        uint16_t * const *l_543 = &l_544;
        uint16_t * const **l_542 = &l_543;
        uint16_t * const ***l_541 = &l_542;
        uint16_t * const ****l_540 = &l_541;
        const uint32_t l_594 = 1U;
        uint32_t l_595 = 2U;
        int32_t *l_600 = &l_419;
        for (l_405 = (-1); (l_405 <= 10); l_405 = safe_add_func_uint16_t_u_u(l_405, 1))
        { /* block id: 240 */
            struct S1 **l_412 = (void*)0;
            struct S1 **l_413 = (void*)0;
            struct S1 l_416 = {-15};
            struct S1 *l_415 = &l_416;
            struct S1 **l_414 = &l_415;
            (*l_414) = (void*)0;
            /* statement id: 241 */
            assert (l_415 == 0);
        }
        if ((0x2094 ^ l_417))
        { /* block id: 243 */
            int32_t **l_420 = &l_418;
            (*l_420) = l_418;
        }
        else
        { /* block id: 245 */
            int32_t *l_424 = &l_419;
            int16_t l_438 = 0x63C9;
            int16_t *l_437 = &l_438;
            struct S1 *l_484 = (void*)0;
            struct S1 **l_483 = &l_484;
            for (l_405 = 0; (l_405 != 32); l_405++)
            { /* block id: 248 */
                int32_t **l_423 = &l_418;
                int32_t l_426 = 0xC6F954EC;
                int32_t *l_425 = &l_426;
                uint32_t *l_445 = &l_444;
                const struct S1 l_450 = {-9};
                struct S1 **l_478 = (void*)0;
                int32_t *l_485 = &l_419;
                struct S1 l_490 = {15};
                (*l_425) = ((*l_424) = (((*l_423) = (void*)0) == l_424));
                /* statement id: 251 */
                assert (l_418 == 0);
                if ((*l_424))
                { /* block id: 252 */
                    uint32_t l_434 = 0xAB5F580B;
                    uint32_t *l_433 = &l_434;
                    int32_t l_435 = 0xA369F491;
                    int16_t *l_442 = (void*)0;
                    int32_t l_465 = 1;
                    int32_t *l_468 = &l_465;
                    if ((safe_rshift_func_int16_t_s_s(((0x9454B698 && (+((safe_lshift_func_uint16_t_u_u((((*l_433) = (safe_unary_minus_func_int16_t_s(l_417))) >= (l_435 ^ (+((((((l_437 != (l_439 , (l_439 , ((safe_rshift_func_int16_t_s_s(0x4F48, 1)) , l_442)))) < ((l_445 = l_443) != (void*)0)) , 0xE684CF5D) & (*l_424)) , l_439.f2) ^ l_439.f3)))), 6)) , (*l_424)))) == l_435), (*l_424))))
                    { /* block id: 255 */
                        const uint16_t l_446 = 1U;
                        return l_446;
                    }
                    else
                    { /* block id: 257 */
                        int32_t l_453 = 0xE2A63C7A;
                        uint16_t **l_463 = &l_16;
                        uint16_t ***l_464 = &l_463;
                        int32_t l_467 = 0x52946B7A;
                        l_467 = ((!((*l_425) = ((safe_lshift_func_uint16_t_u_u(((*l_16) = 65527U), 0)) , (*l_425)))) && (l_450 , (l_419 = ((((safe_add_func_int16_t_s_s((((((*l_437) = (l_453 , (((0U <= (((*l_445) = (safe_lshift_func_int16_t_s_u((((**l_462) = ((((safe_sub_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s(l_439.f1, 5)) || (l_462 == ((*l_464) = l_463))), l_439.f2)) > 0x8DBD) | l_435) | l_465)) == l_435), 12))) >= (*l_424))) , (*l_425)) , 7))) && l_466) , (void*)0) == l_443), l_465)) != (-7)) >= l_439.f2) && 1U))));
                        l_468 = &l_467;
                        /* statement id: 266 */
                        assert (l_468 == &l_467);
                    }
                    /* facts after branching */
                    //assert (l_468 == dangling);
                }
                else
                { /* block id: 268 */
                    struct S1 l_482 = {-12};
                    struct S1 * const l_481 = &l_482;
                    struct S1 * const *l_480 = &l_481;
                    struct S1 * const **l_479 = &l_480;
                    (*l_424) = (((!((((((7 == (safe_lshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_s(((*l_424) <= (safe_mul_func_int16_t_s_s((l_439.f0 , (((*l_424) >= ((65527U && (safe_mul_func_int16_t_s_s((-1), ((*l_437) = ((((*l_479) = l_478) == l_483) == 0))))) & 0x9FCA559D)) , 0x6F03)), l_439.f3))), 5)), 10))) ^ (*l_425)) >= (*l_425)) == l_439.f1) & 0xA31313D4) | l_482.f0)) , l_485) != (*l_423));
                    /* statement id: 271 */
                    assert (l_480 == &l_481 || l_480 == 0);
                    (*l_423) = &l_419;
                    /* statement id: 272 */
                    assert (l_418 == &l_419);
                    return l_482.f0;
                }
                for (l_438 = 0; (l_438 <= 22); l_438 = safe_add_func_int32_t_s_s(l_438, 1))
                { /* block id: 277 */
                    int32_t l_488 = 0x93DD203B;
                    (*l_423) = &l_419;
                    /* statement id: 278 */
                    assert (l_418 == &l_419);
                    if ((*l_418))
                        break;
                    if (l_488)
                        continue;
                    l_490 = l_489;
                }
                /* facts after for loop */
                assert (l_418 == &l_419 || l_418 == 0);
            }
            /* facts after for loop */
            assert (l_418 == &l_419 || l_418 == 0);
        }
        /* facts after branching */
        assert (l_418 == &l_419 || l_418 == 0);
        (*l_491) = l_489;
        for (l_405 = (-1); (l_405 > 40); l_405 = safe_add_func_int32_t_s_s(l_405, 4))
        { /* block id: 288 */
            uint16_t *l_505 = &l_8;
            int32_t l_506 = 0xB2DF4E6D;
            uint8_t *l_521 = &l_405;
            uint16_t ***l_548 = &l_462;
            uint16_t ****l_547 = &l_548;
            uint16_t *****l_546 = &l_547;
            uint8_t l_560 = 0x82;
            uint32_t l_586 = 0U;
            uint32_t l_587 = 0x53B38278;
            struct S0 *l_616 = &l_439;
            struct S0 **l_617 = &l_616;
            if (l_489.f0)
            { /* block id: 289 */
                uint16_t l_496 = 0x8FB7;
                const int32_t **l_501 = (void*)0;
                int32_t **l_503 = &l_418;
                int32_t ***l_502 = &l_503;
                struct S0 *l_515 = (void*)0;
                struct S0 **l_514 = &l_515;
                uint8_t *l_522 = &l_405;
                const struct S1 l_569 = {-10};
                if (((safe_sub_func_uint16_t_u_u((l_439.f2 , (((l_496 , (safe_mul_func_int16_t_s_s(6, 0U))) , (l_439.f1 = (safe_lshift_func_uint16_t_u_u(((((((*l_443) = l_496) == (func_52(((0xA519 ^ (l_501 == ((*l_502) = &l_418))) , (l_504 , l_505))) , l_439.f1)) > l_506) ^ 0xC51A) > l_506), l_439.f2)))) > 0x1CA65634)), l_496)) == l_506))
                { /* block id: 293 */
                    int32_t l_512 = 0;
                    int32_t l_513 = 2;
                    struct S0 ***l_516 = &l_514;
                    if (((safe_sub_func_uint32_t_u_u((safe_mod_func_int16_t_s_s((+l_512), l_512)), (l_513 = l_439.f1))) < (((*l_516) = l_514) != (void*)0)))
                    { /* block id: 296 */
                        struct S0 **l_517 = &l_515;
                        int32_t l_518 = 0x1D8F2B56;
                        (*l_517) = &l_25;
                        /* statement id: 297 */
                        assert (l_515 == &l_25);
                        if (l_518)
                            break;
                        if (l_513)
                            break;
                    }
                    else
                    { /* block id: 300 */
                        return l_519;
                    }
                    /* facts after branching */
                    assert (l_515 == &l_25);
                    return l_506;
                }
                else
                { /* block id: 304 */
                    int32_t l_520 = 4;
                    struct S0 l_552 = {0x0BA0075E,-5,0x4B27,4294967293U};
                    struct S0 ***l_563 = &l_514;
                    if ((l_520 , (l_521 == l_522)))
                    { /* block id: 305 */
                        uint32_t **l_529 = &l_443;
                        const uint32_t *l_531 = (void*)0;
                        const uint32_t **l_530 = &l_531;
                        uint32_t **l_533 = &l_443;
                        uint32_t ***l_532 = &l_533;
                        uint16_t * const **l_539 = (void*)0;
                        uint16_t * const ***l_538 = &l_539;
                        uint16_t * const ****l_537 = &l_538;
                        int16_t *l_551 = &l_439.f2;
                        int16_t l_555 = (-1);
                        int32_t *l_556 = (void*)0;
                        int32_t l_557 = 1;
                        int32_t *l_558 = (void*)0;
                        int32_t *l_559 = &l_520;
                        l_439.f1 = (((safe_sub_func_uint32_t_u_u(((safe_add_func_uint16_t_u_u((((safe_mul_func_int16_t_s_s(l_506, ((((*l_559) = (l_557 = (((l_529 != ((*l_532) = l_530)) & 4294967288U) != ((l_555 = ((safe_unary_minus_func_uint32_t_u((safe_lshift_func_int16_t_s_u(((l_540 = l_537) == l_546), 6)))) >= ((safe_lshift_func_int16_t_s_s(((*l_551) = 8), (l_552 , ((safe_mod_func_int16_t_s_s(((((*l_502) = (*l_502)) == (void*)0) < l_506), 65529U)) ^ l_17)))) , l_519))) >= l_506)))) >= 0xB1358498) | l_560))) == l_560) < l_489.f0), 0xE0E9)) | l_439.f1), l_519)) , 0x8BC9A249) > l_489.f0);
                        /* statement id: 313 */
                        assert (l_540 == &l_538);
                        assert (l_533 == &l_531);
                    }
                    else
                    { /* block id: 314 */
                        struct S0 ****l_564 = &l_563;
                        int32_t *l_565 = &l_506;
                        (*l_565) = ((safe_mul_func_uint16_t_u_u(l_545, ((l_506 , ((*l_564) = l_563)) == (((*l_443) = l_560) , &l_514)))) , l_560);
                    }
                    for (l_8 = 0; (l_8 <= 32); l_8++)
                    { /* block id: 321 */
                        const uint32_t l_568 = 4294967288U;
                        (*l_491) = l_504;
                        return l_568;
                    }
                }
                (*l_491) = l_569;
                if (l_444)
                    break;
            }
            else
            { /* block id: 328 */
                uint32_t l_572 = 0x421C1DE4;
                int16_t *l_583 = &l_439.f2;
                int32_t l_588 = (-1);
                int32_t *l_589 = &l_506;
                uint32_t *l_596 = &l_587;
                l_439.f1 = (((safe_mul_func_uint16_t_u_u((l_572 & (safe_mod_func_uint16_t_u_u(0xC72F, (safe_mod_func_int16_t_s_s(l_560, 65526U))))), l_572)) , (safe_add_func_int32_t_s_s((safe_add_func_int16_t_s_s(1, ((safe_mod_func_int16_t_s_s(((*l_583) = l_519), l_417)) != (((((safe_mod_func_int16_t_s_s(((l_586 <= l_572) , l_587), 8U)) < 0xBFBDB28F) | l_586) , 0xBBBF) | l_588)))), l_489.f0))) < l_25.f0);
                l_546 = &l_547;
                if ((l_572 && (((*l_589) = l_506) | (((*l_596) = (safe_mod_func_int16_t_s_s(((((l_439.f0 <= ((l_586 > (0U ^ (l_504.f0 = 9))) >= ((*l_443) = ((safe_mod_func_uint16_t_u_u((l_444 >= l_586), l_588)) != l_594)))) | l_560) < 2) || l_439.f2), l_595))) <= 7))))
                { /* block id: 336 */
                    uint16_t l_597 = 8U;
                    (*l_491) = (*l_491);
                    if (l_597)
                        continue;
                    for (l_595 = 0; (l_595 < 17); l_595++)
                    { /* block id: 341 */
                        uint32_t **l_607 = &l_443;
                        uint32_t *** const l_606 = &l_607;
                        int32_t l_614 = 0x123C8516;
                        l_600 = l_443;
                        /* statement id: 342 */
                        assert (l_600 == &l_444);
                        (*l_600) = ((((safe_add_func_uint16_t_u_u(((((0xCA5A9F7F | (*l_600)) > ((~(safe_mul_func_int16_t_s_s(((*l_583) = ((l_606 == (void*)0) , ((safe_lshift_func_uint16_t_u_s(((*l_544) = ((((safe_mul_func_int16_t_s_s(((0xA5FB24FD != (safe_lshift_func_uint16_t_u_s(l_405, 2))) , l_614), (safe_unary_minus_func_uint16_t_u((0x5689A9F8 < (0x1B19 <= l_614)))))) ^ (-6)) || l_614) | l_614)), 11)) || l_560))), l_597))) >= 0xBADC)) , 0x092C463D) < 4294967295U), l_597)) == 0x37E1) & 0x5F2161BB) , (*l_589));
                    }
                }
                else
                { /* block id: 347 */
                    return l_587;
                }
            }
            (*l_617) = l_616;
            for (l_595 = 0; (l_595 >= 41); l_595 = safe_add_func_int32_t_s_s(l_595, 1))
            { /* block id: 354 */
                uint32_t l_620 = 0xD64A8A4F;
                int32_t l_621 = (-1);
                l_621 = (((*l_16) = l_620) || l_506);
                return l_506;
            }
        }
        /* facts after for loop */
        //assert (l_540 == &l_541 || l_540 == dangling);
        assert (l_600 == &l_444 || l_600 == &l_419);
    }
    else
    { /* block id: 360 */
        int32_t l_638 = 5;
        uint16_t **l_647 = &l_16;
        int16_t l_652 = (-1);
        int16_t *l_651 = &l_652;
        struct S1 l_653 = {-1};
        struct S1 *l_655 = &l_653;
        int32_t **l_658 = (void*)0;
        int32_t ***l_657 = &l_658;
        int32_t ****l_656 = &l_657;
        int32_t *****l_659 = &l_656;
        uint32_t l_664 = 8U;
        struct S0 l_671 = {0xD69AE156,3,1,0xFC35FCF6};
        if (((((safe_rshift_func_uint16_t_u_s((*l_418), ((((safe_mul_func_int16_t_s_s((*l_418), (safe_add_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((l_632 == (void*)0), ((*l_651) = (safe_mod_func_uint16_t_u_u(0U, (safe_mul_func_uint16_t_u_u(l_638, (safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u(((safe_sub_func_uint32_t_u_u((l_647 != l_647), ((safe_mul_func_uint16_t_u_u((~l_638), (*l_418))) ^ (***l_632)))) == l_638), (**l_633))), (*l_418))), 0))))))))), 14)), (*l_418))))) >= 0x3CD8) , l_638) | (**l_633)))) , l_638) , 1U) , (***l_632)))
        { /* block id: 362 */
            l_653 = l_504;
        }
        else
        { /* block id: 364 */
            return l_654;
        }
        (*l_655) = l_653;
        (*l_659) = l_656;
        (*l_655) = (((((safe_mul_func_uint16_t_u_u((l_25 , (safe_mul_func_uint16_t_u_u((((((*l_16) = ((((l_664 & ((***l_632) , ((*l_651) = 0x0AE5))) <= (l_665 , 0xFFC5337A)) ^ (l_666 < ((((safe_add_func_uint32_t_u_u(((***l_632) ^ 0x250E), 0xB0A22976)) > (-1)) , 0xA796) == 7U))) > l_669)) , (*l_418)) & (**l_633)) | (-9)), 0xA9FA))), (**l_633))) < 0xC25B) , l_670) , l_671) , (*l_655));
    }
    /* facts after branching */
    assert (l_418 == &l_419 || l_418 == 0);
    for (l_666 = (-1); (l_666 == 52); l_666 = safe_add_func_uint32_t_u_u(l_666, 4))
    { /* block id: 375 */
        int32_t **l_675 = &l_418;
        int32_t ***l_674 = &l_675;
        int32_t l_676 = 5;
        int32_t *l_677 = (void*)0;
        int32_t *l_678 = &l_665;
        const uint32_t l_683 = 4294967295U;
        uint32_t l_687 = 0U;
        int16_t l_689 = 0x1C39;
        uint16_t *l_696 = &l_17;
        int32_t l_702 = 0xBE2BBF9F;
        uint8_t l_721 = 1U;
        struct S1 l_725 = {10};
        int32_t l_727 = (-6);
        struct S1 *l_770 = &l_725;
        struct S1 **l_769 = &l_770;
        struct S1 ***l_768 = &l_769;
        const uint16_t *l_782 = &l_8;
        const uint16_t **l_781 = &l_782;
        const uint16_t ***l_780 = &l_781;
        if ((((l_674 != &l_633) & (((*l_678) = l_676) & ((safe_sub_func_uint32_t_u_u(((safe_lshift_func_int16_t_s_u((l_683 == l_676), (65528U & l_504.f0))) , ((((l_676 > ((0xEF01 != l_686) <= 0x0E8E)) >= l_676) , l_687) , 0xA623CBA5)), 0x677C5DAA)) , l_688))) && l_689))
        { /* block id: 377 */
            const uint16_t *l_694 = &l_8;
            uint16_t **l_695 = &l_16;
            uint32_t *l_699 = &l_687;
            const int32_t l_700 = (-1);
            uint32_t l_703 = 0xBBF6E1E6;
            int32_t l_704 = 0x3DC1306B;
            int16_t l_705 = 1;
            uint32_t l_722 = 0x95A5B8D0;
            int32_t l_724 = 0x98A6B257;
            uint32_t l_756 = 4294967295U;
            struct S1 l_802 = {-4};
            struct S0 l_805 = {1U,-7,8,0x01F14E60};
            if ((((safe_mod_func_int32_t_s_s(((((l_704 = ((safe_mod_func_int16_t_s_s(((((((*l_695) = l_694) != l_696) >= 5U) >= ((safe_mul_func_uint16_t_u_u((0x24D0 != (((*l_678) = (((*l_699) = 7U) && (0x2FF52500 & l_700))) >= 0xF23E1934)), 65535U)) , l_701)) | l_702), l_703)) & 2)) ^ 1) , l_703) || l_705), (-7))) < l_700) && l_700))
            { /* block id: 382 */
                int32_t l_712 = (-1);
                int16_t *l_723 = &l_705;
                const struct S0 l_733 = {3U,2,0xDFCB,0U};
                uint32_t l_794 = 0x37BBB021;
                int32_t l_797 = 0;
                uint32_t *l_801 = &l_794;
                if ((safe_sub_func_int16_t_s_s(((*l_723) = (((((safe_rshift_func_uint16_t_u_u((0xB29A | (safe_lshift_func_int16_t_s_u(l_712, 15))), l_688)) != 0xC726D63E) , (0x4D92 ^ ((safe_rshift_func_uint16_t_u_u(l_700, (safe_mul_func_uint32_t_u_u(((*l_699) = ((l_717 = l_712) < (l_704 = l_712))), ((safe_sub_func_int16_t_s_s((((+l_721) != (*l_678)) , l_705), 7U)) < l_722))))) < l_703))) ^ l_712) ^ l_703)), l_724)))
                { /* block id: 387 */
                    struct S1 *l_726 = &l_725;
                    (*l_726) = l_725;
                    l_727 = l_712;
                }
                else
                { /* block id: 390 */
                    int16_t l_736 = (-4);
                    const uint32_t **l_740 = (void*)0;
                    const uint32_t ***l_739 = &l_740;
                    int32_t l_755 = 0x66DCFDB9;
                    int32_t l_758 = 0;
                    (*l_678) = ((((l_712 && ((void*)0 != l_728)) != ((safe_mod_func_uint32_t_u_u(((l_733 , (safe_lshift_func_int16_t_s_u((l_733.f3 || l_736), 8))) , (safe_lshift_func_uint16_t_u_u(0xC31A, 7))), 3)) | (*l_678))) , l_739) != l_741);
                    (*l_678) = ((((((((safe_mul_func_uint16_t_u_u((l_700 | l_736), (-10))) , ((safe_sub_func_int16_t_s_s(l_722, ((l_712 && 0xEA28B86B) ^ (((safe_mul_func_int16_t_s_s((((((safe_unary_minus_func_uint16_t_u(l_724)) & (((safe_rshift_func_uint16_t_u_s((l_704 = ((((((safe_add_func_uint16_t_u_u(5U, l_712)) != l_705) , l_736) > l_736) >= 3U) & l_736)), l_722)) | 0x183B) == 0x517D3B14)) , (void*)0) == (void*)0) < 65534U), l_755)) ^ l_755) & l_712)))) == 0x8E92)) > l_736) & 0xB319) | 0x8E11) <= l_733.f2) < l_733.f3) == l_756);
                    if (l_733.f3)
                        continue;
                    (*l_678) = ((~(l_758 = ((&l_695 == (void*)0) <= l_722))) != l_733.f0);
                }
                if ((safe_mod_func_int16_t_s_s((safe_add_func_uint16_t_u_u(((l_756 | (!(l_756 > (safe_rshift_func_int16_t_s_u(((void*)0 != l_768), ((safe_unary_minus_func_int16_t_s(l_724)) && 2U)))))) == ((*l_678) = ((void*)0 != &l_729))), ((((*l_723) = (((safe_mod_func_int16_t_s_s(((safe_add_func_int16_t_s_s((0x4D28112C & 0x7FAE9AD4), l_722)) || l_776), 1)) > l_724) && l_722)) || 0x7B20) != l_722))), (-1))))
                { /* block id: 400 */
                    int32_t **l_777 = &l_677;
                    (*l_777) = &l_700;
                    /* statement id: 401 */
                    assert (l_677 == &l_700);
                }
                else
                { /* block id: 402 */
                    for (l_717 = 0; (l_717 >= (-24)); l_717--)
                    { /* block id: 405 */
                        uint16_t ****l_783 = &l_729;
                        (*l_783) = l_780;
                        /* statement id: 406 */
                        assert (l_729 == &l_781);
                    }
                    /* facts after for loop */
                    assert (l_729 == &l_781 || l_729 == &l_730);
                    return l_722;
                }
                /* facts after branching */
                assert (l_677 == &l_700);
                l_802 = func_52(func_28((safe_add_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((-9), ((*l_699) = l_712))), (((*l_16) = (safe_mod_func_uint32_t_u_u((safe_mod_func_uint32_t_u_u(((*l_801) = (((safe_mod_func_uint16_t_u_u((l_794 <= l_724), ((safe_add_func_int16_t_s_s((((l_756 != (l_733.f2 > l_797)) >= (safe_add_func_int32_t_s_s(l_794, l_724))) ^ l_797), l_797)) || l_712))) & 0x138431DE) , l_800)), 1U)), (*l_677)))) , l_794))), l_712, (*l_730), l_723));
            }
            else
            { /* block id: 414 */
                struct S0 l_806 = {3U,7,3,0x2C012FCC};
                struct S0 *l_813 = &l_805;
                struct S0 **l_812 = &l_813;
                struct S0 ***l_811 = &l_812;
                int32_t l_819 = 0;
                for (l_686 = (-16); (l_686 != (-17)); l_686--)
                { /* block id: 417 */
                    int16_t *l_807 = &l_806.f2;
                    int32_t l_814 = 0xFFB6A3B9;
                    struct S0 l_826 = {0xE95A4929,-0,-6,4294967295U};
                    if ((l_805 , ((l_806 , ((*l_807) = l_806.f3)) == (+(((*l_678) = 6) ^ ((((safe_lshift_func_int16_t_s_s(((func_52(l_696) , l_811) != ((l_814 >= (safe_mod_func_int32_t_s_s((((*l_699) = (((safe_sub_func_uint16_t_u_u((((l_806.f1 || l_703) ^ l_814) && (-1)), l_814)) | l_805.f2) == 0xA5746F74)) > l_819), (-5)))) , (void*)0)), l_806.f1)) == l_805.f3) >= l_806.f0) || l_820))))))
                    { /* block id: 421 */
                        const int32_t l_821 = 1;
                        return l_821;
                    }
                    else
                    { /* block id: 423 */
                        uint16_t l_822 = 1U;
                        l_822 = l_805.f3;
                        (*l_678) = l_806.f0;
                        if (l_814)
                            break;
                    }
                    l_826.f1 = ((l_814 <= 1) == (~(safe_add_func_int16_t_s_s((l_826 , l_805.f2), 0x3421))));
                }
            }
            /* facts after branching */
            assert (l_16 == &l_8);
            assert (l_677 == 0 || l_677 == &l_700);
        }
        else
        { /* block id: 431 */
            uint32_t *l_831 = &l_666;
            uint16_t ****l_846 = &l_729;
            uint16_t *****l_845 = &l_846;
            int32_t l_850 = 8;
            for (l_665 = 0; (l_665 < (-28)); l_665 = safe_sub_func_int32_t_s_s(l_665, 6))
            { /* block id: 434 */
                int32_t l_851 = 0x44D772B5;
                int32_t l_853 = (-1);
                uint32_t *l_854 = (void*)0;
                (**l_674) = (*l_675);
                for (l_405 = (-5); (l_405 > 55); l_405 = safe_add_func_uint16_t_u_u(l_405, 6))
                { /* block id: 438 */
                    struct S1 l_836 = {-5};
                    uint16_t *****l_844 = (void*)0;
                    uint8_t l_852 = 3U;
                    int32_t *l_855 = (void*)0;
                    struct S0 **l_874 = (void*)0;
                    struct S0 ***l_873 = &l_874;
                    struct S0 ****l_872 = &l_873;
                    struct S0 ***l_876 = &l_874;
                    struct S0 ****l_875 = &l_876;
                    int16_t l_877 = 0xB0FC;
                    int16_t *l_878 = &l_857;
                    int32_t l_879 = 0x5F87F1B0;
                }
            }
            if (l_850)
                continue;
        }
        /* facts after branching */
        //assert (l_677 == 0 || l_677 == dangling);
    }
    /* facts after for loop */
    assert (l_16 == &l_8 || l_16 == &l_17);
    return l_903;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_2(int32_t  p_3, uint8_t  p_4, uint32_t  p_5, uint8_t  p_6, uint32_t  p_7)
{ /* block id: 233 */
    int32_t l_407 = 0;
    int32_t *l_406 = &l_407;
    int32_t **l_408 = (void*)0;
    int32_t **l_409 = &l_406;
    (*l_409) = l_406;
    (*l_409) = (*l_409);
    return p_7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_20(uint16_t  p_21, const struct S0  p_22, const int16_t  p_23, uint16_t * p_24)
{ /* block id: 163 */
    uint16_t l_290 = 0xCE65;
    int32_t l_291 = 0xF6C0B2D7;
    int32_t l_316 = 0x3D46EF55;
    struct S1 l_322 = {-12};
    int32_t *l_329 = &l_316;
    struct S1 *l_392 = &l_322;
    struct S1 **l_391 = &l_392;
    struct S1 ***l_390 = &l_391;
    struct S1 ****l_400 = &l_390;
    struct S1 *****l_399 = &l_400;
    uint16_t l_403 = 0xA07D;
lbl_388:
    for (p_21 = (-13); (p_21 == 23); p_21 = safe_add_func_int32_t_s_s(p_21, 2))
    { /* block id: 166 */
        uint16_t l_273 = 0xE2F4;
        struct S0 l_277 = {9U,2,-1,0xB9C60537};
        uint32_t *l_289 = (void*)0;
        int32_t l_293 = (-1);
        int32_t *l_292 = &l_293;
        l_277.f1 = ((*l_292) = (safe_mul_func_uint16_t_u_u(l_273, (+(safe_mod_func_int32_t_s_s(((((l_277 , (~l_277.f2)) & (l_277.f3 && p_23)) ^ (safe_sub_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u(65534U, (safe_add_func_uint32_t_u_u((l_277.f1 == ((safe_add_func_uint32_t_u_u((safe_add_func_int16_t_s_s(((l_290 = (0xAFE7 ^ p_23)) <= l_291), p_21)), p_21)) , 0x255FDFF7)), l_291)))), l_277.f2))) >= 4294967295U), l_277.f0))))));
    }
    for (l_290 = 3; (l_290 > 18); l_290++)
    { /* block id: 173 */
        uint32_t l_296 = 2U;
        uint32_t l_313 = 0x2D425E7F;
        uint32_t *l_312 = &l_313;
        uint32_t **l_311 = &l_312;
        uint32_t ***l_310 = &l_311;
        int16_t l_315 = 0xE3D5;
        int16_t *l_314 = &l_315;
        uint16_t *l_319 = &l_290;
        uint16_t **l_318 = &l_319;
        uint16_t ***l_317 = &l_318;
        struct S1 l_362 = {3};
        int32_t *l_365 = (void*)0;
        if (((((l_296 ^ ((l_290 ^ ((safe_sub_func_uint32_t_u_u(1U, (l_316 = ((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_u(l_296, 6)), (safe_mul_func_int16_t_s_s(0xF477, ((*l_314) = (p_22.f0 && (safe_unary_minus_func_int16_t_s((safe_mul_func_int16_t_s_s(((void*)0 == l_310), (65535U > p_21))))))))))), 1)) , l_296)))) >= l_313)) > 0x6B29)) , l_317) == (void*)0) ^ 1U))
        { /* block id: 176 */
            if (p_23)
            { /* block id: 177 */
                int32_t *l_327 = (void*)0;
                int32_t **l_328 = &l_327;
                for (l_316 = 22; (l_316 == (-28)); l_316 = safe_sub_func_int16_t_s_s(l_316, 9))
                { /* block id: 180 */
                    struct S1 *l_323 = &l_322;
                    int32_t *l_324 = &l_316;
                    const int32_t *l_326 = &l_316;
                    const int32_t **l_325 = &l_326;
                    (*l_323) = l_322;
                    (*l_325) = l_324;
                }
                (*l_328) = l_327;
                (*l_328) = (l_329 = (void*)0);
                /* statement id: 186 */
                assert (l_329 == 0);
            }
            else
            { /* block id: 187 */
                for (p_21 = 0; (p_21 == 39); p_21 = safe_add_func_uint16_t_u_u(p_21, 3))
                { /* block id: 190 */
                    int32_t l_334 = 0x5AC172C5;
                    int32_t **l_335 = &l_329;
                    for (l_291 = (-1); (l_291 >= (-1)); l_291--)
                    { /* block id: 193 */
                        return l_334;
                    }
                    (*l_335) = &l_334;
                    /* statement id: 196 */
                    assert (l_329 == &l_334);
                }
            }
            for (p_21 = (-1); (p_21 < 37); p_21++)
            { /* block id: 201 */
                int32_t **l_338 = &l_329;
                (*l_338) = &l_316;
                /* statement id: 202 */
                assert (l_329 == &l_316);
            }
        }
        else
        { /* block id: 204 */
            int32_t **l_347 = &l_329;
            int32_t **l_348 = (void*)0;
            int32_t *l_350 = &l_316;
            int32_t **l_349 = &l_350;
            int32_t *l_352 = &l_316;
            int32_t **l_351 = &l_352;
            l_362.f0 = (p_22 , ((safe_add_func_uint16_t_u_u(p_23, ((safe_mul_func_uint16_t_u_u((safe_add_func_int16_t_s_s((safe_add_func_uint16_t_u_u((l_312 == ((*l_351) = ((*l_349) = ((*l_347) = l_312)))), (((safe_lshift_func_uint16_t_u_u((!(((p_22.f3 , (((safe_add_func_uint32_t_u_u((0xB745 == l_313), (safe_rshift_func_uint16_t_u_s((safe_rshift_func_int16_t_s_s(0xBA4A, 3)), 6)))) <= (((((p_21 >= 0x62BF) , 0xCA9A) <= p_23) == l_296) & l_322.f0)) | p_21)) & 0x6375581D) || l_322.f0)), 5)) , l_362) , 0x4288))), p_22.f0)), l_296)) , l_296))) == 4294967286U));
            /* statement id: 208 */
            assert (l_329 == &l_313);
            assert (l_350 == &l_313);
            assert (l_352 == &l_313);
            (*l_351) = (void*)0;
            /* statement id: 209 */
            assert (l_352 == 0);
            return l_296;
        }
        for (l_296 = 0; (l_296 < 8); l_296 = safe_add_func_int32_t_s_s(l_296, 9))
        { /* block id: 214 */
            uint32_t l_368 = 0x011F5A42;
            int32_t *l_378 = (void*)0;
            int32_t l_387 = 0x837497FD;
            struct S1 l_402 = {-6};
            l_365 = &l_316;
            /* statement id: 215 */
            assert (l_365 == &l_316);
            if ((*l_365))
                continue;
            for (l_291 = 0; (l_291 != (-10)); l_291 = safe_sub_func_uint16_t_u_u(l_291, 5))
            { /* block id: 219 */
                int32_t **l_379 = (void*)0;
                int32_t **l_380 = &l_329;
                int32_t **l_381 = &l_365;
                int32_t **l_382 = (void*)0;
                int32_t l_386 = 0x3B0A8462;
                struct S1 ***l_389 = (void*)0;
                int32_t l_401 = (-1);
                l_387 = (((***l_310) = (l_368 <= ((safe_mul_func_int16_t_s_s(l_368, (safe_rshift_func_int16_t_s_u((((safe_lshift_func_uint16_t_u_u(((0x30D7 & (!(safe_mul_func_int16_t_s_s(((((l_378 = ((*l_381) = l_378)) != l_312) & 0x72F5) , (l_291 , (!((((safe_add_func_int32_t_s_s((p_22.f0 , (((p_22.f0 | p_22.f0) , l_316) , 0)), (-7))) < p_22.f1) , p_22.f0) >= l_386)))), l_368)))) && 0xFD6FD450), p_22.f3)) > l_313) && 0x8EFB94D2), 10)))) && 0x0CDD90FA))) , p_21);
                /* statement id: 223 */
                assert (l_365 == 0);
                if (l_296)
                    goto lbl_388;
                l_322.f0 = ((((l_389 == l_390) , p_22) , &l_390) == ((safe_sub_func_int32_t_s_s((((func_52(&l_290) , (((safe_lshift_func_uint16_t_u_s(p_22.f0, p_21)) < (safe_mul_func_uint16_t_u_u(((void*)0 == l_399), p_22.f0))) && p_22.f2)) <= p_22.f2) ^ l_401), 0U)) , (void*)0));
            }
            /* facts after for loop */
            assert (l_365 == 0 || l_365 == &l_316);
            (**l_391) = l_402;
        }
        /* facts after for loop */
        assert (l_365 == &l_316 || l_365 == 0);
    }
    (**l_391) = func_52(&l_290);
    return l_403;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t * func_26(uint16_t * p_27)
{ /* block id: 2 */
    uint16_t l_58 = 0x9BB6;
    uint16_t *l_57 = &l_58;
    struct S1 l_60 = {-14};
    struct S1 *l_59 = &l_60;
    uint16_t **l_214 = &l_57;
    struct S0 *l_222 = (void*)0;
    const struct S1 *l_230 = &l_60;
    const struct S1 **l_229 = &l_230;
    const struct S1 ***l_228 = &l_229;
    const struct S1 ****l_227 = &l_228;
    struct S1 ****l_232 = (void*)0;
    struct S1 *****l_231 = &l_232;
    int32_t l_267 = 0xB49479A4;
    int32_t * const l_266 = &l_267;
    if ((((*l_214) = func_28(func_33(((~6) , func_37((func_41(func_46(func_52(p_27), l_57, ((void*)0 == l_59), l_60.f0, (&l_60 != ((l_60.f0 < l_60.f0) , (void*)0))), &l_58, &l_58, p_27) ^ 0x2128C81A), p_27, l_60.f0)), l_60.f0), l_60.f0, l_57, p_27)) == (void*)0))
    { /* block id: 125 */
        uint16_t *l_215 = (void*)0;
        return l_215;
        /* statement id: 126 */
        //assert (func_26_rv == 0);
    }
    else
    { /* block id: 127 */
        int32_t l_226 = (-1);
        int32_t *l_225 = &l_226;
        if (l_60.f0)
        { /* block id: 128 */
            int32_t l_218 = 0xDD512011;
            int32_t *l_217 = &l_218;
            (*l_217) = ((+(l_58 , l_58)) | 0x70539346);
        }
        else
        { /* block id: 130 */
            struct S0 **l_223 = (void*)0;
            struct S0 **l_224 = &l_222;
            for (l_58 = 0; (l_58 == 36); l_58 = safe_add_func_int32_t_s_s(l_58, 6))
            { /* block id: 133 */
                struct S1 **l_221 = &l_59;
                (*l_221) = (void*)0;
                /* statement id: 134 */
                assert (l_59 == 0);
            }
            /* facts after for loop */
            assert (l_59 == 0 || l_59 == &l_60);
            (*l_224) = l_222;
        }
        /* facts after branching */
        assert (l_59 == 0 || l_59 == &l_60);
        (*l_225) = (-1);
    }
    /* facts after branching */
    assert (l_59 == 0 || l_59 == &l_60);
    (*l_231) = l_227;
    /* statement id: 140 */
    assert (l_232 == &l_228);
    for (l_58 = 3; (l_58 > 51); l_58 = safe_add_func_int32_t_s_s(l_58, 8))
    { /* block id: 143 */
        uint32_t l_236 = 0U;
        uint32_t *l_235 = &l_236;
        int32_t l_237 = 0x96341BAE;
        int32_t l_243 = 0x097E5DDE;
        int32_t *l_242 = &l_243;
        int32_t l_245 = 0x08D2602E;
        int32_t *l_244 = &l_245;
        uint16_t *l_246 = (void*)0;
        int16_t l_257 = 0xF2EF;
        int16_t *l_256 = &l_257;
        uint16_t *l_258 = (void*)0;
        uint16_t *l_259 = (void*)0;
        uint16_t *l_260 = (void*)0;
        uint32_t l_262 = 0x2F718E48;
        uint32_t *l_261 = &l_262;
        int16_t l_263 = 0x2E2E;
        if (((((((((l_237 = ((*l_235) = 5U)) || (((*l_261) = (safe_rshift_func_int16_t_s_u((~((((((l_60.f0 = (+(l_237 && ((-1) > ((*l_244) = ((*l_242) = (l_237 = l_58))))))) & (safe_mod_func_uint32_t_u_u(((*l_235) = l_58), (~2)))) , (l_60.f0 = ((*l_244) = (safe_rshift_func_int16_t_s_s((l_58 , ((*l_256) = (safe_sub_func_int32_t_s_s(l_60.f0, ((safe_mod_func_uint32_t_u_u((0x6995 != l_60.f0), 0xA1DE74A5)) <= l_60.f0))))), 2))))) == (*p_27)) , 0xE08CD4FB) && (*l_244))), 7))) && (*l_244))) , l_60.f0) , l_60.f0) > l_263) <= l_58) != 0x74F6A418) , (*l_244)))
        { /* block id: 155 */
            int32_t *l_264 = (void*)0;
            int32_t **l_265 = &l_264;
            (*l_265) = l_264;
        }
        else
        { /* block id: 157 */
            int32_t *l_268 = &l_245;
            l_268 = l_266;
            /* statement id: 158 */
            assert (l_268 == &l_267);
        }
        return p_27;
        /* statement id: 160 */
        //assert (func_26_rv == &l_8 || func_26_rv == &l_17);
    }
    return p_27;
    /* statement id: 162 */
    //assert (func_26_rv == &l_8 || func_26_rv == &l_17);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t * func_28(uint32_t  p_29, int32_t  p_30, uint16_t * p_31, uint16_t * p_32)
{ /* block id: 121 */
    struct S1 *l_209 = (void*)0;
    struct S1 **l_210 = (void*)0;
    struct S1 **l_211 = &l_209;
    uint16_t l_213 = 0x11A4;
    uint16_t *l_212 = &l_213;
    (*l_211) = l_209;
    return p_31;
    /* statement id: 123 */
    //assert (func_28_rv == &l_58 || func_28_rv == &l_8);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_33(uint8_t  p_34, const uint32_t  p_35)
{ /* block id: 118 */
    const uint32_t l_203 = 0xFC347C86;
    uint32_t l_206 = 0xCE665EB5;
    uint32_t *l_205 = &l_206;
    uint32_t **l_204 = &l_205;
    uint32_t ***l_207 = (void*)0;
    uint32_t ***l_208 = &l_204;
    (*l_208) = (((!l_203) || (0x962BC758 && l_203)) , l_204);
    return l_203;
}


/* ------------------------------------------ */
/* 
 * reads : l_8 l_17
 * writes:
 */
static uint8_t  func_37(int32_t  p_38, uint16_t * p_39, int16_t  p_40)
{ /* block id: 90 */
    struct S1 *l_165 = (void*)0;
    struct S1 **l_166 = &l_165;
    struct S1 l_169 = {-0};
    struct S1 *l_168 = &l_169;
    struct S1 **l_167 = &l_168;
    struct S0 l_191 = {0x7B2B2917,5,0xE031,0xB3E7E005};
    uint16_t ** const ***l_192 = (void*)0;
lbl_183:
    (*l_167) = ((*l_166) = l_165);
    /* statement id: 92 */
    assert (l_168 == 0);
    for (p_38 = 0; (p_38 >= (-19)); p_38 = safe_sub_func_uint32_t_u_u(p_38, 1))
    { /* block id: 95 */
        struct S1 l_180 = {6};
        uint16_t l_198 = 0xCF57;
        uint16_t *l_197 = &l_198;
        uint16_t **l_196 = &l_197;
        uint16_t ***l_195 = &l_196;
        uint16_t ****l_194 = &l_195;
        uint16_t *****l_193 = &l_194;
        if (l_169.f0)
            break;
        for (p_40 = 1; (p_40 <= (-29)); p_40--)
        { /* block id: 99 */
            int32_t l_174 = 0x6BB48C35;
            int16_t l_190 = 1;
            int16_t *l_189 = &l_190;
            uint32_t l_200 = 0xB7B0D791;
            uint32_t *l_199 = &l_200;
            int32_t *l_201 = &l_174;
            for (l_174 = 0; (l_174 != 16); l_174 = safe_add_func_int16_t_s_s(l_174, 4))
            { /* block id: 102 */
                int32_t *l_177 = (void*)0;
                int32_t l_179 = 1;
                int32_t *l_178 = &l_179;
                struct S1 l_182 = {15};
                if ((((*l_178) = p_38) & p_38))
                { /* block id: 104 */
                    struct S1 *l_181 = (void*)0;
                    l_182 = (((void*)0 == &p_39) , l_180);
                    return p_38;
                }
                else
                { /* block id: 107 */
                    if (p_38)
                        goto lbl_183;
                }
            }
            (*l_201) = ((safe_mul_func_uint16_t_u_u((l_169.f0 <= 0x8D29CDFB), (((l_180.f0 & l_180.f0) | p_40) ^ (safe_rshift_func_uint16_t_u_u(((safe_unary_minus_func_uint32_t_u(((*l_199) = (((*l_189) = 1) & (l_191 , ((l_192 = l_192) != l_193)))))) != 2), (*p_39)))))) & 0xA7FF);
        }
    }
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads : l_8 l_17
 * writes:
 */
static uint32_t  func_41(uint16_t * p_42, uint16_t * p_43, uint16_t * p_44, uint16_t * p_45)
{ /* block id: 10 */
    int32_t l_64 = 1;
    int32_t *l_63 = &l_64;
    int32_t **l_65 = &l_63;
    int32_t l_104 = 0x691A67D5;
    int32_t *l_103 = &l_104;
    uint32_t l_109 = 0xAFCE2876;
    const uint16_t ****l_114 = (void*)0;
    int32_t l_164 = 0x0ADED112;
    (*l_65) = l_63;
    if ((**l_65))
    { /* block id: 12 */
        uint32_t l_84 = 1U;
        int32_t *l_102 = &l_64;
        uint8_t l_107 = 1U;
        uint16_t l_120 = 2U;
        uint16_t *l_119 = &l_120;
        uint16_t **l_118 = &l_119;
        uint16_t ***l_117 = &l_118;
        uint16_t ****l_116 = &l_117;
        uint16_t *****l_115 = &l_116;
        if ((**l_65))
        { /* block id: 13 */
            const int32_t *l_66 = &l_64;
            uint16_t l_69 = 65535U;
            uint16_t *l_68 = &l_69;
            uint16_t **l_67 = &l_68;
            uint16_t ***l_70 = &l_67;
            uint16_t ***l_71 = (void*)0;
            uint16_t **l_73 = &l_68;
            uint16_t ***l_72 = &l_73;
            uint16_t **l_75 = &l_68;
            uint16_t ***l_74 = &l_75;
            uint16_t **l_77 = (void*)0;
            uint16_t ***l_76 = &l_77;
            (*l_76) = ((*l_74) = ((*l_72) = ((*l_70) = ((((1 || ((0x8B3176A1 ^ (1 ^ (((void*)0 != l_66) < (*l_66)))) != 0xA1B5)) & (0xEEB3 != (-3))) && (**l_65)) , l_67))));
            /* statement id: 17 */
            assert (l_77 == &l_68);
        }
        else
        { /* block id: 18 */
            uint16_t *l_98 = (void*)0;
            uint16_t *l_99 = (void*)0;
            uint16_t l_101 = 0x3925;
            uint16_t *l_100 = &l_101;
            int32_t *l_105 = &l_64;
            int32_t **l_106 = &l_105;
            int32_t l_108 = 0;
            struct S1 l_112 = {-13};
            struct S1 *l_111 = &l_112;
            struct S1 **l_113 = &l_111;
            if ((safe_mod_func_uint32_t_u_u((((safe_rshift_func_uint16_t_u_u((l_108 = (safe_lshift_func_int16_t_s_s((l_84 != ((((((((safe_mul_func_int16_t_s_s(((((~(safe_mul_func_uint16_t_u_u(((((safe_mod_func_int16_t_s_s((safe_mul_func_uint16_t_u_u((**l_65), ((safe_mod_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_u((6U < l_84), (((*l_100) = ((*p_44) = (*p_44))) , ((l_103 = l_102) != ((*l_106) = l_105))))) ^ ((((*p_45) || ((65534U || (*l_63)) && 0x7826)) >= (-4)) && 0x320C)), (**l_65))) & (*l_63)))), (*l_102))) , (*l_102)) != 0x12D9) ^ (**l_65)), 0x7ADB))) , 0x9D53036C) >= 0xFD73FCFB) , (*l_102)), l_107)) , (*l_103)) , (**l_106)) , (void*)0) == (void*)0) || (*l_102)) >= (*l_102)) == (*l_63))), (*l_102)))), (**l_65))) || (*l_102)) >= (*l_63)), (*l_63))))
            { /* block id: 24 */
                (*l_65) = l_102;
                return l_109;
            }
            else
            { /* block id: 27 */
                int32_t *l_110 = &l_104;
                (*l_106) = l_102;
                (*l_65) = (*l_65);
                l_102 = l_110;
                /* statement id: 30 */
                assert (l_102 == &l_104);
            }
            /* facts after branching */
            assert (l_102 == &l_104);
            assert (l_103 == &l_64);
            (*l_113) = l_111;
        }
        /* facts after branching */
        assert (l_102 == &l_104 || l_102 == &l_64);
        assert (l_103 == &l_64 || l_103 == &l_104);
        (*l_115) = l_114;
        /* statement id: 34 */
        assert (l_116 == 0);
    }
    else
    { /* block id: 35 */
        int32_t *l_121 = &l_104;
        (*l_65) = l_121;
        /* statement id: 36 */
        assert (l_63 == &l_104);
        for (l_104 = 0; (l_104 > 15); l_104++)
        { /* block id: 39 */
            int32_t l_126 = 0;
            struct S0 l_129 = {0x68CE927C,-7,0x208E,2U};
            struct S1 *l_141 = (void*)0;
            struct S1 ** const l_140 = &l_141;
            struct S1 ** const *l_139 = &l_140;
            uint16_t ***l_156 = (void*)0;
            uint16_t ****l_155 = &l_156;
            uint16_t *****l_154 = &l_155;
            int32_t *l_162 = (void*)0;
            (*l_65) = (*l_65);
            if ((*l_121))
                continue;
            for (l_109 = 0; (l_109 < 4); l_109 = safe_add_func_int16_t_s_s(l_109, 8))
            { /* block id: 44 */
                int32_t *l_132 = &l_104;
                struct S1 **l_144 = &l_141;
                struct S1 ***l_143 = &l_144;
                struct S1 ****l_142 = &l_143;
                if (l_126)
                    break;
                for (l_64 = (-24); (l_64 >= (-3)); l_64 = safe_add_func_uint32_t_u_u(l_64, 5))
                { /* block id: 48 */
                    uint16_t l_133 = 0x7563;
                    int32_t *l_134 = &l_126;
                    if ((l_129 , ((*l_134) = (safe_mod_func_uint32_t_u_u((((*l_63) , l_132) == &l_126), l_133)))))
                    { /* block id: 50 */
                        struct S1 l_135 = {2};
                        struct S1 *l_136 = &l_135;
                        (*l_136) = l_135;
                    }
                    else
                    { /* block id: 52 */
                        (*l_65) = (*l_65);
                    }
                    (*l_134) = (safe_rshift_func_uint16_t_u_s(((*p_42) = ((*l_132) & l_129.f0)), (3 & (*l_134))));
                }
                (*l_142) = l_139;
                /* statement id: 58 */
                assert (l_143 == &l_140);
                for (l_126 = (-2); (l_126 != (-19)); l_126 = safe_sub_func_int16_t_s_s(l_126, 1))
                { /* block id: 61 */
                    int32_t *l_149 = (void*)0;
                    for (l_64 = 0; (l_64 != (-26)); l_64--)
                    { /* block id: 64 */
                        l_149 = (void*)0;
                    }
                }
            }
            for (l_109 = 11; (l_109 < 26); l_109++)
            { /* block id: 71 */
                uint16_t l_163 = 0x3E2D;
                for (l_129.f3 = 0; (l_129.f3 == 39); l_129.f3 = safe_add_func_int32_t_s_s(l_129.f3, 3))
                { /* block id: 74 */
                    int32_t *l_157 = &l_64;
                    (*l_157) = ((void*)0 == l_154);
                    if (l_129.f2)
                        continue;
                    return l_129.f0;
                }
                for (l_64 = (-29); (l_64 >= 13); l_64 = safe_add_func_int16_t_s_s(l_64, 1))
                { /* block id: 81 */
                    struct S1 l_161 = {-0};
                    struct S1 *l_160 = &l_161;
                    (*l_160) = func_52(p_44);
                    l_162 = (void*)0;
                }
                l_163 = (*l_121);
            }
        }
    }
    /* facts after branching */
    assert (l_63 == &l_104 || l_63 == &l_64);
    assert (l_103 == &l_64 || l_103 == &l_104);
    return l_164;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t * func_46(struct S1  p_47, uint16_t * p_48, uint32_t  p_49, int32_t  p_50, uint8_t  p_51)
{ /* block id: 7 */
    struct S1 l_61 = {-7};
    struct S1 *l_62 = &l_61;
    (*l_62) = l_61;
    return p_48;
    /* statement id: 9 */
    //assert (func_46_rv == &l_58 || func_46_rv == &l_857);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_52(uint16_t * p_53)
{ /* block id: 3 */
    struct S1 l_54 = {-2};
    struct S1 *l_55 = &l_54;
    struct S1 l_56 = {-13};
    l_54 = l_54;
    l_55 = &l_54;
    return l_56;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 187
   depth: 1, occurrence: 29
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 48
breakdown:
   indirect level: 0, occurrence: 29
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 18
breakdown:
   indirect level: 0, occurrence: 18
XXX times a bitfields struct's address is taken: 22
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 43
XXX times a single bitfield on LHS: 12
XXX times a single bitfield on RHS: 37

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 196
   depth: 2, occurrence: 39
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 3
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 1
   depth: 41, occurrence: 1

XXX total number of pointers: 282

XXX times a variable address is taken: 243
XXX times a pointer is dereferenced on RHS: 90
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 16
   depth: 3, occurrence: 7
XXX times a pointer is dereferenced on LHS: 148
breakdown:
   depth: 1, occurrence: 139
   depth: 2, occurrence: 5
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 652

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 423
   level: 2, occurrence: 117
   level: 3, occurrence: 80
   level: 4, occurrence: 2
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 143
XXX number of pointers point to scalars: 113
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 22.7
XXX average alias set size: 1.17

XXX times a non-volatile is read: 821
XXX times a non-volatile is write: 398
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 189
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 23
   depth: 2, occurrence: 34
   depth: 3, occurrence: 39
   depth: 4, occurrence: 42
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 22.9
XXX percentage an existing variable is used: 77.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

