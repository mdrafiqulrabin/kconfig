/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      686759638
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
inline static int16_t  func_6(int32_t  p_7, uint64_t  p_8, uint32_t  p_9, int32_t  p_10, uint64_t  p_11);
inline static int16_t  func_15(int32_t  p_16, uint64_t  p_17, uint32_t  p_18, int32_t  p_19, uint16_t  p_20);
static int32_t ** func_37(int32_t ** p_38, uint16_t  p_39);
inline static int32_t ** func_40(int32_t ** p_41, int32_t * p_42, int32_t * p_43);
static int32_t * func_45(int32_t * p_46, int32_t  p_47, int32_t * p_48, int32_t ** p_49, int32_t ** p_50);
static int32_t * func_51(int32_t  p_52, int32_t ** p_53, const int32_t  p_54, uint64_t  p_55, int16_t  p_56);
static int32_t ** func_63(int32_t  p_64, uint64_t  p_65);
static int32_t  func_66(float  p_67, uint32_t  p_68, int32_t ** p_69, int64_t  p_70, int32_t  p_71);
inline static uint16_t  func_75(int32_t  p_76, uint32_t  p_77, float * p_78, const int64_t  p_79);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_2 = 0x0890L;
    uint32_t l_12 = 18446744073709551611UL;
    float l_23 = 0x8.85B647p+79;
    int32_t l_33 = 0x53FC2F92L;
    int32_t *l_32 = &l_33;
    uint64_t l_34 = 18446744073709551615UL;
    int32_t l_719 = 0x53A24B9DL;
    float *l_720 = (void*)0;
    float *l_721 = &l_23;
    uint32_t l_747 = 0x89398787L;
    int64_t l_748 = 0xCA9A6FF2D620C7C5LL;
    uint32_t l_749 = 4294967295UL;
    int32_t **l_751 = &l_32;
    int32_t ***l_750 = &l_751;
    int32_t **l_752 = &l_32;
    (*l_721) = (l_2 < (safe_add_func_float_f_f((-(func_6(l_12, l_2, l_12, (safe_add_func_uint64_t_u_u(((((0x9226C312FBB6BC3ELL | ((func_15((safe_mod_func_uint32_t_u_u(4294967295UL, l_2)), l_2, (safe_add_func_int16_t_s_s((safe_mod_func_int32_t_s_s(((*l_32) = (safe_mod_func_uint64_t_u_u((safe_mod_func_uint32_t_u_u((l_2 < 0x356A0B34L), l_2)), l_2))), l_12)), l_12)), l_2, l_34) , 18446744073709551610UL) <= l_34)) == l_2) & l_34) & l_2), l_2)), l_12) , l_719)), l_719)));
    (*l_752) = func_45(&l_33, (~1UL), &l_33, ((*l_750) = (((!(((safe_div_func_int32_t_s_s(((safe_sub_func_uint16_t_u_u((0x83677CD3L < ((*l_32) , (safe_rshift_func_uint16_t_u_s((safe_rshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_u((safe_div_func_uint64_t_u_u((~(safe_div_func_uint64_t_u_u((safe_add_func_int16_t_s_s(((((0x47091ED3D61BDEADLL < ((((safe_rshift_func_int16_t_s_s((*l_32), 10)) , ((safe_mul_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u((*l_32), 0xB2D10E07L)) || l_747), (*l_32))) > (*l_32))) , (*l_32)) ^ (*l_32))) , (*l_32)) >= 0xB7E7L) <= (*l_32)), (*l_32))), l_748))), (*l_32))), (*l_32))), (*l_32))), 5)))), l_749)) , (*l_32)), (*l_32))) | 1UL) == 0xBEC8L)) , (*l_32)) , &l_32)), &l_32);
    /* statement id: 277 */
    assert (l_32 == 0);
    return l_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_6(int32_t  p_7, uint64_t  p_8, uint32_t  p_9, int32_t  p_10, uint64_t  p_11)
{ /* block id: 112 */
    uint64_t l_401 = 0x1FA74C0A3D9820A3LL;
    int32_t *l_406 = (void*)0;
    int32_t **l_405 = &l_406;
    int16_t l_525 = 0x1C55L;
    int16_t *l_524 = &l_525;
    int16_t *l_527 = (void*)0;
    int64_t l_531 = 0x8E14CA5DCCD833A2LL;
    int64_t *l_530 = &l_531;
    int32_t l_537 = 8L;
    int32_t *l_536 = &l_537;
    uint32_t l_577 = 1UL;
    uint32_t *l_576 = &l_577;
    uint16_t l_584 = 0xA1C6L;
    uint16_t *l_583 = &l_584;
    float l_600 = 0x1.9p-1;
    float *l_599 = &l_600;
    float **l_598 = &l_599;
    const uint32_t l_628 = 1UL;
    int32_t ***l_707 = &l_405;
    int32_t ****l_706 = &l_707;
    float l_711 = 0x3.F1F9B5p-44;
    int16_t l_718 = 0xEECBL;
    for (p_9 = 12; (p_9 < 9); p_9 = safe_sub_func_uint32_t_u_u(p_9, 2))
    { /* block id: 115 */
        int16_t l_383 = 0xD910L;
        int32_t *l_393 = (void*)0;
        int32_t **l_392 = &l_393;
        int32_t l_403 = 1L;
        int32_t *l_402 = &l_403;
        for (p_8 = (-14); (p_8 > 11); p_8 = safe_add_func_int32_t_s_s(p_8, 1))
        { /* block id: 118 */
            int16_t l_395 = 6L;
            int16_t *l_394 = &l_395;
            int16_t l_397 = (-2L);
            int16_t *l_396 = &l_397;
            int32_t l_400 = 0L;
            int32_t **l_404 = (void*)0;
            (*l_402) = (0xE402519024F5588DLL < (((*l_394) = (~((-1L) | (safe_mod_func_uint32_t_u_u(((((*l_392) = &p_10) != (*l_405)) || (**l_392)), 1L))))) & 0xB1C7L));
            /* statement id: 123 */
            assert (l_393 == &p_10);
        }
        /* facts after for loop */
        assert (l_393 == &p_10 || l_393 == 0);
        if (p_11)
            break;
        if ((*l_402))
            break;
    }
    for (p_9 = 0; (p_9 <= 12); p_9 = safe_add_func_int32_t_s_s(p_9, 1))
    { /* block id: 130 */
        float l_414 = (-0x5.4p+1);
        int32_t l_415 = 7L;
        int32_t l_433 = 0xE18AC25AL;
        int32_t **l_434 = &l_406;
        uint32_t l_452 = 0x17CAF55BL;
        uint32_t *l_451 = &l_452;
        float *l_511 = (void*)0;
        float **l_510 = &l_511;
        int16_t l_555 = 0L;
        uint16_t *l_585 = &l_584;
        const int64_t *l_641 = (void*)0;
        uint32_t l_673 = 0x19F7B850L;
        for (p_10 = (-4); (p_10 > 13); p_10 = safe_add_func_uint64_t_u_u(p_10, 5))
        { /* block id: 133 */
            int32_t *l_411 = (void*)0;
            int32_t *l_420 = &l_415;
            uint32_t l_424 = 5UL;
            uint32_t *l_423 = &l_424;
            int32_t **l_435 = &l_411;
            float *l_436 = &l_414;
            (*l_435) = ((*l_434) = &p_10);
            /* statement id: 137 */
            assert (l_406 == &p_10);
            assert (l_411 == &p_10);
            (*l_436) = 0x6.8CA31Ap-84;
        }
    }
    /* facts after for loop */
    assert (l_406 == &p_10 || l_406 == 0);
    for (p_8 = 23; (p_8 > 9); p_8--)
    { /* block id: 256 */
        const int32_t l_697 = 0x459D92BCL;
        float *l_704 = &l_600;
        int32_t ***l_705 = (void*)0;
        const int32_t *l_710 = &l_537;
        const int32_t **l_709 = &l_710;
        const int32_t ***l_708 = &l_709;
        int16_t l_712 = 0x160CL;
        int64_t *l_714 = (void*)0;
        (**l_708) = ((***l_706) = func_51((*l_536), func_63((l_697 || (safe_lshift_func_int16_t_s_s((safe_div_func_uint64_t_u_u(((l_697 ^ (safe_mod_func_int64_t_s_s(((((*l_598) = l_704) != l_704) == ((((*l_530) = l_697) ^ ((*l_536) && (l_705 == ((((l_706 != &l_707) >= 1L) <= p_11) , l_708)))) , p_9)), p_8))) > (-1L)), p_7)), 3))), p_9), p_11, (*l_710), l_712));
        /* statement id: 260 */
        assert (l_406 == 0);
        assert (l_710 == 0);
        if (((safe_unary_minus_func_int64_t_s(p_10)) || (l_714 == &l_531)))
        { /* block id: 261 */
            p_10 = (p_7 > p_10);
            (*l_405) = &p_10;
            /* statement id: 263 */
            assert (l_406 == &p_10);
        }
        else
        { /* block id: 264 */
            int64_t l_715 = (-1L);
            return l_715;
        }
        /* facts after branching */
        assert (l_406 == &p_10);
        for (l_401 = (-5); (l_401 != 43); l_401 = safe_add_func_uint16_t_u_u(l_401, 8))
        { /* block id: 269 */
            (***l_707) = p_9;
        }
    }
    (**l_707) = &p_10;
    /* statement id: 273 */
    assert (l_406 == &p_10);
    return l_718;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_15(int32_t  p_16, uint64_t  p_17, uint32_t  p_18, int32_t  p_19, uint16_t  p_20)
{ /* block id: 2 */
    float l_35 = 0x4.26D5D6p-67;
    int32_t l_36 = (-8L);
    int32_t **l_44 = (void*)0;
    int32_t l_308 = (-1L);
    int32_t *l_307 = &l_308;
    int32_t l_340 = 1L;
    int64_t l_341 = (-2L);
    uint16_t l_362 = 0xB509L;
    uint16_t *l_361 = &l_362;
    uint64_t l_366 = 3UL;
    uint64_t *l_365 = &l_366;
    uint64_t **l_367 = &l_365;
    int32_t l_368 = 0x7A8684C5L;
    float *l_369 = &l_35;
    if (l_36)
    { /* block id: 3 */
        float *l_72 = &l_35;
        int32_t l_82 = (-2L);
        uint32_t l_114 = 0x1A9D0E46L;
        uint32_t *l_113 = &l_114;
        int32_t *l_116 = &l_36;
        int32_t **l_115 = &l_116;
        int64_t l_204 = (-9L);
        int64_t *l_203 = &l_204;
        int32_t l_205 = 0xFE2E0279L;
        int32_t **l_264 = &l_116;
        uint16_t l_322 = 0xCF5AL;
        const int16_t l_326 = 2L;
        const int16_t *l_325 = &l_326;
        int64_t l_329 = 7L;
        int16_t *l_342 = (void*)0;
        int16_t l_344 = 0L;
        int16_t *l_343 = &l_344;
        int32_t l_345 = 0x9E36AF4DL;
        l_264 = func_37(func_40(l_44, func_45(((*l_264) = func_51((safe_mul_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u((safe_sub_func_int64_t_s_s(((*l_203) = (0x101EL || (((p_16 , (l_115 = func_63(func_66(((*l_72) = p_19), (p_18 , ((*l_113) = ((l_82 = ((safe_sub_func_int16_t_s_s(((func_75((l_72 != ((safe_div_func_uint64_t_u_u(l_82, ((0xD63CL ^ ((1UL && p_16) > 0L)) | p_17))) , (void*)0)), l_82, l_72, p_18) && 0UL) < l_82), l_82)) != l_82)) >= p_18))), l_115, p_16, p_18), p_20))) == l_44) , 2UL))), l_205)), 0UL)) == 0x7603D44B8B315883LL), l_205)), l_44, p_20, p_16, p_16)), p_20, &l_205, l_264, l_264), l_307), p_19);
        /* statement id: 93 */
        assert (l_116 == 0);
        assert (l_115 == &l_116 || l_115 == 0);
        assert (l_264 == 0);
        p_19 = (p_16 <= (l_322 <= (((safe_sub_func_uint16_t_u_u((l_325 == (void*)0), ((safe_mod_func_uint64_t_u_u(((((p_20 <= l_329) == ((*l_343) = (((safe_mul_func_uint16_t_u_u((safe_div_func_int32_t_s_s((safe_mul_func_int16_t_s_s((safe_mul_func_int16_t_s_s((((&p_18 == ((p_18 > ((safe_div_func_uint32_t_u_u(l_340, p_20)) || 0xE64FL)) , &p_18)) >= p_20) , p_19), l_341)), (*l_307))), p_16)), 0L)) , (*l_307)) && 0UL))) != l_345) || 0xC6549830L), p_18)) , 65535UL))) , p_16) >= (*l_307))));
    }
    else
    { /* block id: 96 */
        uint32_t l_346 = 18446744073709551615UL;
        int32_t l_347 = 1L;
        float *l_348 = &l_35;
        (*l_348) = (l_347 = l_346);
    }
    (*l_369) = (safe_div_func_float_f_f(0x1.6p-1, (safe_mul_func_float_f_f(p_18, (safe_add_func_float_f_f((p_20 >= (safe_div_func_float_f_f(0x1.5p-1, ((safe_sub_func_int16_t_s_s((p_17 < (safe_sub_func_uint16_t_u_u(((*l_361) = p_16), ((p_20 >= (-5L)) > (((safe_mul_func_uint16_t_u_u((((*l_367) = l_365) != &l_366), l_368)) >= p_20) < p_19))))), (*l_307))) , p_19)))), (*l_307)))))));
    for (l_340 = 0; (l_340 < (-6)); l_340 = safe_sub_func_int64_t_s_s(l_340, 4))
    { /* block id: 105 */
        float **l_372 = (void*)0;
        float ***l_373 = &l_372;
        int32_t *l_374 = (void*)0;
        int32_t **l_375 = &l_307;
        (*l_369) = (-0x10.1p-1);
        (*l_373) = l_372;
        (*l_375) = l_374;
        /* statement id: 108 */
        assert (l_307 == 0);
        if (p_17)
            continue;
    }
    /* facts after for loop */
    assert (l_307 == 0 || l_307 == &l_308);
    return p_20;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_37(int32_t ** p_38, uint16_t  p_39)
{ /* block id: 90 */
    const float l_319 = 0xA.149198p-18;
    float l_321 = 0x3.7F35A2p-97;
    float *l_320 = &l_321;
    (*l_320) = l_319;
    return p_38;
    /* statement id: 92 */
    //assert (func_37_rv == 0 || func_37_rv == &l_536);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_40(int32_t ** p_41, int32_t * p_42, int32_t * p_43)
{ /* block id: 87 */
    const uint32_t l_311 = 0xA7B99C51L;
    int64_t l_313 = 5L;
    int64_t *l_312 = &l_313;
    int32_t *l_315 = (void*)0;
    int32_t **l_314 = &l_315;
    int32_t **l_316 = &l_315;
    int32_t **l_317 = &l_315;
    int32_t **l_318 = (void*)0;
    (*p_43) = ((safe_rshift_func_uint16_t_u_u(65534UL, l_311)) & ((void*)0 == l_312));
    return l_318;
    /* statement id: 89 */
    //assert (func_40_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_45(int32_t * p_46, int32_t  p_47, int32_t * p_48, int32_t ** p_49, int32_t ** p_50)
{ /* block id: 68 */
    int32_t l_273 = 0xFB03A117L;
    uint32_t l_275 = 1UL;
    uint32_t l_282 = 4294967295UL;
    uint32_t l_284 = 0x32EA9840L;
    uint32_t *l_283 = &l_284;
    uint16_t l_289 = 1UL;
    int32_t l_290 = (-1L);
    int16_t l_292 = 8L;
    int16_t *l_291 = &l_292;
    uint32_t *l_293 = (void*)0;
    uint32_t l_295 = 0x9FA3D070L;
    uint32_t *l_294 = &l_295;
    float l_296 = 0xE.940A22p-96;
    const int64_t *l_299 = (void*)0;
    int64_t l_301 = 0x478DB606F9668296LL;
    int64_t *l_300 = &l_301;
    (*p_48) = ((safe_sub_func_uint16_t_u_u(p_47, 0xD6DEL)) , (safe_mul_func_uint16_t_u_u(((safe_sub_func_int64_t_s_s((safe_div_func_int32_t_s_s((l_273 = ((((l_273 || ((~0UL) & ((l_275 >= ((*l_294) = (safe_mod_func_uint16_t_u_u(l_273, (safe_lshift_func_int16_t_s_s(((*l_291) = (safe_add_func_int64_t_s_s((((*l_283) = (l_282 = p_47)) , (l_290 = (l_275 , (safe_mod_func_int32_t_s_s(((safe_rshift_func_uint16_t_u_u((l_289 & p_47), 1)) ^ l_289), 0xF9D19914L))))), l_289))), p_47)))))) , 7L))) < l_275) & p_47) , (*p_48))), l_289)), p_47)) , 0xA60EL), (-1L))));
    (*p_49) = func_51(l_289, (p_50 = &p_46), p_47, (((*l_294) = ((((safe_rshift_func_int16_t_s_s(3L, 0)) | (l_273 == ((l_299 = l_299) == l_300))) || (safe_mod_func_int64_t_s_s((!(&l_275 != &l_284)), p_47))) && 0xE526L)) >= p_47), l_284);
    /* statement id: 79 */
    assert (p_50 == &p_46);
    for (l_301 = 0; (l_301 > 6); l_301 = safe_add_func_int64_t_s_s(l_301, 6))
    { /* block id: 82 */
        (*p_50) = &l_273;
        /* statement id: 83 */
        assert (p_46 == &l_273);
        (*p_49) = (*p_49);
    }
    /* facts after for loop */
    //assert (p_46 == &l_273 || p_46 == 0 || p_46 == &l_446 || p_46 == &l_33);
    return (*p_49);
    /* statement id: 86 */
    //assert (func_45_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_51(int32_t  p_52, int32_t ** p_53, const int32_t  p_54, uint64_t  p_55, int16_t  p_56)
{ /* block id: 46 */
    uint16_t l_208 = 0UL;
    int32_t l_246 = (-1L);
    int32_t *l_245 = &l_246;
    int32_t *l_247 = (void*)0;
    int32_t l_249 = 0x42145396L;
    int16_t l_256 = 0x1ADAL;
    const int16_t *l_255 = &l_256;
    const int16_t **l_254 = &l_255;
    int32_t *l_257 = &l_249;
    int32_t **l_259 = &l_247;
    int32_t ***l_258 = &l_259;
    float l_261 = 0x1.8p+1;
    float *l_260 = &l_261;
    int32_t *l_263 = (void*)0;
lbl_262:
    if (((safe_lshift_func_int16_t_s_u(l_208, 12)) ^ l_208))
    { /* block id: 47 */
        const uint32_t l_222 = 0x36E2BBFEL;
        for (p_52 = (-11); (p_52 <= 16); p_52 = safe_add_func_uint64_t_u_u(p_52, 9))
        { /* block id: 50 */
            uint16_t *l_213 = &l_208;
            int16_t *l_215 = (void*)0;
            int16_t **l_214 = &l_215;
            int16_t l_234 = (-9L);
            int16_t *l_233 = &l_234;
            int32_t l_235 = 0x5A3F0290L;
            uint32_t l_237 = 0x9686BF02L;
            uint32_t *l_236 = &l_237;
            uint64_t *l_238 = (void*)0;
            uint64_t l_240 = 0x85341A8226385603LL;
            uint64_t *l_239 = &l_240;
            int32_t *l_241 = &l_235;
            (*l_241) = ((p_55 > (((safe_sub_func_uint16_t_u_u(((*l_213) = 0xA057L), (((*l_214) = (void*)0) == (void*)0))) || (((0xC89E7ADD9F72E6D7LL || (safe_div_func_uint32_t_u_u((((safe_sub_func_uint64_t_u_u(((*l_239) = (safe_mod_func_uint32_t_u_u(((*l_236) = ((((l_222 > (safe_rshift_func_int16_t_s_u(((safe_mod_func_int16_t_s_s(((*l_233) = (safe_rshift_func_uint16_t_u_s((((void*)0 == &l_215) , ((safe_lshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s((p_55 , p_52), 12)), 13)) <= 4294967290UL)), 3))), 0xD7C1L)) ^ 18446744073709551615UL), l_222))) > p_54) & l_235) , p_56)), p_55))), l_222)) != l_235) || l_240), 4294967295UL))) ^ l_208) < l_208)) < 0UL)) & 1L);
        }
    }
    else
    { /* block id: 58 */
        int32_t l_243 = (-1L);
        int32_t *l_242 = &l_243;
        int32_t **l_244 = &l_242;
        (*l_244) = l_242;
        return l_247;
        /* statement id: 60 */
        //assert (func_51_rv == 0);
    }
    (*l_260) = ((p_55 <= (-((l_249 , &l_245) != ((*l_258) = func_63(p_54, (safe_sub_func_int64_t_s_s((safe_mul_func_uint32_t_u_u(p_52, (l_254 == &l_255))), ((((l_257 = l_257) == (p_55 , &l_249)) != p_54) ^ 0xBAFDL)))))))) != p_56);
    /* statement id: 64 */
    assert (l_259 == 0);
    if (l_208)
        goto lbl_262;
    return l_263;
    /* statement id: 66 */
    //assert (func_51_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_63(int32_t  p_64, uint64_t  p_65)
{ /* block id: 27 */
    int32_t *l_133 = (void*)0;
    int32_t l_152 = (-1L);
    int64_t l_162 = 0x9888A1598D8379A3LL;
    int64_t *l_161 = &l_162;
    int32_t l_178 = 0x86BD2DA3L;
    int32_t l_181 = 0x8AE3155DL;
    int16_t l_186 = (-4L);
    int32_t l_187 = 0x19513162L;
    int32_t **l_188 = &l_133;
    int32_t **l_189 = &l_133;
    int32_t **l_190 = &l_133;
    int32_t **l_191 = &l_133;
    int32_t **l_192 = &l_133;
    int32_t **l_193 = &l_133;
    int32_t **l_194 = &l_133;
    int32_t **l_195 = &l_133;
    int32_t **l_196 = &l_133;
    int32_t **l_197 = &l_133;
    int32_t **l_198 = &l_133;
    int32_t **l_199 = &l_133;
    int32_t **l_200 = &l_133;
    int32_t **l_201 = &l_133;
    int32_t **l_202 = (void*)0;
    for (p_64 = 17; (p_64 >= (-26)); p_64 = safe_sub_func_int64_t_s_s(p_64, 1))
    { /* block id: 30 */
        int32_t **l_134 = &l_133;
        int32_t l_147 = 0xF20F69DBL;
        float l_154 = 0xD.DDA0CFp+91;
        float *l_153 = &l_154;
        float l_174 = 0x1.6399BEp-65;
        float *l_173 = &l_174;
        int32_t l_175 = 0xCC145740L;
        uint32_t l_177 = 0x8653E959L;
        uint32_t *l_176 = &l_177;
        float l_180 = 0x3.A8B479p-9;
        float *l_179 = &l_180;
        float l_183 = 0x0.3p+1;
        float *l_182 = &l_183;
        float l_185 = 0x4.Cp-1;
        float *l_184 = &l_185;
        (*l_134) = l_133;
        l_147 = (((safe_mul_func_float_f_f((((safe_mul_func_float_f_f((safe_div_func_float_f_f(((safe_mul_func_float_f_f(((safe_sub_func_float_f_f(((*l_184) = (safe_mul_func_float_f_f(l_147, ((safe_mul_func_float_f_f(((*l_182) = (safe_add_func_float_f_f(((*l_153) = l_152), (l_181 = (safe_div_func_float_f_f((((((((void*)0 == l_153) == ((*l_179) = (l_178 = (safe_mul_func_float_f_f(p_65, (((safe_mul_func_float_f_f((-0x1.2p+1), (l_161 == (((*l_176) = (((safe_lshift_func_int16_t_s_u((safe_mul_func_int16_t_s_s(1L, (safe_div_func_uint32_t_u_u(((((safe_mul_func_int16_t_s_s((((*l_173) = ((safe_add_func_uint32_t_u_u(((((l_133 != l_133) || 0xEC59EA23L) , &l_133) == l_134), p_65)) , 0x4.C885B3p+21)) , l_175), 1L)) ^ 0xE4CEB9145EC307D3LL) , p_64) < l_175), 0xE5966A8FL)))), l_152)) == p_64) , 0x6465E51FL)) , &l_162)))) == 0x8.Bp+1) >= 0x1.7p+1)))))) > 0x7.8CC8C4p+12) != 0x8.Cp+1) >= p_64) < p_65), 0x2.2524E1p+11)))))), p_65)) < p_65)))), p_64)) == p_65), 0xD.0F5FFFp+29)) > l_162), 0x9.FF8C07p+30)), 0xE.04BA90p-22)) >= p_64) != p_64), l_186)) != l_152) != l_187);
        (*l_134) = (void*)0;
    }
    return l_202;
    /* statement id: 43 */
    //assert (func_63_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_66(float  p_67, uint32_t  p_68, int32_t ** p_69, int64_t  p_70, int32_t  p_71)
{ /* block id: 13 */
    int32_t *l_119 = (void*)0;
    int32_t l_122 = 0xD8FC8FA0L;
    uint32_t l_124 = 0x7303F68CL;
    uint32_t *l_123 = &l_124;
    int16_t l_126 = (-1L);
    int16_t *l_125 = &l_126;
    int32_t l_127 = (-4L);
    l_127 = (safe_lshift_func_int16_t_s_u(((((void*)0 == l_119) | (~(l_119 != (((0xCC90FA27L | ((**p_69) = (**p_69))) || (l_122 = (((p_71 || ((*l_125) = ((~((*l_123) = (p_71 || (((l_122 , p_70) == 0xD3BE1F67L) != p_70)))) & 9UL))) && p_70) , p_70))) , (void*)0)))) , p_70), p_70));
    (**p_69) = (**p_69);
    (*p_69) = &l_127;
    /* statement id: 20 */
    //assert (l_116 == &l_127);
    for (p_70 = 0; (p_70 > (-28)); p_70 = safe_sub_func_uint64_t_u_u(p_70, 1))
    { /* block id: 23 */
        uint16_t l_130 = 1UL;
        return l_130;
        /* statement id: 24 */
        //assert (l_116 == dangling);
    }
    return l_122;
    /* statement id: 26 */
    //assert (l_116 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_75(int32_t  p_76, uint32_t  p_77, float * p_78, const int64_t  p_79)
{ /* block id: 5 */
    int32_t l_105 = 0xE1A273DDL;
    int32_t *l_104 = &l_105;
    int32_t **l_103 = &l_104;
    int64_t l_107 = 0L;
    int64_t *l_106 = &l_107;
    uint64_t l_108 = 0x872472F852669728LL;
    float l_110 = 0x9.66C5D8p+80;
    float *l_109 = &l_110;
    (*l_109) = (safe_add_func_float_f_f((((safe_div_func_float_f_f((safe_mul_func_float_f_f(((safe_mod_func_int32_t_s_s((safe_add_func_int16_t_s_s(p_79, (safe_lshift_func_int16_t_s_s((safe_add_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((safe_mod_func_uint64_t_u_u(0UL, p_79)), ((((safe_sub_func_int64_t_s_s(((void*)0 != l_103), (*l_104))) >= ((*l_106) = ((void*)0 != &l_104))) == (p_76 <= p_76)) || (**l_103)))), 65533UL)), (*l_104))))), (*l_104))) , (*l_104)), p_76)), (*l_104))) != p_79) < l_108), 0x1.4p-1));
    (*l_109) = ((safe_sub_func_float_f_f((**l_103), p_79)) != (**l_103));
    (*l_103) = p_78;
    /* statement id: 9 */
    //assert (l_104 == &l_35);
    return p_76;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 148
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 54
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 9, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 21, occurrence: 2
   depth: 27, occurrence: 2
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 34, occurrence: 2
   depth: 53, occurrence: 1
   depth: 54, occurrence: 1

XXX total number of pointers: 182

XXX times a variable address is taken: 172
XXX times a pointer is dereferenced on RHS: 68
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 19
XXX times a pointer is dereferenced on LHS: 123
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 482

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 527
   level: 2, occurrence: 157
   level: 3, occurrence: 16
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 72
XXX number of pointers point to scalars: 110
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.5
XXX average alias set size: 1.19

XXX times a non-volatile is read: 684
XXX times a non-volatile is write: 305
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 66
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 23
   depth: 2, occurrence: 8

XXX percentage a fresh-made variable is used: 12.5
XXX percentage an existing variable is used: 87.5
********************* end of statistics **********************/

