/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --no-pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2030025528
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 10;
   signed f1 : 23;
   float  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_26(void);
static int32_t  func_31(struct S0  p_32);
static struct S0  func_33(int8_t  p_34, float  p_35);
static struct S0  func_48(uint32_t  p_49, uint32_t  p_50, struct S0  p_51, float  p_52, int16_t  p_53);
static uint32_t  func_58(int16_t  p_59, int32_t  p_60, float  p_61, int8_t  p_62);
static uint32_t  func_65(uint32_t  p_66);
static struct S0  func_70(int32_t  p_71, float  p_72, int32_t  p_73, const uint16_t  p_74);
static int32_t  func_78(float  p_79, int8_t  p_80, struct S0  p_81, uint32_t  p_82);
static struct S0  func_83(uint16_t  p_84);
static int16_t  func_85(int8_t  p_86, uint32_t  p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_26(void)
{ /* block id: 36 */
    struct S0 l_27 = {23,-897,0x3.38DC53p-29};
    int32_t l_28 = 1L;
    const int32_t l_408 = 0x1E1CBA1BL;
    int32_t l_409 = 0xAFC5FDFFL;
    int32_t l_414 = 0x085FD940L;
    float l_461 = 0xF.92D70Ap-62;
    float l_501 = 0x0.629844p-54;
    struct S0 l_502 = {6,-157,-0x10.0p-1};
    uint16_t l_515 = 0x4C16L;
lbl_482:
    l_27 = l_27;
    for (l_28 = 17; (l_28 != 1); l_28 -= 1)
    { /* block id: 40 */
        uint16_t l_40 = 65535UL;
        int32_t l_391 = 1L;
        struct S0 l_410 = {29,-2480,-0x1.5p-1};
        int32_t l_421 = 0xEDB2B042L;
        float l_503 = 0x0.3FC86Ep+77;
        int8_t l_518 = (-1L);
        uint16_t l_519 = 65535UL;
        float l_529 = 0x7.5p+1;
        if (func_31(func_33(((0x07DDBF4DL >= ((int16_t)l_27.f0 >> (int16_t)3)) , __builtin_parityll(((((((uint16_t)(((0x9EF8L < l_40) & (((int16_t)(65535UL >= ((int16_t)l_40 * (int16_t)l_40)) - (int16_t)(-5L)) ^ ((-6L) ^ l_28))) , 0x298CL) << (uint16_t)4) < 0x525CL) , l_28) && l_40) != (-5L)))), l_27.f1)))
        { /* block id: 191 */
            int8_t l_377 = 0L;
            int32_t l_388 = 0L;
            int16_t l_389 = 0xBC43L;
            uint16_t l_395 = 0UL;
            struct S0 l_407 = {22,-2100,0xD.6B8790p+83};
            l_388 = ((uint32_t)((int32_t)(-1L) + (int32_t)((l_40 , l_377) && ((int32_t)((int16_t)((((l_40 && l_27.f1) | (((uint16_t)l_40 >> (uint16_t)0) <= ((int16_t)l_27.f0 >> (int16_t)12))) ^ ((l_388 ^ ((func_85(l_389, l_27.f1) > l_40) > l_27.f1)) >= l_28)) , l_377) * (int16_t)l_388) - (int32_t)l_377))) % (uint32_t)l_27.f0);
            l_391 = (((-(float)l_40) == 0x9.C0850Ap-7) != 0x3.7p+1);
            l_27.f1 = (~(l_391 >= (func_78(l_27.f0, (((uint16_t)(((l_395 || (-(int32_t)((uint32_t)((uint16_t)(l_28 >= l_27.f1) - (uint16_t)(l_391 , ((4294967289UL || l_389) , ((int16_t)__builtin_parity(((int32_t)((uint16_t)(((l_407 , l_28) , l_407.f0) && 0xC773L) << (uint16_t)l_407.f1) + (int32_t)l_391)) - (int16_t)(-1L))))) % (uint32_t)l_408))) & l_27.f0) != l_409) << (uint16_t)l_391) == l_408), l_410, l_27.f1) < l_388)));
            if (l_40)
                break;
        }
        else
        { /* block id: 196 */
            struct S0 l_411 = {5,2326,0xF.D080C8p+12};
            int32_t l_415 = 0xEEB9A91AL;
            int16_t l_431 = 0L;
            struct S0 l_452 = {4,-2399,0x1.4p-1};
            int16_t l_481 = 0x6C51L;
            int32_t l_494 = 4L;
            l_27.f1 = 0x8.6DD631p+1;
            if (l_408)
            { /* block id: 198 */
                uint32_t l_429 = 0x582BE5E3L;
                uint32_t l_432 = 0x927304A5L;
                struct S0 l_460 = {21,2307,0xC.7B7ADCp-89};
                l_410 = l_411;
                for (l_391 = 0; (l_391 == (-26)); l_391 -= 4)
                { /* block id: 202 */
                    int32_t l_428 = 0x25053CB1L;
                    if (l_414)
                    { /* block id: 203 */
                        return l_410.f1;
                    }
                    else
                    { /* block id: 205 */
                        int32_t l_430 = 0L;
                        int32_t l_433 = 9L;
                        l_27.f1 = l_415;
                        l_432 = (l_411.f1 == (func_85((!(func_85((((uint32_t)((((((uint16_t)(l_421 < ((((uint16_t)0x9532L - (uint16_t)(((((-1L) && ((uint16_t)((__builtin_ffsl(l_411.f1) >= (((0x719AA14CL | (1L > ((uint16_t)((l_410.f1 , l_428) >= l_411.f1) >> (uint16_t)15))) <= l_429) <= l_430)) , 65534UL) >> (uint16_t)l_428)) & 0x54F2L) && 0x6BD8L) || l_429)) || l_430) , 0xFAD3BD01L)) >> (uint16_t)l_429) | l_27.f1) != 0x5BBDL) | l_430) >= 0x80DCL) - (uint32_t)6L) , 0x91L), l_431) > 0x8CC1155BL)), l_430) <= 0x9.4p+1));
                        l_421 = (-5L);
                        l_433 = (l_432 != 0UL);
                    }
                }
                for (l_415 = 0; (l_415 > 1); l_415 += 1)
                { /* block id: 214 */
                    uint16_t l_448 = 8UL;
                    struct S0 l_451 = {26,-857,0x2.684BF2p+95};
                    l_451 = func_70(l_432, l_411.f1, (((((uint16_t)(((int16_t)(0x7E2D96D4L && (((int32_t)((int16_t)((uint16_t)((uint16_t)l_448 % (uint16_t)((int16_t)__builtin_clzll(l_448) << (int16_t)(((((l_451 , func_83(l_432)) , l_429) & l_414) || l_432) , l_429))) - (uint16_t)l_451.f0) >> (int16_t)l_408) + (int32_t)0x6E28B10FL) ^ 0x3104D623L)) * (int16_t)l_429) | l_451.f0) << (uint16_t)l_448) , l_414) & l_431) && 4294967286UL), l_448);
                    if (__builtin_ia32_crc32qi(l_432, l_27.f1))
                    { /* block id: 216 */
                        l_452 = l_451;
                        l_410 = func_83((l_410.f0 != (l_414 > l_410.f0)));
                    }
                    else
                    { /* block id: 219 */
                        int8_t l_457 = 0x4DL;
                        l_460 = func_70((((((__builtin_ffsl(l_432) > ((((((uint16_t)l_431 >> (uint16_t)14) , (__builtin_ffsll(((int16_t)(8UL <= (l_429 , l_451.f1)) << (int16_t)((func_58(l_457, ((int16_t)(-1L) << (int16_t)11), (l_27.f1 , 0x0.Fp-1), l_408) ^ l_27.f1) ^ l_448))) & 5L)) == 1UL) , 0x6.213159p+24) >= l_391)) , 0x7AC3L) & l_457) ^ (-3L)) , l_457), l_429, l_457, l_432);
                    }
                }
            }
            else
            { /* block id: 223 */
                uint16_t l_462 = 65535UL;
                int32_t l_484 = 0x86AEEF94L;
                if (l_40)
                { /* block id: 224 */
                    int16_t l_480 = (-2L);
                    if (l_462)
                        break;
                    if ((l_40 , 1L))
                    { /* block id: 226 */
                        uint16_t l_479 = 0x0149L;
                        l_481 = (((float)(((float)func_65((((int16_t)(((l_411.f0 || ((uint16_t)(((int16_t)(((int16_t)(l_27.f0 || ((((uint32_t)l_408 % (uint32_t)((l_421 , 0x6FL) , func_65((l_479 == 8UL)))) == ((-6L) <= 0xF981L)) ^ l_462)) << (int16_t)l_411.f0) || 4294967292UL) - (int16_t)l_462) , l_480) >> (uint16_t)l_462)) != l_431) == l_480) >> (int16_t)2) < 1UL)) * (float)l_480) > l_409) * (float)l_410.f1) , l_410.f0);
                        if (l_480)
                            goto lbl_482;
                    }
                    else
                    { /* block id: 229 */
                        int8_t l_483 = 0L;
                        l_484 = l_483;
                    }
                }
                else
                { /* block id: 232 */
                    int16_t l_486 = (-5L);
                    if (l_409)
                    { /* block id: 233 */
                        int8_t l_485 = 0xBDL;
                        l_486 = (l_485 < 0xAB17L);
                        if (l_410.f1)
                            break;
                        l_421 = 0xF0802A14L;
                        if (l_421)
                            continue;
                    }
                    else
                    { /* block id: 238 */
                        l_452.f1 = func_85(((int16_t)(l_410.f1 , l_40) << (int16_t)9), l_486);
                    }
                    return l_40;
                }
                for (l_414 = 0; (l_414 > 24); l_414 += 1)
                { /* block id: 245 */
                    uint16_t l_493 = 1UL;
                    int8_t l_499 = 0xF0L;
                    struct S0 l_500 = {15,-1790,0x6.8602A0p-46};
                    l_27.f1 = (((int16_t)((l_493 , func_78(l_494, l_409, l_452, l_28)) && (((uint16_t)(l_411.f1 == l_410.f0) + (uint16_t)((((uint16_t)l_493 >> (uint16_t)l_493) ^ 1UL) & 4294967295UL)) , l_493)) << (int16_t)l_499) ^ l_40);
                    l_410 = l_500;
                    if (l_431)
                        continue;
                    l_502 = func_83(l_409);
                }
                l_411.f1 = __builtin_ffsll(l_409);
            }
        }
        if (l_27.f1)
            break;
        if ((((int32_t)((((uint16_t)((!l_421) < l_410.f0) * (uint16_t)((func_78(l_410.f0, ((((int16_t)__builtin_parityl(l_28) + (int16_t)((func_58(((uint16_t)l_40 >> (uint16_t)10), l_27.f0, ((float)l_515 + (float)(__builtin_ctzl((((int16_t)l_518 << (int16_t)3) , l_518)) != l_421)), l_502.f1) , l_519) , 0x5EA1L)) | l_40) , 6L), l_410, l_391) | 0x13F15AACL) || l_502.f1)) | l_410.f0) <= 0x2870L) + (int32_t)0xC1212F90L) >= l_410.f1))
        { /* block id: 255 */
            int32_t l_520 = 0x5E591BB0L;
            l_391 = l_520;
            if (l_391)
                break;
        }
        else
        { /* block id: 258 */
            int8_t l_523 = 0xE6L;
            const float l_528 = (-0x1.7p+1);
            int32_t l_530 = 6L;
            l_410.f1 = ((float)__builtin_ffsll(__builtin_ctz(l_523)) * (float)((float)(l_523 <= ((((((l_523 & (l_40 && (l_409 >= (((uint32_t)0xDB7756A1L - (uint32_t)(__builtin_popcountll(l_410.f0) >= 65535UL)) > l_519)))) , l_528) , 3L) & l_40) , l_523) == l_523)) - (float)l_529));
            l_410 = func_83(l_27.f1);
            l_530 = (-3L);
            l_410.f1 = 0xA1A1E9AEL;
        }
    }
    return l_502.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(struct S0  p_32)
{ /* block id: 168 */
    int16_t l_333 = (-1L);
    int16_t l_353 = 0L;
    struct S0 l_361 = {7,-815,0x0.34789Dp-53};
    int32_t l_369 = (-1L);
    p_32.f2 = p_32.f0;
    if (((!func_65(l_333)) , 1L))
    { /* block id: 170 */
        uint32_t l_346 = 0UL;
        int16_t l_355 = 0xA341L;
        p_32.f1 = (((uint16_t)((((((((int32_t)((((int16_t)(-2L) * (int16_t)(0xD79EL >= ((int16_t)l_333 << (int16_t)8))) && ((int16_t)((int16_t)p_32.f0 >> (int16_t)((l_346 == ((int16_t)((uint16_t)0x8E46L * (uint16_t)((uint32_t)(l_353 >= ((!func_65(l_353)) , l_333)) % (uint32_t)0xFC33572AL)) >> (int16_t)4)) , (-1L))) >> (int16_t)13)) | l_333) - (int32_t)p_32.f1) , l_353) , 65532UL) && p_32.f1) == l_353) && 5L) || p_32.f1) << (uint16_t)l_333) && 1L);
        l_355 = (p_32.f0 != l_346);
        if ((l_353 >= (0x3FEFL & 0xCA37L)))
        { /* block id: 173 */
            struct S0 l_356 = {0,1450,0x7.33A1D2p-99};
            p_32 = l_356;
        }
        else
        { /* block id: 175 */
            uint16_t l_359 = 0xBD17L;
            for (l_346 = 0; (l_346 == 50); l_346 += 1)
            { /* block id: 178 */
                int8_t l_360 = 0x76L;
                if (l_346)
                    break;
                l_359 = p_32.f0;
                return l_360;
            }
            p_32 = p_32;
            l_361 = p_32;
            l_361 = p_32;
        }
    }
    else
    { /* block id: 187 */
        uint32_t l_364 = 1UL;
        int32_t l_372 = 0L;
        l_372 = (((l_361 , l_353) >= ((float)l_364 - (float)((l_333 , l_364) <= ((float)p_32.f0 * (float)(((uint32_t)(l_369 & 8UL) - (uint32_t)((((uint16_t)l_353 << (uint16_t)11) == p_32.f0) , l_353)) , l_364))))) != (-0x1.2p-1));
    }
    return p_32.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_33(int8_t  p_34, float  p_35)
{ /* block id: 41 */
    struct S0 l_219 = {6,-703,0x7.DD99D9p-71};
    uint16_t l_244 = 65535UL;
    int8_t l_297 = 0xC8L;
    uint32_t l_298 = 0x1BC2A71DL;
    for (p_34 = 0; (p_34 < (-3)); p_34--)
    { /* block id: 44 */
        struct S0 l_47 = {18,-2557,0x6.B1D441p+51};
        int32_t l_220 = 7L;
        uint32_t l_253 = 0x952072D0L;
        l_47 = l_47;
        l_219 = func_48(l_47.f0, l_47.f0, l_47, p_34, p_34);
        for (l_220 = 0; (l_220 == 29); l_220 += 7)
        { /* block id: 113 */
            int32_t l_223 = (-3L);
            for (l_223 = (-30); (l_223 != (-18)); l_223 += 1)
            { /* block id: 116 */
                int32_t l_226 = (-9L);
                struct S0 l_270 = {12,-576,0x0.0p+1};
                for (l_226 = 0; (l_226 <= (-2)); l_226 -= 8)
                { /* block id: 119 */
                    struct S0 l_245 = {5,-1425,0xE.15F34Ap+39};
                    if (p_34)
                        break;
                    l_219.f1 = ((int16_t)(func_78(((((0x0.DD6C4Dp-32 > p_34) >= l_223) != ((float)((float)(p_34 > (l_223 , l_220)) * (float)(func_58(((((((uint16_t)l_226 + (uint16_t)(-(uint16_t)((uint16_t)l_226 * (uint16_t)((uint16_t)((int16_t)(-10L) + (int16_t)(-1L)) % (uint16_t)p_34)))) & 2UL) , l_223) > p_34) & p_34), l_244, l_219.f0, p_34) != 0x9.7p-1)) + (float)l_223)) != (-0x1.2p-1)), p_34, l_245, p_34) , p_34) << (int16_t)9);
                    l_219.f1 = p_34;
                    if ((-(uint16_t)((int32_t)0L % (int32_t)__builtin_bswap32(l_245.f0))))
                    { /* block id: 123 */
                        p_35 = p_35;
                    }
                    else
                    { /* block id: 125 */
                        int32_t l_258 = 8L;
                        p_35 = ((__builtin_clzl((p_34 || (((0L >= (0x9B9FL | l_226)) <= 0x1060L) != (p_34 & ((uint16_t)(p_34 <= 0L) << (uint16_t)((int16_t)l_253 >> (int16_t)3)))))) >= 0x1.24B164p+81) != l_223);
                        l_245.f1 = (~(!(((p_34 >= (func_85(((int16_t)p_34 >> (int16_t)((l_258 >= ((uint16_t)((uint16_t)l_219.f1 % (uint16_t)((((uint32_t)(((((0x3A50B06DL | ((((((p_34 | ((((l_244 != (__builtin_parityll(l_226) > p_35)) >= l_245.f1) == p_35) , l_245.f1)) , (-9L)) > p_34) > p_34) && l_226) , l_47.f0)) <= l_223) > l_226) | (-2L)) != 0x3CC6216EL) % (uint32_t)l_258) , p_34) ^ l_226)) * (uint16_t)p_34)) > 0UL)), p_34) >= 0x65C8L)) , l_47.f0) || p_34)));
                    }
                }
                if (p_34)
                    continue;
                if (__builtin_clz(((int16_t)p_34 + (int16_t)(-(uint16_t)p_34))))
                { /* block id: 131 */
                    const int8_t l_279 = 0xFDL;
                    int32_t l_285 = 1L;
                    for (l_253 = (-11); (l_253 < 5); l_253 += 1)
                    { /* block id: 134 */
                        l_47 = l_270;
                        if (p_34)
                            continue;
                        l_285 = ((float)((((int16_t)((int16_t)((uint16_t)l_279 % (uint16_t)l_244) - (int16_t)(func_83(func_58(l_223, ((int32_t)l_226 % (int32_t)((int32_t)l_270.f0 + (int32_t)0xD0F7886DL)), (-(float)p_35), p_34)) , p_34)) % (int16_t)p_34) && l_219.f0) , 0x3.2810F8p+5) + (float)p_34);
                    }
                }
                else
                { /* block id: 139 */
                    return l_270;
                }
            }
            l_223 = ((uint32_t)(l_220 , 1UL) % (uint32_t)((uint16_t)(((uint16_t)l_47.f0 - (uint16_t)((int16_t)((int32_t)(!__builtin_ffsll(p_34)) % (int32_t)0xDD5C52C7L) << (int16_t)l_223)) && l_253) >> (uint16_t)4));
        }
    }
    l_298 = l_297;
    l_219 = l_219;
    if (((-3L) >= l_219.f1))
    { /* block id: 148 */
        int8_t l_301 = 0L;
        int32_t l_302 = 1L;
        int32_t l_308 = 0L;
        l_302 = (__builtin_parityl((l_298 > (-3L))) >= ((float)(l_301 != l_301) * (float)l_244));
        l_219.f1 = (__builtin_popcount(p_34) != p_34);
        for (p_34 = 9; (p_34 >= 12); p_34 += 1)
        { /* block id: 153 */
            int32_t l_305 = (-7L);
            l_305 = l_219.f1;
            for (l_302 = 11; (l_302 == (-22)); l_302 -= 5)
            { /* block id: 157 */
                int32_t l_323 = 0x91DCD4F5L;
                l_308 = l_298;
                p_35 = ((float)(((float)((((uint16_t)((((int16_t)(((float)(p_34 , l_301) * (float)((((((float)((4L & ((uint16_t)(__builtin_bswap64(l_323) != 0xB14C57F7L) % (uint16_t)(((uint16_t)(((p_34 & l_323) == ((int32_t)((uint16_t)((((__builtin_parityll(l_302) > p_34) != 0x9.F234EBp-50) <= l_323) , 0x5965L) % (uint16_t)0x1DFFL) + (int32_t)(-1L))) || p_34) * (uint16_t)l_323) , l_323))) , p_35) - (float)l_244) > p_35) < l_323) == p_35) == l_323)) , 0xDBA2L) * (int16_t)0x75CEL) >= 6L) & p_34) + (uint16_t)(-1L)) , p_34) , (-0x7.4p-1)) - (float)0xD.D3B933p+90) <= l_301) * (float)(-0x1.3p+1));
            }
            l_219 = func_70(p_34, p_34, p_34, (((uint32_t)p_34 + (uint32_t)(l_298 , l_305)) & l_305));
            if (p_34)
                break;
        }
    }
    else
    { /* block id: 164 */
        p_35 = l_297;
    }
    return l_219;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_48(uint32_t  p_49, uint32_t  p_50, struct S0  p_51, float  p_52, int16_t  p_53)
{ /* block id: 46 */
    float l_63 = 0x5.696B49p+38;
    int32_t l_171 = 0x80367A8BL;
    for (p_49 = (-26); (p_49 >= 15); p_49 += 1)
    { /* block id: 49 */
        int32_t l_64 = 0x64A3A207L;
        l_64 = ((uint16_t)(p_49 | (func_58(p_49, l_64, (p_50 , ((func_65(p_53) , __builtin_clz(((p_53 < p_49) >= p_53))) , l_171)), l_171) & 0x829B7C7EL)) - (uint16_t)p_49);
    }
    l_171 = ((int16_t)l_171 >> (int16_t)8);
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_58(int16_t  p_59, int32_t  p_60, float  p_61, int8_t  p_62)
{ /* block id: 92 */
    float l_172 = 0x9.Bp+1;
    int32_t l_173 = (-9L);
    int8_t l_212 = 0x45L;
    struct S0 l_216 = {31,-1428,-0x4.1p-1};
    l_173 = __builtin_popcountll(l_173);
    for (p_60 = (-9); (p_60 == 27); p_60 += 1)
    { /* block id: 96 */
        int32_t l_184 = 0x95AD63A6L;
        struct S0 l_199 = {7,2688,-0x9.8p-1};
        int32_t l_202 = (-4L);
        if (((int16_t)((int16_t)(((uint16_t)((1UL ^ l_173) , ((uint16_t)__builtin_clzl(l_184) >> (uint16_t)((func_85((l_184 , ((uint16_t)(func_70(l_184, func_85(l_173, (0xFFD8805FL & ((int16_t)p_62 >> (int16_t)l_184))), p_60, l_184) , p_62) >> (uint16_t)12)), l_184) , (-6L)) < l_173))) * (uint16_t)p_59) >= 0x13ECE359L) % (int16_t)0x1D69L) << (int16_t)6))
        { /* block id: 97 */
            uint32_t l_197 = 0x13F8C49FL;
            int8_t l_198 = 0x12L;
            l_202 = ((float)((l_184 , p_59) <= l_173) - (float)(((float)func_65(((((int16_t)((((int16_t)l_197 << (int16_t)(l_198 < ((((l_199 , ((int16_t)l_199.f1 >> (int16_t)func_65(l_197))) , p_62) | 0L) == l_202))) > p_62) , p_62) << (int16_t)6) , p_59) > l_197)) + (float)p_59) < l_199.f1));
        }
        else
        { /* block id: 99 */
            struct S0 l_211 = {27,-195,0x8.2p+1};
            if (l_184)
                break;
            l_211 = func_70(l_173, p_61, p_60, ((uint16_t)(l_173 , p_62) >> (uint16_t)(((uint16_t)0x05F5L >> (uint16_t)(func_65(((((int16_t)p_59 * (int16_t)(((uint16_t)((0UL | p_60) != p_60) - (uint16_t)0x49A1L) <= l_202)) < l_173) != p_62)) && p_59)) != 0x9344L)));
        }
    }
    l_216 = func_70(__builtin_popcountl(l_173), l_212, (((l_212 , func_83(((int16_t)p_62 << (int16_t)10))) , l_212) , (-(int16_t)0xFFB3L)), l_212);
    return l_173;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_65(uint32_t  p_66)
{ /* block id: 50 */
    int32_t l_69 = (-1L);
    struct S0 l_122 = {9,-329,0xA.0F6DB6p+60};
    for (p_66 = 19; (p_66 > 30); p_66 += 1)
    { /* block id: 53 */
        struct S0 l_75 = {23,-2270,0x2.84A000p-42};
        const int16_t l_123 = (-1L);
        l_69 = p_66;
        l_122 = func_70(((l_75 , (((int32_t)func_78((func_83(((l_69 | (func_85(p_66, (((uint16_t)(l_75.f0 <= __builtin_ctzl(l_69)) + (uint16_t)0x6125L) != ((((uint16_t)0x402EL - (uint16_t)0x987EL) > l_69) , p_66))) & l_75.f1)) >= 1UL)) , l_69), l_75.f0, l_122, l_75.f1) % (int32_t)l_75.f1) > 0x7404L)) != p_66), p_66, p_66, l_123);
    }
    return l_122.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_70(int32_t  p_71, float  p_72, int32_t  p_73, const uint16_t  p_74)
{ /* block id: 71 */
    int8_t l_138 = (-9L);
    int32_t l_147 = 0x730D59BCL;
    struct S0 l_148 = {9,-2240,-0x10.4p-1};
    int32_t l_170 = (-4L);
    if (((int32_t)0x1B53E36EL % (int32_t)0x0335754DL))
    { /* block id: 72 */
        int16_t l_139 = 6L;
        int32_t l_145 = 0xAA5E5C78L;
        struct S0 l_146 = {15,-1977,-0x8.1p+1};
        l_147 = (((int16_t)(((uint16_t)func_78(p_73, ((((uint16_t)(((((float)p_71 + (float)(((float)(p_73 <= ((float)(l_138 <= ((l_139 < 0x0.7p-1) == ((float)l_138 - (float)(((-(float)(((((float)(-0x6.2p+1) * (float)p_73) == l_145) != (-0x7.6p-1)) > l_138)) <= 0x0.9p-1) < l_145)))) - (float)p_72)) - (float)p_71) < l_145)) > 0x4.08C6B9p-91) , 65535UL) & 1UL) << (uint16_t)14) > 1L) & 65535UL), l_146, l_145) - (uint16_t)l_138) != 4294967295UL) << (int16_t)l_138) && l_145);
        l_148 = l_148;
        l_146.f1 = p_73;
        return l_146;
    }
    else
    { /* block id: 77 */
        float l_149 = 0x0.1p+1;
        int32_t l_150 = 6L;
        int8_t l_151 = (-1L);
        l_149 = (-0x6.6p+1);
        l_151 = l_150;
    }
    l_148.f1 = (0x5.8C38B9p-9 > l_138);
    for (p_73 = 0; (p_73 > (-7)); p_73 -= 2)
    { /* block id: 84 */
        float l_154 = 0x0.0p-1;
        int32_t l_155 = 0x8BFC28CDL;
        l_170 = (l_154 >= (l_155 <= ((float)((float)((float)0x7.1p+1 * (float)((float)(l_155 >= (p_74 < (p_71 , ((-(float)((float)(-(float)((float)p_74 * (float)p_71)) - (float)(l_155 < (-0x3.2p+1)))) > l_155)))) + (float)p_74)) - (float)l_148.f0) * (float)p_74)));
    }
    l_148.f1 = (l_138 && p_71);
    return l_148;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_78(float  p_79, int8_t  p_80, struct S0  p_81, uint32_t  p_82)
{ /* block id: 69 */
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_83(uint16_t  p_84)
{ /* block id: 58 */
    float l_96 = (-0x2.7p+1);
    int32_t l_103 = 0x3286B001L;
    uint32_t l_104 = 1UL;
    uint32_t l_113 = 0x28AE825DL;
    float l_116 = 0x9.D5741Ep-93;
    uint32_t l_119 = 0UL;
    int32_t l_120 = 1L;
    struct S0 l_121 = {15,-1976,-0x8.Dp+1};
    for (p_84 = 0; (p_84 == 36); p_84 += 1)
    { /* block id: 61 */
        uint32_t l_105 = 1UL;
        int32_t l_106 = 0x357609E5L;
        l_96 = p_84;
        l_103 = ((int16_t)((__builtin_ctz((((0x558EF108L & __builtin_ffsl(p_84)) != (((int32_t)0x420D6CD4L - (int32_t)0x9DA0115BL) & ((((uint16_t)0x6DE5L >> (uint16_t)4) , (p_84 , p_84)) , 0L))) , l_103)) | 0xEAC2F6E5L) , p_84) % (int16_t)p_84);
        l_105 = l_104;
        l_106 = (((l_105 > l_105) >= 0x1.9BBDC2p+27) == (l_104 >= (l_104 , p_84)));
    }
    l_103 = (((((int16_t)l_104 >> (int16_t)((uint32_t)p_84 + (uint32_t)(p_84 < ((int32_t)__builtin_clzll(((((func_85(l_113, __builtin_clzl(((int16_t)((((((l_103 , (((l_104 == (((((uint32_t)((__builtin_ctzl(((l_113 >= l_104) ^ (l_113 && 0x82BF9DFFL))) , 1UL) && 0x1886L) + (uint32_t)0x85E37C3EL) < p_84) & p_84) == p_84)) > 0xAF1C4852L) == l_104)) && 0x7086L) , p_84) == 65533UL) , p_84) && p_84) << (int16_t)13))) | l_104) ^ 65535UL) <= l_119) , 18446744073709551606UL)) - (int32_t)p_84)))) , l_120) | (-7L)) <= p_84);
    return l_121;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_85(int8_t  p_86, uint32_t  p_87)
{ /* block id: 55 */
    const int32_t l_92 = 0xD24A1705L;
    int32_t l_93 = 8L;
    l_93 = l_92;
    return l_92;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 101
   depth: 1, occurrence: 23
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 23
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 22
XXX times a bitfields struct on RHS: 30
XXX times a single bitfield on LHS: 16
XXX times a single bitfield on RHS: 81

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 146
   depth: 2, occurrence: 30
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 18, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 4
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 2
   depth: 30, occurrence: 1
   depth: 32, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 539
XXX times a non-volatile is write: 95
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 139
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 29
   depth: 2, occurrence: 26
   depth: 3, occurrence: 14
   depth: 4, occurrence: 17
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 20.5
XXX percentage an existing variable is used: 79.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

