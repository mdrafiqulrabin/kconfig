/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      4029237130
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int16_t  f0;
   uint32_t  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
inline static union U0 * func_7(int8_t  p_8, uint16_t  p_9, int32_t ** p_10, int32_t  p_11, int32_t * p_12);
inline static int32_t * func_15(uint32_t  p_16, int32_t  p_17);
inline static int32_t  func_24(union U0 * p_25, uint32_t  p_26);
inline static union U0 * func_36(int32_t * p_37, union U0 * p_38);
static union U0 * func_39(int32_t  p_40, int32_t * const * p_41, int16_t  p_42);
inline static int32_t ** func_44(uint16_t  p_45, const union U0 * p_46, int32_t * p_47);
static union U0 * func_48(uint32_t  p_49, uint16_t  p_50, union U0  p_51, int32_t * const  p_52);
static int32_t  func_57(uint32_t  p_58, int32_t  p_59, int32_t * p_60, uint32_t  p_61, int32_t ** p_62);
inline static int32_t  func_63(const uint8_t  p_64, union U0 * p_65, int16_t  p_66, uint16_t  p_67, const int32_t  p_68);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_2 = 248U;
    int32_t l_4 = 0x17F75960;
    int32_t *l_3 = &l_4;
    int32_t l_5 = (-1);
    int32_t **l_6 = &l_3;
    union U0 *l_758 = (void*)0;
    union U0 **l_757 = &l_758;
    int8_t l_759 = 0x0D;
    (*l_3) = l_2;
    l_5 = (0x8C <= (&l_4 == &l_4));
    (*l_6) = &l_4;
    (*l_757) = func_7((*l_3), (&l_3 == (void*)0), &l_3, (((*l_6) == (*l_6)) >= (safe_add_func_uint8_t_u_u((*l_3), (**l_6)))), func_15((*l_3), (*l_3)));
    /* statement id: 230 */
    //assert (l_3 == dangling || l_3 == &l_4);
    return l_759;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0 * func_7(int8_t  p_8, uint16_t  p_9, int32_t ** p_10, int32_t  p_11, int32_t * p_12)
{ /* block id: 8 */
    union U0 *l_27 = (void*)0;
    int32_t l_28 = 0x0F3BBA68;
    union U0 l_53 = {0x75C8};
    int32_t * const *** const l_731 = (void*)0;
    int32_t * const *** const *l_730 = &l_731;
    union U0 ** const ***l_734 = (void*)0;
    int32_t ****l_735 = (void*)0;
    int32_t **l_737 = (void*)0;
    int32_t ***l_736 = &l_737;
    int32_t ***l_740 = &l_737;
    uint8_t l_749 = 0xB7;
    union U0 **l_750 = &l_27;
    union U0 *l_751 = &l_53;
    union U0 *l_752 = &l_53;
    union U0 *l_753 = &l_53;
    union U0 *l_754 = &l_53;
    union U0 *l_755 = &l_53;
    union U0 *l_756 = (void*)0;
    if (func_24(l_27, (0U & l_28)))
    { /* block id: 12 */
        int16_t l_43 = 0x6128;
        int32_t *l_526 = &l_28;
        (*l_526) = func_24(l_27, (safe_mod_func_int32_t_s_s(((safe_sub_func_uint32_t_u_u(1U, (**p_10))) & (l_28 < l_28)), (func_24(func_36(func_15(l_28, (func_24(func_39((l_43 & p_8), func_44(func_24(func_48(((**p_10) >= p_11), l_43, l_53, (*p_10)), p_9), &l_53, l_526), l_53.f0), (*l_526)) & p_9)), &l_53), (*l_526)) || (-1)))));
        (**p_10) = ((((((((&l_526 == (void*)0) != (safe_sub_func_int8_t_s_s((((((safe_lshift_func_uint16_t_u_s((safe_lshift_func_int8_t_s_u(0xD7, (safe_sub_func_uint16_t_u_u((((!(safe_sub_func_int16_t_s_s(((*l_526) <= (0x843D < p_9)), 65535U))) >= ((l_28 ^ ((*l_526) == (-10))) && 0)) != 1U), p_8)))), 11)) & (-1)) > 1U) && 0x0FCB872D) && l_28), (-1)))) >= p_9) ^ (*l_526)) ^ p_9) != 8U) || l_53.f0) > (*l_526));
    }
    else
    { /* block id: 217 */
        int32_t *l_717 = &l_28;
        int32_t **l_729 = &l_717;
        int32_t ***l_728 = &l_729;
        int32_t *** const *l_727 = &l_728;
        int32_t *** const **l_726 = &l_727;
        if (((void*)0 == l_717))
        { /* block id: 218 */
            (*l_717) = 0x549D2BDA;
        }
        else
        { /* block id: 220 */
            union U0 **l_719 = &l_27;
            union U0 ***l_718 = &l_719;
            (*p_10) = &l_28;
            /* statement id: 221 */
            //assert (l_3 == &l_28);
            (*l_718) = &l_27;
        }
        /* facts after branching */
        //assert (l_3 == &l_28 || l_3 == &l_4);
        (*l_717) = (((safe_lshift_func_int16_t_s_s(0, ((safe_rshift_func_int8_t_s_u(((safe_add_func_uint32_t_u_u(0x9EDFA684, (*l_717))) == (l_726 == l_730)), 4)) > 0x259A))) >= ((**l_729) | (l_734 == l_734))) ^ (**p_10));
    }
    /* facts after branching */
    //assert (l_3 == &l_28 || l_3 == &l_4);
    l_736 = &p_10;
    /* statement id: 226 */
    assert (l_736 == &p_10);
    l_27 = func_48(((((safe_add_func_int16_t_s_s(p_11, (l_740 != &p_10))) || (p_11 | ((((safe_mod_func_int32_t_s_s((safe_rshift_func_int8_t_s_s((&l_53 != &l_53), (((safe_rshift_func_int8_t_s_u((safe_add_func_uint32_t_u_u(p_8, (***l_736))), p_9)) <= 4294967294U) != 0xA9059433))), 7U)) == l_749) & p_11) > 0x3ADD))) > (***l_736)) <= p_8), p_11, l_53, (*p_10));
    (*l_750) = func_36((*p_10), &l_53);
    /* statement id: 228 */
    assert (l_27 == &l_53);
    return l_756;
    /* statement id: 229 */
    //assert (l_3 == dangling || l_3 == &l_4);
    //assert (func_7_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_15(uint32_t  p_16, int32_t  p_17)
{ /* block id: 4 */
    union U0 *l_18 = (void*)0;
    const int32_t l_19 = (-3);
    int32_t l_20 = (-1);
    int32_t *l_21 = &l_20;
    int32_t *l_22 = &l_20;
    int32_t *l_23 = (void*)0;
    l_20 = (((void*)0 != l_18) >= l_19);
    (*l_21) = (l_18 == (void*)0);
    return l_23;
    /* statement id: 7 */
    //assert (func_15_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_24(union U0 * p_25, uint32_t  p_26)
{ /* block id: 9 */
    int32_t l_31 = 0xA603D2CF;
    int32_t *l_30 = &l_31;
    int32_t **l_29 = &l_30;
    (*l_29) = (void*)0;
    /* statement id: 10 */
    assert (l_30 == 0);
    return p_26;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0 * func_36(int32_t * p_37, union U0 * p_38)
{ /* block id: 158 */
    int32_t l_564 = 0x08C7CB94;
    union U0 ** const *l_569 = (void*)0;
    union U0 ** const **l_568 = &l_569;
    union U0 ** const ***l_567 = &l_568;
    int32_t *l_582 = (void*)0;
    int32_t **l_581 = &l_582;
    int32_t ***l_580 = &l_581;
    int32_t ****l_579 = &l_580;
    union U0 ****l_619 = (void*)0;
    int8_t l_620 = 0x12;
    int8_t l_640 = 0;
    const uint32_t l_651 = 9U;
    int32_t *l_702 = &l_564;
    int16_t l_703 = 0x59FB;
    for (l_564 = 19; (l_564 <= 21); l_564 = safe_add_func_uint8_t_u_u(l_564, 8))
    { /* block id: 161 */
        int32_t *l_583 = &l_564;
        const int32_t l_589 = (-4);
        int32_t l_621 = 0x3EA5185A;
        int32_t l_622 = (-6);
        int16_t l_635 = (-1);
        union U0 l_642 = {0xEE13};
        union U0 *l_641 = &l_642;
        uint32_t l_699 = 1U;
        l_567 = l_567;
        if (l_564)
        { /* block id: 163 */
            int8_t l_572 = 5;
            const int32_t ***l_578 = (void*)0;
            const int32_t ****l_577 = &l_578;
            const uint8_t l_588 = 255U;
            const union U0 *l_590 = (void*)0;
            (**l_579) = &p_37;
            /* statement id: 164 */
            assert (l_581 == &p_37);
            (***l_579) = (void*)0;
            /* statement id: 165 */
            assert (p_37 == 0);
        }
        else
        { /* block id: 166 */
            uint8_t l_591 = 1U;
            int32_t l_600 = 0x6E80C633;
            int32_t *l_599 = &l_600;
            uint16_t l_616 = 65526U;
            (**l_580) = func_15(((((l_591 > (safe_add_func_int8_t_s_s((((safe_rshift_func_uint8_t_u_s(1U, 2)) == (((l_591 ^ (*l_583)) > (*l_583)) != (safe_unary_minus_func_uint8_t_u(((-1) && 0x2AD116B9))))) > (safe_mod_func_uint32_t_u_u((((*l_583) && 0U) < (*l_583)), l_564))), (*l_583)))) != (*l_583)) < l_591) ^ (*l_583)), l_591);
            (*l_599) = (-3);
            l_621 = (safe_lshift_func_int8_t_s_s(((!((safe_rshift_func_int16_t_s_u((*l_583), (*l_583))) == (safe_rshift_func_int16_t_s_u((*l_599), (safe_add_func_int16_t_s_s((((safe_div_func_uint8_t_u_u((safe_mod_func_uint32_t_u_u((*l_599), (safe_div_func_uint8_t_u_u(l_616, ((*l_583) && (*l_583)))))), (safe_rshift_func_uint16_t_u_u(((void*)0 == l_619), 1)))) < (*l_599)) >= (*l_599)), l_620)))))) && (*l_583)), 7));
        }
        if ((*l_583))
        { /* block id: 171 */
            return p_38;
            /* statement id: 172 */
            //assert (func_36_rv == &l_53);
        }
        else
        { /* block id: 173 */
            int16_t l_629 = 8;
            int32_t ****l_630 = &l_580;
            int8_t l_675 = 1;
            (***l_630) = func_15(((((((l_622 >= 0x92FA) & (safe_add_func_uint8_t_u_u((safe_sub_func_int16_t_s_s((((safe_lshift_func_uint8_t_u_s((l_629 <= (l_630 == (void*)0)), ((((l_629 & ((((*l_583) == (safe_add_func_uint16_t_u_u(0xCEF0, 9))) < (*l_583)) != (*l_583))) >= (*l_583)) <= 0xE7E7) >= (*l_583)))) <= l_629) > (*l_583)), (*l_583))), l_635))) && (*l_583)) ^ 3U) <= (*l_583)) == 0xEF6F1B79), l_629);
            for (l_620 = 28; (l_620 > (-6)); l_620 = safe_sub_func_int8_t_s_s(l_620, 1))
            { /* block id: 177 */
                uint16_t l_638 = 1U;
                int32_t *l_639 = &l_621;
                (**l_580) = func_15(l_638, (*l_583));
                (*l_639) = 6;
                return p_38;
                /* statement id: 180 */
                //assert (func_36_rv == &l_53);
            }
            (**l_580) = func_15(l_640, ((((((((((l_641 == (void*)0) ^ ((*l_583) == (safe_lshift_func_uint16_t_u_u((*l_583), ((safe_sub_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s(((*l_583) | (((0 >= (safe_sub_func_int16_t_s_s(0x9C71, ((void*)0 != (***l_630))))) || (*l_583)) <= 0x35)), l_651)), 0x54)) | (*l_583)))))) ^ (*l_583)) | (*l_583)) == (*l_583)) | (*l_583)) > 4294967295U) | l_629) && (*l_583)) > 4294967295U));
            if ((1 ^ 1U))
            { /* block id: 183 */
                int8_t l_652 = 0xEB;
                union U0 **l_672 = (void*)0;
                union U0 ***l_671 = &l_672;
                l_652 = 0x3EC22B56;
                if ((*l_583))
                    continue;
                for (l_642.f1 = 4; (l_642.f1 > 2); l_642.f1 = safe_sub_func_uint8_t_u_u(l_642.f1, 4))
                { /* block id: 188 */
                    uint8_t l_676 = 0x71;
                    int32_t l_678 = 1;
                    if ((*l_583))
                    { /* block id: 189 */
                        int32_t * const **l_657 = (void*)0;
                        int32_t * const ***l_656 = &l_657;
                        int32_t * const ****l_655 = &l_656;
                        uint32_t l_667 = 1U;
                        if (l_652)
                            break;
                        (*l_655) = (void*)0;
                        /* statement id: 191 */
                        assert (l_656 == 0);
                        l_667 = (safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((~5U), 1)), (safe_add_func_int8_t_s_s(0xB5, (safe_lshift_func_int16_t_s_u(0, 2))))));
                        (***l_630) = func_15(((((!((((*l_583) | ((0xD9D69DA3 >= 0x2C53623D) || ((safe_add_func_uint32_t_u_u((l_671 != (void*)0), (((safe_rshift_func_uint16_t_u_s((&l_568 == (void*)0), (0U != l_652))) ^ l_675) & (*l_583)))) >= 0))) != l_676) != 1U)) != (*l_583)) < 0xFE) < l_652), l_652);
                    }
                    else
                    { /* block id: 194 */
                        uint32_t l_677 = 0x670D9BA3;
                        (***l_579) = (***l_630);
                        l_678 = l_677;
                    }
                }
                /* facts after for loop */
                                (*l_630) = (*l_579);
            }
            else
            { /* block id: 200 */
                uint32_t l_679 = 0xC8AD7AD7;
                int32_t l_680 = (-1);
                int32_t *l_700 = (void*)0;
                int32_t *l_701 = &l_622;
                l_680 = l_679;
                if ((1U & 0U))
                { /* block id: 202 */
                    l_583 = p_37;
                    /* statement id: 203 */
                    //assert (l_583 == 0 || l_583 == &l_28 || l_583 == &l_4);
                }
                else
                { /* block id: 204 */
                    uint32_t l_683 = 0x2F925433;
                    int32_t *l_684 = &l_622;
                    (*l_684) = (((safe_add_func_uint16_t_u_u(l_679, ((l_683 ^ 0x0E1F) & l_680))) >= l_683) == (&l_580 == l_630));
                }
                /* facts after branching */
                //assert (l_583 == &l_564 || l_583 == 0 || l_583 == &l_28 || l_583 == &l_4);
                (*l_701) = (safe_add_func_uint16_t_u_u((safe_div_func_uint16_t_u_u(((((safe_lshift_func_int8_t_s_s(((*l_579) == (void*)0), (safe_sub_func_int8_t_s_s((((0U == (((&l_630 != (void*)0) | ((safe_sub_func_int8_t_s_s((((safe_div_func_int16_t_s_s(((void*)0 == &p_37), l_679)) >= (((((***l_630) != &l_621) & l_679) || l_635) < l_699)) ^ l_680), l_679)) > l_680)) == l_629)) ^ l_679) == 1), l_629)))) & l_675) != l_675) < l_680), l_680)), l_642.f0));
            }
            /* facts after branching */
            //assert (l_583 == &l_564 || l_583 == 0 || l_583 == &l_28 || l_583 == &l_4);
        }
        /* facts after branching */
        //assert (l_583 == &l_564 || l_583 == 0 || l_583 == &l_28 || l_583 == &l_4);
    }
    /* facts after for loop */
    //assert (l_582 == 0 || l_582 == &l_28 || l_582 == &l_4);
    assert (l_581 == &l_582 || l_581 == &p_37);
    (*l_702) = l_564;
    l_703 = (-1);
    (*l_702) = (((safe_lshift_func_int16_t_s_u((p_38 != (void*)0), 5)) | (-8)) | 4294967286U);
    return p_38;
    /* statement id: 214 */
    //assert (func_36_rv == &l_53);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_39(int32_t  p_40, int32_t * const * p_41, int16_t  p_42)
{ /* block id: 155 */
    int8_t l_548 = 1;
    int32_t l_558 = 0xE7747F3B;
    int32_t *l_557 = &l_558;
    union U0 l_560 = {0xE035};
    union U0 *l_559 = &l_560;
    union U0 *l_561 = &l_560;
    union U0 *l_562 = &l_560;
    union U0 *l_563 = (void*)0;
    (*l_557) = (safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u(l_548, 3)), (safe_sub_func_int16_t_s_s(((((0xA5 <= (safe_add_func_uint8_t_u_u(p_40, ((1 >= (l_548 ^ l_548)) | (safe_mod_func_int32_t_s_s(((l_548 >= (safe_lshift_func_int8_t_s_u(p_40, (p_42 ^ l_548)))) <= p_40), 0x6E60C670)))))) <= l_548) > 4294967293U) & l_548), 1))));
    return l_563;
    /* statement id: 157 */
    //assert (func_39_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_44(uint16_t  p_45, const union U0 * p_46, int32_t * p_47)
{ /* block id: 150 */
    int32_t l_529 = 0x36BDC6EE;
    int32_t *l_528 = &l_529;
    int32_t **l_527 = &l_528;
    union U0 l_536 = {0x6F0F};
    union U0 *l_535 = &l_536;
    union U0 **l_534 = &l_535;
    union U0 ***l_540 = &l_534;
    union U0 ****l_539 = &l_540;
    int32_t *l_541 = (void*)0;
    int32_t *l_542 = &l_536.f2;
    int32_t **l_543 = (void*)0;
    (*l_527) = p_47;
    /* statement id: 151 */
    //assert (l_528 == &l_28);
    (*l_542) = ((safe_sub_func_int8_t_s_s((*l_528), (safe_div_func_int16_t_s_s((((void*)0 == l_534) >= ((safe_sub_func_uint16_t_u_u((l_539 == (void*)0), (**l_527))) || ((void*)0 == &l_540))), (**l_527))))) >= p_45);
    /* statement id: 152 */
        p_46 = p_46;
    return l_543;
    /* statement id: 154 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_48(uint32_t  p_49, uint16_t  p_50, union U0  p_51, int32_t * const  p_52)
{ /* block id: 13 */
    int32_t ***l_54 = (void*)0;
    int32_t **l_56 = (void*)0;
    int32_t ***l_55 = &l_56;
    int32_t l_71 = 0xBD7CCF76;
    union U0 l_73 = {0x82FB};
    union U0 *l_72 = &l_73;
    int32_t *l_78 = &l_71;
    int32_t *l_85 = &l_71;
    uint8_t l_154 = 0x1A;
    int16_t l_165 = (-4);
    uint8_t l_297 = 0U;
    int8_t l_304 = 0x94;
    union U0 ***l_361 = (void*)0;
    int32_t l_390 = 0xB0055050;
    union U0 *l_521 = &l_73;
    union U0 *l_522 = &l_73;
    union U0 *l_523 = &l_73;
    union U0 *l_524 = &l_73;
    union U0 *l_525 = (void*)0;
    (*l_55) = (void*)0;
    return l_525;
    /* statement id: 149 */
    //assert (func_48_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_57(uint32_t  p_58, int32_t  p_59, int32_t * p_60, uint32_t  p_61, int32_t ** p_62)
{ /* block id: 18 */
    uint32_t l_86 = 0x8662677E;
    int32_t l_89 = 9;
    int32_t *l_88 = &l_89;
    int32_t **l_87 = &l_88;
    (*l_87) = func_15(l_86, l_86);
    /* statement id: 19 */
    assert (l_88 == 0);
    (*p_60) = (safe_rshift_func_uint8_t_u_u(((void*)0 == &l_87), 1));
    return (*p_60);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_63(const uint8_t  p_64, union U0 * p_65, int16_t  p_66, uint16_t  p_67, const int32_t  p_68)
{ /* block id: 15 */
    int32_t *l_84 = (void*)0;
    int32_t **l_83 = &l_84;
    (*l_83) = (void*)0;
    return p_67;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 149
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 7
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 2
   depth: 31, occurrence: 1

XXX total number of pointers: 176

XXX times a variable address is taken: 173
XXX times a pointer is dereferenced on RHS: 157
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 9
   depth: 3, occurrence: 6
XXX times a pointer is dereferenced on LHS: 85
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 5
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 45
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 21
XXX times a pointer is qualified to be dereferenced: 901

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 444
   level: 2, occurrence: 66
   level: 3, occurrence: 89
   level: 4, occurrence: 79
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 102
XXX number of pointers point to scalars: 36
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 36.4
XXX average alias set size: 1.19

XXX times a non-volatile is read: 789
XXX times a non-volatile is write: 215
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 72
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 7
   depth: 2, occurrence: 13
   depth: 3, occurrence: 10
   depth: 4, occurrence: 3
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 10.4
XXX percentage an existing variable is used: 89.6
********************* end of statistics **********************/

