/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      4132545524
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 8;
   signed f1 : 29;
   unsigned f2 : 11;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   unsigned f0 : 28;
   unsigned f1 : 24;
   unsigned f2 : 25;
   const signed f3 : 14;
   const unsigned f4 : 7;
   const signed f5 : 19;
   int64_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_32(void);
static float  func_40(int32_t  p_41, const int16_t  p_42, uint16_t  p_43);
static uint64_t  func_44(int32_t  p_45, int32_t  p_46);
inline static int32_t * func_51(int32_t  p_52, int32_t  p_53, struct S1  p_54);
static struct S1  func_57(uint64_t  p_58, int32_t * const  p_59, int32_t * p_60);
inline static int32_t  func_80(int64_t  p_81, float  p_82, int32_t * const * p_83, struct S0 ** const  p_84);
inline static uint16_t  func_87(int16_t  p_88, struct S0 * p_89, struct S0 ** p_90, const struct S0  p_91);
static struct S0 * func_92(int32_t ** p_93, int32_t  p_94, struct S0 * p_95, int32_t ** p_96, int32_t ** const  p_97);
static int32_t ** func_98(struct S0 * p_99, int16_t  p_100, uint32_t  p_101, float  p_102);
static int64_t  func_103(const float * p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_32(void)
{ /* block id: 36 */
    uint16_t l_35 = 0x491BL;
    const uint16_t l_424 = 0x1094L;
    float l_425 = 0x4.922995p-15;
    float *l_426 = &l_425;
    struct S0 l_427 = {9,-19508,17};
    (*l_426) = (((float)l_35 - (float)l_35) < (((((0xA.D93BA6p-5 >= ((float)(((((((l_35 > l_35) == ((float)(0x0.8p-1 < (func_40(((func_44(((int16_t)((l_35 ^ (((uint32_t)0x9150040BL - (uint32_t)((0xF57F54ABL ^ l_35) == l_35)) || l_35)) >= 0x3F07L) + (int16_t)l_35), l_35) != l_35) >= l_35), l_35, l_35) > 0x7.B98AA1p-59)) - (float)l_35)) <= 0xB.5D163Bp-30) != l_35) != 0x5.45276Dp-59) != 0x5.E3D8D6p-51) >= l_35) - (float)l_35)) >= l_35) > l_424) > l_425) >= l_35));
    return l_427;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_40(int32_t  p_41, const int16_t  p_42, uint16_t  p_43)
{ /* block id: 257 */
    uint64_t l_415 = 2UL;
    int32_t l_416 = 0L;
    if (p_41)
    { /* block id: 258 */
        struct S0 l_414 = {7,-8803,10};
        struct S0 * const l_413 = &l_414;
        struct S0 * const *l_412 = &l_413;
        struct S0 * const **l_411 = &l_412;
        (*l_411) = (void*)0;
        /* statement id: 259 */
        assert (l_412 == 0);
        l_416 = (l_415 == (p_43 ^ __builtin_parityl(p_41)));
    }
    else
    { /* block id: 261 */
        const int32_t *l_418 = &l_416;
        const int32_t **l_417 = &l_418;
        struct S0 l_422 = {11,11699,20};
        struct S0 * const l_421 = &l_422;
        struct S0 *l_423 = &l_422;
        (*l_417) = &p_41;
        /* statement id: 262 */
        assert (l_418 == &p_41);
        for (p_41 = 10; (p_41 > (-16)); p_41--)
        { /* block id: 265 */
            l_416 = p_43;
            if ((**l_417))
                break;
        }
        l_423 = l_421;
    }
    return l_415;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_44(int32_t  p_45, int32_t  p_46)
{ /* block id: 37 */
    int32_t l_56 = 0x3A798BE4L;
    int32_t *l_55 = &l_56;
    uint32_t l_61 = 0UL;
    int32_t **l_386 = &l_55;
    struct S0 l_395 = {13,2371,36};
    int32_t l_410 = 0x7B352411L;
    (*l_386) = func_51(p_45, (&p_46 == l_55), func_57(l_61, &l_56, &l_56));
    /* statement id: 243 */
    assert (l_55 == 0);
    for (p_45 = 0; (p_45 <= (-3)); p_45--)
    { /* block id: 246 */
        const struct S0 l_389 = {9,2144,30};
        struct S0 l_391 = {6,-16360,20};
        struct S0 *l_390 = &l_391;
        (*l_390) = l_389;
    }
    for (l_61 = 16; (l_61 == 31); ++l_61)
    { /* block id: 251 */
        struct S0 l_394 = {11,-22099,43};
        float * const l_407 = (void*)0;
        struct S1 l_409 = {1126,3742,3462,52,8,-275,0L};
        l_395 = l_394;
        (*l_386) = &p_46;
        /* statement id: 253 */
        assert (l_55 == &p_46);
        (*l_386) = func_51((**l_386), ((((uint32_t)p_46 / (uint32_t)((uint16_t)((uint64_t)((uint16_t)p_46 >> (uint16_t)1) - (uint64_t)((-(int16_t)((int16_t)(l_55 != l_407) << (int16_t)(((*l_55) > 0xF5A178EDL) || ((~l_394.f1) != (3UL < p_45))))) ^ 0xDBADL)) % (uint16_t)p_46)) || p_46) || (*l_55)), l_409);
        /* statement id: 254 */
        assert (l_55 == 0);
    }
    return l_410;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_51(int32_t  p_52, int32_t  p_53, struct S1  p_54)
{ /* block id: 239 */
    float l_380 = 0x8.5E30F0p-6;
    float *l_379 = &l_380;
    float **l_378 = &l_379;
    float ***l_377 = &l_378;
    int32_t l_382 = 0x0E98C55AL;
    int32_t *l_381 = &l_382;
    struct S0 l_383 = {3,-13265,38};
    struct S0 *l_384 = &l_383;
    int32_t *l_385 = (void*)0;
    (*l_381) = ((void*)0 != l_377);
    (*l_384) = l_383;
    return l_385;
    /* statement id: 242 */
    //assert (func_51_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_57(uint64_t  p_58, int32_t * const  p_59, int32_t * p_60)
{ /* block id: 38 */
    int32_t l_64 = 0L;
    int32_t *l_63 = &l_64;
    int32_t **l_62 = &l_63;
    struct S0 l_67 = {15,22730,12};
    struct S0 *l_66 = &l_67;
    struct S0 **l_65 = &l_66;
    float l_76 = 0x1.Ep-1;
    const struct S0 l_332 = {15,-9391,19};
    uint32_t l_339 = 0x9F0F1A88L;
    int64_t l_346 = (-1L);
    float *l_373 = (void*)0;
    float *l_374 = (void*)0;
    float *l_375 = &l_76;
    struct S1 l_376 = {3123,718,1776,54,5,-19,0xAB3DE261AEE968AELL};
    (*l_62) = (void*)0;
    /* statement id: 39 */
    assert (l_63 == 0);
    (*l_65) = (void*)0;
    /* statement id: 40 */
    assert (l_66 == 0);
    for (l_64 = 0; (l_64 > 12); ++l_64)
    { /* block id: 43 */
        int32_t **l_72 = &l_63;
        struct S0 * const *l_73 = &l_66;
        float l_75 = 0x1.Ep-1;
        float *l_74 = &l_75;
        int32_t l_318 = 1L;
        struct S0 *l_325 = &l_67;
        int32_t **l_326 = (void*)0;
        struct S1 l_348 = {15908,768,733,-56,6,-545,4L};
        const struct S1 *l_347 = &l_348;
        (*l_74) = (((float)p_58 + (float)((void*)0 != l_72)) >= (__builtin_popcount((0x6A86E60EL & __builtin_parity(p_58))) >= ((void*)0 != l_73)));
    }
    (*l_375) = __builtin_bswap32(p_58);
    return l_376;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_80(int64_t  p_81, float  p_82, int32_t * const * p_83, struct S0 ** const  p_84)
{ /* block id: 200 */
    struct S0 l_341 = {0,12831,0};
    struct S0 *l_340 = &l_341;
    l_340 = l_340;
    return l_341.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_87(int16_t  p_88, struct S0 * p_89, struct S0 ** p_90, const struct S0  p_91)
{ /* block id: 195 */
    float **l_334 = (void*)0;
    float ***l_333 = &l_334;
    int32_t l_335 = 1L;
    int32_t *l_337 = &l_335;
    int32_t **l_336 = &l_337;
    uint16_t l_338 = 6UL;
    l_335 = (((void*)0 == l_333) == p_91.f1);
    (*l_336) = &l_335;
    (*l_336) = (void*)0;
    /* statement id: 198 */
    assert (l_337 == 0);
    return l_338;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_92(int32_t ** p_93, int32_t  p_94, struct S0 * p_95, int32_t ** p_96, int32_t ** const  p_97)
{ /* block id: 189 */
    int32_t l_328 = (-8L);
    int32_t * const l_327 = &l_328;
    int32_t *l_330 = (void*)0;
    int32_t **l_329 = &l_330;
    struct S0 l_331 = {12,-15253,12};
    (*l_329) = l_327;
    /* statement id: 190 */
    assert (l_330 == &l_328);
    (*p_95) = l_331;
    (*l_329) = (void*)0;
    /* statement id: 192 */
    assert (l_330 == 0);
    (*p_95) = (*p_95);
    return p_95;
    /* statement id: 194 */
    //assert (func_92_rv == &l_67);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_98(struct S0 * p_99, int16_t  p_100, uint32_t  p_101, float  p_102)
{ /* block id: 186 */
    int32_t l_319 = 0x7DE5B839L;
    int32_t l_321 = 0x4B929F27L;
    int32_t *l_320 = &l_321;
    int32_t **l_322 = &l_320;
    int32_t **l_323 = &l_320;
    int32_t **l_324 = (void*)0;
    (*l_320) = (1UL > l_319);
    return l_324;
    /* statement id: 188 */
    //assert (func_98_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_103(const float * p_104)
{ /* block id: 45 */
    int16_t l_105 = 0x7EEAL;
    int32_t **l_164 = (void*)0;
    struct S0 l_193 = {2,-21208,42};
    int32_t l_210 = (-6L);
    int32_t *l_209 = &l_210;
    struct S0 *l_259 = &l_193;
    struct S0 **l_258 = &l_259;
    int32_t l_260 = 0L;
    uint8_t l_317 = 0x07L;
    if ((l_105 != l_105))
    { /* block id: 46 */
        uint32_t l_108 = 4294967295UL;
        int32_t l_119 = 0xBAD64B6CL;
        int32_t *l_118 = &l_119;
        uint8_t l_149 = 0x09L;
        for (l_105 = 0; (l_105 <= (-11)); --l_105)
        { /* block id: 49 */
            const float l_113 = 0x1.EDFD63p-99;
            const int32_t l_114 = 0xE41E6F70L;
            struct S0 *l_138 = (void*)0;
            struct S0 **l_137 = &l_138;
            int32_t **l_143 = (void*)0;
            if (l_108)
                break;
        }
    }
    else
    { /* block id: 85 */
        const int32_t l_188 = 0x52B13B08L;
        const uint8_t l_189 = 6UL;
        int32_t l_196 = 0x354A0364L;
        int32_t *l_195 = &l_196;
        int32_t **l_194 = &l_195;
        const int32_t *l_298 = (void*)0;
        struct S0 l_305 = {15,22010,33};
        uint8_t l_315 = 0x8AL;
        int32_t **l_316 = &l_209;
        for (l_105 = 0; (l_105 > (-28)); l_105 -= 1)
        { /* block id: 88 */
            struct S0 l_172 = {10,10089,33};
            struct S0 *l_173 = &l_172;
            int16_t l_190 = 1L;
            int32_t l_192 = (-7L);
            int32_t *l_191 = &l_192;
            (*l_173) = l_172;
            (*l_191) = (((uint64_t)((uint16_t)(l_172.f0 >= (l_172.f1 | ((uint16_t)(((((((uint64_t)(((int32_t)0xF285608BL / (int32_t)(-8L)) & ((int16_t)((int64_t)l_172.f1 - (int64_t)l_172.f0) << (int16_t)0)) - (uint64_t)(l_188 < l_172.f2)) && (l_189 && l_189)) != 0xCE49L) <= l_172.f2) & l_189) && l_189) + (uint16_t)l_190))) % (uint16_t)l_188) + (uint64_t)0x44AC5510416570B7LL) > l_189);
            (*l_173) = l_193;
            if (((l_164 == l_194) == (*l_191)))
            { /* block id: 92 */
                (*l_173) = l_193;
                (**l_194) = 0x70524A1AL;
            }
            else
            { /* block id: 95 */
                if ((*l_191))
                    break;
            }
        }
        for (l_105 = 0; (l_105 <= 6); l_105 += 7)
        { /* block id: 101 */
            int32_t l_203 = 0L;
            int32_t *l_254 = &l_203;
            const int32_t *l_280 = &l_210;
            const int32_t *l_297 = &l_210;
            const float l_302 = 0x0.Bp-1;
            const float *l_301 = &l_302;
            const float **l_300 = &l_301;
            const float ***l_299 = &l_300;
            float *l_309 = (void*)0;
            float *l_310 = (void*)0;
            float l_312 = (-0x8.3p-1);
            float *l_311 = &l_312;
        }
        (*l_195) = (0x4331D11E76F3828BLL && ((int64_t)(((((*l_209) & (*l_195)) < 4294967295UL) && (*l_209)) > ((**l_194) != (((l_315 == __builtin_parity((*l_195))) | (*l_195)) && (**l_194)))) - (int64_t)1UL));
        (*l_316) = p_104;
        /* statement id: 183 */
        //assert (l_209 == &l_56);
    }
    /* facts after branching */
    //assert (l_209 == &l_56 || l_209 == &l_210);
    return l_317;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 99
   depth: 1, occurrence: 18
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 18
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 16
breakdown:
   indirect level: 0, occurrence: 16
XXX times a bitfields struct's address is taken: 16
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 28
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 11

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 122

XXX times a variable address is taken: 98
XXX times a pointer is dereferenced on RHS: 55
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 9
XXX times a pointer is dereferenced on LHS: 65
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 219

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 150
   level: 2, occurrence: 39
XXX number of pointers point to pointers: 58
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 20
XXX percent of pointers has null in alias set: 32.8
XXX average alias set size: 1.18

XXX times a non-volatile is read: 414
XXX times a non-volatile is write: 173
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 56
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 15
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3

XXX percentage a fresh-made variable is used: 24.1
XXX percentage an existing variable is used: 75.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

