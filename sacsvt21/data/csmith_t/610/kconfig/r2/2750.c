/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      301186842
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 27;
   const unsigned f1 : 4;
   const signed f2 : 22;
   const int32_t  f3;
   unsigned f4 : 11;
   signed f5 : 11;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 1;
static struct S0 g_19[1] = {{8955,2,-272,-2,37,37}};
static struct S0 *g_18 = &g_19[0];
static int32_t g_35 = 1;
static int32_t *g_39 = &g_2;
static int32_t **g_38 = &g_39;
static int32_t g_92[6][6] = {{0,0xB371DABD,8,0xB371DABD,0,0},{0xC63FEC72,0xB371DABD,0xB371DABD,0xC63FEC72,0xB86155BF,0xC63FEC72},{0xC63FEC72,0xB86155BF,0xC63FEC72,0xB371DABD,0xB371DABD,0xC63FEC72},{0,0,0xB371DABD,8,0xB371DABD,0},{0xB371DABD,0xB86155BF,8,8,0xB86155BF,0xB371DABD},{0,0xB371DABD,8,0xB371DABD,0,0}};
static int32_t g_96[7][5][1] = {{{0x752D6847},{0x7A01C18E},{(-4)},{0x7A01C18E},{0x752D6847}},{{0x7A01C18E},{(-4)},{0x7A01C18E},{0x752D6847},{0x7A01C18E}},{{(-4)},{0x7A01C18E},{0x752D6847},{0x7A01C18E},{(-4)}},{{0x7A01C18E},{0x752D6847},{0x7A01C18E},{(-4)},{0x7A01C18E}},{{0x752D6847},{0x7A01C18E},{(-4)},{0x7A01C18E},{0x752D6847}},{{0x7A01C18E},{(-4)},{0x7A01C18E},{0x752D6847},{0x7A01C18E}},{{(-4)},{0x7A01C18E},{0x752D6847},{0x7A01C18E},{(-4)}}};
static int32_t g_100 = 0xED821F8E;
static int32_t g_101 = 1;
static int32_t g_102[1][9][7] = {{{0x738BD3C8,0xBF4B608A,0xBF4B608A,0x738BD3C8,1,0x738BD3C8,0xBF4B608A},{0,0xEC7D2368,(-10),1,(-10),0xEC7D2368,0},{0x2E4B4840,0xBF4B608A,0x884ACF1A,0xBF4B608A,0x2E4B4840,0x2E4B4840,0xBF4B608A},{0x0099732E,(-1),0x0099732E,0x3E184A18,(-10),(-1),8},{0xBF4B608A,1,0x884ACF1A,0x884ACF1A,1,0xBF4B608A,1},{0x0099732E,0x3E184A18,(-10),(-1),8,(-1),(-10)},{0x2E4B4840,0x2E4B4840,0xBF4B608A,0x884ACF1A,0xBF4B608A,0x2E4B4840,0x2E4B4840},{0,0x3E184A18,0x7EA7EABB,0x3E184A18,0,0xEC7D2368,(-10)},{0x738BD3C8,1,0x738BD3C8,0xBF4B608A,0xBF4B608A,0x738BD3C8,1}}};
static const struct S0 g_187 = {9325,2,1609,-7,17,-11};
static struct S0 g_189[7] = {{-9631,3,-436,0x25B6B4B3,43,25},{-9631,3,-436,0x25B6B4B3,43,25},{-9631,3,-436,0x25B6B4B3,43,25},{-9631,3,-436,0x25B6B4B3,43,25},{-9631,3,-436,0x25B6B4B3,43,25},{-9631,3,-436,0x25B6B4B3,43,25},{-9631,3,-436,0x25B6B4B3,43,25}};
static int32_t ** const *g_190[7][5] = {{&g_38,&g_38,&g_38,&g_38,&g_38},{&g_38,&g_38,&g_38,&g_38,&g_38},{&g_38,&g_38,&g_38,&g_38,&g_38},{&g_38,&g_38,&g_38,&g_38,&g_38},{&g_38,&g_38,&g_38,&g_38,&g_38},{&g_38,&g_38,&g_38,&g_38,&g_38},{&g_38,&g_38,&g_38,&g_38,&g_38}};
static int32_t ** const **g_217 = &g_190[3][0];
static int32_t ** const ***g_272 = &g_217;


/* --- FORWARD DECLARATIONS --- */
inline static const int32_t  func_1(void);
inline static struct S0 * func_5(uint32_t  p_6);
inline static int16_t  func_12(struct S0 * p_13, struct S0 * const  p_14, uint32_t  p_15, int8_t  p_16, struct S0 * p_17);
static struct S0 * func_21(struct S0 * p_22, int32_t  p_23, uint16_t  p_24, struct S0  p_25, struct S0 * p_26);
static int8_t  func_29(int16_t  p_30);
static int32_t ** const * func_42(struct S0 * p_43, struct S0  p_44, struct S0 * const  p_45);
static struct S0 * func_46(int16_t  p_47, int8_t  p_48, int32_t * p_49, const struct S0  p_50, int32_t * p_51);
static const int32_t  func_54(int32_t * const  p_55, int32_t *** p_56, struct S0  p_57, int8_t  p_58, int8_t  p_59);
static struct S0  func_60(int16_t  p_61, uint16_t  p_62, uint32_t  p_63, int32_t  p_64, uint16_t  p_65);
inline static int16_t  func_66(struct S0 * p_67, int32_t  p_68, uint32_t  p_69, int32_t ** const  p_70);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes: g_2
 */
inline static const int32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_11 = 65535U;
    struct S0 *l_20 = &g_19[0];
    for (g_2 = 0; (g_2 != 4); g_2 = safe_add_func_uint32_t_u_u(g_2, 2))
    { /* block id: 3 */
        int8_t l_31 = 0xC2;
        struct S0 **l_273 = &g_18;
    }
    for (l_11 = 12; (l_11 > 3); l_11--)
    { /* block id: 159 */
        struct S0 **l_276 = (void*)0;
        int32_t l_277 = 0xAA367CD0;
        l_20 = &g_19[0];
        if (l_277)
            break;
    }
    return l_11;
}


/* ------------------------------------------ */
/* 
 * reads : g_35 g_217 g_190 g_38 g_101 g_100
 * writes: g_100 g_35 g_39 g_101 g_272
 */
inline static struct S0 * func_5(uint32_t  p_6)
{ /* block id: 77 */
    int32_t *l_194 = (void*)0;
    const int32_t *l_229 = &g_102[0][4][3];
    int32_t *** const l_230 = &g_38;
    int32_t l_235 = (-2);
    int8_t l_261 = 1;
lbl_197:
    l_194 = l_194;
    for (g_100 = 0; (g_100 == (-17)); --g_100)
    { /* block id: 81 */
        uint32_t l_198[7] = {0x124E345E,0x124E345E,0x124E345E,0x124E345E,0x124E345E,0x124E345E,0x124E345E};
        const int32_t *l_227 = &g_102[0][4][3];
        int32_t l_234[3];
        struct S0 ***l_262 = (void*)0;
        struct S0 ***l_263 = (void*)0;
        struct S0 **l_265 = &g_18;
        struct S0 ***l_264 = &l_265;
        int i;
        for (i = 0; i < 3; i = i + 1)
            l_234[i] = 7;
        for (g_35 = 0; (g_35 <= 0); g_35 += 1)
        { /* block id: 84 */
            int32_t l_226 = (-7);
            int i, j;
            if (g_35)
                goto lbl_197;
            if (l_198[5])
                continue;
        }
        (*l_264) = &g_18;
        if ((safe_mul_func_int8_t_s_s(p_6, p_6)))
        { /* block id: 142 */
            (***g_217) = &l_234[1];
            /* statement id: 143 */
            assert ((g_39 >= &l_234[0] && g_39 <= &l_234[2]));
        }
        else
        { /* block id: 144 */
            struct S0 *l_268 = &g_189[1];
            return l_268;
            /* statement id: 145 */
            //assert ((func_5_rv >= &g_189[0] && func_5_rv <= &g_189[6]));
        }
        /* facts after branching */
        assert ((g_39 >= &l_234[0] && g_39 <= &l_234[2]));
        for (g_101 = 0; (g_101 > 14); g_101 = safe_add_func_uint16_t_u_u(g_101, 1))
        { /* block id: 149 */
            int32_t *l_271 = &g_102[0][4][3];
            (*g_38) = l_271;
            /* statement id: 150 */
            assert ((g_39 >= &g_102[0][0][0] && g_39 <= &g_102[0][8][6]));
            g_272 = &g_217;
        }
        /* facts after for loop */
        assert ((g_39 >= &g_102[0][0][0] && g_39 <= &g_102[0][8][6]) || (g_39 >= &l_234[0] && g_39 <= &l_234[2]));
    }
    return &g_189[6];
    /* statement id: 154 */
    //assert ((func_5_rv >= &g_189[0] && func_5_rv <= &g_189[6]));
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_189.f1
 * writes: g_102
 */
inline static int16_t  func_12(struct S0 * p_13, struct S0 * const  p_14, uint32_t  p_15, int8_t  p_16, struct S0 * p_17)
{ /* block id: 74 */
    int32_t l_192 = 0x4FE049F0;
    int32_t *l_193 = &g_102[0][0][1];
    (*l_193) = ((l_192 > p_15) || g_2);
    return g_189[0].f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_38 g_19.f1 g_19.f5 g_19.f4 g_39 g_19.f0 g_2 g_96 g_19.f2 g_19.f3 g_100 g_92 g_102 g_187
 * writes: g_38 g_35 g_92 g_96 g_100 g_101 g_102 g_19.f0 g_190 g_39
 */
static struct S0 * func_21(struct S0 * p_22, int32_t  p_23, uint16_t  p_24, struct S0  p_25, struct S0 * p_26)
{ /* block id: 12 */
    int32_t ** const l_87 = &g_39;
    struct S0 *l_191[1];
    int i;
    for (i = 0; i < 1; i = i + 1)
        l_191[i] = &g_189[0];
    for (p_23 = 0; (p_23 < (-12)); --p_23)
    { /* block id: 15 */
        int32_t ***l_40 = (void*)0;
        int32_t ***l_41 = &g_38;
        int32_t l_86[1][5];
        struct S0 * const l_188[6][5] = {{&g_189[0],&g_189[0],&g_189[0],&g_189[4],&g_189[0]},{&g_189[0],&g_189[0],&g_189[0],&g_189[0],&g_189[0]},{&g_189[0],(void*)0,&g_189[5],&g_189[4],&g_189[0]},{&g_189[5],(void*)0,&g_189[0],&g_189[0],(void*)0},{&g_189[0],&g_189[0],&g_189[0],(void*)0,&g_189[0]},{&g_189[0],&g_189[0],&g_189[0],&g_189[5],&g_189[0]}};
        int i, j;
        for (i = 0; i < 1; i = i + 1)
        {
            for (j = 0; j < 5; j = j + 1)
                l_86[i][j] = 0xA8ABF266;
        }
        (*l_41) = g_38;
        g_190[3][0] = func_42(func_46(g_19[0].f1, (safe_mul_func_int8_t_s_s(func_29(g_19[0].f5), (func_54((*g_38), &g_38, func_60(func_66(&g_19[0], (((safe_mod_func_int16_t_s_s(((safe_mul_func_int16_t_s_s(((((safe_add_func_uint16_t_u_u((65535U || (safe_rshift_func_uint16_t_u_s((!(safe_mod_func_uint16_t_u_u(g_19[0].f0, (safe_mod_func_uint8_t_u_u((safe_mul_func_int8_t_s_s(0x80, g_19[0].f1)), p_25.f5))))), g_19[0].f0))), l_86[0][3])) > g_19[0].f0) < 0x42) | 0x368D), 0xDABF)) < 65526U), (***l_41))) >= (***l_41)) || p_23), g_19[0].f0, l_87), (**l_87), p_25.f0, g_19[0].f2, g_19[0].f3), g_19[0].f5, g_2) >= g_19[0].f4))), (*g_38), g_187, (**l_41)), g_187, l_188[4][4]);
    }
    (*g_38) = &p_23;
    /* statement id: 71 */
    assert (g_39 == &p_23);
    (*g_38) = (*l_87);
    return l_191[0];
    /* statement id: 73 */
    //assert (g_39 == dangling);
    //assert ((func_21_rv >= &g_189[0] && func_21_rv <= &g_189[6]));
}


/* ------------------------------------------ */
/* 
 * reads : g_19.f5 g_19.f1 g_19.f4
 * writes: g_35
 */
static int8_t  func_29(int16_t  p_30)
{ /* block id: 4 */
    for (p_30 = 23; (p_30 == 20); p_30 = safe_sub_func_uint32_t_u_u(p_30, 7))
    { /* block id: 7 */
        int32_t *l_34 = &g_35;
        (*l_34) = (g_19[0].f5 == g_19[0].f1);
        if (p_30)
            break;
    }
    return g_19[0].f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** const * func_42(struct S0 * p_43, struct S0  p_44, struct S0 * const  p_45)
{ /* block id: 67 */
    return &g_38;
    /* statement id: 68 */
    //assert (func_42_rv == &g_38);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_46(int16_t  p_47, int8_t  p_48, int32_t * p_49, const struct S0  p_50, int32_t * p_51)
{ /* block id: 64 */
    p_51 = p_51;
    return &g_19[0];
    /* statement id: 66 */
    //assert ((func_46_rv >= &g_19[0] && func_46_rv <= &g_19[0]));
}


/* ------------------------------------------ */
/* 
 * reads : g_100 g_19.f5 g_92 g_102 g_38 g_39 g_2
 * writes: g_100 g_96
 */
static const int32_t  func_54(int32_t * const  p_55, int32_t *** p_56, struct S0  p_57, int8_t  p_58, int8_t  p_59)
{ /* block id: 57 */
    uint32_t l_184 = 2U;
    for (g_100 = 26; (g_100 == 16); g_100 = safe_sub_func_uint16_t_u_u(g_100, 8))
    { /* block id: 60 */
        uint32_t l_172[5];
        int32_t *l_185 = (void*)0;
        int32_t *l_186 = &g_96[2][2][0];
        int i;
        for (i = 0; i < 5; i = i + 1)
            l_172[i] = 4294967286U;
        (*l_186) = ((4294967289U & (safe_lshift_func_uint16_t_u_u(g_19[0].f5, l_172[2]))) | (safe_rshift_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(((!(p_57.f0 != (0x86 <= g_92[0][4]))) != ((0 <= l_172[2]) | ((safe_unary_minus_func_uint8_t_u((!(safe_mul_func_int8_t_s_s(0x89, g_102[0][6][2]))))) >= g_19[0].f5))), l_184)), p_57.f0)));
    }
    return (***p_56);
}


/* ------------------------------------------ */
/* 
 * reads : g_19.f2 g_2 g_39 g_96 g_100 g_38
 * writes: g_19.f0
 */
static struct S0  func_60(int16_t  p_61, uint16_t  p_62, uint32_t  p_63, int32_t  p_64, uint16_t  p_65)
{ /* block id: 43 */
    int32_t *l_142[1];
    struct S0 l_167 = {7530,3,-1974,1,19,-37};
    int i;
    for (i = 0; i < 1; i = i + 1)
        l_142[i] = &g_96[2][2][0];
lbl_145:
    l_142[0] = l_142[0];
    for (p_62 = 9; (p_62 == 18); p_62 = safe_add_func_int8_t_s_s(p_62, 1))
    { /* block id: 47 */
        if (p_62)
            goto lbl_145;
    }
    g_19[0].f0 = (((safe_sub_func_uint16_t_u_u((safe_add_func_int8_t_s_s((g_19[0].f2 >= (safe_rshift_func_uint16_t_u_s(g_2, (0x37D70613 >= (*g_39))))), (safe_div_func_uint8_t_u_u(0U, 8U)))), 0xB6B1)) || ((p_63 && (safe_mul_func_int8_t_s_s((safe_sub_func_int32_t_s_s((safe_rshift_func_int16_t_s_u(((safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s((3 < p_61), g_96[2][2][0])), g_2)) && p_62), p_61)), 0xB642ED4B)), 0x2F))) & g_100)) > 0U);
    for (p_61 = 7; (p_61 >= 3); p_61 = safe_sub_func_int8_t_s_s(p_61, 6))
    { /* block id: 53 */
        int32_t **l_166 = &l_142[0];
        (*l_166) = (*g_38);
    }
    /* facts after for loop */
    //assert (l_142[0] == &g_2 || (l_142[0] >= &g_96[0][0][0] && l_142[0] <= &g_96[6][4][0]));
    return l_167;
}


/* ------------------------------------------ */
/* 
 * reads : g_39 g_2 g_96 g_19.f0 g_19.f1 g_19.f5 g_19.f4 g_38
 * writes: g_92 g_96 g_100 g_101 g_102
 */
inline static int16_t  func_66(struct S0 * p_67, int32_t  p_68, uint32_t  p_69, int32_t ** const  p_70)
{ /* block id: 17 */
    int8_t l_117 = (-9);
    int32_t l_118 = 0xEEC89669;
    int16_t l_141 = 0xA1B7;
    for (p_69 = 0; (p_69 != 42); p_69 = safe_add_func_int32_t_s_s(p_69, 1))
    { /* block id: 20 */
        int32_t *l_95 = &g_96[2][2][0];
        for (p_68 = (-22); (p_68 < (-26)); p_68 = safe_sub_func_int32_t_s_s(p_68, 7))
        { /* block id: 23 */
            int32_t *l_97 = &g_96[0][0][0];
            if ((**p_70))
                break;
            for (g_92[0][4] = 8; (g_92[0][4] >= (-20)); --g_92[0][4])
            { /* block id: 27 */
                int32_t *l_98 = (void*)0;
                int32_t *l_99 = &g_96[2][2][0];
                l_95 = (*p_70);
                /* statement id: 28 */
                assert (l_95 == &g_2);
                l_97 = (*p_70);
                /* statement id: 29 */
                assert (l_97 == &g_2);
                (*l_99) = (-7);
            }
            /* facts after for loop */
            assert (l_97 == &g_2 || (l_97 >= &g_96[0][0][0] && l_97 <= &g_96[6][4][0]));
            for (g_100 = 0; g_100 < 7; g_100 += 1)
            {
                for (g_101 = 0; g_101 < 5; g_101 += 1)
                {
                    for (g_102[0][4][3] = 0; g_102[0][4][3] < 1; g_102[0][4][3] += 1)
                    {
                        g_96[g_100][g_101][g_102[0][4][3]] = (-8);
                    }
                }
            }
            if ((**p_70))
                break;
        }
        /* facts after for loop */
        assert (l_95 == &g_2 || (l_95 >= &g_96[0][0][0] && l_95 <= &g_96[6][4][0]));
        for (p_68 = 0; (p_68 == 13); p_68 = safe_add_func_int8_t_s_s(p_68, 1))
        { /* block id: 37 */
            const int16_t l_107 = 6;
            uint16_t l_114[10] = {6U,6U,6U,6U,6U,6U,6U,6U,6U,6U};
            int i;
            l_118 = ((((safe_rshift_func_int8_t_s_u(l_107, 1)) && (((safe_mul_func_int8_t_s_s(((void*)0 != &g_39), (&p_70 != (void*)0))) <= (safe_lshift_func_int16_t_s_u((((safe_add_func_uint16_t_u_u(l_114[6], (p_68 && 0x09C2))) || (safe_lshift_func_int8_t_s_s(g_96[2][2][0], l_117))) & g_96[2][2][0]), g_19[0].f0))) & g_19[0].f1)) ^ p_69) || 0);
        }
    }
    g_92[0][4] = ((safe_sub_func_uint32_t_u_u((safe_sub_func_uint16_t_u_u((safe_mul_func_uint8_t_u_u((safe_sub_func_uint32_t_u_u(g_19[0].f5, (!l_118))), (safe_div_func_uint8_t_u_u(((safe_unary_minus_func_int8_t_s(((safe_mod_func_int8_t_s_s(l_118, ((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u((safe_add_func_uint32_t_u_u(((l_118 || (safe_div_func_int32_t_s_s((0x6F && (g_19[0].f1 == (0 && 255U))), ((l_118 < p_69) && l_118)))) || l_117), (*g_39))), 2)), l_141)) || 8U))) < 0))) && g_96[5][0][0]), 0x51)))), g_19[0].f4)), l_141)) || (**g_38));
    return p_68;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    for (i = 0; i < 1; i = i + 1)
    {
        transparent_crc(g_19[i].f0, "g_19[i].f0", print_hash_value);
        transparent_crc(g_19[i].f1, "g_19[i].f1", print_hash_value);
        transparent_crc(g_19[i].f2, "g_19[i].f2", print_hash_value);
        transparent_crc(g_19[i].f3, "g_19[i].f3", print_hash_value);
        transparent_crc(g_19[i].f4, "g_19[i].f4", print_hash_value);
        transparent_crc(g_19[i].f5, "g_19[i].f5", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_35, "g_35", print_hash_value);
    for (i = 0; i < 6; i = i + 1)
    {
        for (j = 0; j < 6; j = j + 1)
        {
            transparent_crc(g_92[i][j], "g_92[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 7; i = i + 1)
    {
        for (j = 0; j < 5; j = j + 1)
        {
            for (k = 0; k < 1; k = k + 1)
            {
                transparent_crc(g_96[i][j][k], "g_96[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_100, "g_100", print_hash_value);
    transparent_crc(g_101, "g_101", print_hash_value);
    for (i = 0; i < 1; i = i + 1)
    {
        for (j = 0; j < 9; j = j + 1)
        {
            for (k = 0; k < 7; k = k + 1)
            {
                transparent_crc(g_102[i][j][k], "g_102[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_187.f0, "g_187.f0", print_hash_value);
    transparent_crc(g_187.f1, "g_187.f1", print_hash_value);
    transparent_crc(g_187.f2, "g_187.f2", print_hash_value);
    transparent_crc(g_187.f3, "g_187.f3", print_hash_value);
    transparent_crc(g_187.f4, "g_187.f4", print_hash_value);
    transparent_crc(g_187.f5, "g_187.f5", print_hash_value);
    for (i = 0; i < 7; i = i + 1)
    {
        transparent_crc(g_189[i].f0, "g_189[i].f0", print_hash_value);
        transparent_crc(g_189[i].f1, "g_189[i].f1", print_hash_value);
        transparent_crc(g_189[i].f2, "g_189[i].f2", print_hash_value);
        transparent_crc(g_189[i].f3, "g_189[i].f3", print_hash_value);
        transparent_crc(g_189[i].f4, "g_189[i].f4", print_hash_value);
        transparent_crc(g_189[i].f5, "g_189[i].f5", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 8
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 6
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 27
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 35

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 59

XXX times a variable address is taken: 94
XXX times a pointer is dereferenced on RHS: 26
breakdown:
   depth: 1, occurrence: 16
   depth: 2, occurrence: 6
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 20
breakdown:
   depth: 1, occurrence: 15
   depth: 2, occurrence: 1
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 190

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 78
   level: 2, occurrence: 26
   level: 3, occurrence: 15
   level: 4, occurrence: 9
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 19
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 22
XXX average alias set size: 1.41

XXX times a non-volatile is read: 219
XXX times a non-volatile is write: 91
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 56
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 15
   depth: 2, occurrence: 11
   depth: 3, occurrence: 3

XXX percentage a fresh-made variable is used: 15.7
XXX percentage an existing variable is used: 84.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

