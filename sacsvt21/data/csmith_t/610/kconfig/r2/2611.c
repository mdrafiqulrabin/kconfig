/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      233287102
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 13;
   unsigned f1 : 14;
   signed f2 : 24;
   signed f3 : 4;
   uint16_t  f4;
   unsigned f5 : 14;
   signed f6 : 20;
   unsigned f7 : 25;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int16_t g_20 = 0x3FFA;
static int16_t g_114 = 0x3BAB;
static uint16_t g_117 = 0x5273;
static int32_t g_118 = 0xED0C0D0C;
static struct S0 g_178 = {-84,25,507,3,0x3508,85,211,2056};
static struct S0 g_278 = {-75,10,-192,-0,0xAA07,93,669,2439};
static int16_t g_425 = 3;


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_28(void);
static int32_t  func_32(struct S0  p_33, struct S0  p_34, uint16_t  p_35, int32_t  p_36);
static struct S0  func_37(uint32_t  p_38, int32_t  p_39, int16_t  p_40, int16_t  p_41);
static int16_t  func_42(struct S0  p_43, int32_t  p_44, uint32_t  p_45);
static struct S0  func_46(uint32_t  p_47, uint32_t  p_48, int32_t  p_49);
static uint32_t  func_57(int16_t  p_58);
static struct S0  func_59(int32_t  p_60);
static uint16_t  func_62(uint16_t  p_63);
static int32_t  func_64(uint16_t  p_65, int32_t  p_66, uint16_t  p_67);
static uint16_t  func_68(int32_t  p_69, int16_t  p_70, int16_t  p_71, uint32_t  p_72);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_20 g_114 g_117 g_118 g_178 g_278 g_425
 * writes: g_20 g_114 g_117 g_118 g_178.f3 g_178.f2 g_178 g_278.f0 g_278.f6 g_278
 */
static uint16_t  func_28(void)
{ /* block id: 36 */
    int16_t l_29 = 0x1615;
    int32_t l_290 = (-1);
    int32_t l_359 = 7;
    int32_t l_401 = (-1);
    uint32_t l_443 = 4294967295U;
    struct S0 l_459 = {16,0,2398,1,0x8916,65,113,3613};
    int32_t l_491 = 0x8AAE05D8;
    l_29 = g_20;
    for (g_20 = 0; (g_20 == (-20)); g_20 -= 7)
    { /* block id: 40 */
        uint16_t l_56 = 0xF3A4;
        uint16_t l_341 = 0x8C62;
        int32_t l_345 = (-5);
        struct S0 l_354 = {61,43,423,-3,0x4B7D,59,-355,2889};
        int32_t l_379 = 0x3005CFBD;
        uint32_t l_386 = 4294967295U;
        struct S0 l_393 = {66,61,2343,1,1U,63,-0,5153};
        uint16_t l_486 = 0xD3EC;
        if (g_20)
        { /* block id: 41 */
            uint32_t l_245 = 0U;
            l_290 = func_32(func_37((((0x71CC545E || g_20) & (func_42(func_46((0xECB4 && ((int16_t)(((((uint16_t)((int32_t)l_56 + (int32_t)g_20) >> (uint16_t)(__builtin_clz(func_57(g_20)) | (((int16_t)__builtin_ctzll((!0x2CDD3E71)) % (int16_t)g_20) || (-2)))) >= g_20) != l_56) < 0U) % (int16_t)l_29)), l_56, g_20), g_20, l_245) < 0x0E0B)) < 0x1384), l_56, l_56, g_20), g_278, g_278.f5, l_56);
        }
        else
        { /* block id: 172 */
            uint32_t l_295 = 0x86674992;
            struct S0 l_351 = {55,75,54,-3,6U,63,315,3855};
            struct S0 l_353 = {-35,16,-1357,1,0x6D1B,6,780,4098};
            for (l_290 = 0; (l_290 > (-7)); l_290 -= 1)
            { /* block id: 175 */
                uint32_t l_299 = 0xB5A75136;
                int32_t l_312 = 0xE71DC64E;
                uint32_t l_323 = 0xA71F94C5;
                struct S0 l_348 = {3,113,-2221,3,65535U,61,-871,3441};
                g_278.f0 = g_117;
                g_118 = ((((int16_t)l_295 - (int16_t)3) > (~0x2718)) < (((((int32_t)__builtin_bswap32(g_178.f1) + (int32_t)(((l_299 != ((int16_t)((uint32_t)g_278.f4 - (uint32_t)g_20) << (int16_t)3)) == l_56) >= l_295)) < 0U) && 4294967289U) & l_299));
                if ((g_278.f7 && (l_299 < ((0x773CC981 ^ ((l_299 | ((uint16_t)((((int16_t)((uint16_t)(((uint32_t)(g_278.f0 < func_64(l_312, g_20, ((uint16_t)(((uint16_t)9U << (uint16_t)(~(((uint16_t)((uint16_t)(!0x9FF5) >> (uint16_t)g_117) + (uint16_t)g_178.f5) < g_278.f5))) < g_278.f3) >> (uint16_t)l_56))) % (uint32_t)g_178.f1) | 0x802A) + (uint16_t)0x2BE1) >> (int16_t)g_278.f5) != 1U) != 65529U) % (uint16_t)2U)) || g_278.f6)) && l_323))))
                { /* block id: 178 */
                    uint32_t l_324 = 4294967288U;
                    g_278.f0 = ((l_324 <= l_295) > ((((((uint32_t)((0xB02E & (g_278.f7 <= ((uint16_t)(((((func_64(l_324, (l_295 >= ((uint32_t)0x19111DD0 + (uint32_t)(((int32_t)(-1) % (int32_t)((int16_t)l_290 << (int16_t)5)) > l_323))), g_117) > l_56) & l_295) != 0x9DAEE6FF) <= l_29) || 0x4CCE) >> (uint16_t)6))) ^ l_56) % (uint32_t)8) | 0x5B72) | g_278.f6) < l_295) & l_323));
                }
                else
                { /* block id: 180 */
                    g_278.f6 = g_278.f0;
                }
                for (l_295 = 0; (l_295 > 55); l_295 += 1)
                { /* block id: 185 */
                    struct S0 l_352 = {39,47,2012,-2,0xC2D3,58,-627,4626};
                    l_345 = ((uint16_t)((int16_t)__builtin_ffsl(l_323) % (int16_t)l_341) >> (uint16_t)((uint16_t)g_178.f3 >> (uint16_t)(~l_295)));
                    for (l_312 = 5; (l_312 == 17); l_312 += 1)
                    { /* block id: 189 */
                        g_178 = l_348;
                    }
                    if (g_278.f1)
                        break;
                    for (g_118 = 0; (g_118 != (-27)); g_118 -= 1)
                    { /* block id: 195 */
                        l_352 = l_351;
                    }
                }
            }
            l_353 = g_178;
            l_354 = func_37(g_278.f2, g_118, ((-7) && l_290), g_278.f6);
        }
        g_178 = g_278;
        if (((uint32_t)2U - (uint32_t)((0xB6B6F650 || (l_354.f1 == __builtin_ia32_crc32qi(((int16_t)l_359 << (int16_t)g_278.f2), (l_290 & ((int32_t)g_117 % (int32_t)l_354.f4))))) | g_117)))
        { /* block id: 204 */
            int32_t l_376 = 0xD4135D0B;
            struct S0 l_446 = {76,9,-3843,1,9U,106,62,2005};
            for (g_114 = (-12); (g_114 < 20); g_114 += 4)
            { /* block id: 207 */
                int16_t l_373 = 0x8EC6;
                for (l_354.f4 = 0; (l_354.f4 < 36); l_354.f4 += 8)
                { /* block id: 210 */
                    int32_t l_372 = (-8);
                    l_373 = ((-7) == ((uint16_t)(((int32_t)__builtin_ffsll(g_178.f4) - (int32_t)((int16_t)(g_278.f5 ^ l_372) << (int16_t)0)) ^ l_354.f0) + (uint16_t)l_29));
                    for (g_178.f4 = 0; (g_178.f4 <= 39); g_178.f4 += 9)
                    { /* block id: 214 */
                        int32_t l_380 = 0xC1D93898;
                        l_380 = (g_20 >= ((func_62(l_376) | (g_117 && g_178.f0)) || ((int32_t)(g_278.f7 & __builtin_bswap64((0U == g_278.f5))) + (int32_t)l_379)));
                    }
                }
            }
            l_359 = func_57(g_114);
            g_178.f6 = (l_359 || l_354.f0);
            if (((uint16_t)0x8AA3 - (uint16_t)(!0x4D92)))
            { /* block id: 221 */
                l_354.f0 = (((uint16_t)(l_386 ^ 4294967295U) >> (uint16_t)2) > (((g_118 || (((int32_t)(-6) + (int32_t)(((int16_t)((int16_t)(0x7C6CCAD6 ^ 4294967293U) >> (int16_t)4) >> (int16_t)((func_68(g_117, g_178.f2, l_354.f3, l_376) > g_278.f5) >= g_20)) || 0)) > 0x2C9CAB9F)) <= 1U) > (-3)));
                g_118 = l_376;
            }
            else
            { /* block id: 224 */
                struct S0 l_394 = {-71,109,3752,-2,0x62C7,30,-23,4180};
                uint16_t l_426 = 65531U;
                if (l_29)
                    break;
                if (__builtin_popcount(func_32(l_393, l_394, g_118, (((uint16_t)__builtin_bswap32((g_278.f2 != ((g_178.f1 < (l_379 != ((int32_t)((g_278.f1 <= ((int16_t)g_178.f6 >> (int16_t)8)) ^ __builtin_ffsll((l_394.f7 > g_178.f7))) + (int32_t)l_401))) || l_290))) << (uint16_t)3) || 1U))))
                { /* block id: 226 */
                    uint32_t l_424 = 1U;
                    l_394.f3 = ((int16_t)((int32_t)((int32_t)g_278.f7 % (int32_t)((uint32_t)g_278.f6 % (uint32_t)(g_278.f5 && (~(-1))))) + (int32_t)((g_278.f0 == (((int16_t)((uint16_t)((int16_t)((((0xA3A97D95 <= ((-1) & ((int16_t)((~(__builtin_popcountl(((uint32_t)(l_401 == ((int16_t)5 + (int16_t)g_278.f5)) % (uint32_t)l_424)) ^ g_178.f4)) == 8) >> (int16_t)4))) | 0xAC16) > 1U) < l_424) - (int16_t)g_425) - (uint16_t)0xBCE8) >> (int16_t)g_118) && l_424)) | 2)) - (int16_t)0x5589);
                    g_278.f6 = l_426;
                }
                else
                { /* block id: 229 */
                    uint32_t l_439 = 1U;
                    if ((((int16_t)((g_178.f6 == (((-(int32_t)((int16_t)(-3) >> (int16_t)(((0xE398 < (-(int32_t)(g_178.f5 & (((((int16_t)(0x8059 || ((uint16_t)l_376 >> (uint16_t)((uint16_t)g_178.f5 >> (uint16_t)(g_278.f7 >= (l_29 || g_278.f1))))) % (int16_t)l_439) | g_278.f2) & 0U) & 3)))) && g_178.f5) == g_278.f5))) > g_114) < 0xF69492F3)) >= 0xCA75) << (int16_t)1) && l_29))
                    { /* block id: 230 */
                        uint32_t l_440 = 1U;
                        int32_t l_444 = 0x9A155680;
                        l_444 = (((g_178.f7 | (l_440 > (0 > ((uint16_t)(func_62((1 | (0xEC50A47C && func_64(l_290, l_439, ((l_393.f2 < func_62(g_117)) != l_440))))) && g_20) - (uint16_t)l_376)))) & l_443) > 0xF6880B50);
                    }
                    else
                    { /* block id: 232 */
                        struct S0 l_445 = {-11,72,-3007,1,0x92FD,118,977,241};
                        l_445 = g_178;
                        g_178.f6 = l_393.f3;
                        g_278 = l_446;
                    }
                    if (l_359)
                        continue;
                    for (l_379 = 5; (l_379 >= 3); l_379 -= 1)
                    { /* block id: 240 */
                        if (l_394.f1)
                            break;
                        return l_446.f5;
                    }
                }
                for (l_345 = 19; (l_345 != 12); l_345 -= 1)
                { /* block id: 247 */
                    return g_178.f3;
                }
            }
        }
        else
        { /* block id: 251 */
            uint32_t l_474 = 1U;
            int16_t l_485 = 0xD4EB;
            int32_t l_487 = 0;
            g_278.f3 = ((int32_t)((__builtin_ffsll(((int16_t)(((g_20 != (((uint16_t)((int16_t)func_42(l_459, g_118, (((uint32_t)((int16_t)((!((1 != (l_386 == ((int16_t)((uint16_t)l_393.f5 >> (uint16_t)l_393.f0) << (int16_t)((((((g_178.f7 <= ((((uint16_t)(~((int16_t)0xBE7E - (int16_t)g_118)) % (uint16_t)g_178.f0) <= g_278.f0) == 0x12A16887)) < (-9)) != 65528U) | 0x2C7D) | g_278.f5) > l_459.f0)))) | l_474)) ^ (-1)) - (int16_t)0x6B18) - (uint32_t)g_278.f0) ^ 0x9D09)) >> (int16_t)3) + (uint16_t)l_474) == 0x56B3CF16)) != l_474) < 1) << (int16_t)4)) < g_278.f6) && (-2)) % (int32_t)l_393.f4);
            l_487 = ((l_393.f2 >= (((int16_t)(-1) % (int16_t)((__builtin_popcountll((((int16_t)0x45A3 << (int16_t)(((l_474 | (g_118 >= ((int16_t)((int16_t)((uint32_t)(((g_278.f6 || g_178.f5) <= l_290) == l_485) + (uint32_t)g_278.f4) % (int16_t)l_486) % (int16_t)g_114))) || g_278.f3) != 3U)) | g_117)) != l_485) || 0x57725044)) <= (-9))) && l_393.f0);
            if (g_278.f7)
                break;
        }
        if (g_278.f4)
            break;
    }
    g_278.f3 = ((uint16_t)(-(uint16_t)func_42(g_278, l_459.f2, ((g_278.f5 ^ __builtin_bswap32((l_491 || ((g_178.f7 < ((int32_t)g_278.f6 + (int32_t)((uint32_t)g_178.f0 - (uint32_t)(__builtin_clzl((4294967295U ^ l_459.f3)) | 1)))) ^ g_278.f2)))) >= l_459.f0))) - (uint16_t)0x2915);
    l_459 = func_59(func_42(func_37(l_443, g_278.f2, l_459.f1, g_425), g_20, g_20));
    return g_178.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_278.f7 g_278.f2
 * writes: g_178.f0 g_178
 */
static int32_t  func_32(struct S0  p_33, struct S0  p_34, uint16_t  p_35, int32_t  p_36)
{ /* block id: 160 */
    uint32_t l_279 = 0x790BFC1F;
    int32_t l_287 = 0xBC070C9E;
    struct S0 l_289 = {12,51,1034,-0,0x9923,106,866,1361};
    g_178.f0 = (p_35 & l_279);
    if ((-(uint16_t)2U))
    { /* block id: 162 */
        uint16_t l_281 = 7U;
        l_281 = p_34.f4;
        p_33.f3 = p_34.f6;
        l_287 = (~((uint16_t)8U - (uint16_t)((uint16_t)((g_278.f7 > l_279) && p_33.f6) << (uint16_t)l_281)));
    }
    else
    { /* block id: 166 */
        uint16_t l_288 = 65530U;
        p_34.f3 = __builtin_ctz(l_288);
    }
    g_178 = l_289;
    return g_278.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_178 g_114 g_20 g_118
 * writes: g_178
 */
static struct S0  func_37(uint32_t  p_38, int32_t  p_39, int16_t  p_40, int16_t  p_41)
{ /* block id: 155 */
    int32_t l_261 = (-7);
    uint32_t l_272 = 0U;
    struct S0 l_277 = {81,26,876,0,3U,30,524,4448};
    g_178 = g_178;
    p_39 = (((0x34CEBFDD && (((g_114 > func_62(g_178.f7)) == ((p_38 >= (0x0062 > l_261)) | ((int16_t)(((((int16_t)((uint16_t)((uint32_t)(p_39 | g_178.f1) % (uint32_t)g_118) - (uint16_t)1U) - (int16_t)65535U) != g_114) && p_39) ^ 0) << (int16_t)6))) | p_38)) != 1U) >= g_178.f0);
    p_39 = ((((int16_t)l_272 % (int16_t)l_261) == ((l_261 >= (0x9D27FB23 ^ ((l_261 > 0) ^ ((int32_t)(((((int16_t)__builtin_clz(p_41) + (int16_t)p_40) == p_38) != 0U) || g_118) % (int32_t)0x6318D7ED)))) | g_178.f5)) > p_40);
    return l_277;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_178
 */
static int16_t  func_42(struct S0  p_43, int32_t  p_44, uint32_t  p_45)
{ /* block id: 150 */
    int32_t l_258 = 0xE2050388;
    p_43.f6 = __builtin_clzll(((uint16_t)((int16_t)3 >> (int16_t)p_43.f5) << (uint16_t)((int16_t)((uint32_t)p_43.f5 % (uint32_t)((uint32_t)((uint16_t)l_258 << (uint16_t)14) - (uint32_t)(-7))) << (int16_t)9)));
    p_43.f2 = ((uint16_t)(l_258 && 0x32C21BFE) >> (uint16_t)p_44);
    g_178 = p_43;
    return l_258;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_46(uint32_t  p_47, uint32_t  p_48, int32_t  p_49)
{ /* block id: 148 */
    struct S0 l_244 = {-61,30,1717,-1,65535U,0,-807,4776};
    return l_244;
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_114 g_117 g_118 g_178
 * writes: g_114 g_117 g_118 g_178.f3 g_178.f2 g_178
 */
static uint32_t  func_57(int16_t  p_58)
{ /* block id: 42 */
    struct S0 l_240 = {70,7,-1013,-2,65535U,126,-323,4897};
    l_240 = func_59(g_20);
    l_240 = func_59(l_240.f5);
    g_178.f0 = p_58;
    return l_240.f6;
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_114 g_117 g_118 g_178
 * writes: g_114 g_117 g_118 g_178.f3 g_178.f2 g_178
 */
static struct S0  func_59(int32_t  p_60)
{ /* block id: 43 */
    uint32_t l_61 = 0x29F19B52;
    struct S0 l_239 = {41,114,-1497,1,0x0AEF,46,151,417};
    if ((l_61 && func_62(__builtin_parity((__builtin_parity(((((func_64(func_68(l_61, l_61, g_20, ((-(uint16_t)((g_20 == g_20) ^ 65535U)) | (((((l_61 != 1) != 0xC1E9) & l_61) | p_60) > 0xB12B))), p_60, p_60) | 4294967295U) <= p_60) <= 1) < p_60)) & g_20)))))
    { /* block id: 134 */
        uint16_t l_234 = 65530U;
        int32_t l_235 = (-6);
        l_235 = (((uint16_t)(((uint16_t)((uint32_t)p_60 % (uint32_t)((0xDDF3FE31 > g_178.f3) & ((uint16_t)4U >> (uint16_t)12))) << (uint16_t)3) > (((int16_t)__builtin_ffs(g_178.f0) << (int16_t)1) && ((l_234 <= 0x271F) || ((g_118 || g_178.f6) == g_178.f7)))) << (uint16_t)13) ^ l_234);
    }
    else
    { /* block id: 136 */
        struct S0 l_238 = {82,72,-3802,2,0x3F47,126,-101,1211};
        for (p_60 = (-10); (p_60 <= (-6)); p_60 += 1)
        { /* block id: 139 */
            l_239 = l_238;
        }
    }
    return l_239;
}


/* ------------------------------------------ */
/* 
 * reads : g_20
 * writes:
 */
static uint16_t  func_62(uint16_t  p_63)
{ /* block id: 132 */
    return g_20;
}


/* ------------------------------------------ */
/* 
 * reads : g_118 g_178.f1 g_178.f2 g_178.f4 g_114
 * writes: g_118
 */
static int32_t  func_64(uint16_t  p_65, int32_t  p_66, uint16_t  p_67)
{ /* block id: 120 */
    uint32_t l_195 = 4294967293U;
    int32_t l_214 = 1;
    for (g_118 = (-10); (g_118 == (-9)); g_118 += 7)
    { /* block id: 123 */
        l_195 = p_67;
    }
    if (((int16_t)((int32_t)g_178.f1 % (int32_t)((uint32_t)((int32_t)g_178.f1 + (int32_t)(l_195 == (g_178.f2 ^ g_178.f4))) % (uint32_t)p_65)) - (int16_t)((int16_t)p_66 - (int16_t)l_195)))
    { /* block id: 126 */
        uint32_t l_222 = 0xFCF7A0FF;
        l_222 = ((uint32_t)((int16_t)(((uint32_t)(p_65 != ((int16_t)l_195 - (int16_t)l_214)) - (uint32_t)((int16_t)((int16_t)(g_178.f4 && (((int16_t)p_65 >> (int16_t)__builtin_ffsll((p_66 != ((l_195 == (0xE43E4D88 || (~((g_178.f4 || 0x446E) == l_214)))) && (-1))))) < 0x83A5F4DC)) << (int16_t)5) - (int16_t)0x8658)) == p_67) << (int16_t)11) % (uint32_t)0xDFD8CB9A);
        return g_114;
    }
    else
    { /* block id: 129 */
        uint32_t l_223 = 1U;
        return l_223;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_114 g_117 g_118 g_178
 * writes: g_114 g_117 g_118 g_178.f3 g_178.f2 g_178
 */
static uint16_t  func_68(int32_t  p_69, int16_t  p_70, int16_t  p_71, uint32_t  p_72)
{ /* block id: 44 */
    struct S0 l_74 = {42,22,2000,1,0x93EB,86,811,5326};
    int32_t l_91 = 0xF8266116;
    uint32_t l_139 = 0x04BDE658;
    l_74 = l_74;
    for (p_72 = 29; (p_72 < 40); p_72 += 6)
    { /* block id: 48 */
        struct S0 l_116 = {-89,108,2881,-3,0U,11,524,194};
        for (p_70 = (-18); (p_70 < (-21)); p_70 -= 1)
        { /* block id: 51 */
            uint16_t l_88 = 0U;
            struct S0 l_115 = {70,50,-2902,0,0xF28F,102,406,2667};
            for (l_74.f4 = 27; (l_74.f4 < 57); l_74.f4 += 5)
            { /* block id: 54 */
                uint16_t l_81 = 0x355D;
                struct S0 l_106 = {14,86,1335,-0,0xD7D5,99,689,1156};
                if (p_69)
                    break;
                if (l_81)
                { /* block id: 56 */
                    int16_t l_85 = 2;
                    p_69 = ((int16_t)(-(int16_t)((-8) | l_85)) % (int16_t)p_70);
                    return g_20;
                }
                else
                { /* block id: 59 */
                    uint16_t l_96 = 0U;
                    uint32_t l_105 = 0xCD7C5103;
                    l_91 = ((uint32_t)(0x2C3D != ((((g_20 <= __builtin_clz(p_72)) > (l_88 == g_20)) && g_20) <= (((uint16_t)(l_81 <= 4294967291U) >> (uint16_t)12) || p_70))) - (uint32_t)(-1));
                    p_69 = ((uint16_t)((int32_t)__builtin_ctzll((l_96 && ((uint16_t)65533U >> (uint16_t)(0x6A28 != ((int16_t)(((0x229B ^ g_20) || l_96) > 65535U) << (int16_t)((uint16_t)p_69 << (uint16_t)((int16_t)(l_74.f2 || 7U) % (int16_t)l_81))))))) - (int32_t)0x1C42294E) + (uint16_t)l_105);
                    l_106 = l_74;
                    l_106.f2 = g_20;
                }
            }
            for (l_91 = (-20); (l_91 != 8); l_91 += 4)
            { /* block id: 68 */
                int16_t l_113 = 0xED9E;
                if (((int16_t)((uint16_t)0x3964 << (uint16_t)l_113) + (int16_t)(-1)))
                { /* block id: 69 */
                    g_114 = 0x972AE315;
                    l_116 = l_115;
                }
                else
                { /* block id: 72 */
                    g_117 = g_114;
                    return l_113;
                }
                g_118 = p_70;
                l_115 = l_115;
            }
            l_74 = l_116;
        }
        for (l_74.f4 = 12; (l_74.f4 < 20); l_74.f4 += 1)
        { /* block id: 83 */
            uint32_t l_129 = 0x29DAAEC3;
            int32_t l_165 = 5;
            struct S0 l_179 = {52,26,-980,1,65530U,111,-359,3465};
            for (g_117 = 0; (g_117 < 55); g_117 += 8)
            { /* block id: 86 */
                int16_t l_138 = 0x7AE6;
                l_129 = (__builtin_clzll(g_118) != (((uint32_t)(g_20 >= g_114) + (uint32_t)l_74.f5) | ((uint16_t)((int16_t)g_114 + (int16_t)(-7)) + (uint16_t)g_118)));
                l_138 = ((g_20 < 0xE4ACFCA9) & (__builtin_clzll((((((int16_t)__builtin_bswap32(g_20) << (int16_t)(1U ^ ((uint16_t)g_114 + (uint16_t)((int32_t)((uint16_t)(g_20 <= l_129) << (uint16_t)(((l_116.f1 > 6) == l_129) || g_114)) % (int32_t)p_71)))) && 0xB487) | g_117) ^ 0x60A15E1F)) > 0xDE94));
                g_118 = l_139;
            }
            if (g_114)
            { /* block id: 91 */
                int32_t l_144 = 0x0892C684;
                g_118 = (__builtin_clzl((g_118 >= ((((uint32_t)0x1B5D9575 % (uint32_t)g_117) != (((uint32_t)(p_71 && (l_144 ^ 0x5176)) - (uint32_t)(((-(uint16_t)(((int16_t)(!(p_70 >= l_129)) >> (int16_t)g_20) & g_20)) != l_116.f2) ^ p_70)) < l_144)) ^ l_144))) <= 0x58A08054);
            }
            else
            { /* block id: 93 */
                int32_t l_164 = 0x80869599;
                if (l_129)
                    break;
                l_165 = ((-(int16_t)((uint32_t)p_69 % (uint32_t)p_69)) ^ ((int32_t)((uint32_t)((((uint16_t)((~(l_116.f7 < (~g_20))) == ((int16_t)p_71 << (int16_t)11)) << (uint16_t)9) <= (g_114 ^ ((int16_t)l_164 % (int16_t)g_114))) < (l_164 >= p_69)) - (uint32_t)1) % (int32_t)p_71));
                if (l_116.f6)
                    continue;
                for (l_91 = (-8); (l_91 <= (-15)); l_91 -= 1)
                { /* block id: 99 */
                    uint32_t l_173 = 0x5341DB1E;
                    if (((~((uint16_t)p_70 << (uint16_t)(((uint16_t)__builtin_ffsl((l_173 != 0x6DAF)) << (uint16_t)9) & (((uint32_t)(((uint16_t)0xD9A8 + (uint16_t)((l_116.f5 > __builtin_bswap32((0x8185 <= (((l_129 != __builtin_clz(g_117)) >= l_74.f6) && 0x042E)))) != l_164)) && p_71) + (uint32_t)p_72) < 0x690D2E26)))) < p_71))
                    { /* block id: 100 */
                        g_118 = 0xA631AE8C;
                        l_179 = g_178;
                    }
                    else
                    { /* block id: 103 */
                        uint32_t l_182 = 0x2A72BD43;
                        if (p_72)
                            break;
                        g_178.f3 = ((((uint16_t)(g_117 <= __builtin_ia32_crc32qi(g_178.f4, l_182)) << (uint16_t)((((((int32_t)p_71 - (int32_t)((uint16_t)(1 <= l_173) % (uint16_t)((uint32_t)0x1B42956F - (uint32_t)((uint32_t)l_173 % (uint32_t)l_182)))) < g_178.f5) > g_178.f3) ^ g_117) && g_178.f3)) != 0xAC28) < l_164);
                        if (p_69)
                            continue;
                    }
                    for (l_164 = 0; (l_164 < (-16)); l_164 -= 1)
                    { /* block id: 110 */
                        return g_178.f3;
                    }
                }
            }
            g_178.f2 = (0 < g_178.f4);
        }
    }
    g_178 = l_74;
    return p_71;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_20, "g_20", print_hash_value);
    transparent_crc(g_114, "g_114", print_hash_value);
    transparent_crc(g_117, "g_117", print_hash_value);
    transparent_crc(g_118, "g_118", print_hash_value);
    transparent_crc(g_178.f0, "g_178.f0", print_hash_value);
    transparent_crc(g_178.f1, "g_178.f1", print_hash_value);
    transparent_crc(g_178.f2, "g_178.f2", print_hash_value);
    transparent_crc(g_178.f3, "g_178.f3", print_hash_value);
    transparent_crc(g_178.f4, "g_178.f4", print_hash_value);
    transparent_crc(g_178.f5, "g_178.f5", print_hash_value);
    transparent_crc(g_178.f6, "g_178.f6", print_hash_value);
    transparent_crc(g_178.f7, "g_178.f7", print_hash_value);
    transparent_crc(g_278.f0, "g_278.f0", print_hash_value);
    transparent_crc(g_278.f1, "g_278.f1", print_hash_value);
    transparent_crc(g_278.f2, "g_278.f2", print_hash_value);
    transparent_crc(g_278.f3, "g_278.f3", print_hash_value);
    transparent_crc(g_278.f4, "g_278.f4", print_hash_value);
    transparent_crc(g_278.f5, "g_278.f5", print_hash_value);
    transparent_crc(g_278.f6, "g_278.f6", print_hash_value);
    transparent_crc(g_278.f7, "g_278.f7", print_hash_value);
    transparent_crc(g_425, "g_425", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 71
   depth: 1, occurrence: 23
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 23
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 21
XXX times a bitfields struct on RHS: 25
XXX times a single bitfield on LHS: 19
XXX times a single bitfield on RHS: 110

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 133
   depth: 2, occurrence: 28
   depth: 3, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 4
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 5
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 2
   depth: 32, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 442
XXX times a non-volatile is write: 89
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 129
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 16
   depth: 2, occurrence: 18
   depth: 3, occurrence: 23
   depth: 4, occurrence: 26
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 19.1
XXX percentage an existing variable is used: 80.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

