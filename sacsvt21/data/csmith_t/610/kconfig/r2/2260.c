/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      638639020
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   int32_t  f1;
   uint8_t  f2;
   const int32_t  f3;
   float  f4;
   int32_t  f5;
   uint64_t  f6;
   float  f7;
   const uint16_t  f8;
};

union U1 {
   int32_t  f0;
   struct S0  f1;
   uint32_t  f2;
};

union U2 {
   const int16_t  f0;
   unsigned f1 : 16;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_28(void);
static const int32_t * func_30(int32_t  p_31, int32_t * p_32, int32_t  p_33, int32_t * p_34, int32_t  p_35);
inline static int32_t * func_37(int16_t  p_38, int16_t  p_39);
inline static struct S0 * func_41(int64_t  p_42, int32_t * p_43, int32_t  p_44, union U1  p_45);
inline static int32_t * func_46(uint32_t  p_47, const struct S0 * p_48, int32_t * p_49, union U2  p_50);
inline static int32_t * func_55(int32_t * p_56);
static int32_t * func_57(uint8_t  p_58);
inline static float  func_62(int32_t * p_63, int32_t * p_64, const uint32_t  p_65, int32_t * p_66);
static int32_t * func_67(struct S0  p_68, uint32_t  p_69, float  p_70, union U2  p_71, int32_t * p_72);
inline static const uint16_t  func_74(int32_t * p_75, int32_t * p_76);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_28(void)
{ /* block id: 36 */
    uint64_t l_29 = 18446744073709551615UL;
    int32_t l_40 = (-5L);
    union U2 *****l_991 = (void*)0;
    int32_t l_996 = 0x3C3289A3L;
    int32_t *l_1003 = &l_996;
    int32_t **l_1002 = &l_1003;
    int32_t ***l_1001 = &l_1002;
    float l_1005 = 0x6.8E780Ep-46;
    float *l_1004 = &l_1005;
    union U1 l_1006 = {1L};
    if ((0x66BCL == l_29))
    { /* block id: 37 */
        int16_t l_36 = 0xCF5AL;
        int32_t l_842 = 0xDF25B063L;
        int32_t *l_841 = &l_842;
        const int32_t *l_990 = &l_842;
        union U2 ****l_993 = (void*)0;
        union U2 *****l_992 = &l_993;
        l_990 = func_30(l_36, func_37(l_40, l_36), (((uint64_t)(func_74(l_841, func_37(((uint16_t)(__builtin_popcountl((*l_841)) != 18446744073709551606UL) % (uint16_t)l_29), (*l_841))) == 0x1CA0DDABL) + (uint64_t)l_40) <= 0x46A13A8B2981FC43LL), &l_842, l_29);
        /* statement id: 579 */
        assert (l_990 == 0);
        l_992 = l_991;
        /* statement id: 580 */
        assert (l_992 == 0);
    }
    else
    { /* block id: 581 */
        int32_t l_995 = 0xEA13693BL;
        int32_t *l_994 = &l_995;
        (*l_994) = l_40;
    }
    l_996 = (-9L);
    (*l_1004) = ((float)(((float)(((__builtin_ctz(l_29) == l_40) > 0xE.08F352p-8) >= l_996) - (float)__builtin_popcountl(l_29)) != ((void*)0 == l_1001)) / (float)(**l_1002));
    (*l_1002) = (**l_1001);
    return l_1006;
    /* statement id: 587 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_30(int32_t  p_31, int32_t * p_32, int32_t  p_33, int32_t * p_34, int32_t  p_35)
{ /* block id: 497 */
    union U2 *l_846 = (void*)0;
    int32_t l_847 = 2L;
    union U2 * const *l_866 = &l_846;
    union U2 * const **l_865 = &l_866;
    union U2 * const ***l_864 = &l_865;
    struct S0 l_874 = {0x06953BD2L,5L,0xF7L,0x8151E5C5L,0x1.29EEFFp+36,0L,0xF492B3935B25A58BLL,0xD.9D207Cp-16,0x2617L};
    struct S0 * const l_873 = &l_874;
    struct S0 * const *l_872 = &l_873;
    struct S0 * const **l_871 = &l_872;
    struct S0 * const ***l_870 = &l_871;
    struct S0 * const ****l_869 = &l_870;
    union U1 l_969 = {0x555B2405L};
    union U1 *l_968 = &l_969;
    const int32_t *l_979 = &l_847;
    const int32_t *l_980 = &l_847;
    const int32_t *l_982 = &l_874.f1;
    const int32_t *l_983 = &l_874.f3;
    const int32_t *l_984 = &l_874.f3;
    const int32_t *l_985 = &l_847;
    const int32_t *l_986 = &l_874.f3;
    const int32_t *l_987 = &l_847;
    const int32_t *l_988 = &l_874.f3;
    const int32_t *l_989 = (void*)0;
    if ((((-(int16_t)((void*)0 != l_846)) > l_847) && (((int32_t)((int64_t)(p_33 >= p_35) - (int64_t)(((((uint16_t)p_31 >> (uint16_t)(p_35 | ((int16_t)p_31 >> (int16_t)((int16_t)(0UL < 0x2DBCL) >> (int16_t)12)))) & 0x3ADB0840L) >= l_847) == l_847)) / (int32_t)l_847) >= (-1L))))
    { /* block id: 498 */
        float l_867 = (-0x1.Ep-1);
        int32_t l_868 = 1L;
        int32_t l_875 = 1L;
        (*p_34) = (((int32_t)((int16_t)(((uint64_t)(l_864 != (void*)0) + (uint64_t)((l_868 <= ((0x8120L | func_74(&l_868, func_55(&l_868))) <= ((l_869 == (void*)0) ^ 0xBF86E2D0L))) | l_875)) <= l_868) >> (int16_t)1) % (int32_t)l_875) != 1L);
        (*p_34) = (*p_34);
    }
    else
    { /* block id: 501 */
        uint32_t l_878 = 1UL;
        int32_t *l_891 = &l_847;
        union U2 **l_920 = (void*)0;
        struct S0 * const ****l_937 = &l_870;
        union U1 l_956 = {0xF8DDFC34L};
        union U1 * const l_955 = &l_956;
        int32_t *l_963 = &l_874.f1;
        uint8_t l_967 = 0xB9L;
        int32_t *l_975 = &l_874.f1;
        const int32_t *l_981 = (void*)0;
        if ((p_35 ^ (((int32_t)(l_878 < ((uint32_t)(p_31 ^ (l_878 == ((int32_t)((((int16_t)(-1L) >> (int16_t)7) >= ((uint16_t)l_878 >> (uint16_t)(((int16_t)p_33 >> (int16_t)1) && p_33))) ^ (((int16_t)((0x07DF7D1AL || 4294967295UL) > p_31) << (int16_t)l_874.f5) >= l_878)) % (int32_t)(*p_34)))) - (uint32_t)p_35)) / (int32_t)l_878) < p_33)))
        { /* block id: 502 */
            int16_t l_907 = 2L;
            uint32_t l_909 = 0x98E86FE7L;
            int32_t **l_911 = &l_891;
            int32_t * const **l_916 = (void*)0;
            int32_t * const ***l_915 = &l_916;
            int32_t * const ****l_914 = &l_915;
            if ((func_74(l_891, l_891) | l_874.f1))
            { /* block id: 503 */
                struct S0 *l_894 = &l_874;
                struct S0 **l_893 = &l_894;
                struct S0 ***l_892 = &l_893;
                struct S0 ** const **l_895 = (void*)0;
                l_892 = l_892;
            }
            else
            { /* block id: 505 */
                int64_t l_900 = 0xD6699DA84764BFB6LL;
                union U2 **l_903 = &l_846;
                for (l_874.f5 = (-4); (l_874.f5 >= 4); ++l_874.f5)
                { /* block id: 508 */
                    uint32_t l_906 = 7UL;
                    int32_t *l_908 = &l_847;
                    float *l_910 = &l_874.f4;
                    (*l_891) = ((uint16_t)(l_900 > ((uint16_t)p_33 % (uint16_t)1L)) << (uint16_t)(l_903 != l_903));
                    (*l_910) = (((((float)(l_906 <= l_906) - (float)((((l_874.f2 <= __builtin_parity(l_906)) > (l_874.f8 <= (*l_908))) > 0xF.9D32ADp+6) != l_907)) != (*l_908)) < l_909) <= p_31);
                    (*p_34) = (*l_908);
                }
            }
            (*l_911) = &p_33;
            /* statement id: 514 */
            assert (l_891 == &p_33);
            for (l_874.f0 = (-19); (l_874.f0 <= 33); l_874.f0 += 6)
            { /* block id: 517 */
                int64_t l_926 = 5L;
                struct S0 *l_931 = &l_874;
                struct S0 **l_930 = &l_931;
                struct S0 ***l_929 = &l_930;
                struct S0 ****l_928 = &l_929;
                uint16_t l_940 = 0x8806L;
                l_914 = (void*)0;
                /* statement id: 518 */
                assert (l_914 == 0);
            }
            /* facts after for loop */
            assert (l_914 == 0 || l_914 == &l_915);
        }
        else
        { /* block id: 549 */
            int32_t *l_946 = &l_847;
            const struct S0 *l_950 = &l_874;
            for (p_33 = 0; (p_33 >= 24); p_33 += 9)
            { /* block id: 552 */
                int32_t *l_945 = &l_874.f1;
                int32_t **l_970 = &l_963;
                if (((uint16_t)func_74(l_945, l_946) >> (uint16_t)(p_33 <= (((int16_t)l_874.f2 / (int16_t)(+(-3L))) >= 0x1A22107735A14F75LL))))
                { /* block id: 553 */
                    struct S0 *l_952 = &l_874;
                    struct S0 **l_951 = &l_952;
                    struct S0 ** const *l_954 = &l_951;
                    struct S0 ** const **l_953 = &l_954;
                    int32_t l_960 = 0x125BFBDBL;
                    float *l_966 = (void*)0;
                    float **l_965 = &l_966;
                    float ***l_964 = &l_965;
                    (*l_951) = l_950;
                    if (((p_35 < (l_953 == (void*)0)) > 0x9089L))
                    { /* block id: 555 */
                        union U1 *l_958 = &l_956;
                        union U1 **l_957 = &l_958;
                        int32_t *l_959 = (void*)0;
                        union U2 l_961 = {0x376EL};
                        (*l_957) = l_955;
                        (*l_891) = func_74(l_959, func_55(l_891));
                    }
                    else
                    { /* block id: 558 */
                        union U2 ***l_962 = &l_920;
                        (*l_891) = __builtin_ia32_crc32qi(l_960, (((void*)0 == l_962) && p_31));
                        (*p_34) = ((func_74(l_963, func_57(l_960)) | (*l_963)) >= ((void*)0 == l_964));
                        l_967 = 0x0.9p+1;
                    }
                }
                else
                { /* block id: 563 */
                    l_968 = &l_956;
                    /* statement id: 564 */
                    assert (l_968 == &l_956);
                }
                (*l_970) = &p_31;
                /* statement id: 566 */
                assert (l_963 == &p_31);
                (**l_970) = ((uint32_t)(*l_963) + (uint32_t)(*l_946));
            }
            /* facts after for loop */
            assert (l_963 == &p_31 || l_963 == &l_874.f1);
            assert (l_968 == &l_956 || l_968 == &l_969);
        }
        /* facts after branching */
        assert (l_891 == &l_847 || l_891 == &p_33);
        assert (l_963 == &p_31 || l_963 == &l_874.f1);
        assert (l_968 == &l_956 || l_968 == &l_969);
        p_32 = func_57(((uint16_t)(*l_963) >> (uint16_t)2));
        if ((*l_891))
        { /* block id: 571 */
            int32_t **l_976 = &l_891;
            (*l_976) = func_55(l_975);
            /* statement id: 572 */
            assert (l_891 == &l_874.f1);
            (*l_976) = (*l_976);
        }
        else
        { /* block id: 574 */
            const int32_t *l_977 = &l_874.f3;
            const int32_t *l_978 = &l_874.f1;
            return l_981;
            /* statement id: 575 */
            //assert (func_30_rv == 0);
        }
        /* facts after branching */
        assert (l_891 == &l_874.f1);
    }
    /* facts after branching */
    //assert (l_968 == dangling || l_968 == &l_969);
    return l_989;
    /* statement id: 578 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_37(int16_t  p_38, int16_t  p_39)
{ /* block id: 38 */
    float l_51 = 0x6.864854p+20;
    int32_t l_52 = 0xB314B812L;
    struct S0 l_54 = {0xCB64B693L,0L,0xB9L,0x520F3038L,-0x10.6p+1,-9L,0x9C0105807C1ABDF1LL,-0x1.Fp-1,0x2CD8L};
    const struct S0 *l_53 = &l_54;
    union U2 l_676 = {-8L};
    union U1 l_725 = {0xD4762F34L};
    struct S0 **l_759 = (void*)0;
    struct S0 **l_760 = (void*)0;
    const struct S0 **l_761 = &l_53;
    struct S0 *l_793 = &l_54;
    struct S0 * const *l_792 = &l_793;
    struct S0 * const **l_791 = &l_792;
    struct S0 * const ***l_790 = &l_791;
    struct S0 * const ****l_789 = &l_790;
    union U2 ***l_808 = (void*)0;
    int32_t *l_813 = &l_52;
    int32_t l_834 = (-1L);
    int32_t *l_835 = &l_54.f1;
    int32_t *l_836 = &l_54.f1;
    int32_t *l_837 = &l_54.f1;
    int32_t *l_838 = (void*)0;
    (*l_761) = func_41((p_39 < 0x2522ABF7L), func_46(l_52, l_53, func_55(func_57(p_38)), l_676), l_54.f6, l_725);
    /* statement id: 452 */
    assert (l_53 == 0);
    for (l_725.f1.f0 = 16; (l_725.f1.f0 >= 8); l_725.f1.f0 -= 4)
    { /* block id: 455 */
        union U2 l_767 = {0xD28EL};
        union U2 *l_766 = &l_767;
        int32_t *l_794 = &l_54.f1;
        const struct S0 *l_810 = &l_54;
        union U2 ****l_817 = &l_808;
        union U2 *****l_816 = &l_817;
        for (l_54.f5 = (-24); (l_54.f5 > (-11)); l_54.f5 += 2)
        { /* block id: 458 */
            const struct S0 ***l_783 = &l_761;
            int32_t *l_796 = &l_54.f1;
            uint8_t l_809 = 0xF5L;
            union U2 l_811 = {0xF31BL};
            l_766 = &l_676;
            /* statement id: 459 */
            assert (l_766 == &l_676);
            for (l_54.f1 = 0; (l_54.f1 < (-11)); l_54.f1--)
            { /* block id: 462 */
                int32_t *l_770 = &l_52;
                union U2 **l_779 = &l_766;
                (*l_770) = ((p_38 >= (p_39 ^ (l_725.f2 ^ l_725.f2))) && 0x6A23AA01E9654DBDLL);
                (*l_770) = ((uint32_t)0x149BAF86L % (uint32_t)((uint64_t)(0xB0D9FCE505CDE539LL == l_54.f2) % (uint64_t)((uint64_t)0xC2A42968D4158D25LL / (uint64_t)(((uint16_t)p_39 >> (uint16_t)(p_39 > (((void*)0 == l_779) || p_39))) || l_54.f0))));
                if (p_39)
                    continue;
                for (l_54.f6 = 22; (l_54.f6 > 56); ++l_54.f6)
                { /* block id: 468 */
                    int32_t *l_795 = (void*)0;
                    int32_t *l_797 = &l_52;
                    if (p_39)
                    { /* block id: 469 */
                        float *l_782 = &l_54.f4;
                        struct S0 * const l_788 = &l_54;
                        struct S0 * const *l_787 = &l_788;
                        struct S0 * const **l_786 = &l_787;
                        struct S0 * const ***l_785 = &l_786;
                        struct S0 * const ****l_784 = &l_785;
                        (*l_782) = (*l_770);
                        (*l_770) = (&l_759 == l_783);
                        l_789 = l_784;
                        /* statement id: 472 */
                        assert (l_789 == &l_785);
                    }
                    else
                    { /* block id: 473 */
                        return l_795;
                        /* statement id: 474 */
                        //assert (func_37_rv == 0);
                    }
                    /* facts after branching */
                    //assert (l_789 == dangling);
                    return l_795;
                    /* statement id: 476 */
                    //assert (func_37_rv == 0);
                }
            }
            if ((((uint16_t)((uint32_t)p_38 - (uint32_t)(*l_796)) + (uint16_t)(~(((uint32_t)func_74(func_46((l_54.f8 && (((((int16_t)3L + (int16_t)(((~(*l_796)) & p_38) & (((l_794 == l_796) >= (l_808 == (void*)0)) == (*l_794)))) > p_38) <= p_38) > l_809)), l_810, l_794, l_811), l_796) + (uint32_t)(*l_796)) ^ 5UL))) | (-1L)))
            { /* block id: 479 */
                struct S0 l_812 = {5UL,0L,0xEAL,1L,0xC.CF7AB8p-7,0x27536C39L,0xE909982AC0DE20CBLL,0x0.15C015p+45,4UL};
                l_813 = func_67(l_812, l_54.f5, (*l_796), l_811, l_794);
                /* statement id: 480 */
                assert (l_813 == &l_54.f1);
                (*l_813) = 0x812C6561L;
            }
            else
            { /* block id: 482 */
                union U2 ****l_815 = (void*)0;
                union U2 *****l_814 = &l_815;
                int32_t l_830 = 4L;
                l_816 = l_814;
                /* statement id: 483 */
                assert (l_816 == &l_815);
                (*l_794) = 0xB208E560L;
                (*l_813) = ((uint16_t)(p_38 || ((+(*l_813)) != (~(p_38 || ((uint64_t)(((int32_t)(__builtin_ia32_crc32qi(((uint16_t)(*l_813) % (uint16_t)((uint64_t)p_39 % (uint64_t)p_39)), p_39) < p_38) + (int32_t)l_830) == 4UL) / (uint64_t)p_39))))) - (uint16_t)0xA0E6L);
            }
        }
        /* facts after for loop */
        assert (l_766 == &l_676 || l_766 == &l_767);
        //assert (l_816 == dangling || l_816 == &l_817);
        for (l_52 = 0; (l_52 < (-17)); --l_52)
        { /* block id: 490 */
            int32_t *l_833 = (void*)0;
            l_794 = l_794;
            return l_833;
            /* statement id: 492 */
            //assert (func_37_rv == 0);
        }
        if (l_834)
            break;
    }
    /* facts after for loop */
    assert (l_813 == &l_52 || l_813 == &l_54.f1);
    return l_838;
    /* statement id: 496 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_41(int64_t  p_42, int32_t * p_43, int32_t  p_44, union U1  p_45)
{ /* block id: 438 */
    int32_t l_745 = 1L;
    int64_t l_747 = 1L;
    int32_t l_751 = (-1L);
    int32_t *l_750 = &l_751;
    int32_t **l_752 = &l_750;
    const struct S0 *l_753 = (void*)0;
    union U2 l_754 = {8L};
    struct S0 l_756 = {0xB107D535L,0xA8688186L,0x4AL,-1L,0x5.D63C8Fp-36,0xC2FAB2E2L,0xA5B43B9F2D266AA9LL,0x0.Cp+1,0xF30CL};
    struct S0 *l_755 = &l_756;
    struct S0 *l_757 = &l_756;
    struct S0 *l_758 = (void*)0;
    if (__builtin_clz(p_44))
    { /* block id: 439 */
        int32_t l_729 = 0L;
        int32_t *l_728 = &l_729;
        for (p_45.f1.f5 = (-30); (p_45.f1.f5 <= 23); ++p_45.f1.f5)
        { /* block id: 442 */
            int32_t *l_730 = &l_729;
            l_730 = l_728;
        }
    }
    else
    { /* block id: 445 */
        int16_t l_742 = 0xFD97L;
        uint8_t l_746 = 0x1DL;
        int32_t l_749 = 0xF38CB56BL;
        int32_t *l_748 = &l_749;
        (*l_748) = ((uint32_t)((uint16_t)((int32_t)(((int16_t)p_42 << (int16_t)((-(uint32_t)(((int16_t)l_742 << (int16_t)9) > (-9L))) > ((uint32_t)l_745 / (uint32_t)l_745))) && (l_746 >= l_747)) + (int32_t)l_746) << (uint16_t)(p_45.f0 > l_747)) + (uint32_t)(-1L));
    }
    (*l_752) = l_750;
    (*l_752) = func_46((*l_750), l_753, (*l_752), l_754);
    (*l_750) = (**l_752);
    return l_758;
    /* statement id: 451 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_46(uint32_t  p_47, const struct S0 * p_48, int32_t * p_49, union U2  p_50)
{ /* block id: 432 */
    int32_t l_679 = (-9L);
    int32_t *l_678 = &l_679;
    int32_t **l_677 = &l_678;
    uint16_t l_682 = 0x451DL;
    union U1 *l_684 = (void*)0;
    union U1 **l_683 = &l_684;
    union U2 l_687 = {0L};
    const union U2 *l_686 = &l_687;
    const union U2 **l_685 = &l_686;
    int64_t l_694 = 0xE84A6A01E2B2023ELL;
    int32_t *l_695 = &l_679;
    struct S0 *l_702 = (void*)0;
    struct S0 **l_701 = &l_702;
    struct S0 ***l_700 = &l_701;
    struct S0 ****l_699 = &l_700;
    struct S0 *****l_698 = &l_699;
    union U2 *l_723 = (void*)0;
    union U2 **l_722 = &l_723;
    union U2 ***l_721 = &l_722;
    union U2 ****l_720 = &l_721;
    union U2 *****l_719 = &l_720;
    uint16_t l_724 = 65529UL;
    (*l_677) = p_49;
    /* statement id: 433 */
    //assert (l_678 == 0 || l_678 == &l_751 || l_678 == &l_54.f1);
    (*l_695) = (((l_679 == l_682) | (((l_683 != (void*)0) ^ p_47) <= (l_685 == (void*)0))) != __builtin_ffsll(((int16_t)(((((int16_t)(((int32_t)__builtin_bswap64(func_74(p_49, (*l_677))) + (int32_t)0xC8DA064AL) >= 0UL) >> (int16_t)p_47) == 6L) & p_50.f0) & p_47) - (int16_t)l_694)));
    (*l_677) = p_49;
    (*l_695) = ((uint32_t)(l_698 == &l_699) - (uint32_t)(p_50.f0 < (+((uint64_t)((((*l_695) & __builtin_ctz(((((int16_t)((uint16_t)(*l_695) / (uint16_t)((int16_t)((uint16_t)__builtin_popcountl(((uint32_t)(!0xC5BF4443L) + (uint32_t)((uint32_t)__builtin_popcountll(((void*)0 == l_719)) + (uint32_t)(*l_695)))) >> (uint16_t)p_47) >> (int16_t)p_50.f0)) >> (int16_t)3) <= (*l_695)) || l_724))) <= 0x57CFADEEL) && (*l_695)) % (uint64_t)0xA3B9110ACE2073D3LL))));
    return p_49;
    /* statement id: 437 */
    //assert (func_46_rv == 0 || func_46_rv == &l_751 || func_46_rv == &l_54.f1);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_55(int32_t * p_56)
{ /* block id: 414 */
    struct S0 l_632 = {0x147DD618L,5L,255UL,0x9E5E615CL,-0x1.8p-1,-2L,0xD9476D26F4E3DEA1LL,0xD.3F8E32p-68,0UL};
    struct S0 *l_638 = &l_632;
    struct S0 **l_637 = &l_638;
    struct S0 ***l_636 = &l_637;
    struct S0 ****l_635 = &l_636;
    union U2 l_642 = {-5L};
    union U2 *l_641 = &l_642;
    union U2 **l_640 = &l_641;
    union U2 ***l_639 = &l_640;
    int32_t *l_643 = &l_632.f1;
    int32_t * const *l_660 = (void*)0;
    int32_t * const **l_659 = &l_660;
    int32_t * const *** const l_658 = &l_659;
    int32_t l_661 = 1L;
    l_643 = p_56;
    /* statement id: 415 */
    //assert (l_643 == 0 || l_643 == &l_868 || l_643 == &p_33 || l_643 == &l_847 || l_643 == &l_874.f1);
    for (l_632.f6 = (-15); (l_632.f6 < 39); l_632.f6 += 5)
    { /* block id: 418 */
        uint64_t l_649 = 0x58DDAE5411332B8CLL;
        uint16_t l_653 = 0UL;
        union U2 **l_662 = &l_641;
        int32_t * const l_674 = &l_661;
        if (((uint16_t)(((+(__builtin_bswap64(l_649) | ((int32_t)(-1L) + (int32_t)(!l_649)))) != ((l_632.f3 ^ (0x474208F3L || l_653)) != l_653)) & ((int16_t)((((int16_t)((void*)0 != l_658) - (int16_t)l_661) != (-2L)) == l_653) - (int16_t)65531UL)) >> (uint16_t)1))
        { /* block id: 419 */
            (*l_639) = l_662;
        }
        else
        { /* block id: 421 */
            uint16_t l_666 = 0UL;
            union U2 ****l_667 = &l_639;
            int32_t *l_675 = &l_661;
            for (l_632.f5 = (-3); (l_632.f5 > (-11)); l_632.f5 -= 8)
            { /* block id: 424 */
                float *l_668 = (void*)0;
                int32_t l_669 = (-2L);
                union U2 **** const l_673 = &l_639;
                l_669 = ((+l_666) >= ((void*)0 == l_667));
                l_669 = ((((float)l_653 + (float)__builtin_popcount((l_662 == (void*)0))) != (((+l_649) == (0x8.DB35F9p+81 <= ((l_673 != (void*)0) < ((l_669 > l_669) < l_649)))) < l_669)) <= l_669);
            }
            l_675 = l_674;
        }
    }
    return p_56;
    /* statement id: 431 */
    //assert (func_55_rv == 0 || func_55_rv == &l_868 || func_55_rv == &p_33 || func_55_rv == &l_847 || func_55_rv == &l_874.f1);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_57(uint8_t  p_58)
{ /* block id: 39 */
    struct S0 l_73 = {0x9335309FL,0x3D48A24EL,2UL,1L,0xB.EE0456p+35,-6L,18446744073709551615UL,0x5.2p+1,65535UL};
    int32_t *l_77 = (void*)0;
    int32_t l_81 = 0x822C2642L;
    union U2 l_82 = {0x0BF2L};
    float *l_543 = &l_73.f7;
    uint64_t l_625 = 18446744073709551608UL;
    int32_t *l_630 = (void*)0;
    int32_t *l_631 = (void*)0;
lbl_561:
    (*l_543) = ((-0x1.Dp+1) != (((!p_58) <= ((float)func_62(func_67(l_73, (func_74(l_77, l_77) && 0x0F96L), l_81, l_82, &l_81), l_77, p_58, l_77) / (float)(-0x1.Bp+1))) >= 0x0.Cp-1));
    for (l_81 = 0; (l_81 != (-18)); l_81 -= 9)
    { /* block id: 356 */
        uint8_t l_548 = 0x16L;
        int32_t *l_560 = (void*)0;
        int32_t **l_570 = &l_77;
        int32_t ***l_569 = &l_570;
        union U2 l_615 = {0xA90CL};
        int32_t l_618 = 1L;
        int32_t *l_626 = &l_73.f1;
        (*l_543) = __builtin_parityl((((int16_t)(((l_548 > ((((int32_t)((int64_t)(p_58 && 0xC30FAA53L) % (int64_t)p_58) / (int32_t)__builtin_popcount((p_58 && 2UL))) > p_58) < (((int32_t)(~l_548) - (int32_t)(-1L)) ^ l_81))) == p_58) != 1UL) >> (int16_t)11) > p_58));
        for (l_73.f2 = 16; (l_73.f2 == 2); l_73.f2--)
        { /* block id: 360 */
            uint16_t l_559 = 0xD2ADL;
            int32_t *l_564 = &l_81;
            int32_t ***l_571 = &l_570;
            struct S0 l_600 = {1UL,-5L,0UL,0x0FCE6CACL,0x9.2p+1,0xA555A7ADL,18446744073709551615UL,0xD.26FC89p-13,0x2E9EL};
            if ((+l_559))
            { /* block id: 361 */
                return l_560;
                /* statement id: 362 */
                //assert (func_57_rv == 0);
            }
            else
            { /* block id: 363 */
                int32_t *l_572 = (void*)0;
                const int32_t ***l_580 = (void*)0;
                const int32_t *** const *l_579 = &l_580;
                int32_t *l_581 = (void*)0;
                int32_t *l_582 = &l_73.f1;
                if (p_58)
                { /* block id: 364 */
                    if (l_73.f5)
                        goto lbl_561;
                    (*l_543) = 0x1.3p-1;
                    for (l_559 = 14; (l_559 > 47); l_559++)
                    { /* block id: 369 */
                        int32_t **l_565 = &l_564;
                        int32_t ***l_566 = (void*)0;
                        int32_t ***l_567 = &l_565;
                        (*l_565) = l_564;
                        (*l_543) = func_74(l_564, l_560);
                        (*l_567) = &l_564;
                        if (p_58)
                            continue;
                    }
                }
                else
                { /* block id: 375 */
                    uint32_t l_573 = 0UL;
                    if ((+p_58))
                    { /* block id: 376 */
                        (*l_570) = (**l_571);
                    }
                    else
                    { /* block id: 378 */
                        if (p_58)
                            goto lbl_561;
                        if (l_573)
                            break;
                    }
                    for (l_73.f0 = 0; (l_73.f0 > 48); l_73.f0 += 4)
                    { /* block id: 384 */
                        struct S0 *l_577 = &l_73;
                        struct S0 **l_576 = &l_577;
                        (*l_576) = (void*)0;
                        /* statement id: 385 */
                        assert (l_577 == 0);
                    }
                    if (p_58)
                        goto lbl_561;
                }
                (*l_582) = (-(uint64_t)(p_58 || (&l_571 == l_579)));
                for (l_73.f5 = 0; (l_73.f5 == 17); ++l_73.f5)
                { /* block id: 392 */
                    int32_t l_589 = (-1L);
                    const uint32_t l_614 = 4294967295UL;
                    struct S0 *l_616 = &l_600;
                    struct S0 **l_617 = &l_616;
                    l_73.f1 = (((uint32_t)((uint32_t)(l_589 & (0x8928L <= ((0xF09492095068A105LL != p_58) && p_58))) - (uint32_t)p_58) / (uint32_t)((int64_t)p_58 % (int64_t)p_58)) >= p_58);
                    for (l_73.f0 = 26; (l_73.f0 < 43); l_73.f0 += 4)
                    { /* block id: 396 */
                        float l_601 = 0x4.8EE165p+41;
                        int32_t l_612 = 1L;
                        union U2 l_613 = {0x21BCL};
                        (*l_543) = ((float)((float)0x3.010913p+67 + (float)((((float)((l_613.f0 < p_58) <= p_58) - (float)(-0x1.3p-1)) >= p_58) != 0x4.DE6746p-98)) / (float)p_58);
                    }
                    (*l_617) = l_616;
                }
            }
            (*l_543) = (((l_618 >= ((p_58 <= ((float)((p_58 < (*l_564)) > p_58) / (float)((float)(0x2.98EF12p+10 >= (((p_58 != 0x7.D939E8p-72) > p_58) == (-0x5.6p-1))) / (float)(*l_564)))) == 0x2.04A438p+35)) > p_58) <= (-0x7.Ep-1));
            (**l_571) = &l_81;
            /* statement id: 403 */
            assert (l_77 == &l_81);
            l_600.f1 = ((((***l_571) > p_58) && (p_58 || (*l_77))) && 1UL);
        }
        (*l_626) = ((int16_t)((**l_569) == &l_81) / (int16_t)__builtin_ctz((6L <= (l_625 < __builtin_bswap64(p_58)))));
        for (l_73.f5 = 25; (l_73.f5 > (-20)); l_73.f5 -= 9)
        { /* block id: 409 */
            int32_t *l_629 = &l_81;
            return l_630;
            /* statement id: 410 */
            //assert (func_57_rv == 0);
        }
    }
    return l_631;
    /* statement id: 413 */
    //assert (func_57_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_62(int32_t * p_63, int32_t * p_64, const uint32_t  p_65, int32_t * p_66)
{ /* block id: 344 */
    struct S0 l_511 = {1UL,0x324052EEL,0x0CL,0x7CF48B9DL,0x1.3p-1,0x9688EA05L,0x77881DCCE8D195F2LL,0x5.8405B0p+65,0xFCE7L};
    union U2 l_512 = {0xFBF8L};
    union U1 l_517 = {-1L};
    union U1 *l_516 = &l_517;
    union U1 **l_515 = &l_516;
    int32_t *l_518 = (void*)0;
    int32_t l_542 = (-7L);
    if (func_74(p_64, p_66))
    { /* block id: 345 */
        int32_t **l_519 = &l_518;
        (*l_515) = (*l_515);
        (*l_519) = p_66;
        /* statement id: 347 */
        //assert (l_518 == 0 || l_518 == &l_612 || l_518 == &l_81);
        return p_65;
    }
    else
    { /* block id: 349 */
        int16_t l_530 = (-8L);
        (*p_63) = (((int16_t)((uint16_t)l_511.f6 % (uint16_t)0x6280L) + (int16_t)((int16_t)((p_65 || (((((uint16_t)p_65 << (uint16_t)(((int64_t)l_530 % (int64_t)8L) == l_530)) == ((uint16_t)((-(int64_t)((int32_t)((int32_t)((uint32_t)((uint64_t)l_542 + (uint64_t)0xD513ECCE02C5EA47LL) + (uint32_t)(*p_63)) % (int32_t)p_65) % (int32_t)l_530)) || 0x2B7AB4C6E2BD3278LL) << (uint16_t)11)) < (-1L)) & 0x03EDE6BDD7E7F9EFLL)) > p_65) % (int16_t)l_530)) != 0xE62DC694L);
    }
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_67(struct S0  p_68, uint32_t  p_69, float  p_70, union U2  p_71, int32_t * p_72)
{ /* block id: 43 */
    int32_t l_83 = 0xC31B53A2L;
    float l_168 = 0xD.13F5BBp+73;
    float *l_167 = &l_168;
    int32_t *l_318 = (void*)0;
    struct S0 *l_334 = (void*)0;
    int32_t ***l_358 = (void*)0;
    struct S0 * const * const l_372 = &l_334;
    struct S0 * const * const *l_371 = &l_372;
    struct S0 * const * const **l_370 = &l_371;
    struct S0 * const * const ***l_369 = &l_370;
    union U1 l_469 = {-2L};
    union U1 *l_468 = &l_469;
    uint32_t l_471 = 0x4D4A0A18L;
    int16_t l_478 = 0L;
    if (l_83)
    { /* block id: 44 */
        int16_t l_84 = 0x6FFBL;
        const int32_t *l_108 = (void*)0;
        const int32_t **l_107 = &l_108;
        const int32_t ***l_106 = &l_107;
        int32_t l_116 = 0x7283BD05L;
        int32_t *l_115 = &l_116;
        uint16_t l_130 = 0x6627L;
        if ((l_84 <= (l_84 > l_84)))
        { /* block id: 45 */
            struct S0 l_88 = {18446744073709551608UL,0x7B9758ACL,0x21L,0x1A659E80L,0x4.7p-1,-10L,0xBA2AAC5DA298B236LL,-0x1.1p-1,65535UL};
            struct S0 *l_87 = &l_88;
            (*p_72) = ((int16_t)((l_87 != (void*)0) || ((int16_t)l_83 >> (int16_t)3)) >> (int16_t)15);
            p_72 = p_72;
        }
        else
        { /* block id: 48 */
            (*p_72) = (*p_72);
        }
        for (p_68.f6 = (-14); (p_68.f6 == 9); p_68.f6++)
        { /* block id: 53 */
            uint32_t l_117 = 4294967287UL;
            (*p_72) = __builtin_bswap64(((uint16_t)p_71.f0 - (uint16_t)__builtin_ctzl(l_84)));
            for (p_68.f5 = 0; (p_68.f5 < 18); p_68.f5 += 4)
            { /* block id: 57 */
                union U2 l_99 = {0xE6FCL};
                union U2 *l_98 = &l_99;
                union U2 **l_97 = &l_98;
                int32_t l_112 = 0x64988723L;
                int32_t *l_111 = &l_112;
                const int64_t l_127 = 4L;
                uint8_t l_140 = 1UL;
                float l_147 = 0x5.412C47p+42;
                float *l_146 = &l_147;
                (*p_72) = l_84;
                (*l_97) = &p_71;
                /* statement id: 59 */
                assert (l_98 == &p_71);
            }
        }
        (**l_106) = (**l_106);
    }
    else
    { /* block id: 89 */
        int32_t l_154 = 0x8A051233L;
        int32_t l_156 = 0xB1AA685BL;
        int32_t *l_155 = &l_156;
        (*p_72) = ((uint32_t)(((uint16_t)__builtin_ia32_crc32qi(((uint16_t)p_68.f2 << (uint16_t)p_69), (((l_154 | func_74(l_155, p_72)) > (((int32_t)((void*)0 != &l_156) + (int32_t)__builtin_ffsl(p_71.f0)) && l_83)) >= p_71.f0)) % (uint16_t)p_68.f3) <= p_68.f3) + (uint32_t)(*l_155));
    }
    return p_72;
    /* statement id: 343 */
    //assert (func_67_rv == &l_81 || func_67_rv == &l_54.f1);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_74(int32_t * p_75, int32_t * p_76)
{ /* block id: 40 */
    int32_t l_80 = 0x1B4D09D5L;
    int32_t *l_79 = &l_80;
    int32_t **l_78 = &l_79;
    (*l_78) = p_75;
    /* statement id: 41 */
    //assert (l_79 == 0 || l_79 == &l_116 || l_79 == &l_112 || l_79 == &l_81 || l_79 == &l_156 || l_79 == &l_218.f1 || l_79 == &l_168 || l_79 == &l_384 || l_79 == &l_498 || l_79 == &l_589 || l_79 == &l_612 || l_79 == &l_751 || l_79 == &l_54.f1 || l_79 == &l_842 || l_79 == &l_868 || l_79 == &l_847 || l_79 == &l_874.f1 || l_79 == &p_31);
    return l_80;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 253
   depth: 1, occurrence: 5
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 23
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 156
   depth: 2, occurrence: 25
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 5, occurrence: 6
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 302

XXX times a variable address is taken: 286
XXX times a pointer is dereferenced on RHS: 131
breakdown:
   depth: 1, occurrence: 107
   depth: 2, occurrence: 17
   depth: 3, occurrence: 7
XXX times a pointer is dereferenced on LHS: 167
breakdown:
   depth: 1, occurrence: 151
   depth: 2, occurrence: 13
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 40
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 483

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 507
   level: 2, occurrence: 69
   level: 3, occurrence: 25
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 147
XXX number of pointers point to scalars: 109
XXX number of pointers point to structs: 25
XXX percent of pointers has null in alias set: 27.8
XXX average alias set size: 1.42

XXX times a non-volatile is read: 1110
XXX times a non-volatile is write: 439
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 6

XXX stmts: 142
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 26
   depth: 2, occurrence: 26
   depth: 3, occurrence: 23
   depth: 4, occurrence: 17
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

