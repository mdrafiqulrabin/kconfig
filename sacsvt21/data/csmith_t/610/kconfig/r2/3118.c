/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      261313087
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const uint32_t  f0;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static uint16_t g_3 = 65527U;
static uint32_t g_41 = 0U;
static int16_t g_62 = 0xB31C;
static int16_t g_64 = 1;
static int32_t g_69 = 0x8D6DB9E5;
static int32_t *g_68 = &g_69;
static union U0 g_85 = {0x0CABDBFA};
static int32_t g_101 = 4;
static union U0 g_123 = {0x9630A554};
static union U0 *g_122 = &g_123;
static int16_t g_136 = 0;
static volatile int32_t **g_142 = (void*)0;
static volatile int32_t ***g_141 = &g_142;
static int16_t g_185 = 6;
static volatile int32_t g_195 = 0x63640059;/* VOLATILE GLOBAL g_195 */
static volatile int32_t *g_194 = &g_195;
static const volatile int32_t *g_208 = (void*)0;
static const volatile int32_t **g_207 = &g_208;
static const volatile int32_t ***g_206 = &g_207;
static const volatile int32_t ****g_205 = &g_206;
static const volatile int32_t *****g_204 = &g_205;
static union U0 g_255 = {0x57621A52};
static uint16_t g_329 = 1U;
static int32_t **g_335 = &g_68;
static int32_t *****g_341 = (void*)0;
static uint32_t g_357 = 0xF3BFE32F;
static int32_t *g_366 = &g_69;
static int32_t g_405 = 1;
static uint64_t g_426 = 1U;
static uint8_t g_450 = 251U;
static uint8_t g_454 = 1U;
static volatile int32_t g_491 = (-3);/* VOLATILE GLOBAL g_491 */
static uint32_t g_492 = 4294967295U;
static int32_t ***g_585 = &g_335;
static int32_t * const *g_587 = (void*)0;
static int32_t * const **g_586 = &g_587;
static volatile int32_t *g_613 = (void*)0;
static volatile int32_t **g_612 = &g_613;
static uint16_t *g_618 = (void*)0;
static uint16_t **g_617 = &g_618;
static volatile int32_t ***g_648 = &g_612;
static volatile int32_t ****g_647 = &g_648;
static int16_t ****g_652 = (void*)0;
static int16_t *****g_651 = &g_652;
static volatile int16_t ***g_837 = (void*)0;
static volatile uint16_t g_886 = 0x6979;/* VOLATILE GLOBAL g_886 */
static uint8_t *g_909 = &g_454;
static uint8_t **g_908 = &g_909;
static volatile uint32_t g_915 = 0x451D254C;/* VOLATILE GLOBAL g_915 */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_24(void);
inline static const int32_t * func_25(int16_t  p_26);
inline static uint32_t  func_29(int32_t * p_30, int32_t  p_31);
static int32_t * func_32(int32_t  p_33, int32_t * p_34);
static uint32_t * func_46(int32_t * p_47, int32_t * p_48, const int32_t * p_49, int32_t * p_50, uint32_t * p_51);
inline static int32_t * func_52(const uint16_t  p_53, const uint32_t  p_54, uint32_t  p_55, const uint32_t  p_56);
inline static int32_t * func_66(int32_t  p_67);
static int32_t * func_77(int32_t  p_78, union U0  p_79, int32_t  p_80, int16_t * p_81, int32_t ** p_82);
static union U0  func_83(union U0  p_84);
inline static const uint16_t  func_92(int32_t * p_93, union U0  p_94, uint16_t  p_95, uint16_t  p_96, int16_t  p_97);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_64 g_68 g_62 g_85 g_101 g_69 g_123.f1 g_194 g_195 g_255.f1 g_85.f0 g_85.f1 g_136 g_335 g_366 g_122 g_123 g_255.f0 g_329 g_123.f0 g_405 g_450 g_357 g_205 g_206 g_207 g_617 g_618 g_41 g_585 g_255 g_185 g_426 g_648 g_612 g_208 g_204 g_837 g_491 g_886 g_915
 * writes: g_41 g_62 g_64 g_68 g_3 g_69 g_85.f1 g_101 g_136 g_255.f1 g_329 g_185 g_195 g_123.f1 g_208 g_357 g_122 g_366 g_492 g_335 g_908
 */
static int32_t  func_24(void)
{ /* block id: 36 */
    uint16_t l_39 = 9U;
    uint32_t *l_40 = &g_41;
    int16_t *l_61 = &g_62;
    int16_t *l_63 = &g_64;
    int16_t l_65 = 1;
    uint32_t *l_566 = &g_85.f1;
    uint32_t **l_565 = &l_566;
    uint32_t l_567 = 0x6671754A;
    uint16_t *l_568 = &g_329;
    int32_t l_570 = (-3);
    const int32_t **l_912 = (void*)0;
    const int32_t *l_914 = &g_69;
    const int32_t **l_913 = &l_914;
    (*l_913) = func_25((g_3 , ((((int16_t)4 + (int16_t)3U) | (func_29(func_32(((((int16_t)((int32_t)(((*l_40) = (l_39 > 0x196E86FF)) != (__builtin_ffs(__builtin_ctzl((((*l_568) = ((((uint16_t)((((uint16_t)(((*l_565) = func_46(func_52(g_3, ((uint16_t)((int16_t)((*l_61) = 0x49AC) >> (int16_t)6) >> (uint16_t)(l_65 = ((*l_63) = l_39))), g_3, l_39), l_40, l_40, l_40, l_40)) == &g_492) << (uint16_t)8) || l_65) > l_567) >> (uint16_t)9) , 65529U) & l_567)) < l_39))) < 0)) - (int32_t)4294967295U) - (int16_t)0x89FD) <= g_357) != 0x434B), l_40), l_570) || (-1))) == l_39)));
    (*g_194) = g_915;
    return l_570;
}


/* ------------------------------------------ */
/* 
 * reads : g_136 g_366 g_41 g_85.f0 g_85 g_3 g_101 g_64 g_68 g_62 g_194 g_585 g_335 g_255 g_185 g_426 g_648 g_612 g_205 g_206 g_207 g_208 g_123.f1 g_204 g_69 g_837 g_329 g_491 g_255.f0 g_886
 * writes: g_185 g_101 g_69 g_68 g_122 g_195 g_366 g_357 g_492 g_208 g_123.f1 g_329 g_136 g_41 g_85.f1 g_335 g_62 g_64 g_3 g_908
 */
inline static const int32_t * func_25(int16_t  p_26)
{ /* block id: 494 */
    int32_t l_685 = 0x9E625DFD;
    union U0 l_688 = {0U};
    int32_t *l_689 = (void*)0;
    int32_t l_692 = 0x972C6083;
    int16_t *l_693 = &g_185;
    int32_t l_694 = 5;
    uint16_t l_696 = 8U;
    const int32_t *l_776 = &g_69;
    int16_t **** const l_796 = (void*)0;
    uint32_t l_814 = 0xF40A51C7;
    uint64_t *l_831 = &g_426;
    uint64_t **l_830 = &l_831;
    uint64_t ***l_829 = &l_830;
    uint64_t ****l_828 = &l_829;
    uint16_t l_864 = 0x3667;
    int32_t l_899 = 9;
    int32_t l_900 = 0x8D65FF8B;
    uint16_t **l_901 = (void*)0;
    uint16_t *l_902 = &l_864;
    uint16_t *l_903 = &g_3;
    uint16_t *l_904 = (void*)0;
    uint16_t *l_905 = &l_696;
    int32_t *l_910 = &l_692;
    if ((((int32_t)__builtin_clzl(l_685) % (int32_t)(((*l_693) = ((int16_t)l_692 >> (int16_t)6)) ^ p_26)) && (l_692 = __builtin_clz(l_694))))
    { /* block id: 497 */
        int32_t l_695 = 0xD19DBC87;
        union U0 l_724 = {0x3969E931};
        int32_t **l_752 = (void*)0;
        uint16_t **l_773 = (void*)0;
        int32_t l_785 = 7;
        int16_t **l_799 = &l_693;
        int16_t ***l_798 = &l_799;
        int16_t ****l_797 = &l_798;
        union U0 l_815 = {0xFF10E18D};
        int32_t l_844 = 0xE8950469;
        if ((p_26 < l_695))
        { /* block id: 498 */
            uint32_t l_705 = 0U;
            int32_t *l_708 = &l_694;
            int32_t l_710 = 0xE31C75F7;
            const uint8_t *l_719 = (void*)0;
            int32_t *l_768 = &l_692;
            const uint16_t *l_772 = (void*)0;
            const uint16_t **l_771 = &l_772;
            if (l_696)
            { /* block id: 499 */
                int32_t **l_709 = &l_708;
                int32_t l_711 = 1;
                (*g_194) = ((g_136 < ((__builtin_ctzll((func_92((((int16_t)((int32_t)((((uint16_t)(l_705 <= ((void*)0 == &g_648)) + (uint16_t)0x8C40) && ((((((l_710 = ((*g_366) = ((uint32_t)(p_26 & (((*l_709) = l_708) != (void*)0)) - (uint32_t)p_26))) && 1U) == 0x48D3CF48) | (-1)) >= l_711) | 0x4EBA)) | g_41) - (int32_t)g_85.f0) >> (int16_t)l_688.f0) , &l_710), g_85, p_26, p_26, p_26) , 0xE505350F2C46BCBFLL)) , l_711) < 0U)) , p_26);
                (**g_585) = &l_711;
            }
            else
            { /* block id: 505 */
                int32_t **l_712 = &g_366;
                uint32_t *l_713 = &g_357;
                int32_t l_714 = 0xDEE6AE29;
                int32_t *** const l_756 = &l_752;
                int32_t *** const *l_755 = &l_756;
                l_714 = __builtin_ctzl(((*l_713) = ((g_255 , func_32(p_26, &l_710)) != ((*l_712) = (void*)0))));
                (*g_194) = (-5);
                for (g_185 = 0; (g_185 < 13); g_185 += 1)
                { /* block id: 512 */
                    uint8_t * const l_720 = &g_454;
                    int32_t l_725 = 0x37986FDE;
                    uint32_t *l_726 = &l_724.f1;
                    if (((uint16_t)((0x0E0EC834 >= (l_719 == l_720)) <= ((~((*l_726) = func_92(&l_710, (g_426 , l_688), l_705, (((int16_t)p_26 >> (int16_t)(((l_724 , l_724.f0) >= l_725) == 0)) , p_26), l_710))) ^ 0x47ABDDB7)) >> (uint16_t)9))
                    { /* block id: 514 */
                        (*g_194) = 0xECE31247;
                    }
                    else
                    { /* block id: 516 */
                        (*g_194) = (~p_26);
                    }
                    for (l_724.f1 = 3; (l_724.f1 <= 29); ++l_724.f1)
                    { /* block id: 521 */
                        int32_t l_734 = 0x05F83B71;
                        int32_t ****l_740 = &g_585;
                        int32_t *****l_739 = &l_740;
                        int32_t **l_750 = (void*)0;
                        uint32_t *l_751 = &g_492;
                        if (p_26)
                            break;
                        (*g_194) = ((uint16_t)(((int32_t)(__builtin_ffsll(l_734) , ((int32_t)(((((int16_t)(&g_205 == (l_739 = (void*)0)) % (int16_t)((uint32_t)((((((uint16_t)(~((uint16_t)(((*l_751) = (((uint16_t)(((p_26 || (p_26 ^ ((p_26 , l_750) == (void*)0))) & 0x073BBC48) <= l_725) >> (uint16_t)10) , g_62)) , 0U) - (uint16_t)0x81A2)) % (uint16_t)p_26) , l_710) || 8) , (*g_648)) == l_752) - (uint32_t)0U)) ^ 0xAF0F) != 0) ^ (-2)) - (int32_t)l_724.f0)) - (int32_t)0xF7F6E0D8) || g_64) >> (uint16_t)p_26);
                        (*l_712) = (p_26 , &l_692);
                        return &g_69;
                    }
                    (*g_194) = ((int32_t)((0xF6DE8DA1 == __builtin_parity(l_695)) != ((l_755 == (p_26 , &g_648)) ^ ((int16_t)(((uint16_t)p_26 >> (uint16_t)4) & (l_724.f0 && p_26)) >> (int16_t)p_26))) % (int32_t)0xA6328E51);
                    (*l_712) = l_768;
                }
                (**g_206) = (((~(!(l_771 != l_773))) > 65531U) , (***g_205));
            }
            for (g_123.f1 = 0; (g_123.f1 > 56); g_123.f1 += 1)
            { /* block id: 537 */
                return l_776;
            }
        }
        else
        { /* block id: 540 */
            int16_t l_779 = 0xA39A;
            uint16_t *l_780 = &g_329;
            union U0 **l_781 = &g_122;
            int16_t *l_784 = &g_136;
            const uint32_t l_788 = 4U;
            int32_t *l_802 = (void*)0;
            uint64_t **l_808 = (void*)0;
            int32_t l_816 = 0x31234F99;
            (**g_585) = &l_692;
            (****g_204) = (void*)0;
            if ((p_26 < ((((int16_t)p_26 + (int16_t)((*l_693) = 0)) , (((*l_780) = l_779) == ((__builtin_parityll((((void*)0 != l_781) , (((uint16_t)0xA443 >> (uint16_t)14) > func_92(func_77((*l_776), l_724, p_26, l_784, &l_689), l_724, p_26, l_785, p_26)))) , 0x7541C35F) > 0xE3FC82D8))) && 0x3F44)))
            { /* block id: 545 */
                if ((__builtin_clz(g_426) == ((int16_t)((l_788 ^ (p_26 = ((int16_t)p_26 << (int16_t)((int16_t)((**l_799) = ((~p_26) && (((uint16_t)(l_796 == l_797) << (uint16_t)13) , ((uint32_t)__builtin_clzl((l_788 >= ((*l_784) = p_26))) - (uint32_t)g_64)))) + (int16_t)p_26)))) < l_779) << (int16_t)13)))
                { /* block id: 549 */
                    const int32_t *l_803 = &g_69;
                    const int32_t **l_804 = (void*)0;
                    const int32_t **l_805 = &l_803;
                    (**g_206) = (void*)0;
                    (*g_366) = __builtin_ctz(p_26);
                    (*l_805) = l_803;
                    (*g_194) = __builtin_ffsl(p_26);
                }
                else
                { /* block id: 554 */
                    for (l_696 = 0; (l_696 >= 25); l_696 += 4)
                    { /* block id: 557 */
                        uint64_t ***l_809 = &l_808;
                        uint64_t **l_811 = (void*)0;
                        uint64_t ***l_810 = &l_811;
                        (*l_810) = ((*l_809) = l_808);
                    }
                }
            }
            else
            { /* block id: 562 */
                uint32_t *l_817 = &g_41;
                int32_t l_840 = 0;
                union U0 l_841 = {0xDEE2436D};
                if (((int32_t)(l_814 <= func_92(l_802, l_688, p_26, (g_123.f1 && (l_815 , (((*l_817) = (l_816 ^ ((void*)0 == &g_652))) | p_26))), p_26)) % (int32_t)p_26))
                { /* block id: 564 */
                    uint32_t l_825 = 4294967295U;
                    for (l_816 = 0; (l_816 >= (-5)); l_816 -= 1)
                    { /* block id: 567 */
                        union U0 l_820 = {1U};
                        (*g_194) = (((l_820 , p_26) & (&l_788 != (((((int32_t)((*g_366) = ((uint16_t)p_26 + (uint16_t)p_26)) % (int32_t)l_825) , p_26) || ((int16_t)((void*)0 != &g_205) << (int16_t)10)) , (void*)0))) >= p_26);
                        l_695 = p_26;
                        l_828 = l_828;
                        l_695 = 0x07DF4D51;
                    }
                }
                else
                { /* block id: 574 */
                    int16_t ***l_842 = &l_799;
                    int32_t l_843 = 0;
                    uint32_t *l_860 = &g_492;
                    (*g_585) = (((***l_842) = (((((~(__builtin_popcountl((l_815.f1 && ((int16_t)((int32_t)(g_837 != (func_83((((int16_t)l_840 << (int16_t)p_26) , l_841)) , l_842)) + (int32_t)((*l_776) > (0x2B356951 && p_26))) << (int16_t)12))) >= 0x3A50)) || (*l_776)) ^ (-1)) && 0) != l_843)) , (void*)0);
                    (*g_194) = (0xF42FC4F1 <= g_329);
                    (*g_366) = ((uint16_t)(~((uint16_t)((((uint32_t)l_841.f0 + (uint32_t)(*g_366)) && ((((uint32_t)((uint16_t)(p_26 >= (((*l_817) = l_843) == ((((*l_860) = ((int32_t)(l_840 , __builtin_bswap64((1U != ((void*)0 == (***g_204))))) % (int32_t)l_840)) | 0x5D1299B5) , l_841.f1))) % (uint16_t)0x2DF6) - (uint32_t)p_26) <= (*l_776)) , 65530U)) , 0x0553) >> (uint16_t)p_26)) >> (uint16_t)l_840);
                    (*l_781) = (void*)0;
                }
            }
            return l_802;
        }
    }
    else
    { /* block id: 586 */
        uint32_t l_863 = 4294967291U;
        const volatile int32_t *l_867 = &g_491;
        (**g_206) = (****g_204);
        for (l_692 = 0; (l_692 >= 17); l_692 += 5)
        { /* block id: 590 */
            uint32_t l_866 = 0U;
            (*g_194) = l_863;
            if ((*g_366))
            { /* block id: 592 */
                (*g_366) = ((-5) > 0U);
            }
            else
            { /* block id: 594 */
                uint16_t l_865 = 0x64DB;
                l_865 = (l_864 = (0x70A9 ^ p_26));
                return &g_101;
            }
            l_866 = (*g_366);
        }
        if (__builtin_bswap64(l_863))
        { /* block id: 601 */
            l_867 = (**g_206);
        }
        else
        { /* block id: 603 */
            union U0 l_868 = {0U};
            int16_t *l_882 = (void*)0;
            int16_t *l_883 = &g_62;
            int16_t *l_884 = &g_64;
            (**g_585) = &l_692;
            (*g_335) = func_77(p_26, l_868, (~((int32_t)((uint16_t)(func_83((((uint32_t)p_26 - (uint32_t)(((*l_884) = ((*l_883) = (l_868.f0 & ((int32_t)((uint16_t)(l_868.f1 | (*l_867)) << (uint16_t)((*l_693) = l_863)) - (int32_t)((*g_68) = __builtin_popcount(((uint16_t)l_868.f1 >> (uint16_t)4))))))) >= (*l_776))) , l_868)) , l_868.f1) >> (uint16_t)p_26) - (int32_t)l_868.f1)), &g_136, (*g_585));
        }
        (*g_194) = (g_255.f0 , (-(int32_t)(g_886 == ((int16_t)(((uint16_t)(*l_776) << (uint16_t)8) > l_863) << (int16_t)10))));
    }
    if ((((*l_905) = ((*l_903) = ((*l_902) = ((-(uint16_t)((uint32_t)((((l_796 == l_796) ^ ((*l_776) , (((int16_t)((uint32_t)g_3 + (uint32_t)0xD947B072) >> (int16_t)5) <= (!l_899)))) , (void*)0) == ((p_26 & (p_26 , l_900)) , l_901)) % (uint32_t)(-6))) >= 0x245C)))) || p_26))
    { /* block id: 616 */
        uint8_t *l_907 = &g_454;
        uint8_t **l_906 = &l_907;
        g_908 = l_906;
    }
    else
    { /* block id: 618 */
        int32_t *l_911 = &l_899;
        l_911 = l_910;
    }
    return &g_101;
}


/* ------------------------------------------ */
/* 
 * reads : g_205 g_206 g_207 g_255.f1 g_3 g_357 g_335 g_69 g_617 g_618 g_366 g_101 g_68 g_64 g_85 g_123.f1 g_194 g_195 g_85.f0 g_122 g_123 g_255.f0 g_329 g_85.f1 g_123.f0 g_405 g_450 g_62 g_136
 * writes: g_208 g_3 g_357 g_68 g_101 g_69 g_62 g_85.f1 g_136 g_255.f1 g_329 g_185 g_195 g_123.f1 g_122 g_366
 */
inline static uint32_t  func_29(int32_t * p_30, int32_t  p_31)
{ /* block id: 399 */
    uint32_t l_592 = 4294967286U;
    union U0 l_593 = {4294967293U};
    uint16_t l_605 = 0x6D2C;
    int16_t *l_622 = &g_62;
    uint32_t l_644 = 0xA1A96F75;
    int32_t *l_662 = &g_101;
    uint32_t l_676 = 0x486F09BC;
    (***g_205) = (void*)0;
    if ((((int16_t)0 % (int16_t)g_255.f1) ^ p_31))
    { /* block id: 401 */
        int16_t l_604 = 7;
        uint16_t *l_616 = &l_605;
        uint16_t **l_615 = &l_616;
        int32_t l_620 = 0x8D03B18C;
        int32_t *l_624 = &g_101;
        uint16_t *l_667 = (void*)0;
        for (p_31 = 12; (p_31 >= (-20)); p_31 -= 9)
        { /* block id: 404 */
            int32_t *l_578 = &g_69;
            int16_t l_595 = 0x2B66;
            union U0 l_608 = {4294967286U};
            uint32_t l_611 = 5U;
            for (g_3 = (-5); (g_3 <= 29); g_3 += 6)
            { /* block id: 407 */
                uint32_t l_577 = 2U;
                int32_t *l_579 = &g_69;
                const int16_t *l_602 = &g_62;
                int32_t *l_623 = &l_620;
                union U0 *l_629 = &g_255;
                int32_t *l_646 = (void*)0;
            }
            for (g_357 = (-16); (g_357 != 1); g_357 += 1)
            { /* block id: 464 */
                uint32_t l_657 = 0xCB715143;
                union U0 l_663 = {4294967295U};
                (*g_335) = l_662;
            }
            (*g_366) = (!(((int32_t)(*l_578) % (int32_t)__builtin_popcountl((((*l_662) = (1U & 0xD5EE4F31)) <= (*l_578)))) > ((*g_617) == l_667)));
        }
        (*g_335) = func_66((*l_662));
    }
    else
    { /* block id: 473 */
        union U0 *l_668 = &l_593;
        union U0 **l_669 = (void*)0;
        union U0 **l_670 = &l_668;
        int32_t l_671 = (-1);
        int16_t *l_674 = &g_136;
        int16_t *l_675 = &g_185;
        (*l_670) = ((*p_30) , l_668);
        l_671 = (*p_30);
        (*g_366) = func_92(func_46(func_77((*g_366), (*g_122), ((int16_t)(((*l_674) = ((*l_622) = (*l_662))) , p_31) >> (int16_t)12), (l_675 = l_622), &p_30), &l_671, &l_671, l_662, &g_41), l_593, p_31, l_592, l_676);
    }
    for (g_255.f1 = 0; (g_255.f1 >= 54); g_255.f1 += 1)
    { /* block id: 483 */
        union U0 l_679 = {4294967295U};
        int32_t **l_680 = &g_366;
        (*l_680) = (func_83(func_83(l_679)) , ((*g_335) = l_662));
        for (g_136 = (-5); (g_136 != (-29)); g_136 -= 8)
        { /* block id: 488 */
            (**g_335) = 1;
        }
        return (*l_662);
    }
    return g_85.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_32(int32_t  p_33, int32_t * p_34)
{ /* block id: 397 */
    int32_t *l_569 = &g_101;
    return l_569;
}


/* ------------------------------------------ */
/* 
 * reads : g_255.f0 g_3 g_329 g_85.f1 g_335 g_68 g_69 g_64 g_85 g_101 g_123.f1 g_194 g_195 g_255.f1 g_85.f0 g_123.f0 g_405 g_122 g_450 g_366
 * writes: g_255.f1 g_329 g_185 g_68 g_62 g_3 g_69 g_85.f1 g_101 g_136 g_195 g_123.f1
 */
static uint32_t * func_46(int32_t * p_47, int32_t * p_48, const int32_t * p_49, int32_t * p_50, uint32_t * p_51)
{ /* block id: 261 */
    uint16_t l_382 = 1U;
    uint32_t *l_383 = &g_255.f1;
    uint16_t *l_390 = &g_329;
    int32_t ***l_394 = &g_335;
    int16_t *l_397 = (void*)0;
    int16_t *l_398 = (void*)0;
    int16_t *l_399 = &g_185;
    int32_t **l_446 = &g_366;
    union U0 *l_497 = &g_85;
    int16_t **l_508 = &l_397;
    int16_t ***l_507 = &l_508;
    int16_t ****l_506 = &l_507;
    (*g_335) = func_66((((*l_383) = ((int16_t)l_382 << (int16_t)15)) || (((int16_t)((uint16_t)((int16_t)(((((*l_390) = g_255.f0) && (!(((uint16_t)__builtin_popcountl((l_394 != l_394)) - (uint16_t)g_329) , 0xC0902CA0))) < ((*l_399) = ((int16_t)g_85.f1 % (int16_t)((***l_394) & 1)))) >= (***l_394)) - (int16_t)(***l_394)) << (uint16_t)1) + (int16_t)0) != (-1))));
    (*g_194) = (*g_194);
    (**g_335) = ((*p_47) >= ((((uint32_t)(((0x3AC0 >= g_64) ^ ((***l_394) <= g_195)) <= (***l_394)) % (uint32_t)(***l_394)) , ((uint32_t)g_255.f0 - (uint32_t)((0x52279812 < g_64) == (*g_194)))) ^ (***l_394)));
    if ((0x313CBA39 == g_123.f0))
    { /* block id: 268 */
        int32_t l_404 = 1;
        (**g_335) = l_404;
    }
    else
    { /* block id: 270 */
        union U0 l_406 = {0x56A28996};
        int16_t *l_407 = &g_185;
        int32_t l_413 = 0x24C83F1C;
        int16_t l_433 = (-1);
        int32_t ****l_472 = &l_394;
        int32_t *****l_471 = &l_472;
        union U0 **l_486 = &g_122;
        int32_t l_533 = (-1);
        int32_t l_552 = (-1);
        int32_t l_553 = (-2);
        (*g_335) = func_77(g_405, l_406, l_406.f1, l_407, &g_68);
        for (g_69 = 0; (g_69 != 24); g_69 += 4)
        { /* block id: 274 */
            int32_t ** const l_412 = (void*)0;
            int16_t *l_437 = &g_136;
            int32_t l_444 = (-3);
            int32_t ****l_470 = &l_394;
            int32_t *****l_469 = &l_470;
            union U0 l_483 = {1U};
        }
        for (l_382 = (-18); (l_382 != 8); l_382 += 2)
        { /* block id: 382 */
            int32_t l_560 = 0xEF40D5FF;
            int16_t ****l_561 = &l_507;
            union U0 l_562 = {0x7FF8C50C};
            (****l_472) = ((uint16_t)((uint32_t)l_560 + (uint32_t)((((__builtin_ia32_crc32qi(((((void*)0 != l_561) <= ((((*l_486) == (void*)0) || 0x6ED7C2E3) == (l_562 , ((*l_399) = (g_450 & (((((****l_472) == (**l_446)) > (***l_394)) & l_560) <= l_560)))))) , g_405), (*****l_471)) <= (*****l_471)) || (*p_47)) > (*****l_471)) >= 1U)) >> (uint16_t)9);
            if ((****l_472))
                break;
            (**l_446) = l_562.f1;
        }
        for (g_123.f1 = 0; (g_123.f1 == 14); ++g_123.f1)
        { /* block id: 390 */
            (**l_394) = (*l_446);
        }
    }
    return &g_492;
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_68 g_62 g_3 g_85 g_101 g_69 g_123.f1 g_194 g_195 g_255.f1 g_85.f0 g_85.f1 g_136 g_335 g_366 g_122 g_123
 * writes: g_68 g_62 g_3 g_69 g_85.f1 g_101 g_136 g_255.f1
 */
inline static int32_t * func_52(const uint16_t  p_53, const uint32_t  p_54, uint32_t  p_55, const uint32_t  p_56)
{ /* block id: 41 */
    uint32_t l_377 = 4294967294U;
    uint32_t *l_378 = &g_255.f1;
    int32_t *l_379 = &g_69;
    (*g_335) = func_66(g_64);
    (*g_335) = func_66(((__builtin_clz(((*l_378) = l_377)) , ((*g_366) < ((g_255.f1 , (*g_122)) , (-10)))) <= l_377));
    l_379 = l_378;
    return l_379;
}


/* ------------------------------------------ */
/* 
 * reads : g_68 g_62 g_3 g_64 g_85 g_101 g_69 g_123.f1 g_194 g_195 g_255.f1 g_85.f0 g_85.f1 g_136 g_335
 * writes: g_68 g_62 g_3 g_69 g_85.f1 g_101 g_136
 */
inline static int32_t * func_66(int32_t  p_67)
{ /* block id: 42 */
    int32_t **l_70 = &g_68;
    union U0 l_265 = {0x8F23623D};
    uint16_t l_268 = 0x828F;
    uint32_t l_276 = 0x78C1B4A0;
    int16_t *l_312 = &g_64;
    int16_t **l_311 = &l_312;
    int16_t ***l_310 = &l_311;
    int32_t *****l_340 = (void*)0;
    int32_t *l_363 = &g_101;
    (*l_70) = g_68;
    for (g_62 = 8; (g_62 >= (-6)); g_62 -= 1)
    { /* block id: 46 */
        int32_t *l_76 = &g_69;
        union U0 l_262 = {4294967290U};
        uint16_t l_277 = 0xC9BD;
        int32_t * const *l_307 = &g_68;
        int32_t * const **l_306 = &l_307;
        for (g_3 = 0; (g_3 < 53); g_3 += 9)
        { /* block id: 49 */
            int32_t * const l_75 = &g_69;
            int16_t *l_258 = &g_185;
            int16_t **l_257 = &l_258;
            l_76 = l_75;
            g_68 = func_77(((*l_76) = (g_64 == 0x0182)), func_83(g_85), (g_64 < (p_67 , (&g_136 != (void*)0))), ((*l_257) = &g_64), &l_76);
            (*l_75) = (**l_70);
        }
        (**l_70) = (*l_76);
        (*l_70) = ((func_83(func_83(l_262)) , ((uint16_t)g_123.f1 - (uint16_t)(((((p_67 == (func_83(l_265) , 0xA1B547D5)) , ((uint16_t)(((*g_68) = ((((((((p_67 , (*l_76)) != p_67) , 0x1653) <= 0xA540) <= 0xB345A963) && p_67) , g_123.f1) != (**l_70))) != (*g_194)) >> (uint16_t)g_255.f1)) && l_268) >= g_123.f1) | 4294967286U))) , l_76);
        if (((((*g_68) = (!(g_69 ^ 0x66D0))) < ((int16_t)0x666D >> (int16_t)((((uint16_t)2U % (uint16_t)((int16_t)(p_67 | l_276) - (int16_t)l_277)) | ((((int16_t)((((void*)0 == g_194) && 0xDB21) != g_85.f0) << (int16_t)9) == l_268) > 0xB435F6B2)) >= p_67))) == l_262.f0))
        { /* block id: 188 */
            int32_t *l_280 = &g_69;
            int32_t **l_281 = &l_280;
            uint32_t l_308 = 0x860C5FD5;
            int16_t *l_309 = &g_62;
            (*l_281) = (l_76 = ((*l_70) = l_280));
            for (g_85.f1 = 0; (g_85.f1 < 50); g_85.f1 += 2)
            { /* block id: 194 */
                uint16_t *l_289 = &g_3;
                uint32_t *l_292 = (void*)0;
                uint32_t *l_293 = &g_123.f1;
                int32_t l_294 = 0;
                int32_t ***l_305 = &l_70;
            }
            if ((**l_307))
                continue;
        }
        else
        { /* block id: 203 */
            int16_t ****l_313 = (void*)0;
            int16_t ****l_314 = &l_310;
            (*l_314) = l_310;
        }
    }
    for (g_136 = (-12); (g_136 > 13); g_136 += 1)
    { /* block id: 209 */
        int32_t l_321 = 6;
        uint16_t *l_322 = &l_268;
        uint16_t *l_323 = &g_3;
        uint16_t *l_328 = &g_329;
        int32_t l_330 = 3;
        union U0 l_369 = {0x84FCC0D0};
    }
    return (*g_335);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_77(int32_t  p_78, union U0  p_79, int32_t  p_80, int16_t * p_81, int32_t ** p_82)
{ /* block id: 178 */
    const union U0 *l_260 = &g_255;
    const union U0 **l_259 = &l_260;
    int32_t *l_261 = &g_101;
    (*l_259) = (void*)0;
    return l_261;
}


/* ------------------------------------------ */
/* 
 * reads : g_85.f1 g_101
 * writes: g_85.f1 g_101
 */
static union U0  func_83(union U0  p_84)
{ /* block id: 52 */
    uint16_t l_145 = 65533U;
    int32_t l_165 = 8;
    const volatile int32_t *****l_209 = &g_205;
    int16_t l_215 = (-9);
    uint32_t l_231 = 4U;
    int32_t *l_248 = &g_101;
    union U0 l_256 = {0U};
    for (g_85.f1 = 0; (g_85.f1 > 54); g_85.f1 += 1)
    { /* block id: 55 */
        int16_t *l_91 = &g_64;
        int32_t l_105 = (-8);
        int32_t **l_130 = &g_68;
        int32_t ***l_129 = &l_130;
        int32_t *l_183 = &l_105;
        volatile int32_t *l_196 = &g_195;
        union U0 l_203 = {4294967292U};
    }
    (*l_248) = (*l_248);
    return l_256;
}


/* ------------------------------------------ */
/* 
 * reads : g_85.f0 g_3 g_101 g_64 g_68 g_62
 * writes: g_101 g_68 g_122
 */
inline static const uint16_t  func_92(int32_t * p_93, union U0  p_94, uint16_t  p_95, uint16_t  p_96, int16_t  p_97)
{ /* block id: 61 */
    int32_t l_113 = 0x86A60883;
    if ((((int16_t)(__builtin_ctzll(g_85.f0) < __builtin_bswap64(g_3)) + (int16_t)((__builtin_ffsll(((((uint32_t)(__builtin_parity(p_94.f0) > (~g_3)) % (uint32_t)((-(int16_t)l_113) | p_94.f0)) , l_113) , p_97)) | 0U) | l_113)) < g_101))
    { /* block id: 62 */
        uint32_t l_114 = 0xE40B14FA;
        int32_t *l_115 = &l_113;
        int32_t l_116 = 0x9B05D12C;
        int32_t **l_117 = &l_115;
        l_114 = (l_113 > ((void*)0 != p_93));
        g_101 = (l_116 = ((*l_115) = ((void*)0 != &g_101)));
        (*l_117) = &l_113;
        (*l_115) = 0xF8BB411E;
    }
    else
    { /* block id: 69 */
        int32_t *l_118 = (void*)0;
        int32_t *l_119 = &g_101;
        int32_t **l_121 = &l_119;
        int32_t ***l_120 = &l_121;
        (*l_119) = g_64;
        (*l_120) = &g_68;
        (**l_120) = &l_113;
        (***l_120) = p_94.f1;
    }
    g_122 = &p_94;
    return g_62;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_24();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_41, "g_41", print_hash_value);
    transparent_crc(g_62, "g_62", print_hash_value);
    transparent_crc(g_64, "g_64", print_hash_value);
    transparent_crc(g_69, "g_69", print_hash_value);
    transparent_crc(g_85.f0, "g_85.f0", print_hash_value);
    transparent_crc(g_85.f1, "g_85.f1", print_hash_value);
    transparent_crc(g_101, "g_101", print_hash_value);
    transparent_crc(g_123.f0, "g_123.f0", print_hash_value);
    transparent_crc(g_123.f1, "g_123.f1", print_hash_value);
    transparent_crc(g_136, "g_136", print_hash_value);
    transparent_crc(g_185, "g_185", print_hash_value);
    transparent_crc(g_195, "g_195", print_hash_value);
    transparent_crc(g_255.f0, "g_255.f0", print_hash_value);
    transparent_crc(g_255.f1, "g_255.f1", print_hash_value);
    transparent_crc(g_329, "g_329", print_hash_value);
    transparent_crc(g_357, "g_357", print_hash_value);
    transparent_crc(g_405, "g_405", print_hash_value);
    transparent_crc(g_426, "g_426", print_hash_value);
    transparent_crc(g_450, "g_450", print_hash_value);
    transparent_crc(g_454, "g_454", print_hash_value);
    transparent_crc(g_491, "g_491", print_hash_value);
    transparent_crc(g_492, "g_492", print_hash_value);
    transparent_crc(g_886, "g_886", print_hash_value);
    transparent_crc(g_915, "g_915", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 248
XXX total union variables: 26

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 45
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 31
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 2
   depth: 9, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 45, occurrence: 1

XXX total number of pointers: 257

XXX times a variable address is taken: 269
XXX times a pointer is dereferenced on RHS: 145
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 25
   depth: 3, occurrence: 16
   depth: 4, occurrence: 4
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 245
breakdown:
   depth: 1, occurrence: 210
   depth: 2, occurrence: 23
   depth: 3, occurrence: 4
   depth: 4, occurrence: 7
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 1226

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 710
   level: 2, occurrence: 198
   level: 3, occurrence: 147
   level: 4, occurrence: 46
   level: 5, occurrence: 49
XXX number of pointers point to pointers: 116
XXX number of pointers point to scalars: 134
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.9
XXX average alias set size: 1.28

XXX times a non-volatile is read: 1124
XXX times a non-volatile is write: 616
XXX times a volatile is read: 20
XXX    times read thru a pointer: 10
XXX times a volatile is write: 23
XXX    times written thru a pointer: 23
XXX times a volatile is available for access: 333
XXX percentage of non-volatile access: 97.6

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 129
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 32
   depth: 2, occurrence: 27
   depth: 3, occurrence: 13
   depth: 4, occurrence: 14
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
********************* end of statistics **********************/

