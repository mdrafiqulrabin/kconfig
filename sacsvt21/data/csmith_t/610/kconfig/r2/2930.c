/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2070194220
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int64_t  f0;
   uint16_t  f1;
   unsigned f2 : 28;
   int16_t  f3;
   const uint32_t  f4;
};

union U1 {
   uint32_t  f0;
   const uint32_t  f1;
   unsigned f2 : 26;
   uint32_t  f3;
};

union U2 {
   int64_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_33(void);
inline static uint16_t  func_39(const int64_t  p_40, int32_t  p_41, int32_t  p_42, union U2  p_43, float * p_44);
static union U2  func_45(float * p_46);
inline static float  func_50(int32_t  p_51, uint32_t  p_52, float * p_53);
static float * func_59(const float * p_60, float * const  p_61, float * const  p_62);
static float * func_65(float * p_66, int32_t  p_67, uint64_t  p_68, int32_t  p_69);
inline static float * func_70(float * p_71);
inline static uint16_t  func_82(union U1  p_83, int16_t  p_84, uint64_t  p_85, uint16_t  p_86, union U1  p_87);
static union U1  func_88(float * p_89, float  p_90, int32_t  p_91);
static float  func_99(union U1  p_100, float * p_101, int16_t  p_102, uint16_t  p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_33(void)
{ /* block id: 36 */
    int64_t l_34 = 1L;
    float l_36 = 0x0.D85027p-79;
    float *l_35 = &l_36;
    float *l_47 = &l_36;
    float *l_338 = (void*)0;
    union U0 l_480 = {1L};
    union U0 *l_479 = &l_480;
    int64_t l_494 = 0x871B233FA9AAFF6ALL;
    union U1 l_524 = {9UL};
    int32_t l_525 = 0x7D5859F1L;
    const int32_t ***l_541 = (void*)0;
    const int32_t ****l_540 = &l_541;
    const int32_t *****l_539 = &l_540;
    union U2 l_574 = {0xB415A30E4C0C7379LL};
    int32_t *l_576 = &l_525;
    int64_t l_609 = 0xF358BECFD6787335LL;
    float *l_619 = &l_36;
    int32_t l_624 = 5L;
    (*l_35) = l_34;
    if (((uint16_t)func_39(l_34, l_34, l_34, func_45(l_47), l_338) + (uint16_t)(l_34 & (l_34 == l_34))))
    { /* block id: 270 */
        union U0 **l_481 = (void*)0;
        const union U0 **l_482 = (void*)0;
        union U0 **l_483 = &l_479;
        const int32_t l_484 = 0L;
        const float *l_485 = &l_36;
        union U2 l_502 = {0xB4CB6625C39C28E8LL};
        union U2 *l_501 = &l_502;
        int32_t ****l_504 = (void*)0;
        int32_t ***** const l_503 = &l_504;
        uint64_t l_507 = 18446744073709551615UL;
        union U1 l_515 = {0xD4BF3CD4L};
        uint32_t l_554 = 1UL;
        int32_t l_571 = 0xEC4276A1L;
        const int16_t l_572 = 0xFE9AL;
        float *l_575 = (void*)0;
        uint32_t l_614 = 0x646BA2EDL;
        const int32_t l_617 = 0x3BBF8FDAL;
        float l_620 = 0x5.B4B3A2p-82;
lbl_601:
        (*l_483) = l_479;
        if (l_484)
        { /* block id: 272 */
            union U2 l_505 = {0x268F694B0D4290D7LL};
            float *l_506 = &l_36;
            union U1 l_522 = {18446744073709551615UL};
            int32_t *l_532 = &l_525;
            union U0 *l_537 = &l_480;
            if ((l_34 <= (l_485 != l_485)))
            { /* block id: 273 */
                uint64_t l_488 = 5UL;
                int32_t l_509 = 1L;
                int32_t *l_508 = &l_509;
                l_488 = ((uint16_t)0x8C91L << (uint16_t)3);
                (*l_508) = (-(int64_t)((uint64_t)l_488 % (uint64_t)((int64_t)l_494 / (int64_t)((uint16_t)65535UL + (uint16_t)((int16_t)((((l_501 != (void*)0) != (l_503 != &l_504)) < (func_39((l_480.f3 && (l_494 == l_480.f1)), l_494, l_488, l_505, l_506) <= l_507)) & 0UL) / (int16_t)l_34)))));
            }
            else
            { /* block id: 276 */
                const union U2 **l_513 = (void*)0;
                const int32_t l_514 = 0xBDCFD5DAL;
                union U1 l_523 = {4UL};
                union U0 *l_530 = &l_480;
                int32_t *l_531 = &l_525;
                l_525 = (((int32_t)((-(uint16_t)((void*)0 != l_513)) > func_39(l_514, l_480.f2, (func_82(l_515, l_514, (l_480.f4 < (((l_514 <= ((((uint64_t)((int64_t)(((uint16_t)(((func_82(l_522, l_522.f0, l_522.f3, l_522.f2, l_523) != l_514) > l_480.f3) >= 4294967295UL) >> (uint16_t)l_480.f2) && l_480.f4) - (int64_t)l_480.f4) - (uint64_t)0x14AEFDD36A248AD6LL) != l_522.f0) | 0L)) && l_480.f0) >= l_480.f2)), l_522.f2, l_524) | l_34), l_505, l_506)) / (int32_t)l_480.f3) | l_514);
                (*l_531) = ((int16_t)(((int16_t)l_524.f2 - (int16_t)l_523.f0) <= (&l_480 == l_530)) - (int16_t)l_505.f0);
                l_532 = l_506;
                /* statement id: 279 */
                assert (l_532 == &l_36);
            }
            /* facts after branching */
            assert (l_532 == &l_36 || l_532 == &l_525);
            for (l_480.f3 = 6; (l_480.f3 == 19); ++l_480.f3)
            { /* block id: 283 */
                int16_t l_536 = 0x9E3DL;
                (*l_47) = ((*l_532) <= ((!(-0x8.9p+1)) >= (l_536 >= l_536)));
                return l_536;
            }
            /* facts after for loop */
                        (*l_483) = l_537;
            l_525 = ((-(int32_t)(*l_532)) < ((((void*)0 == l_539) & (*l_532)) ^ ((uint16_t)(*l_532) - (uint16_t)(l_481 != &l_479))));
        }
        else
        { /* block id: 289 */
            int32_t l_557 = 0x9FBF3F2DL;
            union U2 l_561 = {0xF96545FCD3875BE9LL};
            float *l_562 = &l_36;
            uint8_t l_564 = 0x5DL;
            int32_t * const * const * const l_568 = (void*)0;
            uint64_t l_584 = 18446744073709551615UL;
            int32_t l_604 = 0x2B096630L;
            union U1 *l_621 = &l_515;
            for (l_502.f0 = 0; (l_502.f0 <= (-19)); l_502.f0--)
            { /* block id: 292 */
                const uint32_t l_546 = 0x273C4C20L;
                int32_t *l_560 = &l_525;
                if (l_546)
                { /* block id: 293 */
                    int16_t l_551 = 0x05C4L;
                    uint32_t l_573 = 0xEFE63921L;
                    int32_t **l_586 = &l_560;
                    int32_t *** const l_585 = &l_586;
                    uint16_t l_591 = 0xCE7DL;
                    union U1 *l_594 = &l_524;
                    if ((((uint64_t)18446744073709551614UL - (uint64_t)l_551) <= (((int32_t)0xD50B3FAAL % (int32_t)l_554) > ((uint16_t)(func_39((l_557 <= ((uint16_t)((0x5EF2AA02L == (l_560 == l_560)) & (-6L)) >> (uint16_t)5)), (*l_560), l_557, l_561, l_562) <= 0xC6D6L) / (uint16_t)8UL))))
                    { /* block id: 294 */
                        l_564 = (-(float)l_561.f0);
                    }
                    else
                    { /* block id: 296 */
                        float *l_565 = &l_36;
                        int32_t l_566 = 4L;
                        uint64_t l_567 = 0x75E01E494C05B71ELL;
                        l_576 = func_65(l_565, l_566, (((l_567 | (0x490A3EB4L | l_551)) != ((void*)0 != l_568)) >= (((func_39(((*l_560) | ((l_571 || l_572) > 0x567CDC1EL)), l_573, l_573, l_574, l_575) || l_567) & (-1L)) > l_566)), l_567);
                        /* statement id: 297 */
                        assert (l_576 == &l_36);
                    }
                    for (l_564 = 0; (l_564 >= 54); ++l_564)
                    { /* block id: 301 */
                        int32_t l_579 = 0x9A51ED6FL;
                        return l_579;
                    }
                    if ((((int16_t)((int16_t)((l_584 < (l_585 != (*l_540))) && ((uint32_t)(**l_586) % (uint32_t)((int16_t)(l_591 & (((*l_560) > ((uint16_t)(l_594 != (void*)0) >> (uint16_t)(*l_576))) >= l_584)) + (int16_t)1UL))) << (int16_t)(*l_560)) << (int16_t)(***l_585)) > (*l_560)))
                    { /* block id: 304 */
                        (**l_585) = func_59(l_575, l_560, l_562);
                        /* statement id: 305 */
                        assert (l_560 == 0);
                        (*l_586) = l_560;
                        if (l_546)
                            continue;
                    }
                    else
                    { /* block id: 308 */
                        (*l_560) = (**l_586);
                    }
                    /* facts after branching */
                    assert (l_560 == &l_525 || l_560 == 0);
                }
                else
                { /* block id: 311 */
                    int32_t *l_598 = &l_525;
                    for (l_561.f0 = 4; (l_561.f0 > (-14)); --l_561.f0)
                    { /* block id: 314 */
                        int16_t l_597 = 0x8820L;
                        union U0 l_600 = {9L};
                        union U0 *l_599 = &l_600;
                        (*l_47) = l_597;
                        l_598 = l_598;
                        l_599 = &l_480;
                        /* statement id: 317 */
                        assert (l_599 == &l_480);
                    }
                    if ((*l_560))
                    { /* block id: 319 */
                        if (l_571)
                            goto lbl_601;
                    }
                    else
                    { /* block id: 321 */
                        float *l_602 = &l_36;
                        int32_t *l_603 = &l_525;
                        l_603 = func_59(func_70(l_598), func_59(l_598, func_70(func_70(func_70(l_602))), l_598), l_602);
                        /* statement id: 322 */
                        assert (l_603 == 0);
                        return l_604;
                    }
                    (*l_560) = (((*l_560) > ((uint32_t)1UL - (uint32_t)(__builtin_ffsl((((uint32_t)(*l_576) + (uint32_t)(*l_598)) && (*l_560))) >= ((*l_560) | (l_502.f0 < l_609))))) == l_507);
                    for (l_574.f0 = (-27); (l_574.f0 == (-11)); l_574.f0 += 6)
                    { /* block id: 328 */
                        uint32_t l_612 = 0x30FAA534L;
                        (*l_560) = __builtin_clz((*l_598));
                        l_598 = l_598;
                        return l_612;
                    }
                }
                /* facts after branching */
                assert (l_560 == &l_525 || l_560 == 0);
            }
            if ((+(l_557 <= ((0x3C35L < l_614) != (((int64_t)func_39(l_617, l_617, (!((*l_576) >= 6L)), (*l_501), l_619) - (int64_t)l_557) > (*l_576))))))
            { /* block id: 335 */
                (*l_576) = ((l_554 ^ 0x00C2L) & (*l_576));
            }
            else
            { /* block id: 337 */
                union U1 **l_622 = &l_621;
                (*l_622) = l_621;
            }
        }
        /* facts after branching */
            }
    else
    { /* block id: 341 */
        int16_t l_623 = (-1L);
        (*l_576) = l_623;
    }
    /* facts after branching */
        assert (l_576 == &l_36 || l_576 == &l_525);
    return l_624;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_39(const int64_t  p_40, int32_t  p_41, int32_t  p_42, union U2  p_43, float * p_44)
{ /* block id: 188 */
    int64_t l_341 = 0xA281D226D04433F0LL;
    union U1 l_347 = {0xE9F7C02CL};
    union U1 * const l_346 = &l_347;
    float l_366 = 0x5.50ECB8p-99;
    float *l_365 = &l_366;
    union U1 l_381 = {0x1DD5F38AL};
    uint32_t l_412 = 0UL;
    int32_t l_442 = (-6L);
    uint64_t l_456 = 1UL;
    int32_t *l_463 = &l_442;
    int32_t **l_462 = &l_463;
    int32_t ***l_461 = &l_462;
    const union U0 l_476 = {0x9B985E9CE2A3B59ALL};
    const union U0 *l_475 = &l_476;
    const union U0 **l_474 = &l_475;
    union U2 l_478 = {1L};
    union U2 *l_477 = &l_478;
    if (((int64_t)l_341 / (int64_t)(+l_341)))
    { /* block id: 189 */
        int32_t l_345 = (-5L);
        union U1 *l_348 = &l_347;
        int32_t l_358 = (-1L);
        int32_t l_370 = 0L;
        union U0 l_372 = {0x68FD03CFEF64EFBDLL};
        union U0 *l_371 = &l_372;
        union U0 **l_373 = &l_371;
        union U2 *l_377 = (void*)0;
        union U2 **l_376 = &l_377;
        float *l_378 = &l_366;
        int32_t l_414 = 0x6E57CC7FL;
        uint8_t l_421 = 255UL;
    }
    else
    { /* block id: 258 */
        uint8_t l_469 = 1UL;
        union U2 **l_470 = (void*)0;
        union U2 l_473 = {0x0FE08873CDE5C421LL};
        union U2 *l_472 = &l_473;
        union U2 **l_471 = &l_472;
        (**l_461) = &p_41;
        /* statement id: 259 */
        assert (l_463 == &p_41);
        (**l_462) = ((l_469 > (func_82((*l_346), p_43.f0, p_41, l_469, func_88(p_44, (**l_462), (***l_461))) != p_43.f0)) && 0x92E9B0BE5CBDDB98LL);
        (*l_365) = (**l_462);
        (*l_471) = &p_43;
        /* statement id: 262 */
        assert (l_472 == &p_43);
    }
    /* facts after branching */
    assert (l_463 == &p_41 || l_463 == &l_442);
    if ((l_474 != &l_475))
    { /* block id: 264 */
        (*l_462) = &p_41;
        /* statement id: 265 */
        assert (l_463 == &p_41);
    }
    else
    { /* block id: 266 */
        (*l_365) = (((&p_43 == &p_43) == 0x1.Cp-1) >= ((void*)0 == l_477));
    }
    return p_43.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_45(float * p_46)
{ /* block id: 38 */
    uint16_t l_58 = 0UL;
    const float l_64 = (-0x4.Fp+1);
    const float *l_63 = &l_64;
    float l_73 = 0x1.4p+1;
    float *l_72 = &l_73;
    union U1 l_334 = {0UL};
    int32_t l_336 = 0xA174F5C3L;
    int32_t *l_335 = &l_336;
    union U2 l_337 = {0xD4075E5BE3678092LL};
    (*l_72) = (((float)func_50((((int16_t)((uint16_t)l_58 + (uint16_t)l_58) >> (int16_t)3) != ((void*)0 == p_46)), l_58, func_59(l_63, func_65(func_70(l_72), ((uint32_t)(((uint32_t)l_58 / (uint32_t)0x39F82EC5L) | l_58) - (uint32_t)l_58), l_58, l_58), l_72)) - (float)0x7.F70B33p+24) < l_58);
    (*l_335) = func_82(l_334, l_334.f3, l_334.f1, l_334.f2, l_334);
    return l_337;
    /* statement id: 187 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_50(int32_t  p_51, uint32_t  p_52, float * p_53)
{ /* block id: 180 */
    union U1 l_316 = {0x720E6C04L};
    union U1 l_317 = {0xEC9F885BL};
    union U2 *l_323 = (void*)0;
    union U2 ** const l_322 = &l_323;
    int32_t l_324 = 0x2238FF03L;
    int32_t l_326 = 0L;
    int32_t *l_325 = &l_326;
    union U0 l_329 = {0x1E64B5358D98CD05LL};
    union U0 *l_328 = &l_329;
    union U0 ** const l_327 = &l_328;
    float *l_330 = (void*)0;
    float l_332 = (-0x7.Ap+1);
    float *l_331 = &l_332;
    int32_t **l_333 = &l_325;
    (*l_325) = (+((((uint64_t)0x72B0FFD9DDA32BF4LL % (uint64_t)((uint64_t)(((func_82(l_316, l_316.f2, p_51, l_316.f2, l_317) != ((int16_t)l_316.f3 << (int16_t)4)) & ((int16_t)(l_322 != (void*)0) + (int16_t)l_316.f1)) ^ l_324) - (uint64_t)0xB4BD51CD5DB39EC2LL)) != 1L) > p_51));
    (*l_331) = ((void*)0 != l_327);
    (*l_333) = &p_51;
    /* statement id: 183 */
    assert (l_325 == &p_51);
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_59(const float * p_60, float * const  p_61, float * const  p_62)
{ /* block id: 176 */
    union U2 l_293 = {0x5F21B87BBF4A9A9FLL};
    union U2 *l_292 = &l_293;
    union U2 **l_294 = &l_292;
    int32_t l_296 = 0xE9F7B3F3L;
    int32_t *l_295 = &l_296;
    float l_298 = 0x1.6p+1;
    float *l_297 = &l_298;
    float *l_299 = &l_298;
    float *l_300 = &l_298;
    float *l_301 = &l_298;
    float *l_302 = &l_298;
    float *l_303 = &l_298;
    float *l_304 = &l_298;
    float *l_305 = &l_298;
    float *l_306 = &l_298;
    float *l_307 = &l_298;
    float *l_308 = &l_298;
    float *l_309 = &l_298;
    float *l_310 = (void*)0;
    (*l_294) = l_292;
    (*l_295) = 0L;
    return l_310;
    /* statement id: 179 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_65(float * p_66, int32_t  p_67, uint64_t  p_68, int32_t  p_69)
{ /* block id: 123 */
    int32_t l_215 = (-8L);
    int32_t *l_214 = &l_215;
    int32_t **l_213 = &l_214;
    union U1 l_217 = {0x17E072EDL};
    union U1 *l_219 = &l_217;
    union U1 * const * const l_218 = &l_219;
    int32_t * const l_230 = &l_215;
    union U1 * const *l_245 = &l_219;
    int32_t * const *l_253 = &l_214;
    union U0 l_287 = {-1L};
    union U0 *l_286 = &l_287;
    float l_291 = 0x7.AB7566p-7;
    float *l_290 = &l_291;
    (*l_213) = func_70(p_66);
    /* statement id: 124 */
    //assert (l_214 == &l_73 || l_214 == &l_36);
    if (p_67)
    { /* block id: 125 */
        int32_t *l_216 = &l_215;
        (*l_213) = l_216;
        /* statement id: 126 */
        assert (l_214 == &l_215);
        (*l_213) = func_70(l_214);
    }
    else
    { /* block id: 128 */
        (*l_214) = (**l_213);
        (*l_214) = 5L;
    }
    /* facts after branching */
    //assert (l_214 == &l_73 || l_214 == &l_215 || l_214 == &l_36);
    if (func_82(l_217, ((__builtin_parityl(((void*)0 == l_218)) >= ((*l_214) && ((int32_t)((uint64_t)0x5034E9F7E8E123B5LL % (uint64_t)((int32_t)0L + (int32_t)(((uint16_t)((((((int64_t)(**l_213) + (int64_t)__builtin_clzll((**l_213))) >= (-1L)) || (*l_214)) | p_68) & p_68) >> (uint16_t)3) & 0x0395L))) % (int32_t)(*l_214)))) & (**l_213)), (*l_214), (*l_214), (*l_219)))
    { /* block id: 132 */
        (*p_66) = (*p_66);
        (*l_213) = l_230;
        /* statement id: 134 */
        assert (l_214 == &l_215);
    }
    else
    { /* block id: 135 */
        const uint64_t l_233 = 0xEEDCE3446011D501LL;
        const int32_t *l_234 = &l_215;
        union U1 *l_264 = &l_217;
        union U0 l_289 = {0L};
        union U0 *l_288 = &l_289;
        if (((l_233 | (l_234 == (void*)0)) && p_69))
        { /* block id: 136 */
            union U1 *l_239 = &l_217;
            (**l_213) = ((int16_t)((uint32_t)(((p_68 && p_68) != ((void*)0 != l_239)) != (p_68 >= ((int64_t)((uint16_t)p_69 >> (uint16_t)9) / (int64_t)(**l_213)))) + (uint32_t)(p_68 == (*l_234))) % (int16_t)(-3L));
        }
        else
        { /* block id: 138 */
            union U1 * const *l_244 = (void*)0;
            int32_t * const *l_252 = (void*)0;
lbl_257:
            l_245 = l_244;
            /* statement id: 139 */
            assert (l_245 == 0);
            for (l_217.f3 = (-22); (l_217.f3 > 20); ++l_217.f3)
            { /* block id: 142 */
                int32_t *l_256 = &l_215;
                if ((*l_234))
                { /* block id: 143 */
                    int32_t *l_251 = &l_215;
                    int32_t ***l_255 = &l_213;
                    int32_t ****l_254 = &l_255;
                    for (p_68 = 0; (p_68 <= 32); ++p_68)
                    { /* block id: 146 */
                        float *l_250 = (void*)0;
                        (*l_230) = (p_69 & 0xC39F9920L);
                        (*l_213) = l_251;
                        /* statement id: 148 */
                        assert (l_214 == &l_215);
                    }
                    l_253 = l_252;
                    /* statement id: 150 */
                    assert (l_253 == 0);
                    (*l_254) = &l_253;
                    /* statement id: 151 */
                    assert (l_255 == &l_253);
                }
                else
                { /* block id: 152 */
                    const uint8_t l_258 = 0xACL;
                    l_234 = l_256;
                    if (l_217.f3)
                        goto lbl_257;
                    if (l_258)
                        continue;
                    (*l_214) = ((-1L) ^ l_258);
                    if (l_217.f3)
                        goto lbl_285;
                }
            }
            /* facts after for loop */
                        if (p_68)
            { /* block id: 159 */
                (*l_213) = func_70(l_214);
            }
            else
            { /* block id: 161 */
                uint16_t l_263 = 65535UL;
                (*p_66) = ((float)__builtin_ffsll(((uint16_t)l_263 + (uint16_t)((p_66 != l_214) >= ((void*)0 == l_264)))) - (float)(((((*l_234) > (*l_230)) > (-(float)__builtin_ctzll(((((uint32_t)((uint32_t)((((int64_t)0xC952AE489F4295DALL % (int64_t)l_263) && l_263) != 0x6E5673ACL) + (uint32_t)p_69) + (uint32_t)p_69) | l_263) >= 1UL)))) > 0x1.Bp-1) == (*p_66)));
                (**l_213) = 8L;
                if (p_69)
                    goto lbl_272;
lbl_272:
                (*p_66) = (*p_66);
                (*p_66) = (((float)(+((float)((((!(-(float)l_263)) != 0xB.5D863Cp+26) <= ((*p_66) > ((*p_66) == (*p_66)))) > (((-0x3.1p+1) > ((float)(*p_66) + (float)((!(*l_234)) > ((float)0x0.2p-1 - (float)0x0.24D4ECp+54)))) == 0xA.5D6FB8p+95)) - (float)0x1.8p-1)) - (float)(*p_66)) == (*p_66));
            }
            (*p_66) = __builtin_ctzl(p_69);
        }
        /* facts after branching */
        assert (l_245 == 0 || l_245 == &l_219);
        assert (l_253 == &l_214 || l_253 == 0);
        (*p_66) = 0x1.Fp-1;
lbl_285:
        (*l_213) = &p_69;
        /* statement id: 171 */
        assert (l_214 == &p_69);
        l_288 = l_286;
        /* statement id: 173 */
        assert (l_288 == &l_287);
    }
    /* facts after branching */
    assert (l_214 == &p_69 || l_214 == &l_215);
    assert (l_245 == 0 || l_245 == &l_219);
    assert (l_253 == &l_214 || l_253 == 0);
    return p_66;
    /* statement id: 175 */
    //assert (func_65_rv == &l_73 || func_65_rv == &l_36);
}


/* ------------------------------------------ */
/* 
 * reads : l_73 l_36
 * writes:
 */
inline static float * func_70(float * p_71)
{ /* block id: 39 */
    float l_79 = 0xB.BE76DCp-30;
    float *l_78 = &l_79;
    int32_t l_94 = (-2L);
    union U1 l_104 = {0xBD68E480L};
    int32_t *l_207 = &l_94;
    int32_t **l_208 = &l_207;
    (*l_207) = ((int16_t)(((int64_t)__builtin_bswap32((p_71 == l_78)) / (int64_t)((uint16_t)func_82(func_88(p_71, (((float)(l_94 < ((float)((((float)((0x0.9p+1 == 0x4.09F33Dp-43) >= func_99(l_104, p_71, l_104.f0, l_104.f0)) / (float)l_104.f2) <= 0x9.4BCA0Fp+86) != 0xC.AE9822p+36) + (float)0xD.A2CA01p+38)) - (float)l_104.f0) < l_94), l_104.f0), l_104.f0, l_104.f2, l_104.f0, l_104) >> (uint16_t)5)) && l_104.f2) >> (int16_t)l_104.f3);
    (*l_208) = p_71;
    /* statement id: 121 */
    //assert (l_207 == &l_73 || l_207 == &l_215 || l_207 == &l_366 || l_207 == &l_36 || l_207 == &l_525);
    return p_71;
    /* statement id: 122 */
    //assert (func_70_rv == &l_73 || func_70_rv == &l_215 || func_70_rv == &l_366 || func_70_rv == &l_36 || func_70_rv == &l_525);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_82(union U1  p_83, int16_t  p_84, uint64_t  p_85, uint16_t  p_86, union U1  p_87)
{ /* block id: 47 */
    uint8_t l_148 = 0x66L;
    const int32_t *l_176 = (void*)0;
    for (p_83.f0 = 0; (p_83.f0 <= 7); p_83.f0 += 7)
    { /* block id: 50 */
        float l_116 = 0x1.Bp+1;
        int32_t l_117 = 0x2121A659L;
        int32_t *l_118 = &l_117;
        int32_t **l_142 = &l_118;
        int32_t ***l_141 = &l_142;
        int32_t ****l_140 = &l_141;
        (*l_118) = l_117;
        if (((-(int32_t)((int16_t)(-1L) >> (int16_t)0)) == p_87.f0))
        { /* block id: 52 */
            float *l_132 = (void*)0;
            int32_t l_137 = 0x4BAF7209L;
            int32_t *****l_154 = &l_140;
            union U1 l_169 = {0xC97A6105L};
            (*l_118) = ((int64_t)(*l_118) - (int64_t)((uint16_t)((int16_t)0L >> (int16_t)(__builtin_ctzl(__builtin_parityll(p_87.f3)) != ((*l_118) >= 7UL))) - (uint16_t)0xC0C0L));
            if ((p_83.f3 || ((uint32_t)((p_83.f2 != (l_132 == (void*)0)) && ((uint16_t)((int64_t)p_87.f0 - (int64_t)__builtin_parityll(((l_137 || (*l_118)) != ((int64_t)((*l_118) | (p_84 | p_87.f2)) % (int64_t)p_83.f3)))) + (uint16_t)1UL)) % (uint32_t)p_83.f2)))
            { /* block id: 54 */
                int32_t ** const ***l_143 = (void*)0;
                int32_t *****l_144 = (void*)0;
                int32_t *****l_145 = &l_140;
                (*l_145) = l_140;
                for (l_117 = (-26); (l_117 > (-28)); l_117--)
                { /* block id: 58 */
                    return l_148;
                }
                (*l_142) = (*l_142);
            }
            else
            { /* block id: 62 */
                uint32_t l_153 = 0UL;
                int32_t *****l_155 = &l_140;
                float *l_170 = &l_116;
                if ((((int32_t)l_137 + (int32_t)((((uint16_t)p_85 % (uint16_t)(0x1D2EL && 0xB3E5L)) >= 0xB986BC5A18187EA6LL) >= l_153)) | (***l_141)))
                { /* block id: 63 */
                    l_155 = l_154;
                    return p_83.f3;
                }
                else
                { /* block id: 66 */
                    int32_t l_156 = 0xD2C718CAL;
                    (*****l_155) = ((*****l_155) ^ l_156);
                    if (l_148)
                    { /* block id: 68 */
                        return l_148;
                    }
                    else
                    { /* block id: 70 */
                        uint16_t l_157 = 65530UL;
                        int32_t l_158 = 0x7105BA91L;
                        (*****l_155) = p_87.f0;
                        l_158 = (l_156 <= l_157);
                        (***l_140) = &l_158;
                        /* statement id: 73 */
                        assert (l_118 == &l_158);
                    }
                    /* facts after branching */
                    //assert (l_118 == dangling);
                    for (l_153 = 6; (l_153 <= 36); l_153++)
                    { /* block id: 77 */
                        if (l_156)
                            break;
                    }
                    for (p_84 = 0; (p_84 >= 13); p_84 += 4)
                    { /* block id: 82 */
                        const int32_t l_167 = (-8L);
                        (*l_170) = (0x4.881B6Ap-65 > ((float)0x0.Cp+1 + (float)(((float)l_167 - (float)(p_87.f1 > (l_167 == (-(float)func_99(l_169, l_170, (1UL < p_87.f1), l_148))))) > l_156)));
                        if (p_83.f2)
                            continue;
                    }
                }
                /* facts after branching */
                //assert (l_118 == dangling);
            }
            /* facts after branching */
            //assert (l_118 == dangling || l_118 == &l_117);
        }
        else
        { /* block id: 88 */
            float *l_171 = &l_116;
            (*l_171) = (**l_142);
            return p_86;
        }
        /* facts after branching */
        //assert (l_118 == dangling || l_118 == &l_117);
        for (p_85 = 0; (p_85 == 43); p_85++)
        { /* block id: 94 */
            for (l_117 = 0; (l_117 >= (-22)); l_117--)
            { /* block id: 97 */
                return p_87.f2;
            }
        }
        if ((((0xE5C3585974949FC4LL | 0x7E6343A15A7CFDFCLL) <= (l_176 != l_176)) ^ ((uint64_t)18446744073709551608UL / (uint64_t)p_83.f3)))
        { /* block id: 101 */
            float *l_183 = &l_116;
            int32_t l_186 = 8L;
            (*l_183) = ((float)p_86 / (float)__builtin_ffsl((((uint16_t)((l_183 != (void*)0) <= (((((void*)0 != l_176) | (((uint16_t)(l_186 == 0x1CD18219L) >> (uint16_t)0) && ((p_87.f0 > ((int16_t)((int64_t)((int64_t)__builtin_popcountl(p_83.f0) / (int64_t)p_86) - (int64_t)18446744073709551613UL) << (int16_t)l_186)) ^ 0x9FD49C48L))) | 0x4C0CL) | (-2L))) % (uint16_t)p_87.f1) <= l_186)));
            if (p_83.f1)
                break;
        }
        else
        { /* block id: 104 */
            union U0 l_194 = {3L};
            union U0 *l_193 = &l_194;
            union U0 **l_195 = &l_193;
            union U1 *l_200 = (void*)0;
            union U1 **l_199 = &l_200;
            (*l_195) = l_193;
            for (p_87.f0 = 0; (p_87.f0 != 1); ++p_87.f0)
            { /* block id: 108 */
                uint64_t l_198 = 18446744073709551614UL;
                l_198 = 0L;
            }
            (*l_199) = &p_83;
            /* statement id: 111 */
            assert (l_200 == &p_83);
        }
    }
    for (p_85 = 6; (p_85 > 20); ++p_85)
    { /* block id: 116 */
        int32_t **l_203 = (void*)0;
        int32_t l_206 = 0x85BE0904L;
        int32_t *l_205 = &l_206;
        int32_t **l_204 = &l_205;
        (*l_204) = (void*)0;
        /* statement id: 117 */
        assert (l_205 == 0);
    }
    return p_87.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_88(float * p_89, float  p_90, int32_t  p_91)
{ /* block id: 43 */
    int32_t l_111 = 1L;
    int32_t *l_110 = &l_111;
    int32_t **l_109 = &l_110;
    int32_t ***l_112 = &l_109;
    union U1 l_113 = {18446744073709551615UL};
    (*l_112) = l_109;
    (*l_109) = p_89;
    /* statement id: 45 */
    //assert (l_110 == &l_73 || l_110 == &l_215 || l_110 == &l_366 || l_110 == 0 || l_110 == &l_36 || l_110 == &l_525);
    return l_113;
    /* statement id: 46 */
    }


/* ------------------------------------------ */
/* 
 * reads : l_73 l_215 l_366 l_36 l_525
 * writes:
 */
static float  func_99(union U1  p_100, float * p_101, int16_t  p_102, uint16_t  p_103)
{ /* block id: 40 */
    float l_106 = 0x8.Cp+1;
    float *l_105 = &l_106;
    int32_t l_107 = 3L;
    int32_t *l_108 = &l_107;
    (*l_108) = (((p_101 == l_105) >= (0UL < 0x61EA52FA57A880E1LL)) <= l_107);
    return (*p_101);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 193
XXX total union variables: 21

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 41
breakdown:
   indirect level: 0, occurrence: 17
   indirect level: 1, occurrence: 17
   indirect level: 2, occurrence: 7
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 24
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 35
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 23

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 167
   depth: 2, occurrence: 28
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 14, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 28, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 163

XXX times a variable address is taken: 145
XXX times a pointer is dereferenced on RHS: 85
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 82
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 325

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 313
   level: 2, occurrence: 51
   level: 3, occurrence: 20
   level: 4, occurrence: 13
   level: 5, occurrence: 41
XXX number of pointers point to pointers: 58
XXX number of pointers point to scalars: 77
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.3
XXX average alias set size: 1.4

XXX times a non-volatile is read: 694
XXX times a non-volatile is write: 224
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 5

XXX stmts: 146
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 24
   depth: 2, occurrence: 21
   depth: 3, occurrence: 23
   depth: 4, occurrence: 22
   depth: 5, occurrence: 25

XXX percentage a fresh-made variable is used: 18.8
XXX percentage an existing variable is used: 81.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

