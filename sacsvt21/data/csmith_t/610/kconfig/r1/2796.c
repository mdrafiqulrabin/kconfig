/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1146069729
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   signed f1 : 4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_29(void);
inline static int32_t * func_30(uint32_t  p_31, float  p_32, uint8_t  p_33, uint8_t  p_34);
inline static uint8_t  func_37(const float  p_38, const int64_t  p_39, const int32_t * p_40, int32_t * p_41);
static int16_t  func_42(int32_t * p_43, int32_t  p_44);
inline static int32_t * func_45(int32_t * p_46, uint64_t  p_47, uint32_t  p_48, int16_t  p_49);
static int32_t * func_50(int16_t  p_51);
static struct S0  func_64(int16_t  p_65, uint16_t  p_66);
inline static int16_t  func_67(uint32_t  p_68, int32_t * p_69, uint16_t  p_70);
inline static int32_t * func_71(float  p_72, struct S0  p_73, uint32_t  p_74);
inline static struct S0  func_75(const int32_t * p_76, int16_t  p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_29(void)
{ /* block id: 36 */
    float l_35 = 0x1.3p+1;
    int32_t l_36 = (-1L);
    const int32_t *l_518 = (void*)0;
    const int32_t **l_517 = &l_518;
    uint64_t l_519 = 18446744073709551615UL;
    (*l_517) = func_30(l_36, __builtin_ctz(l_36), func_37(l_36, ((((l_36 | ((l_36 ^ 0x83DE467BL) >= func_42(func_45(func_50((-(uint32_t)((int64_t)(&l_36 == &l_36) / (int64_t)1UL))), l_36, l_36, l_36), l_36))) && l_36) | l_36) | l_36), &l_36, &l_36), l_36);
    return l_519;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_30(uint32_t  p_31, float  p_32, uint8_t  p_33, uint8_t  p_34)
{ /* block id: 335 */
    uint32_t l_502 = 0UL;
    struct S0 l_510 = {0x5C985D93L,1};
    struct S0 *l_509 = &l_510;
    struct S0 **l_508 = &l_509;
    struct S0 ** const *l_507 = &l_508;
    int32_t l_512 = 0x2B403E00L;
    int32_t *l_511 = &l_512;
    int32_t *l_513 = &l_512;
    int32_t *l_514 = &l_512;
    int32_t *l_515 = &l_512;
    int32_t *l_516 = (void*)0;
    (*l_511) = ((uint32_t)(0xD8D2665FL <= (l_502 > (((int16_t)p_31 - (int16_t)((0x8FC5L || (((int16_t)p_34 + (int16_t)l_502) == __builtin_ctzll(l_502))) > (l_507 == &l_508))) | l_510.f0))) - (uint32_t)p_34);
    return l_516;
    /* statement id: 337 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_37(const float  p_38, const int64_t  p_39, const int32_t * p_40, int32_t * p_41)
{ /* block id: 319 */
    int32_t l_452 = 0x92B22A9DL;
    int32_t *l_451 = &l_452;
    struct S0 *l_465 = (void*)0;
    struct S0 **l_464 = &l_465;
    int32_t **l_477 = (void*)0;
    int32_t ***l_476 = &l_477;
    int32_t ****l_475 = &l_476;
    struct S0 l_499 = {0x334A0F4AL,3};
    l_451 = func_45(l_451, (*l_451), ((uint64_t)((uint32_t)(((*l_451) != ((*l_451) ^ ((4294967295UL <= (*l_451)) || ((uint32_t)((*l_451) >= ((int64_t)(((*l_451) == (*p_41)) && (*l_451)) / (int64_t)18446744073709551609UL)) - (uint32_t)(*l_451))))) == (*l_451)) / (uint32_t)(*l_451)) % (uint64_t)0xCD150BA0D21EE898LL), (*l_451));
    if (((void*)0 != p_40))
    { /* block id: 321 */
        int32_t **l_461 = &l_451;
        (*l_461) = (void*)0;
        /* statement id: 322 */
        assert (l_451 == 0);
        return p_39;
    }
    else
    { /* block id: 324 */
        uint32_t l_462 = 1UL;
        struct S0 l_463 = {2UL,-3};
        struct S0 *l_474 = &l_463;
        int32_t *l_480 = (void*)0;
        if (l_462)
        { /* block id: 325 */
            uint64_t l_470 = 0x250989A8940A48A9LL;
            struct S0 *l_473 = &l_463;
            int32_t l_481 = (-6L);
            (*l_473) = func_75(func_71(l_462, l_463, (p_39 | ((void*)0 != l_464))), ((int16_t)(((((uint16_t)(l_470 && ((-1L) & (((int32_t)((&p_40 == &p_40) & 0xFC1D73C0L) % (int32_t)(*l_451)) > (*l_451)))) << (uint16_t)4) < p_39) > 1UL) & (*l_451)) << (int16_t)p_39));
            (*l_464) = l_474;
            /* statement id: 327 */
            assert (l_465 == &l_463);
            l_480 = func_45(p_41, (*l_451), ((l_475 == (void*)0) ^ p_39), ((int16_t)9L - (int16_t)__builtin_bswap32((l_470 > 0xDEB38CE7A4FBB89CLL))));
            /* statement id: 328 */
            //assert (l_480 == &l_36);
            return l_481;
        }
        else
        { /* block id: 330 */
            float l_482 = 0x0.9p+1;
            int32_t l_496 = 0x926E7076L;
            l_499 = func_64(((p_39 != ((((uint16_t)(((int16_t)((((-(int16_t)((int32_t)((int64_t)((int16_t)((1UL == ((uint16_t)1UL % (uint16_t)l_496)) < 0x763AL) - (int16_t)((~p_39) | (-(uint32_t)p_39))) - (int64_t)p_39) / (int32_t)(18446744073709551615UL | 0x150C1583F1BB0B55LL))) <= l_496) && p_39) | 0x3C7869FAL) >> (int16_t)3) < p_39) << (uint16_t)5) & 2L) == p_39)) ^ l_496), p_39);
            return p_39;
        }
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_42(int32_t * p_43, int32_t  p_44)
{ /* block id: 315 */
    int32_t l_443 = (-6L);
    const int32_t *l_442 = &l_443;
    struct S0 l_448 = {0x566013AFL,1};
    float l_450 = (-0x10.2p-1);
    float *l_449 = &l_450;
    l_448 = func_75(l_442, ((65534UL <= ((*l_442) & ((uint16_t)p_44 >> (uint16_t)(((uint16_t)((*l_442) < ((*l_442) >= p_44)) >> (uint16_t)(((*l_442) != ((p_44 != (*l_442)) != 0x8BD4L)) >= (*l_442))) && (*l_442))))) | (*l_442)));
    (*l_449) = p_44;
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_45(int32_t * p_46, uint64_t  p_47, uint32_t  p_48, int16_t  p_49)
{ /* block id: 312 */
    uint32_t l_440 = 0UL;
    int32_t l_441 = 0L;
    l_441 = (l_440 < (l_440 > (l_440 > p_48)));
    return p_46;
    /* statement id: 314 */
    //assert (func_45_rv == 0 || func_45_rv == &l_452 || func_45_rv == &l_36);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_50(int16_t  p_51)
{ /* block id: 37 */
    struct S0 l_58 = {0x323FA9DFL,2};
    struct S0 *l_57 = &l_58;
    int32_t l_307 = 0x59A3684EL;
    int32_t *l_306 = &l_307;
    int32_t **l_305 = &l_306;
    int32_t l_418 = 0xDECFFE95L;
    int32_t *l_438 = &l_418;
    int32_t *l_439 = (void*)0;
    for (p_51 = 0; (p_51 >= 23); p_51 += 4)
    { /* block id: 40 */
        int16_t l_146 = 8L;
        l_57 = l_57;
        if (p_51)
            goto lbl_308;
        for (l_58.f0 = 0; (l_58.f0 < 15); l_58.f0++)
        { /* block id: 44 */
            int32_t l_61 = 0x9C1C73B0L;
            struct S0 l_304 = {0x20633EA2L,3};
            for (l_61 = 0; (l_61 < (-19)); l_61 -= 8)
            { /* block id: 47 */
                const int32_t *l_78 = &l_61;
                l_304 = func_64(func_67(l_61, func_71(p_51, func_75(l_78, p_51), (0x1CD05094191B8600LL & (*l_78))), l_146), l_58.f0);
            }
            if (p_51)
                continue;
        }
    }
lbl_308:
    (*l_305) = (void*)0;
    /* statement id: 227 */
    assert (l_306 == 0);
    for (l_58.f0 = 0; (l_58.f0 > 34); l_58.f0 += 3)
    { /* block id: 231 */
        struct S0 * const l_313 = &l_58;
        int32_t l_314 = 9L;
        int32_t ***l_324 = &l_305;
        struct S0 l_332 = {0x9E29BA9FL,2};
        float l_336 = 0x8.E7BC49p+64;
        int32_t *l_356 = &l_307;
        struct S0 **l_417 = &l_57;
        struct S0 ***l_416 = &l_417;
        float *l_437 = &l_336;
    }
    return l_439;
    /* statement id: 311 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_64(int16_t  p_65, uint16_t  p_66)
{ /* block id: 217 */
    uint32_t l_297 = 0x3AB29AFFL;
    int32_t *l_298 = (void*)0;
    int32_t **l_299 = (void*)0;
    int32_t **l_300 = &l_298;
    int32_t l_302 = 0x6CB08EF8L;
    int32_t *l_301 = &l_302;
    struct S0 l_303 = {4294967292UL,1};
    l_297 = p_66;
    (*l_300) = l_298;
    (*l_301) = p_65;
    return l_303;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_67(uint32_t  p_68, int32_t * p_69, uint16_t  p_70)
{ /* block id: 87 */
    int32_t l_148 = 1L;
    const int32_t *l_147 = &l_148;
    struct S0 l_150 = {0xAAAAF263L,-0};
    struct S0 *l_149 = &l_150;
    struct S0 l_218 = {4294967295UL,-1};
    int32_t l_228 = (-1L);
    struct S0 l_275 = {4UL,3};
    int32_t ***l_278 = (void*)0;
    const int32_t *l_285 = &l_148;
lbl_229:
    (*l_149) = func_75(l_147, ((*l_147) && p_68));
lbl_208:
    if (((*l_147) & ((int16_t)0xC860L % (int16_t)p_68)))
    { /* block id: 89 */
        int32_t * const l_153 = (void*)0;
        int32_t *l_155 = (void*)0;
        int32_t **l_154 = &l_155;
        (*l_154) = l_153;
    }
    else
    { /* block id: 91 */
        const struct S0 * const *l_156 = (void*)0;
        struct S0 **l_158 = &l_149;
        struct S0 ***l_157 = &l_158;
        struct S0 l_159 = {4UL,1};
        (*l_157) = l_156;
        /* statement id: 92 */
        assert (l_158 == 0);
        (*l_149) = func_75(&l_148, p_68);
        (*l_149) = l_159;
    }
    if (((int16_t)1L >> (int16_t)(0xF3DCL != ((void*)0 == &l_148))))
    { /* block id: 96 */
        int64_t l_164 = 0x3554E5FB264BA2F5LL;
        if (((((uint32_t)(0UL != l_164) + (uint32_t)l_164) < (*l_147)) ^ (*l_147)))
        { /* block id: 97 */
            int32_t *l_165 = &l_148;
            (*l_165) = l_164;
        }
        else
        { /* block id: 99 */
            uint32_t l_168 = 18446744073709551612UL;
            uint64_t l_169 = 0x7B5E8C0C16224620LL;
            const int32_t *l_172 = &l_148;
            float l_188 = (-0x5.9p+1);
            float *l_187 = &l_188;
            struct S0 **l_189 = &l_149;
            int32_t *l_191 = (void*)0;
            int32_t **l_190 = &l_191;
            if ((p_70 >= ((int64_t)0xA75F86E748EE0A1FLL - (int64_t)(l_168 && l_169))))
            { /* block id: 100 */
                float l_171 = 0x1.212FD2p-10;
                float *l_170 = &l_171;
                int32_t *l_174 = (void*)0;
                int32_t **l_173 = &l_174;
                (*l_170) = (p_70 <= (__builtin_parity(p_70) >= p_68));
                (*l_149) = func_75(l_172, p_70);
                (*l_173) = p_69;
                /* statement id: 103 */
                //assert (l_174 == 0 || l_174 == &l_314 || l_174 == &l_336);
            }
            else
            { /* block id: 104 */
                uint8_t l_175 = 0xB3L;
                (*l_149) = func_75(p_69, (l_175 < ((int16_t)((((((uint64_t)l_164 - (uint64_t)0xA4583ED9FA11705FLL) > ((*l_147) <= ((uint32_t)(*l_147) - (uint32_t)(0xFEA8EEEDL < ((uint16_t)((int16_t)p_68 + (int16_t)(*l_147)) << (uint16_t)(*l_172)))))) ^ p_68) == 0x6A3CL) == 0x26C4C03FL) >> (int16_t)p_70)));
            }
            (*l_187) = (-(float)(*l_147));
            (*l_189) = &l_150;
            (*l_190) = l_172;
            /* statement id: 109 */
            assert (l_191 == &l_148);
        }
        return l_164;
    }
    else
    { /* block id: 112 */
        uint16_t l_209 = 0x308FL;
        int32_t l_210 = 1L;
        float l_221 = (-0x9.9p-1);
        struct S0 l_245 = {1UL,-0};
        for (l_148 = (-1); (l_148 >= 18); ++l_148)
        { /* block id: 115 */
            struct S0 * const **l_194 = (void*)0;
            struct S0 ***l_195 = (void*)0;
            const struct S0 **l_197 = (void*)0;
            const struct S0 ***l_196 = &l_197;
            (*l_196) = &l_149;
            /* statement id: 116 */
            assert (l_197 == &l_149);
        }
        for (l_148 = 0; (l_148 == (-19)); l_148 -= 7)
        { /* block id: 120 */
            int16_t l_207 = (-1L);
            struct S0 *l_224 = (void*)0;
            int32_t *l_225 = &l_210;
            for (p_68 = 0; (p_68 == 14); p_68 += 1)
            { /* block id: 123 */
                int32_t l_203 = (-1L);
                int32_t *l_202 = &l_203;
                struct S0 * const l_211 = &l_150;
                (*l_202) = 0xA909BF4FL;
                (*l_202) = (!(*l_202));
                if (((int16_t)(((-8L) | p_70) & (l_207 > 0x8DFEB7701912ACE4LL)) - (int16_t)(p_69 == p_69)))
                { /* block id: 126 */
                    if (l_207)
                        goto lbl_208;
                    return p_70;
                }
                else
                { /* block id: 129 */
                    struct S0 **l_212 = (void*)0;
                    struct S0 **l_213 = &l_149;
                    int32_t l_219 = (-1L);
                    l_210 = (p_70 >= __builtin_parityll(((*l_147) | l_209)));
                    (*l_213) = l_211;
                    for (l_207 = 0; (l_207 != 6); l_207 += 6)
                    { /* block id: 134 */
                        int32_t **l_220 = (void*)0;
                        p_69 = func_71(((float)p_70 + (float)((*l_202) != 0x2.AF4697p-48)), l_218, l_219);
                        /* statement id: 135 */
                        assert (p_69 == 0);
                        l_210 = (p_69 != p_69);
                    }
                }
            }
            (*l_225) = (((l_210 == (*l_147)) < ((int64_t)((void*)0 == l_224) + (int64_t)p_68)) ^ l_207);
        }
        if ((((int16_t)l_228 - (int16_t)(*l_147)) == p_68))
        { /* block id: 142 */
            struct S0 l_249 = {4294967286UL,-3};
            const int32_t *l_259 = &l_210;
            if ((*l_147))
            { /* block id: 143 */
                float *l_230 = &l_221;
                int32_t *l_233 = &l_148;
                int32_t **l_232 = &l_233;
                if (p_68)
                    goto lbl_229;
                if (p_70)
                    goto lbl_231;
lbl_231:
                (*l_230) = p_68;
                (*l_232) = func_71(p_68, func_75(p_69, p_68), p_68);
                /* statement id: 147 */
                assert (l_233 == 0);
                (*l_149) = func_75(p_69, ((void*)0 != &p_69));
            }
            else
            { /* block id: 149 */
                uint8_t l_238 = 0xEFL;
                int32_t *l_252 = &l_148;
                float *l_257 = (void*)0;
                float *l_258 = &l_221;
                int32_t **l_260 = &l_252;
                for (l_210 = 4; (l_210 >= (-19)); l_210--)
                { /* block id: 152 */
                    int32_t ***l_247 = (void*)0;
                    if (((uint64_t)l_238 - (uint64_t)(+__builtin_clz(p_68))))
                    { /* block id: 153 */
                        float *l_240 = &l_221;
                        int32_t *l_242 = &l_210;
                        int32_t **l_241 = &l_242;
                        struct S0 *l_243 = &l_218;
                        struct S0 **l_244 = &l_243;
                        (*l_240) = (p_70 < 0xB.8A83B6p+8);
                        (*l_241) = &l_210;
                        (*l_244) = l_243;
                        (*l_149) = l_245;
                    }
                    else
                    { /* block id: 158 */
                        float *l_246 = &l_221;
                        (*l_246) = 0x1.45E500p+16;
                        l_247 = l_247;
                        l_245.f1 = (l_210 == p_68);
                        return p_68;
                    }
                    l_252 = func_71((0x4.F05403p-94 >= ((!(-0x1.7p-1)) < 0x0.6p+1)), l_249, ((((uint64_t)l_245.f1 / (uint64_t)l_210) && 0xB0F1F695L) >= __builtin_ctz(l_249.f0)));
                    /* statement id: 164 */
                    assert (l_252 == 0);
                }
                /* facts after for loop */
                assert (l_252 == 0 || l_252 == &l_148);
                for (l_150.f0 = 0; (l_150.f0 != 51); l_150.f0++)
                { /* block id: 168 */
                    struct S0 **l_256 = &l_149;
                    struct S0 ***l_255 = &l_256;
                    (*l_255) = &l_149;
                    if ((*l_147))
                        continue;
                }
                (*l_258) = (-0x1.Cp+1);
                (*l_260) = func_71(p_68, func_75(&l_228, l_249.f0), ((void*)0 != l_259));
                /* statement id: 173 */
                assert (l_252 == 0);
            }
        }
        else
        { /* block id: 175 */
            float *l_261 = (void*)0;
            float *l_262 = (void*)0;
            float *l_263 = (void*)0;
            float *l_264 = &l_221;
            (*l_264) = p_70;
        }
        for (l_245.f0 = (-8); (l_245.f0 >= 11); l_245.f0++)
        { /* block id: 180 */
            struct S0 ***l_276 = (void*)0;
            float l_281 = 0x9.1E9BC4p-33;
            const int32_t l_282 = (-1L);
        }
    }
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_71(float  p_72, struct S0  p_73, uint32_t  p_74)
{ /* block id: 51 */
    uint64_t l_94 = 0x7D1C2B13F3B720FALL;
    struct S0 l_101 = {1UL,0};
    struct S0 *l_100 = &l_101;
    int32_t l_116 = (-1L);
    int32_t *l_115 = &l_116;
    int32_t *l_117 = &l_116;
    int32_t *l_143 = &l_116;
    int32_t *l_144 = &l_116;
    int32_t *l_145 = (void*)0;
    if (((uint32_t)(p_73.f0 && 0xCCDFL) % (uint32_t)p_74))
    { /* block id: 52 */
        int32_t l_89 = 0xC1F62131L;
        int32_t l_103 = 0x2D528561L;
        int32_t *l_102 = &l_103;
        float l_105 = (-0x9.0p+1);
        float *l_104 = &l_105;
        int32_t *l_119 = &l_103;
        int32_t *l_122 = &l_103;
        (*l_102) = (p_73.f1 || (((uint16_t)((p_73.f0 & (((-(uint16_t)(p_73.f1 ^ p_74)) <= l_89) != (((int64_t)((int32_t)(l_94 && (!((uint16_t)((uint16_t)1UL >> (uint16_t)12) << (uint16_t)((l_100 != &l_101) || p_73.f1)))) + (int32_t)2UL) + (int64_t)0xF870A65522591552LL) == l_89))) || p_73.f0) << (uint16_t)9) <= l_89));
        (*l_104) = 0x1.C3887Dp+82;
        (*l_104) = l_94;
        if ((p_73.f1 | ((uint16_t)(p_73.f1 > (*l_102)) << (uint16_t)7)))
        { /* block id: 56 */
            (*l_102) = 1L;
        }
        else
        { /* block id: 58 */
            int32_t *l_111 = &l_103;
            int32_t *l_121 = &l_103;
            if (((int64_t)((l_101.f0 <= p_73.f0) ^ __builtin_ia32_crc32qi(p_73.f1, p_73.f1)) - (int64_t)(p_73.f0 ^ (-(uint64_t)((((void*)0 == l_111) >= 0x47550418L) | 4294967295UL)))))
            { /* block id: 59 */
                int32_t **l_112 = &l_102;
                int32_t *l_123 = (void*)0;
                (*l_112) = &l_103;
                for (l_101.f0 = 0; (l_101.f0 >= 35); ++l_101.f0)
                { /* block id: 63 */
                    int32_t *l_118 = &l_116;
                    int32_t *l_120 = &l_103;
                    return l_123;
                    /* statement id: 64 */
                    //assert (func_71_rv == 0);
                }
            }
            else
            { /* block id: 66 */
                int32_t **l_124 = (void*)0;
                int32_t **l_125 = &l_119;
                const int32_t *l_131 = &l_116;
                (*l_125) = &l_116;
                /* statement id: 67 */
                assert (l_119 == &l_116);
                for (p_74 = (-10); (p_74 != 58); ++p_74)
                { /* block id: 70 */
                    const int32_t *l_130 = &l_103;
                    uint64_t l_139 = 0x6583FDF714E35B4FLL;
                    for (l_101.f0 = 7; (l_101.f0 == 9); l_101.f0++)
                    { /* block id: 73 */
                        (*l_125) = l_111;
                        /* statement id: 74 */
                        assert (l_119 == &l_103);
                    }
                    l_131 = l_130;
                    /* statement id: 76 */
                    assert (l_131 == &l_103);
                    (*l_122) = (((((p_73.f0 && ((int16_t)p_73.f1 >> (int16_t)(p_74 & (((+((int32_t)(p_74 > (0UL == p_74)) % (int32_t)(*l_130))) >= p_73.f0) || ((uint16_t)(p_73.f0 | 1UL) >> (uint16_t)15))))) ^ l_139) != p_73.f0) <= (-1L)) != 0x2608L);
                }
                /* facts after for loop */
                assert (l_119 == &l_103 || l_119 == &l_116);
                assert (l_131 == &l_103 || l_131 == &l_116);
                (*l_125) = &l_103;
                /* statement id: 79 */
                assert (l_119 == &l_103);
            }
        }
    }
    else
    { /* block id: 82 */
        int32_t *l_140 = &l_116;
        int32_t *l_141 = &l_116;
        int32_t *l_142 = (void*)0;
        return l_142;
        /* statement id: 83 */
        //assert (func_71_rv == 0);
    }
    p_73.f1 = (__builtin_clzl(p_73.f1) == 0xECAFL);
    return l_145;
    /* statement id: 86 */
    //assert (func_71_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_75(const int32_t * p_76, int16_t  p_77)
{ /* block id: 48 */
    int32_t l_80 = (-1L);
    int32_t * const l_79 = &l_80;
    const int32_t *l_82 = &l_80;
    const int32_t **l_81 = &l_82;
    struct S0 l_83 = {0UL,3};
    (*l_81) = l_79;
    return l_83;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 118
   depth: 1, occurrence: 19
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 33
breakdown:
   indirect level: 0, occurrence: 19
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 6
XXX times a bitfields struct on RHS: 20
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 11

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 18
   depth: 3, occurrence: 7
   depth: 4, occurrence: 8
   depth: 5, occurrence: 1
   depth: 6, occurrence: 4
   depth: 7, occurrence: 1
   depth: 10, occurrence: 3
   depth: 12, occurrence: 2
   depth: 15, occurrence: 3
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 150

XXX times a variable address is taken: 137
XXX times a pointer is dereferenced on RHS: 54
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 75
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 299

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 535
   level: 2, occurrence: 25
   level: 3, occurrence: 22
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 53
XXX number of pointers point to scalars: 85
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 34.7
XXX average alias set size: 1.21

XXX times a non-volatile is read: 504
XXX times a non-volatile is write: 207
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 2

XXX stmts: 115
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 21
   depth: 2, occurrence: 20
   depth: 3, occurrence: 22
   depth: 4, occurrence: 13
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 14
XXX percentage an existing variable is used: 86
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

