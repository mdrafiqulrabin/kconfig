/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      762430235
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 12;
   signed f1 : 19;
   unsigned f2 : 10;
   int32_t  f3;
   signed f4 : 22;
};
#pragma pack(pop)

union U1 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_29(void);
static uint32_t  func_67(uint16_t  p_68);
static struct S0  func_70(uint16_t  p_71, union U1  p_72, int32_t  p_73, int32_t  p_74, int16_t  p_75);
inline static struct S0  func_87(struct S0  p_88);
inline static struct S0  func_89(struct S0  p_90, struct S0  p_91, struct S0  p_92);
inline static struct S0  func_93(struct S0  p_94, int32_t  p_95);
inline static uint32_t  func_96(uint32_t  p_97, int32_t  p_98);
static uint16_t  func_99(uint16_t  p_100, int32_t  p_101, int32_t  p_102, int32_t  p_103, int16_t  p_104);
inline static int32_t  func_105(int32_t  p_106, int16_t  p_107, int16_t  p_108);
static uint16_t  func_109(union U1  p_110);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_30 = 0U;
    int32_t l_37 = 0x7828451D;
    int32_t l_38 = 0x586FA66F;
    uint32_t l_39 = 1U;
    int32_t l_40 = (-6);
    uint16_t l_66 = 0U;
    struct S0 l_358 = {2,465,13,0x4A1A8C06,44};
    uint32_t l_398 = 4294967293U;
    union U1 l_404 = {4294967295U};
    uint32_t l_477 = 0x7BA9D097;
    l_30 = 0x65251C60;
    l_40 = ((int16_t)((int16_t)__builtin_parityl(l_30) + (int16_t)65535U) << (int16_t)(__builtin_ffsll(l_30) > (l_39 ^= ((l_30 , ((l_37 = ((int16_t)l_30 % (int16_t)l_30)) | ((l_38 = l_30) | l_30))) || l_38))));
    for (l_38 = (-15); (l_38 < (-14)); l_38 += 1)
    { /* block id: 44 */
        int32_t l_52 = 0xEFEC1A2C;
        uint32_t l_332 = 0x3867B030;
        int32_t l_333 = 0;
        int32_t l_355 = (-5);
        int32_t l_395 = 0;
        uint32_t l_413 = 4294967287U;
        union U1 l_425 = {0x473DD930};
        struct S0 l_470 = {32,281,21,0xCE2F32C4,1112};
        struct S0 l_471 = {57,65,26,4,941};
        for (l_30 = 0; (l_30 != 56); l_30 += 8)
        { /* block id: 47 */
            int32_t l_58 = 8;
            int32_t l_329 = 0x730C1C02;
            struct S0 l_364 = {21,-282,22,0x1B390526,-623};
            int32_t l_384 = (-2);
            for (l_39 = 0; (l_39 != 36); l_39 += 9)
            { /* block id: 50 */
                int32_t l_47 = (-1);
                int32_t l_326 = 0;
                int32_t l_328 = 0x1529816D;
                struct S0 l_365 = {18,431,17,1,-1185};
                l_40 &= l_47;
                for (l_37 = (-9); (l_37 <= (-6)); l_37 += 9)
                { /* block id: 54 */
                    int16_t l_327 = 0x8FB7;
                    int32_t l_340 = 0x1C35D5C1;
                    struct S0 l_357 = {31,321,9,-1,-1342};
                    union U1 l_374 = {6U};
                    for (l_47 = (-8); (l_47 != (-5)); l_47 += 3)
                    { /* block id: 57 */
                        int32_t l_53 = 1;
                        uint32_t l_69 = 0xF9520128;
                        l_53 = l_52;
                        l_329 ^= ((int16_t)(l_53 , ((((uint16_t)l_58 >> (uint16_t)((((((-(uint32_t)(l_53 == ((int32_t)(l_328 = ((l_52 <= (l_38 < ((uint32_t)l_66 - (uint32_t)(((func_67(l_69) && (l_326 = ((int16_t)l_52 * (int16_t)0x3A7B))) , l_327) | l_52)))) ^ l_69)) - (int32_t)l_69))) || l_52) & 0x1153) , l_327) , l_52) | l_30)) , l_327) && l_58)) >> (int16_t)l_58);
                    }
                    if ((l_333 = ((uint32_t)l_30 + (uint32_t)l_332)))
                    { /* block id: 221 */
                        l_40 = 0;
                        if (l_329)
                            continue;
                    }
                    else
                    { /* block id: 224 */
                        int16_t l_339 = 2;
                        int32_t l_356 = 0x4A210223;
                        l_328 ^= ((((uint16_t)(l_340 = (!(((l_339 ^= ((__builtin_parityll(l_47) >= (((int16_t)0x80BC % (int16_t)l_329) < l_326)) != l_327)) || (-3)) != (((((l_58 = 0x9983) ^ l_40) >= l_329) ^ l_40) & l_40)))) >> (uint16_t)14) , l_326) , 1);
                        l_326 = l_52;
                        l_40 |= (((l_356 |= __builtin_popcountl((((uint16_t)(((!((l_328 = ((uint16_t)((uint16_t)(l_37 & ((((((((int32_t)0xBB967418 % (int32_t)(l_339 ^ l_332)) , ((l_339 > l_66) | (l_326 ^= ((uint32_t)((!((int16_t)8 >> (int16_t)1)) ^ (l_39 && (__builtin_parityl((((l_355 ^ 0xC04F) | l_327) , l_58)) , 1U))) % (uint32_t)5U)))) != l_329) == l_339) > l_38) != l_328) < l_30)) << (uint16_t)0) << (uint16_t)l_39)) != 0x7AA4DF51)) > 0xBC391C3C) <= 4294967291U) + (uint16_t)l_58) && 0xD37DC95B))) == 0xB002A27E) , l_52);
                    }
                    if (l_37)
                    { /* block id: 235 */
                        l_358 = l_357;
                    }
                    else
                    { /* block id: 237 */
                        uint32_t l_361 = 1U;
                        uint32_t l_383 = 0x04460A15;
                        l_365 = (((uint16_t)l_361 >> (uint16_t)((int16_t)l_357.f0 - (int16_t)l_329)) , l_364);
                        if (l_58)
                            break;
                        l_52 = ((uint16_t)65535U * (uint16_t)((uint16_t)((l_340 = ((int16_t)l_52 + (int16_t)((((int16_t)((l_333 |= ((((l_332 < l_38) , l_374) , ((int16_t)__builtin_ffsll(__builtin_parityll(((uint32_t)((uint16_t)(((uint16_t)l_357.f1 - (uint16_t)__builtin_ia32_crc32qi(l_358.f1, ((l_358.f3 = (1 & l_66)) , 0xDB))) == l_361) * (uint16_t)0) + (uint32_t)l_357.f4))) << (int16_t)5)) ^ 0x44F20A68)) != 8) >> (int16_t)l_383) | l_364.f4) & l_357.f3))) && l_365.f0) + (uint16_t)8U));
                    }
                    l_357.f3 = (l_358.f3 >= l_384);
                }
                l_333 = ((int16_t)8 % (int16_t)(l_58 , l_329));
            }
            l_37 = func_96(((int32_t)(((((uint32_t)((int32_t)((((int16_t)((l_58 & __builtin_ctz((l_364.f1 &= (l_395 , ((uint16_t)__builtin_parityll(l_384) >> (uint16_t)(l_333 ^= (((4294967293U != __builtin_parity(l_364.f2)) >= l_52) , l_364.f0))))))) , l_364.f0) - (int16_t)l_358.f1) < l_52) , 0xFCA8566A) + (int32_t)l_364.f2) - (uint32_t)l_52) != 0x0A3EDAA9) , l_66) ^ 0xB26566AD) - (int32_t)l_358.f3), l_329);
            l_364.f4 &= l_398;
            l_358.f3 = 0x1F511CAA;
        }
        l_37 = (((int16_t)(((-(int16_t)l_358.f0) > 6) && ((int32_t)0x65791FB3 + (int32_t)l_66)) << (int16_t)10) == (func_109(l_404) || (((uint32_t)((((((int16_t)((uint16_t)__builtin_clzll(l_358.f3) << (uint16_t)13) << (int16_t)6) ^ ((uint32_t)l_395 - (uint32_t)l_52)) , 0xC607) < l_395) & l_413) % (uint32_t)0x73CC8CE1) != l_30)));
        l_333 &= ((((uint16_t)l_332 + (uint16_t)(l_358 , ((l_358.f0 <= l_413) ^ l_358.f1))) >= (l_39 , (l_37 ^= (l_413 ^ (((((uint32_t)4294967287U - (uint32_t)(((((int16_t)((l_358.f4 & l_358.f1) || l_358.f0) % (int16_t)l_66) > l_40) >= l_332) || l_355)) , 0xF5DF9CED) & 0U) && l_395))))) >= l_39);
        for (l_40 = 0; (l_40 > 20); l_40 += 1)
        { /* block id: 260 */
            uint32_t l_426 = 0x26DE157F;
            int32_t l_443 = 0x1FA86979;
            struct S0 l_446 = {49,708,26,0xAC991035,-1526};
            int32_t l_453 = 0;
            struct S0 l_456 = {5,-341,25,0xD3E306D3,-1755};
            union U1 l_458 = {0U};
            uint32_t l_490 = 0x3C8C507F;
            uint16_t l_494 = 0x7066;
            for (l_39 = 10; (l_39 != 60); l_39 += 1)
            { /* block id: 263 */
                uint32_t l_424 = 4294967289U;
                int16_t l_430 = 0x4A67;
                int32_t l_469 = 0x31180D5B;
                int32_t l_472 = (-1);
                l_358 = func_70(l_424, l_425, l_426, func_105(l_395, ((((-(int32_t)l_426) < l_426) < ((int16_t)1 << (int16_t)l_413)) ^ l_38), l_430), l_430);
                if ((l_430 < ((uint32_t)(l_52 |= ((int16_t)((int16_t)l_425.f0 % (int16_t)((uint16_t)((uint16_t)l_426 * (uint16_t)(l_453 |= (l_426 == ((int16_t)l_443 - (int16_t)((uint32_t)__builtin_popcountll(l_332) + (uint32_t)(l_446 , (~((~((int32_t)(((uint16_t)l_398 << (uint16_t)3) != l_446.f4) + (int32_t)l_355)) | l_395)))))))) >> (uint16_t)15)) % (int16_t)l_30)) % (uint32_t)l_446.f0)))
                { /* block id: 267 */
                    uint32_t l_457 = 4294967290U;
                    struct S0 l_461 = {34,-3,26,0x54CA6F1A,610};
                    uint32_t l_468 = 0x87670D3A;
                    for (l_424 = (-3); (l_424 > 34); l_424 += 1)
                    { /* block id: 270 */
                        l_456 = (l_446 = l_358);
                        if (l_424)
                            break;
                        return l_430;
                    }
                    l_470 = ((func_70(l_457, (l_425 , l_458), l_453, ((int32_t)l_457 - (int32_t)(((l_457 ^ ((l_461 , ((l_472 ^= ((uint16_t)((uint32_t)0x1271786E + (uint32_t)(func_89(func_93((func_67((l_469 = ((int16_t)l_461.f0 * (int16_t)l_468))) , l_470), l_461.f3), l_461, l_471) , 1)) << (uint16_t)l_38)) , 4294967291U)) , 65528U)) >= l_456.f4) > 2)), l_456.f3) , 5U) , l_358);
                }
                else
                { /* block id: 279 */
                    int16_t l_480 = (-1);
                    uint32_t l_489 = 0xC95D6D45;
                    l_490 ^= (((l_471.f2 < ((int16_t)((((((uint16_t)(l_477 ^ (((((uint16_t)65528U * (uint16_t)(((l_480 < __builtin_ia32_crc32qi((((uint16_t)((l_472 == 0xEF04) , (((((func_96(((uint32_t)((int32_t)l_446.f2 % (int32_t)((int32_t)(l_425.f0 | l_446.f4) + (int32_t)l_480)) + (uint32_t)l_480), l_480) ^ l_470.f2) != l_446.f1) , l_480) & 8U) , 0x0716)) * (uint16_t)l_446.f3) < l_66), l_37)) ^ l_469) ^ l_469)) >= l_358.f2) < 0x6B88) & l_470.f3)) * (uint16_t)(-2)) , 0) , l_480) | l_480) && l_456.f2) % (int16_t)9)) == l_446.f2) , l_489);
                }
                return l_37;
            }
            for (l_39 = 0; (l_39 > 41); l_39 += 1)
            { /* block id: 286 */
                int16_t l_495 = (-2);
                int32_t l_496 = (-7);
                l_496 |= (l_358.f1 = (l_470.f1 = func_105(l_470.f2, (l_446.f3 &= ((~func_67(l_494)) , ((l_477 , l_456) , (l_456.f1 ^= 0x6BFE)))), l_495)));
            }
        }
    }
    return l_358.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_67(uint16_t  p_68)
{ /* block id: 59 */
    int32_t l_78 = (-4);
    union U1 l_111 = {4294967295U};
    int32_t l_197 = 0xFDBDBAA6;
    struct S0 l_198 = {48,-187,29,0xD00BA8EA,-1375};
    struct S0 l_205 = {43,-477,13,0xB5B4C238,-1721};
    struct S0 l_206 = {40,-441,17,-2,-1381};
    struct S0 l_207 = {37,423,19,0,1011};
    int32_t l_286 = 0xEB0CF147;
    struct S0 l_305 = {22,-321,7,0xAFB836CF,-1157};
    int32_t l_310 = 0x6EF71A36;
    l_305 = func_70((((int16_t)(l_78 < ((l_286 = (((((((uint32_t)((int16_t)((((uint16_t)((uint16_t)l_78 - (uint16_t)(func_87((l_207 = func_89((l_206 = (l_205 = func_93((l_198 = ((l_78 >= (l_197 ^= (func_96(l_78, (p_68 | func_99(p_68, l_78, func_105((func_109(l_111) != l_78), p_68, l_78), p_68, l_111.f0))) & 2U))) , l_198)), p_68))), l_207, l_207))) , l_78)) + (uint16_t)l_111.f0) >= 0U) | p_68) * (int16_t)0x24EC) % (uint32_t)l_78) ^ l_111.f0) ^ l_78) , l_207.f0) && l_205.f2) > l_78)) & (-8))) * (int16_t)l_111.f0) ^ p_68), l_111, l_78, l_78, l_111.f0);
    l_205.f4 &= p_68;
    l_198.f4 = (((int16_t)p_68 >> (int16_t)10) , (((0xE039 && (7 || (l_111 , ((l_111 , ((int16_t)__builtin_parityll((l_207.f1 = (l_310 ^ ((l_205.f1 &= (-(int32_t)(-3))) || __builtin_bswap32(l_206.f0))))) + (int16_t)(-1))) > l_78)))) < p_68) < p_68));
    if (p_68)
    { /* block id: 198 */
        int16_t l_312 = 0xB983;
        struct S0 l_313 = {54,-432,13,1,206};
        l_313 = func_87((l_198 = (func_109(l_111) , func_87((l_305 = func_93(func_70(__builtin_popcountll(p_68), l_111, (l_207.f3 ^= 0xC18F20B7), (l_206.f4 = 0), ((((p_68 , p_68) != p_68) , l_312) || 4U)), p_68))))));
    }
    else
    { /* block id: 204 */
        int16_t l_318 = 0xEDF5;
        struct S0 l_319 = {55,-593,27,9,-685};
        l_206.f3 = ((((l_310 = 65535U) && 0x60DE) || ((__builtin_popcount(((uint16_t)__builtin_popcountll(l_318) >> (uint16_t)5)) > p_68) >= ((l_319 , ((((uint32_t)p_68 + (uint32_t)(p_68 , p_68)) >= p_68) , p_68)) ^ p_68))) != l_319.f2);
        l_319.f4 = 5;
        l_319.f3 &= 0x0D5265D9;
        for (l_206.f3 = 0; (l_206.f3 >= (-4)); l_206.f3 -= 1)
        { /* block id: 211 */
            l_198.f1 = l_318;
        }
    }
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_70(uint16_t  p_71, union U1  p_72, int32_t  p_73, int32_t  p_74, int16_t  p_75)
{ /* block id: 184 */
    uint32_t l_287 = 4294967295U;
    int32_t l_294 = 0xF315A7A7;
    int32_t l_295 = 0x28AE0F1C;
    int32_t l_302 = (-5);
    int32_t l_303 = (-8);
    struct S0 l_304 = {34,-81,7,0x5AF64C55,338};
    p_74 = (p_74 > (__builtin_clzll(l_287) != __builtin_ffsl((l_295 = (l_294 ^= ((int32_t)(p_74 < (p_71 = p_72.f0)) - (int32_t)__builtin_ffsl(((int16_t)l_287 >> (int16_t)((uint16_t)(l_287 & p_74) % (uint16_t)(0 || p_73))))))))));
    p_74 = (l_294 = (0x3C01 || (l_294 < p_72.f0)));
    l_294 = (((-1) || ((((int32_t)p_73 % (int32_t)func_99(((int32_t)(-5) % (int32_t)0xEACDEA14), l_294, l_295, p_74, ((uint16_t)(0x9712668D ^ l_302) * (uint16_t)l_303))) , (-1)) > 0x5DE1)) ^ l_287);
    return l_304;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_87(struct S0  p_88)
{ /* block id: 170 */
    int32_t l_266 = 0x68A31390;
    int32_t l_283 = 0x8C9A2879;
    int16_t l_284 = 4;
    int32_t l_285 = 0xD141096F;
    if (p_88.f3)
    { /* block id: 171 */
        struct S0 l_262 = {11,571,23,-5,-330};
        return l_262;
    }
    else
    { /* block id: 173 */
        int32_t l_263 = 1;
        l_263 ^= p_88.f4;
    }
    p_88.f3 &= 0x17790CCD;
    p_88.f4 = ((uint32_t)(p_88.f0 < (p_88.f4 , l_266)) - (uint32_t)((l_266 || 0x3BB4) == (((uint16_t)func_99(l_266, p_88.f1, l_266, l_266, p_88.f1) >> (uint16_t)5) <= 0x91A9)));
    p_88.f1 &= (l_266 != (l_285 &= (((int16_t)1 * (int16_t)(((((l_284 = ((0xF99E5869 == ((int16_t)((uint16_t)l_266 % (uint16_t)(((uint32_t)(func_96(((((uint16_t)(((uint16_t)l_266 << (uint16_t)8) , 1U) << (uint16_t)((65535U & ((((int16_t)(l_283 = (-1)) - (int16_t)(p_88.f4 , l_266)) ^ p_88.f4) || 65535U)) , 0x0317)) , 0xC408DC6C) , 0x9B9190C5), l_266) | l_266) - (uint32_t)l_266) || 0)) * (int16_t)l_266)) && p_88.f3)) <= 0x1E16781F) , p_88.f4) == p_88.f3) | 0xBD95)) | l_266)));
    return p_88;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_89(struct S0  p_90, struct S0  p_91, struct S0  p_92)
{ /* block id: 131 */
    uint32_t l_210 = 0x45C538B7;
    int32_t l_211 = (-1);
    int32_t l_214 = 0x7E704F44;
    int32_t l_231 = 1;
    int32_t l_232 = (-4);
    int32_t l_233 = (-1);
    struct S0 l_234 = {4,364,6,2,-190};
    int16_t l_247 = 0x9719;
    uint16_t l_256 = 0x5391;
    p_90.f3 ^= ((((uint16_t)(l_211 = ((l_210 = p_91.f1) != (-1))) * (uint16_t)0x04C1) ^ p_92.f4) > ((uint32_t)l_214 + (uint32_t)(__builtin_clz(l_214) != l_214)));
    if (__builtin_ffsll((__builtin_bswap32((l_233 ^= ((uint16_t)l_214 * (uint16_t)(((uint16_t)0x1B9E >> (uint16_t)(l_211 = (((uint16_t)l_210 >> (uint16_t)5) != (l_232 = (p_90.f2 && (((((uint16_t)(0x309F && l_211) * (uint16_t)(l_211 == ((((l_231 |= ((int16_t)((int32_t)(((p_92.f3 = l_214) == ((((((((int16_t)((int16_t)1 * (int16_t)65530U) << (int16_t)12) <= p_92.f0) < 0xE846025C) >= l_210) != l_214) > p_91.f3) & 0x8B26)) & 6U) + (int32_t)0xB0E61FE2) * (int16_t)p_91.f2)) | l_232) , l_232) != (-10)))) >= l_214) >= p_92.f2) || (-1))))))) , 7)))) & l_214)))
    { /* block id: 140 */
        uint32_t l_246 = 0x768AC21E;
        union U1 l_252 = {2U};
        uint32_t l_253 = 4294967293U;
        uint32_t l_255 = 0xA175790A;
        l_234 = p_91;
        p_92.f3 &= l_234.f1;
        if (l_210)
        { /* block id: 143 */
            struct S0 l_235 = {29,713,31,1,1422};
            l_235 = (l_234.f3 , l_234);
            p_92.f4 = l_235.f4;
        }
        else
        { /* block id: 146 */
            uint32_t l_241 = 1U;
            int32_t l_248 = (-1);
            int32_t l_249 = (-1);
            l_249 = (((int16_t)(l_233 = ((uint16_t)(0x2B0F & (l_241 = ((!5) && l_231))) * (uint16_t)(p_92.f2 == ((l_211 = 6U) | (l_248 = ((p_92.f1 < (l_214 |= (((uint16_t)((func_96(p_90.f1, ((((uint16_t)(l_246 = (l_232 = l_234.f1)) >> (uint16_t)2) , (func_93(func_93(p_91, p_92.f1), l_234.f4) , p_90.f2)) > p_90.f0)) , 0xE986) & p_90.f4) + (uint16_t)l_247) ^ l_210))) <= p_90.f0)))))) * (int16_t)l_234.f4) , l_241);
        }
        p_92.f4 &= (((uint16_t)(p_92.f0 && l_246) * (uint16_t)((l_253 ^= (func_109(l_252) | l_246)) != (-(int32_t)(p_92.f1 &= l_255)))) || ((((((((func_96(l_210, p_90.f0) > p_91.f1) > l_233) < l_256) & p_90.f3) != (-1)) > p_90.f1) < l_255) >= l_246));
    }
    else
    { /* block id: 159 */
        int32_t l_257 = (-3);
        l_257 = l_234.f0;
    }
    for (l_232 = 0; (l_232 <= 0); l_232 += 1)
    { /* block id: 164 */
        return l_234;
    }
    p_92.f4 = ((int16_t)p_91.f4 * (int16_t)(0x5DF6 < l_256));
    return p_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_93(struct S0  p_94, int32_t  p_95)
{ /* block id: 122 */
    int32_t l_201 = 0x4FDE4B57;
    uint16_t l_202 = 65532U;
    int32_t l_203 = 0x9B31375F;
    struct S0 l_204 = {52,-630,7,-2,1995};
    l_204 = ((((((uint16_t)((l_202 = (l_201 = l_201)) || (p_94.f3 = (p_94.f0 ^ p_94.f1))) * (uint16_t)l_203) != p_94.f0) ^ 0x63E4) || p_94.f1) , l_204);
    l_204 = p_94;
    return l_204;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_96(uint32_t  p_97, int32_t  p_98)
{ /* block id: 97 */
    struct S0 l_171 = {59,-17,24,4,1518};
    union U1 l_178 = {4294967286U};
    int16_t l_191 = (-6);
    l_171 = l_171;
    for (p_98 = 0; (p_98 == (-7)); p_98 -= 4)
    { /* block id: 101 */
        int32_t l_177 = 0xF828D7B0;
        uint16_t l_179 = 0x3999;
        int32_t l_190 = 0x28A13AAE;
        struct S0 l_195 = {51,626,1,0xAC5C3DF7,1564};
        if (p_97)
            break;
        if (((!(p_98 || ((p_97 < (func_105((((int16_t)p_98 * (int16_t)(__builtin_ia32_crc32qi(l_171.f4, p_98) == (l_177 || func_109(l_178)))) | 0x7F53FFDE), l_177, p_97) != l_179)) ^ l_179))) ^ p_98))
        { /* block id: 103 */
            union U1 l_187 = {0x90BE2757};
            int32_t l_192 = 0;
            int32_t l_193 = 3;
            int32_t l_194 = 0x105A86EB;
            l_194 |= __builtin_clzll((l_171.f4 = ((uint16_t)(6U || (__builtin_ffsll(((l_192 |= (func_99((p_98 <= l_179), (l_190 = (!(((int16_t)((int32_t)(p_98 || (((l_187 , (l_171.f3 = (l_171.f1 = (l_177 != l_187.f0)))) > p_98) & func_105(((((uint16_t)p_97 << (uint16_t)l_187.f0) & 0x1D3E0DDA) & p_97), l_177, p_97))) % (int32_t)0x127BBD15) - (int16_t)l_187.f0) < p_98))), l_171.f2, l_191, p_98) | l_179)) & l_193)) || 4294967295U)) * (uint16_t)l_187.f0)));
            l_193 |= ((l_195 , (l_195.f1 = (l_195.f3 = l_195.f3))) , 0x90B9DDE5);
        }
        else
        { /* block id: 113 */
            int16_t l_196 = 1;
            l_195.f4 = (p_98 <= (l_196 | p_97));
            return l_195.f2;
        }
        l_190 |= 0x91EDA5D4;
    }
    return p_97;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_99(uint16_t  p_100, int32_t  p_101, int32_t  p_102, int32_t  p_103, int16_t  p_104)
{ /* block id: 89 */
    uint16_t l_160 = 0xABAF;
    int32_t l_161 = 0xB7CC63A2;
    int32_t l_162 = (-3);
    int32_t l_163 = 0xA9D40A94;
    int32_t l_164 = 2;
    uint32_t l_169 = 0x71A61B91;
    int32_t l_170 = 0xCA1C995B;
    l_170 = ((int32_t)(((uint16_t)((((int16_t)((l_160 >= (l_161 &= __builtin_ffs(l_160))) ^ p_100) >> (int16_t)2) | 0x5124) != p_103) >> (uint16_t)(((l_164 ^= (l_163 = (l_162 = p_104))) , (l_162 = 6)) , (((uint32_t)((int32_t)__builtin_popcount(l_162) - (int32_t)p_102) - (uint32_t)0xD7620052) , p_104))) > l_169) + (int32_t)p_100);
    return l_163;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_105(int32_t  p_106, int16_t  p_107, int16_t  p_108)
{ /* block id: 82 */
    int32_t l_145 = (-10);
    int32_t l_148 = (-10);
    int32_t l_149 = (-5);
    int32_t l_151 = 0x5F034421;
    int32_t l_152 = 0xA19E5FB7;
    uint16_t l_153 = 0xDAF6;
    l_153 = __builtin_ffsl(((((uint32_t)(((l_145 &= p_106) | (p_108 | p_106)) != (l_151 |= (((l_149 = __builtin_bswap64(((((uint16_t)(l_148 ^= 65535U) + (uint16_t)l_149) == 0x005CC3D6) , (!(l_149 , l_149))))) > p_108) >= p_106))) - (uint32_t)1U) ^ l_152) && p_107));
    return l_152;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_109(union U1  p_110)
{ /* block id: 60 */
    uint16_t l_114 = 0x621A;
    int32_t l_115 = 0xCEC1DFBC;
    int32_t l_132 = 0x5B45A7EA;
    struct S0 l_136 = {16,181,0,0,1851};
    struct S0 l_137 = {25,71,10,4,1115};
    l_132 = (((uint32_t)(l_114 > (l_115 = ((l_114 != p_110.f0) > p_110.f0))) - (uint32_t)(((int32_t)(l_114 < ((uint16_t)p_110.f0 >> (uint16_t)(((uint32_t)l_114 - (uint32_t)((uint16_t)(((uint32_t)((uint32_t)__builtin_clzl((l_114 , ((int16_t)((((uint16_t)p_110.f0 * (uint16_t)0xC5F5) != l_114) ^ 0xDF84) * (int16_t)l_114))) + (uint32_t)l_114) + (uint32_t)(-8)) || p_110.f0) * (uint16_t)0xCEE8)) <= 1U))) % (int32_t)l_114) , p_110.f0)) ^ p_110.f0);
    for (l_115 = 8; (l_115 != (-10)); l_115 -= 6)
    { /* block id: 65 */
        uint32_t l_135 = 0x738E283F;
        if (l_135)
            break;
        return l_135;
    }
    l_137 = (l_136 = l_136);
    if (p_110.f0)
    { /* block id: 71 */
        int16_t l_142 = 0x6F70;
        for (l_136.f3 = 0; (l_136.f3 < 23); l_136.f3 += 8)
        { /* block id: 74 */
            uint16_t l_140 = 0x43F3;
            int32_t l_141 = (-3);
            l_142 = (l_140 < (l_141 && p_110.f0));
            l_132 = l_141;
        }
    }
    else
    { /* block id: 78 */
        return l_137.f3;
    }
    return p_110.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 122
   depth: 1, occurrence: 25
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 25
breakdown:
   indirect level: 0, occurrence: 25
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 21
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 22
XXX times a single bitfield on RHS: 75

XXX max expression depth: 50
breakdown:
   depth: 1, occurrence: 110
   depth: 2, occurrence: 18
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 2
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1
   depth: 36, occurrence: 1
   depth: 50, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 497
XXX times a non-volatile is write: 159
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 106
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 38
   depth: 1, occurrence: 24
   depth: 2, occurrence: 16
   depth: 3, occurrence: 7
   depth: 4, occurrence: 7
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 22.5
XXX percentage an existing variable is used: 77.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

