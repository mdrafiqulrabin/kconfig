/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      642904484
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint16_t  f0;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_29(void);
static int32_t * func_35(int32_t * p_36, float  p_37);
static int32_t * func_38(uint32_t  p_39, uint16_t  p_40);
static const uint32_t  func_49(int32_t * p_50, struct S0  p_51);
inline static struct S0  func_53(const uint32_t  p_54, int32_t * p_55, uint16_t  p_56, int32_t * p_57);
inline static int32_t * func_58(uint16_t  p_59, int32_t  p_60, uint32_t  p_61, uint32_t  p_62, const struct S0  p_63);
static uint16_t  func_69(struct S0  p_70, uint16_t  p_71, int16_t  p_72);
inline static struct S0  func_73(int32_t * p_74, uint32_t  p_75, int32_t  p_76, uint16_t  p_77);
static uint32_t  func_83(struct S0  p_84, const uint16_t  p_85, uint32_t  p_86, uint32_t  p_87, int32_t * p_88);
static struct S0  func_91(int32_t * p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_32 = 0xDE0980DB;
    int32_t *l_33 = (void*)0;
    int32_t l_34 = (-1);
    float l_45 = 0xE.551B32p-76;
    float l_46 = 0xC.EB16E2p+60;
    int32_t *l_52 = &l_34;
    int32_t l_66 = 0xEA376659;
    const struct S0 l_190 = {0x1F5B};
    int32_t **l_532 = &l_52;
    int32_t *l_533 = &l_34;
    float l_536 = 0x5.7p-1;
    int16_t l_537 = 0x7FC9;
    l_34 = ((uint32_t)l_32 + (uint32_t)1U);
    (*l_532) = func_35(func_38(l_34, ((uint16_t)((uint16_t)(l_32 || (l_34 >= (((((uint16_t)(func_49(l_52, func_53((*l_52), func_58(((*l_52) && ((int16_t)l_66 >> (int16_t)12)), ((uint16_t)func_69(func_73(&l_34, (*l_52), (*l_52), (*l_52)), (*l_52), (*l_52)) << (uint16_t)(*l_52)), (*l_52), (*l_52), l_190), (*l_52), &l_34)) & (*l_52)) << (uint16_t)15) < 65535U) != (*l_52)) > (*l_52)))) << (uint16_t)5) - (uint16_t)(*l_52))), (*l_52));
    /* statement id: 344 */
    assert (l_52 == 0);
    (*l_533) = 0x540C17C1;
    for (l_32 = 10; (l_32 > 18); l_32++)
    { /* block id: 348 */
        (*l_532) = (*l_532);
    }
    return l_537;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_35(int32_t * p_36, float  p_37)
{ /* block id: 341 */
    uint16_t l_529 = 0x38B0;
    int32_t *l_531 = (void*)0;
    int32_t **l_530 = &l_531;
    (*l_530) = func_38(l_529, __builtin_clzll(l_529));
    return p_36;
    /* statement id: 343 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_38(uint32_t  p_39, uint16_t  p_40)
{ /* block id: 193 */
    struct S0 l_274 = {6U};
    struct S0 **l_290 = (void*)0;
    struct S0 *** const l_289 = &l_290;
    struct S0 *** const *l_288 = &l_289;
    int32_t l_294 = (-1);
    int32_t *l_293 = &l_294;
    const uint32_t l_295 = 0x51B0F9FA;
    int32_t *l_297 = &l_294;
    int32_t ***l_346 = (void*)0;
    int32_t l_355 = 0x2EC38D99;
    struct S0 *l_382 = &l_274;
    uint32_t l_438 = 0x867074C7;
    int32_t ****l_459 = (void*)0;
    int32_t *****l_458 = &l_459;
    const int32_t l_514 = 0;
    int16_t l_519 = 1;
    int32_t *l_523 = &l_355;
    int32_t *l_525 = &l_294;
    int32_t *l_527 = &l_294;
    int32_t *l_528 = (void*)0;
    if (p_39)
    { /* block id: 194 */
        int32_t l_281 = 0x0373C028;
        int32_t *l_280 = &l_281;
        uint32_t l_314 = 1U;
        struct S0 * const l_317 = &l_274;
        float l_348 = 0x1.Fp+1;
        const int32_t *l_351 = &l_281;
        const int32_t **l_350 = &l_351;
        const int32_t ***l_349 = &l_350;
        for (p_39 = 26; (p_39 < 42); p_39 += 8)
        { /* block id: 197 */
            struct S0 ***l_292 = &l_290;
            struct S0 ****l_291 = &l_292;
            int32_t l_296 = (-1);
            uint16_t l_302 = 0U;
            int32_t *l_319 = &l_296;
            uint32_t l_374 = 0xA2A62F15;
            struct S0 * const l_379 = &l_274;
            struct S0 * const *l_378 = &l_379;
            l_274 = l_274;
        }
    }
    else
    { /* block id: 239 */
        struct S0 *l_381 = &l_274;
        int32_t l_389 = (-6);
        int32_t *l_415 = &l_389;
        uint32_t l_426 = 0x4AC20B94;
        struct S0 *****l_481 = (void*)0;
        struct S0 l_488 = {8U};
        const int32_t l_491 = (-3);
        struct S0 *** const **l_503 = &l_288;
        struct S0 l_520 = {0xBCE6};
        float l_522 = 0x7.5p-1;
        float *l_521 = &l_522;
        int32_t *l_524 = &l_355;
        int32_t *l_526 = (void*)0;
    }
    return l_528;
    /* statement id: 340 */
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_49(int32_t * p_50, struct S0  p_51)
{ /* block id: 145 */
    int32_t l_208 = 0xDBF33FCB;
    int32_t *l_211 = &l_208;
    int32_t **l_212 = &l_211;
    struct S0 l_267 = {0x0948};
    float l_268 = 0x7.8p+1;
    float *l_269 = &l_268;
    (*l_212) = func_58(((*p_50) < (l_208 ^ l_208)), (((((func_83(p_51, __builtin_parity(p_51.f0), ((int16_t)p_51.f0 % (int16_t)1U), p_51.f0, l_211) >= (*l_211)) && (*l_211)) < 0U) && (*l_211)) && (*l_211)), p_51.f0, (*l_211), p_51);
    /* statement id: 146 */
    assert (l_211 == 0);
    for (l_208 = 0; (l_208 <= (-19)); l_208 -= 5)
    { /* block id: 149 */
        uint16_t l_217 = 0x52BB;
        int32_t l_218 = 0xBD1C9D4F;
        const struct S0 l_219 = {0xFE58};
        int32_t l_227 = 0xF04E7F97;
        uint32_t l_230 = 0xDA0BE558;
        struct S0 ** const *l_239 = (void*)0;
        struct S0 ** const **l_238 = &l_239;
        struct S0 ** const ***l_237 = &l_238;
        struct S0 l_243 = {1U};
        struct S0 *l_257 = &l_243;
        struct S0 **l_256 = &l_257;
        struct S0 ***l_255 = &l_256;
        struct S0 ****l_254 = &l_255;
        struct S0 *****l_253 = &l_254;
        (*l_212) = func_58((((int32_t)(*p_50) - (int32_t)p_51.f0) <= l_217), l_217, p_51.f0, l_218, l_219);
        /* statement id: 150 */
        assert (l_211 == 0);
        if ((*p_50))
        { /* block id: 151 */
            struct S0 l_221 = {0U};
            struct S0 *l_220 = &l_221;
            int32_t *l_222 = &l_218;
            struct S0 **l_223 = &l_220;
            (*l_222) = __builtin_ffs(__builtin_ffsl(((void*)0 != l_220)));
            if (__builtin_bswap64(p_51.f0))
            { /* block id: 153 */
                struct S0 ***l_224 = &l_223;
                int32_t l_231 = 0x19C9193D;
                (*l_224) = l_223;
                for (l_221.f0 = 16; (l_221.f0 == 21); l_221.f0 += 5)
                { /* block id: 157 */
                    int16_t l_232 = 0xF95B;
                    const struct S0 l_233 = {0x1533};
                    struct S0 ****l_234 = &l_224;
                    (*l_212) = func_58(l_227, (*l_222), ((uint32_t)p_51.f0 - (uint32_t)(*p_50)), ((func_83(func_91(func_58((l_217 && (func_69(p_51, p_51.f0, p_51.f0) ^ p_51.f0)), l_230, p_51.f0, l_218, l_219)), p_51.f0, l_231, p_51.f0, &l_218) || p_51.f0) >= l_232), l_233);
                    /* statement id: 158 */
                    assert (l_211 == 0);
                    (*l_234) = (void*)0;
                    /* statement id: 159 */
                    assert (l_224 == 0);
                    (*l_222) = (((*p_50) != func_83(p_51, p_51.f0, l_219.f0, p_51.f0, &l_218)) >= 0x68A6);
                    (*l_212) = p_50;
                    /* statement id: 161 */
                    //assert (l_211 == &l_34 || l_211 == &l_281 || l_211 == &l_294 || l_211 == &l_389);
                }
                /* facts after for loop */
                //assert (l_211 == &l_34 || l_211 == 0 || l_211 == &l_281 || l_211 == &l_294 || l_211 == &l_389);
                assert (l_224 == 0 || l_224 == &l_223);
                (*l_212) = l_222;
                /* statement id: 163 */
                assert (l_211 == &l_218);
            }
            else
            { /* block id: 164 */
                int16_t l_235 = 0xAB2A;
                struct S0 ** const ***l_236 = (void*)0;
                if (l_235)
                { /* block id: 165 */
                    uint32_t l_242 = 4294967295U;
                    int32_t *l_244 = &l_208;
                    float l_246 = (-0x1.8p+1);
                    float *l_245 = &l_246;
                    l_237 = l_236;
                    /* statement id: 166 */
                    assert (l_237 == 0);
                    (*l_245) = ((float)l_242 + (float)((p_51.f0 == p_51.f0) < func_83(l_243, p_51.f0, p_51.f0, (l_242 != (0xB660035E && (*p_50))), l_244)));
                }
                else
                { /* block id: 168 */
                    uint32_t l_252 = 0U;
                    for (l_227 = (-30); (l_227 != 21); l_227++)
                    { /* block id: 171 */
                        int32_t **** const l_249 = (void*)0;
                        int32_t ****l_251 = (void*)0;
                        int32_t *****l_250 = &l_251;
                        (*l_250) = l_249;
                        return p_51.f0;
                    }
                    if (l_252)
                        break;
                    (*l_222) = (&l_238 == l_253);
                }
                /* facts after branching */
                assert (l_237 == &l_238 || l_237 == 0);
                (*l_222) = (p_51.f0 < ((+0x1.2p-1) >= l_235));
            }
            /* facts after branching */
            assert (l_211 == 0 || l_211 == &l_218);
            assert (l_237 == &l_238 || l_237 == 0);
        }
        else
        { /* block id: 180 */
            struct S0 l_259 = {0x2AB6};
            (***l_255) = l_259;
            (*****l_253) = p_51;
        }
        /* facts after branching */
        assert (l_211 == 0 || l_211 == &l_218);
        assert (l_237 == &l_238 || l_237 == 0);
        (*l_212) = &l_218;
        /* statement id: 184 */
        assert (l_211 == &l_218);
    }
    /* facts after for loop */
    //assert (l_211 == dangling || l_211 == 0);
    (*l_269) = ((((-0x4.Ep-1) != ((((float)((float)p_51.f0 + (float)((p_51.f0 >= p_51.f0) > __builtin_ctzl(p_51.f0))) + (float)0x0.Ep+1) == (__builtin_ctzll((((int32_t)(0x99EC ^ (!(func_69(l_267, p_51.f0, p_51.f0) < (*p_50)))) % (int32_t)p_51.f0) == p_51.f0)) >= 0x4.C65940p-82)) >= p_51.f0)) < l_268) < p_51.f0);
    for (l_267.f0 = 0; (l_267.f0 > 37); l_267.f0 += 9)
    { /* block id: 189 */
        (*l_212) = p_50;
        /* statement id: 190 */
        //assert (l_211 == &l_34 || l_211 == &l_281 || l_211 == &l_294 || l_211 == &l_389);
    }
    /* facts after for loop */
    //assert (l_211 == &l_34 || l_211 == dangling || l_211 == 0 || l_211 == &l_281 || l_211 == &l_294 || l_211 == &l_389);
    return p_51.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_53(const uint32_t  p_54, int32_t * p_55, uint16_t  p_56, int32_t * p_57)
{ /* block id: 143 */
    struct S0 l_207 = {1U};
    return l_207;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_58(uint16_t  p_59, int32_t  p_60, uint32_t  p_61, uint32_t  p_62, const struct S0  p_63)
{ /* block id: 140 */
    const uint32_t l_193 = 0xF8DAC292;
    int32_t l_195 = 0;
    int32_t *l_194 = &l_195;
    int32_t *l_200 = &l_195;
    int32_t *l_201 = &l_195;
    int32_t *l_202 = &l_195;
    int32_t *l_203 = &l_195;
    int32_t *l_204 = &l_195;
    int32_t *l_205 = &l_195;
    int32_t *l_206 = (void*)0;
    (*l_194) = (0 > ((((uint16_t)(l_193 & (l_194 == (void*)0)) >> (uint16_t)10) <= p_63.f0) != ((uint16_t)((((*l_194) >= ((uint32_t)(0x59AEBFD9 >= 6U) - (uint32_t)0x86F3FE56)) == (*l_194)) && p_63.f0) >> (uint16_t)(*l_194))));
    return l_206;
    /* statement id: 142 */
    //assert (func_58_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_69(struct S0  p_70, uint16_t  p_71, int16_t  p_72)
{ /* block id: 113 */
    const int16_t l_155 = 0xDDBF;
    const struct S0 l_158 = {2U};
    const struct S0 *l_157 = &l_158;
    const struct S0 **l_156 = &l_157;
    int32_t l_160 = 0x2037B1C4;
    int32_t *l_159 = &l_160;
    struct S0 l_176 = {0U};
    int32_t l_182 = 0x98758D7F;
    if ((((uint16_t)(+(0x7DA69EDF || func_83(p_70, l_155, ((l_156 != &l_157) & l_155), l_158.f0, l_159))) >> (uint16_t)(*l_159)) && 0xD7CB))
    { /* block id: 114 */
        uint32_t l_161 = 0x40C85F22;
        struct S0 l_163 = {0x493B};
        struct S0 *l_162 = &l_163;
        (*l_162) = func_73(&l_160, p_72, l_161, (3 >= (*l_159)));
    }
    else
    { /* block id: 116 */
        uint32_t l_164 = 0xCCE31A55;
        int32_t *l_177 = &l_160;
        if (l_164)
        { /* block id: 117 */
            return l_164;
        }
        else
        { /* block id: 119 */
            int32_t *l_165 = &l_160;
            l_159 = l_165;
        }
        if ((((uint16_t)(((l_164 || (*l_159)) & ((uint16_t)((uint32_t)((((int32_t)p_70.f0 - (int32_t)(((int16_t)p_70.f0 - (int16_t)(*l_159)) | func_83(l_176, (*l_159), ((p_71 != p_71) >= p_70.f0), (*l_159), l_177))) || (*l_159)) != 0x8EF7) - (uint32_t)1) - (uint16_t)(-9))) >= (*l_177)) >> (uint16_t)14) <= (*l_177)))
        { /* block id: 122 */
            return p_71;
        }
        else
        { /* block id: 124 */
            int32_t **l_178 = &l_177;
            (*l_178) = l_177;
        }
        for (p_70.f0 = 17; (p_70.f0 != 35); p_70.f0++)
        { /* block id: 129 */
            int32_t **l_181 = &l_177;
            (*l_181) = (void*)0;
            /* statement id: 130 */
            assert (l_177 == 0);
        }
        /* facts after for loop */
        assert (l_177 == 0 || l_177 == &l_160);
    }
    if ((p_70.f0 <= l_182))
    { /* block id: 133 */
        int16_t l_183 = 0xE77A;
        (*l_159) = p_70.f0;
        return l_183;
    }
    else
    { /* block id: 136 */
        int32_t l_186 = 2;
        struct S0 *l_189 = &l_176;
        (*l_189) = func_73(&l_160, (func_83(p_70, p_71, ((*l_159) | (((int32_t)func_83(p_70, (*l_159), l_186, ((uint16_t)p_72 >> (uint16_t)((0xA75D && p_71) >= 0x7AC5C07F)), &l_160) - (int32_t)(*l_159)) ^ p_72)), (*l_159), &l_186) || l_186), p_71, (*l_159));
    }
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_73(int32_t * p_74, uint32_t  p_75, int32_t  p_76, uint16_t  p_77)
{ /* block id: 38 */
    int16_t l_80 = (-10);
    int32_t l_82 = 0x9DB3FA3C;
    int32_t *l_81 = &l_82;
    struct S0 l_89 = {65529U};
    int32_t l_90 = 0x10065160;
    struct S0 l_151 = {0xE343};
    if ((p_76 && (((uint32_t)l_80 - (uint32_t)((void*)0 != l_81)) > func_83(l_89, (__builtin_bswap32(p_76) || 0x7B2E), p_75, l_90, &l_82))))
    { /* block id: 97 */
        struct S0 l_143 = {65531U};
        struct S0 *l_145 = &l_143;
        struct S0 **l_144 = &l_145;
        (*l_81) = ((int32_t)1 - (int32_t)func_83(l_143, p_77, l_143.f0, p_77, &l_82));
        (*l_144) = &l_143;
    }
    else
    { /* block id: 100 */
        for (l_80 = 0; (l_80 > (-21)); l_80 -= 9)
        { /* block id: 103 */
            struct S0 l_148 = {0x5D42};
            return l_148;
        }
        for (l_82 = (-27); (l_82 > 13); l_82 += 1)
        { /* block id: 108 */
            if ((*l_81))
                break;
        }
    }
    return l_151;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_83(struct S0  p_84, const uint16_t  p_85, uint32_t  p_86, uint32_t  p_87, int32_t * p_88)
{ /* block id: 39 */
    int32_t *l_93 = (void*)0;
    struct S0 l_140 = {0U};
    struct S0 *l_139 = &l_140;
    (*l_139) = func_91(l_93);
    return p_84.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_91(int32_t * p_92)
{ /* block id: 40 */
    uint32_t l_94 = 4294967292U;
    struct S0 l_130 = {0x96E7};
    if (l_94)
    { /* block id: 41 */
        uint32_t l_97 = 0x3144D991;
        int32_t l_99 = 0x52F506A5;
        int32_t *l_98 = &l_99;
        for (l_94 = 17; (l_94 == 19); l_94++)
        { /* block id: 44 */
            int32_t **l_100 = &l_98;
            l_97 = l_94;
            (*l_100) = l_98;
        }
    }
    else
    { /* block id: 48 */
        int32_t l_102 = 0x5B4C0DD7;
        int32_t *l_101 = &l_102;
        const int32_t *l_104 = &l_102;
        const int32_t **l_103 = &l_104;
        struct S0 l_105 = {0U};
        (*l_103) = l_101;
        if (l_94)
        { /* block id: 50 */
            (*l_101) = (-3);
        }
        else
        { /* block id: 52 */
            struct S0 *l_106 = (void*)0;
            struct S0 *l_107 = &l_105;
            int32_t l_116 = 0x1E91BE67;
            (*l_107) = l_105;
        }
        return l_130;
    }
    return l_130;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 136
   depth: 1, occurrence: 31
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 20, occurrence: 3
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 144

XXX times a variable address is taken: 143
XXX times a pointer is dereferenced on RHS: 103
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 89
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 3
   depth: 3, occurrence: 1
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 450

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 375
   level: 2, occurrence: 35
   level: 3, occurrence: 26
   level: 4, occurrence: 14
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 64
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 27.1
XXX average alias set size: 1.29

XXX times a non-volatile is read: 660
XXX times a non-volatile is write: 228
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 79
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 21
   depth: 2, occurrence: 16
   depth: 3, occurrence: 5
   depth: 4, occurrence: 9
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 19.7
XXX percentage an existing variable is used: 80.3
********************* end of statistics **********************/

