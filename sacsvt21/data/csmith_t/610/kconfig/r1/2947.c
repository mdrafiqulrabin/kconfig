/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1700531344
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 22;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
inline static int16_t  func_4(uint16_t  p_5, const uint64_t  p_6, uint32_t  p_7);
static int16_t  func_12(int16_t  p_13, uint8_t  p_14, int8_t  p_15);
static int32_t * func_25(int16_t  p_26, int32_t ** p_27, uint32_t  p_28);
inline static uint64_t  func_31(uint8_t  p_32, int32_t * const * p_33, uint16_t  p_34, int32_t * p_35);
inline static const uint64_t  func_36(int32_t * p_37, int64_t  p_38, uint32_t  p_39);
inline static int32_t * func_40(int32_t * p_41, int32_t * p_42);
static int32_t * func_43(uint16_t  p_44, const uint16_t  p_45, int8_t  p_46, int32_t ** p_47);
static int8_t  func_49(uint32_t  p_50, uint16_t  p_51, uint32_t  p_52, int16_t  p_53, int32_t ** p_54);
static uint16_t  func_57(const int32_t * p_58, struct S0  p_59, float  p_60, int8_t  p_61, int32_t * const  p_62);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_11 = 1UL;
    int32_t l_18 = (-5L);
    int8_t l_495 = (-1L);
    uint8_t l_505 = 0x04L;
    struct S0 l_530 = {-913};
    struct S0 *l_529 = &l_530;
    int32_t *l_565[9] = {&l_18,&l_18,&l_18,&l_18,&l_18,&l_18,&l_18,&l_18,&l_18};
    uint64_t l_640 = 18446744073709551615UL;
    int32_t * const *l_659 = &l_565[3];
    int32_t * const * const *l_658 = &l_659;
    uint64_t l_660 = 0UL;
    int8_t l_665 = 0xFDL;
    float l_703 = 0x5.1p+1;
    float *l_702 = &l_703;
    float **l_701 = &l_702;
    uint64_t l_717 = 18446744073709551615UL;
    uint8_t l_720 = 0xFEL;
    uint8_t l_723 = 1UL;
    uint32_t l_725 = 0xC8F2F155L;
    int32_t l_729 = 0L;
    int32_t l_730[9] = {0x509C0E78L,(-1L),0x509C0E78L,0x509C0E78L,(-1L),0x509C0E78L,0x509C0E78L,(-1L),0x509C0E78L};
    int i;
    if ((safe_div_func_int16_t_s_s(func_4((safe_lshift_func_int16_t_s_s((!l_11), func_12(l_11, (safe_lshift_func_int8_t_s_u(l_11, 3)), l_18))), (safe_lshift_func_uint16_t_u_u((+0x5DL), 7)), l_495), (((safe_mul_func_int16_t_s_s((safe_lshift_func_uint8_t_u_s((safe_add_func_uint32_t_u_u(l_18, l_495)), l_18)), l_18)) < l_505) && l_495))))
    { /* block id: 282 */
        int32_t l_508[4][5] = {{0xE3F1211DL,0xE3F1211DL,0xE3F1211DL,0xE3F1211DL,0xE3F1211DL},{(-8L),0x406FBD9CL,(-8L),0x406FBD9CL,(-8L)},{0xE3F1211DL,0xE3F1211DL,0xE3F1211DL,0xE3F1211DL,0xE3F1211DL},{(-8L),0x406FBD9CL,(-8L),0x406FBD9CL,(-8L)}};
        float *** const l_509 = (void*)0;
        struct S0 l_513 = {1117};
        struct S0 *l_512 = &l_513;
        struct S0 **l_511[1][10] = {{&l_512,&l_512,&l_512,&l_512,&l_512,&l_512,&l_512,&l_512,&l_512,&l_512}};
        struct S0 *** const l_510 = &l_511[0][4];
        uint16_t l_537 = 0x3294L;
        int32_t l_545 = 9L;
        int16_t l_563[3];
        uint8_t l_564[4] = {255UL,255UL,255UL,255UL};
        uint16_t l_625[4][5][6] = {{{0x401EL,0x325FL,0xD429L,0x325FL,0x401EL,0xD429L},{0x325FL,0x401EL,0xD429L,0xA805L,0xA805L,0xD429L},{0xA805L,0xA805L,0xD429L,0x401EL,0x325FL,0xD429L},{0x401EL,0x325FL,0xD429L,0x325FL,0x401EL,0xD429L},{0x325FL,0x401EL,0xD429L,0xA805L,0xA805L,0xD429L}},{{0xA805L,0xA805L,0xD429L,0x401EL,0x325FL,0xD429L},{0x401EL,0x325FL,0xD429L,0x325FL,0x401EL,0xD429L},{0x325FL,0x401EL,0xD429L,0xA805L,0xA805L,0xD429L},{0xA805L,0xA805L,0xD429L,0x401EL,0x325FL,0xD429L},{0x401EL,0x325FL,0xD429L,0x325FL,0x401EL,0xD429L}},{{0x325FL,0x401EL,0xD429L,0xA805L,0xA805L,0xD429L},{0xA805L,0xA805L,0xD429L,0x401EL,0x325FL,0xD429L},{0x401EL,0x325FL,0xD429L,0x325FL,0x401EL,0xD429L},{0x325FL,0x401EL,0xD429L,0xA805L,0xA805L,0xD429L},{0xA805L,0xA805L,0xD429L,0x401EL,0x325FL,0xD429L}},{{0x401EL,0x325FL,0xD429L,0x325FL,0x401EL,0xD429L},{0x325FL,0x401EL,0xD429L,0xA805L,0xA805L,0xD429L},{0xA805L,0xA805L,0xD429L,0x401EL,0x325FL,0xD429L},{0x401EL,0x325FL,0xD429L,0x325FL,0x401EL,0xD429L},{0x325FL,0x401EL,0xD429L,0xA805L,0xA805L,0xD429L}}};
        float l_655[9] = {0xD.2BB9EBp-34,0xD.2BB9EBp-34,0x2.05F5EAp+80,0xD.2BB9EBp-34,0xD.2BB9EBp-34,0x2.05F5EAp+80,0xD.2BB9EBp-34,0xD.2BB9EBp-34,0x2.05F5EAp+80};
        float *l_654 = &l_655[3];
        float **l_653 = &l_654;
        float ***l_652 = &l_653;
        float ****l_651 = &l_652;
        float ***** const l_650[2] = {&l_651,&l_651};
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_563[i] = 0xE5DBL;
        if ((safe_rshift_func_uint8_t_u_u((l_508[2][1] && (l_509 == (void*)0)), ((l_510 == (void*)0) && (safe_mod_func_int32_t_s_s(l_508[2][1], (safe_rshift_func_int8_t_s_s((safe_add_func_uint16_t_u_u((safe_div_func_int32_t_s_s(0L, (-1L))), l_505)), 2))))))))
        { /* block id: 283 */
            struct S0 * const *l_531 = &l_512;
            for (l_11 = (-22); (l_11 < 29); l_11 = safe_add_func_int8_t_s_s(l_11, 1))
            { /* block id: 286 */
                struct S0 l_524 = {-335};
                for (l_505 = 0; (l_505 <= 3); l_505 += 1)
                { /* block id: 289 */
                    int32_t *l_528 = &l_508[0][1];
                    struct S0 * const *l_532 = &l_512;
                    (***l_510) = (***l_510);
                    (***l_510) = l_524;
                    for (l_495 = 3; (l_495 >= 0); l_495 -= 1)
                    { /* block id: 294 */
                        int32_t *l_525 = &l_508[2][1];
                        int32_t **l_526 = (void*)0;
                        int32_t **l_527 = &l_525;
                        (*l_527) = l_525;
                        (*l_527) = func_40(l_528, &l_508[2][1]);
                        l_529 = (void*)0;
                        /* statement id: 297 */
                        assert (l_529 == 0);
                        l_532 = l_531;
                    }
                }
                /* facts after for loop */
                assert (l_529 == 0 || l_529 == &l_530);
                return l_524.f0;
            }
        }
        else
        { /* block id: 303 */
            const int8_t l_540 = 0x94L;
            float l_550 = 0x0.Cp+1;
            float *l_549 = &l_550;
            float **l_548[9][7] = {{&l_549,&l_549,&l_549,&l_549,(void*)0,&l_549,(void*)0},{&l_549,(void*)0,(void*)0,&l_549,&l_549,&l_549,&l_549},{(void*)0,&l_549,&l_549,&l_549,&l_549,&l_549,&l_549},{&l_549,(void*)0,&l_549,&l_549,(void*)0,&l_549,&l_549},{&l_549,(void*)0,&l_549,(void*)0,&l_549,&l_549,(void*)0},{&l_549,&l_549,(void*)0,&l_549,&l_549,&l_549,(void*)0},{(void*)0,(void*)0,&l_549,&l_549,&l_549,&l_549,&l_549},{&l_549,&l_549,&l_549,&l_549,&l_549,&l_549,&l_549},{&l_549,(void*)0,(void*)0,&l_549,&l_549,&l_549,&l_549}};
            float ***l_547 = &l_548[6][2];
            float ****l_546 = &l_547;
            int32_t *l_557 = &l_508[0][2];
            int32_t **l_556[1];
            int i, j;
            for (i = 0; i < 1; i++)
                l_556[i] = &l_557;
            (*l_549) = (((safe_sub_func_float_f_f((safe_add_func_float_f_f(l_495, (0x3.60AD40p-63 >= l_537))), (l_508[2][1] != (safe_sub_func_float_f_f((0xD.733126p-73 != l_540), (((safe_add_func_float_f_f(((safe_div_func_float_f_f(l_545, (l_546 != (void*)0))) != 0x3.66B382p+34), l_513.f0)) < l_495) >= l_540)))))) == 0x8.A0385Ep+91) != l_540);
            l_565[5] = func_25(((safe_div_func_int64_t_s_s((safe_unary_minus_func_int64_t_s(l_540)), (safe_rshift_func_uint8_t_u_u(l_18, 5)))) >= 18446744073709551609UL), l_556[0], (((l_505 <= (((-3L) >= (safe_unary_minus_func_int32_t_s(((l_18 & (*l_557)) == (safe_rshift_func_uint8_t_u_s(((safe_mul_func_int8_t_s_s(l_508[2][1], l_537)) & l_513.f0), l_563[0])))))) != (*l_557))) > l_564[1]) != 6L));
            /* statement id: 305 */
            //assert (l_557 == dangling || l_557 == 0);
        }
        for (l_495 = 0; (l_495 == (-30)); --l_495)
        { /* block id: 309 */
            int16_t l_571[5][10][3] = {{{(-3L),0x82F7L,8L},{0xC237L,0xD160L,1L},{0x82CBL,0x95ECL,0xBCA8L},{0xD160L,0xF2B8L,7L},{9L,7L,0x82F7L},{0x1ABEL,3L,0x82F7L},{1L,0x18E1L,7L},{0xA42CL,0xBCA8L,0xBCA8L},{8L,0x1ABEL,1L},{3L,(-1L),8L}},{{1L,(-1L),0x52B2L},{(-5L),0xA42CL,0x6DE3L},{1L,(-1L),0x740DL},{1L,(-1L),0x3D5AL},{1L,0x1ABEL,0xD160L},{0x95ECL,0xBCA8L,0x1ABEL},{0x52B2L,0x18E1L,1L},{(-1L),3L,(-1L)},{(-1L),7L,0x95ECL},{0x52B2L,0xF2B8L,9L}},{{0x95ECL,0x95ECL,1L},{1L,0xD160L,(-3L)},{1L,0x82F7L,1L},{1L,0xA94DL,0x82CBL},{(-5L),1L,1L},{1L,(-3L),(-3L)},{3L,0x52B2L,1L},{8L,(-1L),9L},{0xA42CL,8L,0x95ECL},{1L,1L,(-1L)}},{{0x1ABEL,1L,1L},{9L,8L,0x1ABEL},{0xD160L,(-1L),0xD160L},{0x82CBL,0x52B2L,0x3D5AL},{0xC237L,(-3L),0x740DL},{(-3L),1L,0x6DE3L},{0x82F7L,0xA94DL,0x52B2L},{(-3L),0x82F7L,8L},{0xC237L,0xD160L,1L},{0x82CBL,0x95ECL,0xBCA8L}},{{0xD160L,0xF2B8L,7L},{9L,7L,0x82F7L},{0x1ABEL,3L,0x82F7L},{1L,0x18E1L,7L},{0xA42CL,0xBCA8L,0xBCA8L},{8L,0x1ABEL,1L},{3L,(-1L),8L},{1L,(-1L),0x52B2L},{(-5L),0xA42CL,0x6DE3L},{1L,(-1L),0x740DL}}};
            struct S0 **l_604 = &l_529;
            float **l_615 = (void*)0;
            int32_t l_626 = (-1L);
            int32_t l_642 = 0x9DE9E254L;
            float ***l_649 = &l_615;
            float ****l_648 = &l_649;
            float **** const *l_647 = &l_648;
            int32_t l_678[7][10][3];
            uint8_t l_683 = 0x08L;
            int32_t **l_686 = &l_565[1];
            int i, j, k;
            for (i = 0; i < 7; i++)
            {
                for (j = 0; j < 10; j++)
                {
                    for (k = 0; k < 3; k++)
                        l_678[i][j][k] = 0x62680E86L;
                }
            }
            for (l_18 = 0; (l_18 > 19); l_18++)
            { /* block id: 312 */
                uint8_t l_570 = 247UL;
                uint32_t l_595 = 0x535950E5L;
                const uint32_t l_596 = 0UL;
                int32_t l_685 = 0x6C83002AL;
                if (l_570)
                { /* block id: 313 */
                    int32_t l_580 = 0xAADC9CFDL;
                    l_565[5] = &l_508[2][1];
                    for (l_537 = 0; (l_537 <= 3); l_537 += 1)
                    { /* block id: 317 */
                        uint32_t l_585 = 0x962ACFE7L;
                        float *** const *l_594 = (void*)0;
                        int32_t l_597 = 0xD4E597F0L;
                        if (l_571[4][5][0])
                            break;
                        (***l_510) = (*l_529);
                        l_597 = (safe_add_func_float_f_f((((safe_add_func_float_f_f(((0x5.7p-1 <= (safe_div_func_float_f_f((((safe_mul_func_float_f_f((l_580 != (safe_add_func_float_f_f((safe_div_func_float_f_f((l_585 != (((safe_div_func_float_f_f((0x2.96DCF8p+91 > (safe_div_func_float_f_f((safe_div_func_float_f_f(((void*)0 != &l_530), ((((l_545 < ((safe_sub_func_float_f_f(((l_563[0] <= ((void*)0 != l_594)) <= l_595), 0xB.01897Bp+79)) > l_564[1])) != (-0x9.3p-1)) == l_570) != l_580))), l_580))), l_580)) > l_585) > l_580)), l_585)), l_508[2][1]))), (-0x5.1p+1))) > l_571[3][8][0]) < l_585), l_585))) <= l_585), l_571[4][1][0])) <= l_596) <= 0x0.Dp-1), l_571[4][5][0]));
                    }
                    if ((~(l_571[3][5][1] || (0UL != l_595))))
                    { /* block id: 322 */
                        uint16_t l_601 = 0x35CBL;
                        l_601 = 0x0.Bp+1;
                        l_513.f0 = (-0x1.9p+1);
                    }
                    else
                    { /* block id: 325 */
                        int32_t **l_602 = (void*)0;
                        int32_t **l_603 = &l_565[6];
                        (*l_603) = &l_18;
                        if (l_571[0][8][0])
                            continue;
                        (*l_510) = l_604;
                    }
                    if (l_580)
                        break;
                }
                else
                { /* block id: 331 */
                    const uint16_t l_611 = 0xE3C3L;
                    int32_t l_627 = 0xD548A9DCL;
                    struct S0 **l_664 = &l_529;
                    if ((safe_mul_func_int16_t_s_s((253UL & (((&l_565[6] != (void*)0) >= l_595) <= (safe_lshift_func_int16_t_s_s((safe_lshift_func_uint8_t_u_s(l_611, ((((~(safe_add_func_int16_t_s_s((l_615 != (void*)0), (~(!(safe_lshift_func_int8_t_s_s((-1L), (((safe_sub_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((!l_611), 4294967295UL)), l_625[0][2][2])) & l_626) || l_596)))))))) == l_564[1]) ^ l_596) ^ l_611))), l_611)))), 0L)))
                    { /* block id: 332 */
                        l_627 = 0x4D06275DL;
                    }
                    else
                    { /* block id: 334 */
                        int8_t l_641 = 0x60L;
                        if (l_571[4][5][0])
                            break;
                        l_642 = ((safe_lshift_func_uint16_t_u_s((0xA36D73A02E538EF2LL == (safe_div_func_uint64_t_u_u((safe_mod_func_int64_t_s_s(((((safe_add_func_uint8_t_u_u((l_611 && l_596), ((l_626 > ((safe_mod_func_int8_t_s_s(l_611, ((((safe_sub_func_int64_t_s_s((l_627 ^ (-2L)), l_571[4][5][0])) | ((l_596 != 0xD0L) <= l_640)) ^ l_627) || l_595))) < 0xAAL)) != 0x0DL))) != l_641) | l_641) & l_545), l_611)), l_596))), l_571[4][5][0])) != l_641);
                    }
                    if ((((safe_add_func_int32_t_s_s((safe_lshift_func_int8_t_s_u(l_642, l_563[0])), (l_647 == l_650[0]))) < (((safe_rshift_func_int8_t_s_s(l_595, (((void*)0 == l_658) ^ (-1L)))) || l_626) || l_660)) || l_611))
                    { /* block id: 338 */
                        uint64_t l_661 = 0x61080B7E39FFCE45LL;
                        int32_t **l_662 = &l_565[5];
                        struct S0 **l_663 = (void*)0;
                        if (l_661)
                            break;
                        (*l_662) = &l_508[2][1];
                        l_665 = (l_663 != l_664);
                    }
                    else
                    { /* block id: 342 */
                        int8_t l_675 = (-9L);
                        l_685 = (safe_sub_func_uint8_t_u_u((safe_sub_func_uint8_t_u_u(l_625[2][1][1], (!(safe_mul_func_uint16_t_u_u(0xE6B7L, (((+((!l_675) > (safe_rshift_func_int16_t_s_s(l_678[1][0][0], 4)))) >= (safe_sub_func_uint64_t_u_u((((safe_sub_func_int16_t_s_s((((l_683 > ((void*)0 != &l_651)) && 0x8271L) != (+(-1L))), l_596)) <= l_595) ^ l_563[0]), l_508[3][1]))) == l_545)))))), l_675));
                    }
                }
            }
            /* facts after for loop */
            //assert (l_511[0][0] == &l_529 || l_511[0][0] == &l_512);
            //assert ((l_565[0] >= &l_508[0][0] && l_565[0] <= &l_508[3][4]) || l_565[0] == 0 || l_565[0] == &l_18);
            (*l_686) = (**l_658);
            return l_513.f0;
        }
    }
    else
    { /* block id: 350 */
        uint16_t l_699 = 0x1747L;
        int32_t *l_705[1];
        int32_t l_719 = 1L;
        int64_t l_724 = 1L;
        int16_t l_728[9] = {0x9DD5L,(-6L),0x9DD5L,0x9DD5L,(-6L),0x9DD5L,0x9DD5L,(-6L),0x9DD5L};
        int i;
        for (i = 0; i < 1; i++)
            l_705[i] = &l_18;
        for (l_660 = 0; (l_660 >= 22); l_660 = safe_add_func_uint8_t_u_u(l_660, 9))
        { /* block id: 353 */
            struct S0 **l_693 = &l_529;
            const int32_t *l_696 = (void*)0;
            const int32_t **l_695 = &l_696;
            int32_t **l_704[5];
            int i;
            for (i = 0; i < 5; i++)
                l_704[i] = &l_565[6];
            for (l_665 = 0; (l_665 < 17); ++l_665)
            { /* block id: 356 */
                struct S0 **l_694 = (void*)0;
                float l_698 = 0xA.146954p-92;
                float *l_697 = &l_698;
                int32_t l_700 = 0xB8F4B44EL;
                float *** const l_709 = &l_701;
                uint8_t l_718 = 0xE9L;
                (*l_697) = (safe_mul_func_float_f_f((l_693 != l_694), ((void*)0 != l_695)));
            }
            if (l_719)
                break;
        }
        l_729 = ((l_720 != (0x19L ^ (safe_div_func_int64_t_s_s(l_723, l_724)))) > (l_725 | ((((safe_sub_func_int32_t_s_s(0xE04CF280L, 1UL)) != 247UL) && l_728[5]) < 0x0FL)));
    }
    return l_730[2];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_4(uint16_t  p_5, const uint64_t  p_6, uint32_t  p_7)
{ /* block id: 279 */
    int32_t l_497 = (-9L);
    int32_t *l_496[2];
    int32_t **l_498 = (void*)0;
    int i;
    for (i = 0; i < 2; i++)
        l_496[i] = &l_497;
    l_496[0] = l_496[0];
    return p_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_12(int16_t  p_13, uint8_t  p_14, int8_t  p_15)
{ /* block id: 1 */
    int32_t l_20[7] = {1L,1L,1L,1L,1L,1L,1L};
    int32_t * const l_19 = &l_20[5];
    int32_t *l_22 = &l_20[5];
    int32_t **l_21 = &l_22;
    struct S0 l_63[5][9] = {{{1611},{956},{-1885},{-787},{-283},{1735},{-283},{-787},{-1885}},{{-1885},{-1885},{-1470},{619},{340},{956},{619},{-283},{619}},{{-1470},{-855},{1859},{1859},{-855},{-1470},{-787},{1611},{-1885}},{{-283},{-1963},{1735},{-1885},{-855},{-855},{-1885},{1735},{-1963}},{{-855},{340},{-1470},{956},{-803},{-1963},{-787},{-787},{-1963}}};
    int8_t l_70 = 1L;
    int32_t *l_169[9] = {&l_20[4],&l_20[0],&l_20[4],&l_20[0],&l_20[4],&l_20[0],&l_20[4],&l_20[0],&l_20[4]};
    int32_t l_477 = (-6L);
    int i, j;
    (*l_21) = l_19;
    for (p_15 = 2; (p_15 == (-29)); --p_15)
    { /* block id: 5 */
        int32_t *l_48 = &l_20[2];
        int32_t l_397 = (-1L);
        struct S0 *l_479 = &l_63[0][3];
    }
    return p_14;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_25(int16_t  p_26, int32_t ** p_27, uint32_t  p_28)
{ /* block id: 255 */
    struct S0 l_430 = {1270};
    struct S0 *l_431[1];
    struct S0 l_432 = {-1752};
    int32_t l_434 = (-2L);
    int32_t *l_433[2][8][5] = {{{(void*)0,(void*)0,&l_434,(void*)0,(void*)0},{&l_434,&l_434,&l_434,&l_434,(void*)0},{(void*)0,&l_434,&l_434,(void*)0,&l_434},{(void*)0,&l_434,&l_434,&l_434,(void*)0},{&l_434,(void*)0,&l_434,&l_434,(void*)0},{(void*)0,&l_434,&l_434,&l_434,&l_434},{(void*)0,(void*)0,&l_434,(void*)0,(void*)0},{&l_434,&l_434,&l_434,&l_434,(void*)0}},{{(void*)0,&l_434,&l_434,(void*)0,&l_434},{(void*)0,&l_434,&l_434,&l_434,(void*)0},{&l_434,(void*)0,&l_434,&l_434,(void*)0},{(void*)0,&l_434,&l_434,&l_434,&l_434},{(void*)0,(void*)0,&l_434,(void*)0,(void*)0},{&l_434,&l_434,&l_434,&l_434,(void*)0},{(void*)0,&l_434,&l_434,(void*)0,&l_434},{(void*)0,&l_434,&l_434,&l_434,(void*)0}}};
    float l_436 = 0x4.7p+1;
    float *l_435[1];
    int64_t l_437 = 0xF3164F34E5C46421LL;
    uint8_t l_450 = 1UL;
    int32_t l_451 = 0L;
    int32_t *l_452 = &l_434;
    int32_t *l_453 = (void*)0;
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_431[i] = &l_430;
    for (i = 0; i < 1; i++)
        l_435[i] = &l_436;
    l_432 = l_430;
    (*p_27) = l_433[1][5][3];
    /* statement id: 257 */
    //assert (l_22 == &l_434 || l_22 == 0);
    l_437 = p_28;
    (*p_27) = func_43(p_28, p_26, ((-1L) >= (safe_mul_func_int8_t_s_s(((p_26 || ((safe_rshift_func_int8_t_s_u((((safe_add_func_uint16_t_u_u(p_28, (safe_mod_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(0x15EFL, p_28)), p_28)))) <= 0UL) <= p_28), p_26)) > p_26)) || l_450), l_451))), p_27);
    return l_453;
    /* statement id: 260 */
    //assert (l_22 == dangling || l_22 == 0);
    //assert (func_25_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_31(uint8_t  p_32, int32_t * const * p_33, uint16_t  p_34, int32_t * p_35)
{ /* block id: 252 */
    struct S0 l_427 = {1013};
    struct S0 *l_426 = &l_427;
    struct S0 **l_425 = &l_426;
    const struct S0 **l_429[2];
    const struct S0 ***l_428 = &l_429[1];
    int i;
    for (i = 0; i < 2; i++)
        l_429[i] = (void*)0;
    (*l_428) = l_425;
    /* statement id: 253 */
    //assert (l_429[0] == &l_426 || l_429[0] == 0);
    return p_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint64_t  func_36(int32_t * p_37, int64_t  p_38, uint32_t  p_39)
{ /* block id: 243 */
    int32_t l_418 = 0L;
    int32_t *l_417 = &l_418;
    int32_t **l_416 = &l_417;
    int32_t ***l_415 = &l_416;
    struct S0 l_419 = {870};
    struct S0 *l_423[8] = {&l_419,&l_419,&l_419,&l_419,&l_419,&l_419,&l_419,&l_419};
    struct S0 l_424 = {-451};
    int i;
    for (p_39 = 0; (p_39 <= 11); p_39++)
    { /* block id: 246 */
        int32_t l_414 = (-6L);
        const int32_t *l_413 = &l_414;
        const int32_t ** const l_412[6][9] = {{&l_413,&l_413,(void*)0,(void*)0,&l_413,&l_413,(void*)0,(void*)0,&l_413},{&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413},{&l_413,(void*)0,(void*)0,&l_413,&l_413,(void*)0,(void*)0,&l_413,&l_413},{&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413},{&l_413,&l_413,(void*)0,(void*)0,&l_413,&l_413,(void*)0,(void*)0,&l_413},{&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413,&l_413}};
        const int32_t ** const *l_411[1][4] = {{&l_412[0][1],&l_412[0][1],&l_412[0][1],&l_412[0][1]}};
        struct S0 *l_420 = (void*)0;
        struct S0 *l_421 = (void*)0;
        struct S0 l_422 = {895};
        int i, j;
        (***l_415) = (p_38 >= ((safe_lshift_func_int8_t_s_u((safe_rshift_func_int8_t_s_u((safe_add_func_int32_t_s_s(((18446744073709551609UL && (9L <= (+0x559AC1A0D15A3745LL))) >= (safe_mod_func_uint32_t_u_u((l_411[0][2] == &l_412[1][5]), (*p_37)))), 0x447AFBABL)), (&l_412[0][1] == l_415))), p_38)) >= 0x197F9CA6L));
        l_422 = l_419;
    }
    l_424 = l_419;
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_40(int32_t * p_41, int32_t * p_42)
{ /* block id: 78 */
    int16_t l_170[5][1];
    int32_t l_171[9][2][9];
    float l_182 = 0xD.F02422p+88;
    float *l_181 = &l_182;
    struct S0 l_187 = {-1348};
    struct S0 *l_186 = &l_187;
    int32_t *l_190 = &l_171[8][1][8];
    int32_t **l_189 = &l_190;
    int32_t ** const l_203 = &l_190;
    const int8_t l_228 = 0x12L;
    float * const *l_234 = (void*)0;
    float * const **l_233 = &l_234;
    int64_t l_367 = 0L;
    float l_374 = 0x3.Ap+1;
    int i, j, k;
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 1; j++)
            l_170[i][j] = (-1L);
    }
    for (i = 0; i < 9; i++)
    {
        for (j = 0; j < 2; j++)
        {
            for (k = 0; k < 9; k++)
                l_171[i][j][k] = 0x1F99661AL;
        }
    }
    for (l_171[0][1][1] = 0; (l_171[0][1][1] <= 0); l_171[0][1][1] += 1)
    { /* block id: 81 */
        int32_t l_172 = 0xE523DBDAL;
        float *l_183 = &l_182;
        float **l_215[5][3] = {{&l_183,(void*)0,&l_181},{&l_183,&l_183,&l_183},{&l_183,&l_183,&l_183},{(void*)0,&l_181,&l_183},{&l_183,&l_183,&l_183}};
        float ** const *l_214 = &l_215[1][0];
        int32_t * const * const l_216 = (void*)0;
        int32_t **l_239[5];
        struct S0 *l_247 = (void*)0;
        uint8_t l_290 = 0x3DL;
        struct S0 l_311 = {349};
        uint16_t l_355 = 0UL;
        int i, j;
        for (i = 0; i < 5; i++)
            l_239[i] = &l_190;
        for (l_172 = 0; (l_172 >= 0); l_172 -= 1)
        { /* block id: 84 */
            int32_t l_173 = 0x33B60DBCL;
            struct S0 *l_188 = (void*)0;
            float **l_207 = &l_181;
            for (l_173 = 0; (l_173 <= 0); l_173 += 1)
            { /* block id: 87 */
                int32_t **l_217[5];
                int i, j;
                for (i = 0; i < 5; i++)
                    l_217[i] = &l_190;
                if ((safe_div_func_uint8_t_u_u((p_42 != p_41), l_170[(l_173 + 4)][l_171[0][1][1]])))
                { /* block id: 88 */
                    int32_t l_176 = 0x1062BF17L;
                    int i, j;
                    for (l_176 = 0; (l_176 >= 0); l_176 -= 1)
                    { /* block id: 91 */
                        int i, j;
                        (*l_189) = func_43((safe_lshift_func_uint8_t_u_u((l_170[(l_173 + 4)][l_171[0][1][1]] <= ((l_173 && ((p_42 == (void*)0) <= ((l_173 == (l_181 != l_183)) < (safe_lshift_func_int8_t_s_s(((l_186 != l_188) >= (-9L)), 7))))) != (-6L))), 1)), l_173, l_170[(l_173 + 4)][l_171[0][1][1]], l_189);
                    }
                    (*p_42) = l_170[(l_171[0][1][1] + 3)][l_172];
                }
                else
                { /* block id: 95 */
                    int32_t l_191 = 0xA5E03110L;
                    float **l_193[2][3];
                    float ***l_192 = &l_193[1][1];
                    int32_t **l_196 = &l_190;
                    int i, j;
                    for (i = 0; i < 2; i++)
                    {
                        for (j = 0; j < 3; j++)
                            l_193[i][j] = &l_183;
                    }
                    (*p_42) = l_170[(l_173 + 1)][l_173];
                    for (l_191 = 0; (l_191 >= 0); l_191 -= 1)
                    { /* block id: 99 */
                        int i, j;
                        if (l_170[(l_172 + 4)][l_171[0][1][1]])
                            break;
                    }
                    (*l_192) = (void*)0;
                    /* statement id: 102 */
                    //assert (l_193[0][0] == 0 || l_193[0][0] == &l_183);
                    (*l_196) = func_43((safe_rshift_func_int16_t_s_u(l_170[(l_173 + 4)][l_171[0][1][1]], 1)), l_170[(l_173 + 4)][l_171[0][1][1]], l_172, l_196);
                }
                if (l_173)
                { /* block id: 105 */
                    float l_198 = 0x0.Ep+1;
                    struct S0 *l_205 = &l_187;
                    int32_t l_211 = 0x7862B190L;
                    if (((void*)0 == p_41))
                    { /* block id: 106 */
                        const uint64_t l_199[7][5] = {{0xCF23647BCEAF5C80LL,6UL,0xCF23647BCEAF5C80LL,6UL,0xCF23647BCEAF5C80LL},{0UL,18446744073709551615UL,18446744073709551615UL,0UL,0UL},{18446744073709551615UL,6UL,18446744073709551615UL,6UL,18446744073709551615UL},{0UL,0UL,18446744073709551615UL,18446744073709551615UL,0UL},{0xCF23647BCEAF5C80LL,6UL,0xCF23647BCEAF5C80LL,6UL,0xCF23647BCEAF5C80LL},{0UL,18446744073709551615UL,18446744073709551615UL,0UL,0UL},{18446744073709551615UL,6UL,18446744073709551615UL,6UL,18446744073709551615UL}};
                        uint8_t l_204 = 0xC9L;
                        int i, j;
                        if ((*p_41))
                            break;
                        (*l_189) = func_43(((+l_173) <= l_173), l_199[2][4], (((l_172 < (5L & l_172)) == (safe_unary_minus_func_uint32_t_u((safe_add_func_uint8_t_u_u((((void*)0 != l_203) <= (0L ^ l_173)), l_204))))) <= 0x4225E665L), &l_190);
                    }
                    else
                    { /* block id: 109 */
                        uint32_t l_206 = 0x02343891L;
                        (*l_181) = (l_205 != &l_187);
                        (*l_203) = func_43(l_206, ((l_172 < (l_207 == (void*)0)) && l_173), (0x113A2588FA3BE208LL == ((!(((*p_42) >= (*p_41)) <= (safe_rshift_func_uint8_t_u_s(l_211, l_206)))) || (-6L))), &l_190);
                    }
                    (**l_207) = (safe_div_func_float_f_f((l_214 != (void*)0), l_170[(l_173 + 4)][l_171[0][1][1]]));
                    for (l_211 = 0; (l_211 <= 0); l_211 += 1)
                    { /* block id: 116 */
                        int32_t l_218 = 9L;
                        int i, j;
                        (*l_181) = (l_216 != l_217[0]);
                        if (l_170[l_173][l_173])
                            continue;
                        l_218 = 0x0.E9FE6Bp-44;
                    }
                    for (l_211 = 0; (l_211 >= 0); l_211 -= 1)
                    { /* block id: 123 */
                        (*l_203) = &l_173;
                        /* statement id: 124 */
                        assert (l_190 == &l_173);
                        p_42 = p_41;
                        return p_41;
                        /* statement id: 126 */
                        //assert ((func_40_rv >= &l_20[0] && func_40_rv <= &l_20[6]) || (func_40_rv >= &l_508[0][0] && func_40_rv <= &l_508[3][4]) || func_40_rv == &l_18);
                    }
                }
                else
                { /* block id: 128 */
                    return p_42;
                    /* statement id: 129 */
                    //assert ((func_40_rv >= &l_20[0] && func_40_rv <= &l_20[6]) || (func_40_rv >= &l_508[0][0] && func_40_rv <= &l_508[3][4]) || func_40_rv == &l_18);
                }
            }
            return p_41;
            /* statement id: 132 */
            //assert ((func_40_rv >= &l_20[0] && func_40_rv <= &l_20[6]) || (func_40_rv >= &l_508[0][0] && func_40_rv <= &l_508[3][4]) || func_40_rv == &l_18);
        }
        (*l_181) = ((((*l_190) >= 0x0.24888Cp+88) > ((-0x1.4p+1) <= (safe_mul_func_float_f_f((safe_add_func_float_f_f((((**l_203) == (safe_add_func_float_f_f((safe_add_func_float_f_f((((-0x10.Fp+1) < 0x9.E2514Ep+64) >= ((**l_189) >= 0x3.1B48E1p+47)), (!(((*l_190) < (**l_203)) <= (**l_189))))), l_172))) == 0x3.7B0903p+3), l_172)), l_172)))) > (**l_189));
        (*l_189) = func_43((**l_189), l_228, ((**l_189) <= ((safe_lshift_func_int8_t_s_u((safe_rshift_func_uint8_t_u_s(((void*)0 != l_233), 1)), (((safe_rshift_func_int8_t_s_u((safe_mod_func_int32_t_s_s(((&l_215[1][0] != (void*)0) | ((*l_233) != (*l_233))), (**l_189))), (**l_203))) < 0UL) ^ (*l_190)))) || (**l_189))), l_239[0]);
        for (l_172 = 2; (l_172 >= 0); l_172 -= 1)
        { /* block id: 138 */
            int32_t ***l_240[10] = {&l_239[2],&l_239[2],&l_239[2],&l_239[2],&l_239[2],&l_239[2],&l_239[2],&l_239[2],&l_239[2],&l_239[2]};
            int i, j;
            l_239[0] = (void*)0;
            (*l_183) = ((((-0x3.Ep-1) >= (safe_sub_func_float_f_f((safe_sub_func_float_f_f(l_170[(l_171[0][1][1] + 4)][l_171[0][1][1]], ((safe_sub_func_float_f_f((**l_189), (((*l_190) >= ((void*)0 != l_247)) <= ((void*)0 == p_42)))) <= (safe_div_func_float_f_f((*l_190), 0x4.Ep-1))))), (**l_189)))) != (*l_190)) == (*l_190));
        }
        /* facts after for loop */
        //assert (l_239[0] == 0 || l_239[0] == &l_190);
        for (l_172 = 0; (l_172 >= 0); l_172 -= 1)
        { /* block id: 144 */
            struct S0 *l_272 = &l_187;
            int32_t *l_308 = &l_171[0][1][1];
            int i, j;
        }
    }
    return p_41;
    /* statement id: 242 */
    //assert ((func_40_rv >= &l_20[0] && func_40_rv <= &l_20[6]) || (func_40_rv >= &l_508[0][0] && func_40_rv <= &l_508[3][4]) || func_40_rv == &l_18);
}


/* ------------------------------------------ */
/* 
 * reads : l_22 l_557 l_705
 * writes:
 */
static int32_t * func_43(uint16_t  p_44, const uint16_t  p_45, int8_t  p_46, int32_t ** p_47)
{ /* block id: 64 */
    float l_152 = 0x3.E8D535p+69;
    int32_t l_165 = 0x66A3BB2BL;
    for (p_44 = 14; (p_44 >= 38); ++p_44)
    { /* block id: 67 */
        int32_t l_166 = (-4L);
    }
    for (l_165 = 24; (l_165 <= (-10)); l_165--)
    { /* block id: 74 */
        return (*p_47);
        /* statement id: 75 */
        //assert ((func_43_rv >= &l_20[0] && func_43_rv <= &l_20[6]) || (func_43_rv >= &l_171[0][0][0] && func_43_rv <= &l_171[8][1][8]) || func_43_rv == &l_434 || func_43_rv == 0 || func_43_rv == &l_18);
    }
    return (*p_47);
    /* statement id: 77 */
    //assert ((func_43_rv >= &l_20[0] && func_43_rv <= &l_20[6]) || (func_43_rv >= &l_171[0][0][0] && func_43_rv <= &l_171[8][1][8]) || func_43_rv == &l_434 || func_43_rv == 0 || func_43_rv == &l_18);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_49(uint32_t  p_50, uint16_t  p_51, uint32_t  p_52, int16_t  p_53, int32_t ** p_54)
{ /* block id: 11 */
    uint16_t l_71[1];
    struct S0 l_101 = {1935};
    int32_t l_109 = 9L;
    int i;
    for (i = 0; i < 1; i++)
        l_71[i] = 0x54C3L;
    for (p_53 = 0; (p_53 >= 0); p_53 -= 1)
    { /* block id: 14 */
        int i;
        if (l_71[p_53])
            break;
        for (p_50 = 0; (p_50 <= 0); p_50 += 1)
        { /* block id: 18 */
            uint8_t l_79 = 0x05L;
            struct S0 l_99 = {1115};
            struct S0 *l_98 = &l_99;
            int32_t l_103 = (-1L);
            int32_t *l_102 = &l_103;
        }
    }
    return l_109;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_57(const int32_t * p_58, struct S0  p_59, float  p_60, int8_t  p_61, int32_t * const  p_62)
{ /* block id: 6 */
    uint32_t l_64[2][4] = {{0x997736EAL,0x997736EAL,0x997736EAL,0x997736EAL},{0x997736EAL,0x997736EAL,0x997736EAL,0x997736EAL}};
    int32_t l_65 = 0xF6ED7348L;
    struct S0 l_66 = {-1689};
    struct S0 *l_67 = (void*)0;
    struct S0 *l_68 = &l_66;
    int i, j;
lbl_69:
    for (p_61 = 0; p_61 < 2; p_61 += 1)
    {
        for (l_65 = 0; l_65 < 4; l_65 += 1)
        {
            l_64[p_61][l_65] = 0xC4B79A97L;
        }
    }
    (*l_68) = l_66;
    if (l_66.f0)
        goto lbl_69;
    return l_66.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 149
   depth: 1, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 34
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 10
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 15
breakdown:
   indirect level: 0, occurrence: 15
XXX times a bitfields struct's address is taken: 36
XXX times a bitfields struct on LHS: 4
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 8

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 111
   depth: 2, occurrence: 27
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 137

XXX times a variable address is taken: 221
XXX times a pointer is dereferenced on RHS: 116
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 39
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 81
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 3
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 36
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 15
XXX times a pointer is qualified to be dereferenced: 895

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 270
   level: 2, occurrence: 120
   level: 3, occurrence: 25
XXX number of pointers point to pointers: 75
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 27
XXX average alias set size: 1.39

XXX times a non-volatile is read: 778
XXX times a non-volatile is write: 241
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 111
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 14
   depth: 2, occurrence: 12
   depth: 3, occurrence: 6
   depth: 4, occurrence: 20
   depth: 5, occurrence: 31

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

