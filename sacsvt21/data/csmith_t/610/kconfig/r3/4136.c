/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1742488429
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   signed f1 : 10;
   uint64_t  f2;
   int32_t  f3;
   uint32_t  f4;
   int64_t  f5;
   int16_t  f6;
   uint64_t  f7;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint64_t  f0;
   float  f1;
   int16_t  f2;
   int32_t  f3;
   int32_t  f4;
   uint64_t  f5;
   uint8_t  f6;
   const uint32_t  f7;
};
#pragma pack(pop)

union U2 {
   uint8_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_31(void);
inline static union U2 * func_35(float  p_36, union U2 * p_37, struct S0  p_38);
static float  func_52(uint64_t  p_53, const uint64_t  p_54, const union U2 * const  p_55, union U2 * const  p_56);
inline static union U2 ** func_66(int16_t  p_67, union U2 ** p_68, uint8_t  p_69, uint32_t  p_70, union U2 * p_71);
inline static union U2 ** func_72(union U2 ** p_73, struct S1  p_74, union U2  p_75, int16_t  p_76);
inline static union U2 ** func_77(uint8_t  p_78, uint8_t  p_79);
static int16_t  func_81(union U2 * const  p_82, struct S0  p_83);
inline static struct S0  func_99(union U2 * p_100, int32_t  p_101, struct S0  p_102);
inline static union U2 * func_103(int32_t * const * p_104, struct S0  p_105);
static int32_t ** func_106(union U2 ** p_107, uint32_t  p_108, union U2 * p_109, struct S1  p_110, uint8_t  p_111);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 0x6123D4A1L;
    union U2 *l_61 = (void*)0;
    int32_t l_62 = (-5L);
    struct S0 l_470 = {1L,-10,18446744073709551615UL,0x31CFBA77L,0x4C1D5532L,0L,0xC722L,0x1FA1381323F42504LL};
    const uint32_t l_474 = 0xA2A10F93L;
    for (l_32 = 13; (l_32 == (-10)); l_32 -= 1)
    { /* block id: 39 */
        float l_47 = 0x0.82ECC9p+31;
        const int32_t l_63 = (-1L);
        union U2 l_469 = {0x97L};
        union U2 *l_468 = &l_469;
        union U2 **l_473 = &l_61;
    }
    return l_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * func_35(float  p_36, union U2 * p_37, struct S0  p_38)
{ /* block id: 264 */
    union U2 l_472 = {0x71L};
    union U2 *l_471 = &l_472;
    return p_37;
    /* statement id: 265 */
    //assert (func_35_rv == &l_469);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_52(uint64_t  p_53, const uint64_t  p_54, const union U2 * const  p_55, union U2 * const  p_56)
{ /* block id: 40 */
    const union U2 **l_80 = (void*)0;
    struct S0 l_84 = {-1L,-23,0x01997FBCB15E7CE1LL,0xF9D45AA7L,0x5BEB379DL,-1L,0xC3B0L,1UL};
    struct S1 l_324 = {0x07660B678B59EA32LL,-0x1.9p+1,0x314DL,0xC262E34BL,0x77ECFCCCL,0x3AA1B837C6D80C1CLL,0x77L,1UL};
    int64_t l_335 = (-10L);
    int32_t *l_454 = &l_324.f3;
    float *l_458 = (void*)0;
    float **l_457 = &l_458;
    float ***l_456 = &l_457;
    float *l_459 = &l_324.f1;
    for (p_53 = 0; (p_53 < 47); ++p_53)
    { /* block id: 43 */
        int32_t l_89 = 2L;
        int32_t *l_88 = &l_89;
        union U2 l_325 = {0x19L};
        const union U2 ***l_453 = &l_80;
        (*l_453) = func_66(p_54, func_72(func_77((((l_80 != (void*)0) ^ (func_81(p_56, l_84) <= (l_88 != (void*)0))) != ((int16_t)(0xE70CL ^ 0x14F8L) << (int16_t)(*l_88))), p_54), l_324, l_325, (*l_88)), l_335, l_324.f7, &l_325);
        if (l_84.f2)
            break;
        if (p_53)
            continue;
    }
    (*l_454) = p_53;
    (*l_459) = (((!(*l_454)) != ((*l_454) < ((l_456 == &l_457) > (func_81(p_56, l_84) <= (-0x1.4p-1))))) < __builtin_parityll((*l_454)));
    if (p_54)
    { /* block id: 251 */
        int32_t *l_460 = &l_324.f3;
        const int32_t *l_462 = &l_324.f3;
        const int32_t **l_461 = &l_462;
        (*l_461) = l_460;
        (*l_454) = 0x8AF2F0B5L;
        (*l_461) = (*l_461);
    }
    else
    { /* block id: 255 */
        uint32_t l_467 = 5UL;
        (*l_454) = (((uint32_t)(p_54 < p_54) + (uint32_t)(*l_454)) < (*l_454));
        for (l_84.f4 = 3; (l_84.f4 == 41); l_84.f4 += 4)
        { /* block id: 259 */
            if (l_467)
                break;
        }
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 ** func_66(int16_t  p_67, union U2 ** p_68, uint8_t  p_69, uint32_t  p_70, union U2 * p_71)
{ /* block id: 190 */
    int32_t l_337 = 8L;
    int32_t *l_336 = &l_337;
    union U2 **l_339 = (void*)0;
    union U2 l_360 = {251UL};
    union U2 *l_359 = &l_360;
    struct S0 l_361 = {-2L,31,18446744073709551610UL,-1L,0xA91FA1F5L,0x7CFA7BE4CF603A90LL,0x0045L,0UL};
    struct S0 l_374 = {3L,13,0x31EC9D5EB3C4B767LL,-5L,0UL,0L,0x36CDL,9UL};
    float l_377 = 0x6.8062F8p+83;
    float *l_376 = &l_377;
    float *l_378 = (void*)0;
    int32_t **l_379 = &l_336;
    struct S1 l_435 = {4UL,0xA.ED2619p-74,0xCFABL,0x493E8527L,0L,4UL,0x0CL,0x07EB1FF3L};
    struct S1 *l_434 = &l_435;
    struct S1 ** const l_433 = &l_434;
    union U2 **l_441 = &l_359;
    union U2 **l_447 = &l_359;
    union U2 **l_448 = &l_359;
    union U2 **l_449 = &l_359;
    union U2 **l_450 = &l_359;
    union U2 **l_451 = &l_359;
    union U2 **l_452 = (void*)0;
    if (p_69)
    { /* block id: 191 */
        int32_t **l_338 = &l_336;
        (*l_338) = l_336;
        return l_339;
        /* statement id: 193 */
        //assert (func_66_rv == 0);
    }
    else
    { /* block id: 194 */
        int32_t l_348 = 0xF5FCE747L;
        float l_355 = (-0x1.4p+1);
        float *l_354 = &l_355;
        float **l_353 = &l_354;
        float ***l_352 = &l_353;
        float ****l_351 = &l_352;
        float *****l_350 = &l_351;
        struct S1 l_367 = {18446744073709551615UL,0x1.Ep+1,0x1E93L,-1L,0x89C4CF2EL,0x6DEFC8F240B66F2DLL,0UL,0x59324BC6L};
        struct S1 *l_366 = &l_367;
        struct S1 ** const l_365 = &l_366;
        union U2 * const l_373 = &l_360;
        int32_t **l_375 = &l_336;
        for (l_337 = 0; (l_337 < (-2)); l_337--)
        { /* block id: 197 */
            const uint64_t l_349 = 18446744073709551611UL;
            float *****l_356 = &l_351;
            int32_t l_358 = 0x9FE8F8B7L;
            int32_t *l_357 = &l_358;
            struct S0 l_362 = {0x08638680L,-18,1UL,0xA1052F1DL,0x53E89256L,0x65F758B053FAF5FALL,-1L,0x84AF5CDD96B38B31LL};
            const float *l_364 = &l_355;
            const float **l_363 = &l_364;
            (*l_357) = ((uint16_t)((uint16_t)(p_70 == ((int16_t)(9L <= l_348) >> (int16_t)3)) << (uint16_t)(0xC4152906L == ((l_349 > l_348) > (l_350 != l_356)))) << (uint16_t)p_70);
            l_362 = func_99(l_359, l_348, l_361);
            l_363 = (void*)0;
            /* statement id: 200 */
            assert (l_363 == 0);
        }
        (*l_336) = ((((((l_365 != (void*)0) != (~(&p_71 == (void*)0))) && ((uint16_t)(p_67 ^ (*l_336)) >> (uint16_t)7)) <= (((int16_t)func_81(l_373, l_374) << (int16_t)p_70) < l_367.f6)) & p_69) <= p_67);
        (*l_375) = l_354;
        /* statement id: 203 */
        assert (l_336 == &l_355);
    }
    /* facts after branching */
    //assert (l_336 == dangling);
    (*l_376) = (l_376 == l_378);
    (*l_379) = &l_337;
    /* statement id: 206 */
    assert (l_336 == &l_337);
    for (l_374.f4 = (-5); (l_374.f4 <= 41); l_374.f4 += 3)
    { /* block id: 209 */
        float *l_394 = &l_377;
        union U2 * const l_397 = &l_360;
        struct S0 l_398 = {0xC6CE29C8L,-12,18446744073709551615UL,2L,18446744073709551614UL,0x5B8C3F0EF3C61BAELL,0x08FEL,0x40A3092513C46F98LL};
        union U2 **l_439 = &l_359;
        union U2 **l_444 = &l_359;
    }
    return l_452;
    /* statement id: 244 */
    //assert (func_66_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 ** func_72(union U2 ** p_73, struct S1  p_74, union U2  p_75, int16_t  p_76)
{ /* block id: 186 */
    int32_t l_326 = (-5L);
    float l_328 = 0xF.3CA451p+55;
    float *l_327 = &l_328;
    float **l_330 = &l_327;
    float ***l_329 = &l_330;
    float ****l_331 = &l_329;
    union U2 l_334 = {0x8FL};
    union U2 *l_333 = &l_334;
    union U2 **l_332 = &l_333;
    (*l_327) = l_326;
    (*l_331) = l_329;
    return p_73;
    /* statement id: 189 */
    //assert (func_72_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 ** func_77(uint8_t  p_78, uint8_t  p_79)
{ /* block id: 47 */
    int32_t l_92 = 0xC746EA38L;
    union U2 *l_115 = (void*)0;
    struct S0 l_143 = {-1L,-5,0x0BC39A6180E03166LL,-2L,7UL,0L,-6L,3UL};
    int32_t *l_232 = &l_92;
    int32_t * const *l_231 = &l_232;
    struct S1 l_238 = {0x97E377CF922F5302LL,0x4.7CDA0Bp+52,0x8DFBL,1L,1L,1UL,0x42L,18446744073709551615UL};
    struct S1 *l_237 = &l_238;
    union U2 **l_247 = &l_115;
    union U2 **l_248 = &l_115;
    union U2 **l_250 = &l_115;
    union U2 **l_252 = &l_115;
    union U2 **l_281 = &l_115;
    union U2 **l_284 = &l_115;
    float *l_300 = &l_238.f1;
    float **l_299 = &l_300;
    float ***l_298 = &l_299;
    int32_t **l_322 = &l_232;
    union U2 **l_323 = (void*)0;
    if (l_92)
    { /* block id: 48 */
        int32_t *l_93 = &l_92;
        int32_t **l_94 = &l_93;
        union U2 *l_113 = (void*)0;
        union U2 **l_112 = &l_113;
        struct S0 l_129 = {0L,-9,0x20EB5B7D993E846ALL,-1L,0x26A84ADDL,-2L,0x1B67L,0xCF541361E08BDFDFLL};
        (*l_94) = l_93;
        for (p_78 = 24; (p_78 > 56); p_78 += 1)
        { /* block id: 52 */
            uint32_t l_114 = 3UL;
            struct S1 l_116 = {8UL,0xC.6E9516p-67,0x6E34L,0x743E6CB9L,6L,3UL,0xE2L,0x7064EC29L};
            struct S0 *l_202 = &l_129;
            (**l_94) = ((-0x1.Bp-1) <= ((float)(-0x1.8p-1) - (float)l_92));
            (*l_202) = func_99(func_103(func_106(l_112, l_114, l_115, l_116, p_79), l_129), l_116.f0, l_143);
        }
    }
    else
    { /* block id: 110 */
        int32_t *l_205 = &l_92;
        union U2 l_209 = {250UL};
        union U2 *l_208 = &l_209;
        struct S0 l_217 = {-5L,-20,0x69023DF18954A2B7LL,4L,18446744073709551615UL,0xCFC64E1DA1D933A2LL,0xCBE6L,0xDDE1F1B1ED08982DLL};
        union U2 **l_253 = &l_115;
        union U2 **l_254 = (void*)0;
        float *l_258 = &l_238.f1;
        float **l_257 = &l_258;
        float ***l_256 = &l_257;
        float ****l_255 = &l_256;
        float ** const **l_260 = (void*)0;
        float ** const ***l_259 = &l_260;
        for (l_143.f5 = (-30); (l_143.f5 <= 11); ++l_143.f5)
        { /* block id: 113 */
            int32_t *l_206 = &l_92;
            int32_t **l_207 = &l_205;
            union U2 *l_210 = &l_209;
            struct S0 *l_218 = &l_217;
            l_206 = l_205;
            (*l_207) = l_206;
        }
        (*l_259) = l_255;
        /* statement id: 142 */
        assert (l_260 == &l_256);
        for (l_217.f6 = (-21); (l_217.f6 == 20); l_217.f6 += 1)
        { /* block id: 145 */
            int32_t **l_263 = &l_232;
            (*l_256) = (*l_256);
            (*l_263) = l_205;
            if ((*l_205))
                break;
            for (l_143.f0 = 0; (l_143.f0 == 21); l_143.f0 += 5)
            { /* block id: 151 */
                float ****l_267 = &l_256;
                (****l_260) = (+(l_267 != (void*)0));
            }
        }
    }
    if (((int32_t)__builtin_ia32_crc32qi(((uint64_t)((int32_t)(0x430AC928L != (*l_232)) + (int32_t)(((int32_t)((**l_231) > p_79) % (int32_t)p_78) < 0xCBB8D6C72585D44CLL)) - (uint64_t)(p_79 & (**l_231))), (**l_231)) - (int32_t)(**l_231)))
    { /* block id: 156 */
        struct S0 *l_276 = &l_143;
        int32_t **l_279 = &l_232;
        union U2 **l_280 = &l_115;
        union U2 **l_283 = &l_115;
        const float *l_307 = &l_238.f1;
        const float **l_306 = &l_307;
        const float ***l_305 = &l_306;
        const float ****l_304 = &l_305;
        const float *****l_303 = &l_304;
        struct S1 *l_311 = &l_238;
        struct S1 l_313 = {7UL,0x1.8p-1,0xD4F4L,-1L,0x065AF7ACL,1UL,0x7EL,18446744073709551609UL};
        struct S1 *l_312 = &l_313;
        (*l_276) = l_143;
        if ((0UL ^ func_81(func_103(&l_232, func_99((*l_252), ((uint64_t)((void*)0 != l_279) % (uint64_t)(0x26AFAFC6B1E59010LL & (**l_279))), l_143)), l_143)))
        { /* block id: 158 */
            union U2 **l_282 = &l_115;
            union U2 **l_285 = (void*)0;
            return l_285;
            /* statement id: 159 */
            //assert (func_77_rv == 0);
        }
        else
        { /* block id: 160 */
            uint8_t l_297 = 251UL;
            (*l_276) = (*l_276);
            for (l_92 = 0; (l_92 == (-4)); l_92 -= 9)
            { /* block id: 164 */
                int64_t l_290 = 0x8B6CD922F6D8BA3ALL;
                for (l_238.f2 = (-8); (l_238.f2 >= 20); l_238.f2++)
                { /* block id: 167 */
                    l_290 = p_79;
                }
            }
            (**l_279) = __builtin_ctz((((uint16_t)p_78 + (uint16_t)(((p_79 > (**l_279)) > (((int32_t)((int64_t)l_297 - (int64_t)((((void*)0 == l_298) >= (-4L)) >= l_297)) - (int32_t)((int16_t)(*l_232) + (int16_t)0x886EL)) && (**l_279))) ^ (**l_279))) != 0x92D2L));
        }
        if ((l_303 == &l_304))
        { /* block id: 173 */
            const uint32_t l_310 = 1UL;
            (**l_279) = (((**l_279) & (p_78 != ((void*)0 == (*l_303)))) | ((int16_t)p_78 + (int16_t)(l_310 < (**l_279))));
        }
        else
        { /* block id: 175 */
            l_312 = l_311;
            /* statement id: 176 */
            assert (l_312 == &l_238);
        }
        /* facts after branching */
        assert (l_312 == &l_238 || l_312 == &l_313);
        (**l_279) = 0L;
    }
    else
    { /* block id: 179 */
        int32_t *l_314 = &l_238.f3;
        int32_t **l_315 = (void*)0;
        int32_t **l_316 = &l_232;
        union U2 * const l_319 = (void*)0;
        (*l_316) = l_314;
        /* statement id: 180 */
        assert (l_232 == &l_238.f3);
        (**l_231) = ((uint64_t)p_79 % (uint64_t)(**l_231));
        (**l_299) = (((**l_231) == func_81(l_319, l_143)) > (0x4.DAA210p+40 == ((((float)((*l_314) < func_81((*l_248), l_143)) + (float)(**l_316)) == p_79) < (*l_232))));
    }
    /* facts after branching */
    assert (l_232 == &l_238.f3 || l_232 == &l_92);
    (*l_322) = (*l_231);
    return l_323;
    /* statement id: 185 */
    //assert (func_77_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_81(union U2 * const  p_82, struct S0  p_83)
{ /* block id: 44 */
    int32_t *l_85 = (void*)0;
    int32_t l_87 = 0x136032EEL;
    int32_t *l_86 = &l_87;
    (*l_86) = 0x80504C99L;
    return p_83.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_99(union U2 * p_100, int32_t  p_101, struct S0  p_102)
{ /* block id: 73 */
    int32_t l_145 = 0x493E54A6L;
    int32_t * const l_144 = &l_145;
    int32_t *l_147 = &l_145;
    int32_t **l_146 = &l_147;
    union U2 l_188 = {253UL};
    union U2 * const l_187 = &l_188;
    union U2 *l_190 = (void*)0;
    union U2 **l_189 = &l_190;
    struct S1 l_196 = {18446744073709551610UL,0x5.49DF44p-45,0xD8CFL,0x2574CFE0L,0xAD7CC647L,0xD7F101BA2FB85166LL,0x6BL,0x269F6BAAL};
lbl_148:
    (*l_146) = l_144;
    if ((*l_144))
    { /* block id: 75 */
        int32_t l_163 = 0L;
        uint8_t l_170 = 1UL;
        float l_172 = (-0x2.7p+1);
        float *l_171 = &l_172;
        struct S0 l_174 = {0L,-8,5UL,-1L,0x923BADFCL,0x2834275C064C4BACLL,0x3114L,18446744073709551615UL};
        struct S0 *l_173 = &l_174;
        if (p_102.f2)
        { /* block id: 76 */
            uint8_t l_149 = 1UL;
            struct S0 l_161 = {6L,-9,3UL,0x93DF311EL,8UL,0x2DFF05BDE445A64CLL,0L,0xC4BDB83C02C40A72LL};
            struct S0 * const l_160 = &l_161;
            if (l_145)
                goto lbl_148;
            if (l_145)
                goto lbl_169;
            if (__builtin_ctzll(l_149))
            { /* block id: 78 */
                uint64_t l_162 = 2UL;
                int32_t l_164 = (-1L);
                l_164 = ((int16_t)l_149 / (int16_t)((uint16_t)((int64_t)1L + (int64_t)p_102.f4) - (uint16_t)(((((int64_t)((((((*l_147) ^ (p_102.f1 > (18446744073709551610UL == p_102.f0))) && ((uint64_t)(l_160 == (void*)0) / (uint64_t)(*l_144))) && p_102.f7) != p_102.f6) == l_162) + (int64_t)p_102.f1) == p_102.f4) || l_163) && l_161.f1)));
                (*l_146) = &l_164;
                /* statement id: 80 */
                assert (l_147 == &l_164);
                for (p_102.f5 = (-8); (p_102.f5 >= (-29)); p_102.f5--)
                { /* block id: 83 */
                    for (p_102.f3 = (-20); (p_102.f3 != (-20)); p_102.f3 += 8)
                    { /* block id: 86 */
                        (*l_144) = (**l_146);
                    }
                }
            }
            else
            { /* block id: 90 */
                (*l_146) = &l_163;
                /* statement id: 91 */
                assert (l_147 == &l_163);
            }
            /* facts after branching */
            //assert (l_147 == &l_163 || l_147 == dangling);
        }
        else
        { /* block id: 93 */
lbl_169:
            (*l_146) = (*l_146);
            (*l_171) = l_170;
        }
        /* facts after branching */
        //assert (l_147 == &l_145 || l_147 == &l_163 || l_147 == dangling);
        (*l_173) = p_102;
        (*l_146) = &l_163;
        /* statement id: 99 */
        assert (l_147 == &l_163);
    }
    else
    { /* block id: 100 */
        int32_t l_195 = 0x77700A42L;
        struct S0 l_197 = {0x3550C489L,-26,18446744073709551606UL,0xEA2471E6L,0xDA4F5882L,0x4ECC6CAB483B4BD1LL,0x0D12L,18446744073709551606UL};
        struct S1 *l_198 = &l_196;
        struct S1 **l_199 = &l_198;
        struct S0 *l_200 = (void*)0;
        struct S0 *l_201 = &l_197;
        (*l_147) = ((int32_t)((uint16_t)((**l_146) <= (p_102.f0 <= (+p_102.f2))) + (uint16_t)((uint32_t)((int32_t)((((+(func_81(l_187, p_102) > func_81(func_103(func_106(l_189, ((((uint16_t)0UL - (uint16_t)((((int32_t)(p_102.f3 != p_102.f3) - (int32_t)l_195) & 0UL) == (*l_147))) | p_102.f4) != (**l_146)), p_100, l_196, l_195), p_102), l_197))) <= 4UL) & p_102.f1) & l_197.f0) / (int32_t)0xB2B88A4EL) - (uint32_t)4294967294UL)) - (int32_t)l_197.f7);
        (*l_199) = l_198;
        (*l_201) = p_102;
        (*l_189) = p_100;
        /* statement id: 104 */
        //assert (l_190 == 0 || l_190 == &l_209 || l_190 == &l_360);
    }
    /* facts after branching */
    //assert (l_147 == &l_145 || l_147 == dangling);
    //assert (l_190 == 0 || l_190 == &l_209 || l_190 == &l_360);
    (*l_146) = &l_145;
    /* statement id: 106 */
    assert (l_147 == &l_145);
    return p_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * func_103(int32_t * const * p_104, struct S0  p_105)
{ /* block id: 67 */
    int32_t l_131 = 0L;
    int32_t *l_130 = &l_131;
    int32_t **l_132 = (void*)0;
    int32_t **l_133 = &l_130;
    struct S0 l_136 = {-10L,23,18446744073709551615UL,1L,0x33A92D29L,-4L,0x4A0DL,0x95FA104C7A4504AELL};
    struct S0 *l_135 = &l_136;
    struct S0 **l_134 = &l_135;
    union U2 l_138 = {0UL};
    union U2 *l_137 = &l_138;
    union U2 *l_139 = &l_138;
    union U2 *l_140 = &l_138;
    union U2 *l_141 = &l_138;
    union U2 *l_142 = (void*)0;
    (*l_133) = l_130;
    (*l_133) = (*l_133);
    (*l_133) = (*l_133);
    (*l_134) = &p_105;
    /* statement id: 71 */
    assert (l_135 == &p_105);
    return l_142;
    /* statement id: 72 */
    //assert (func_103_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_106(union U2 ** p_107, uint32_t  p_108, union U2 * p_109, struct S1  p_110, uint8_t  p_111)
{ /* block id: 54 */
    const int32_t *l_120 = (void*)0;
    const int32_t **l_119 = &l_120;
    int32_t *l_126 = (void*)0;
    int32_t **l_125 = &l_126;
    int32_t **l_127 = &l_126;
    int32_t **l_128 = (void*)0;
    for (p_110.f6 = (-15); (p_110.f6 > 3); p_110.f6 += 5)
    { /* block id: 57 */
        struct S0 l_123 = {0x1B120E24L,-12,7UL,0xC2D3C6BEL,18446744073709551615UL,0xEDD96C0B5FFC7B43LL,1L,0x720855C5D77E0797LL};
        l_119 = l_119;
        for (p_110.f3 = (-12); (p_110.f3 == (-26)); p_110.f3--)
        { /* block id: 61 */
            struct S0 *l_124 = &l_123;
            (*l_124) = l_123;
        }
        (*l_119) = (*l_119);
    }
    return l_128;
    /* statement id: 66 */
    //assert (func_106_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 130
   depth: 1, occurrence: 17
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 14
   indirect level: 1, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 33
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 5

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 125
   depth: 2, occurrence: 20
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 17, occurrence: 1
   depth: 21, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 170

XXX times a variable address is taken: 152
XXX times a pointer is dereferenced on RHS: 54
breakdown:
   depth: 1, occurrence: 38
   depth: 2, occurrence: 16
XXX times a pointer is dereferenced on LHS: 67
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 6
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 162

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 211
   level: 2, occurrence: 32
   level: 3, occurrence: 1
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 93
XXX number of pointers point to scalars: 33
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 24.1
XXX average alias set size: 1.15

XXX times a non-volatile is read: 428
XXX times a non-volatile is write: 175
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 101
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 35
   depth: 2, occurrence: 24
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 18.3
XXX percentage an existing variable is used: 81.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

