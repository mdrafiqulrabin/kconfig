/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1793807167
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 30;
   unsigned f1 : 29;
   signed f2 : 12;
   unsigned f3 : 7;
   signed f4 : 28;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   const uint32_t  f0;
   uint16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   uint32_t  f4;
   uint32_t  f5;
   int32_t  f6;
   int32_t  f7;
   signed f8 : 24;
};
#pragma pack(pop)

union U2 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_32(void);
static union U2 * func_33(union U2 * const  p_34, const union U2 * const  p_35);
inline static union U2 * const  func_36(float  p_37, struct S1  p_38, union U2 * p_39, struct S1  p_40);
inline static float  func_41(union U2 * p_42, union U2 * p_43, const union U2 * p_44);
inline static union U2 * func_47(struct S0  p_48, union U2 * p_49, union U2 * p_50, union U2 * p_51);
inline static float  func_56(union U2  p_57, union U2 * p_58, union U2 * const  p_59, union U2  p_60);
static union U2 * func_62(uint32_t  p_63, union U2 * p_64, float  p_65);
inline static int32_t  func_70(union U2 * p_71, union U2 * p_72, union U2 * const  p_73, int32_t  p_74, int32_t  p_75);
inline static union U2 * func_76(union U2 * p_77, const uint32_t  p_78);
static const int16_t  func_88(uint16_t  p_89, const union U2 * p_90, uint16_t  p_91, int32_t  p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_32(void)
{ /* block id: 36 */
    union U2 l_46 = {1};
    union U2 *l_45 = &l_46;
    struct S0 l_52 = {17174,12538,0,2,7097};
    union U2 *l_53 = &l_46;
    struct S1 l_526 = {0x8D610EE2,0x0107,0xEEE152A4,0xC8394970,7U,0x5E54DABD,0xDF9191F9,0x77D26157,2639};
    union U2 **l_612 = &l_45;
    (*l_612) = func_33(func_36((0xB.2D49ACp-47 >= (func_41(l_45, func_47(l_52, &l_46, l_53, &l_46), &l_46) < l_46.f0)), l_526, &l_46, l_526), &l_46);
    /* statement id: 442 */
    assert (l_45 == 0);
    return l_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2 * func_33(union U2 * const  p_34, const union U2 * const  p_35)
{ /* block id: 389 */
    struct S0 ***** const l_548 = (void*)0;
    struct S0 *****l_549 = (void*)0;
    int32_t **l_551 = (void*)0;
    int32_t ***l_550 = &l_551;
    float l_553 = (-0x10.Fp-1);
    float *l_552 = &l_553;
    int32_t l_558 = 0x298B29EC;
    struct S1 l_560 = {0x9B9288B7,2U,0x474F118D,0xD0527272,0U,0x510C14C1,-9,0x950F61D7,1564};
    struct S1 *l_559 = &l_560;
    union U2 l_572 = {0x20879AAA};
    union U2 *l_571 = &l_572;
    union U2 *l_604 = &l_572;
    union U2 *l_605 = &l_572;
    union U2 *l_606 = &l_572;
    union U2 *l_607 = &l_572;
    union U2 *l_608 = &l_572;
    union U2 *l_609 = &l_572;
    union U2 *l_610 = &l_572;
    union U2 *l_611 = (void*)0;
    l_549 = l_548;
    (*l_552) = (l_550 == &l_551);
    if (((uint16_t)((uint16_t)l_558 >> (uint16_t)15) >> (uint16_t)6))
    { /* block id: 392 */
        struct S1 **l_561 = &l_559;
        int32_t *l_562 = &l_560.f7;
        int32_t **l_563 = &l_562;
        (*l_561) = l_559;
        (*l_563) = l_562;
    }
    else
    { /* block id: 395 */
        struct S0 l_564 = {-30052,1617,34,0,9038};
        struct S0 *l_568 = &l_564;
        struct S0 **l_567 = &l_568;
        struct S0 ***l_566 = &l_567;
        struct S0 ****l_565 = &l_566;
        struct S0 *****l_569 = &l_565;
        int32_t *l_578 = &l_558;
        union U2 *l_591 = &l_572;
        l_564 = l_564;
        (*l_569) = l_565;
        if (l_564.f4)
        { /* block id: 398 */
            int32_t l_570 = (-1);
            union U2 *l_573 = (void*)0;
            l_570 = __builtin_clz(l_564.f2);
            return l_573;
            /* statement id: 400 */
            //assert (func_33_rv == 0);
        }
        else
        { /* block id: 401 */
            int32_t l_574 = 4;
            struct S1 **l_575 = (void*)0;
            (*l_552) = 0x7.84DB20p-21;
            l_564.f0 = l_574;
            l_575 = l_575;
            l_574 = l_564.f2;
        }
        for (l_560.f7 = (-5); (l_560.f7 == 15); l_560.f7++)
        { /* block id: 409 */
            const int32_t *l_580 = &l_560.f7;
            const int32_t **l_579 = &l_580;
            union U2 *l_590 = &l_572;
            struct S0 *l_603 = (void*)0;
            (*l_579) = l_578;
            /* statement id: 410 */
            assert (l_580 == &l_558);
            for (l_572.f0 = (-23); (l_572.f0 > 23); l_572.f0 += 5)
            { /* block id: 413 */
                int16_t l_585 = (-4);
                union U2 *l_594 = (void*)0;
                struct S0 ****l_602 = &l_566;
                (*l_579) = (*l_579);
                for (l_560.f4 = 1; (l_560.f4 >= 48); ++l_560.f4)
                { /* block id: 417 */
                    (*l_579) = (void*)0;
                    /* statement id: 418 */
                    assert (l_580 == 0);
                    (*l_579) = l_578;
                    /* statement id: 419 */
                    assert (l_580 == &l_558);
                    (*l_578) = l_585;
                }
                (*l_578) = l_585;
                for (l_560.f1 = 0; (l_560.f1 >= 49); l_560.f1 += 9)
                { /* block id: 425 */
                    int32_t l_588 = 0x52831297;
                    union U2 *l_592 = &l_572;
                    union U2 * const l_601 = &l_572;
                    if (l_588)
                    { /* block id: 426 */
                        struct S1 *l_589 = &l_560;
                        union U2 *l_593 = &l_572;
                        if (l_588)
                            break;
                        (*l_579) = (void*)0;
                        /* statement id: 428 */
                        assert (l_580 == 0);
                        l_589 = l_589;
                        return l_594;
                        /* statement id: 430 */
                        //assert (func_33_rv == 0);
                    }
                    else
                    { /* block id: 431 */
                        union U2 *l_599 = &l_572;
                        const int32_t l_600 = 4;
                        (*l_579) = l_578;
                        (*l_578) = ((int16_t)(((0x985A28A2 || ((0x0D5FFFDD | (l_588 || (*l_578))) == (((((uint16_t)func_70(l_599, func_76(l_594, l_600), l_601, (*l_578), l_600) - (uint16_t)0x6198) != 0U) & 0xE337BEB0) != l_588))) || (*l_580)) ^ l_588) << (int16_t)14);
                        l_602 = (void*)0;
                        /* statement id: 434 */
                        assert (l_602 == 0);
                        (**l_566) = l_603;
                        /* statement id: 435 */
                        assert (l_568 == 0);
                    }
                    /* facts after branching */
                    assert (l_568 == 0);
                    assert (l_602 == 0);
                }
                /* facts after for loop */
                assert (l_602 == 0 || l_602 == &l_566);
            }
        }
        /* facts after for loop */
        assert (l_568 == 0 || l_568 == &l_564);
    }
    return l_611;
    /* statement id: 441 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * const  func_36(float  p_37, struct S1  p_38, union U2 * p_39, struct S1  p_40)
{ /* block id: 374 */
    const int16_t l_529 = 0x6481;
    struct S0 l_533 = {-1129,8461,20,4,-2026};
    struct S0 *l_532 = &l_533;
    int32_t l_534 = 0x62A59981;
    int32_t l_535 = 0x3D36BC6A;
    float l_537 = 0x0.1p+1;
    float *l_536 = &l_537;
    struct S1 ***l_538 = (void*)0;
    struct S1 ****l_539 = &l_538;
    (*l_536) = ((((float)(((((l_529 < ((float)p_38.f3 - (float)((((l_532 != &l_533) == l_533.f4) >= (l_533.f1 > p_38.f2)) <= (l_533.f4 <= ((((((0x9.8F0D11p-62 >= p_38.f4) > l_533.f4) <= p_40.f5) != 0x0.0p-1) > 0x9.2D7024p-39) < l_533.f2))))) > 0x4.Ep-1) != p_38.f7) >= l_533.f1) > l_534) - (float)l_535) == p_40.f0) >= 0x7.20F2C5p-97);
    (*l_539) = l_538;
    for (p_38.f7 = (-12); (p_38.f7 <= (-28)); p_38.f7 -= 2)
    { /* block id: 379 */
        uint32_t l_542 = 0xD1236AFF;
        const union U2 l_544 = {0xA37E573F};
        const union U2 *l_543 = &l_544;
        if ((0 ^ func_88(l_542, l_543, p_38.f6, (1U >= p_38.f4))))
        { /* block id: 380 */
            (*l_532) = (*l_532);
        }
        else
        { /* block id: 382 */
            int32_t *l_545 = &l_535;
            const int32_t *l_547 = &l_544.f0;
            const int32_t **l_546 = &l_547;
            (*l_546) = l_545;
            /* statement id: 383 */
            assert (l_547 == &l_535);
            (*l_546) = &l_535;
            (*l_545) = p_40.f2;
        }
    }
    return p_39;
    /* statement id: 388 */
    //assert (func_36_rv == &l_46);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_41(union U2 * p_42, union U2 * p_43, const union U2 * p_44)
{ /* block id: 371 */
    struct S1 l_525 = {4294967286U,65535U,2U,0xEE744610,4294967295U,0xB498175C,0xF7CA3DB3,1,1810};
    struct S1 *l_524 = &l_525;
    l_524 = l_524;
    return l_525.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * func_47(struct S0  p_48, union U2 * p_49, union U2 * p_50, union U2 * p_51)
{ /* block id: 37 */
    union U2 l_61 = {-9};
    float l_508 = 0x9.67FAD0p-43;
    float *l_507 = &l_508;
    float **l_506 = &l_507;
    float ***l_505 = &l_506;
    float ****l_504 = &l_505;
lbl_510:
    l_61.f0 = ((float)func_56(l_61, &l_61, func_62(l_61.f0, p_50, l_61.f0), l_61) - (float)l_61.f0);
    if (((uint16_t)((int32_t)l_61.f0 % (int32_t)(-1)) % (uint16_t)l_61.f0))
    { /* block id: 342 */
        union U2 *l_476 = &l_61;
        return p_49;
        /* statement id: 343 */
        //assert (func_47_rv == &l_46);
    }
    else
    { /* block id: 344 */
        float l_487 = 0xE.5C1BD8p-10;
        float * const l_486 = &l_487;
        float * const *l_485 = &l_486;
        float * const ** const l_484 = &l_485;
        int32_t l_500 = 7;
        union U2 *l_520 = &l_61;
        struct S1 l_522 = {0xF9A0C013,7U,1U,0x5F37A506,4294967294U,0U,1,0,-52};
        struct S1 *l_521 = &l_522;
        struct S1 **l_523 = &l_521;
        if (__builtin_ffs(p_48.f2))
        { /* block id: 345 */
            float l_481 = (-0x9.4p+1);
            float *l_480 = &l_481;
            float **l_483 = &l_480;
            float *** const l_482 = &l_483;
            int32_t *l_488 = &l_61.f0;
            (*l_480) = ((float)(-(float)p_48.f0) - (float)p_48.f2);
            (*l_488) = (l_482 != l_484);
            if ((((((uint16_t)(((int16_t)((((uint16_t)(!((int16_t)(*l_488) >> (int16_t)3)) - (uint16_t)((0x9D0F >= func_88((((0xE9A9 != __builtin_ffsl(l_61.f0)) | __builtin_popcountl(((((int16_t)__builtin_ctz((*l_488)) >> (int16_t)1) <= l_61.f0) && (-1)))) >= l_500), &l_61, l_61.f0, l_500)) != 8)) < 1) > 65529U) >> (int16_t)p_48.f0) == l_61.f0) - (uint16_t)0U) || l_500) <= p_48.f4) <= 0x511A3D45))
            { /* block id: 348 */
                union U2 *l_501 = &l_61;
                return p_51;
                /* statement id: 349 */
                //assert (func_47_rv == &l_46);
            }
            else
            { /* block id: 350 */
                const int32_t **l_502 = (void*)0;
                int32_t **l_503 = &l_488;
                float *****l_509 = &l_504;
                (*l_503) = l_480;
                /* statement id: 351 */
                assert (l_488 == &l_481);
                (*l_509) = l_504;
                if (l_61.f0)
                    goto lbl_510;
                for (l_500 = (-29); (l_500 > (-26)); ++l_500)
                { /* block id: 356 */
                    union U2 *l_515 = &l_61;
                    for (l_61.f0 = (-21); (l_61.f0 == (-25)); l_61.f0--)
                    { /* block id: 359 */
                        return p_50;
                        /* statement id: 360 */
                        //assert (func_47_rv == &l_46);
                    }
                }
            }
            /* facts after branching */
            assert (l_488 == &l_481);
        }
        else
        { /* block id: 364 */
            struct S0 l_516 = {25285,14986,12,10,7200};
            struct S0 *l_517 = (void*)0;
            struct S0 *l_518 = &l_516;
            union U2 *l_519 = &l_61;
            (*l_518) = l_516;
            return p_50;
            /* statement id: 366 */
            //assert (func_47_rv == &l_46);
        }
        (*l_523) = l_521;
        return p_49;
        /* statement id: 369 */
        //assert (func_47_rv == &l_46);
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_56(union U2  p_57, union U2 * p_58, union U2 * const  p_59, union U2  p_60)
{ /* block id: 332 */
    int32_t *l_467 = (void*)0;
    int32_t **l_468 = &l_467;
    (*l_468) = l_467;
    (*l_468) = (void*)0;
    for (p_57.f0 = 13; (p_57.f0 == 7); --p_57.f0)
    { /* block id: 337 */
        int32_t l_471 = 0xE7F69890;
        return l_471;
    }
    return p_57.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2 * func_62(uint32_t  p_63, union U2 * p_64, float  p_65)
{ /* block id: 38 */
    uint16_t l_94 = 0U;
    union U2 *l_335 = (void*)0;
    int32_t l_455 = 0x98A81FEB;
    int32_t *l_454 = &l_455;
    if (p_63)
    { /* block id: 39 */
        union U2 l_80 = {0xB1CC8FFC};
        union U2 *l_79 = &l_80;
        uint32_t l_103 = 0x1A6511C0;
        uint32_t l_104 = 0x59678192;
        if (((int32_t)((int32_t)0xAD503240 % (int32_t)4294967287U) + (int32_t)func_70(func_76(l_79, ((uint16_t)(((((uint16_t)0xE524 + (uint16_t)(((int32_t)(!(func_88(p_63, &l_80, (~l_94), p_63) <= l_103)) % (int32_t)l_94) < 0xCB10B3F4)) | l_103) <= 0xB084) & p_63) >> (uint16_t)l_104)), l_335, l_335, l_94, l_94)))
        { /* block id: 308 */
            return p_64;
            /* statement id: 309 */
            //assert (func_62_rv == &l_46);
        }
        else
        { /* block id: 310 */
            return p_64;
            /* statement id: 311 */
            //assert (func_62_rv == &l_46);
        }
    }
    else
    { /* block id: 313 */
        float *l_460 = (void*)0;
        int32_t l_465 = (-1);
        for (l_94 = (-24); (l_94 >= 60); l_94++)
        { /* block id: 316 */
            int32_t l_453 = 0xF8A40BFA;
            int32_t *l_452 = &l_453;
            int32_t **l_456 = &l_454;
            for (p_63 = 0; (p_63 < 11); p_63 += 4)
            { /* block id: 319 */
                l_454 = l_452;
                /* statement id: 320 */
                assert (l_454 == &l_453);
            }
            /* facts after for loop */
            //assert (l_454 == &l_453 || l_454 == dangling || l_454 == &l_455);
        }
        /* facts after for loop */
        //assert (l_454 == dangling || l_454 == &l_455);
        for (l_94 = (-5); (l_94 < 36); l_94 += 8)
        { /* block id: 327 */
            float *l_459 = (void*)0;
            int32_t l_466 = 1;
            l_466 = ((l_459 == l_460) || ((int16_t)((uint16_t)l_465 + (uint16_t)__builtin_ffsl(l_466)) >> (int16_t)l_465));
        }
        return p_64;
        /* statement id: 330 */
        //assert (func_62_rv == &l_46);
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_70(union U2 * p_71, union U2 * p_72, union U2 * const  p_73, int32_t  p_74, int32_t  p_75)
{ /* block id: 221 */
    int32_t *l_336 = (void*)0;
    int32_t **l_337 = &l_336;
    struct S0 l_341 = {24643,16325,2,7,1714};
    int32_t ***l_382 = (void*)0;
    int32_t ****l_381 = &l_382;
    struct S1 l_399 = {4U,65533U,4294967295U,9,0x69882152,0xD474E7F7,0,0xEAA3B41B,-1931};
    struct S1 *l_398 = &l_399;
    struct S1 **l_397 = &l_398;
    const uint32_t l_400 = 0xE4E40386;
    union U2 l_409 = {0x0B7D17F2};
    const union U2 *l_408 = &l_409;
    int32_t *l_447 = &l_399.f7;
lbl_338:
    (*l_337) = l_336;
lbl_369:
    (*l_337) = &p_75;
    /* statement id: 223 */
    assert (l_336 == &p_75);
    if (p_74)
    { /* block id: 224 */
        struct S1 l_340 = {4294967289U,65526U,7U,0xD09B6B8F,4294967289U,0x122B5390,0x25CD2622,4,211};
        struct S1 *l_339 = &l_340;
        if (p_74)
            goto lbl_338;
        l_339 = l_339;
        (**l_337) = l_340.f7;
    }
    else
    { /* block id: 228 */
        struct S0 *l_342 = (void*)0;
        struct S0 *l_343 = &l_341;
        struct S1 l_352 = {7U,0x5827,0x74B817AD,0x72ABD017,0xE2BD8798,0xFAE7A31B,-7,0x4877228C,-1190};
        struct S1 *l_351 = &l_352;
        union U2 l_365 = {-5};
        union U2 *l_364 = &l_365;
        union U2 **l_363 = &l_364;
        int32_t *** const l_375 = &l_337;
        float *l_407 = (void*)0;
        float **l_406 = &l_407;
        float ***l_405 = &l_406;
        float ****l_404 = &l_405;
        float *****l_403 = &l_404;
        int32_t l_426 = 9;
lbl_439:
        (*l_343) = l_341;
        for (p_75 = 0; (p_75 == (-27)); --p_75)
        { /* block id: 232 */
            struct S0 l_356 = {2919,23140,44,3,-12845};
            const union U2 *l_390 = (void*)0;
            float **** const *l_402 = (void*)0;
            union U2 *l_425 = &l_365;
            int32_t *l_428 = &l_399.f7;
            int32_t l_429 = 0;
            struct S1 *l_440 = &l_399;
            (*l_343) = l_341;
            if (__builtin_bswap32(p_74))
            { /* block id: 234 */
                uint16_t l_346 = 1U;
                if (l_346)
                { /* block id: 235 */
                    int16_t l_348 = 0x562B;
                    union U2 l_350 = {0};
                    const union U2 *l_349 = &l_350;
                    if ((!(func_88(l_348, l_349, (l_351 == (void*)0), (-(uint16_t)(0xA83E0B29 & (&l_350 != p_73)))) && l_346)))
                    { /* block id: 236 */
                        (*l_343) = l_356;
                    }
                    else
                    { /* block id: 238 */
                        uint32_t l_357 = 0x7126FB48;
                        float *l_360 = (void*)0;
                        float l_362 = 0x6.2p-1;
                        float *l_361 = &l_362;
                        (*l_361) = ((l_357 == 0x2.E0EB8Ep+5) <= ((float)p_75 + (float)0xE.375911p+57));
                    }
                }
                else
                { /* block id: 241 */
                    union U2 ***l_366 = &l_363;
                    (*l_366) = l_363;
                }
            }
            else
            { /* block id: 244 */
                float l_372 = (-0x1.0p+1);
                float *l_371 = &l_372;
                for (p_74 = 0; (p_74 != 10); ++p_74)
                { /* block id: 247 */
                    if (l_341.f2)
                        goto lbl_369;
                    return p_74;
                }
                (*l_343) = l_356;
                (*l_371) = (-(float)0x9.8p+1);
                (*l_343) = l_341;
            }
            for (p_74 = (-26); (p_74 >= (-28)); p_74 -= 8)
            { /* block id: 257 */
                uint16_t l_392 = 0x1346;
                struct S1 **l_396 = &l_351;
                (*l_337) = &p_75;
                /* statement id: 258 */
                assert (l_336 == &p_75);
                if (((1U ^ p_75) <= __builtin_parityll((l_375 != (void*)0))))
                { /* block id: 259 */
                    uint32_t l_391 = 0x6158B851;
                    int32_t *l_393 = &l_365.f0;
                    float l_395 = 0xA.7FDB8Ap+57;
                    float *l_394 = &l_395;
                    (*l_393) = ((~(((void*)0 == &l_363) == ((uint16_t)((int16_t)0x901A << (int16_t)(((((0x39C1 | 0xE173) ^ ((void*)0 == l_381)) != ((uint16_t)((int16_t)p_74 - (int16_t)((uint16_t)(func_88((-(uint32_t)(l_356.f3 > p_75)), l_390, (***l_375), l_391) <= (**l_337)) << (uint16_t)p_74)) >> (uint16_t)1)) != l_356.f0) > l_391)) >> (uint16_t)6))) > l_392);
                    (*l_394) = (((0x2.9p+1 == (**l_337)) == (l_392 >= __builtin_parityl((***l_375)))) != (p_75 != (p_74 <= (p_75 > 0x0.Ap+1))));
                    (*l_394) = (((void*)0 == &l_393) <= ((*l_393) < ((l_396 != l_397) == l_400)));
                    return l_392;
                }
                else
                { /* block id: 264 */
                    return l_356.f3;
                }
            }
            if ((!func_88((l_402 != l_403), l_408, l_356.f0, p_75)))
            { /* block id: 268 */
                int32_t l_430 = 0x25F09CD1;
                struct S0 l_443 = {8923,6831,13,1,-3345};
                (*l_337) = (void*)0;
                /* statement id: 269 */
                assert (l_336 == 0);
                if (p_74)
                { /* block id: 270 */
                    int16_t l_422 = 0x4FDD;
                    if ((l_356.f2 < (p_74 & (((!((int16_t)p_75 << (int16_t)0)) > (p_75 <= (p_75 & 0x77763F05))) && (0U || 0x39660C89)))))
                    { /* block id: 271 */
                        struct S0 l_413 = {-4828,17789,54,6,7164};
                        l_413 = l_356;
                        l_413 = l_356;
                    }
                    else
                    { /* block id: 274 */
                        const int16_t l_414 = 0x7D02;
                        int32_t *l_427 = &l_426;
                        l_356.f2 = (((p_75 != l_414) < ((float)(func_88((((int16_t)((((int16_t)(((-(uint16_t)l_422) && ((int32_t)p_75 + (int32_t)0xA5E4B6AA)) || ((func_88(p_75, func_76(func_76(l_425, l_414), p_75), p_74, p_75) | l_422) <= p_75)) << (int16_t)l_422) != l_352.f4) <= p_75) - (int16_t)l_414) && 0), p_71, p_74, l_426) > 0x0.7p+1) + (float)p_75)) <= 0xE.B505FBp+14);
                        l_428 = l_427;
                        /* statement id: 276 */
                        assert (l_428 == &l_426);
                        l_428 = (**l_375);
                        /* statement id: 277 */
                        assert (l_428 == 0);
                        (*l_397) = (*l_397);
                    }
                    /* facts after branching */
                    assert (l_428 == 0 || l_428 == &l_399.f7);
                }
                else
                { /* block id: 280 */
                    float l_432 = 0xB.0751F6p-22;
                    float *l_431 = &l_432;
                    l_430 = l_429;
                    (*l_428) = 0x3.20FF23p+66;
                    if ((((void*)0 == l_431) & (((void*)0 == (*l_397)) >= (l_430 >= (0x7CD6856D >= ((int32_t)((uint16_t)1U << (uint16_t)(((int16_t)func_88(p_75, (*l_363), l_430, p_74) >> (int16_t)7) && p_75)) + (int32_t)0xC19E6022))))))
                    { /* block id: 283 */
                        if (l_341.f1)
                            goto lbl_439;
                        p_74 = (p_75 > 0x008A2179);
                        (*l_397) = l_440;
                    }
                    else
                    { /* block id: 287 */
                        return l_430;
                    }
                    for (p_74 = 22; (p_74 <= 25); p_74 += 9)
                    { /* block id: 292 */
                        (*l_343) = l_443;
                        return p_75;
                    }
                }
                /* facts after branching */
                assert (l_428 == 0 || l_428 == &l_399.f7);
                (*l_337) = l_428;
                /* statement id: 297 */
                assert (l_336 == 0 || l_336 == &l_399.f7);
                if (p_75)
                    continue;
            }
            else
            { /* block id: 299 */
                struct S0 l_444 = {12192,5287,-44,0,-8113};
                float l_446 = 0x1.1p-1;
                float *l_445 = &l_446;
                l_341 = l_444;
                (*l_445) = 0x8.8E88F4p+30;
            }
            /* facts after branching */
            assert (l_428 == 0 || l_428 == &l_399.f7);
        }
        /* facts after for loop */
        assert (l_336 == 0 || l_336 == &l_399.f7 || l_336 == &p_75);
        (*l_343) = l_341;
    }
    /* facts after branching */
    assert (l_336 == 0 || l_336 == &l_399.f7 || l_336 == &p_75);
    (*l_447) = p_75;
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * func_76(union U2 * p_77, const uint32_t  p_78)
{ /* block id: 47 */
    int32_t l_106 = 0xF2EA6DA2;
    int32_t *l_105 = &l_106;
    float l_111 = 0xF.E598C2p+21;
    float *l_110 = &l_111;
    float **l_109 = &l_110;
    uint32_t l_113 = 0xDC7CBFAB;
    const union U2 l_117 = {0x9FDCBA9C};
    const union U2 *l_116 = &l_117;
    uint32_t l_158 = 4294967295U;
    int16_t l_162 = 0x9BC0;
    struct S0 l_177 = {26021,10383,53,1,-2089};
    struct S0 * const l_176 = &l_177;
    struct S0 * const *l_175 = &l_176;
    struct S1 l_192 = {4294967295U,4U,1U,0x423BFD0A,6U,0U,0xB170AB69,-1,-3795};
    struct S1 *l_191 = &l_192;
    struct S0 l_205 = {3353,17072,-7,6,-7724};
    int32_t l_223 = 0x14BE7DE1;
    int32_t l_270 = (-1);
    (*l_105) = 0;
    for (l_106 = 20; (l_106 >= 26); l_106 += 9)
    { /* block id: 51 */
        float **l_112 = (void*)0;
        l_112 = l_109;
        /* statement id: 52 */
        assert (l_112 == &l_110);
        (*l_110) = __builtin_ffs((*l_105));
    }
    return p_77;
    /* statement id: 220 */
    //assert (func_76_rv == &l_80 || func_76_rv == &l_365 || func_76_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_88(uint16_t  p_89, const union U2 * p_90, uint16_t  p_91, int32_t  p_92)
{ /* block id: 40 */
    float l_96 = 0xA.8B70E9p+96;
    float *l_95 = &l_96;
    struct S0 l_97 = {-15070,7215,-40,1,-6950};
    struct S0 *l_98 = &l_97;
    float **l_99 = &l_95;
    int32_t l_102 = (-1);
    int32_t *l_101 = &l_102;
    (*l_95) = p_92;
    (*l_98) = l_97;
    if (l_97.f1)
        goto lbl_100;
lbl_100:
    l_99 = &l_95;
    (*l_101) = l_97.f0;
    return p_89;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 163
   depth: 1, occurrence: 19
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 43
breakdown:
   indirect level: 0, occurrence: 19
   indirect level: 1, occurrence: 14
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 2
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 18
breakdown:
   indirect level: 0, occurrence: 18
XXX times a bitfields struct's address is taken: 25
XXX times a bitfields struct on LHS: 7
XXX times a bitfields struct on RHS: 37
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 22

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 185
   depth: 2, occurrence: 24
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 9, occurrence: 4
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 216

XXX times a variable address is taken: 196
XXX times a pointer is dereferenced on RHS: 62
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 9
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 114
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 9
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 310

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 339
   level: 2, occurrence: 42
   level: 3, occurrence: 33
   level: 4, occurrence: 11
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 89
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 27
XXX percent of pointers has null in alias set: 19.9
XXX average alias set size: 1.18

XXX times a non-volatile is read: 627
XXX times a non-volatile is write: 303
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 5

XXX stmts: 147
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 24
   depth: 2, occurrence: 25
   depth: 3, occurrence: 23
   depth: 4, occurrence: 19
   depth: 5, occurrence: 23

XXX percentage a fresh-made variable is used: 24.3
XXX percentage an existing variable is used: 75.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

