/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3747262210
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   int16_t  f1;
   int16_t  f2;
   uint32_t  f3;
   const uint32_t  f4;
   uint32_t  f5;
};

struct S1 {
   float  f0;
   uint16_t  f1;
   const int16_t  f2;
   int32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_36(void);
static float  func_45(struct S1  p_46, struct S0  p_47, uint16_t  p_48);
static float  func_56(struct S1  p_57);
static float  func_59(int16_t  p_60, struct S0  p_61, uint32_t  p_62, const uint16_t  p_63);
static int32_t * func_78(int32_t * p_79);
static float  func_86(int32_t * p_87, int32_t * p_88);
inline static int32_t * func_89(int32_t * p_90);
inline static int32_t * func_91(uint32_t  p_92, uint32_t  p_93, int16_t  p_94, int32_t * p_95);
inline static struct S0 * func_108(struct S0 * p_109, uint32_t  p_110, struct S1 * p_111, int32_t * p_112, const uint32_t  p_113);
static struct S0 * func_114(int16_t  p_115);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_36(void)
{ /* block id: 36 */
    int32_t l_37 = 7;
    uint32_t l_51 = 1U;
    struct S0 l_552 = {0x445092B7,0x36DD,1,4294967289U,0xAF85561B,4294967287U};
    struct S1 l_557 = {0x9.23A13Fp+90,4U,-8,-1};
    const struct S1 *l_556 = &l_557;
    const struct S1 **l_555 = &l_556;
    const struct S1 ***l_554 = &l_555;
    const struct S1 ****l_553 = &l_554;
    uint32_t l_589 = 0U;
    int32_t l_595 = 0xB40B7054;
    struct S0 *l_616 = (void*)0;
    struct S0 **l_615 = &l_616;
    struct S0 ***l_614 = &l_615;
    struct S0 ****l_613 = &l_614;
    for (l_37 = 0; (l_37 != (-19)); --l_37)
    { /* block id: 39 */
        uint32_t l_42 = 0xE11914CC;
        struct S1 **l_560 = (void*)0;
        struct S1 ***l_559 = &l_560;
        struct S1 ****l_558 = &l_559;
        int32_t l_561 = 2;
        int16_t l_578 = 0xCCDB;
        if ((((int16_t)l_42 << (int16_t)(l_37 >= l_42)) || l_37))
        { /* block id: 40 */
            struct S1 l_49 = {0x8.B40284p+19,65535U,0xACC1,0};
            struct S0 l_50 = {0xE1289ED5,2,0,1U,0xBFA08552,0xD14CA72C};
            int32_t *l_571 = &l_37;
            int32_t **l_610 = &l_571;
            l_561 = ((((float)(-0x6.6p-1) - (float)(func_45(l_49, l_50, __builtin_popcountl(l_51)) == ((func_59(l_42, l_552, (l_553 == l_558), l_50.f4) <= l_50.f0) >= 0x0.Bp-1))) >= l_42) <= (-0x4.8p-1));
            for (l_42 = 0; (l_42 != 60); ++l_42)
            { /* block id: 354 */
                int32_t * const *l_582 = &l_571;
                int32_t * const **l_581 = &l_582;
                int32_t * const ***l_584 = &l_581;
                int32_t * const ****l_583 = &l_584;
                float l_592 = 0x9.Ap+1;
                int32_t *l_598 = &l_561;
                for (l_49.f1 = 0; (l_49.f1 != 22); l_49.f1++)
                { /* block id: 357 */
                    int32_t l_577 = 0xBED10270;
                    int32_t * const *l_580 = &l_571;
                    int32_t * const **l_579 = &l_580;
                    for (l_51 = (-29); (l_51 != 57); l_51 += 2)
                    { /* block id: 360 */
                        int32_t **l_568 = (void*)0;
                        int32_t *l_570 = &l_561;
                        int32_t **l_569 = &l_570;
                        int32_t *l_572 = &l_561;
                        (*l_569) = &l_37;
                        /* statement id: 361 */
                        assert (l_570 == &l_37);
                        (*l_572) = (l_571 != (void*)0);
                    }
                    if (((((0x5E6F & (~0xDD2755A4)) > (~(l_561 || __builtin_ia32_crc32qi(l_561, (((int16_t)((l_577 <= (-3)) >= l_577) % (int16_t)l_578) != (l_579 == l_581)))))) == 1) < l_578))
                    { /* block id: 364 */
                        uint16_t l_594 = 0x3EED;
                        int32_t **l_596 = &l_571;
                        float *l_597 = &l_557.f0;
                        l_583 = (void*)0;
                        /* statement id: 365 */
                        assert (l_583 == 0);
                        l_595 = (__builtin_popcount(((int16_t)8 << (int16_t)13)) == (l_37 == ((((int16_t)(l_589 < (&l_50 == &l_552)) + (int16_t)((int16_t)(*l_571) << (int16_t)6)) > (((-(int16_t)(0x2B90 | (-2))) < (***l_581)) != l_594)) && l_552.f4)));
                        (*l_596) = l_571;
                        (*l_597) = l_552.f3;
                    }
                    else
                    { /* block id: 369 */
                        l_595 = (***l_581);
                        l_598 = (void*)0;
                        /* statement id: 371 */
                        assert (l_598 == 0);
                    }
                }
                /* facts after for loop */
                assert (l_583 == &l_584 || l_583 == 0);
                assert (l_598 == 0 || l_598 == &l_561);
                for (l_50.f3 = 22; (l_50.f3 < 10); l_50.f3 -= 5)
                { /* block id: 376 */
                    const int32_t *l_602 = (void*)0;
                    const int32_t **l_601 = &l_602;
                    (*l_601) = (**l_581);
                    /* statement id: 377 */
                    assert (l_602 == &l_37);
                }
            }
            (*l_610) = func_91(l_557.f1, ((*l_571) == ((((uint16_t)((((int16_t)__builtin_clz(l_51) - (int16_t)__builtin_popcountll((~(((((((int16_t)((*l_571) < l_42) >> (int16_t)9) && ((void*)0 != l_571)) >= l_552.f2) != (*l_571)) == 0x49092B03) == l_552.f5)))) & 65530U) != l_557.f2) << (uint16_t)2) | 0U) && l_561)), l_561, &l_561);
            /* statement id: 380 */
            assert (l_571 == &l_561);
            for (l_42 = 15; (l_42 < 8); l_42--)
            { /* block id: 383 */
                return l_51;
            }
        }
        else
        { /* block id: 386 */
            struct S0 *****l_617 = &l_613;
            (*l_617) = l_613;
        }
    }
    return l_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_45(struct S1  p_46, struct S0  p_47, uint16_t  p_48)
{ /* block id: 41 */
    struct S1 l_58 = {-0x4.Ap+1,1U,0xCEDB,-1};
    float *l_491 = (void*)0;
    float *l_492 = (void*)0;
    float *l_493 = &l_58.f0;
    int32_t l_498 = (-3);
    struct S1 ** const * const l_534 = (void*)0;
    uint32_t l_550 = 4294967291U;
    int32_t l_551 = 0xE1F16F2C;
    (*l_493) = ((float)(((float)(func_56(l_58) > 0x5.0C0662p-52) - (float)l_58.f1) <= l_58.f2) + (float)p_46.f0);
lbl_523:
    for (p_47.f5 = 0; (p_47.f5 < 15); p_47.f5++)
    { /* block id: 294 */
        const int32_t l_497 = 0;
        const int32_t *l_496 = &l_497;
        l_496 = (void*)0;
        /* statement id: 295 */
        assert (l_496 == 0);
    }
    l_498 = p_47.f2;
    for (l_498 = 0; (l_498 < 16); l_498 += 8)
    { /* block id: 300 */
        int32_t *l_507 = &l_498;
        struct S1 *l_515 = &l_58;
        struct S1 **l_514 = &l_515;
        struct S1 ***l_513 = &l_514;
        struct S1 ****l_512 = &l_513;
        if (((uint16_t)0x5524 << (uint16_t)p_47.f3))
        { /* block id: 301 */
            struct S1 ****l_520 = &l_513;
            int32_t l_522 = 0x949A61FA;
            for (p_47.f5 = 0; (p_47.f5 < 46); p_47.f5 += 5)
            { /* block id: 304 */
                struct S1 ****l_516 = (void*)0;
                if (p_47.f4)
                    break;
            }
            if (((uint32_t)(((*l_507) | ((l_520 != (void*)0) < p_47.f2)) || 0x0E8362BC) + (uint32_t)p_47.f0))
            { /* block id: 321 */
                uint32_t l_521 = 0U;
                int32_t **l_526 = &l_507;
                if ((*l_507))
                { /* block id: 322 */
                    if (l_521)
                    { /* block id: 323 */
                        (*l_493) = l_522;
                        return l_522;
                    }
                    else
                    { /* block id: 326 */
                        if (l_522)
                            goto lbl_523;
                    }
                    if (l_498)
                        break;
                }
                else
                { /* block id: 330 */
                    (*l_493) = (__builtin_bswap32(l_498) == (p_47.f0 > ((float)p_46.f0 + (float)l_498)));
                }
                (*l_526) = l_507;
                if (((int16_t)(((int16_t)((+(p_47.f3 > ((uint16_t)l_522 >> (uint16_t)(((void*)0 != l_534) > __builtin_popcount(p_47.f4))))) | ((int16_t)0 + (int16_t)p_47.f3)) + (int16_t)l_522) && l_58.f3) << (int16_t)14))
                { /* block id: 334 */
                    (*l_526) = (*l_526);
                }
                else
                { /* block id: 336 */
                    (*l_526) = (*l_526);
                }
            }
            else
            { /* block id: 339 */
                int32_t *l_537 = &l_522;
                int32_t **l_538 = &l_507;
                struct S0 l_540 = {1U,-3,-2,0xC7BAD7CD,3U,4294967295U};
                struct S0 *l_539 = &l_540;
                struct S0 **l_541 = (void*)0;
                struct S0 **l_542 = &l_539;
                l_537 = l_537;
                (*l_538) = l_537;
                /* statement id: 341 */
                assert (l_507 == &l_522);
                (*l_542) = l_539;
            }
            /* facts after branching */
            assert (l_507 == &l_522 || l_507 == &l_498);
        }
        else
        { /* block id: 344 */
            float l_545 = (-0x1.4p-1);
            (*l_493) = (((float)__builtin_ffsll((*l_507)) + (float)(((float)(-0x1.9p-1) + (float)((((float)(*l_507) - (float)l_498) >= 0x6.Ap-1) <= p_47.f5)) >= p_47.f1)) >= l_550);
            (*l_514) = &p_46;
            /* statement id: 346 */
            assert (l_515 == &p_46);
        }
        /* facts after branching */
        //assert (l_507 == dangling || l_507 == &l_498);
        assert (l_515 == &p_46 || l_515 == &l_58);
        l_551 = (((l_491 == l_492) || l_498) & 0x292557BF);
    }
    return l_58.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_56(struct S1  p_57)
{ /* block id: 42 */
    uint16_t l_66 = 1U;
    struct S0 l_77 = {4294967295U,0x0CD5,0xB18A,0x03ECEF36,4294967287U,1U};
    float l_483 = 0xF.C10232p-56;
    float *l_482 = &l_483;
    int32_t **l_487 = (void*)0;
    int32_t ***l_486 = &l_487;
    int32_t l_490 = 1;
    int32_t *l_489 = &l_490;
    int32_t **l_488 = &l_489;
    (*l_482) = func_59((((int16_t)(((l_66 >= ((int16_t)((-4) & (((int16_t)p_57.f1 >> (int16_t)0) | ((uint32_t)(l_66 > (((((-1) <= (((((uint32_t)(l_66 > ((((uint16_t)(l_66 > (__builtin_ia32_crc32qi(p_57.f3, p_57.f1) <= 0x7358)) - (uint16_t)p_57.f3) != p_57.f3) < 4294967290U)) + (uint32_t)0xD9D30CD9) != p_57.f3) != p_57.f1) || l_66)) >= p_57.f2) && 0x7422) == l_66)) - (uint32_t)l_66))) >> (int16_t)l_66)) <= l_66) != l_66) << (int16_t)5) >= 3), l_77, p_57.f2, p_57.f2);
    (*l_488) = func_91(((1U | p_57.f3) >= ((l_77.f1 >= ((uint16_t)p_57.f1 << (uint16_t)(((-1) == ((l_486 == (void*)0) >= 0x2C25)) >= p_57.f2))) > p_57.f1)), l_77.f3, p_57.f3, l_482);
    /* statement id: 289 */
    assert (l_489 == &l_483);
    return p_57.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_59(int16_t  p_60, struct S0  p_61, uint32_t  p_62, const uint16_t  p_63)
{ /* block id: 43 */
    int32_t l_81 = 0x5D54DBC7;
    int32_t *l_80 = &l_81;
    l_80 = func_78(l_80);
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_78(int32_t * p_79)
{ /* block id: 44 */
    uint32_t l_82 = 1U;
    int32_t l_101 = 0x159E9DC6;
    int32_t l_103 = 0x20CA5725;
    int32_t *l_481 = &l_101;
    if (l_82)
    { /* block id: 45 */
        const float l_85 = 0xE.20B692p-79;
        int32_t l_98 = (-5);
        uint16_t l_102 = 0x7628;
        float *l_477 = (void*)0;
        float l_479 = (-0x1.4p-1);
        float *l_478 = &l_479;
        (*l_478) = (((float)0xE.FF7B51p-53 - (float)l_85) < func_86(func_89(func_91((0 & (l_82 == ((l_98 || ((uint16_t)l_98 % (uint16_t)l_98)) == l_82))), (l_101 ^ l_102), l_103, &l_101)), p_79));
    }
    else
    { /* block id: 282 */
        int32_t *l_480 = &l_101;
        l_481 = l_480;
    }
    return p_79;
    /* statement id: 285 */
    //assert (func_78_rv == &l_81);
}


/* ------------------------------------------ */
/* 
 * reads : l_81
 * writes: l_81
 */
static float  func_86(int32_t * p_87, int32_t * p_88)
{ /* block id: 238 */
    int32_t l_417 = 0x718AAE45;
    uint32_t l_425 = 1U;
    float l_429 = 0xA.7CDB1Fp-10;
    int32_t l_431 = 1;
    int32_t *l_430 = &l_431;
    int32_t **l_432 = &l_430;
    struct S1 **l_436 = (void*)0;
    struct S0 l_455 = {0x46D6A43C,-1,1,0x878CFAC5,0xC3AD2EF7,0x4E7BD56A};
    struct S0 *l_454 = &l_455;
    struct S0 **l_453 = &l_454;
    struct S1 ** const *l_460 = (void*)0;
    struct S1 ** const **l_459 = &l_460;
    (*l_432) = func_91(l_417, l_417, ((((((((uint32_t)(((uint32_t)((int16_t)0x1F95 >> (int16_t)3) + (uint32_t)(l_417 != l_417)) ^ ((l_417 || (((~l_417) || (l_425 <= ((uint16_t)(~l_425) << (uint16_t)10))) < l_417)) & (*p_88))) % (uint32_t)l_417) < l_417) == (-1)) <= (*p_88)) ^ l_425) != l_417) < l_417), l_430);
    if ((*l_430))
    { /* block id: 240 */
        uint16_t l_433 = 3U;
        struct S1 l_439 = {-0x1.1p-1,65532U,-8,0x01A00784};
        struct S1 *l_438 = &l_439;
        struct S1 **l_437 = &l_438;
        (*p_88) = (((*p_88) != 0xD6A5D7A0) == l_433);
        (*p_88) = (((int32_t)(l_436 != l_437) + (int32_t)(**l_432)) | (((*l_430) >= ((((void*)0 == &l_438) || ((uint16_t)((**l_432) | ((uint32_t)((*l_430) || ((uint32_t)l_439.f2 - (uint32_t)(*p_88))) - (uint32_t)0U)) << (uint16_t)l_439.f2)) > l_439.f2)) <= 1U));
        if ((((int16_t)(**l_432) >> (int16_t)1) != (**l_432)))
        { /* block id: 243 */
            const int16_t l_452 = 1;
            for (l_431 = 29; (l_431 < (-24)); --l_431)
            { /* block id: 246 */
                float *l_456 = &l_429;
                (*l_456) = ((float)l_452 + (float)(l_453 != (void*)0));
            }
        }
        else
        { /* block id: 249 */
lbl_471:
            for (l_439.f3 = 0; (l_439.f3 < (-1)); l_439.f3--)
            { /* block id: 252 */
                int32_t l_467 = (-9);
                (*p_88) = (*p_88);
                l_459 = l_459;
                if (l_439.f3)
                    goto lbl_471;
                for (l_425 = 7; (l_425 < 42); l_425++)
                { /* block id: 257 */
                    int32_t l_470 = 0xFB09E31F;
                    for (l_455.f2 = 20; (l_455.f2 != (-30)); l_455.f2--)
                    { /* block id: 260 */
                        (*l_430) = ((int16_t)l_467 - (int16_t)((uint16_t)(l_470 ^ l_433) >> (uint16_t)__builtin_popcountll(l_470)));
                    }
                    (*l_430) = (1 != l_470);
                }
                return l_433;
            }
            return l_433;
        }
    }
    else
    { /* block id: 270 */
        (*l_430) = ((*l_430) >= (**l_432));
    }
    for (l_455.f1 = 0; (l_455.f1 < 0); l_455.f1++)
    { /* block id: 275 */
        int32_t l_476 = 0xD7C74CE6;
        if ((**l_432))
            break;
        (*l_430) = (((int16_t)(**l_432) << (int16_t)5) > l_476);
    }
    (*l_432) = p_87;
    /* statement id: 279 */
    //assert (l_430 == &l_101 || l_430 == 0);
    return l_455.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_89(int32_t * p_90)
{ /* block id: 194 */
    uint32_t l_356 = 0x2ED9C985;
    int32_t l_363 = 0xBDC7D750;
    int32_t *l_362 = &l_363;
    int32_t **l_361 = &l_362;
    int32_t *l_416 = (void*)0;
    (*l_361) = func_91(l_356, l_356, ((int16_t)0x139B + (int16_t)((uint32_t)l_356 % (uint32_t)l_356)), p_90);
    /* statement id: 195 */
    //assert (l_362 == &l_101);
    for (l_363 = 0; (l_363 < (-8)); l_363 -= 7)
    { /* block id: 198 */
        int32_t l_366 = (-1);
        int32_t *l_379 = &l_363;
        struct S1 ** const l_382 = (void*)0;
        struct S1 **l_383 = (void*)0;
        const uint32_t l_386 = 0x6652550F;
        struct S0 l_406 = {4294967294U,0xC0AC,0x0EDD,0x6B2D1BC9,0xADE45835,0x9A151ED1};
        struct S0 * const l_405 = &l_406;
        struct S0 * const *l_404 = &l_405;
        (*l_361) = func_91(l_366, l_366, (*l_362), (*l_361));
        for (l_356 = 7; (l_356 <= 27); l_356 += 1)
        { /* block id: 202 */
            int32_t l_373 = 0x8704BFAE;
            float l_374 = 0x3.20B833p-44;
            struct S1 ***l_400 = &l_383;
            struct S1 l_410 = {0xB.187E16p-67,0U,0x6289,0x290C4CCB};
            struct S1 *l_409 = &l_410;
            float *l_415 = &l_410.f0;
            for (l_366 = 0; (l_366 >= 7); ++l_366)
            { /* block id: 205 */
                int32_t l_375 = (-1);
                float *l_387 = (void*)0;
                float *l_388 = (void*)0;
                float *l_389 = (void*)0;
                float *l_390 = &l_374;
                struct S0 **l_395 = (void*)0;
                if ((((uint32_t)(l_366 == l_373) + (uint32_t)0xD62FD04E) == 9))
                { /* block id: 206 */
                    l_373 = (((l_374 >= l_373) >= 0x9.8p-1) < l_375);
                }
                else
                { /* block id: 208 */
                    float l_380 = 0x9.88E628p+43;
                    int32_t l_381 = 9;
                    for (l_375 = (-11); (l_375 <= (-17)); --l_375)
                    { /* block id: 211 */
                        uint32_t l_378 = 0x6F8027C9;
                        (*l_361) = p_90;
                        p_90 = func_91(l_381, l_373, l_378, p_90);
                    }
                    l_383 = l_382;
                }
                (*l_361) = l_379;
                /* statement id: 217 */
                assert (l_362 == &l_363);
                (*l_390) = ((&l_375 == p_90) < ((float)((((*l_379) < ((0xB.E0A52Fp+11 == (l_375 <= ((l_386 == l_375) >= (0x0.7p+1 == ((*l_379) > 0x4.47A6F8p+58))))) != l_373)) >= l_375) >= (*l_362)) + (float)(-0x7.5p-1)));
                if ((((int16_t)(7U > (((int16_t)((((void*)0 != l_395) | ((int16_t)(*l_362) << (int16_t)14)) > ((uint16_t)0U >> (uint16_t)(((void*)0 == l_400) != ((0xA0CA31FB <= (~l_375)) ^ (**l_361))))) << (int16_t)(*l_379)) <= (*l_379))) << (int16_t)6) > 0x0ED297B4))
                { /* block id: 219 */
                    int32_t *l_411 = &l_373;
                    for (l_375 = 0; (l_375 < 16); ++l_375)
                    { /* block id: 222 */
                        struct S0 ***l_407 = &l_395;
                        int32_t l_408 = 0x974B316C;
                        (*l_407) = l_404;
                        /* statement id: 223 */
                        assert (l_395 == &l_405);
                        (*l_361) = func_91(l_408, (*l_379), l_375, p_90);
                        /* statement id: 224 */
                        //assert (l_362 == &l_101);
                        l_411 = func_91(l_408, (0U == (*l_362)), ((l_375 <= __builtin_bswap32((*l_379))) > ((void*)0 != l_409)), p_90);
                        /* statement id: 225 */
                        //assert (l_411 == &l_101);
                    }
                    /* facts after for loop */
                    //assert (l_362 == &l_101 || l_362 == &l_363);
                    assert (l_395 == &l_405 || l_395 == 0);
                    //assert (l_411 == &l_101 || l_411 == &l_373);
                    return p_90;
                    /* statement id: 227 */
                    //assert (func_89_rv == &l_101);
                }
                else
                { /* block id: 228 */
                    int32_t *l_414 = &l_363;
                    (*p_90) = ((uint32_t)__builtin_popcount((**l_361)) % (uint32_t)(**l_361));
                    return p_90;
                    /* statement id: 230 */
                    //assert (func_89_rv == &l_101);
                }
            }
            (*l_415) = (*l_362);
            (*l_362) = (*p_90);
        }
    }
    return l_416;
    /* statement id: 237 */
    //assert (func_89_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_101
 * writes: l_101
 */
inline static int32_t * func_91(uint32_t  p_92, uint32_t  p_93, int16_t  p_94, int32_t * p_95)
{ /* block id: 46 */
    struct S1 l_105 = {0x0.Fp+1,65535U,2,0x167AC4CB};
    struct S1 *l_104 = &l_105;
    int32_t l_285 = 0;
    int32_t *l_284 = &l_285;
    int32_t ***l_301 = (void*)0;
    uint32_t l_345 = 3U;
    int32_t *l_354 = &l_285;
    int32_t *l_355 = &l_285;
    l_104 = (void*)0;
    /* statement id: 47 */
    assert (l_104 == 0);
    for (l_105.f3 = (-29); (l_105.f3 <= (-29)); l_105.f3 += 1)
    { /* block id: 50 */
        uint16_t l_187 = 0x331B;
        int32_t l_189 = 0;
        int32_t *l_188 = &l_189;
        struct S0 l_277 = {0x4296BABB,0xB166,-1,1U,0xAE008CDA,0xA2B93A76};
        struct S0 *l_276 = &l_277;
        struct S0 **l_275 = &l_276;
        (*l_275) = func_108(func_114(((int16_t)p_92 << (int16_t)10)), l_187, &l_105, l_188, (*l_188));
        /* statement id: 134 */
        assert (l_276 == 0);
        if (l_105.f3)
        { /* block id: 135 */
            int16_t l_291 = 2;
            struct S1 **l_304 = &l_104;
            struct S1 ***l_303 = &l_304;
            int32_t l_324 = 0xCD262044;
            uint32_t l_329 = 1U;
            for (l_277.f3 = (-20); (l_277.f3 <= 34); l_277.f3 += 1)
            { /* block id: 138 */
                uint32_t l_289 = 1U;
                int32_t *l_325 = &l_189;
                for (l_277.f2 = 0; (l_277.f2 != 8); l_277.f2 += 8)
                { /* block id: 141 */
                    uint16_t l_290 = 0x02E8;
                    int32_t * const * const *l_300 = (void*)0;
                    struct S1 ****l_305 = (void*)0;
                    struct S1 ****l_306 = &l_303;
                    int32_t *l_307 = &l_285;
                }
                (**l_303) = &l_105;
                /* statement id: 161 */
                assert (l_104 == &l_105);
                if ((((((uint16_t)9U >> (uint16_t)((uint16_t)((int32_t)((void*)0 == &l_188) + (int32_t)((uint32_t)(p_94 | (l_291 | ((uint16_t)(!(p_92 | l_289)) + (uint16_t)((p_93 || 0x3317) <= p_92)))) % (uint32_t)(*l_188))) >> (uint16_t)14)) ^ p_92) & 0x29E2) >= 0x97F1))
                { /* block id: 162 */
                    return p_95;
                    /* statement id: 163 */
                    //assert (func_91_rv == &l_101 || func_91_rv == &l_431 || func_91_rv == &l_483 || func_91_rv == &l_561);
                }
                else
                { /* block id: 164 */
                    l_324 = 0x6.6DCAA2p+76;
                    return p_95;
                    /* statement id: 166 */
                    //assert (func_91_rv == &l_101 || func_91_rv == &l_431 || func_91_rv == &l_483 || func_91_rv == &l_561);
                }
            }
            if ((*p_95))
                continue;
            l_329 = ((((__builtin_clzl((*l_188)) != (*l_284)) <= p_92) != (__builtin_ffsll((*l_188)) == ((float)l_324 - (float)((+(p_94 == (*l_284))) > 0x8.F99B6Fp+21)))) <= 0x7.8p+1);
        }
        else
        { /* block id: 171 */
            float l_332 = (-0x2.9p+1);
            int32_t l_333 = (-9);
            int32_t **l_336 = &l_284;
            struct S0 **l_346 = &l_276;
            struct S1 * const *l_352 = &l_104;
            struct S1 * const **l_351 = &l_352;
            if ((*p_95))
            { /* block id: 172 */
                return p_95;
                /* statement id: 173 */
                //assert (func_91_rv == &l_101 || func_91_rv == &l_431 || func_91_rv == &l_483 || func_91_rv == &l_561);
            }
            else
            { /* block id: 174 */
                uint16_t l_339 = 0xD611;
                float *l_353 = &l_105.f0;
                if (((int32_t)((*l_188) != 0U) + (int32_t)(0x6C6AAB39 || ((l_333 & __builtin_clzll(l_333)) > (l_333 && __builtin_ia32_crc32qi(((uint16_t)(1 | (&l_188 == l_336)) << (uint16_t)p_92), p_92))))))
                { /* block id: 175 */
                    float *l_342 = &l_332;
                    (*l_342) = (((*l_284) == (((((*l_284) != 0x1.5p-1) != ((float)((0x7.8p-1 != (**l_336)) <= l_339) - (float)((0xA.631B1Cp+90 == (((-(float)l_339) > ((!(**l_336)) < (*l_188))) < l_339)) > 0x0.Dp+1))) != 0x7.1D2B57p-30) == 0x7.EC1DAEp-11)) != p_92);
                    for (l_277.f3 = (-26); (l_277.f3 > 54); l_277.f3++)
                    { /* block id: 179 */
                        struct S0 ***l_347 = &l_346;
                        (*l_284) = l_345;
                        (*l_347) = l_346;
                        (*l_342) = p_94;
                    }
                }
                else
                { /* block id: 184 */
                    int32_t l_348 = 0xADE88CFF;
                    (*l_336) = p_95;
                    /* statement id: 185 */
                    //assert (l_284 == &l_101 || l_284 == &l_431 || l_284 == &l_483 || l_284 == &l_561);
                    (*l_284) = (l_348 == ((__builtin_parity((p_94 & (p_93 < 0x89BF))) || (*p_95)) != ((uint32_t)1U % (uint32_t)l_348)));
                }
                (*l_353) = (((-0x2.5p-1) < ((l_351 != (void*)0) >= (**l_336))) > 0x7.7AD65Fp+65);
            }
            (*l_336) = (*l_336);
        }
    }
    /* facts after for loop */
    //assert (l_284 == &l_101 || l_284 == &l_285 || l_284 == &l_431 || l_284 == &l_483 || l_284 == &l_561);
    return p_95;
    /* statement id: 193 */
    //assert (func_91_rv == &l_101 || func_91_rv == &l_431 || func_91_rv == &l_483 || func_91_rv == &l_561);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_108(struct S0 * p_109, uint32_t  p_110, struct S1 * p_111, int32_t * p_112, const uint32_t  p_113)
{ /* block id: 80 */
    float l_190 = 0x8.430F98p-89;
    int32_t l_191 = 0;
    const struct S1 *l_194 = (void*)0;
    uint16_t l_205 = 0xC0BE;
    struct S0 l_241 = {0U,0xB085,-1,0U,0U,1U};
    struct S0 *l_240 = &l_241;
    int32_t *l_269 = (void*)0;
    if (l_191)
    { /* block id: 81 */
        int32_t *l_193 = &l_191;
        int32_t **l_192 = &l_193;
        struct S1 l_197 = {0x9.12183Ap-26,5U,0x6090,0};
        struct S1 *l_196 = &l_197;
        struct S1 **l_195 = &l_196;
        (*l_192) = &l_191;
        (*l_195) = l_194;
        /* statement id: 83 */
        assert (l_196 == 0);
    }
    else
    { /* block id: 84 */
        uint32_t l_200 = 1U;
        (*p_112) = ((l_200 != (*p_112)) | (l_200 == 0));
    }
    if (((((&p_112 != (void*)0) > l_191) >= ((int16_t)((uint32_t)(l_205 < p_113) % (uint32_t)(*p_112)) >> (int16_t)8)) | (l_191 > (((void*)0 == p_112) <= 0x1794))))
    { /* block id: 87 */
        const float l_206 = 0x1.9BA216p+66;
        int32_t l_209 = 8;
        const float l_210 = 0x7.Fp+1;
        int32_t l_220 = 0xBDEBE93C;
        struct S1 l_228 = {0x6.3CE9E4p+46,65532U,-5,0};
        struct S1 *l_227 = &l_228;
        struct S1 **l_226 = &l_227;
        struct S1 * const *l_230 = &l_227;
        struct S1 * const **l_229 = &l_230;
        int32_t l_231 = 2;
        struct S0 **l_263 = (void*)0;
        (*p_112) = (*p_112);
        if ((p_113 && ((int16_t)((4294967295U || (((l_191 > ((void*)0 != p_112)) != ((p_110 || (__builtin_ia32_crc32qi(l_209, p_110) & l_209)) < l_205)) != 0x6837)) != l_209) - (int16_t)0x0C34)))
        { /* block id: 89 */
            struct S0 l_213 = {0x83291253,8,0,0x4AA58026,0xCD83BFDD,1U};
            struct S0 *l_212 = &l_213;
            struct S0 **l_211 = &l_212;
            (*l_211) = p_109;
            /* statement id: 90 */
            assert (l_212 == 0);
        }
        else
        { /* block id: 91 */
            int32_t *l_223 = &l_220;
            int32_t **l_222 = &l_223;
            int32_t ***l_221 = &l_222;
            int32_t ** const *l_225 = (void*)0;
            int32_t ** const **l_224 = &l_225;
            l_220 = ((&p_112 == &p_112) > (((float)(((p_113 > ((p_113 > ((float)l_191 - (float)((float)l_205 + (float)p_110))) == 0x3.10B782p+43)) < (((p_110 > 0x8.000169p-70) >= p_113) != l_205)) <= (-0x3.8p-1)) - (float)0xE.40BDA7p+24) != l_191));
            (*l_224) = l_221;
            /* statement id: 93 */
            assert (l_225 == &l_222);
        }
        (*l_229) = l_226;
        if (l_231)
        { /* block id: 96 */
            int32_t *l_233 = (void*)0;
            int32_t **l_232 = &l_233;
            struct S0 l_239 = {0xD6A5165A,0,-7,0U,0U,4294967294U};
            struct S0 *l_238 = &l_239;
            (*l_232) = p_112;
            /* statement id: 97 */
            //assert (l_233 == &l_189);
            for (l_220 = 0; (l_220 == (-17)); l_220 -= 1)
            { /* block id: 100 */
                for (l_209 = 0; (l_209 <= 2); ++l_209)
                { /* block id: 103 */
                    return p_109;
                    /* statement id: 104 */
                    //assert (func_108_rv == 0);
                }
            }
            (*p_112) = ((int16_t)l_228.f1 << (int16_t)10);
        }
        else
        { /* block id: 108 */
            uint32_t l_259 = 0x7FDFE881;
            for (l_231 = 12; (l_231 <= 8); l_231--)
            { /* block id: 111 */
                uint32_t l_249 = 0x71D185BE;
                struct S1 *l_267 = &l_228;
                float *l_272 = &l_190;
                (*p_112) = (p_110 && ((((int16_t)((!0xE48DE73D) == (l_249 || (l_241.f4 == (+(-(uint16_t)(~l_241.f2)))))) << (int16_t)4) | (((((int16_t)((0x8EFD < ((void*)0 != &p_109)) <= (((uint16_t)((int32_t)(p_109 != (void*)0) - (int32_t)p_113) % (uint16_t)l_259) >= l_228.f2)) << (int16_t)10) && 0x50DD6F6E) < l_249) | p_113)) >= 0x77B9CB57));
                for (p_110 = 0; (p_110 >= 37); p_110 += 9)
                { /* block id: 115 */
                    int16_t l_262 = 0x9858;
                    if (l_262)
                        break;
                    if ((l_263 != (void*)0))
                    { /* block id: 117 */
                        int32_t *l_265 = &l_220;
                        int32_t **l_264 = &l_265;
                        struct S0 **l_266 = &l_240;
                        (*l_264) = p_112;
                        /* statement id: 118 */
                        //assert (l_265 == &l_189);
                        l_266 = &p_109;
                        /* statement id: 119 */
                        assert (l_266 == &p_109);
                        if ((*p_112))
                            break;
                        (*l_226) = l_267;
                    }
                    else
                    { /* block id: 122 */
                        float *l_268 = &l_190;
                        int32_t **l_270 = (void*)0;
                        int32_t **l_271 = &l_269;
                        (*l_268) = (__builtin_bswap32((4294967293U && (*p_112))) == p_113);
                        (*l_271) = l_269;
                    }
                }
                (*l_272) = l_259;
            }
        }
    }
    else
    { /* block id: 130 */
        int32_t l_274 = 5;
        (*p_112) = (!l_274);
    }
    return p_109;
    /* statement id: 133 */
    //assert (func_108_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_114(int16_t  p_115)
{ /* block id: 51 */
    uint32_t l_118 = 0x41CECC2F;
    const struct S1 *l_125 = (void*)0;
    const struct S1 **l_124 = &l_125;
    int32_t l_127 = 0x6A5B839C;
    int32_t *l_126 = &l_127;
    struct S0 *l_147 = (void*)0;
    uint16_t l_182 = 0x160F;
    int32_t l_183 = 0;
    int16_t l_184 = 0xEDDB;
    int32_t *l_185 = (void*)0;
    int32_t *l_186 = &l_127;
    if (l_118)
    { /* block id: 52 */
        struct S1 l_123 = {0xF.62E968p-85,0U,0x1F5D,-5};
        const struct S1 *l_122 = &l_123;
        const struct S1 **l_121 = &l_122;
        int32_t *l_143 = &l_127;
        struct S0 l_146 = {0xF56540EC,0x16C3,0xCF3F,0xEAB44AF1,0x809F8260,4294967293U};
        struct S0 *l_145 = &l_146;
        for (p_115 = (-14); (p_115 <= 17); p_115++)
        { /* block id: 55 */
            int32_t **l_128 = &l_126;
            float *l_129 = &l_123.f0;
            l_124 = l_121;
            /* statement id: 56 */
            assert (l_124 == &l_122);
            (*l_128) = l_126;
            (*l_129) = ((*l_124) != (void*)0);
            for (l_118 = 0; (l_118 >= 50); l_118 += 7)
            { /* block id: 61 */
                float *l_134 = (void*)0;
                int32_t l_136 = 0xCBBBBCA1;
                int32_t *l_144 = &l_127;
            }
        }
        /* facts after for loop */
        assert (l_124 == &l_122 || l_124 == &l_125);
    }
    else
    { /* block id: 73 */
        float l_149 = 0x0.Fp+1;
        float *l_148 = &l_149;
        int32_t **l_150 = (void*)0;
        int32_t **l_151 = (void*)0;
        (*l_148) = 0xD.1B4A57p-83;
        l_126 = (void*)0;
        /* statement id: 75 */
        assert (l_126 == 0);
    }
    /* facts after branching */
    //assert (l_124 == dangling || l_124 == &l_125);
    assert (l_126 == 0 || l_126 == &l_127);
    (*l_186) = (+((int32_t)((uint16_t)((p_115 || (+(((((uint32_t)((~((int32_t)((((((((((uint16_t)((((int16_t)p_115 % (int16_t)((int16_t)((uint32_t)(~(65534U && 0x62EA)) + (uint32_t)(p_115 | 2U)) >> (int16_t)(l_147 != (void*)0))) | ((uint16_t)(((((int16_t)((int32_t)(-(int16_t)(+((int16_t)l_127 >> (int16_t)1))) + (int32_t)p_115) >> (int16_t)8) || l_118) ^ p_115) <= 1U) % (uint16_t)p_115)) ^ 1) >> (uint16_t)l_118) && p_115) > l_182) | 0x982E9718) | l_183) & 0x0E50) == 0x1194) >= p_115) <= p_115) + (int32_t)p_115)) & l_182) - (uint32_t)p_115) != l_127) >= l_127) > 1))) & 2U) >> (uint16_t)l_127) - (int32_t)l_184));
    (*l_186) = p_115;
    return l_147;
    /* statement id: 79 */
    //assert (func_114_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_36();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 154
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 185
   depth: 2, occurrence: 37
   depth: 3, occurrence: 5
   depth: 4, occurrence: 6
   depth: 5, occurrence: 6
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 5
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 19, occurrence: 1
   depth: 22, occurrence: 2
   depth: 32, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 176

XXX times a variable address is taken: 149
XXX times a pointer is dereferenced on RHS: 76
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 14
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 84
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 190

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 427
   level: 2, occurrence: 65
   level: 3, occurrence: 6
XXX number of pointers point to pointers: 84
XXX number of pointers point to scalars: 66
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 30.1
XXX average alias set size: 1.22

XXX times a non-volatile is read: 642
XXX times a non-volatile is write: 232
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 173
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 27
   depth: 2, occurrence: 31
   depth: 3, occurrence: 30
   depth: 4, occurrence: 27
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 27.6
XXX percentage an existing variable is used: 72.4
********************* end of statistics **********************/

