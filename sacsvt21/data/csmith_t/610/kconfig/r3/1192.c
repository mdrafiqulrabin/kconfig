/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      224230752
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const uint32_t  f0;
   signed f1 : 27;
   signed f2 : 17;
   int32_t  f3;
   unsigned f4 : 10;
   signed f5 : 14;
   signed f6 : 23;
};

union U1 {
   uint16_t  f0;
   uint16_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_1(void);
static int32_t * func_2(int32_t * p_3, int32_t  p_4, union U1  p_5);
inline static int16_t  func_18(union U1  p_19, int32_t * p_20);
static int32_t * func_24(int32_t * p_25, int32_t * p_26, struct S0  p_27);
static int32_t * func_28(int32_t  p_29, uint8_t  p_30);
static uint32_t  func_32(uint32_t  p_33);
inline static int32_t * func_41(int32_t  p_42, union U1  p_43, int8_t  p_44, uint32_t  p_45);
inline static int32_t * func_63(int8_t  p_64, int32_t * p_65, int32_t * const  p_66);
inline static int32_t * func_80(int32_t  p_81, int32_t * p_82, uint16_t  p_83, const int32_t * p_84, int8_t  p_85);
static const int32_t * func_88(int32_t * p_89, uint32_t  p_90, const int32_t  p_91, int32_t * p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_7 = (-1);
    int32_t *l_6 = &l_7;
    union U1 l_8 = {0xEDBD};
    int32_t **l_942 = &l_6;
    int8_t l_943 = 0x6A;
    (*l_942) = func_2(l_6, (*l_6), l_8);
    /* statement id: 372 */
    assert (l_6 == 0);
    return l_943;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_2(int32_t * p_3, int32_t  p_4, union U1  p_5)
{ /* block id: 1 */
    uint8_t l_15 = 249U;
    union U1 l_21 = {0x0513};
    int32_t l_23 = 0x9A130DFD;
    int32_t *l_22 = &l_23;
    union U1 *l_757 = &l_21;
    union U1 **l_756 = &l_757;
    union U1 *** const l_755 = &l_756;
    union U1 *** const *l_754 = &l_755;
    uint8_t l_772 = 0x6F;
    uint16_t l_773 = 0x1639;
    union U1 ***l_777 = &l_756;
    union U1 **** const l_776 = &l_777;
    uint16_t l_797 = 1U;
    struct S0 **l_816 = (void*)0;
    uint32_t l_819 = 0U;
    int32_t **l_868 = &l_22;
    int32_t ***l_867 = &l_868;
    int32_t *l_872 = &l_23;
    int32_t *l_927 = &l_23;
    int32_t *l_929 = (void*)0;
    int32_t *l_930 = &l_23;
    int32_t *l_931 = &l_23;
    int32_t *l_932 = &l_23;
    int32_t *l_933 = &l_23;
    int32_t *l_934 = &l_23;
    int32_t *l_935 = &l_23;
    int32_t *l_936 = &l_23;
    int32_t *l_937 = &l_23;
    int32_t *l_938 = &l_23;
    int32_t *l_939 = &l_23;
    int32_t *l_940 = &l_23;
    int32_t *l_941 = (void*)0;
    (*l_22) = (((safe_add_func_int16_t_s_s(p_5.f1, (safe_add_func_uint16_t_u_u(((safe_mod_func_uint8_t_u_u((&p_4 != (void*)0), 1)) & l_15), (-4))))) > ((safe_sub_func_int16_t_s_s((func_18(l_21, l_22) == p_5.f0), p_5.f0)) <= (*l_22))) > (*l_22));
    if ((((l_754 == &l_755) > ((safe_add_func_int32_t_s_s((p_5.f1 != (p_5.f0 == ((((((safe_div_func_int32_t_s_s(((void*)0 == &l_755), (safe_rshift_func_int16_t_s_u((safe_mod_func_int32_t_s_s((1 <= (safe_rshift_func_int16_t_s_s((((safe_rshift_func_uint8_t_u_u(((safe_mod_func_int16_t_s_s(p_5.f1, l_772)) || l_773), (*l_22))) | 4) || 0xA05F558A), 2))), 0x7DF62456)), 0)))) < p_5.f0) & p_4) && (*l_22)) ^ p_5.f0) != (*p_3)))), (*l_22))) < (*l_22))) || p_5.f0))
    { /* block id: 319 */
        int32_t l_795 = (-7);
        for (l_21.f1 = (-26); (l_21.f1 >= 41); l_21.f1 = safe_add_func_uint16_t_u_u(l_21.f1, 7))
        { /* block id: 322 */
            union U1 * const ***l_779 = (void*)0;
            union U1 * const ****l_778 = &l_779;
            int32_t l_796 = 0x73292DC9;
            (*l_778) = l_776;
            /* statement id: 323 */
            assert (l_779 == &l_777);
            (*l_22) = (safe_div_func_int16_t_s_s(((0x62 <= (safe_div_func_int32_t_s_s((((*l_754) == (void*)0) == (safe_rshift_func_uint16_t_u_s((p_4 && (safe_lshift_func_uint8_t_u_s((safe_div_func_int16_t_s_s(p_5.f0, (((safe_add_func_uint8_t_u_u((safe_lshift_func_int8_t_s_s((((~p_5.f1) | (l_795 != (l_796 ^ 0x21FF5F84))) == p_5.f1), 5)), 255U)) != (*p_3)) | p_5.f1))), 2))), l_797))), 0x56DD31CF))) || 0xC4BB), p_5.f1));
        }
        /* facts after for loop */
            }
    else
    { /* block id: 326 */
        uint16_t l_798 = 0x41D0;
        int32_t l_820 = 0xEE4069D7;
        union U1 ****l_852 = &l_777;
        int32_t l_882 = (-1);
        int32_t ***l_890 = &l_868;
        (*p_3) = 0;
        if (l_798)
        { /* block id: 328 */
            int32_t l_811 = 0x749AFC8E;
            const struct S0 *l_829 = (void*)0;
            int32_t *** const l_869 = &l_868;
            union U1 ***l_881 = &l_756;
            int32_t l_885 = 0xB12A4766;
            union U1 * const *l_895 = &l_757;
            union U1 * const **l_894 = &l_895;
            union U1 * const ***l_893 = &l_894;
            union U1 * const ****l_892 = &l_893;
            l_820 = (safe_lshift_func_int16_t_s_u((safe_lshift_func_int8_t_s_s((safe_div_func_int16_t_s_s((((*l_754) == (void*)0) > (safe_rshift_func_uint16_t_u_u(l_798, (safe_rshift_func_int16_t_s_s((safe_rshift_func_int8_t_s_s(l_811, (p_5.f0 > (safe_rshift_func_uint8_t_u_u(((l_798 < ((safe_rshift_func_int8_t_s_u(((void*)0 != l_816), 5)) <= ((safe_rshift_func_uint16_t_u_u(((((((((l_811 != l_819) > p_4) < 1) == (*p_3)) < 0x077C87F6) <= 0x6B) | (-1)) | 5), l_798)) != 5U))) && (*l_22)), 6))))), 13))))), p_4)), p_5.f1)), l_798));
            for (l_819 = 5; (l_819 != 41); l_819 = safe_add_func_uint8_t_u_u(l_819, 3))
            { /* block id: 332 */
                struct S0 l_831 = {0U,-3352,17,0x3E25E155,29,111,-1630};
                struct S0 *l_830 = &l_831;
                uint32_t l_883 = 0xFB882C12;
                union U1 * const *l_887 = &l_757;
                union U1 * const **l_886 = &l_887;
                int32_t *l_891 = &l_831.f3;
            }
            (*l_892) = (void*)0;
            /* statement id: 349 */
            assert (l_893 == 0);
            (***l_867) = (***l_890);
        }
        else
        { /* block id: 351 */
            for (p_4 = 26; (p_4 != (-10)); p_4--)
            { /* block id: 354 */
                (**l_890) = (void*)0;
                /* statement id: 355 */
                assert (l_22 == 0);
            }
            /* facts after for loop */
            assert (l_22 == 0 || l_22 == &l_23);
        }
        /* facts after branching */
        assert (l_22 == 0 || l_22 == &l_23);
        (*l_890) = (*l_867);
    }
    /* facts after branching */
        assert (l_22 == 0 || l_22 == &l_23);
    for (p_5.f1 = 0; (p_5.f1 <= 49); p_5.f1 = safe_add_func_uint16_t_u_u(p_5.f1, 1))
    { /* block id: 362 */
        uint32_t l_902 = 0x5CBCBA06;
        int16_t l_911 = 1;
        const int32_t *l_925 = &l_23;
        int32_t *l_926 = &l_23;
        if (((((*p_3) == (((-1) || ((safe_lshift_func_uint8_t_u_u(0x15, 2)) >= ((*l_872) >= (*p_3)))) || l_902)) && ((((~0x7A) >= ((safe_add_func_int8_t_s_s((((safe_mod_func_uint32_t_u_u(((((((*p_3) & (!(safe_lshift_func_uint16_t_u_s((((*l_754) == (void*)0) == l_911), l_911)))) != 255U) != 0U) >= l_902) <= 0xCF5CE687), (*p_3))) != p_5.f0) != p_5.f0), 0x28)) ^ p_5.f1)) != 0x8BB80810) && p_5.f0)) | 0xD741E189))
        { /* block id: 363 */
            const struct S0 l_913 = {0xCFA586B7,-5999,67,0xD5C8B925,24,17,2211};
            const struct S0 *l_912 = &l_913;
            (**l_867) = (void*)0;
            /* statement id: 364 */
            assert (l_22 == 0);
            (*l_868) = func_80((l_912 != &l_913), (*l_868), (safe_sub_func_uint16_t_u_u(((safe_sub_func_uint8_t_u_u((((safe_mod_func_int32_t_s_s((p_4 & ((-1) & (((0x6AAE4366 >= ((-1) < l_902)) > ((((safe_mod_func_int16_t_s_s((safe_unary_minus_func_uint32_t_u(0U)), 0xDE97)) && 0xF864) != p_5.f0) >= l_913.f1)) == (*l_872)))), 0x010D599F)) ^ p_5.f1) > p_5.f0), (*l_872))) > 0x1A97), p_4)), l_925, l_913.f0);
        }
        else
        { /* block id: 366 */
            int32_t *l_928 = &l_23;
            return l_929;
            /* statement id: 367 */
            //assert (func_2_rv == 0);
        }
        /* facts after branching */
        assert (l_22 == 0);
        (**l_867) = (void*)0;
    }
    /* facts after for loop */
        return l_941;
    /* statement id: 371 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_18(union U1  p_19, int32_t * p_20)
{ /* block id: 2 */
    int32_t l_36 = 0x633933B8;
    struct S0 l_722 = {0xC8D7D62A,9277,-14,0x0E7C56A3,19,1,-483};
    int16_t l_737 = (-1);
    union U1 ****l_747 = (void*)0;
    p_20 = func_24(p_20, func_28(((0xBF3B8CFF >= ((!func_32((safe_div_func_uint8_t_u_u(p_19.f0, (((((p_20 == (void*)0) == (*p_20)) >= l_36) && ((!((p_19.f1 > 1) || l_36)) >= l_36)) & 0xE905F4D0))))) > 1)) == l_36), l_36), l_722);
    /* statement id: 306 */
    assert (p_20 == 0);
    for (p_19.f0 = (-23); (p_19.f0 == 24); ++p_19.f0)
    { /* block id: 309 */
        int16_t l_725 = 0x7E22;
        union U1 **l_728 = (void*)0;
        union U1 *** const l_727 = &l_728;
        union U1 *** const *l_726 = &l_727;
        union U1 ***l_730 = &l_728;
        union U1 ****l_729 = &l_730;
        if ((l_725 || (l_726 == l_729)))
        { /* block id: 310 */
            return p_19.f0;
        }
        else
        { /* block id: 312 */
            uint16_t l_751 = 0xA214;
            l_722.f1 = ((safe_rshift_func_uint8_t_u_u(((((safe_mod_func_uint32_t_u_u((((((((safe_add_func_int32_t_s_s((l_737 == (safe_mod_func_uint16_t_u_u((0x7BFB84A2 < p_19.f0), p_19.f1))), 0x10BD9416)) & (safe_div_func_uint32_t_u_u(((((safe_add_func_int32_t_s_s((~((safe_mod_func_uint8_t_u_u(((l_722.f4 != (l_747 == l_747)) == (((safe_unary_minus_func_uint32_t_u((safe_mod_func_uint16_t_u_u((((p_19.f1 == p_19.f1) <= 0x55) > l_722.f6), l_751)))) ^ l_751) == 0)), l_725)) & 2U)), 0x10B0D003)) != p_19.f1) != 0U) & 0x8227B8D6), l_725))) && l_725) == p_19.f0) || 0) < l_725) ^ p_19.f1), p_19.f0)) | l_725) ^ 0) < p_19.f1), p_19.f1)) == 0x28);
        }
        if (l_725)
            continue;
    }
    return p_19.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_24(int32_t * p_25, int32_t * p_26, struct S0  p_27)
{ /* block id: 304 */
    return p_26;
    /* statement id: 305 */
    //assert (func_24_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_28(int32_t  p_29, uint8_t  p_30)
{ /* block id: 6 */
    uint32_t l_48 = 1U;
    union U1 l_50 = {1U};
    int32_t l_654 = 0xD2499436;
    const int32_t *l_653 = &l_654;
    struct S0 l_665 = {0U,-5896,284,0,12,-30,168};
    struct S0 *l_664 = &l_665;
    struct S0 ** const l_663 = &l_664;
    int32_t l_706 = 0x6B0DB3F9;
    int32_t *l_715 = &l_665.f3;
    int32_t *l_716 = &l_706;
    int32_t *l_717 = &l_665.f3;
    int32_t *l_718 = &l_665.f3;
    int32_t *l_719 = &l_706;
    int32_t *l_720 = &l_706;
    int32_t *l_721 = (void*)0;
    if (((0x2F52 & (-1)) || func_32(((safe_unary_minus_func_int8_t_s(p_29)) || p_29))))
    { /* block id: 7 */
        int16_t l_49 = (-8);
        int32_t l_649 = 0x9E872F02;
        const int32_t *l_648 = &l_649;
        const int32_t **l_647 = &l_648;
        struct S0 l_651 = {0xA43A7006,9169,-352,1,18,-88,-1670};
        struct S0 *l_650 = &l_651;
        struct S0 **l_652 = &l_650;
        union U1 *l_672 = &l_50;
        int16_t l_703 = 0xF9D6;
        (*l_647) = func_41((p_30 != (safe_mod_func_int32_t_s_s(l_48, l_49))), l_50, func_32((((((safe_lshift_func_uint16_t_u_u(l_50.f1, 8)) < (safe_rshift_func_int8_t_s_u(((safe_rshift_func_uint8_t_u_s(l_48, (p_29 & p_30))) <= (safe_mod_func_uint16_t_u_u((9 | 0x38E5EFB4), l_49))), p_29))) != (-4)) & 4294967295U) == 0xF9BD)), p_30);
        /* statement id: 276 */
        assert (l_648 == 0);
        (*l_652) = l_650;
        l_653 = (*l_647);
        /* statement id: 278 */
        assert (l_653 == 0);
        for (p_29 = 0; (p_29 > (-23)); p_29 = safe_sub_func_uint16_t_u_u(p_29, 7))
        { /* block id: 281 */
            int32_t *l_657 = &l_649;
            struct S0 ** const l_662 = &l_650;
            union U1 *l_673 = &l_50;
            (*l_657) = ((-6) <= 0x6DA284B8);
            (*l_657) = (safe_add_func_int32_t_s_s(p_29, p_30));
            if ((safe_mul_func_uint8_t_u_u(p_29, ((l_662 == l_663) < (0 && (65529U != ((safe_rshift_func_uint8_t_u_u(((!p_30) < p_30), p_30)) | ((*l_657) <= l_50.f1))))))))
            { /* block id: 284 */
                int16_t l_671 = (-1);
                (*l_657) = (safe_div_func_int16_t_s_s((l_671 <= ((((0xF9B5 != ((l_672 == l_673) < (safe_sub_func_int16_t_s_s((safe_lshift_func_int8_t_s_s((safe_lshift_func_int16_t_s_u(p_29, 14)), ((safe_rshift_func_int16_t_s_u((safe_sub_func_uint32_t_u_u(((0x5A4D > p_29) | (*l_657)), ((!(safe_unary_minus_func_int32_t_s(p_30))) < l_671))), 3)) | p_30))), (*l_657))))) ^ p_29) & (-8)) | (-9))), (*l_657)));
            }
            else
            { /* block id: 286 */
                union U1 **l_697 = &l_672;
                union U1 ***l_696 = &l_697;
                union U1 ****l_695 = &l_696;
                int32_t l_698 = 0;
                (*l_647) = l_657;
                /* statement id: 287 */
                assert (l_648 == &l_649);
                (*l_647) = l_657;
                (*l_657) = (safe_div_func_int8_t_s_s((safe_unary_minus_func_int16_t_s(((safe_sub_func_uint32_t_u_u((safe_mod_func_int32_t_s_s(((p_30 && (((void*)0 != l_695) == (((*l_657) || l_698) | p_29))) | (0xD2 >= (safe_lshift_func_int8_t_s_u(p_29, (((((((safe_add_func_uint16_t_u_u(0U, l_698)) & p_30) ^ p_30) && l_703) && (*l_657)) & l_665.f1) ^ p_29))))), 0x1E82716A)), p_30)) < (*l_657)))), p_29));
            }
            (*l_657) = (safe_lshift_func_int8_t_s_u((0x44AD || (l_706 | p_30)), 3));
        }
        /* facts after for loop */
        assert (l_648 == &l_649 || l_648 == 0);
    }
    else
    { /* block id: 293 */
        int8_t l_713 = (-1);
        int32_t *l_714 = (void*)0;
        for (l_50.f0 = 0; (l_50.f0 <= 33); l_50.f0 = safe_add_func_uint32_t_u_u(l_50.f0, 1))
        { /* block id: 296 */
            struct S0 ***l_709 = (void*)0;
            struct S0 **l_711 = &l_664;
            struct S0 ***l_710 = &l_711;
            union U1 **l_712 = (void*)0;
            (*l_710) = &l_664;
            l_713 = ((void*)0 != l_712);
        }
        return l_714;
        /* statement id: 300 */
        //assert (func_28_rv == 0);
    }
    /* facts after branching */
    assert (l_653 == 0);
    (*l_715) = p_29;
    return l_721;
    /* statement id: 303 */
    //assert (func_28_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_32(uint32_t  p_33)
{ /* block id: 3 */
    int32_t l_39 = 0x121F2059;
    int32_t *l_38 = &l_39;
    (*l_38) = (l_38 != (void*)0);
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_41(int32_t  p_42, union U1  p_43, int8_t  p_44, uint32_t  p_45)
{ /* block id: 8 */
    int32_t l_79 = 3;
    int32_t *l_78 = &l_79;
    int16_t l_413 = 0x61EB;
    union U1 l_426 = {1U};
    union U1 *l_425 = &l_426;
    int32_t l_501 = 0xA6EB08D9;
    int32_t *l_517 = &l_79;
    int32_t *l_523 = (void*)0;
    int32_t **l_547 = &l_517;
    int32_t ***l_546 = &l_547;
    int16_t l_556 = 0x7529;
    int32_t *l_557 = &l_79;
    int32_t l_621 = 1;
    uint32_t l_627 = 0x7AEE3B0A;
    int32_t *l_645 = &l_79;
    int32_t *l_646 = (void*)0;
    for (p_45 = (-5); (p_45 <= 21); ++p_45)
    { /* block id: 11 */
        uint8_t l_67 = 248U;
        int8_t l_77 = 0x61;
        int32_t l_422 = 0xF135EEA6;
        struct S0 l_492 = {9U,-7362,121,0,17,118,-2313};
        const struct S0 *l_491 = &l_492;
        const union U1 *l_500 = (void*)0;
        const union U1 **l_499 = &l_500;
        int32_t *l_520 = &l_492.f3;
        uint8_t l_524 = 0U;
    }
    (*l_78) = (safe_add_func_int16_t_s_s(p_43.f0, 0x0C81));
    p_42 = ((p_43.f0 && (safe_add_func_int16_t_s_s((((~p_44) <= (safe_add_func_uint16_t_u_u((p_45 != (((((((&p_43 != &l_426) >= (((p_44 >= p_43.f0) <= (0x2D0700D7 > (((((((safe_lshift_func_int8_t_s_u((safe_div_func_uint16_t_u_u(5U, (-1))), p_43.f1)) <= (*l_78)) ^ 1U) > 0) < 0U) ^ p_45) == 0xC3))) <= p_43.f1)) != p_43.f1) > 7U) && 0) >= (*l_517)) > p_43.f0)), l_621))) == 1), (*l_517)))) || (*l_78));
    if (((0x5C8B5565 == 1U) || (((void*)0 != &l_547) == (*l_557))))
    { /* block id: 260 */
        const union U1 **l_628 = (void*)0;
        union U1 **l_630 = &l_425;
        union U1 ***l_629 = &l_630;
        union U1 ****l_631 = &l_629;
        for (l_556 = 14; (l_556 < (-4)); l_556 = safe_sub_func_uint32_t_u_u(l_556, 3))
        { /* block id: 263 */
            int16_t l_624 = 0x7F44;
            int32_t *l_625 = (void*)0;
            uint32_t l_626 = 0x226455D9;
            (*l_78) = (l_624 | 0xEA7516BC);
            (**l_546) = l_625;
            /* statement id: 265 */
            assert (l_517 == 0);
            (*l_547) = &p_42;
            /* statement id: 266 */
            assert (l_517 == &p_42);
        }
        /* facts after for loop */
        assert (l_517 == &p_42 || l_517 == &l_79);
        (*l_517) = l_627;
        (*l_629) = l_628;
        /* statement id: 269 */
        assert (l_630 == 0);
        (*l_631) = &l_630;
    }
    else
    { /* block id: 271 */
        const uint16_t l_643 = 0x2860;
        union U1 **l_644 = &l_425;
        (***l_546) = (((((safe_mod_func_uint8_t_u_u((&l_547 != (void*)0), p_44)) && (safe_rshift_func_uint8_t_u_s((((*l_557) | (safe_unary_minus_func_int8_t_s((safe_div_func_int32_t_s_s(((((*l_517) | ((safe_rshift_func_uint8_t_u_u((3 ^ (safe_sub_func_uint32_t_u_u(((*l_517) != ((*l_517) && (l_643 && l_643))), (**l_547)))), l_643)) <= 0)) <= l_643) && (*l_517)), (*l_517)))))) && (**l_547)), l_643))) < (-2)) > 0x54EB) != l_643);
        (*l_644) = &p_43;
        /* statement id: 273 */
        assert (l_425 == &p_43);
    }
    /* facts after branching */
    assert (l_425 == &p_43 || l_425 == &l_426);
    assert (l_517 == &p_42 || l_517 == &l_79);
    return l_646;
    /* statement id: 275 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_63(int8_t  p_64, int32_t * p_65, int32_t * const  p_66)
{ /* block id: 15 */
    uint8_t l_86 = 255U;
    int32_t *l_87 = (void*)0;
    int32_t **l_198 = &l_87;
    int32_t l_245 = 1;
    uint32_t l_279 = 1U;
    int32_t l_373 = 5;
    struct S0 l_403 = {4294967288U,9841,93,7,20,75,-323};
    struct S0 *l_402 = &l_403;
lbl_270:
    (*l_198) = func_80(l_86, l_87, p_64, func_88(p_65, p_64, ((p_64 > l_86) >= 1U), p_65), p_64);
    if ((~(((void*)0 != &p_66) ^ (&p_65 != (void*)0))))
    { /* block id: 68 */
        uint16_t l_208 = 3U;
        int32_t * const *l_335 = (void*)0;
        int32_t * const **l_334 = &l_335;
        union U1 l_349 = {0x6103};
        union U1 *l_348 = &l_349;
        union U1 **l_347 = &l_348;
        int32_t *l_352 = &l_245;
        for (l_86 = 0; (l_86 > 40); ++l_86)
        { /* block id: 71 */
            int32_t l_205 = 0x72B36A80;
            int32_t *l_204 = &l_205;
            if ((*p_65))
            { /* block id: 72 */
                return p_65;
                /* statement id: 73 */
                //assert (func_63_rv == &l_79);
            }
            else
            { /* block id: 74 */
                if ((*l_204))
                { /* block id: 75 */
                    if ((*p_66))
                        break;
                }
                else
                { /* block id: 77 */
                    (*p_65) = 9;
                }
            }
            return p_65;
            /* statement id: 81 */
            //assert (func_63_rv == &l_79);
        }
        (*p_66) = ((safe_add_func_uint16_t_u_u((p_64 | l_208), (&l_87 != &p_65))) <= p_64);
        (*p_66) = (*p_66);
    }
    else
    { /* block id: 186 */
        if (p_64)
            goto lbl_270;
    }
    (*l_198) = (void*)0;
    l_402 = l_402;
    return p_65;
    /* statement id: 191 */
    //assert (func_63_rv == &l_79);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_80(int32_t  p_81, int32_t * p_82, uint16_t  p_83, const int32_t * p_84, int8_t  p_85)
{ /* block id: 64 */
    int32_t **l_196 = (void*)0;
    const int32_t *l_197 = (void*)0;
    l_197 = p_84;
    /* statement id: 65 */
    //assert (l_197 == 0 || l_197 == &l_79 || l_197 == &l_422 || l_197 == &l_831.f3 || l_197 == &l_23);
    return p_82;
    /* statement id: 66 */
    //assert (func_80_rv == 0 || func_80_rv == &l_79 || func_80_rv == &l_245 || func_80_rv == &l_578 || func_80_rv == &l_831.f3);
}


/* ------------------------------------------ */
/* 
 * reads : l_79 p_42
 * writes: l_79 p_42
 */
static const int32_t * func_88(int32_t * p_89, uint32_t  p_90, const int32_t  p_91, int32_t * p_92)
{ /* block id: 16 */
    uint32_t l_104 = 0x47EB5F43;
    uint8_t l_110 = 0x87;
    int32_t l_112 = (-9);
    int32_t * const l_111 = &l_112;
    int32_t *l_121 = &l_112;
    const int32_t l_170 = (-3);
    const int32_t *l_191 = &l_112;
    const int32_t *l_193 = &l_112;
    const int32_t *l_194 = &l_170;
    const int32_t *l_195 = (void*)0;
    if ((((((safe_mod_func_int16_t_s_s(p_90, (safe_add_func_uint16_t_u_u((safe_lshift_func_int8_t_s_u((-2), 6)), ((((!(safe_add_func_uint16_t_u_u(l_104, (safe_unary_minus_func_uint16_t_u(p_90))))) >= p_91) | ((l_104 | (safe_lshift_func_int16_t_s_s((safe_add_func_int32_t_s_s((l_104 >= l_110), (l_111 == &l_112))), 9))) != (*l_111))) > (*l_111)))))) & p_91) < 0x75) & (*p_92)) && p_90))
    { /* block id: 17 */
        int32_t *l_115 = &l_112;
        int16_t l_153 = 0x33B6;
        uint32_t l_171 = 0U;
        int32_t **l_189 = &l_121;
        if ((safe_add_func_int32_t_s_s((*p_92), (0xFC022558 && ((l_115 == &p_91) > (!(safe_add_func_uint32_t_u_u((safe_div_func_int16_t_s_s(((*l_111) && (p_90 & ((&l_112 != l_121) > p_91))), p_91)), 1U))))))))
        { /* block id: 18 */
            (*l_115) = ((void*)0 == &p_91);
        }
        else
        { /* block id: 20 */
            const int32_t *l_127 = (void*)0;
            const uint32_t l_172 = 0U;
            int32_t l_181 = (-1);
            (*l_121) = ((void*)0 == &p_91);
            for (l_104 = 0; (l_104 >= 49); ++l_104)
            { /* block id: 24 */
                int32_t l_151 = 0x61DEDA81;
                const int32_t *l_154 = &l_151;
                if ((*p_89))
                    break;
                for (l_110 = 0; (l_110 == 18); l_110 = safe_add_func_uint16_t_u_u(l_110, 6))
                { /* block id: 28 */
                    const int32_t *l_126 = &l_112;
                    if ((*p_92))
                        break;
                    return l_127;
                    /* statement id: 30 */
                    //assert (func_88_rv == 0);
                }
            }
            (*l_115) = (*l_115);
        }
        (*l_189) = &p_91;
        /* statement id: 57 */
        assert (l_121 == &p_91);
    }
    else
    { /* block id: 58 */
        const int32_t *l_190 = &l_112;
        const int32_t *l_192 = (void*)0;
        (*l_121) = 0;
        return l_192;
        /* statement id: 60 */
        //assert (func_88_rv == 0);
    }
    /* facts after branching */
    assert (l_121 == &p_91);
    (*p_89) = (*p_92);
    return l_195;
    /* statement id: 63 */
    //assert (func_88_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 213
   depth: 1, occurrence: 1
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 11
   indirect level: 2, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 13
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 9

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 106
   depth: 2, occurrence: 20
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 184

XXX times a variable address is taken: 198
XXX times a pointer is dereferenced on RHS: 150
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 5
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 102
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 8
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 43
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 598

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 313
   level: 2, occurrence: 60
   level: 3, occurrence: 18
XXX number of pointers point to pointers: 73
XXX number of pointers point to scalars: 90
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 27.2
XXX average alias set size: 1.23

XXX times a non-volatile is read: 930
XXX times a non-volatile is write: 266
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 98
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 28
   depth: 2, occurrence: 27
   depth: 3, occurrence: 9
   depth: 4, occurrence: 4

XXX percentage a fresh-made variable is used: 12.4
XXX percentage an existing variable is used: 87.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

