/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3841291076
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   unsigned f1 : 29;
   uint64_t  f2;
   uint64_t  f3;
   uint32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_31(void);
static struct S0  func_32(struct S0  p_33, uint16_t  p_34);
inline static struct S0  func_35(uint64_t  p_36, uint64_t  p_37, struct S0  p_38, struct S0  p_39, uint16_t  p_40);
static struct S0  func_42(uint64_t  p_43, uint32_t  p_44);
inline static uint32_t  func_47(const uint32_t  p_48, int64_t  p_49);
static uint64_t  func_58(uint8_t  p_59, float  p_60, uint32_t  p_61);
inline static uint64_t  func_79(float  p_80, int16_t  p_81, int32_t  p_82);
inline static int32_t  func_87(const float  p_88, uint64_t  p_89, struct S0 * p_90);
static int32_t * func_92(struct S0 * p_93, const uint32_t  p_94);
static struct S0 * func_95(uint32_t  p_96);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_41 = 0x19C2B2E5L;
    struct S0 l_532 = {0x8FCB661FL,6286,1UL,18446744073709551615UL,0x61FBEE41L};
    int32_t l_603 = (-1L);
    struct S0 *l_845 = &l_532;
    uint16_t l_850 = 1UL;
    struct S0 **l_858 = &l_845;
    struct S0 ***l_857 = &l_858;
    struct S0 ****l_856 = &l_857;
    struct S0 ***** const l_855 = &l_856;
    int32_t **l_863 = (void*)0;
    (*l_845) = func_32(func_35(l_41, l_41, func_42(l_41, (((uint64_t)(func_47(((uint16_t)l_41 >> (uint16_t)4), ((int16_t)l_41 << (int16_t)((int64_t)((uint64_t)(func_58(__builtin_bswap32(((int64_t)l_41 - (int64_t)(-5L))), (l_41 > l_41), l_41) > l_41) - (uint64_t)l_41) + (int64_t)l_41))) && l_41) / (uint64_t)l_41) >= l_41)), l_532, l_532.f2), l_603);
lbl_894:
    if (((uint16_t)(((uint16_t)l_532.f3 >> (uint16_t)__builtin_popcount(l_603)) | (l_850 || ((uint64_t)l_532.f1 + (uint64_t)((int16_t)(l_855 != (void*)0) >> (int16_t)(l_532.f1 ^ (l_532.f4 >= l_532.f1)))))) << (uint16_t)8))
    { /* block id: 587 */
        int32_t *l_865 = &l_603;
        int32_t **l_864 = &l_865;
        struct S0 **l_866 = (void*)0;
        uint8_t l_867 = 0xBEL;
        const int16_t l_874 = 0x85CAL;
        int32_t ***l_886 = &l_863;
        int32_t ****l_885 = &l_886;
        if (((((18446744073709551608UL | 6UL) | ((((uint32_t)(func_87(l_532.f4, (((uint32_t)l_532.f1 - (uint32_t)(l_863 == l_864)) > ((void*)0 != l_866)), (***l_856)) == (-6L)) - (uint32_t)0L) >= 1UL) | l_867)) ^ l_603) >= 65526UL))
        { /* block id: 588 */
            uint16_t l_887 = 0xD78FL;
            (*l_865) = __builtin_ctzll(((int16_t)((uint64_t)((int16_t)func_47(l_874, __builtin_parityl(((**l_864) != ((int16_t)((uint64_t)((**l_864) ^ (((int16_t)(((0x99691549CD6F2632LL | ((uint32_t)((uint16_t)((void*)0 != &l_863) << (uint16_t)((((void*)0 == l_885) != (0xB5A3ADEC67F501E1LL == 0x44E6B3CE9434A594LL)) || l_887)) % (uint32_t)(**l_864))) & l_887) | l_887) << (int16_t)7) >= l_887)) + (uint64_t)0L) + (int16_t)0x0DE5L)))) << (int16_t)l_887) % (uint64_t)l_887) << (int16_t)13));
            (*l_864) = (void*)0;
            /* statement id: 590 */
            assert (l_865 == 0);
        }
        else
        { /* block id: 591 */
            int32_t *l_888 = (void*)0;
            (*l_864) = l_888;
            /* statement id: 592 */
            assert (l_865 == 0);
        }
        /* facts after branching */
        assert (l_865 == 0);
    }
    else
    { /* block id: 594 */
        struct S0 l_889 = {4UL,13842,0x37CE6B0C373AB5ACLL,18446744073709551607UL,18446744073709551615UL};
        (*l_845) = l_889;
    }
    for (l_603 = 2; (l_603 > 2); l_603++)
    { /* block id: 599 */
        int32_t *l_893 = &l_603;
        int32_t **l_892 = &l_893;
        (*l_892) = &l_603;
        if (l_532.f3)
            goto lbl_894;
    }
    return l_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_32(struct S0  p_33, uint16_t  p_34)
{ /* block id: 432 */
    int32_t l_608 = 0L;
    struct S0 *l_618 = (void*)0;
    int32_t l_623 = 0xC16DC959L;
    int32_t *l_622 = &l_623;
    struct S0 **l_641 = (void*)0;
    struct S0 ***l_640 = &l_641;
    struct S0 ****l_639 = &l_640;
    int32_t **l_718 = &l_622;
    int32_t ***l_717 = &l_718;
    int32_t ****l_716 = &l_717;
    int32_t *****l_715 = &l_716;
    int16_t l_772 = (-10L);
    int16_t l_816 = 9L;
    struct S0 *****l_832 = &l_639;
    uint64_t l_835 = 1UL;
    int32_t l_842 = 0x3F7EA474L;
    int32_t *l_844 = &l_623;
lbl_818:
    if (((int16_t)((uint16_t)(0L == p_33.f1) >> (uint16_t)l_608) >> (int16_t)8))
    { /* block id: 433 */
        return p_33;
    }
    else
    { /* block id: 435 */
        float l_611 = 0x7.46BE09p-39;
        const int32_t *l_614 = (void*)0;
        const int32_t l_619 = 1L;
        int32_t **l_620 = (void*)0;
        int32_t **l_621 = (void*)0;
        for (p_33.f3 = 0; (p_33.f3 <= 27); ++p_33.f3)
        { /* block id: 438 */
            if (p_33.f4)
                break;
            if (p_33.f1)
                continue;
            for (p_33.f0 = 0; (p_33.f0 != 19); ++p_33.f0)
            { /* block id: 443 */
                int32_t l_617 = 0xBACB4DB1L;
                int32_t *l_616 = &l_617;
                int32_t **l_615 = &l_616;
                if (p_33.f1)
                    break;
                (*l_615) = l_614;
                /* statement id: 445 */
                assert (l_616 == 0);
            }
        }
        l_622 = func_92(l_618, l_619);
        /* statement id: 448 */
        assert (l_622 == 0);
    }
    /* facts after branching */
    assert (l_622 == 0);
    if (func_58(func_58((((int16_t)((int16_t)((((int16_t)__builtin_bswap32((p_33.f2 == ((uint16_t)((p_34 > (&l_618 == &l_618)) ^ (((!p_33.f3) > p_33.f4) >= p_34)) << (uint16_t)((int16_t)(((int64_t)((int16_t)((l_639 != &l_640) | 0x381287C2FF62C3F6LL) << (int16_t)0) + (int64_t)(-6L)) & p_33.f3) << (int16_t)5)))) << (int16_t)12) != p_33.f1) > 3UL) - (int16_t)p_33.f2) + (int16_t)(-1L)) && l_608), l_623, p_33.f3), l_623, p_33.f1))
    { /* block id: 450 */
        uint32_t l_642 = 3UL;
        const float l_644 = 0x0.Fp+1;
        struct S0 l_647 = {0x6558930EL,19885,1UL,18446744073709551615UL,0xF8E28246L};
        struct S0 **l_676 = &l_618;
        uint32_t l_702 = 0xF871930BL;
        int32_t *l_725 = &l_623;
        int32_t ***l_729 = (void*)0;
        uint32_t l_759 = 0xF85BBE8EL;
        int32_t *l_830 = (void*)0;
        if (l_642)
        { /* block id: 451 */
            struct S0 **l_643 = &l_618;
            (*l_643) = func_95(p_33.f1);
            /* statement id: 452 */
            assert (l_618 == 0);
        }
        else
        { /* block id: 453 */
            struct S0 l_650 = {0x56C2B703L,9026,0UL,0xD9788DE7A86F961ELL,0x4710752BL};
            int32_t l_657 = 0x70CB83D5L;
            float l_671 = 0x4.B80C23p-94;
            float *l_670 = &l_671;
            struct S0 ** const l_675 = &l_618;
lbl_713:
            if (p_34)
            { /* block id: 454 */
                return p_33;
            }
            else
            { /* block id: 456 */
                const float l_645 = (-0x3.8p-1);
                int32_t **l_646 = &l_622;
                (*l_646) = func_92(func_95((9UL >= p_33.f1)), p_33.f2);
            }
            l_647 = l_647;
            if (((int16_t)(p_33.f0 | p_33.f2) << (int16_t)10))
            { /* block id: 460 */
                float l_651 = 0x0.8p-1;
                int32_t l_674 = 0x2644C142L;
                l_650 = p_33;
                if (l_650.f4)
                { /* block id: 462 */
                    struct S0 ****l_669 = &l_640;
                    int32_t l_672 = 0x081CBCF8L;
                    for (l_647.f0 = 0; (l_647.f0 == 52); l_647.f0 += 4)
                    { /* block id: 465 */
                        int32_t *l_654 = &l_623;
                        (*l_654) = p_33.f3;
                    }
                    for (l_650.f2 = 13; (l_650.f2 > 49); l_650.f2++)
                    { /* block id: 470 */
                        struct S0 *l_658 = &l_647;
                        int32_t l_673 = 6L;
                        l_657 = 1L;
                        (*l_658) = l_650;
                        l_674 = ((((int32_t)(+func_87((-(float)((float)((float)((float)(-0x1.8p-1) - (float)((void*)0 == l_669)) + (float)(-0x1.5p-1)) - (float)__builtin_parityll(((void*)0 != l_622)))), (((void*)0 != l_670) >= p_34), l_658)) / (int32_t)l_672) != 0x93EFL) && l_673);
                    }
                    (*l_670) = (l_675 == l_676);
                }
                else
                { /* block id: 476 */
                    int32_t *l_688 = &l_674;
                    struct S0 l_691 = {4294967288UL,17842,18446744073709551614UL,0x57D5AED16524C95ALL,0x82F3FD69L};
                    uint16_t l_707 = 1UL;
                    (*l_688) = (((uint16_t)((int32_t)__builtin_parityl(l_650.f1) + (int32_t)__builtin_parity(l_642)) - (uint16_t)(p_33.f1 > func_47(p_33.f0, (p_33.f1 >= (((int16_t)((int16_t)(-(uint64_t)p_33.f1) % (int16_t)(((uint16_t)__builtin_ctzl(l_650.f2) << (uint16_t)0) & 9L)) + (int16_t)p_33.f1) == 0x60643AB7L))))) >= p_33.f3);
                    (*l_670) = p_33.f3;
                    for (l_623 = 0; (l_623 > 19); l_623 += 1)
                    { /* block id: 481 */
                        uint8_t l_698 = 0x9EL;
                        l_691 = p_33;
                        (*l_688) = func_87((((float)(-0x1.6p+1) - (float)((float)(((float)l_698 / (float)(p_33.f2 != (l_698 != ((float)((+l_702) < __builtin_ctz((((int32_t)p_33.f0 - (int32_t)l_647.f0) < (((void*)0 != &l_674) > 0x16B1L)))) + (float)l_698)))) == 0xB.E79426p+1) + (float)(-0x8.Ap+1))) > l_642), l_674, &l_691);
                    }
                    if (((l_650.f1 & (((uint16_t)l_707 - (uint16_t)p_33.f3) <= (((((uint32_t)0xACC1BE01L / (uint32_t)((func_47(p_33.f0, l_650.f2) | ((uint16_t)l_623 << (uint16_t)(*l_688))) || l_647.f0)) >= (*l_688)) > 4UL) < l_650.f0))) >= l_657))
                    { /* block id: 485 */
                        int32_t **l_712 = &l_688;
                        (*l_712) = l_688;
                        (*l_712) = (*l_712);
                        (*l_712) = &l_674;
                        if (l_650.f4)
                            goto lbl_713;
                    }
                    else
                    { /* block id: 490 */
                        int32_t **l_714 = &l_622;
                        (*l_714) = func_92((*l_675), l_702);
                    }
                }
            }
            else
            { /* block id: 494 */
                (*l_725) = ((((void*)0 == l_715) && ((uint64_t)(((uint64_t)((uint16_t)1UL << (uint16_t)14) % (uint64_t)(p_33.f4 || (((((p_34 || l_650.f4) ^ ((((****l_715) != l_725) & l_650.f0) > 0x4A6C492F84B1C78ELL)) == l_650.f0) && p_33.f1) == 0x7D94E97AC22D6BFALL))) != p_33.f1) % (uint64_t)18446744073709551610UL)) | p_33.f2);
            }
        }
        if (p_33.f3)
        { /* block id: 498 */
            uint8_t l_728 = 0x26L;
            int32_t l_735 = 0xF8A528CBL;
            struct S0 *l_752 = &l_647;
            int32_t *l_788 = &l_623;
            l_725 = (*l_718);
            /* statement id: 499 */
            assert (l_725 == 0);
            if ((l_728 <= (l_729 != (void*)0)))
            { /* block id: 500 */
                int32_t * const *l_734 = &l_622;
                float *l_741 = (void*)0;
                int32_t l_744 = (-1L);
                for (l_642 = (-6); (l_642 >= 32); l_642 += 8)
                { /* block id: 503 */
                    uint8_t l_748 = 0x39L;
                    float l_750 = 0x4.3EC519p+40;
                    float *l_749 = &l_750;
                    struct S0 l_751 = {0x197C5F5DL,19827,0xB5CBE7584F0B7FF9LL,0x82761255775F2979LL,1UL};
                    l_735 = ((int16_t)func_47((l_734 != l_734), p_33.f4) << (int16_t)13);
                    if (((int16_t)((~(p_33.f2 < __builtin_ffsll(p_34))) == ((int32_t)(l_622 == l_741) - (int32_t)__builtin_ia32_crc32qi(p_33.f1, ((((int64_t)(l_744 & p_33.f0) + (int64_t)(0xCFC0L <= 65527UL)) ^ l_728) != p_33.f1)))) % (int16_t)1L))
                    { /* block id: 505 */
                        int32_t **l_745 = (void*)0;
                        (**l_717) = (*l_734);
                    }
                    else
                    { /* block id: 507 */
                        float l_746 = 0x0.3F981Ep-16;
                        int32_t *l_747 = &l_735;
                        (*l_747) = l_728;
                    }
                    (*l_749) = l_748;
                    p_33 = l_751;
                }
            }
            else
            { /* block id: 513 */
                const int32_t l_753 = (-1L);
                int32_t *l_754 = &l_735;
                struct S0 *l_769 = &l_647;
                (***l_716) = func_92(l_752, l_753);
                l_754 = (**l_717);
                /* statement id: 515 */
                assert (l_754 == 0);
                for (p_33.f2 = 22; (p_33.f2 <= 22); ++p_33.f2)
                { /* block id: 518 */
                    for (l_647.f0 = (-1); (l_647.f0 > 60); ++l_647.f0)
                    { /* block id: 521 */
                        (*l_718) = func_92((*l_676), (p_34 == __builtin_ffsl(l_759)));
                        return p_33;
                    }
                    for (l_647.f4 = 0; (l_647.f4 >= 58); ++l_647.f4)
                    { /* block id: 527 */
                        int16_t l_768 = 0xD845L;
                        uint32_t l_773 = 0x5C554E68L;
                        (*l_718) = func_92((*l_676), (((int16_t)((uint32_t)__builtin_ffsll(p_33.f3) / (uint32_t)((uint32_t)(0UL ^ (((((0x0DD4L && p_33.f3) != l_768) > (0x1A26D1FAFE0A63DELL < (l_768 == l_735))) > p_33.f4) > p_33.f1)) + (uint32_t)p_33.f0)) >> (int16_t)11) < (-5L)));
                        (**l_717) = func_92(l_769, ((int16_t)l_772 >> (int16_t)4));
                        l_773 = l_768;
                    }
                    if (p_33.f3)
                        break;
                }
                for (l_702 = 0; (l_702 < 56); l_702 += 5)
                { /* block id: 536 */
                    uint8_t l_786 = 1UL;
                    int32_t l_787 = 0L;
                    l_787 = ((uint32_t)((int64_t)p_33.f0 + (int64_t)((((int16_t)func_87(func_79((p_33.f0 <= (((float)p_33.f0 + (float)func_79(p_34, p_33.f3, p_33.f0)) < ((float)(func_79((&p_33 != (void*)0), p_33.f4, p_33.f4) > p_33.f0) + (float)p_33.f0))), p_34, l_786), l_728, l_752) >> (int16_t)12) != l_735) > l_728)) - (uint32_t)p_33.f0);
                    (**l_717) = (void*)0;
                    l_788 = &l_735;
                    /* statement id: 539 */
                    assert (l_788 == &l_735);
                }
                /* facts after for loop */
                assert (l_788 == &l_735 || l_788 == &l_623);
            }
            /* facts after branching */
            assert (l_788 == &l_735 || l_788 == &l_623);
        }
        else
        { /* block id: 542 */
            float l_802 = 0x6.D9BB5Ap-51;
            int32_t l_803 = 4L;
            int32_t ***l_811 = &l_718;
            if ((p_34 | ((2UL <= ((uint16_t)(((uint64_t)((int64_t)(+p_33.f4) % (int64_t)p_33.f2) - (uint64_t)((((uint64_t)((uint64_t)((uint32_t)p_33.f0 + (uint32_t)((__builtin_bswap32(((0xDFB41D5A55DF478BLL <= p_33.f3) == p_33.f4)) <= l_803) > 0x46528C99L)) % (uint64_t)(*l_725)) % (uint64_t)p_33.f2) <= 0UL) <= 4UL)) || l_803) + (uint16_t)9L)) > p_33.f0)))
            { /* block id: 543 */
                uint32_t l_810 = 7UL;
                int32_t l_817 = 1L;
                l_817 = ((uint64_t)(((uint16_t)((uint16_t)func_79((l_810 == ((void*)0 != l_811)), l_810, p_34) << (uint16_t)(((uint32_t)p_34 - (uint32_t)((uint16_t)0UL >> (uint16_t)(((l_810 & l_816) != l_810) == l_803))) && 0xF279D20FL)) << (uint16_t)p_33.f4) || 9UL) / (uint64_t)0xE89616BEFFCD0996LL);
                return p_33;
            }
            else
            { /* block id: 546 */
                int64_t l_824 = (-1L);
                (*l_676) = &p_33;
                /* statement id: 547 */
                assert (l_618 == &p_33);
                if (l_647.f1)
                    goto lbl_818;
                for (l_647.f3 = 14; (l_647.f3 < 49); l_647.f3 += 1)
                { /* block id: 551 */
                    int16_t l_821 = (-1L);
                    int32_t **l_825 = &l_622;
                    float *l_826 = &l_802;
                    (****l_715) = (****l_715);
                    if (l_821)
                        break;
                    (*l_826) = ((float)l_824 - (float)(l_821 != (0x1.2p-1 < (p_33.f3 < (((**l_716) == l_825) == 0x5.5F7450p+13)))));
                }
            }
            /* facts after branching */
            assert (l_618 == &p_33);
            (*l_725) = p_34;
            (*l_718) = (***l_716);
            if ((p_33.f1 & p_33.f4))
            { /* block id: 559 */
                (****l_715) = (*l_718);
                (*l_718) = func_92(&p_33, p_33.f4);
                for (l_759 = 0; (l_759 != 6); ++l_759)
                { /* block id: 564 */
                }
            }
            else
            { /* block id: 574 */
                struct S0 l_829 = {7UL,6727,0x161472859EC389FFLL,0x2D34FABDD3105653LL,1UL};
                return l_829;
            }
        }
        /* facts after branching */
        assert (l_725 == &l_623 || l_725 == 0);
        (*l_718) = l_830;
    }
    else
    { /* block id: 579 */
        struct S0 l_831 = {0xB6DAE6BBL,12084,0x2A4E067BA0C65605LL,0xC750C40E5080FB0ALL,18446744073709551611UL};
        (*l_718) = (****l_715);
        p_33 = func_35(p_34, p_33.f1, p_33, l_831, l_831.f4);
    }
    l_832 = (void*)0;
    /* statement id: 583 */
    assert (l_832 == 0);
    (*l_844) = p_34;
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_35(uint64_t  p_36, uint64_t  p_37, struct S0  p_38, struct S0  p_39, uint16_t  p_40)
{ /* block id: 390 */
    uint32_t l_535 = 1UL;
    int32_t l_538 = 0L;
    struct S0 ****l_542 = (void*)0;
    struct S0 *****l_541 = &l_542;
    float l_548 = 0x4.8E6A1Fp+28;
    float *l_547 = &l_548;
    int32_t ***l_556 = (void*)0;
    int32_t ****l_555 = &l_556;
    struct S0 l_590 = {0x1A32B1D5L,2883,0xD78B7F5A9B57CE6ALL,0x4B907FBFAA622FA7LL,1UL};
    struct S0 *l_589 = &l_590;
    struct S0 **l_588 = &l_589;
    int32_t l_598 = 0xF45E9A4CL;
    l_535 = ((float)p_39.f2 - (float)0x4.7p+1);
    if (((l_535 != ((int16_t)(l_538 || (func_79(((float)(l_541 == &l_542) + (float)((float)p_38.f2 - (float)((float)(l_535 > (((void*)0 != l_547) > (l_538 >= p_39.f2))) + (float)l_535))), p_40, p_36) > 0xCE24L)) << (int16_t)l_535)) || p_38.f0))
    { /* block id: 392 */
        int32_t ***l_554 = (void*)0;
        int32_t ****l_553 = &l_554;
        if ((((int16_t)((uint16_t)(l_553 == l_555) << (uint16_t)8) >> (int16_t)2) || ((int16_t)p_39.f4 << (int16_t)14)))
        { /* block id: 393 */
            int32_t * const l_569 = (void*)0;
            uint16_t l_580 = 65528UL;
            for (l_535 = 0; (l_535 == 60); l_535++)
            { /* block id: 396 */
                int64_t l_574 = 0L;
                int32_t *l_576 = (void*)0;
                int32_t **l_575 = &l_576;
                int32_t *l_584 = (void*)0;
                int32_t *l_585 = &l_538;
                for (p_40 = 0; (p_40 != 24); p_40 += 4)
                { /* block id: 399 */
                    struct S0 l_566 = {4294967295UL,9713,0UL,0UL,0x1230DB85L};
                    struct S0 *l_565 = &l_566;
                    struct S0 **l_564 = &l_565;
                    struct S0 ***l_563 = &l_564;
                    struct S0 ** const *l_568 = &l_564;
                    struct S0 ** const **l_567 = &l_568;
                    int32_t *l_571 = (void*)0;
                    int32_t **l_570 = &l_571;
                    uint64_t l_579 = 0x46111636982659E2LL;
                    int32_t *l_581 = (void*)0;
                    int32_t *l_582 = (void*)0;
                    int32_t *l_583 = &l_538;
                    (*l_567) = l_563;
                    (*l_570) = l_569;
                    for (l_566.f2 = 0; (l_566.f2 < 6); l_566.f2 += 1)
                    { /* block id: 404 */
                        (*l_570) = (*l_570);
                    }
                    (*l_583) = ((((p_38.f4 <= (p_37 <= (l_574 ^ (l_575 == (void*)0)))) > ((int16_t)func_47(p_39.f0, l_579) << (int16_t)l_580)) >= 0xC1CA34C7E3E9FBA8LL) <= 0x0D7C4660L);
                }
                (*l_547) = (l_569 != l_576);
                (*l_585) = p_37;
            }
        }
        else
        { /* block id: 412 */
            int32_t *l_586 = &l_538;
            struct S0 **l_587 = (void*)0;
            l_586 = l_586;
            if (p_38.f2)
            { /* block id: 414 */
                l_588 = l_587;
                /* statement id: 415 */
                assert (l_588 == 0);
            }
            else
            { /* block id: 416 */
                (*l_589) = func_42(p_38.f1, p_39.f1);
                (*l_586) = p_39.f0;
            }
            /* facts after branching */
            assert (l_588 == &l_589 || l_588 == 0);
        }
        /* facts after branching */
        assert (l_588 == &l_589 || l_588 == 0);
    }
    else
    { /* block id: 421 */
        int32_t *l_591 = &l_538;
        struct S0 *l_592 = &l_590;
        int32_t **l_599 = &l_591;
        (*l_591) = __builtin_popcount(p_36);
        (*l_599) = func_92(l_592, ((int16_t)0x590FL >> (int16_t)((int16_t)(*l_591) >> (int16_t)(+l_598))));
        /* statement id: 423 */
        assert (l_591 == 0);
        for (l_538 = 0; (l_538 <= (-19)); l_538--)
        { /* block id: 426 */
            struct S0 *l_602 = (void*)0;
            (*l_588) = l_602;
            /* statement id: 427 */
            assert (l_589 == 0);
            (*l_592) = p_39;
        }
        /* facts after for loop */
        assert (l_589 == 0 || l_589 == &l_590);
    }
    /* facts after branching */
    assert (l_589 == 0 || l_589 == &l_590);
    assert (l_588 == &l_589 || l_588 == 0);
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_42(uint64_t  p_43, uint32_t  p_44)
{ /* block id: 388 */
    struct S0 l_531 = {7UL,912,7UL,0xE460AEE66FE87BB7LL,0UL};
    return l_531;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_47(const uint32_t  p_48, int64_t  p_49)
{ /* block id: 386 */
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_58(uint8_t  p_59, float  p_60, uint32_t  p_61)
{ /* block id: 37 */
    uint16_t l_66 = 1UL;
    struct S0 l_86 = {0x30DD3593L,20882,18446744073709551610UL,18446744073709551615UL,1UL};
    int32_t l_473 = 0x182D7C8CL;
    const int32_t *l_472 = &l_473;
    const int32_t **l_471 = &l_472;
    const int32_t ***l_470 = &l_471;
    const int32_t ****l_469 = &l_470;
    int32_t **l_498 = (void*)0;
    int32_t ***l_497 = &l_498;
    int32_t ****l_496 = &l_497;
    int32_t *****l_495 = &l_496;
    struct S0 l_502 = {6UL,18667,0x00E19483CD63475BLL,0x08A3B0C5488CFB32LL,9UL};
    for (p_61 = 0; (p_61 == 33); ++p_61)
    { /* block id: 40 */
        return p_61;
    }
    if ((l_66 | (((int32_t)((uint16_t)0x1FC5L << (uint16_t)15) + (int32_t)__builtin_popcountl((l_66 != (((uint16_t)((uint16_t)l_66 + (uint16_t)p_59) << (uint16_t)13) && (l_66 || ((__builtin_popcount((((uint64_t)((func_79(l_66, p_59, p_61) <= l_66) && 1UL) - (uint64_t)0UL) && p_59)) <= 0x0F9AB13FL) >= 0x7D87L)))))) <= p_59)))
    { /* block id: 46 */
        struct S0 l_85 = {0x961F0846L,8621,0x2D30A9375314680ELL,0xED6215A4C4AE3B72LL,0xD76E6681L};
        int32_t l_457 = 0xCFBFE7C5L;
        int32_t *l_456 = &l_457;
        int32_t **l_458 = &l_456;
        l_86 = l_85;
        (*l_456) = func_87((&l_86 == &l_86), l_86.f2, &l_85);
        (*l_458) = &l_457;
    }
    else
    { /* block id: 315 */
        int16_t l_459 = 3L;
        struct S0 *l_460 = &l_86;
        float l_462 = 0x8.7p+1;
        float *l_461 = &l_462;
        struct S0 ***l_487 = (void*)0;
        int16_t l_493 = 1L;
        int32_t *****l_494 = (void*)0;
        int32_t *l_507 = &l_473;
        if (l_459)
        { /* block id: 316 */
            float *l_463 = (void*)0;
            int32_t l_466 = 1L;
            int32_t *l_465 = &l_466;
            int32_t **l_464 = &l_465;
            int32_t ****l_476 = (void*)0;
            uint32_t l_480 = 2UL;
            struct S0 *l_481 = &l_86;
            struct S0 **l_489 = &l_460;
            struct S0 ***l_488 = &l_489;
            const int32_t l_492 = 0xAD423761L;
            (*l_464) = func_92(l_460, (l_461 != l_463));
            /* statement id: 317 */
            assert (l_465 == 0);
            if (l_66)
                goto lbl_477;
            if (func_79(((((float)l_459 / (float)0x6.3p-1) == __builtin_ffs((l_469 == (void*)0))) < ((float)l_459 - (float)p_59)), ((void*)0 != l_476), p_61))
            { /* block id: 318 */
lbl_477:
                (**l_470) = func_92(&l_86, (**l_471));
                /* statement id: 319 */
                assert (l_472 == 0);
                (**l_470) = func_92(func_95(((uint16_t)l_480 >> (uint16_t)15)), p_61);
                (*l_464) = func_92(l_481, p_59);
            }
            else
            { /* block id: 323 */
                (*l_481) = (*l_460);
            }
            /* facts after branching */
            assert (l_472 == &l_473 || l_472 == 0);
            (*l_460) = (*l_481);
            p_60 = (((!(__builtin_popcountll(p_59) > ((func_79(p_59, ((uint16_t)(__builtin_popcountll((func_79((0x8.1p-1 >= (!(0x8.0B3856p-71 != ((!((l_487 != l_488) < (((float)l_459 + (float)p_59) < 0x1.Ep-1))) >= p_61)))), l_459, p_61) != l_459)) <= l_492) + (uint16_t)p_59), p_59) != l_459) >= p_59))) == l_493) < 0x4.83F359p+80);
        }
        else
        { /* block id: 328 */
            uint16_t l_503 = 0x1633L;
            int32_t *l_506 = (void*)0;
            l_495 = l_494;
            /* statement id: 329 */
            assert (l_495 == 0);
            for (l_86.f2 = 8; (l_86.f2 > 51); ++l_86.f2)
            { /* block id: 332 */
                struct S0 l_501 = {4294967295UL,18197,0x00F83D03F561DA92LL,18446744073709551615UL,18446744073709551615UL};
                l_502 = l_501;
                if (l_503)
                { /* block id: 334 */
                    (*l_461) = (__builtin_parity(p_59) > l_503);
                }
                else
                { /* block id: 336 */
                    for (l_501.f3 = 0; (l_501.f3 <= 30); ++l_501.f3)
                    { /* block id: 339 */
                        (**l_470) = l_506;
                        /* statement id: 340 */
                        assert (l_472 == 0);
                        if (p_59)
                            continue;
                    }
                }
            }
            /* facts after for loop */
            assert (l_472 == 0 || l_472 == &l_473);
        }
        /* facts after branching */
        assert (l_472 == &l_473 || l_472 == 0);
        assert (l_495 == 0 || l_495 == &l_496);
        (*l_507) = 0x156AD473L;
        for (l_473 = 0; (l_473 < (-7)); l_473--)
        { /* block id: 349 */
            struct S0 *l_510 = &l_502;
            int32_t l_511 = (-1L);
            (***l_469) = func_92(l_510, p_59);
            /* statement id: 350 */
            assert (l_472 == 0);
            return l_511;
        }
        if (((*l_507) & p_61))
        { /* block id: 353 */
            (*l_461) = 0xE.436BD2p-93;
        }
        else
        { /* block id: 355 */
            float l_519 = 0xB.95F059p-15;
            int32_t *l_520 = &l_473;
            for (l_493 = 0; (l_493 >= (-25)); l_493--)
            { /* block id: 358 */
                int32_t *l_517 = &l_473;
                if (p_59)
                { /* block id: 359 */
                    (*l_460) = l_86;
                }
                else
                { /* block id: 361 */
                    struct S0 *l_514 = &l_502;
                    l_517 = func_92(l_514, ((int16_t)p_59 << (int16_t)0));
                    /* statement id: 362 */
                    assert (l_517 == 0);
                }
                /* facts after branching */
                assert (l_517 == 0 || l_517 == &l_473);
                if (p_61)
                    continue;
            }
            l_520 = func_92(&l_86, (((!(*l_507)) < (((&l_497 != (void*)0) > p_59) ^ (func_87(p_60, p_59, &l_502) >= p_61))) < 0UL));
            /* statement id: 366 */
            assert (l_520 == 0);
            for (l_459 = 12; (l_459 == 11); l_459 -= 1)
            { /* block id: 369 */
                if (p_59)
                    break;
            }
        }
    }
    /* facts after branching */
    assert (l_472 == &l_473 || l_472 == 0);
    assert (l_495 == 0 || l_495 == &l_496);
    for (l_86.f4 = 0; (l_86.f4 < 23); ++l_86.f4)
    { /* block id: 376 */
        float l_530 = 0x9.147A8Bp+99;
        float *l_529 = &l_530;
        for (l_86.f2 = 0; (l_86.f2 > 56); l_86.f2++)
        { /* block id: 379 */
            struct S0 l_527 = {0UL,16192,0x4B7865FC8E736708LL,0xAE79FE34874BAAC3LL,0x457D2946L};
            struct S0 *l_528 = &l_502;
            (*l_528) = l_527;
        }
        (*l_529) = (p_60 != p_61);
    }
    (***l_469) = (***l_469);
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_79(float  p_80, int16_t  p_81, int32_t  p_82)
{ /* block id: 43 */
    struct S0 l_84 = {0x9C591EBBL,5446,0xA0786CB52F506A54LL,0UL,18446744073709551615UL};
    struct S0 *l_83 = &l_84;
    l_83 = l_83;
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_87(const float  p_88, uint64_t  p_89, struct S0 * p_90)
{ /* block id: 48 */
    uint16_t l_91 = 0xAE9EL;
    int32_t l_442 = 7L;
    struct S0 l_443 = {0x596A58D8L,19536,0x522CE8A9F10ABFB8LL,0x006C132CEA825F12LL,0x28909DBFL};
    int32_t *l_455 = &l_442;
    int32_t **l_454 = &l_455;
    if ((l_91 >= l_91))
    { /* block id: 49 */
        int32_t l_441 = (-1L);
        int32_t *l_440 = &l_441;
        int32_t **l_439 = &l_440;
        (*l_439) = func_92(func_95(p_89), (p_89 != (0xA21AL <= (((int16_t)0x4643L >> (int16_t)12) & 0L))));
        /* statement id: 294 */
        assert (l_440 == 0);
        l_442 = l_91;
        (*p_90) = l_443;
    }
    else
    { /* block id: 297 */
        int32_t *l_446 = &l_442;
        for (l_443.f4 = 0; (l_443.f4 < 13); ++l_443.f4)
        { /* block id: 300 */
            int32_t **l_447 = &l_446;
            (*l_447) = l_446;
        }
        for (l_443.f3 = 0; (l_443.f3 == 8); l_443.f3++)
        { /* block id: 305 */
            struct S0 *l_450 = &l_443;
            const uint32_t l_451 = 1UL;
            int32_t **l_452 = (void*)0;
            int32_t **l_453 = &l_446;
            (*l_453) = func_92(l_450, l_451);
            /* statement id: 306 */
            assert (l_446 == 0);
            (*l_453) = &l_442;
            /* statement id: 307 */
            assert (l_446 == &l_442);
            (*l_453) = (*l_453);
        }
    }
    (*l_454) = &l_442;
    return p_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_92(struct S0 * p_93, const uint32_t  p_94)
{ /* block id: 215 */
    int32_t l_338 = 1L;
    struct S0 l_345 = {4294967293UL,13256,0x1793FD4F5B5C5C84LL,18446744073709551615UL,1UL};
    struct S0 *l_344 = &l_345;
    struct S0 **l_343 = &l_344;
    struct S0 ***l_342 = &l_343;
    uint8_t l_423 = 0x5EL;
    int32_t *l_438 = (void*)0;
    if ((((int16_t)((int16_t)((uint64_t)0xEFC0E631E9C2AB02LL - (uint64_t)(((uint16_t)(func_79(l_338, ((p_94 < (+((void*)0 != &p_93))) >= l_338), p_94) && (((uint64_t)(((l_342 != (void*)0) && p_94) > 0x8089151EL) - (uint64_t)l_345.f0) > p_94)) << (uint16_t)13) & p_94)) >> (int16_t)l_345.f3) >> (int16_t)10) == 3L))
    { /* block id: 216 */
        int64_t l_346 = (-9L);
        int32_t *l_355 = &l_338;
        struct S0 l_376 = {0UL,21117,18446744073709551615UL,0x7F7FB4EBCAFB7451LL,0xF5524AC2L};
        int32_t **l_408 = (void*)0;
        int32_t **l_409 = &l_355;
        if (func_79(l_346, p_94, ((uint16_t)0xEBA1L % (uint16_t)p_94)))
        { /* block id: 217 */
            struct S0 l_349 = {0x912CEF29L,2721,0x3A2C7831F2CF1AC8LL,0xC532CF43B99A6A31LL,0x5F08C032L};
            struct S0 ***l_352 = &l_343;
            (***l_342) = l_349;
            for (l_349.f3 = 0; (l_349.f3 < 39); ++l_349.f3)
            { /* block id: 221 */
                int16_t l_353 = 0x9F8BL;
                int32_t *l_357 = (void*)0;
                if ((func_79(l_345.f2, l_345.f0, ((void*)0 == l_352)) || l_353))
                { /* block id: 222 */
                    struct S0 l_354 = {0xEB3384EAL,3682,0UL,18446744073709551615UL,0xAFE5DA07L};
                    int32_t **l_356 = &l_355;
                    (***l_342) = l_354;
                    (*l_356) = l_355;
                    return l_357;
                    /* statement id: 225 */
                    //assert (func_92_rv == 0);
                }
                else
                { /* block id: 226 */
                    int16_t l_360 = (-8L);
                    if (((uint64_t)(*l_355) - (uint64_t)l_360))
                    { /* block id: 227 */
                        struct S0 l_375 = {0xDF211AAEL,10937,0xB6EFACE8F519CF44LL,1UL,18446744073709551615UL};
                        float l_378 = 0xD.ED5903p-18;
                        float *l_377 = &l_378;
                        (*l_355) = ((uint16_t)((uint64_t)((int16_t)p_94 % (int16_t)0xE596L) % (uint64_t)0x6118C7AA07E235D7LL) << (uint16_t)(((uint16_t)65535UL + (uint16_t)(((uint16_t)(((uint16_t)p_94 >> (uint16_t)(__builtin_clzll((*l_355)) < ((int16_t)(((*l_355) > 3L) == 0UL) - (int16_t)p_94))) == p_94) % (uint16_t)0x8A6AL) ^ (-2L))) | 4UL));
                        (*l_344) = l_375;
                        (*l_344) = l_376;
                        (*l_377) = __builtin_ffsll((*l_355));
                    }
                    else
                    { /* block id: 232 */
                        int32_t **l_379 = &l_357;
                        (*l_379) = l_357;
                        (*l_379) = (*l_379);
                    }
                }
            }
            for (l_349.f4 = 0; (l_349.f4 < 55); l_349.f4 += 9)
            { /* block id: 240 */
                int64_t l_395 = 0xEB3B867074C7D2C4LL;
                int32_t l_396 = 0xC5DC2EABL;
                int32_t *l_402 = &l_338;
                for (l_376.f4 = (-5); (l_376.f4 < 26); l_376.f4++)
                { /* block id: 243 */
                    const int32_t l_392 = 0x05790A04L;
                    (*l_355) = func_79(p_94, l_345.f4, p_94);
                    for (l_349.f2 = 18; (l_349.f2 > 22); l_349.f2 += 1)
                    { /* block id: 247 */
                        float l_398 = 0x5.88506Fp+55;
                        float *l_397 = &l_398;
                        (*l_397) = ((*l_355) > ((-(float)((float)l_345.f4 + (float)((((float)(-(float)l_392) / (float)(((float)((l_349.f0 > ((l_392 < (((l_349.f2 <= func_79(l_395, l_345.f0, l_396)) >= 0x8.A05CA2p+22) >= p_94)) != p_94)) == (-0x1.8p-1)) / (float)l_396) != 0xD.6392CDp+88)) > 0x1.9369D8p+0) <= 0x1.Cp+1))) >= 0x2.41EB15p-35));
                    }
                    for (l_349.f3 = 2; (l_349.f3 <= 21); l_349.f3++)
                    { /* block id: 252 */
                        int32_t **l_401 = (void*)0;
                        float l_406 = (-0x1.Cp+1);
                        float *l_405 = &l_406;
                        l_402 = &l_338;
                        (*l_405) = ((float)(*l_402) + (float)((*l_402) == p_94));
                    }
                    l_355 = l_355;
                }
                if (p_94)
                    break;
                if ((*l_402))
                    break;
            }
            (***l_342) = l_376;
        }
        else
        { /* block id: 262 */
            struct S0 l_407 = {0UL,4613,0UL,18446744073709551615UL,0xE18F58E4L};
            l_376 = l_376;
            (***l_342) = l_407;
        }
        (***l_342) = (***l_342);
        (*l_409) = l_355;
        (*l_409) = (*l_409);
    }
    else
    { /* block id: 269 */
        int16_t l_414 = 0x8583L;
        for (l_338 = (-29); (l_338 == 16); l_338 += 7)
        { /* block id: 272 */
            int32_t *l_417 = &l_338;
            float l_437 = 0x0.Ep+1;
            float *l_436 = &l_437;
            for (l_345.f3 = 0; (l_345.f3 == 24); l_345.f3++)
            { /* block id: 275 */
                int16_t l_418 = (-3L);
                if (((l_414 < 0xB6FFB877L) && ((((int32_t)0x77488DAAL / (int32_t)p_94) >= ((l_417 != (void*)0) & func_79(p_94, (l_414 || l_418), l_414))) && p_94)))
                { /* block id: 276 */
                    for (l_345.f4 = 0; (l_345.f4 <= 53); l_345.f4 += 1)
                    { /* block id: 279 */
                        struct S0 l_421 = {0UL,10528,18446744073709551609UL,0x2D105EE8748BCDBALL,18446744073709551615UL};
                        struct S0 *l_422 = &l_421;
                        (*l_422) = l_421;
                        (*l_343) = func_95(p_94);
                        /* statement id: 281 */
                        assert (l_344 == 0);
                    }
                }
                else
                { /* block id: 283 */
                    int32_t l_425 = 2L;
                    int32_t *l_424 = &l_425;
                    (*l_424) = l_423;
                    (*l_424) = p_94;
                    if ((*l_424))
                        break;
                }
            }
            (*l_436) = (((((float)l_414 - (float)((p_94 >= (*l_417)) < p_94)) > ((float)l_338 - (float)((0x1.8p+1 <= ((float)0x4.8p+1 - (float)(p_94 != (__builtin_bswap64(((uint16_t)((int16_t)1L >> (int16_t)0) >> (uint16_t)3)) < p_94)))) > l_414))) < p_94) == p_94);
            if (p_94)
                continue;
        }
        /* facts after for loop */
        assert (l_344 == 0 || l_344 == &l_345);
    }
    /* facts after branching */
    assert (l_344 == 0 || l_344 == &l_345);
    return l_438;
    /* statement id: 293 */
    //assert (func_92_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_95(uint32_t  p_96)
{ /* block id: 50 */
    uint16_t l_97 = 0xFD3CL;
    struct S0 l_99 = {5UL,10095,0xE7FB9BE98DF1E582LL,0x275DCB43529ADFF6LL,0x75EB9154L};
    struct S0 *l_98 = &l_99;
    struct S0 *l_100 = &l_99;
    int32_t l_122 = (-6L);
    int32_t *l_121 = &l_122;
    int32_t **l_120 = &l_121;
    int32_t ***l_186 = &l_120;
    uint16_t l_203 = 0xBEDFL;
    struct S0 l_209 = {1UL,3198,18446744073709551609UL,0xC61942F87E49781ELL,0UL};
    int32_t l_294 = 0x0BC5584FL;
    int32_t *****l_299 = (void*)0;
    struct S0 *l_327 = (void*)0;
    if (func_79(l_97, (((__builtin_popcount(p_96) && (l_98 == l_100)) < l_99.f0) >= p_96), p_96))
    { /* block id: 51 */
        int32_t l_103 = (-2L);
        int32_t *l_102 = &l_103;
        int32_t ** const l_101 = &l_102;
        int32_t **l_105 = &l_102;
        int32_t ***l_104 = &l_105;
        uint16_t l_117 = 0xD423L;
        struct S0 *l_136 = &l_99;
        struct S0 *l_139 = (void*)0;
        int32_t l_266 = (-1L);
        uint64_t l_286 = 0x5513274FA118B2DALL;
        int16_t l_288 = 0x6317L;
        int32_t ****l_302 = &l_186;
        int32_t *****l_301 = &l_302;
        (*l_104) = l_101;
    }
    else
    { /* block id: 201 */
        uint32_t l_312 = 0UL;
        int32_t ***l_321 = &l_120;
        for (l_203 = 9; (l_203 < 55); ++l_203)
        { /* block id: 204 */
            (*l_100) = (*l_100);
        }
        if (((uint64_t)(((uint16_t)0xE12AL + (uint16_t)((0x52E9BAA9CE8E05B0LL || __builtin_ffs(((p_96 ^ 1UL) || ((uint16_t)((l_312 || (l_312 || ((uint64_t)(*l_121) / (uint64_t)l_312))) ^ (l_312 >= (*l_121))) >> (uint16_t)14)))) < p_96)) < l_312) / (uint64_t)18446744073709551609UL))
        { /* block id: 207 */
            uint64_t l_319 = 0UL;
            uint64_t l_320 = 0xEB68EF077623B56ALL;
            int32_t * const **l_322 = (void*)0;
            float l_326 = 0x7.1p-1;
            float *l_325 = &l_326;
            (*l_121) = ((int16_t)((uint32_t)(((**l_120) != l_319) ^ p_96) - (uint32_t)p_96) >> (int16_t)15);
            (*l_325) = (l_320 <= ((l_321 != l_322) <= ((float)p_96 + (float)__builtin_parityll((***l_321)))));
        }
        else
        { /* block id: 210 */
            (**l_186) = (**l_321);
        }
    }
    return l_327;
    /* statement id: 214 */
    //assert (func_95_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 216
   depth: 1, occurrence: 26
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 70
breakdown:
   indirect level: 0, occurrence: 26
   indirect level: 1, occurrence: 28
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 2
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 44
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 54
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 27

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 255
   depth: 2, occurrence: 48
   depth: 3, occurrence: 13
   depth: 4, occurrence: 5
   depth: 5, occurrence: 8
   depth: 6, occurrence: 4
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 5
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 24, occurrence: 3
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 209

XXX times a variable address is taken: 195
XXX times a pointer is dereferenced on RHS: 81
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 13
   depth: 3, occurrence: 10
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 147
breakdown:
   depth: 1, occurrence: 113
   depth: 2, occurrence: 20
   depth: 3, occurrence: 11
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 29
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 15
XXX times a pointer is qualified to be dereferenced: 517

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1362
   level: 2, occurrence: 92
   level: 3, occurrence: 262
   level: 4, occurrence: 37
   level: 5, occurrence: 14
XXX number of pointers point to pointers: 99
XXX number of pointers point to scalars: 74
XXX number of pointers point to structs: 36
XXX percent of pointers has null in alias set: 33
XXX average alias set size: 1.17

XXX times a non-volatile is read: 949
XXX times a non-volatile is write: 434
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 7

XXX stmts: 232
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 39
   depth: 2, occurrence: 52
   depth: 3, occurrence: 41
   depth: 4, occurrence: 40
   depth: 5, occurrence: 32

XXX percentage a fresh-made variable is used: 21.1
XXX percentage an existing variable is used: 78.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

