/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1728846994
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int16_t  f0;
   int16_t  f1;
   int64_t  f2;
   const float  f3;
};

union U1 {
   const signed f0 : 14;
   int32_t  f1;
   uint8_t  f2;
};

union U2 {
   const int16_t  f0;
   int16_t  f1;
   int32_t  f2;
   int16_t  f3;
   uint32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_29(void);
static const int32_t * func_32(const uint16_t  p_33, int64_t  p_34);
inline static int16_t  func_49(int16_t  p_50);
inline static float  func_58(uint64_t  p_59, int32_t  p_60);
static uint64_t  func_61(int32_t  p_62);
static uint32_t  func_65(union U1  p_66, float  p_67);
inline static union U1  func_68(int32_t * p_69, union U2  p_70, uint16_t  p_71);
static int32_t * func_72(int32_t * const  p_73, union U2  p_74, int32_t * p_75);
inline static int32_t * func_76(int32_t * p_77, float  p_78);
inline static int32_t * func_79(int32_t  p_80, int32_t  p_81, int16_t  p_82, union U2  p_83, const int32_t  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_29(void)
{ /* block id: 36 */
    float l_30 = 0x0.9p-1;
    int16_t l_31 = 8L;
    if (l_31)
    { /* block id: 37 */
        int32_t l_1130 = (-6L);
        int32_t *l_1129 = &l_1130;
        int32_t **l_1128 = &l_1129;
        (*l_1128) = func_32(l_31, l_31);
        /* statement id: 614 */
        assert (l_1129 == 0);
    }
    else
    { /* block id: 615 */
        float *l_1131 = &l_30;
        (*l_1131) = l_31;
        (*l_1131) = (-0x1.5p+1);
    }
    return l_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_32(const uint16_t  p_33, int64_t  p_34)
{ /* block id: 38 */
    int32_t l_46 = 0x5FCB4448L;
    int32_t *l_45 = &l_46;
    const union U0 *l_1002 = (void*)0;
    float l_1004 = 0x7.6p+1;
    float *l_1003 = &l_1004;
    const int32_t l_1021 = 0x7B5DBADCL;
    const int32_t *l_1036 = &l_46;
    const int32_t *l_1043 = &l_1021;
    const int32_t *l_1044 = &l_46;
    const int32_t *l_1064 = &l_46;
    union U0 l_1080 = {0x96A0L};
    union U0 *l_1079 = &l_1080;
    union U0 **l_1078 = &l_1079;
    union U0 ***l_1077 = &l_1078;
    union U0 ****l_1076 = &l_1077;
    union U0 *l_1095 = &l_1080;
    const int32_t *l_1096 = &l_1021;
    const int32_t *l_1098 = &l_1021;
    const int32_t *l_1100 = (void*)0;
    const int32_t *l_1127 = (void*)0;
lbl_1055:
    (*l_1003) = ((((((float)__builtin_bswap32(((int64_t)__builtin_ffsll(((uint16_t)((uint32_t)((uint16_t)((void*)0 == l_45) >> (uint16_t)((int16_t)func_49((*l_45)) / (int16_t)((uint16_t)(*l_45) >> (uint16_t)5))) / (uint32_t)((uint32_t)((__builtin_bswap64(((int64_t)((uint64_t)(*l_45) + (uint64_t)((*l_45) != (p_33 | ((l_1002 != l_1002) < p_34)))) % (int64_t)p_33)) > (-1L)) && (*l_45)) % (uint32_t)(*l_45))) % (uint16_t)0xE080L)) - (int64_t)(*l_45))) - (float)p_33) <= (*l_45)) != (-0x1.Bp+1)) > (*l_45)) != (*l_45));
    if (p_33)
    { /* block id: 532 */
        uint32_t l_1010 = 0x4E751B11L;
        const union U2 l_1028 = {0xF746L};
        const union U2 *l_1027 = &l_1028;
        const union U2 **l_1026 = &l_1027;
        const union U2 ***l_1025 = &l_1026;
        const int32_t *l_1031 = &l_1021;
        const int32_t *l_1033 = &l_46;
        const int32_t *l_1035 = &l_1021;
        const int32_t *l_1046 = &l_46;
        const int32_t *l_1048 = &l_46;
        union U0 *l_1050 = (void*)0;
        union U0 * const *l_1083 = &l_1050;
        union U0 * const ** const l_1082 = &l_1083;
        union U0 * const ** const *l_1081 = &l_1082;
        if (((*l_45) ^ p_33))
        { /* block id: 533 */
            uint32_t l_1011 = 3UL;
            union U1 l_1018 = {-6L};
            union U1 *l_1017 = &l_1018;
            union U1 **l_1016 = &l_1017;
            union U1 ***l_1015 = &l_1016;
            union U1 ****l_1014 = &l_1015;
            const int32_t *l_1034 = &l_1021;
            const int32_t *l_1038 = &l_1021;
            const int32_t *l_1047 = &l_1021;
            union U0 **l_1051 = &l_1050;
            int32_t **l_1058 = &l_45;
            int32_t *** const l_1057 = &l_1058;
            int32_t *** const *l_1056 = &l_1057;
            const int32_t *l_1063 = &l_1021;
            const int32_t *l_1065 = (void*)0;
            const float *l_1073 = &l_1004;
            const float **l_1072 = &l_1073;
lbl_1054:
            if ((+((uint64_t)((p_33 >= (((((((int64_t)l_1010 + (int64_t)(l_1011 ^ ((uint32_t)(((((p_34 == ((((void*)0 == l_1014) | ((int16_t)(*l_45) / (int16_t)l_1011)) ^ 6UL)) > (-6L)) != l_1010) == p_33) >= l_1018.f0) + (uint32_t)l_1011))) && l_1021) | p_33) && 6UL) == p_33) || l_1010)) != (-1L)) / (uint64_t)p_34)))
            { /* block id: 534 */
                for (l_1011 = (-19); (l_1011 == 55); l_1011++)
                { /* block id: 537 */
                    int32_t **l_1024 = &l_45;
                    (*l_45) = p_33;
                    if (p_33)
                        continue;
                    (*l_1024) = &l_46;
                }
            }
            else
            { /* block id: 542 */
                float l_1029 = 0x6.00614Cp+58;
                const int32_t *l_1030 = &l_1021;
                const int32_t *l_1040 = &l_1021;
                const int32_t *l_1042 = &l_46;
                if (__builtin_popcount((l_1025 != (void*)0)))
                { /* block id: 543 */
                    (*l_45) = 6L;
                }
                else
                { /* block id: 545 */
                    const int32_t *l_1032 = &l_1021;
                    const int32_t *l_1037 = &l_1021;
                    const int32_t *l_1039 = &l_46;
                    const int32_t *l_1041 = &l_1021;
                    const int32_t *l_1045 = &l_46;
                    const int32_t *l_1049 = (void*)0;
                    (*l_45) = p_33;
                    return l_1049;
                    /* statement id: 547 */
                    //assert (func_32_rv == 0);
                }
            }
            (*l_1051) = l_1050;
            if (__builtin_popcountl(((void*)0 != (**l_1025))))
            { /* block id: 551 */
                int32_t **l_1052 = &l_45;
                int32_t **l_1053 = &l_45;
                (*l_1052) = &l_1021;
                /* statement id: 552 */
                assert (l_45 == &l_1021);
                (*l_1053) = l_1038;
            }
            else
            { /* block id: 554 */
                if (l_1021)
                    goto lbl_1054;
                if (l_1021)
                    goto lbl_1055;
            }
            /* facts after branching */
            assert (l_45 == &l_46 || l_45 == &l_1021);
            if (((void*)0 == l_1056))
            { /* block id: 558 */
                const int32_t *l_1062 = &l_46;
                for (l_1010 = 0; (l_1010 == 5); l_1010++)
                { /* block id: 561 */
                    int32_t *l_1061 = (void*)0;
                    l_1061 = &l_46;
                    /* statement id: 562 */
                    assert (l_1061 == &l_46);
                }
                return l_1065;
                /* statement id: 564 */
                //assert (func_32_rv == 0);
            }
            else
            { /* block id: 565 */
                int32_t l_1084 = 0xE174AC10L;
                int32_t l_1092 = 0xCA7A3194L;
                union U0 **l_1094 = &l_1079;
                for (l_1018.f2 = 28; (l_1018.f2 > 11); l_1018.f2--)
                { /* block id: 568 */
                    const int32_t *l_1085 = (void*)0;
                    if ((*l_1034))
                    { /* block id: 569 */
                        if (p_33)
                            break;
                        (***l_1056) = &l_46;
                        /* statement id: 571 */
                        assert (l_45 == &l_46);
                    }
                    else
                    { /* block id: 572 */
                        int32_t l_1068 = 0L;
                        l_1084 = (l_1068 < ((uint16_t)(p_33 > (((+(l_1072 == (void*)0)) != (-2L)) == ((int16_t)(l_1076 == l_1081) + (int16_t)(p_34 <= (18446744073709551615UL <= p_34))))) >> (uint16_t)(*l_1048)));
                        return l_1085;
                        /* statement id: 574 */
                        //assert (func_32_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_45 == &l_46);
                }
                /* facts after for loop */
                                for (p_34 = (-26); (p_34 >= 24); p_34++)
                { /* block id: 579 */
                    int32_t *l_1088 = &l_46;
                    (*l_1088) = p_34;
                    if (p_34)
                        continue;
                    if (p_33)
                    { /* block id: 582 */
                        union U0 ****l_1091 = (void*)0;
                        (*l_1088) = ((uint16_t)65528UL << (uint16_t)((***l_1057) < (-1L)));
                        (*l_1003) = p_33;
                        (*l_1088) = (__builtin_clz(p_33) < (((void*)0 == l_1091) && (l_1084 != __builtin_ffs((*l_1044)))));
                        l_1092 = (***l_1057);
                    }
                    else
                    { /* block id: 587 */
                        const int32_t *l_1093 = (void*)0;
                        return l_1093;
                        /* statement id: 588 */
                        //assert (func_32_rv == 0);
                    }
                }
                (*l_1094) = (***l_1081);
                /* statement id: 591 */
                assert (l_1079 == 0);
            }
            /* facts after branching */
                        assert (l_1079 == 0);
        }
        else
        { /* block id: 593 */
            (*l_45) = ((void*)0 != l_1095);
        }
        /* facts after branching */
        assert (l_45 == &l_46 || l_45 == &l_1021);
        assert (l_1079 == &l_1080 || l_1079 == 0);
    }
    else
    { /* block id: 596 */
        const int32_t *l_1097 = &l_46;
        const int32_t *l_1099 = &l_46;
        (*l_45) = 0x6.043A95p+4;
        return l_1100;
        /* statement id: 598 */
        //assert (func_32_rv == 0);
    }
    /* facts after branching */
    assert (l_45 == &l_46 || l_45 == &l_1021);
    assert (l_1079 == &l_1080 || l_1079 == 0);
    for (l_1080.f2 = 0; (l_1080.f2 >= (-6)); l_1080.f2--)
    { /* block id: 602 */
        float *l_1105 = &l_1004;
        int32_t l_1106 = 0xBBB87B21L;
        union U1 ***l_1120 = (void*)0;
        union U2 *** const **l_1121 = (void*)0;
        union U2 ***l_1124 = (void*)0;
        union U2 ****l_1123 = &l_1124;
        union U2 *****l_1122 = &l_1123;
        if ((0x7BC222D0E8177198LL > ((0xBFD9L > p_34) || 1L)))
        { /* block id: 603 */
            int32_t * const l_1107 = &l_1106;
            int32_t **l_1108 = &l_45;
            (*l_1003) = (p_34 < (((*l_1096) < (func_61(func_49((*l_1096))) != (0xA.5F354Cp-6 < ((float)((void*)0 == l_1105) + (float)0x6.Cp-1)))) <= l_1106));
            (*l_1108) = l_1107;
            /* statement id: 605 */
            assert (l_45 == &l_1106);
        }
        else
        { /* block id: 606 */
            int64_t l_1109 = 1L;
            union U1 **l_1119 = (void*)0;
            union U1 ** const *l_1118 = &l_1119;
            (*l_1003) = ((l_1109 < ((*l_1076) != (void*)0)) != ((float)func_58(((uint16_t)((int64_t)p_33 % (int64_t)((int16_t)l_1109 - (int16_t)(((-1L) < (&l_1105 != (void*)0)) != ((l_1118 != l_1120) != 0UL)))) >> (uint16_t)p_33), p_34) + (float)l_1106));
        }
        /* facts after branching */
        //assert (l_45 == &l_46 || l_45 == &l_1021 || l_45 == dangling || l_45 == &l_1106);
        (*l_1122) = (void*)0;
        /* statement id: 609 */
        assert (l_1123 == 0);
        l_46 = ((int16_t)p_33 >> (int16_t)8);
    }
    /* facts after for loop */
    //assert (l_45 == &l_46 || l_45 == &l_1021 || l_45 == dangling);
        l_46 = 1L;
    return l_1127;
    /* statement id: 613 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_49(int16_t  p_50)
{ /* block id: 39 */
    int16_t l_55 = (-5L);
    uint32_t l_87 = 0x268D9A65L;
    union U2 l_88 = {0x426CL};
    int32_t l_715 = 0xA6901545L;
    int32_t *l_714 = &l_715;
    const uint32_t l_725 = 0UL;
    float l_833 = 0x3.47BDACp-18;
    float *l_832 = &l_833;
    union U1 ****l_835 = (void*)0;
    union U1 *****l_834 = &l_835;
    union U2 *l_842 = &l_88;
    union U2 **l_841 = &l_842;
    union U2 ***l_840 = &l_841;
    uint64_t l_843 = 4UL;
    union U0 l_922 = {7L};
    union U0 *l_921 = &l_922;
    union U0 **l_920 = &l_921;
    union U0 ***l_919 = &l_920;
    union U0 ****l_918 = &l_919;
    int32_t * const ****l_981 = (void*)0;
    (*l_832) = ((float)((float)0x0.721867p+57 + (float)(l_55 > p_50)) + (float)((float)func_58(func_61((4294967295UL < ((uint16_t)(func_65(func_68(func_72(func_76(func_79(((((uint16_t)__builtin_clz(l_55) << (uint16_t)5) <= l_55) >= l_87), (((l_55 ^ l_55) < l_55) < 0x3DB47DC46221EB1ELL), l_87, l_88, p_50), l_88.f0), l_88, l_714), l_88, p_50), l_87) && 0x1E8CCA5AL) - (uint16_t)l_725))), p_50) + (float)p_50));
    (*l_714) = (((void*)0 != l_834) < ((uint16_t)(((int64_t)0xDED2DD5654EBEAC6LL / (int64_t)(*l_714)) && (l_840 == &l_841)) - (uint16_t)func_61(l_843)));
    for (l_843 = 0; (l_843 == 30); ++l_843)
    { /* block id: 452 */
        uint32_t l_848 = 1UL;
        union U1 *****l_849 = (void*)0;
        int32_t * const l_850 = &l_715;
        int32_t **l_851 = (void*)0;
        int32_t **l_852 = &l_714;
        (*l_832) = ((float)l_848 + (float)(l_849 == (void*)0));
        (*l_852) = l_850;
    }
    for (l_88.f1 = (-23); (l_88.f1 == (-2)); l_88.f1++)
    { /* block id: 458 */
        uint32_t l_864 = 0xFEA501A8L;
        union U1 l_869 = {-2L};
        union U1 * const * const *l_891 = (void*)0;
        union U1 * const * const **l_890 = &l_891;
        int32_t * const l_905 = &l_715;
        uint8_t l_936 = 0x46L;
        int32_t *l_951 = &l_715;
        int32_t **l_969 = (void*)0;
        int32_t ***l_968 = &l_969;
        int32_t ****l_967 = &l_968;
        (*l_841) = (**l_840);
        for (l_87 = 22; (l_87 == 52); ++l_87)
        { /* block id: 462 */
            union U1 l_859 = {3L};
            union U1 *l_858 = &l_859;
            union U1 **l_857 = &l_858;
            int16_t l_872 = 0xF838L;
            union U2 l_903 = {1L};
            union U0 l_908 = {0xE2FFL};
            union U0 *l_907 = &l_908;
            union U0 **l_906 = &l_907;
            int32_t **l_911 = &l_714;
            float **l_989 = &l_832;
            (*l_857) = (void*)0;
            /* statement id: 463 */
            assert (l_858 == 0);
        }
    }
    /* facts after for loop */
        return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_58(uint64_t  p_59, int32_t  p_60)
{ /* block id: 442 */
    int32_t l_813 = (-8L);
    int32_t *l_812 = &l_813;
    const int32_t *l_823 = &l_813;
    const int32_t **l_822 = &l_823;
    union U0 l_828 = {0xC545L};
    union U0 *l_827 = &l_828;
    union U0 **l_826 = &l_827;
    union U0 ***l_825 = &l_826;
    union U0 ****l_824 = &l_825;
    union U0 *****l_829 = (void*)0;
    union U0 ****l_830 = &l_825;
    uint16_t l_831 = 7UL;
    l_812 = l_812;
    (*l_822) = func_76(func_76(&l_813, ((float)p_59 / (float)((-0x1.Ep+1) >= ((float)p_59 + (float)p_59)))), ((float)(*l_812) + (float)func_61((((int32_t)(*l_812) / (int32_t)(*l_812)) == (*l_812)))));
    l_830 = l_824;
    (*l_812) = p_59;
    return l_831;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_61(int32_t  p_62)
{ /* block id: 408 */
    union U2 l_729 = {0x2FA4L};
    union U2 *l_728 = &l_729;
    union U2 **l_727 = &l_728;
    union U2 ***l_726 = &l_727;
    union U2 ** const **l_730 = (void*)0;
    union U2 ****l_731 = &l_726;
    union U1 l_738 = {0L};
    const union U1 *l_737 = &l_738;
    const union U1 **l_736 = &l_737;
    float l_810 = 0x0.Fp+1;
    int32_t l_811 = (-1L);
    (*l_731) = l_726;
    if ((((((uint16_t)(1UL ^ __builtin_bswap64(p_62)) + (uint16_t)((l_729.f0 ^ (((int16_t)l_729.f3 >> (int16_t)2) >= ((*l_731) == (void*)0))) || l_729.f0)) <= (l_736 == (void*)0)) || 0x6F967563L) > l_729.f0))
    { /* block id: 410 */
        float l_744 = 0xD.598163p-30;
        float *l_743 = &l_744;
        (*l_743) = (((((float)l_738.f0 - (float)(p_62 != 0x1.2p-1)) != 0x5.F0BB95p-24) >= ((float)p_62 + (float)((-0x1.7p-1) >= p_62))) != p_62);
    }
    else
    { /* block id: 412 */
        int64_t l_745 = (-6L);
        uint64_t l_770 = 18446744073709551612UL;
        union U2 l_772 = {0x70FAL};
        int32_t l_779 = 0x84FED21FL;
        int32_t *l_778 = &l_779;
        union U1 **** const l_809 = (void*)0;
        if (l_745)
        { /* block id: 413 */
            float l_746 = 0x8.1CA09Ap-91;
            return p_62;
        }
        else
        { /* block id: 415 */
            int32_t *l_748 = (void*)0;
            int32_t **l_747 = &l_748;
            union U0 ** const l_754 = (void*)0;
            union U0 ** const *l_753 = &l_754;
            int32_t l_755 = 8L;
            union U1 l_800 = {0x6633D5E6L};
            union U1 *l_808 = &l_800;
            union U1 **l_807 = &l_808;
            union U1 ***l_806 = &l_807;
            union U1 ****l_805 = &l_806;
            (*l_747) = (void*)0;
            if ((((uint16_t)p_62 << (uint16_t)2) ^ (0xB95383CB7436B2F3LL >= ((((int16_t)l_738.f0 / (int16_t)p_62) <= ((void*)0 == l_753)) <= p_62))))
            { /* block id: 417 */
lbl_783:
                l_755 = 3L;
            }
            else
            { /* block id: 419 */
                uint16_t l_771 = 65531UL;
                int32_t l_775 = 0L;
                union U2 *l_782 = &l_729;
                int32_t l_802 = 0x9332367EL;
                for (l_738.f1 = (-25); (l_738.f1 != 10); ++l_738.f1)
                { /* block id: 422 */
                    union U1 *l_767 = &l_738;
                    union U1 **l_766 = &l_767;
                    union U1 *** const l_765 = &l_766;
                    union U1 *** const *l_764 = &l_765;
                    int32_t * const l_776 = &l_775;
                    union U2 l_777 = {0x1BECL};
                    (*l_747) = func_79(l_745, (((uint64_t)0UL / (uint64_t)((uint16_t)((uint32_t)((void*)0 != l_764) / (uint32_t)((((int16_t)l_770 >> (int16_t)((p_62 >= p_62) ^ p_62)) != (func_65((**l_766), p_62) >= 65534UL)) || p_62)) - (uint16_t)p_62)) | p_62), l_771, l_772, p_62);
                    /* statement id: 423 */
                    assert (l_748 == 0);
                    l_775 = ((int16_t)l_771 >> (int16_t)9);
                    (*l_747) = func_72(l_776, l_777, l_778);
                    /* statement id: 425 */
                    assert (l_748 == &l_779);
                    for (l_745 = (-26); (l_745 >= (-10)); l_745 += 4)
                    { /* block id: 428 */
                        union U1 ***l_785 = &l_766;
                        union U1 ****l_784 = &l_785;
                        (*l_727) = l_782;
                        if (l_777.f3)
                            goto lbl_783;
                        (*l_784) = (void*)0;
                        /* statement id: 431 */
                        assert (l_785 == 0);
                        return p_62;
                    }
                }
                /* facts after for loop */
                                assert (l_748 == &l_779 || l_748 == 0);
                l_811 = (((float)(0x0.Fp+1 == (((float)((float)((+p_62) >= func_65((*l_737), (-(float)((float)(((float)((float)(func_65(l_800, __builtin_ctz((~l_802))) <= (((float)((l_805 != l_809) != 0xC.70E5B0p+39) - (float)(*l_778)) > l_810)) - (float)0x0.3p-1) + (float)p_62) < p_62) + (float)(-0x1.Ap-1))))) / (float)(*l_778)) / (float)p_62) == p_62)) / (float)l_771) <= p_62);
                (*l_778) = (*l_778);
                (*l_778) = (*l_778);
            }
            /* facts after branching */
            assert (l_748 == &l_779 || l_748 == 0);
        }
    }
    return l_738.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_65(union U1  p_66, float  p_67)
{ /* block id: 406 */
    int16_t l_724 = 0L;
    return l_724;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_68(int32_t * p_69, union U2  p_70, uint16_t  p_71)
{ /* block id: 404 */
    union U1 l_723 = {0xDFB6E76DL};
    return l_723;
    /* statement id: 405 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_72(int32_t * const  p_73, union U2  p_74, int32_t * p_75)
{ /* block id: 394 */
    union U1 l_719 = {-1L};
    union U1 *l_718 = &l_719;
    uint64_t l_720 = 0xD611F1D0EDBA3515LL;
    float l_722 = 0xB.2991C5p+13;
    float *l_721 = &l_722;
    for (p_74.f1 = 0; (p_74.f1 != (-25)); --p_74.f1)
    { /* block id: 397 */
        return p_75;
        /* statement id: 398 */
        //assert (func_72_rv == &l_715 || func_72_rv == &l_779);
    }
    /* facts after for loop */
        l_718 = l_718;
    (*p_75) = (*p_75);
    (*l_721) = l_720;
    return p_75;
    /* statement id: 403 */
    //assert (func_72_rv == &l_715 || func_72_rv == &l_779);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_76(int32_t * p_77, float  p_78)
{ /* block id: 73 */
    int32_t l_133 = 0x5EB5F4D7L;
    union U0 *l_172 = (void*)0;
    union U0 **l_171 = &l_172;
    union U2 l_175 = {3L};
    int32_t l_226 = 0xAE951E9AL;
    int32_t *l_225 = &l_226;
    union U1 ***l_262 = (void*)0;
    int64_t l_273 = (-10L);
    uint32_t l_276 = 0UL;
    int32_t l_289 = 8L;
    const union U1 *****l_295 = (void*)0;
    union U2 *l_303 = &l_175;
    union U2 **l_302 = &l_303;
    uint8_t l_361 = 0xD7L;
    uint16_t l_371 = 0xD920L;
    uint32_t l_414 = 1UL;
    int32_t l_491 = (-1L);
    union U1 l_537 = {-7L};
    union U1 *l_536 = &l_537;
    union U1 **l_535 = &l_536;
    uint64_t l_538 = 18446744073709551606UL;
    float *l_539 = (void*)0;
    float l_541 = 0x8.9p+1;
    float *l_540 = &l_541;
    float l_542 = 0x8.2B46AFp+89;
    float l_559 = 0x2.6p-1;
    int16_t l_583 = (-6L);
    int32_t **l_673 = &l_225;
    int32_t ***l_672 = &l_673;
    int32_t ****l_671 = &l_672;
    uint8_t l_712 = 252UL;
    int32_t *l_713 = &l_491;
    return p_77;
    /* statement id: 393 */
    //assert (func_76_rv == 0 || func_76_rv == &l_813 || func_76_rv == &l_715);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_79(int32_t  p_80, int32_t  p_81, int16_t  p_82, union U2  p_83, const int32_t  p_84)
{ /* block id: 40 */
    int32_t l_90 = 0xD17F4926L;
    int32_t *l_89 = &l_90;
    int32_t **l_91 = (void*)0;
    int32_t **l_92 = &l_89;
    union U0 l_105 = {0xD0E7L};
    union U0 *l_104 = &l_105;
    int32_t *l_110 = &l_90;
    int32_t *l_112 = &l_90;
    int32_t *l_132 = (void*)0;
    l_89 = l_89;
    (*l_92) = &l_90;
    if (((((int16_t)((0xDFAC86E89BE308DDLL >= (((-9L) > p_84) <= 0xA718BA30L)) > (**l_92)) - (int16_t)(((((uint16_t)(((((!(((int32_t)(*l_89) % (int32_t)((int16_t)(*l_89) >> (int16_t)4)) | 0x8EE0L)) ^ p_81) ^ (*l_89)) && p_81) > 1UL) % (uint16_t)(*l_89)) || p_83.f0) < (**l_92)) < (*l_89))) && p_80) == p_83.f3))
    { /* block id: 43 */
        uint8_t l_108 = 251UL;
        int32_t ** const l_109 = &l_89;
        int32_t *l_111 = &l_90;
        int32_t *l_113 = (void*)0;
        for (p_81 = 4; (p_81 <= (-12)); --p_81)
        { /* block id: 46 */
            union U0 **l_106 = &l_104;
            const int32_t l_107 = (-8L);
            (*l_106) = l_104;
            if (l_107)
                continue;
        }
        (**l_92) = ((l_108 == ((void*)0 == l_109)) | ((**l_109) < p_84));
        return l_113;
        /* statement id: 51 */
        //assert (func_79_rv == 0);
    }
    else
    { /* block id: 52 */
        uint64_t l_114 = 0xD6BDADCC66F1EAACLL;
        int32_t *l_116 = &l_90;
        union U0 *l_119 = &l_105;
        if (((0xE2AFE58852677066LL ^ l_114) > (~(l_114 > (0xC2412408L | l_114)))))
        { /* block id: 53 */
            float l_131 = 0x1.6p+1;
            float *l_130 = &l_131;
            if (l_114)
            { /* block id: 54 */
                float l_118 = 0x7.0E62F1p+13;
                float *l_117 = &l_118;
                union U0 **l_120 = &l_119;
                l_116 = &p_80;
                /* statement id: 55 */
                assert (l_116 == &p_80);
                (*l_117) = ((void*)0 != &p_80);
                (*l_120) = l_119;
            }
            else
            { /* block id: 58 */
                float l_122 = (-0x8.Bp+1);
                float *l_121 = &l_122;
                int32_t l_129 = 0xF4160CA1L;
                (*l_121) = (*l_110);
                for (p_81 = 29; (p_81 < 19); p_81--)
                { /* block id: 62 */
                    (*l_121) = (((float)0x1.5p+1 - (float)(p_83.f1 < (((float)((__builtin_bswap64(p_80) == (l_116 != l_116)) > p_83.f1) / (float)l_129) < p_83.f1))) >= p_80);
                }
                (*l_121) = (*l_116);
            }
            /* facts after branching */
            assert (l_116 == &l_90 || l_116 == &p_80);
            (*l_130) = p_82;
        }
        else
        { /* block id: 68 */
            (*l_116) = (&l_119 == &l_104);
        }
        /* facts after branching */
        assert (l_116 == &l_90 || l_116 == &p_80);
    }
    return l_132;
    /* statement id: 72 */
    //assert (func_79_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 306
XXX total union variables: 21

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 39
breakdown:
   indirect level: 0, occurrence: 3
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 8
   indirect level: 4, occurrence: 10
   indirect level: 5, occurrence: 6
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 16
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 13
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 9

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 140
   depth: 2, occurrence: 20
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 3
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 333

XXX times a variable address is taken: 301
XXX times a pointer is dereferenced on RHS: 126
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 20
   depth: 3, occurrence: 4
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 166
breakdown:
   depth: 1, occurrence: 159
   depth: 2, occurrence: 4
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 47
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 19
XXX times a pointer is qualified to be dereferenced: 597

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 337
   level: 2, occurrence: 75
   level: 3, occurrence: 28
   level: 4, occurrence: 13
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 178
XXX number of pointers point to scalars: 114
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.2
XXX average alias set size: 1.14

XXX times a non-volatile is read: 1146
XXX times a non-volatile is write: 428
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 9

XXX stmts: 120
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 20
   depth: 2, occurrence: 17
   depth: 3, occurrence: 22
   depth: 4, occurrence: 16
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

