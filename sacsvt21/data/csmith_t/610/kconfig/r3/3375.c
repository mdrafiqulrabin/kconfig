/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1591107608
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   unsigned f0 : 31;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 0U;
static int32_t g_25 = 0xC8F0D071;
static struct S1 g_61 = {4857};
static struct S0 g_103 = {-510};
static int32_t g_135 = (-2);
static uint32_t g_201 = 0x54092619;
static struct S0 g_499 = {7965};
static int32_t g_519 = 3;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_24(void);
static uint16_t  func_27(struct S0  p_28, uint32_t  p_29, uint32_t  p_30);
static struct S1  func_38(uint16_t  p_39, int32_t  p_40);
static int32_t  func_51(struct S1  p_52, uint16_t  p_53, uint16_t  p_54, uint32_t  p_55, struct S1  p_56);
static int32_t  func_64(int16_t  p_65, uint32_t  p_66);
static int16_t  func_70(int16_t  p_71, uint32_t  p_72, uint32_t  p_73, uint32_t  p_74, uint32_t  p_75);
static int32_t  func_82(uint32_t  p_83);
static struct S0  func_91(uint32_t  p_92, uint16_t  p_93, uint16_t  p_94);
static int32_t  func_95(struct S0  p_96, int16_t  p_97, int32_t  p_98);
static struct S0  func_99(uint32_t  p_100, uint32_t  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_25 g_61 g_103 g_135 g_201 g_519
 * writes: g_25 g_103 g_61 g_135 g_201 g_499
 */
static int16_t  func_24(void)
{ /* block id: 36 */
    uint16_t l_26 = 0x8F4F;
    struct S0 l_31 = {-6729};
    int32_t l_36 = 0xC3A60813;
    int32_t l_37 = (-1);
    g_25 = (0xA0D461E3 & g_5);
    l_31.f0 = (__builtin_popcountl((l_26 || l_26)) > func_27(l_31, (((int32_t)((uint32_t)__builtin_ffsll(g_5) % (uint32_t)((2 && g_25) ^ __builtin_popcountl(l_36))) + (int32_t)l_26) <= 0x75DAA08B), l_37));
    l_36 = (-3);
    return g_201;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_25 g_61 g_103 g_135 g_201 g_519
 * writes: g_103 g_61 g_25 g_135 g_201 g_499
 */
static uint16_t  func_27(struct S0  p_28, uint32_t  p_29, uint32_t  p_30)
{ /* block id: 38 */
    struct S1 l_57 = {2158};
    int16_t l_542 = 0xC681;
    l_57 = func_38(g_5, (((int32_t)((int16_t)((uint32_t)((int32_t)((uint32_t)0xE96BB645 - (uint32_t)(func_51(l_57, (!(((int32_t)(l_57.f0 >= l_57.f0) - (int32_t)g_25) >= g_5)), p_29, g_25, g_61) >= 0xD294866E)) % (int32_t)g_519) + (uint32_t)1) << (int16_t)g_5) + (int32_t)g_519) ^ 4294967293U));
    p_28.f0 = ((g_519 != ((p_28.f0 > (((uint32_t)(7 >= l_57.f0) % (uint32_t)l_57.f0) < ((((int16_t)(p_30 != (((int16_t)(__builtin_parityll((l_542 == p_29)) <= g_61.f0) + (int16_t)(-3)) && l_542)) << (int16_t)3) & p_28.f0) <= g_201))) > g_5)) == (-1));
    return l_542;
}


/* ------------------------------------------ */
/* 
 * reads : g_25
 * writes: g_103.f0
 */
static struct S1  func_38(uint16_t  p_39, int32_t  p_40)
{ /* block id: 316 */
    uint32_t l_530 = 0U;
    int32_t l_531 = 0;
    int32_t l_532 = (-1);
    struct S1 l_533 = {3873};
    l_531 = (((uint16_t)0xE26C + (uint16_t)1U) & (((int32_t)((int16_t)((uint16_t)((9 ^ 0x94A4F0EC) == p_39) + (uint16_t)(p_40 <= ((((p_39 ^ p_39) >= g_25) | 0x9E20) > 1))) >> (int16_t)3) % (int32_t)l_530) < 0xE8DE9C3C));
    g_103.f0 = l_532;
    return l_533;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_61.f0 g_103 g_25 g_61 g_135 g_201 g_519
 * writes: g_103 g_61 g_25 g_135 g_201 g_499
 */
static int32_t  func_51(struct S1  p_52, uint16_t  p_53, uint16_t  p_54, uint32_t  p_55, struct S1  p_56)
{ /* block id: 39 */
    int32_t l_69 = 0xE2CCF58D;
    uint32_t l_417 = 4294967295U;
    l_69 = ((((int16_t)((func_64(p_53, ((uint16_t)l_69 - (uint16_t)(func_70(((uint16_t)((uint16_t)((uint16_t)(l_69 <= func_82(((uint16_t)((uint32_t)l_69 % (uint32_t)0x6B495482) - (uint16_t)p_54))) << (uint16_t)11) % (uint16_t)((int32_t)(l_69 || ((-6) ^ l_69)) - (int32_t)g_5)) << (uint16_t)l_417), g_5, l_417, g_5, l_417) < g_5))) < g_5) > p_52.f0) << (int16_t)14) && g_5) != g_5);
    g_103.f0 = ((uint16_t)((uint16_t)g_135 >> (uint16_t)((l_417 != 0x54E2F47A) ^ ((uint16_t)((65528U >= ((int16_t)0xD1DE % (int16_t)((((p_56.f0 ^ 0xFB32) != l_69) || (((int16_t)0xD12B << (int16_t)13) < g_5)) | g_201))) <= (-1)) + (uint16_t)g_519))) + (uint16_t)0x04A2);
    g_61 = p_52;
    l_69 = ((uint32_t)(l_417 | l_417) + (uint32_t)g_135);
    return l_417;
}


/* ------------------------------------------ */
/* 
 * reads : g_25
 * writes: g_103 g_499
 */
static int32_t  func_64(int16_t  p_65, uint32_t  p_66)
{ /* block id: 307 */
    uint16_t l_498 = 0x0039;
    uint32_t l_507 = 0xBEADE78D;
    int32_t l_508 = 0x2E9DD434;
    g_499 = func_99(l_498, g_25);
    l_508 = ((int16_t)((uint16_t)(-(uint32_t)(((int16_t)l_498 - (int16_t)l_507) && 3U)) >> (uint16_t)10) + (int16_t)65535U);
    return l_498;
}


/* ------------------------------------------ */
/* 
 * reads : g_103 g_25 g_5 g_61.f0 g_61 g_201 g_135
 * writes: g_135 g_25 g_61 g_103.f0
 */
static int16_t  func_70(int16_t  p_71, uint32_t  p_72, uint32_t  p_73, uint32_t  p_74, uint32_t  p_75)
{ /* block id: 264 */
    int16_t l_424 = 0xEA5E;
    int32_t l_432 = 0x1BF074DA;
    uint32_t l_454 = 0x86876B8A;
    struct S1 l_496 = {29699};
    for (p_72 = 0; (p_72 <= 33); p_72 += 3)
    { /* block id: 267 */
        struct S0 l_425 = {3259};
        struct S1 l_428 = {11981};
        struct S1 l_457 = {135};
        uint32_t l_492 = 0x881C60C0;
        g_135 = func_95(g_103, ((((uint16_t)((uint16_t)(l_424 < func_95(l_425, (l_425.f0 & g_25), (0xC588 < (4U & l_425.f0)))) << (uint16_t)l_424) - (uint16_t)l_424) != p_72) != 0x482857D9), p_74);
        for (g_25 = 13; (g_25 < 4); g_25 -= 1)
        { /* block id: 271 */
            uint32_t l_429 = 4294967295U;
            uint32_t l_455 = 0U;
            struct S1 l_497 = {44242};
            l_428 = g_61;
            if (l_425.f0)
                continue;
            l_432 = (l_429 && (((int16_t)g_201 << (int16_t)0) || p_72));
            if ((__builtin_clzl(((int16_t)(g_135 | g_135) << (int16_t)p_74)) != (((int16_t)0x3782 >> (int16_t)0) == (p_75 == g_25))))
            { /* block id: 275 */
                struct S1 l_456 = {33830};
                int32_t l_461 = 0x0E8BD0BC;
                g_61 = g_61;
                l_425.f0 = ((uint16_t)((int32_t)((uint16_t)((uint16_t)(((((int32_t)(((int16_t)0xD021 + (int16_t)(-(uint16_t)(__builtin_clzll(g_61.f0) < ((int16_t)0x9B04 % (int16_t)((int16_t)p_74 << (int16_t)g_135))))) && 0xC8A2) % (int32_t)l_424) ^ (((l_425.f0 && l_454) && 0xAF70949F) < 1)) & g_135) || 0U) % (uint16_t)l_455) << (uint16_t)4) - (int32_t)p_72) >> (uint16_t)g_135);
                if (l_454)
                { /* block id: 278 */
                    l_457 = l_456;
                    g_61 = g_61;
                    for (p_74 = 15; (p_74 != 8); p_74 -= 7)
                    { /* block id: 283 */
                        struct S1 l_460 = {28873};
                        l_457 = l_460;
                        g_103.f0 = (4294967295U > ((0x68E7 && p_73) != (g_5 || 0x0AFE82C0)));
                        l_461 = p_71;
                    }
                }
                else
                { /* block id: 288 */
                    uint16_t l_464 = 65535U;
                    l_425.f0 = ((int16_t)p_71 << (int16_t)3);
                    l_464 = l_456.f0;
                }
                l_461 = ((((((int32_t)l_432 % (int32_t)((int16_t)g_103.f0 + (int16_t)((int32_t)__builtin_clz(l_457.f0) - (int32_t)((int16_t)(-1) << (int16_t)(((uint16_t)((int32_t)((uint32_t)((uint32_t)((uint16_t)(!p_74) >> (uint16_t)g_103.f0) - (uint32_t)((uint32_t)(((uint32_t)((int16_t)l_424 % (int16_t)((int32_t)l_492 - (int32_t)g_5)) % (uint32_t)p_73) || 0x87055465) - (uint32_t)g_5)) % (uint32_t)(-6)) + (int32_t)l_454) << (uint16_t)g_201) > p_71))))) != 65535U) < 0xC26DD470) > p_73) <= l_461);
            }
            else
            { /* block id: 293 */
                struct S1 l_493 = {7112};
                l_493 = l_428;
                for (l_454 = (-21); (l_454 < 5); l_454 += 3)
                { /* block id: 297 */
                    l_497 = l_496;
                    if (p_73)
                        continue;
                    l_496 = l_496;
                }
                if (l_457.f0)
                    break;
            }
        }
    }
    return l_496.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_61.f0 g_103 g_25 g_61 g_135 g_201
 * writes: g_103 g_61 g_25 g_135 g_201
 */
static int32_t  func_82(uint32_t  p_83)
{ /* block id: 40 */
    int32_t l_88 = 0x7B8A5F03;
    struct S1 l_379 = {18035};
    struct S0 l_392 = {-3102};
    if (l_88)
    { /* block id: 41 */
        return g_5;
    }
    else
    { /* block id: 43 */
        int16_t l_90 = 0;
        struct S0 l_301 = {3920};
        uint16_t l_317 = 0x7D87;
        uint16_t l_375 = 1U;
        struct S1 l_380 = {433};
        if ((!l_90))
        { /* block id: 44 */
            int32_t l_114 = 0xA3D91D69;
            int32_t l_304 = (-1);
            struct S0 l_357 = {6282};
            int32_t l_368 = 0xBEA12880;
            l_301 = func_91((func_95(func_99(l_88, p_83), g_5, (0xD795 || (((-10) || (((int16_t)p_83 >> (int16_t)14) > 0)) > p_83))) >= l_114), p_83, g_5);
            for (g_25 = (-10); (g_25 != (-15)); g_25 -= 1)
            { /* block id: 174 */
                l_88 = (l_88 && (1U ^ ((g_25 | (((l_304 >= (0xE1962AD8 | ((uint16_t)0xE188 + (uint16_t)l_88))) < __builtin_bswap64(p_83)) && 0x7A1F)) == p_83)));
                return g_201;
            }
            if (p_83)
            { /* block id: 178 */
                uint16_t l_310 = 0x2AFE;
                struct S0 l_311 = {-915};
                int32_t l_316 = (-1);
                if (p_83)
                { /* block id: 179 */
                    int32_t l_307 = 1;
                    return l_307;
                }
                else
                { /* block id: 181 */
                    struct S0 l_312 = {373};
                    for (l_304 = 0; (l_304 >= (-8)); l_304 -= 1)
                    { /* block id: 184 */
                        l_310 = g_25;
                        l_312 = l_311;
                    }
                }
                l_301.f0 = p_83;
                for (g_201 = 18; (g_201 > 56); g_201 += 1)
                { /* block id: 192 */
                    struct S1 l_322 = {24593};
                    int32_t l_330 = 0x0D2922DF;
                    if (__builtin_bswap64(p_83))
                    { /* block id: 193 */
                        g_103.f0 = (p_83 | (~(__builtin_parity(g_135) ^ ((-10) && (l_316 ^ (l_317 & (7 == 0x53CF)))))));
                        l_301.f0 = p_83;
                    }
                    else
                    { /* block id: 196 */
                        if (g_61.f0)
                            break;
                    }
                    for (g_25 = 0; (g_25 < (-29)); g_25 -= 1)
                    { /* block id: 201 */
                        g_135 = func_95(func_99(g_201, l_310), ((uint16_t)p_83 >> (uint16_t)p_83), p_83);
                        l_311.f0 = (g_103.f0 | l_317);
                        g_61 = l_322;
                        l_330 = (((uint16_t)func_95(l_311, (((((int16_t)(0x0E6A5700 != __builtin_bswap32(p_83)) + (int16_t)(p_83 != (l_304 & g_135))) != (-(uint32_t)((p_83 != ((int16_t)(__builtin_clz((func_95(l_301, g_25, g_5) <= p_83)) < p_83) << (int16_t)l_317)) ^ 0U))) == g_25) || g_61.f0), p_83) >> (uint16_t)9) < g_103.f0);
                    }
                    if (((((((uint16_t)6U - (uint16_t)((int16_t)p_83 >> (int16_t)(g_25 == l_330))) | (l_304 & (((uint16_t)g_135 + (uint16_t)(g_5 < l_90)) | ((uint16_t)(p_83 && p_83) >> (uint16_t)12)))) ^ p_83) <= 0x6CCA4D00) || p_83))
                    { /* block id: 207 */
                        struct S0 l_339 = {115};
                        if (g_103.f0)
                            break;
                        l_339 = l_339;
                    }
                    else
                    { /* block id: 210 */
                        uint16_t l_351 = 2U;
                        int32_t l_352 = 5;
                        g_25 = ((p_83 == p_83) != 0x6CFE8687);
                        l_352 = (((((!((l_88 && (g_61.f0 >= ((int16_t)p_83 + (int16_t)0x3B0A))) | ((uint16_t)((int16_t)g_135 >> (int16_t)g_25) << (uint16_t)0))) ^ l_322.f0) < l_310) || ((int16_t)((((((uint16_t)((l_322.f0 != l_351) != p_83) >> (uint16_t)p_83) > l_322.f0) && 1U) | l_317) ^ p_83) % (int16_t)p_83)) && g_201);
                    }
                    l_316 = (g_103.f0 || (g_25 < ((int32_t)p_83 - (int32_t)p_83)));
                }
            }
            else
            { /* block id: 216 */
                uint16_t l_369 = 0xCD57;
                for (g_201 = (-18); (g_201 == 34); g_201 += 1)
                { /* block id: 219 */
                    int32_t l_367 = 0xE7C90FF4;
                    int32_t l_376 = (-1);
                    l_357.f0 = func_95(l_357, p_83, p_83);
                    if ((p_83 != (((uint16_t)(g_103.f0 && (((__builtin_parityll(l_88) <= (((uint32_t)((g_201 & (l_317 ^ ((int32_t)p_83 % (int32_t)(~((int16_t)__builtin_parityll(p_83) << (int16_t)l_367))))) && p_83) % (uint32_t)p_83) & 0x8FE824BA)) < l_114) && g_61.f0)) >> (uint16_t)14) != p_83)))
                    { /* block id: 221 */
                        l_304 = l_368;
                        l_369 = 1;
                        if (l_301.f0)
                            continue;
                    }
                    else
                    { /* block id: 225 */
                        return p_83;
                    }
                    l_88 = (g_61.f0 < ((4294967286U & ((l_368 > ((((l_90 > g_5) == (((0x79C0 != g_61.f0) && g_135) | (((int16_t)((uint16_t)(-(int16_t)(((p_83 >= g_103.f0) && l_367) <= l_367)) + (uint16_t)p_83) + (int16_t)(-1)) > 0xEEEA668F))) == l_375) >= p_83)) == 0x7B00D799)) >= l_368));
                    l_376 = p_83;
                }
                for (l_375 = (-12); (l_375 <= 54); l_375 += 1)
                { /* block id: 233 */
                    l_379 = g_61;
                }
            }
        }
        else
        { /* block id: 237 */
            int16_t l_388 = 0xB5E4;
            int32_t l_414 = 0xCA58404E;
            g_61 = l_380;
            for (p_83 = 0; (p_83 != 55); p_83 += 5)
            { /* block id: 241 */
                struct S1 l_383 = {3909};
                l_383 = g_61;
                for (l_90 = 0; (l_90 <= (-7)); l_90 -= 1)
                { /* block id: 245 */
                    struct S0 l_391 = {-7698};
                    for (g_25 = 0; (g_25 != 20); g_25 += 1)
                    { /* block id: 248 */
                        int32_t l_393 = 4;
                        g_103.f0 = l_388;
                        l_391 = func_99((0U | ((g_61.f0 > (((int16_t)__builtin_clzl(g_61.f0) >> (int16_t)(p_83 & g_201)) ^ g_5)) != l_388)), p_83);
                        l_392 = l_392;
                        return l_393;
                    }
                    l_391.f0 = g_135;
                }
            }
            g_25 = (p_83 & (((!((__builtin_ctzll(g_61.f0) == (p_83 <= (0x95A60534 >= p_83))) || p_83)) >= (((int16_t)((uint16_t)((uint16_t)((int32_t)(g_25 <= ((__builtin_ia32_crc32qi((p_83 || p_83), p_83) <= 9U) ^ g_103.f0)) % (int32_t)g_61.f0) >> (uint16_t)g_5) - (uint16_t)p_83) - (int16_t)65530U) > (-3))) != l_317));
            l_414 = (((uint32_t)((-(int32_t)((int16_t)func_95(l_392, ((((uint16_t)((uint16_t)(p_83 > (__builtin_parityll(p_83) >= (-(int16_t)p_83))) << (uint16_t)7) >> (uint16_t)5) >= (-(uint16_t)p_83)) < l_317), g_25) << (int16_t)8)) >= l_388) % (uint32_t)0x30AFCA1F) | l_379.f0);
        }
    }
    l_392 = l_392;
    g_135 = g_61.f0;
    return l_88;
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_103.f0 g_25 g_135 g_5 g_103 g_201
 * writes: g_61 g_25 g_103 g_135
 */
static struct S0  func_91(uint32_t  p_92, uint16_t  p_93, uint16_t  p_94)
{ /* block id: 53 */
    int16_t l_124 = 0x71D4;
    int32_t l_133 = 0x628AE825;
    struct S1 l_138 = {36777};
    uint32_t l_273 = 0xDE5451DF;
    struct S0 l_300 = {-7262};
    for (p_92 = (-7); (p_92 <= 13); p_92 += 1)
    { /* block id: 56 */
        g_61 = g_61;
    }
    for (p_92 = (-19); (p_92 >= 11); p_92 += 5)
    { /* block id: 61 */
        uint16_t l_132 = 0x7FFA;
        struct S0 l_153 = {-1420};
        uint32_t l_223 = 0x5E15677D;
        int16_t l_268 = 0xB1B5;
        for (p_93 = 18; (p_93 > 32); p_93 += 1)
        { /* block id: 64 */
            int32_t l_121 = 0x35E3C92A;
            struct S0 l_180 = {-5031};
            struct S1 l_258 = {27448};
            l_121 = 0x001120EA;
            for (p_94 = 0; (p_94 > 45); p_94 += 2)
            { /* block id: 68 */
                l_124 = 0xE4C4DC47;
            }
            if ((((int16_t)((uint16_t)g_103.f0 % (uint16_t)g_25) >> (int16_t)10) | g_61.f0))
            { /* block id: 71 */
                int16_t l_131 = 0x5FBE;
                struct S0 l_134 = {-272};
                if ((g_103.f0 == l_121))
                { /* block id: 72 */
                    for (l_124 = (-26); (l_124 == (-20)); l_124 += 1)
                    { /* block id: 75 */
                        l_133 = (((l_131 || 5) >= l_131) > (0x9852 < l_132));
                        return l_134;
                    }
                }
                else
                { /* block id: 79 */
                    g_25 = __builtin_popcount(g_135);
                }
                for (p_94 = 0; (p_94 > 23); p_94 += 1)
                { /* block id: 84 */
                    int32_t l_152 = 0x96F087C2;
                    struct S1 l_162 = {39322};
                    g_61 = l_138;
                    for (l_133 = (-8); (l_133 < (-18)); l_133 -= 3)
                    { /* block id: 88 */
                        l_153 = func_99((-(uint32_t)l_121), (((((uint16_t)__builtin_ctzll(p_92) << (uint16_t)((__builtin_ffsl((((int16_t)((uint16_t)((((uint16_t)g_103.f0 >> (uint16_t)(p_92 & g_103.f0)) ^ (((int16_t)g_5 >> (int16_t)g_5) ^ g_135)) < p_92) - (uint16_t)g_135) << (int16_t)l_152) ^ l_134.f0)) > p_92) | 0xF7219921)) ^ 0x4321B6B7) || g_61.f0) & g_5));
                        g_25 = ((int16_t)p_94 % (int16_t)((int16_t)((l_121 || (func_95(func_99(p_93, ((int16_t)p_94 << (int16_t)13)), (((0xE3D09CE0 == 0x0665BEC7) | ((int16_t)p_93 << (int16_t)7)) == l_134.f0), g_5) && p_92)) >= 0U) >> (int16_t)3));
                        if (p_94)
                            continue;
                    }
                    g_61 = l_162;
                    l_134.f0 = (((uint32_t)l_153.f0 % (uint32_t)((int16_t)p_93 << (int16_t)(((uint16_t)(__builtin_ctz(((uint16_t)((l_133 == ((uint16_t)__builtin_ctzll((8U <= ((0xA4DFBEF9 | ((g_61.f0 > ((uint16_t)((l_152 && ((int16_t)p_93 << (int16_t)p_92)) != 0xA7B65799) - (uint16_t)l_134.f0)) ^ 0x2BD29671)) != 0x6370))) << (uint16_t)1)) <= p_94) << (uint16_t)g_25)) & l_138.f0) + (uint16_t)l_134.f0) | p_93))) <= p_94);
                }
                l_133 = 0;
            }
            else
            { /* block id: 97 */
                uint32_t l_182 = 1U;
                struct S0 l_193 = {-1994};
                struct S1 l_215 = {35518};
                for (l_132 = 0; (l_132 > 10); l_132 += 1)
                { /* block id: 100 */
                    int32_t l_181 = (-1);
                    l_180 = func_99(g_135, (!g_25));
                    l_181 = __builtin_clzll((g_103.f0 == l_133));
                    l_153 = func_99(l_182, l_133);
                }
                if (p_92)
                { /* block id: 105 */
                    uint16_t l_195 = 0U;
                    g_135 = l_133;
                    if (g_103.f0)
                        continue;
                    l_133 = ((int16_t)((int16_t)(p_94 != ((int16_t)l_138.f0 << (int16_t)g_61.f0)) + (int16_t)(((-1) < ((uint16_t)((uint16_t)func_95(l_193, g_103.f0, ((!g_135) ^ (p_92 ^ func_95(g_103, g_103.f0, g_5)))) << (uint16_t)2) << (uint16_t)l_195)) == l_133)) + (int16_t)65527U);
                }
                else
                { /* block id: 109 */
                    struct S0 l_198 = {-5239};
                    for (l_132 = 16; (l_132 > 31); l_132 += 1)
                    { /* block id: 112 */
                        if (g_135)
                            break;
                        l_133 = (p_93 <= 0x821A);
                        l_133 = l_121;
                        return l_198;
                    }
                    for (l_124 = 0; (l_124 < 2); l_124 += 1)
                    { /* block id: 120 */
                        l_153.f0 = func_95(func_99(p_94, l_132), g_25, p_94);
                        g_135 = g_135;
                    }
                    if (g_103.f0)
                        break;
                    if ((0x8BF02E39 || (((0x19CC ^ g_201) & ((int16_t)l_198.f0 << (int16_t)10)) <= func_95(func_99((l_182 || (((int16_t)((int16_t)(-(uint16_t)(l_133 || l_124)) >> (int16_t)(p_92 <= ((int32_t)(((int16_t)(((int16_t)l_193.f0 + (int16_t)p_92) >= 9) >> (int16_t)3) == (-1)) + (int32_t)l_193.f0))) << (int16_t)g_25) | g_135)), g_103.f0), l_182, p_94))))
                    { /* block id: 125 */
                        struct S1 l_216 = {36921};
                        l_216 = l_215;
                        g_135 = ((g_61.f0 > ((int16_t)((int16_t)g_135 << (int16_t)2) % (int16_t)((int32_t)(l_216.f0 == (p_92 || ((g_25 || l_124) < l_223))) + (int32_t)1U))) & func_95(func_99(l_193.f0, p_92), p_94, g_61.f0));
                    }
                    else
                    { /* block id: 128 */
                        uint32_t l_231 = 4294967295U;
                        l_198.f0 = ((int32_t)l_124 - (int32_t)(__builtin_ffs((((((~((uint16_t)((int32_t)p_92 + (int32_t)l_223) - (uint16_t)((((((g_25 & l_198.f0) && p_93) < ((l_231 == (g_61.f0 != l_153.f0)) <= l_121)) & l_124) < l_231) ^ 0x7BF4D477))) || 8U) && 3) ^ 3U) ^ p_94)) || l_223));
                        l_153 = func_99(g_5, (-(uint16_t)(g_201 || 0x446F)));
                        l_133 = ((int16_t)(((uint16_t)p_92 >> (uint16_t)__builtin_parity(g_61.f0)) && __builtin_ia32_crc32qi((g_5 || ((!g_61.f0) ^ (g_5 & ((uint16_t)((g_5 <= ((uint32_t)((l_121 && (((uint16_t)g_135 >> (uint16_t)l_153.f0) >= p_93)) == 0x14C23F78) - (uint32_t)g_25)) <= p_92) - (uint16_t)l_198.f0)))), g_135)) - (int16_t)l_215.f0);
                        g_103.f0 = p_92;
                    }
                }
                if (g_25)
                { /* block id: 135 */
                    uint16_t l_248 = 65535U;
                    struct S0 l_249 = {-5168};
                    l_180.f0 = p_94;
                    if (((int32_t)g_25 + (int32_t)((g_201 || (1U == __builtin_ffs(p_94))) < (((__builtin_ffs(func_95(g_103, g_201, ((uint16_t)l_248 >> (uint16_t)g_61.f0))) <= 1U) == p_92) >= p_92))))
                    { /* block id: 137 */
                        return l_249;
                    }
                    else
                    { /* block id: 139 */
                        uint16_t l_250 = 8U;
                        l_180.f0 = (l_250 < (__builtin_bswap32(p_93) && (-(int32_t)(p_94 || ((int16_t)l_182 >> (int16_t)(((int16_t)g_201 << (int16_t)((uint16_t)(func_95(g_103, ((7 & (l_132 == g_103.f0)) || p_94), g_135) == g_201) % (uint16_t)1)) < l_138.f0))))));
                    }
                }
                else
                { /* block id: 142 */
                    l_153.f0 = 0xF0367B0D;
                }
                l_258 = l_258;
            }
        }
        if ((((g_61.f0 && (((uint32_t)((0xD9B7CDBE <= ((((uint32_t)func_95(func_99(((0xCAEAABA6 < ((int16_t)(0x3124 < (func_95(l_153, (((uint32_t)(!p_94) + (uint32_t)8) ^ p_93), p_94) >= l_268)) << (int16_t)15)) < g_201), g_5), l_138.f0, g_135) % (uint32_t)0x01E5D373) < g_201) > l_268)) <= p_93) % (uint32_t)g_61.f0) && g_25)) && 4294967289U) ^ g_5))
        { /* block id: 148 */
            struct S0 l_271 = {-436};
            g_103.f0 = ((int16_t)1 << (int16_t)g_103.f0);
            return l_271;
        }
        else
        { /* block id: 151 */
            int16_t l_272 = 0x93A5;
            g_25 = __builtin_clzll(l_272);
            g_25 = g_5;
            if (l_272)
                break;
        }
    }
    if (l_273)
    { /* block id: 157 */
        int32_t l_278 = 2;
        int32_t l_281 = 0x87565C97;
        l_278 = func_95(g_103, ((uint32_t)0x9A9337A3 - (uint32_t)0x9974A848), ((((uint16_t)g_5 << (uint16_t)g_25) <= 0) <= (((((p_92 && g_5) != (((l_133 != 0x5C0E044A) & g_103.f0) > l_138.f0)) & p_93) != g_135) >= p_94)));
        if (__builtin_parityl((__builtin_popcount(g_103.f0) | g_103.f0)))
        { /* block id: 159 */
            struct S0 l_279 = {7956};
            g_25 = p_93;
            return l_279;
        }
        else
        { /* block id: 162 */
            struct S1 l_280 = {17583};
            l_280 = l_280;
            l_281 = g_25;
            g_135 = ((int32_t)g_61.f0 % (int32_t)l_281);
        }
    }
    else
    { /* block id: 167 */
        uint16_t l_287 = 0U;
        l_133 = ((!l_287) >= ((l_138.f0 <= (l_273 | ((uint32_t)((uint16_t)g_5 + (uint16_t)((uint16_t)p_93 % (uint16_t)((int16_t)(((uint16_t)l_287 - (uint16_t)(((((__builtin_clzll(((uint16_t)(__builtin_bswap64(g_103.f0) | 0x69CB) + (uint16_t)p_92)) && 0xC3CE8049) < p_94) || g_25) == 0x8925) >= p_92)) | 0xE472) >> (int16_t)p_94))) - (uint32_t)0xC878D31A))) < g_201));
    }
    return l_300;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_61.f0 g_103 g_25
 * writes:
 */
static int32_t  func_95(struct S0  p_96, int16_t  p_97, int32_t  p_98)
{ /* block id: 48 */
    uint32_t l_106 = 0x8228F8F0;
    int32_t l_107 = (-1);
    l_107 = l_106;
    l_107 = (g_5 | (((((uint16_t)(1U < 1) % (uint16_t)(0x186F & ((((((uint32_t)p_96.f0 - (uint32_t)(l_107 <= ((uint32_t)(l_107 ^ l_106) + (uint32_t)p_96.f0))) || 0x087D4E0D) && 4) <= l_106) > g_61.f0))) || l_106) || l_106) < g_61.f0));
    p_96 = g_103;
    return g_25;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_103
 */
static struct S0  func_99(uint32_t  p_100, uint32_t  p_101)
{ /* block id: 45 */
    struct S0 l_102 = {-7651};
    g_103 = l_102;
    return l_102;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_24();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_25, "g_25", print_hash_value);
    transparent_crc(g_61.f0, "g_61.f0", print_hash_value);
    transparent_crc(g_103.f0, "g_103.f0", print_hash_value);
    transparent_crc(g_135, "g_135", print_hash_value);
    transparent_crc(g_201, "g_201", print_hash_value);
    transparent_crc(g_499.f0, "g_499.f0", print_hash_value);
    transparent_crc(g_519, "g_519", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 68
   depth: 1, occurrence: 41
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 41
breakdown:
   indirect level: 0, occurrence: 41
XXX full-bitfields structs in the program: 41
breakdown:
   indirect level: 0, occurrence: 41
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 33
XXX times a bitfields struct on RHS: 48
XXX times a single bitfield on LHS: 22
XXX times a single bitfield on RHS: 97

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 193
   depth: 2, occurrence: 33
   depth: 3, occurrence: 6
   depth: 4, occurrence: 6
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 4
   depth: 15, occurrence: 5
   depth: 16, occurrence: 4
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 19, occurrence: 3
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 580
XXX times a non-volatile is write: 126
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 175
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 10
   depth: 2, occurrence: 24
   depth: 3, occurrence: 24
   depth: 4, occurrence: 40
   depth: 5, occurrence: 43

XXX percentage a fresh-made variable is used: 16.4
XXX percentage an existing variable is used: 83.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

