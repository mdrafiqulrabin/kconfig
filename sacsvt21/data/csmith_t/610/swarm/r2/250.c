/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2040164532
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 8;
   const unsigned f1 : 29;
   unsigned f2 : 11;
   signed f3 : 11;
   unsigned f4 : 14;
   signed f5 : 13;
   const signed f6 : 23;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const int16_t  func_29(void);
static int32_t * func_36(float  p_37, int32_t * p_38, uint8_t  p_39, float  p_40, struct S0  p_41);
static int16_t  func_44(int32_t * p_45, uint8_t  p_46, int32_t * p_47, float  p_48, int32_t * p_49);
static float  func_53(uint8_t  p_54);
static int32_t * func_55(uint32_t  p_56, float  p_57);
static float  func_59(int32_t  p_60);
static int16_t  func_63(uint32_t  p_64, int32_t  p_65, int32_t * p_66, int32_t * p_67, int32_t * p_68);
static int32_t * func_70(int32_t * p_71);
static int32_t * func_72(uint8_t  p_73, int32_t * p_74, uint32_t  p_75, int16_t  p_76);
static uint32_t  func_77(int32_t  p_78);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_29(void)
{ /* block id: 36 */
    int32_t l_30 = 0x203BD652;
    int32_t *l_948 = &l_30;
    struct S0 l_949 = {7,1093,33,22,63,30,-2644};
    int32_t **l_954 = &l_948;
    const int32_t l_955 = 0xB1B10D01;
    for (l_30 = 0; (l_30 > 28); l_30 = safe_add_func_uint16_t_u_u(l_30, 8))
    { /* block id: 39 */
        int32_t l_33 = 0xAAF0A9B2;
        int32_t *l_50 = &l_30;
        struct S0 l_496 = {1,18723,38,7,7,41,-837};
        for (l_33 = 0; (l_33 > (-27)); l_33 = safe_sub_func_uint32_t_u_u(l_33, 1))
        { /* block id: 42 */
            int16_t l_495 = 0xC0F0;
            int32_t **l_947 = &l_50;
            (*l_947) = func_36((safe_add_func_float_f_f(__builtin_popcount((0x3BA6 >= ((func_44(&l_30, __builtin_clzl(l_33), l_50, (safe_mul_func_float_f_f(l_30, func_53(l_30))), &l_33) && (*l_50)) >= l_495))), 0xE.85CE02p-6)), &l_30, (*l_50), (*l_50), l_496);
            /* statement id: 571 */
            assert (l_50 == &l_30);
            (*l_947) = &l_33;
            /* statement id: 572 */
            assert (l_50 == &l_33);
        }
        /* facts after for loop */
        assert (l_50 == &l_33 || l_50 == &l_30);
    }
    (*l_954) = func_72(l_30, func_36(l_30, l_948, (*l_948), (*l_948), l_949), (safe_div_func_int32_t_s_s((*l_948), (((safe_div_func_uint16_t_u_u((*l_948), (*l_948))) < (*l_948)) ^ 0xB0FA6DCC))), (*l_948));
    return l_955;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(float  p_37, int32_t * p_38, uint8_t  p_39, float  p_40, struct S0  p_41)
{ /* block id: 301 */
    int32_t *l_497 = (void*)0;
    int32_t l_499 = 0x647536DF;
    int32_t *l_498 = &l_499;
    uint32_t l_594 = 0xAA672867;
    struct S0 **l_604 = (void*)0;
    const int32_t *l_635 = &l_499;
    const int32_t **l_634 = &l_635;
    const int32_t ***l_633 = &l_634;
    uint16_t l_647 = 1U;
    int32_t **l_662 = &l_498;
    int32_t ***l_661 = &l_662;
    int32_t ****l_660 = &l_661;
    int32_t *****l_659 = &l_660;
    struct S0 *****l_665 = (void*)0;
    uint8_t l_688 = 0x3F;
    int32_t *l_835 = (void*)0;
    int32_t l_916 = 5;
    int32_t **l_940 = &l_835;
    struct S0 l_946 = {1,23157,27,8,7,-25,-2238};
    struct S0 *l_945 = &l_946;
    (*l_498) = (p_41.f0 <= (p_38 != (void*)0));
    for (l_499 = (-7); (l_499 <= (-16)); l_499 = safe_sub_func_uint32_t_u_u(l_499, 6))
    { /* block id: 305 */
        int32_t l_503 = 1;
        int32_t *l_502 = &l_503;
        struct S0 ****l_510 = (void*)0;
        float l_555 = 0x5.79FCC3p+44;
        float *l_554 = &l_555;
        float **l_553 = &l_554;
        uint32_t l_580 = 0x3194C8E7;
        uint32_t l_585 = 1U;
        int32_t ****l_627 = (void*)0;
        int32_t *****l_626 = &l_627;
        struct S0 **l_653 = (void*)0;
        struct S0 *****l_664 = &l_510;
    }
    return p_38;
    /* statement id: 570 */
    //assert (func_36_rv == &l_30);
}


/* ------------------------------------------ */
/* 
 * reads : l_30
 * writes:
 */
static int16_t  func_44(int32_t * p_45, uint8_t  p_46, int32_t * p_47, float  p_48, int32_t * p_49)
{ /* block id: 80 */
    int32_t l_150 = (-6);
    int32_t *l_149 = &l_150;
    int32_t **l_148 = &l_149;
    int32_t ***l_211 = &l_148;
    int32_t ****l_210 = &l_211;
    int32_t *****l_209 = &l_210;
    int32_t *l_333 = (void*)0;
    const struct S0 ***l_352 = (void*)0;
    uint32_t l_462 = 0x7CCAEBB7;
    (*l_148) = p_49;
    /* statement id: 81 */
    //assert (l_149 == &l_33 || l_149 == &l_30 || l_149 == &l_499);
lbl_360:
    for (l_150 = 0; (l_150 == (-9)); l_150--)
    { /* block id: 84 */
        int32_t l_161 = (-1);
        int32_t *l_160 = &l_161;
        int32_t l_230 = 0xEE88BD6E;
    }
    if ((safe_rshift_func_uint16_t_u_s((****l_210), (((safe_rshift_func_uint16_t_u_u(__builtin_ctzl(p_46), 14)) && (safe_lshift_func_uint16_t_u_u(((func_77((*****l_209)) | (safe_mod_func_uint32_t_u_u((**l_148), (***l_211)))) < (****l_210)), 7))) ^ (*****l_209)))))
    { /* block id: 139 */
        int32_t l_275 = 0xCFAA0CEB;
        int32_t l_276 = 0x5E54CF3B;
        float l_293 = (-0x5.8p+1);
        const float *l_292 = &l_293;
        const float **l_291 = &l_292;
        const float ***l_290 = &l_291;
        int16_t l_308 = 0xBA7F;
        int32_t ***l_334 = &l_148;
        float l_337 = (-0x10.Dp-1);
        l_276 = (((((safe_add_func_float_f_f(p_46, ((safe_mul_func_float_f_f(((((safe_div_func_float_f_f(p_46, ((+0x1.7p-1) != ((*l_209) != (void*)0)))) < ((((**l_148) > func_59(p_46)) != p_48) == (*l_149))) > 0x1.Dp+1) < 0xA.0A94A8p-80), 0x4.A9CF79p-37)) < p_46))) == 0xC.5EDEFCp+10) == p_48) >= l_275) < p_48);
        (*l_211) = (***l_209);
        if ((0x71CBBB26 && p_46))
        { /* block id: 142 */
            int32_t l_283 = (-5);
            uint8_t l_297 = 0x67;
            int32_t *l_298 = (void*)0;
            struct S0 l_300 = {10,14887,29,-26,7,-22,-834};
            struct S0 *l_299 = &l_300;
            if ((safe_div_func_int32_t_s_s(((safe_mul_func_int16_t_s_s(((safe_div_func_int32_t_s_s((((l_276 | l_283) & (safe_add_func_int16_t_s_s((-10), ((-10) >= ((p_46 <= 0x9B6F4331) != (((safe_mul_func_int16_t_s_s(((p_46 & (*p_45)) < 0x051D552A), 0x79C1)) <= p_46) == p_46)))))) | p_46), (*p_47))) < p_46), p_46)) && 0xFB12), p_46)))
            { /* block id: 143 */
                if ((*p_49))
                { /* block id: 144 */
                    (****l_209) = p_47;
                }
                else
                { /* block id: 146 */
                    struct S0 **l_301 = &l_299;
                    (*l_301) = l_299;
                }
            }
            else
            { /* block id: 149 */
                int32_t l_305 = (-5);
                const int32_t **l_314 = (void*)0;
                const int32_t ***l_313 = &l_314;
                const int32_t ****l_312 = &l_313;
                (**l_211) = (void*)0;
                /* statement id: 150 */
                assert (l_149 == 0);
                if ((*p_47))
                { /* block id: 151 */
                    l_150 = (*p_45);
                    p_48 = ((*l_209) == (*l_209));
                }
                else
                { /* block id: 154 */
                    int32_t *l_304 = &l_276;
                    for (l_150 = 0; (l_150 == (-8)); l_150--)
                    { /* block id: 157 */
                        (****l_209) = p_47;
                        /* statement id: 158 */
                        //assert (l_149 == &l_30 || l_149 == &l_499 || l_149 == &l_33);
                        (**l_211) = l_304;
                        /* statement id: 159 */
                        assert (l_149 == &l_276);
                    }
                    /* facts after for loop */
                    assert (l_149 == &l_276 || l_149 == 0);
                    p_48 = p_46;
                    (**l_211) = func_55((*l_304), (l_305 >= (safe_mul_func_float_f_f(l_308, (0xE.CB952Bp-66 == (safe_sub_func_float_f_f((-(l_312 == (void*)0)), p_48)))))));
                    /* statement id: 162 */
                    assert (l_149 == 0);
                    for (l_305 = 0; (l_305 > 16); l_305 = safe_add_func_int16_t_s_s(l_305, 1))
                    { /* block id: 165 */
                        int32_t *****l_319 = (void*)0;
                        float l_323 = 0x3.C31470p-54;
                        uint16_t l_328 = 0xD9AC;
                        l_276 = ((((l_319 == (void*)0) | p_46) & ((p_46 ^ (((safe_unary_minus_func_int16_t_s(((*l_304) == ((safe_div_func_int16_t_s_s(p_46, ((safe_sub_func_int16_t_s_s(((void*)0 == &p_47), (safe_sub_func_uint32_t_u_u((((*p_49) > (*p_49)) == 1U), l_300.f2)))) | p_46))) >= 0x7C00BED4)))) > p_46) & 0x76EF)) != (*p_45))) && l_328);
                    }
                }
                (**l_211) = (*l_148);
            }
            /* facts after branching */
            //assert (l_149 == 0 || l_149 == &l_33 || l_149 == &l_30 || l_149 == &l_499);
            l_276 = (-8);
            l_276 = l_308;
            (*l_210) = l_334;
        }
        else
        { /* block id: 174 */
            int32_t ****l_348 = (void*)0;
            uint8_t l_349 = 0xEE;
            uint32_t l_363 = 0xCA28AB6E;
            l_209 = &l_210;
            if ((safe_add_func_uint16_t_u_u(p_46, (safe_rshift_func_int16_t_s_s(p_46, __builtin_clzll(p_46))))))
            { /* block id: 176 */
                int32_t *l_350 = (void*)0;
                int32_t *l_351 = &l_276;
                struct S0 ***l_354 = (void*)0;
                struct S0 ****l_353 = &l_354;
                (*l_351) = (safe_add_func_uint32_t_u_u(((0x321B || 0x9924) && p_46), (((*p_47) && (safe_lshift_func_uint16_t_u_s(((safe_rshift_func_uint16_t_u_u((__builtin_bswap64(((safe_sub_func_int16_t_s_s(0xBF38, (((void*)0 != l_348) || p_46))) | 0x0BF2)) == 0x7A06AB12), 10)) >= 0xEC57FC2B), p_46))) > l_349)));
                (*l_353) = l_352;
                (*l_351) = (***l_334);
            }
            else
            { /* block id: 180 */
                struct S0 l_356 = {6,5472,19,-5,124,79,1114};
                struct S0 *l_355 = &l_356;
                struct S0 **l_357 = &l_355;
                (*l_357) = l_355;
                for (l_308 = 24; (l_308 == (-1)); l_308--)
                { /* block id: 184 */
                    if (p_46)
                        goto lbl_360;
                    l_363 = (safe_add_func_int32_t_s_s((l_356.f2 >= (&l_357 != &l_357)), p_46));
                }
                for (l_276 = (-27); (l_276 > 28); l_276 = safe_add_func_int16_t_s_s(l_276, 2))
                { /* block id: 190 */
                    return (***l_334);
                }
            }
        }
        /* facts after branching */
        //assert (l_149 == 0 || l_149 == &l_33 || l_149 == &l_30 || l_149 == &l_499);
        for (p_46 = 6; (p_46 <= 19); ++p_46)
        { /* block id: 197 */
            int32_t l_369 = 0;
            if ((+(p_46 ^ ((l_369 <= l_276) > p_46))))
            { /* block id: 198 */
                const uint16_t l_370 = 0U;
                int32_t *l_376 = &l_369;
                if (l_370)
                { /* block id: 199 */
                    int32_t *l_371 = &l_150;
                    (*l_371) = 0x19D4D782;
                }
                else
                { /* block id: 201 */
                    float *l_375 = &l_293;
                    float **l_374 = &l_375;
                    for (l_150 = 29; (l_150 >= (-15)); l_150 = safe_sub_func_int16_t_s_s(l_150, 1))
                    { /* block id: 204 */
                        (*l_375) = ((void*)0 == l_374);
                        (****l_209) = l_376;
                        /* statement id: 206 */
                        assert (l_149 == &l_369);
                    }
                    /* facts after for loop */
                    //assert (l_149 == &l_369 || l_149 == dangling || l_149 == 0 || l_149 == &l_33 || l_149 == &l_30 || l_149 == &l_499);
                }
                /* facts after branching */
                //assert (l_149 == &l_369 || l_149 == dangling || l_149 == 0 || l_149 == &l_33 || l_149 == &l_30 || l_149 == &l_499);
            }
            else
            { /* block id: 209 */
                if ((*p_45))
                    break;
            }
            /* facts after branching */
            //assert (l_149 == &l_369 || l_149 == dangling || l_149 == 0 || l_149 == &l_33 || l_149 == &l_30 || l_149 == &l_499);
        }
        /* facts after for loop */
        //assert (l_149 == dangling || l_149 == 0 || l_149 == &l_33 || l_149 == &l_30 || l_149 == &l_499);
    }
    else
    { /* block id: 213 */
        int32_t *l_381 = &l_150;
        int32_t l_384 = 0x112E2B93;
        uint32_t l_403 = 0x3A4A643F;
        struct S0 l_413 = {10,22290,6,35,40,73,572};
        struct S0 *l_412 = &l_413;
        int32_t ***l_422 = (void*)0;
        int32_t *l_430 = &l_384;
        if ((**l_148))
        { /* block id: 214 */
            int32_t *l_385 = &l_384;
            float l_398 = 0xD.BB6D1Ep-25;
            float *l_397 = &l_398;
            float **l_396 = &l_397;
            float l_417 = 0x8.8p-1;
            if (((safe_lshift_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(func_63((***l_211), (*p_47), l_381, p_49, (*l_148)), (((((-1) == ((*p_45) > (safe_lshift_func_uint16_t_u_s((p_46 > 0x2E3B), 1)))) != p_46) == 0x7A479240) && l_384))) <= p_46), p_46)) | 65533U))
            { /* block id: 215 */
                l_385 = p_47;
                /* statement id: 216 */
                //assert (l_385 == &l_30 || l_385 == &l_499 || l_385 == &l_33);
            }
            else
            { /* block id: 217 */
                int32_t l_390 = 0x1AB46CC7;
                int32_t l_418 = (-1);
                (*l_381) = ((safe_add_func_int32_t_s_s((*l_385), ((safe_mod_func_int16_t_s_s(l_390, ((+l_390) || (*l_385)))) & (0x6765D163 ^ (*l_149))))) > p_46);
                p_47 = p_47;
                if ((((safe_add_func_int16_t_s_s(__builtin_bswap32(p_46), 0xDB10)) | 9) || ((func_77((*p_45)) != (((void*)0 == l_396) > (*l_381))) <= p_46)))
                { /* block id: 220 */
                    int32_t *l_415 = &l_150;
                    int32_t ****l_416 = &l_211;
                    for (p_46 = (-14); (p_46 >= 5); ++p_46)
                    { /* block id: 223 */
                        (*l_381) = (safe_rshift_func_uint16_t_u_u((0 | __builtin_clzll(p_46)), (__builtin_clzll(((void*)0 != (*l_210))) | (*p_47))));
                    }
                    if (p_46)
                        goto lbl_409;
lbl_409:
                    for (p_46 = 0; (p_46 != 27); p_46 = safe_add_func_int32_t_s_s(p_46, 1))
                    { /* block id: 228 */
                        struct S0 ****l_408 = (void*)0;
                        (*l_381) = (((safe_sub_func_int32_t_s_s(0x73E67246, func_77((*p_47)))) == ((void*)0 != l_408)) == (**l_148));
                    }
                    for (l_384 = 0; (l_384 < (-15)); l_384 = safe_sub_func_uint32_t_u_u(l_384, 3))
                    { /* block id: 234 */
                        struct S0 **l_414 = &l_412;
                        (*l_414) = l_412;
                        l_381 = l_415;
                        (*l_381) = (l_416 != l_416);
                    }
                    l_418 = (-2);
                }
                else
                { /* block id: 240 */
                    for (l_384 = (-29); (l_384 == 5); l_384 = safe_add_func_uint16_t_u_u(l_384, 1))
                    { /* block id: 243 */
                        int32_t ***l_421 = (void*)0;
                        l_422 = l_421;
                    }
                }
            }
            /* facts after branching */
            //assert (l_385 == &l_384 || l_385 == &l_30 || l_385 == &l_499 || l_385 == &l_33);
        }
        else
        { /* block id: 248 */
            uint32_t l_423 = 0x7CB00655;
            const int32_t *l_432 = &l_384;
            int32_t l_445 = 0xCF3FB13B;
            l_423 = (*p_45);
            if ((0x8CB4 < p_46))
            { /* block id: 250 */
                return p_46;
            }
            else
            { /* block id: 252 */
                struct S0 **l_438 = &l_412;
                struct S0 ***l_437 = &l_438;
                struct S0 ****l_436 = &l_437;
                int32_t l_439 = 0x3908799C;
                (*l_381) = (p_46 > p_46);
                for (p_46 = 0; (p_46 > 43); p_46 = safe_add_func_int32_t_s_s(p_46, 8))
                { /* block id: 256 */
                    uint32_t l_427 = 0x17077844;
                    int32_t *l_431 = (void*)0;
                }
                if ((safe_rshift_func_int16_t_s_u(p_46, 2)))
                { /* block id: 267 */
                    int32_t *l_442 = &l_150;
                    float l_444 = (-0x3.4p+1);
                    float *l_443 = &l_444;
                    p_49 = func_70(l_442);
                    /* statement id: 268 */
                    assert (p_49 == &l_150);
                    (*l_443) = __builtin_clzl((*l_432));
                    (*l_442) = (*p_49);
                    l_445 = (0x907D06C2 | p_46);
                }
                else
                { /* block id: 272 */
                    uint32_t l_446 = 4294967293U;
                    float l_448 = 0x9.55153Cp-11;
                    float *l_447 = &l_448;
                    l_446 = 0xA9F1200F;
                    (*l_447) = (*l_381);
                }
                /* facts after branching */
                //assert (p_49 == &l_33 || p_49 == &l_150 || p_49 == &l_30 || p_49 == &l_499);
            }
            /* facts after branching */
            //assert (p_49 == &l_33 || p_49 == &l_150 || p_49 == &l_30 || p_49 == &l_499);
            return (*****l_209);
        }
    }
    /* facts after branching */
    //assert (l_149 == dangling || l_149 == 0 || l_149 == &l_33 || l_149 == &l_30 || l_149 == &l_499);
    for (p_46 = 0; (p_46 <= 29); p_46 = safe_add_func_int32_t_s_s(p_46, 2))
    { /* block id: 282 */
        float l_451 = (-0x1.3p+1);
        int32_t l_457 = 8;
        struct S0 l_469 = {11,18791,6,-3,34,48,1235};
        struct S0 *l_468 = &l_469;
        struct S0 **l_467 = &l_468;
        struct S0 ***l_466 = &l_467;
        struct S0 ****l_465 = &l_466;
        int32_t ***l_488 = &l_148;
        int16_t l_489 = 1;
        float *l_494 = &l_451;
        if ((0x2486AC3A || (*p_45)))
        { /* block id: 283 */
            int32_t l_452 = 3;
            (****l_209) = func_72(l_452, p_47, (safe_sub_func_uint32_t_u_u((l_452 > (safe_rshift_func_uint16_t_u_u(l_457, func_77((p_46 && ((&p_49 != (***l_209)) && ((0x6C9B00F3 && l_457) != p_46))))))), (*p_49))), l_452);
            /* statement id: 284 */
            //assert (l_149 == &l_30 || l_149 == &l_499 || l_149 == &l_33);
        }
        else
        { /* block id: 285 */
            int32_t *l_458 = (void*)0;
            struct S0 *l_464 = (void*)0;
            struct S0 **l_463 = &l_464;
            (****l_209) = func_72(p_46, l_458, (safe_lshift_func_uint16_t_u_s(((safe_unary_minus_func_uint16_t_u(l_462)) != (((l_463 != (void*)0) == ((void*)0 != l_465)) <= (safe_sub_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_u((-4), ((~((0U != 0U) < l_469.f1)) ^ (*p_49)))) || (*p_45)), 13)) < (*p_45)), p_46)))), 1)), p_46);
            /* statement id: 286 */
            assert (l_149 == 0);
            return p_46;
        }
        /* facts after branching */
        //assert (l_149 == &l_30 || l_149 == &l_499 || l_149 == &l_33);
        for (l_150 = (-13); (l_150 != 9); l_150 = safe_add_func_int16_t_s_s(l_150, 1))
        { /* block id: 291 */
            int32_t *l_479 = (void*)0;
            int32_t *l_480 = &l_457;
        }
        (*l_494) = (safe_div_func_float_f_f((safe_mul_func_float_f_f(p_48, ((**l_488) == (void*)0))), (p_48 > p_46)));
        (***l_210) = func_72(((*l_149) > (**l_148)), func_72((***l_488), (**l_488), ((void*)0 != l_488), p_46), (***l_488), p_46);
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_53(uint8_t  p_54)
{ /* block id: 43 */
    uint16_t l_58 = 0x05EF;
    int32_t l_62 = 0x0BADCAB3;
    int32_t *l_61 = &l_62;
    int32_t **l_147 = &l_61;
    l_61 = func_55(l_58, func_59(__builtin_clzl(((l_61 == (void*)0) ^ func_63((3U & 0xF32A), (+p_54), func_70(func_72((*l_61), &l_62, func_77((*l_61)), (*l_61))), l_61, l_61)))));
    /* statement id: 77 */
    assert (l_61 == 0);
    (*l_147) = &l_62;
    /* statement id: 78 */
    assert (l_61 == &l_62);
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_55(uint32_t  p_56, float  p_57)
{ /* block id: 74 */
    int32_t *l_134 = (void*)0;
    int32_t **l_133 = &l_134;
    int32_t ***l_132 = &l_133;
    int32_t ****l_135 = &l_132;
    int32_t l_137 = 0x549F135B;
    int32_t *l_136 = &l_137;
    int32_t *l_138 = &l_137;
    int32_t *l_139 = &l_137;
    int32_t *l_140 = &l_137;
    int32_t *l_141 = &l_137;
    int32_t *l_142 = &l_137;
    int32_t *l_143 = &l_137;
    int32_t *l_144 = &l_137;
    int32_t *l_145 = &l_137;
    int32_t *l_146 = (void*)0;
    (*l_135) = l_132;
    return l_146;
    /* statement id: 76 */
    //assert (func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_59(int32_t  p_60)
{ /* block id: 68 */
    float l_125 = 0xB.BCF703p-49;
    float *l_124 = &l_125;
    int32_t l_129 = (-10);
    int32_t *l_128 = &l_129;
    int32_t **l_127 = &l_128;
    int32_t ***l_126 = &l_127;
    int32_t *l_130 = (void*)0;
    int32_t **l_131 = &l_128;
    (*l_124) = 0x0.6p+1;
    (*l_126) = (void*)0;
    /* statement id: 70 */
    assert (l_127 == 0);
    (*l_124) = p_60;
    (*l_131) = l_130;
    /* statement id: 72 */
    assert (l_128 == 0);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads : l_33 l_30 l_499
 * writes:
 */
static int16_t  func_63(uint32_t  p_64, int32_t  p_65, int32_t * p_66, int32_t * p_67, int32_t * p_68)
{ /* block id: 57 */
    int16_t l_99 = (-1);
    int32_t **l_113 = (void*)0;
    int32_t l_121 = 0xE5F3B424;
    int32_t *l_120 = &l_121;
    int32_t **l_119 = &l_120;
    const int32_t *l_122 = &l_121;
    int32_t **l_123 = &l_120;
    if (l_99)
    { /* block id: 58 */
        float l_106 = 0xA.345D18p-54;
        float *l_109 = (void*)0;
        float *l_110 = &l_106;
        const int32_t l_118 = 1;
        (*l_110) = (((safe_div_func_float_f_f(func_77((safe_unary_minus_func_uint32_t_u((+(safe_add_func_int32_t_s_s(func_77(l_99), p_64)))))), l_106)) >= l_99) != (0x1.Ap-1 == (safe_add_func_float_f_f(((void*)0 == p_66), p_65))));
        (*p_66) = (safe_add_func_int32_t_s_s((&p_68 != l_113), (((-1) ^ ((safe_add_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(p_64, (l_118 > ((__builtin_clz(((0x7BC7 || 0U) >= func_77((func_77(l_118) < (*p_66))))) || p_64) == 0x6D0A3AFD)))), l_118)) | l_118)) == l_118)));
    }
    else
    { /* block id: 61 */
        p_68 = &p_65;
        /* statement id: 62 */
        assert (p_68 == &p_65);
        (*p_68) = (*p_67);
    }
    /* facts after branching */
    //assert (p_68 == &p_65 || p_68 == &l_62 || p_68 == &l_33 || p_68 == &l_30 || p_68 == &l_503 || p_68 == &l_499);
    (*l_119) = &p_65;
    /* statement id: 65 */
    assert (l_120 == &p_65);
    (*l_123) = l_122;
    /* statement id: 66 */
    assert (l_120 == &l_121);
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_70(int32_t * p_71)
{ /* block id: 54 */
    uint32_t l_96 = 0x19633EF2;
    (*p_71) = (safe_add_func_uint16_t_u_u((0x864B == (safe_lshift_func_uint16_t_u_u((0xFA52E963 && (func_77((__builtin_popcount(l_96) == l_96)) <= (safe_rshift_func_int16_t_s_s((l_96 < ((1 >= ((l_96 <= 0x33FF) < l_96)) <= (-1))), 11)))), l_96))), l_96));
    return p_71;
    /* statement id: 56 */
    //assert (func_70_rv == &l_62 || func_70_rv == &l_150 || func_70_rv == &l_503 || func_70_rv == &l_499);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_72(uint8_t  p_73, int32_t * p_74, uint32_t  p_75, int16_t  p_76)
{ /* block id: 48 */
    int32_t l_85 = 0x18CE6826;
    int32_t *l_84 = &l_85;
    int32_t **l_86 = &l_84;
    int16_t l_87 = (-1);
    float l_89 = 0x1.Cp+1;
    float *l_88 = &l_89;
    (*l_86) = l_84;
    (*l_84) = func_77((*l_84));
    l_87 = (**l_86);
    (*l_88) = func_77((*l_84));
    return p_74;
    /* statement id: 53 */
    //assert (func_72_rv == &l_62 || func_72_rv == &l_150 || func_72_rv == &l_30 || func_72_rv == 0 || func_72_rv == &l_499 || func_72_rv == &l_503 || func_72_rv == &l_904 || func_72_rv == &l_33);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_77(int32_t  p_78)
{ /* block id: 44 */
    int32_t l_80 = 1;
    int32_t *l_79 = &l_80;
    int32_t **l_81 = &l_79;
    float l_83 = 0x3.054615p+70;
    float *l_82 = &l_83;
    (*l_81) = l_79;
    (*l_82) = ((-0x6.1p-1) <= (**l_81));
    return p_78;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 226
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 8
   indirect level: 5, occurrence: 5
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 15
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 108

XXX max expression depth: 19
breakdown:
   depth: 1, occurrence: 137
   depth: 2, occurrence: 31
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 3

XXX total number of pointers: 240

XXX times a variable address is taken: 225
XXX times a pointer is dereferenced on RHS: 248
breakdown:
   depth: 1, occurrence: 198
   depth: 2, occurrence: 20
   depth: 3, occurrence: 17
   depth: 4, occurrence: 10
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 151
breakdown:
   depth: 1, occurrence: 116
   depth: 2, occurrence: 20
   depth: 3, occurrence: 5
   depth: 4, occurrence: 9
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 40
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 15
XXX times a pointer is qualified to be dereferenced: 1024

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1370
   level: 2, occurrence: 206
   level: 3, occurrence: 148
   level: 4, occurrence: 160
   level: 5, occurrence: 51
XXX number of pointers point to pointers: 106
XXX number of pointers point to scalars: 121
XXX number of pointers point to structs: 13
XXX percent of pointers has null in alias set: 25.8
XXX average alias set size: 1.36

XXX times a non-volatile is read: 1306
XXX times a non-volatile is write: 444
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 121
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 14
   depth: 2, occurrence: 16
   depth: 3, occurrence: 20
   depth: 4, occurrence: 25
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

