/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --no-float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2258741524
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const uint8_t  f0;
};

struct S1 {
   int16_t  f0;
   uint16_t  f1;
   int32_t  f2;
   volatile struct S0  f3;
   int32_t  f4;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_13 = 0x307D7C11;
static int32_t *g_12[3] = {&g_13,&g_13,&g_13};
static int32_t g_35[7] = {(-1),(-1),(-1),(-1),(-1),(-1),(-1)};
static int32_t g_58 = 0x8ED9E8BD;
static int32_t *g_77 = (void*)0;
static int32_t ** volatile g_76 = &g_77;/* VOLATILE GLOBAL g_76 */
static struct S0 g_92 = {249U};
static struct S1 * volatile g_93[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static struct S1 * volatile *g_148 = &g_93[6];
static struct S1 * volatile ** volatile g_147 = &g_148;/* VOLATILE GLOBAL g_147 */
static struct S0 *g_169 = &g_92;
static struct S0 ** volatile g_168[9] = {(void*)0,(void*)0,&g_169,(void*)0,(void*)0,&g_169,(void*)0,(void*)0,&g_169};
static struct S0 g_171 = {0x54};
static struct S0 g_175 = {5U};
static const int32_t ** volatile g_181 = (void*)0;/* VOLATILE GLOBAL g_181 */
static struct S1 g_183[8][9][3] = {{{{0x7179,0x351A,0x4ED83160,{0x87},1},{5,0U,0,{255U},-1},{0x2AAD,65529U,0xEE90912E,{253U},0x50D92D6B}},{{0x3B26,65526U,0x7E6E7EB6,{0x03},0xB460E39E},{0x1945,0x40B0,1,{249U},0x2AFA6F61},{0xFB6B,0x1A3F,6,{253U},0x7CE15402}},{{0xD058,65530U,0x1124197F,{0x55},0xB3DCC72A},{0x2FEA,65527U,0,{0U},-1},{0xEAA7,0xBC96,0x2B8A50C0,{0xB5},0x9F704EBC}},{{0xD058,65530U,0x1124197F,{0x55},0xB3DCC72A},{1,0xEF5A,0xA185DD03,{1U},1},{0x7179,0x351A,0x4ED83160,{0x87},1}},{{0x3B26,65526U,0x7E6E7EB6,{0x03},0xB460E39E},{1,0xA394,0x1759D767,{255U},0xE271CBBB},{0xCD24,0xA2A6,-5,{0U},0}},{{0x7179,0x351A,0x4ED83160,{0x87},1},{0x3B26,65526U,0x7E6E7EB6,{0x03},0xB460E39E},{0xA406,0U,0xA0B9BCC1,{255U},9}},{{0x1B4A,0x3188,-8,{0xE9},-1},{0xA803,0x3609,4,{255U},0x8DE72FA7},{0,0U,0xC98A1C93,{0xE8},-2}},{{0xC75D,0xA5ED,0xFCC24070,{0x36},0x99CFFFDC},{0x02DD,0xE1D8,0x1891164B,{0U},0},{0x1945,0x40B0,1,{249U},0x2AFA6F61}},{{0x2FEA,65527U,0,{0U},-1},{0x0440,0xCE34,0x315DE78D,{0x23},-1},{-1,65535U,-1,{0x36},-7}}},{{{0x7179,0x351A,0x4ED83160,{0x87},1},{0xEAA7,0xBC96,0x2B8A50C0,{0xB5},0x9F704EBC},{0,0U,0xCDE3425D,{0x39},0x8CDBBAE0}},{{0,0U,0xCDE3425D,{0x39},0x8CDBBAE0},{0x5E94,65532U,0x292E38BF,{6U},0x0A5ABD8B},{0x06AD,0x58E1,0x7FD1B8A4,{255U},0x33BDD32E}},{{0x0ADC,1U,0xBDBDEA83,{0x7F},1},{0x0ADC,1U,0xBDBDEA83,{0x7F},1},{0xBFFA,0U,0xA1B735CC,{0x81},9}},{{0xFB6B,0x1A3F,6,{253U},0x7CE15402},{0x7179,0x351A,0x4ED83160,{0x87},1},{6,9U,0,{2U},0xD2294016}},{{0,0xF067,0xDA4C94F8,{1U},6},{0xF525,0xA837,0x3A6807BA,{7U},0},{1,3U,-1,{255U},9}},{{5,0U,0,{255U},-1},{0xBAE5,1U,0,{0U},-9},{0x5E94,65532U,0x292E38BF,{6U},0x0A5ABD8B}},{{-6,0xD386,1,{0x2A},-5},{0,0xF067,0xDA4C94F8,{1U},6},{1,3U,-1,{255U},9}},{{0xD058,65530U,0x1124197F,{0x55},0xB3DCC72A},{0,0x3BF7,0x7D9CE7F4,{255U},0x84F2A5F7},{6,9U,0,{2U},0xD2294016}},{{0x736F,0xA9FA,0xDE9202AD,{246U},0x4A36DFC6},{0x9C31,65535U,0xC6BE33A2,{0xEF},0x9AAB8839},{0xBFFA,0U,0xA1B735CC,{0x81},9}}},{{{0xCD24,0xA2A6,-5,{0U},0},{1,0x4585,0,{0xB5},0xC865190E},{0x06AD,0x58E1,0x7FD1B8A4,{255U},0x33BDD32E}},{{-1,1U,0,{3U},-6},{1,65535U,0,{0x6D},1},{0,0U,0xCDE3425D,{0x39},0x8CDBBAE0}},{{0xF525,0xA837,0x3A6807BA,{7U},0},{0xC75D,0xA5ED,0xFCC24070,{0x36},0x99CFFFDC},{-1,65535U,-1,{0x36},-7}},{{1,0x4585,0,{0xB5},0xC865190E},{0x03EE,0x8BD6,1,{0xB4},0x91CA70F6},{0x1945,0x40B0,1,{249U},0x2AFA6F61}},{{0,0x3BF7,0x7D9CE7F4,{255U},0x84F2A5F7},{0x8D04,0x5E4B,0,{252U},0xF47D9D0D},{0,0U,0xC98A1C93,{0xE8},-2}},{{1,0xEF5A,0xA185DD03,{1U},1},{1,65535U,1,{255U},1},{5,65528U,0xB1C7B1A2,{0U},0}},{{0x33CC,0x0774,0x2FFC6FEF,{0U},0x81C0EB34},{0xFF38,0xDED3,0x824FAA81,{0x5E},0xEFB666E4},{0,2U,0,{0xBC},1}},{{0x9C31,65535U,0xC6BE33A2,{0xEF},0x9AAB8839},{-1,1U,0,{3U},-6},{0xC1CB,0x3B74,0,{0x1E},-5}},{{0xB383,65535U,-1,{0xB7},0x0C7B68BE},{0xAA0C,6U,0x079F33D5,{0x54},-1},{1,3U,0,{0xDB},0x4883662F}}},{{{-7,65535U,0x66C24980,{255U},0xBCBDF4B4},{0xAA0C,6U,0x079F33D5,{0x54},-1},{-1,65532U,-2,{255U},0x0C68C705}},{{0x02DD,0xE1D8,0x1891164B,{0U},0},{-1,1U,0,{3U},-6},{0x03EE,0x8BD6,1,{0xB4},0x91CA70F6}},{{0x5C89,0xF83F,-1,{5U},0},{0xFF38,0xDED3,0x824FAA81,{0x5E},0xEFB666E4},{0,0xF067,0xDA4C94F8,{1U},6}},{{0xD851,0U,5,{8U},0xCB9365FC},{1,65535U,1,{255U},1},{0x9C31,65535U,0xC6BE33A2,{0xEF},0x9AAB8839}},{{1,0xA394,0x1759D767,{255U},0xE271CBBB},{0x8D04,0x5E4B,0,{252U},0xF47D9D0D},{0x0440,0xCE34,0x315DE78D,{0x23},-1}},{{-1,65535U,-1,{0x36},-7},{0x03EE,0x8BD6,1,{0xB4},0x91CA70F6},{1,65535U,1,{255U},1}},{{-1,65532U,-2,{255U},0x0C68C705},{0xC75D,0xA5ED,0xFCC24070,{0x36},0x99CFFFDC},{0x1483,65534U,1,{0x26},0x06BE9B9E}},{{0x1B56,65527U,-1,{0x25},0xE1635C7A},{1,65535U,0,{0x6D},1},{0x02DD,0xE1D8,0x1891164B,{0U},0}},{{1,65535U,0,{0x6D},1},{1,0x4585,0,{0xB5},0xC865190E},{1,65535U,0,{0x6D},1}}},{{{0x1483,65534U,1,{0x26},0x06BE9B9E},{0x9C31,65535U,0xC6BE33A2,{0xEF},0x9AAB8839},{0x738E,0xF7AC,1,{0U},0x23A6D7AE}},{{0,0U,0xC98A1C93,{0xE8},-2},{0,0x3BF7,0x7D9CE7F4,{255U},0x84F2A5F7},{0x95E8,0U,8,{0U},0x02788A45}},{{0x1EF9,0x17D9,0x232D534F,{0x89},1},{0,0xF067,0xDA4C94F8,{1U},6},{1,0xDB11,-7,{9U},0xEC019993}},{{0x10CB,0x38BE,0xE6BB7537,{1U},0x3FEE94D8},{0xBAE5,1U,0,{0U},-9},{0x0ADC,1U,0xBDBDEA83,{0x7F},1}},{{0x1EF9,0x17D9,0x232D534F,{0x89},1},{0xF525,0xA837,0x3A6807BA,{7U},0},{1,0x4585,0,{0xB5},0xC865190E}},{{0,0U,0xC98A1C93,{0xE8},-2},{0x7179,0x351A,0x4ED83160,{0x87},1},{0x2FEA,65527U,0,{0U},-1}},{{0x1483,65534U,1,{0x26},0x06BE9B9E},{0x0ADC,1U,0xBDBDEA83,{0x7F},1},{0x1B4A,0x3188,-8,{0xE9},-1}},{{1,65535U,0,{0x6D},1},{0x5E94,65532U,0x292E38BF,{6U},0x0A5ABD8B},{0,0xB184,6,{0U},0xC19E56F2}},{{0x1B56,65527U,-1,{0x25},0xE1635C7A},{0xEAA7,0xBC96,0x2B8A50C0,{0xB5},0x9F704EBC},{1,0xEF5A,0xA185DD03,{1U},1}}},{{{-1,65532U,-2,{255U},0x0C68C705},{0x0440,0xCE34,0x315DE78D,{0x23},-1},{0x1B56,65527U,-1,{0x25},0xE1635C7A}},{{-1,65535U,-1,{0x36},-7},{0x02DD,0xE1D8,0x1891164B,{0U},0},{0xA803,0x3609,4,{255U},0x8DE72FA7}},{{1,0xA394,0x1759D767,{255U},0xE271CBBB},{0xA803,0x3609,4,{255U},0x8DE72FA7},{0,0xD3DD,0x4F9C2C93,{246U},-7}},{{0xD851,0U,5,{8U},0xCB9365FC},{0xA406,0U,0xA0B9BCC1,{255U},9},{0x1EF9,0x17D9,0x232D534F,{0x89},1}},{{0x5C89,0xF83F,-1,{5U},0},{0x10E7,65531U,-1,{0U},0x7CE89026},{0,0x3BF7,0x7D9CE7F4,{255U},0x84F2A5F7}},{{0x02DD,0xE1D8,0x1891164B,{0U},0},{0x1EF9,0x17D9,0x232D534F,{0x89},1},{0,0x5973,0x2F4EEEBA,{0xED},1}},{{-7,65535U,0x66C24980,{255U},0xBCBDF4B4},{-1,65535U,-1,{0x36},-7},{0,0x5973,0x2F4EEEBA,{0xED},1}},{{0xB383,65535U,-1,{0xB7},0x0C7B68BE},{0x2AAD,65529U,0xEE90912E,{253U},0x50D92D6B},{0,0x3BF7,0x7D9CE7F4,{255U},0x84F2A5F7}},{{0x9C31,65535U,0xC6BE33A2,{0xEF},0x9AAB8839},{1,0xDB11,-7,{9U},0xEC019993},{0x1EF9,0x17D9,0x232D534F,{0x89},1}}},{{{0x33CC,0x0774,0x2FFC6FEF,{0U},0x81C0EB34},{0x738E,0xF7AC,1,{0U},0x23A6D7AE},{0,0xD3DD,0x4F9C2C93,{246U},-7}},{{1,0xEF5A,0xA185DD03,{1U},1},{0x9AA5,2U,-1,{0x93},-1},{0xA803,0x3609,4,{255U},0x8DE72FA7}},{{0,0x3BF7,0x7D9CE7F4,{255U},0x84F2A5F7},{0x5C89,0xF83F,-1,{5U},0},{0x1B56,65527U,-1,{0x25},0xE1635C7A}},{{1,0x4585,0,{0xB5},0xC865190E},{1,3U,-1,{255U},9},{1,0xEF5A,0xA185DD03,{1U},1}},{{0xF525,0xA837,0x3A6807BA,{7U},0},{0xCD24,0xA2A6,-5,{0U},0},{0,0xB184,6,{0U},0xC19E56F2}},{{-1,1U,0,{3U},-6},{0x1B4A,0x3188,-8,{0xE9},-1},{0x1B4A,0x3188,-8,{0xE9},-1}},{{0xCD24,0xA2A6,-5,{0U},0},{0xA2A6,65533U,0xD5BE6635,{1U},0xC7811917},{0x2FEA,65527U,0,{0U},-1}},{{0x736F,0xA9FA,0xDE9202AD,{246U},0x4A36DFC6},{0x6AA3,0x504E,-1,{0xE8},0xB06A7539},{1,0x4585,0,{0xB5},0xC865190E}},{{0xD058,65530U,0x1124197F,{0x55},0xB3DCC72A},{1,0x92AF,0xFF993564,{0x3D},1},{0x0ADC,1U,0xBDBDEA83,{0x7F},1}}},{{{-6,0xD386,1,{0x2A},-5},{0,0xB184,6,{0U},0xC19E56F2},{1,0xDB11,-7,{9U},0xEC019993}},{{5,0U,0,{255U},-1},{1,0x92AF,0xFF993564,{0x3D},1},{0x95E8,0U,8,{0U},0x02788A45}},{{0,0xF067,0xDA4C94F8,{1U},6},{0x6AA3,0x504E,-1,{0xE8},0xB06A7539},{0x738E,0xF7AC,1,{0U},0x23A6D7AE}},{{0xFB6B,0x1A3F,6,{253U},0x7CE15402},{0xA2A6,65533U,0xD5BE6635,{1U},0xC7811917},{1,65535U,0,{0x6D},1}},{{0x0ADC,1U,0xBDBDEA83,{0x7F},1},{0x1B4A,0x3188,-8,{0xE9},-1},{0x02DD,0xE1D8,0x1891164B,{0U},0}},{{0,0U,0xCDE3425D,{0x39},0x8CDBBAE0},{0xCD24,0xA2A6,-5,{0U},0},{0x1483,65534U,1,{0x26},0x06BE9B9E}},{{0x7179,0x351A,0x4ED83160,{0x87},1},{1,3U,-1,{255U},9},{0x1483,65534U,1,{0x26},0x06BE9B9E}},{{-1,65535U,-1,{0x36},-7},{1,0xA394,0x1759D767,{255U},0xE271CBBB},{0xEAA7,0xBC96,0x2B8A50C0,{0xB5},0x9F704EBC}},{{0xFF38,0xDED3,0x824FAA81,{0x5E},0xEFB666E4},{0x33CC,0x0774,0x2FFC6FEF,{0U},0x81C0EB34},{1,3U,-1,{255U},9}}}};
static int32_t * volatile g_228 = &g_35[4];/* VOLATILE GLOBAL g_228 */
static int32_t * volatile g_229[8] = {&g_35[4],&g_35[4],&g_35[4],&g_35[4],&g_35[4],&g_35[4],&g_35[4],&g_35[4]};
static int32_t * volatile g_310 = &g_35[4];/* VOLATILE GLOBAL g_310 */
static struct S1 **g_315 = (void*)0;
static struct S1 ***g_314 = &g_315;
static struct S1 ****g_313 = &g_314;
static int32_t * volatile g_329 = &g_35[5];/* VOLATILE GLOBAL g_329 */
static volatile int32_t * volatile g_349 = (void*)0;/* VOLATILE GLOBAL g_349 */
static volatile int32_t * volatile * volatile g_350 = &g_349;/* VOLATILE GLOBAL g_350 */
static int32_t **g_376 = &g_12[1];
static int32_t ***g_375 = &g_376;
static int32_t **** volatile g_374 = &g_375;/* VOLATILE GLOBAL g_374 */
static int32_t * volatile g_422 = (void*)0;/* VOLATILE GLOBAL g_422 */
static int32_t * volatile g_423 = &g_35[4];/* VOLATILE GLOBAL g_423 */
static int32_t * volatile g_471 = &g_35[6];/* VOLATILE GLOBAL g_471 */
static int32_t * volatile * volatile g_489 = &g_329;/* VOLATILE GLOBAL g_489 */
static int32_t * volatile g_642 = &g_35[4];/* VOLATILE GLOBAL g_642 */
static const int32_t *g_647 = &g_35[4];
static const int32_t ** volatile g_646 = &g_647;/* VOLATILE GLOBAL g_646 */
static volatile int16_t g_687 = 0x9D43;/* VOLATILE GLOBAL g_687 */
static struct S0 g_723 = {0x43};
static volatile struct S0 * volatile g_734 = (void*)0;/* VOLATILE GLOBAL g_734 */
static volatile struct S0 * volatile *g_733 = &g_734;
static volatile struct S0 * volatile * volatile *g_732[7][1] = {{&g_733},{&g_733},{&g_733},{&g_733},{&g_733},{&g_733},{&g_733}};
static int32_t ** volatile g_775 = &g_77;/* VOLATILE GLOBAL g_775 */
static int32_t * volatile g_777 = (void*)0;/* VOLATILE GLOBAL g_777 */
static int32_t * volatile g_863 = &g_35[4];/* VOLATILE GLOBAL g_863 */
static volatile int8_t g_930 = 1;/* VOLATILE GLOBAL g_930 */
static int32_t * volatile g_1076 = &g_13;/* VOLATILE GLOBAL g_1076 */
static int32_t * volatile g_1078 = &g_35[4];/* VOLATILE GLOBAL g_1078 */
static struct S0 ** volatile g_1108 = (void*)0;/* VOLATILE GLOBAL g_1108 */
static const struct S0 *g_1189 = &g_175;
static const struct S0 ** volatile g_1188 = &g_1189;/* VOLATILE GLOBAL g_1188 */
static int32_t * volatile g_1246 = &g_35[4];/* VOLATILE GLOBAL g_1246 */
static uint32_t g_1257 = 0U;
static int32_t * volatile g_1263 = &g_13;/* VOLATILE GLOBAL g_1263 */
static struct S1 *** volatile * volatile g_1341 = &g_314;/* VOLATILE GLOBAL g_1341 */
static struct S1 *** volatile * volatile * volatile g_1340 = &g_1341;/* VOLATILE GLOBAL g_1340 */
static int32_t * volatile g_1342 = &g_58;/* VOLATILE GLOBAL g_1342 */
static volatile int16_t g_1371 = 0x150E;/* VOLATILE GLOBAL g_1371 */
static const struct S1 g_1377 = {0x2E9D,65535U,0x2C64200A,{0x49},0x5A4C5D93};/* VOLATILE GLOBAL g_1377 */
static int32_t * volatile g_1399 = &g_58;/* VOLATILE GLOBAL g_1399 */
static volatile int32_t g_1410 = 0xBC1626C9;/* VOLATILE GLOBAL g_1410 */
static volatile int32_t *g_1409 = &g_1410;
static volatile int32_t **g_1408[7] = {&g_1409,&g_1409,&g_1409,&g_1409,&g_1409,&g_1409,&g_1409};
static volatile int32_t ***g_1407 = &g_1408[1];
static volatile int32_t **** volatile g_1406 = &g_1407;/* VOLATILE GLOBAL g_1406 */
static int16_t g_1469 = 0xB099;
static struct S1 g_1472 = {0,0xF644,0,{0x7A},-5};/* VOLATILE GLOBAL g_1472 */
static int8_t g_1505 = (-10);
static uint32_t g_1542 = 1U;
static volatile int32_t * volatile * volatile g_1561 = (void*)0;/* VOLATILE GLOBAL g_1561 */
static uint32_t g_1563[9][4] = {{4294967295U,4294967295U,4294967295U,0x7490B4CE},{0x7490B4CE,4294967295U,4294967295U,0xDF33216F},{4294967295U,0U,4294967295U,4U},{4294967295U,4294967295U,1U,4294967295U},{0xDDC64DD0,4294967295U,4U,4294967295U},{0xDF33216F,4294967290U,4U,4294967293U},{0xDDC64DD0,1U,1U,0xDDC64DD0},{4294967295U,0xDF33216F,4294967295U,0x368AA3A6},{4294967295U,0x368AA3A6,4294967295U,4294967290U}};
static const volatile struct S0 g_1706[8][5][5] = {{{{255U},{0x25},{251U},{255U},{0x25}},{{0x70},{0x34},{255U},{0x34},{0x70}},{{0x25},{255U},{251U},{0x25},{255U}},{{0xA3},{0x66},{0x01},{0x34},{0x01}},{{255U},{255U},{0xF6},{255U},{255U}}},{{{0x53},{0x34},{0x53},{0x66},{0x70}},{{255U},{251U},{251U},{255U},{0x25}},{{0xA3},{0x34},{0x3C},{0x34},{0xA3}},{{0x25},{255U},{251U},{251U},{255U}},{{0x70},{0x66},{0x53},{0x34},{0x53}}},{{{255U},{255U},{0xF6},{255U},{255U}},{{0x01},{0x34},{0x01},{0x66},{0xA3}},{{255U},{0x25},{251U},{255U},{0x25}},{{0x70},{0x34},{255U},{0x34},{0x70}},{{0x25},{255U},{251U},{0x25},{255U}}},{{{0xA3},{0x66},{0x01},{0x34},{0x01}},{{255U},{255U},{0xF6},{255U},{255U}},{{0x53},{0x34},{0x53},{0x66},{0x70}},{{255U},{251U},{251U},{255U},{0x25}},{{0xA3},{0x34},{0x3C},{0x34},{0xA3}}},{{{0x25},{255U},{251U},{251U},{255U}},{{0x70},{0x66},{0x53},{0x34},{0x53}},{{255U},{255U},{0xF6},{255U},{255U}},{{0x01},{0x34},{0x01},{0x66},{0xA3}},{{255U},{0x25},{251U},{255U},{0x25}}},{{{0x53},{0x66},{0x70},{0x66},{0x53}},{{0x81},{251U},{0xF6},{0x81},{0x25}},{{0x01},{0xB4},{0x3C},{0x66},{0x3C}},{{0x25},{0x25},{255U},{251U},{0x25}},{{255U},{0x66},{255U},{0xB4},{0x53}}},{{{0x25},{0xF6},{0xF6},{0x25},{0x81}},{{0x01},{0x66},{0xA3},{0x66},{0x01}},{{0x81},{0x25},{0xF6},{0xF6},{0x25}},{{0x53},{0xB4},{255U},{0x66},{255U}},{{0x25},{251U},{255U},{0x25},{0x25}}},{{{0x3C},{0x66},{0x3C},{0xB4},{0x01}},{{0x25},{0x81},{0xF6},{251U},{0x81}},{{0x53},{0x66},{0x70},{0x66},{0x53}},{{0x81},{251U},{0xF6},{0x81},{0x25}},{{0x01},{0xB4},{0x3C},{0x66},{0x3C}}}};
static const volatile struct S0 *g_1705 = &g_1706[2][3][2];
static const volatile struct S0 **g_1704 = &g_1705;
static const volatile struct S0 ** volatile *g_1703[4] = {&g_1704,&g_1704,&g_1704,&g_1704};
static const volatile struct S0 ** volatile **g_1702 = &g_1703[1];
static const volatile struct S0 ** volatile ***g_1701[4][1][3] = {{{&g_1702,&g_1702,&g_1702}},{{&g_1702,(void*)0,(void*)0}},{{&g_1702,&g_1702,&g_1702}},{{&g_1702,(void*)0,(void*)0}}};
static const volatile struct S0 g_1735 = {0x72};/* VOLATILE GLOBAL g_1735 */
static struct S1 g_1750 = {-1,65533U,-1,{0xBE},-3};/* VOLATILE GLOBAL g_1750 */
static volatile int32_t * volatile * volatile g_1751 = (void*)0;/* VOLATILE GLOBAL g_1751 */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
inline static int32_t * func_2(int32_t * p_3, const uint32_t  p_4, const int16_t  p_5, int32_t  p_6);
inline static int32_t * func_7(int32_t * p_8, int16_t  p_9, uint16_t  p_10, int32_t * p_11);
static int32_t  func_17(int32_t  p_18);
inline static int32_t  func_25(uint8_t  p_26, int16_t  p_27);
inline static uint8_t  func_41(uint8_t  p_42, int32_t * p_43, int32_t * p_44, uint32_t  p_45, int16_t  p_46);
inline static uint8_t  func_47(const int32_t * p_48, uint32_t  p_49);
static int32_t * func_51(int32_t * p_52, int32_t * p_53, uint32_t  p_54, struct S0  p_55);
static int32_t * func_56(const int32_t  p_57);
inline static int32_t * func_62(int32_t  p_63, int32_t * p_64);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_13 g_310 g_35 g_58 g_374 g_375 g_329 g_183.f1 g_376 g_183.f0 g_313 g_314 g_169 g_76 g_77 g_775 g_175.f0 g_93 g_92.f0 g_687 g_183.f4 g_723.f0 g_183.f2 g_171.f0 g_183.f3.f0 g_863 g_147 g_148 g_930 g_642 g_646 g_489 g_1076 g_423 g_1078 g_733 g_734 g_1188 g_647 g_1246 g_1257 g_1263 g_1469 g_1377.f0 g_1377.f4 g_1472.f2 g_1377.f1 g_1542 g_1409 g_1472.f1 g_1701 g_1505 g_1472.f0 g_1704 g_1705 g_1702 g_1703 g_1750.f0 g_1563
 * writes: g_35 g_13 g_58 g_77 g_12 g_93 g_315 g_647 g_329 g_687 g_169 g_376 g_1189 g_1410 g_1472.f1 g_1257 g_1472.f0 g_1469 g_734
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_16 = 4294967295U;
    int32_t *l_1590 = &g_58;
    const int32_t l_1593[2][6] = {{0x25B10B3D,0x77260CD9,0x77260CD9,0x25B10B3D,0x77260CD9,0x77260CD9},{0x25B10B3D,0x77260CD9,0x77260CD9,0x25B10B3D,0x77260CD9,0x77260CD9}};
    uint16_t l_1605 = 0xF06D;
    int32_t ****l_1611[9][6][1] = {{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}},{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}},{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}},{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}},{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}},{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}},{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}},{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}},{{&g_375},{&g_375},{&g_375},{&g_375},{&g_375},{&g_375}}};
    uint8_t l_1612 = 0x3E;
    uint8_t l_1619 = 252U;
    uint32_t l_1620 = 4294967295U;
    const uint32_t l_1621[8] = {0x79CB3B1B,0x79CB3B1B,0x79CB3B1B,0x79CB3B1B,0x79CB3B1B,0x79CB3B1B,0x79CB3B1B,0x79CB3B1B};
    struct S0 *l_1626 = &g_171;
    uint16_t l_1636 = 0xA9E0;
    uint32_t l_1764 = 0x31CC2F25;
    int32_t *l_1765 = &g_35[4];
    int i, j, k;
    l_1590 = func_2(func_7(g_12[1], ((uint16_t)(g_13 & (l_16 < func_17(((uint32_t)(l_16 <= (((int8_t)l_16 / (int8_t)((uint16_t)(((0 > 0) && func_25(l_16, l_16)) < l_16) >> (uint16_t)l_16)) == l_16)) % (uint32_t)g_58)))) % (uint16_t)0xFDF1), g_183[2][4][1].f1, (**g_375)), g_92.f0, l_16, l_16);
    /* statement id: 729 */
    //assert (g_12[0] == 0 || (g_12[0] >= &g_35[0] && g_12[0] <= &g_35[6]) || g_12[0] == &g_13);
    assert (g_77 == 0 || (g_77 >= &g_35[0] && g_77 <= &g_35[6]));
    assert (g_169 == &g_171 || g_169 == &g_92);
    //assert (g_315 == 0 || g_315 == dangling);
    //assert (g_376 == dangling || (g_376 >= &g_12[0] && g_376 <= &g_12[2]));
    assert (l_1590 == 0 || (l_1590 >= &g_35[0] && l_1590 <= &g_35[6]) || l_1590 == &g_13);
    (*g_775) = func_56((((int8_t)(l_1593[0][1] ^ (((int8_t)((uint16_t)((uint32_t)(!0xED42F470) - (uint32_t)((((int16_t)((int16_t)(((l_1605 < (((int8_t)(~((((uint16_t)(&g_1407 != l_1611[5][4][0]) + (uint16_t)g_1469) > l_1612) | (((*g_642) > ((int8_t)(((int8_t)(((uint8_t)g_1377.f0 - (uint8_t)g_1377.f4) >= (-7)) + (int8_t)1) > l_1619) - (int8_t)g_1472.f2)) == 0U))) >> (int8_t)g_1377.f1) <= 0x497A)) | g_183[2][4][1].f2) <= g_58) / (int16_t)g_1472.f2) + (int16_t)0U) | 0) ^ g_1377.f1)) - (uint16_t)g_171.f0) << (int8_t)l_1620) | l_1621[0])) << (int8_t)6) & 0x8CFA));
    /* statement id: 730 */
    assert (g_77 == 0 || (g_77 >= &g_35[0] && g_77 <= &g_35[6]) || g_77 == &g_13);
    if (((((-5) != ((int16_t)g_58 - (int16_t)((int8_t)((void*)0 == l_1626) << (int8_t)g_13))) | (((uint16_t)(((l_1626 != l_1626) < ((int8_t)g_1542 / (int8_t)((uint32_t)(~(((uint32_t)((0x82325499 > (**g_489)) || g_1377.f1) / (uint32_t)0x7FC97405) < g_1377.f4)) % (uint32_t)0x0C6EAA13))) <= l_1636) - (uint16_t)0xE378) | g_1469)) & (-3)))
    { /* block id: 731 */
        struct S1 *l_1637 = &g_1472;
        int32_t l_1639 = 0xC5238BB5;
        int32_t *l_1658[3];
        int32_t l_1683 = 6;
        int i;
        for (i = 0; i < 3; i++)
            l_1658[i] = &g_13;
        if ((l_1637 == l_1637))
        { /* block id: 732 */
            uint32_t l_1638 = 0x3A8AB85D;
            (*g_1409) = ((l_1638 >= 250U) ^ (l_1639 != (((-1) < g_92.f0) == g_175.f0)));
        }
        else
        { /* block id: 734 */
            int16_t l_1652 = 0;
            uint8_t l_1657 = 0x6C;
            int32_t *l_1676 = &g_13;
            for (l_1612 = 7; (l_1612 <= 28); l_1612 += 2)
            { /* block id: 737 */
                uint32_t l_1645 = 0x5F52FCF8;
                for (g_1472.f1 = 0; (g_1472.f1 <= 8); g_1472.f1 += 1)
                { /* block id: 740 */
                    (*g_1409) = ((~(((int16_t)g_171.f0 * (int16_t)((l_1645 == ((((int8_t)((uint8_t)l_1645 - (uint8_t)l_1645) << (int8_t)5) || 0x0B86) ^ ((uint32_t)(0 && l_1652) % (uint32_t)((int16_t)g_183[2][4][1].f1 >> (int16_t)((uint8_t)254U << (uint8_t)4))))) == l_1657)) > g_1257)) & 0x11);
                    l_1658[0] = func_62(l_1645, (*g_775));
                    /* statement id: 742 */
                    //assert ((l_1658[0] >= &g_35[0] && l_1658[0] <= &g_35[6]) || l_1658[0] == &g_13);
                    for (g_1257 = 0; g_1257 < 9; g_1257 += 1)
                    {
                        for (l_1652 = 0; l_1652 < 6; l_1652 += 1)
                        {
                            for (g_13 = 0; g_13 < 1; g_13 += 1)
                            {
                                l_1611[g_1257][l_1652][g_13] = &g_375;
                            }
                        }
                    }
                    return g_1469;
                }
            }
            l_1676 = l_1676;
        }
        l_1658[0] = func_62(((((uint16_t)(0x0A == (((((g_183[2][4][1].f0 > l_1683) != ((((uint8_t)((uint16_t)(((int16_t)((uint16_t)(-(int32_t)((*g_863) > (((int8_t)g_171.f0 << (int8_t)(((uint8_t)0xC1 - (uint8_t)g_723.f0) || (-8))) & ((g_1701[1][0][1] != (void*)0) && 0)))) >> (uint16_t)7) - (int16_t)g_1472.f2) == g_1472.f2) << (uint16_t)g_1505) * (uint8_t)g_13) ^ 0) < 4U)) < g_1472.f0) || (*g_1263)) == g_183[2][4][1].f2)) >> (uint16_t)13) | g_1472.f0) == g_92.f0), &l_1639);
        /* statement id: 749 */
        //assert ((l_1658[0] >= &g_35[0] && l_1658[0] <= &g_35[6]) || l_1658[0] == &g_13);
    }
    else
    { /* block id: 750 */
        struct S1 *****l_1722 = &g_313;
        int32_t *l_1726 = &g_35[1];
        const int32_t **l_1753 = (void*)0;
        for (g_1472.f0 = (-8); (g_1472.f0 == 29); g_1472.f0++)
        { /* block id: 753 */
            int16_t l_1723 = 0x5B78;
            l_1723 = ((uint16_t)(((int8_t)(0x4C81 & (~(((int8_t)((int8_t)g_183[2][4][1].f4 << (int8_t)4) >> (int8_t)3) >= ((uint16_t)(g_687 & ((uint8_t)g_183[2][4][1].f1 >> (uint8_t)7)) + (uint16_t)(0x6AE3 >= (l_1722 == (void*)0)))))) - (int8_t)(&g_1407 != &g_1407)) > 1U) / (uint16_t)g_1472.f2);
        }
        for (l_1620 = 0; (l_1620 >= 40); l_1620++)
        { /* block id: 758 */
            const struct S1 *l_1727 = (void*)0;
            int32_t *l_1744 = (void*)0;
            (*g_775) = l_1726;
            /* statement id: 759 */
            assert ((g_77 >= &g_35[0] && g_77 <= &g_35[6]));
            for (l_1605 = 0; (l_1605 <= 31); l_1605++)
            { /* block id: 762 */
                for (g_1469 = 0; (g_1469 >= (-19)); g_1469 -= 3)
                { /* block id: 765 */
                    (*g_76) = (void*)0;
                    /* statement id: 766 */
                    assert (g_77 == 0);
                }
                (*g_733) = (*g_733);
            }
            /* facts after for loop */
            assert (g_77 == 0 || (g_77 >= &g_35[0] && g_77 <= &g_35[6]));
            for (g_58 = 0; (g_58 < (-27)); g_58--)
            { /* block id: 772 */
                const volatile struct S0 *l_1734[1];
                int i;
                for (i = 0; i < 1; i++)
                    l_1734[i] = &g_1735;
                l_1734[0] = (*g_1704);
                /* statement id: 773 */
                //assert ((l_1734[0] >= &g_1706[0][0][0] && l_1734[0] <= &g_1706[7][4][4]) || l_1734[0] == &g_1735);
            }
        }
        (*g_646) = (*g_646);
    }
    (*g_76) = func_62(((uint8_t)(((void*)0 == (*g_1702)) == g_1750.f0) >> (uint8_t)((uint8_t)0x77 + (uint8_t)((uint8_t)(((((uint16_t)(((g_1563[6][2] | (0x13 > (g_1257 <= (((uint16_t)((*g_310) && 4U) - (uint16_t)0x03DB) >= l_1764)))) < g_183[2][4][1].f0) != g_171.f0) + (uint16_t)(-1)) || 0x96) & 0x68297209) || (-1)) / (uint8_t)g_1505))), l_1765);
    /* statement id: 790 */
    assert ((g_77 >= &g_35[0] && g_77 <= &g_35[6]));
    return g_183[2][4][1].f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_147 g_148 g_93 g_13 g_171.f0 g_183.f0 g_183.f4 g_183.f1 g_92.f0 g_930 g_863 g_35 g_723.f0 g_175.f0 g_642 g_313 g_314 g_76 g_77 g_375 g_376 g_58 g_374 g_687 g_775 g_646 g_12 g_489 g_329 g_1076 g_423 g_1078 g_733 g_734 g_183.f2 g_183.f3.f0 g_1188 g_310 g_647 g_1246 g_1257 g_1263
 * writes: g_35 g_13 g_58 g_77 g_12 g_647 g_329 g_687 g_169 g_376 g_93 g_1189
 */
inline static int32_t * func_2(int32_t * p_3, const uint32_t  p_4, const int16_t  p_5, int32_t  p_6)
{ /* block id: 382 */
    uint32_t l_875 = 0xBB870DAB;
    int32_t l_975 = (-1);
    struct S1 ****l_1049[1][2];
    struct S0 **l_1171 = (void*)0;
    struct S0 ***l_1170 = &l_1171;
    struct S0 ****l_1169 = &l_1170;
    int32_t ****l_1201 = &g_375;
    int32_t *l_1264 = (void*)0;
    struct S0 l_1312 = {0x7D};
    volatile int32_t * volatile l_1314 = (void*)0;/* VOLATILE GLOBAL l_1314 */
    int16_t l_1339[3];
    int32_t l_1390 = 0x3F1FBEE2;
    uint8_t l_1392[1];
    uint8_t l_1516 = 0x0D;
    const uint8_t l_1583 = 0x6D;
    int32_t l_1584 = 0x424A308E;
    int i, j;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 2; j++)
            l_1049[i][j] = &g_314;
    }
    for (i = 0; i < 3; i++)
        l_1339[i] = 1;
    for (i = 0; i < 1; i++)
        l_1392[i] = 0x87;
    if (l_875)
    { /* block id: 383 */
        int8_t l_918 = 6;
        const struct S1 *l_922[4][5][5] = {{{&g_183[2][4][1],&g_183[7][2][2],&g_183[2][2][1],&g_183[2][4][1],&g_183[2][4][1]},{(void*)0,&g_183[7][2][2],(void*)0,(void*)0,&g_183[2][4][1]},{&g_183[2][4][1],(void*)0,(void*)0,&g_183[2][4][1],&g_183[2][4][1]},{&g_183[2][4][1],&g_183[7][2][2],&g_183[2][2][1],&g_183[2][4][1],&g_183[2][4][1]},{(void*)0,&g_183[7][2][2],(void*)0,(void*)0,&g_183[2][4][1]}},{{&g_183[2][4][1],&g_183[5][4][1],&g_183[5][4][1],&g_183[1][3][1],&g_183[2][6][1]},{&g_183[1][3][1],(void*)0,&g_183[2][4][1],&g_183[1][3][1],&g_183[4][5][1]},{&g_183[0][3][1],(void*)0,&g_183[5][4][1],&g_183[0][3][1],&g_183[4][5][1]},{&g_183[1][3][1],&g_183[5][4][1],&g_183[5][4][1],&g_183[1][3][1],&g_183[2][6][1]},{&g_183[1][3][1],(void*)0,&g_183[2][4][1],&g_183[1][3][1],&g_183[4][5][1]}},{{&g_183[0][3][1],(void*)0,&g_183[5][4][1],&g_183[0][3][1],&g_183[4][5][1]},{&g_183[1][3][1],&g_183[5][4][1],&g_183[5][4][1],&g_183[1][3][1],&g_183[2][6][1]},{&g_183[1][3][1],(void*)0,&g_183[2][4][1],&g_183[1][3][1],&g_183[4][5][1]},{&g_183[0][3][1],(void*)0,&g_183[5][4][1],&g_183[0][3][1],&g_183[4][5][1]},{&g_183[1][3][1],&g_183[5][4][1],&g_183[5][4][1],&g_183[1][3][1],&g_183[2][6][1]}},{{&g_183[1][3][1],(void*)0,&g_183[2][4][1],&g_183[1][3][1],&g_183[4][5][1]},{&g_183[0][3][1],(void*)0,&g_183[5][4][1],&g_183[0][3][1],&g_183[4][5][1]},{&g_183[1][3][1],&g_183[5][4][1],&g_183[5][4][1],&g_183[1][3][1],&g_183[2][6][1]},{&g_183[1][3][1],(void*)0,&g_183[2][4][1],&g_183[1][3][1],&g_183[4][5][1]},{&g_183[0][3][1],(void*)0,&g_183[5][4][1],&g_183[0][3][1],&g_183[4][5][1]}}};
        int32_t **l_969[4];
        struct S0 **l_980 = &g_169;
        struct S0 ***l_979 = &l_980;
        int i, j, k;
        for (i = 0; i < 4; i++)
            l_969[i] = &g_77;
        for (l_875 = 0; (l_875 <= 2); l_875++)
        { /* block id: 386 */
            int32_t l_880 = 0xBC4A41C8;
            struct S0 **l_897 = (void*)0;
            int32_t *l_898 = &g_35[3];
            int32_t l_947 = 0x5C25FA49;
            struct S0 ***l_978 = &l_897;
            (*l_898) = (((uint8_t)l_880 << (uint8_t)l_880) <= ((((int16_t)((int16_t)((int16_t)((int8_t)((uint8_t)((uint8_t)((void*)0 == &p_3) >> (uint8_t)0) % (uint8_t)((int8_t)(((void*)0 != (**g_147)) && ((int8_t)g_13 / (int8_t)p_5)) >> (int8_t)(&g_169 == l_897))) % (int8_t)0x24) << (int16_t)p_6) / (int16_t)p_4) * (int16_t)p_4) != (-7)) != 65535U));
            if ((-(int8_t)(!(((uint32_t)((int16_t)p_6 * (int16_t)0x670A) / (uint32_t)((l_875 < ((uint16_t)((int16_t)p_4 - (int16_t)1) << (uint16_t)p_5)) ^ 0x783A70A9)) && ((!((int16_t)((int16_t)((g_171.f0 ^ ((uint32_t)((uint16_t)((0x6A04 >= g_183[2][4][1].f0) != g_13) % (uint16_t)g_183[2][4][1].f4) + (uint32_t)l_875)) == 0) / (int16_t)g_183[2][4][1].f1) % (int16_t)l_918)) || g_92.f0)))))
            { /* block id: 388 */
                struct S1 *****l_919[9][8] = {{&g_313,&g_313,&g_313,&g_313,&g_313,&g_313,&g_313,&g_313},{(void*)0,&g_313,&g_313,(void*)0,(void*)0,&g_313,(void*)0,(void*)0},{&g_313,(void*)0,&g_313,&g_313,(void*)0,&g_313,&g_313,&g_313},{&g_313,&g_313,(void*)0,(void*)0,&g_313,&g_313,(void*)0,(void*)0},{&g_313,&g_313,&g_313,&g_313,(void*)0,&g_313,&g_313,&g_313},{&g_313,&g_313,&g_313,&g_313,(void*)0,&g_313,&g_313,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,&g_313,&g_313,&g_313,&g_313},{&g_313,(void*)0,&g_313,&g_313,&g_313,(void*)0,&g_313,(void*)0},{&g_313,(void*)0,&g_313,(void*)0,&g_313,&g_313,(void*)0,&g_313}};
                int32_t l_929 = (-1);
                int i, j;
                for (p_6 = 6; (p_6 >= 3); p_6 -= 1)
                { /* block id: 391 */
                    l_919[0][3] = &g_313;
                }
                (*l_898) = (l_875 & (((int32_t)(0x5B1DC4FD | (((-1) | (((p_3 == (void*)0) || ((((void*)0 != l_922[1][0][1]) != ((uint16_t)((int32_t)(((int8_t)l_875 >> (int8_t)1) & 0x56512E63) / (int32_t)l_929) + (uint16_t)g_930)) | l_918)) == 1)) < 0x1126)) - (int32_t)0xC4FA3103) ^ l_929));
                for (p_6 = (-6); (p_6 < (-11)); p_6 -= 4)
                { /* block id: 397 */
                    for (g_13 = 7; (g_13 >= 0); g_13 -= 1)
                    { /* block id: 400 */
                        if (l_929)
                            break;
                    }
                }
            }
            else
            { /* block id: 404 */
                uint16_t l_950 = 65535U;
                l_950 = (((((uint32_t)((int8_t)(((-1) != ((int16_t)(-1) % (int16_t)((g_183[2][4][1].f0 > ((uint8_t)(~((~((int8_t)p_6 % (int8_t)p_4)) >= 0xD1AD343A)) / (uint8_t)((int32_t)(((((*g_863) ^ l_947) && ((uint8_t)(l_918 || p_4) * (uint8_t)0x16)) < g_183[2][4][1].f0) <= p_4) % (int32_t)p_4))) || (*l_898)))) || l_875) - (int8_t)0xB2) / (uint32_t)p_6) ^ p_5) == g_723.f0) < l_875);
            }
            (**g_375) = func_56((((int16_t)((int16_t)(((int16_t)p_5 / (int16_t)(*l_898)) < ((g_175.f0 == ((((uint32_t)((uint32_t)(l_918 != (((int8_t)l_918 + (int8_t)(*l_898)) || (*g_642))) + (uint32_t)((((*g_313) != (void*)0) <= l_918) || l_918)) - (uint32_t)5U) && l_918) < l_918)) == p_5)) * (int16_t)0xC43E) * (int16_t)(*l_898)) || l_918));
            for (g_58 = 0; (g_58 >= (-23)); g_58 -= 2)
            { /* block id: 410 */
                int32_t l_974 = 0xD0538200;
                l_975 = (((int16_t)((l_875 >= (-1)) != ((uint16_t)g_723.f0 * (uint16_t)((g_171.f0 == (l_969[1] != (**g_374))) & 0xBCD1))) - (int16_t)((uint32_t)((int8_t)6 << (int8_t)4) / (uint32_t)l_974)) | 0x02);
                (**g_375) = p_3;
                (*l_898) = ((int32_t)(l_978 != l_979) - (int32_t)0xA257424F);
            }
        }
        l_975 = (&l_922[1][4][4] == (void*)0);
    }
    else
    { /* block id: 417 */
        int16_t l_987 = 0;
        int32_t l_1002[5][2];
        struct S1 *l_1036 = &g_183[2][4][1];
        struct S1 **l_1035 = &l_1036;
        uint32_t l_1073[1];
        int32_t l_1074 = 4;
        uint32_t l_1107 = 1U;
        const int16_t l_1125 = 7;
        int16_t l_1179[5][10] = {{4,0xE14B,4,0xC842,0x464D,0x464D,0xC842,4,0xE14B,4},{4,1,0xE14B,(-1),0xE14B,1,4,4,1,0xE14B},{1,4,4,1,0xE14B,(-1),0xE14B,1,4,4},{0xE14B,4,0xC842,0x464D,0x464D,0xC842,4,0xE14B,4,0xC842},{(-1),1,0x464D,1,(-1),0x464D,0x464D,0xC842,4,0xE14B}};
        uint8_t l_1180 = 0xE8;
        uint32_t l_1200[2][10][9] = {{{0x7195AB52,4294967293U,8U,4294967295U,0x19EBFEB5,0xFE964463,0x76EF4558,4U,0U},{4294967289U,4294967293U,0xBA99B9EA,0x4CAD1AEA,4294967294U,1U,0x1F66BD44,0x1F66BD44,1U},{0x76EF4558,0xF90771E0,0x31A64659,0xF90771E0,0x76EF4558,1U,0xBA99B9EA,0xD49189DF,0U},{1U,0x76EF4558,4294967289U,0x16EDEB65,0xBC16255E,4U,0xC108E008,0x506D042C,0x1F66BD44},{0x0BD7F486,6U,1U,0xE11D4479,1U,1U,0xBC16255E,0x4CAD1AEA,4294967291U},{0x70FDFCDF,0U,0xF1648F6A,0xDFBF9410,0x259F1F5B,1U,0x2C8C8E25,0xFE964463,0x31A64659},{0xDFBF9410,0x16EDEB65,0x76EF4558,0U,4294967289U,0xFE964463,0xAD53F177,0U,4294967291U},{0xDFBF9410,0x2D3EAFA3,0x16EDEB65,0xFE964463,0x2B2F38A6,8U,0U,8U,0x2B2F38A6},{0x70FDFCDF,0xFE964463,0xFE964463,0x70FDFCDF,0x08DC2CC7,4294967289U,6U,0x4F76AD23,0x76EF4558},{0x0BD7F486,4294967289U,0U,0x7195AB52,8U,0x16EDEB65,1U,0xAD53F177,4294967293U}},{{1U,0xF1648F6A,0x2C8C8E25,1U,0x08DC2CC7,0x4F76AD23,0xE11D4479,4294967288U,4294967286U},{0x76EF4558,0x506D042C,0x19ADED1F,0x2C8C8E25,0x2B2F38A6,4294967295U,0xD49189DF,1U,4U},{4294967289U,0x259F1F5B,4294967294U,4294967291U,4294967289U,0xBA99B9EA,8U,0x31A64659,4U},{0x7195AB52,4294967291U,0x506D042C,4294967286U,0x259F1F5B,0x70FDFCDF,0x70FDFCDF,0x259F1F5B,4294967286U},{0x2D3EAFA3,1U,0x2D3EAFA3,0xBC16255E,1U,4294967288U,4294967294U,4294967295U,4294967293U},{4294967295U,1U,0x4CAD1AEA,0x0BD7F486,0xBC16255E,0U,0xFE964463,6U,0x76EF4558},{1U,0x7195AB52,4294967295U,0xBC16255E,0x76EF4558,0x506D042C,0x19ADED1F,0x2C8C8E25,0x2B2F38A6},{0x4F76AD23,0xE11D4479,4294967288U,4294967286U,4294967294U,0U,0x259F1F5B,0x76EF4558,4294967291U},{6U,0x70FDFCDF,0xF90771E0,4294967291U,0x19EBFEB5,0xE11D4479,0x2B2F38A6,0x76EF4558,0x31A64659},{0x31A64659,4294967291U,4294967291U,0x2C8C8E25,0x506D042C,0x19EBFEB5,0x506D042C,0x2C8C8E25,4294967291U}}};
        int i, j, k;
        for (i = 0; i < 5; i++)
        {
            for (j = 0; j < 2; j++)
                l_1002[i][j] = 1;
        }
        for (i = 0; i < 1; i++)
            l_1073[i] = 0xFA616788;
        for (g_58 = 0; (g_58 >= (-4)); g_58--)
        { /* block id: 420 */
            uint8_t l_992 = 255U;
            int8_t l_1006 = 0x3A;
            int32_t l_1007 = 0x85F33B62;
            int32_t ***l_1014 = &g_376;
            uint16_t l_1020 = 65535U;
            struct S1 *l_1034 = (void*)0;
            struct S1 **l_1033 = &l_1034;
            int8_t l_1062[2];
            int i;
            for (i = 0; i < 2; i++)
                l_1062[i] = 6;
            l_1002[0][0] = ((uint8_t)0x8D * (uint8_t)((int8_t)((p_4 < (l_987 && p_4)) ^ (((uint8_t)((~(!l_992)) && ((uint8_t)(0U >= ((0xEA <= (-(int8_t)(((int8_t)0x99 * (int8_t)((uint32_t)((uint16_t)l_975 * (uint16_t)p_5) / (uint32_t)l_975)) != 0x94))) ^ 0U)) >> (uint8_t)6)) * (uint8_t)g_35[0]) >= l_992)) % (int8_t)g_183[2][4][1].f1));
            if ((g_58 || (!(p_6 ^ l_992))))
            { /* block id: 422 */
                struct S1 *l_1026 = &g_183[2][8][0];
                int32_t l_1059 = 1;
                for (l_975 = 0; (l_975 <= 0); l_975 += 1)
                { /* block id: 425 */
                    if ((((uint16_t)p_4 << (uint16_t)l_1002[0][0]) && l_1006))
                    { /* block id: 426 */
                        l_1007 = (&p_3 == (void*)0);
                    }
                    else
                    { /* block id: 428 */
                        int16_t l_1019 = (-1);
                        l_1019 = ((uint8_t)((uint16_t)l_1007 * (uint16_t)(((int8_t)((void*)0 == l_1014) + (int8_t)g_183[2][4][1].f1) != (((void*)0 == &g_375) > 0x3434))) - (uint8_t)((uint8_t)((uint8_t)p_6 * (uint8_t)(g_183[2][4][1].f1 >= g_687)) << (uint8_t)p_4));
                        (**l_1014) = p_3;
                    }
                    for (p_6 = 0; (p_6 <= 8); p_6 += 1)
                    { /* block id: 434 */
                        (**l_1014) = (void*)0;
                        (**g_375) = (void*)0;
                        if (l_1020)
                            continue;
                        (*g_646) = func_62((((g_35[4] & ((int16_t)l_987 << (int16_t)p_6)) <= (!p_5)) & ((int16_t)0x8A4C >> (int16_t)((0x6126 | (l_1026 != (void*)0)) < 0x30010A79))), (*g_775));
                    }
                    return (**l_1014);
                    /* statement id: 440 */
                    //assert (func_2_rv == 0 || (func_2_rv >= &g_35[0] && func_2_rv <= &g_35[6]) || func_2_rv == &g_13);
                }
                for (l_975 = 0; (l_975 > 0); l_975++)
                { /* block id: 444 */
                    uint16_t l_1056[3][7] = {{0xF36C,0xF36C,0xF36C,0xF36C,0xF36C,0xF36C,0xF36C},{0x8D56,0x8D56,0x8D56,0x8D56,0x8D56,0x8D56,0x8D56},{0xF36C,0xF36C,0xF36C,0xF36C,0xF36C,0xF36C,0xF36C}};
                    int i, j;
                    l_1007 = ((void*)0 != (*g_147));
                    l_1059 = ((uint8_t)(((uint16_t)(l_1033 != l_1035) % (uint16_t)((((uint8_t)((int32_t)((((((uint8_t)((int8_t)((int16_t)(-1) - (int16_t)p_6) << (int8_t)((((uint16_t)(((void*)0 != l_1049[0][1]) | ((int16_t)g_183[2][4][1].f0 - (int16_t)(((int16_t)(((uint16_t)l_1056[0][3] * (uint16_t)((int16_t)(-1) << (int16_t)11)) <= 4294967292U) << (int16_t)g_35[3]) | l_1056[0][3]))) * (uint16_t)g_687) ^ g_183[2][4][1].f0) & g_13)) / (uint8_t)7U) >= p_5) != g_92.f0) > 0x154CADC2) != g_183[2][4][1].f0) + (int32_t)l_1006) * (uint8_t)g_171.f0) | l_1059) || 0xC782AA8A)) | 0x7A098EE3) % (uint8_t)(-7));
                }
                l_1074 = (((l_1062[0] < (((uint8_t)((int16_t)((uint16_t)((&l_1026 == (void*)0) & (((uint32_t)p_4 + (uint32_t)(((int8_t)g_183[2][4][1].f1 << (int8_t)p_5) | l_1059)) > (g_171.f0 & g_687))) * (uint16_t)0xB671) + (int16_t)g_183[2][4][1].f1) + (uint8_t)p_6) > l_1073[0])) || l_975) >= g_35[4]);
            }
            else
            { /* block id: 449 */
                int32_t * volatile *l_1075[1];
                int i;
                for (i = 0; i < 1; i++)
                    l_1075[i] = &g_471;
                (*g_489) = (*g_489);
                for (g_687 = 0; g_687 < 7; g_687 += 1)
                {
                    g_35[g_687] = 0;
                }
            }
            (*g_1076) = ((&p_3 == (void*)0) >= l_987);
        }
        if ((l_875 & (*g_423)))
        { /* block id: 455 */
            uint32_t l_1077 = 0x7F932FF3;
            struct S0 ****l_1081 = (void*)0;
            struct S1 ***l_1115 = &g_315;
            (*g_1078) = (l_1077 <= (&p_3 != (*g_375)));
            for (g_13 = 11; (g_13 == (-24)); g_13--)
            { /* block id: 459 */
                int32_t *l_1082 = (void*)0;
                int32_t *l_1083 = &g_35[3];
                struct S0 *l_1086 = &g_171;
                (**g_375) = func_56(p_6);
                (*l_1083) = (l_1081 == &g_732[4][0]);
                (*l_1083) = ((uint8_t)((*g_733) == l_1086) / (uint8_t)((g_183[2][4][1].f4 > (((uint32_t)((int32_t)(((g_183[2][4][1].f4 < ((int32_t)((((int8_t)(((int16_t)(((int32_t)(l_1073[0] > ((4294967295U > (((uint16_t)((p_3 == (void*)0) <= ((uint8_t)((uint8_t)(((uint32_t)((g_183[2][4][1].f1 > p_4) != g_35[4]) + (uint32_t)l_1002[1][0]) == 0xB7) - (uint8_t)p_6) >> (uint8_t)g_183[2][4][1].f2)) << (uint16_t)13) >= l_975)) <= l_875)) % (int32_t)p_4) > g_92.f0) * (int16_t)g_92.f0) || 4294967295U) >> (int8_t)3) == g_183[2][4][1].f2) & l_1077) - (int32_t)0x9E6B672F)) | 0) && p_6) / (int32_t)l_1107) / (uint32_t)g_92.f0) || (-5))) & g_171.f0));
                for (l_1107 = 0; (l_1107 <= 6); l_1107 += 1)
                { /* block id: 465 */
                    struct S0 **l_1109 = &g_169;
                    const uint32_t l_1122 = 0xD05895A5;
                    struct S1 *****l_1155[2][8][9] = {{{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&g_313,&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&g_313,&g_313,&l_1049[0][1],&l_1049[0][1]},{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&g_313,&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&g_313,&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&g_313,&g_313,&l_1049[0][1],&l_1049[0][1]},{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]}},{{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&g_313,&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&g_313,&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&g_313,&g_313,&l_1049[0][1],&l_1049[0][1]},{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&g_313,&g_313,&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]},{&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1],&l_1049[0][1]}}};
                    int i, j, k;
                    (*l_1109) = l_1086;
                    /* statement id: 466 */
                    assert (g_169 == &g_171);
                    (*g_376) = p_3;
                    if ((((uint16_t)(g_58 ^ l_1077) / (uint16_t)((((l_1125 != ((((int8_t)g_183[2][4][1].f0 * (int8_t)(((int16_t)(((int16_t)p_4 >> (int16_t)15) & ((uint32_t)(((uint32_t)(!(l_1073[0] ^ ((uint16_t)l_1002[0][0] * (uint16_t)(((uint16_t)((((void*)0 != (*g_148)) < l_975) || p_5) << (uint16_t)15) > l_1107)))) / (uint32_t)0x966999A7) <= 255U) - (uint32_t)(*l_1083))) + (int16_t)(*l_1083)) <= l_875)) == (-1)) && g_183[2][4][1].f3.f0)) & p_4) && g_175.f0) || g_13)) >= 0x845E))
                    { /* block id: 468 */
                        int i;
                        g_35[l_1107] = l_1107;
                        (**g_375) = (void*)0;
                        (*l_1083) = ((uint16_t)(4294967295U == (0xFEAB7D07 < ((void*)0 == &l_1074))) << (uint16_t)0);
                    }
                    else
                    { /* block id: 472 */
                        (*l_1083) = (g_723.f0 & ((int8_t)((uint8_t)((uint8_t)g_171.f0 << (uint8_t)(((uint8_t)p_6 + (uint8_t)((int16_t)g_35[2] >> (int16_t)(p_5 ^ 0x97))) || l_975)) + (uint8_t)((g_930 > (l_1155[0][6][8] != &g_313)) & l_1077)) + (int8_t)0x04));
                        (*g_375) = &p_3;
                        /* statement id: 474 */
                        assert (g_376 == &p_3);
                    }
                }
            }
            /* facts after for loop */
            assert (g_169 == &g_171 || g_169 == &g_92);
            assert (g_376 == &p_3 || (g_376 >= &g_12[0] && g_376 <= &g_12[2]));
            if (((uint8_t)((int16_t)((int8_t)((~((((uint16_t)((uint8_t)((uint8_t)g_183[2][4][1].f2 + (uint8_t)((void*)0 != l_1169)) * (uint8_t)(((1 && ((g_183[2][4][1].f1 <= g_183[2][4][1].f2) <= (-(uint8_t)((int16_t)((((*g_733) == (void*)0) < ((uint32_t)l_1179[1][5] - (uint32_t)l_1077)) != l_1180) * (int16_t)l_1002[0][0])))) & 0x5FEF) < l_1077)) >> (uint16_t)14) == g_183[2][4][1].f1) != l_1077)) & p_4) / (int8_t)l_1002[1][0]) << (int16_t)10) + (uint8_t)0x20))
            { /* block id: 478 */
                for (l_875 = 28; (l_875 == 22); --l_875)
                { /* block id: 481 */
                    return p_3;
                    /* statement id: 482 */
                    //assert (g_376 == dangling || (g_376 >= &g_12[0] && g_376 <= &g_12[2]));
                    //assert (func_2_rv == 0 || (func_2_rv >= &g_35[0] && func_2_rv <= &g_35[6]) || func_2_rv == &g_13);
                }
                for (g_58 = 26; (g_58 == (-15)); g_58 -= 4)
                { /* block id: 486 */
                    const struct S0 *l_1187 = &g_175;
                    for (l_1180 = 11; (l_1180 < 21); l_1180 += 1)
                    { /* block id: 489 */
                        (**g_375) = (void*)0;
                        (*g_148) = (void*)0;
                        (*g_1188) = l_1187;
                        (*g_376) = (*g_76);
                    }
                }
            }
            else
            { /* block id: 496 */
                int8_t l_1199[3];
                struct S1 **l_1204[6] = {&l_1036,&l_1036,&l_1036,&l_1036,&l_1036,&l_1036};
                int32_t *l_1210 = &g_13;
                int i;
                for (i = 0; i < 3; i++)
                    l_1199[i] = 0x43;
                if ((((*g_1076) <= (((int8_t)0x46 << (int8_t)(l_875 && (((int16_t)l_975 * (int16_t)(0xE7 > ((int16_t)(((void*)0 != &g_1189) < ((uint8_t)((!l_1199[2]) ^ ((g_175.f0 || g_183[2][4][1].f0) >= (-1))) - (uint8_t)l_1199[2])) / (int16_t)7U))) ^ p_4))) | g_171.f0)) >= l_1200[0][2][0]))
                { /* block id: 497 */
                    int32_t *****l_1202 = &l_1201;
                    p_3 = (*g_376);
                    (*l_1202) = l_1201;
                }
                else
                { /* block id: 500 */
                    uint16_t l_1203 = 0xB906;
                    int32_t l_1205 = 0x126DEAC7;
                    struct S1 ***l_1206 = &l_1204[2];
                    l_1203 = (-2);
                    l_1205 = (l_1204[1] != &l_1036);
                    l_1206 = l_1115;
                    /* statement id: 503 */
                    assert (l_1206 == &g_315);
                    for (l_975 = 0; (l_975 > 17); l_975++)
                    { /* block id: 506 */
                        int32_t *l_1209 = &l_1205;
                        l_1209 = (void*)0;
                        /* statement id: 507 */
                        assert (l_1209 == 0);
                        return l_1210;
                        /* statement id: 508 */
                        //assert (g_376 == dangling || (g_376 >= &g_12[0] && g_376 <= &g_12[2]));
                        //assert (func_2_rv == &g_13);
                    }
                }
                (*g_863) = (g_183[2][4][1].f4 == ((uint16_t)p_5 % (uint16_t)(((int16_t)g_171.f0 >> (int16_t)((uint16_t)((int32_t)(*l_1210) + (int32_t)0x3D55DBFD) % (uint16_t)l_1107)) ^ ((-(uint32_t)((p_5 | ((uint32_t)(&l_1036 == (void*)0) + (uint32_t)(*g_310))) > 1)) || 0x6F7BA7CD))));
            }
        }
        else
        { /* block id: 513 */
            int32_t l_1232 = 0x45A05BD4;
            int8_t l_1262 = 0x18;
            struct S0 *l_1265 = &g_723;
            int32_t l_1269 = 0x1F069E7C;
            for (l_987 = 24; (l_987 != 24); l_987 += 4)
            { /* block id: 516 */
                if (p_4)
                    break;
                (***l_1201) = (void*)0;
            }
            if ((p_4 < (((((((uint16_t)((uint32_t)((int16_t)(1 != ((uint16_t)65528U * (uint16_t)p_6)) >> (int16_t)l_1232) % (uint32_t)l_1200[0][2][0]) * (uint16_t)((uint16_t)((uint8_t)l_1179[1][5] * (uint8_t)((int8_t)l_1232 * (int8_t)l_1232)) << (uint16_t)g_687)) == p_5) == g_171.f0) != p_5) < l_1232) < (*g_647))))
            { /* block id: 520 */
                struct S1 ***l_1245 = (void*)0;
                if ((~((uint16_t)(-(uint16_t)p_5) / (uint16_t)l_1232)))
                { /* block id: 521 */
                    for (l_975 = (-23); (l_975 > (-30)); l_975 -= 2)
                    { /* block id: 524 */
                        (*g_1246) = (l_1245 == (void*)0);
                        (**g_375) = (***g_374);
                    }
                    (**g_375) = func_56(p_4);
                }
                else
                { /* block id: 529 */
                    const struct S0 *l_1266 = &g_171;
                    int32_t l_1267[6][10] = {{0x9AFB3823,0,1,1,0,0x9AFB3823,2,0xB4C588F0,0xCEC9249E,6},{0x352685FD,0xFAB947D3,3,5,1,0x9AC26C9C,0xCEC9249E,5,0xD6D57031,1},{0x352685FD,0xFADE5AB9,1,0x74AB11DA,1,1,0x0BB9781E,0,0x0BB9781E,1},{1,0x0BB9781E,0,0x0BB9781E,1,1,0xD6D57031,5,0xCEC9249E,0x9AC26C9C},{0x0BB9781E,0,1,0x352685FD,0x9AFB3823,(-1),0xFADE5AB9,0xFAB947D3,0xB4C588F0,0x9AC26C9C},{0x480CA87F,0x352685FD,2,0x9123C5E8,1,0,(-1),(-1),0,1}};
                    int i, j;
                    if (((&l_1049[0][1] == &l_1049[0][0]) > (-5)))
                    { /* block id: 530 */
                        (*g_376) = func_62((*g_329), p_3);
                        (*g_1263) = ((uint16_t)0xF901 + (uint16_t)(((((int8_t)((0x70B0 >= 65532U) && (l_1232 >= ((void*)0 != (*g_147)))) % (int8_t)((uint16_t)((uint32_t)g_183[2][4][1].f4 % (uint32_t)g_1257) * (uint16_t)(((int8_t)((uint8_t)g_35[6] >> (uint8_t)7) * (int8_t)p_4) >= l_1262))) != p_4) <= 0x0CC3) ^ g_183[2][4][1].f4));
                        return l_1264;
                        /* statement id: 533 */
                        //assert (func_2_rv == 0);
                    }
                    else
                    { /* block id: 534 */
                        l_1267[2][7] = (l_1265 != l_1266);
                        (***l_1201) = p_3;
                        (*g_1076) = l_1262;
                        p_3 = p_3;
                    }
                    return (***l_1201);
                    /* statement id: 540 */
                    //assert (func_2_rv == 0 || (func_2_rv >= &g_35[0] && func_2_rv <= &g_35[6]) || func_2_rv == &g_13);
                }
                for (g_13 = 1; (g_13 >= 0); g_13 -= 1)
                { /* block id: 544 */
                    return (**g_375);
                    /* statement id: 545 */
                    //assert (func_2_rv == 0 || (func_2_rv >= &g_35[0] && func_2_rv <= &g_35[6]) || func_2_rv == &g_13);
                }
            }
            else
            { /* block id: 547 */
                uint8_t l_1268 = 0x74;
                l_1269 = l_1268;
            }
        }
        /* facts after branching */
        assert (g_169 == &g_171 || g_169 == &g_92);
        assert (g_376 == &p_3 || (g_376 >= &g_12[0] && g_376 <= &g_12[2]));
    }
    /* facts after branching */
    assert (g_169 == &g_171 || g_169 == &g_92);
    assert (g_376 == &p_3 || (g_376 >= &g_12[0] && g_376 <= &g_12[2]));
    for (p_6 = (-4); (p_6 == 23); p_6 += 1)
    { /* block id: 554 */
        int32_t l_1284 = 1;
        struct S1 ***l_1287 = (void*)0;
        uint32_t l_1292 = 0x5BE93AF7;
        int32_t *****l_1310 = &l_1201;
        int16_t l_1333[6] = {(-1),(-1),(-1),(-1),(-1),(-1)};
        struct S0 ***l_1357 = &l_1171;
        int16_t l_1358[3];
        struct S1 *****l_1378 = &g_313;
        int32_t *l_1498 = (void*)0;
        int32_t l_1508 = 0x6C0F31B4;
        struct S0 l_1515 = {9U};
        struct S0 *****l_1559[8] = {(void*)0,&l_1169,(void*)0,&l_1169,(void*)0,&l_1169,(void*)0,&l_1169};
        int32_t *l_1573 = &g_58;
        int i;
        for (i = 0; i < 3; i++)
            l_1358[i] = 0x20A8;
    }
    return p_3;
    /* statement id: 728 */
    //assert (g_376 == dangling || (g_376 >= &g_12[0] && g_376 <= &g_12[2]));
    //assert (func_2_rv == 0 || (func_2_rv >= &g_35[0] && func_2_rv <= &g_35[6]) || func_2_rv == &g_13);
}


/* ------------------------------------------ */
/* 
 * reads : g_35 g_183.f0 g_313 g_314 g_169 g_13 g_58 g_375 g_376 g_12 g_76 g_77 g_775 g_183.f1 g_175.f0 g_93 g_92.f0 g_687 g_183.f4 g_723.f0 g_183.f2 g_171.f0 g_183.f3.f0 g_863 g_374
 * writes: g_13 g_58 g_77 g_12 g_93 g_35 g_315
 */
inline static int32_t * func_7(int32_t * p_8, int16_t  p_9, uint16_t  p_10, int32_t * p_11)
{ /* block id: 340 */
    struct S0 **l_781 = &g_169;
    int32_t l_782[1][8] = {{9,9,9,9,9,9,9,9}};
    int32_t ***l_801 = &g_376;
    uint16_t l_802 = 65535U;
    int16_t l_804 = 0xC68E;
    struct S0 *l_819 = &g_175;
    struct S0 *l_849[4][5] = {{&g_723,&g_175,&g_175,&g_723,&g_175},{&g_723,&g_723,(void*)0,&g_723,&g_723},{&g_175,&g_723,&g_175,&g_175,&g_723},{&g_723,&g_175,&g_175,&g_723,&g_175}};
    struct S1 *l_870 = (void*)0;
    struct S1 **l_869 = &l_870;
    uint8_t l_874 = 247U;
    int i, j;
    if ((8 <= (((((int8_t)(l_781 != (void*)0) * (int8_t)g_35[6]) || l_782[0][1]) > (~(7 ^ g_183[2][4][1].f0))) | ((int8_t)p_9 >> (int8_t)(((void*)0 == (*g_313)) & l_782[0][1])))))
    { /* block id: 341 */
        struct S0 *l_792 = &g_723;
        int32_t l_803[8] = {0,0xA261437F,0,0xA261437F,0,0xA261437F,0,0xA261437F};
        int16_t l_811 = 0x8073;
        int32_t *l_852 = (void*)0;
        int i;
        (***g_375) = ((int8_t)((int16_t)((&g_168[3] != (void*)0) | ((int32_t)(l_792 == (*l_781)) + (int32_t)p_9)) * (int16_t)(((uint8_t)(0xC5278211 > (*p_8)) / (uint8_t)(((((((int8_t)((uint16_t)((uint8_t)p_10 << (uint8_t)(((((void*)0 == l_801) <= 1U) == l_802) == l_803[5])) % (uint16_t)p_10) << (int8_t)0) == p_10) == 6) && 0x2E91C490) != 0) || p_10)) == g_58)) << (int8_t)l_804);
        if ((***l_801))
        { /* block id: 343 */
            const uint8_t l_805 = 0x08;
            (*g_376) = func_56(l_805);
            /* statement id: 344 */
            //assert (g_12[0] == 0 || g_12[0] == &g_13);
            assert (g_77 == 0 || (g_77 >= &g_35[0] && g_77 <= &g_35[6]));
            p_11 = p_8;
        }
        else
        { /* block id: 346 */
            int16_t l_808 = (-6);
            int32_t l_812 = 0;
            struct S0 l_813 = {0xB1};
            int32_t ***l_820 = &g_376;
            (**l_801) = func_51((*g_775), p_8, ((uint16_t)((((1U == ((((g_183[2][4][1].f1 ^ l_808) || l_803[5]) ^ ((*p_11) > (0x60A6B67B <= ((int16_t)((7U && g_175.f0) ^ l_808) / (int16_t)0x7E9A)))) | 0x7F62)) <= l_811) > 0xCD) > g_35[4]) * (uint16_t)l_812), l_813);
            /* statement id: 347 */
            //assert (g_12[0] == 0 || g_12[0] == &g_13);
            (*p_11) = (((!l_812) < ((int8_t)(((((((int16_t)g_687 >> (int16_t)(&l_813 != l_819)) == (g_13 < (((void*)0 != l_820) && 65528U))) ^ ((uint16_t)(0U == g_183[2][4][1].f4) - (uint16_t)g_175.f0)) >= 0xFC3E) != 0xAE) != l_803[5]) + (int8_t)255U)) ^ p_9);
            return p_11;
            /* statement id: 349 */
            //assert (func_7_rv == &g_13);
        }
        /* facts after branching */
        //assert (g_12[0] == 0 || g_12[0] == &g_13);
        assert (g_77 == 0 || (g_77 >= &g_35[0] && g_77 <= &g_35[6]));
        for (g_13 = 0; (g_13 >= 16); g_13++)
        { /* block id: 353 */
            uint32_t l_837 = 1U;
            struct S0 l_862 = {0x6E};
            for (p_10 = 0; (p_10 != 28); p_10++)
            { /* block id: 356 */
                int32_t l_850 = (-2);
                if (l_811)
                    break;
                for (l_804 = 14; (l_804 > (-9)); l_804--)
                { /* block id: 360 */
                    const uint32_t l_829[6][5] = {{4294967291U,0x81FED43B,4294967291U,4294967295U,8U},{0U,0xF957ED17,8U,0xF957ED17,0U},{4294967291U,0xF957ED17,0x81FED43B,0U,0x81FED43B},{0x81FED43B,0x81FED43B,8U,0U,0xE13BB57F},{0xF957ED17,4294967291U,4294967291U,0xF957ED17,0x81FED43B},{0xF957ED17,0U,4294967295U,4294967295U,0U}};
                    int i, j;
                    if (((0x8C62 & g_723.f0) >= l_829[4][2]))
                    { /* block id: 361 */
                        uint8_t l_834 = 0x1D;
                        int32_t **l_842 = (void*)0;
                        int32_t l_851 = 0x54D2BBC7;
                        l_851 = ((uint8_t)((((int32_t)(l_834 != g_92.f0) % (int32_t)((uint16_t)(((l_837 != (((((uint16_t)l_811 - (uint16_t)((p_10 || (((void*)0 == l_842) > (((int16_t)((int8_t)(((int8_t)(l_849[3][4] == (void*)0) >> (int8_t)4) <= p_9) + (int8_t)l_837) - (int16_t)l_837) && g_183[2][4][1].f2))) | g_183[2][4][1].f2)) <= l_837) < g_171.f0) ^ g_183[2][4][1].f3.f0)) <= p_10) != l_803[5]) << (uint16_t)l_850)) <= (*p_11)) ^ (*p_11)) / (uint8_t)g_183[2][4][1].f4);
                        if ((*p_11))
                            break;
                    }
                    else
                    { /* block id: 364 */
                        int16_t l_861 = (-10);
                        struct S0 ***l_865 = &l_781;
                        struct S0 ****l_864 = &l_865;
                        struct S0 *****l_866 = &l_864;
                        (**g_375) = func_51(l_852, p_8, (((*p_11) & ((((((((uint16_t)((uint16_t)(0xDE < l_837) + (uint16_t)((((int16_t)(p_9 > ((int16_t)l_861 * (int16_t)(-8))) << (int16_t)p_9) & (*p_8)) != l_829[4][2])) + (uint16_t)g_183[2][4][1].f0) && 8) < l_829[5][1]) | g_723.f0) <= p_9) != l_837) ^ 0U)) || (-3)), l_862);
                        (*g_863) = (*p_8);
                        (*l_866) = l_864;
                        (**l_801) = (**l_801);
                    }
                }
                for (l_811 = 0; l_811 < 8; l_811 += 1)
                {
                    l_803[l_811] = (-1);
                }
            }
        }
        /* facts after for loop */
        //assert (g_12[0] == 0 || (g_12[0] >= &g_35[0] && g_12[0] <= &g_35[6]) || g_12[0] == &g_13);
        (*p_8) = 0x6E384BFB;
    }
    else
    { /* block id: 375 */
        struct S0 l_867 = {3U};
        struct S1 ****l_868 = &g_314;
        (**l_801) = func_51((**l_801), p_8, p_9, l_867);
        /* statement id: 376 */
        //assert (g_12[0] == 0 || g_12[0] == &g_13);
        (*p_11) = (((l_868 == (void*)0) != (l_869 != (void*)0)) > 0xEA);
    }
    /* facts after branching */
    //assert (g_12[0] == 0 || (g_12[0] >= &g_35[0] && g_12[0] <= &g_35[6]) || g_12[0] == &g_13);
    assert (g_77 == 0 || (g_77 >= &g_35[0] && g_77 <= &g_35[6]));
    (*g_314) = &l_870;
    /* statement id: 379 */
    assert (g_315 == &l_870);
    (*p_8) = (((int32_t)(*p_8) + (int32_t)(-(uint32_t)p_10)) || l_874);
    return (***g_374);
    /* statement id: 381 */
    //assert (g_315 == dangling);
    //assert (func_7_rv == 0 || (func_7_rv >= &g_35[0] && func_7_rv <= &g_35[6]) || func_7_rv == &g_13);
}


/* ------------------------------------------ */
/* 
 * reads : g_374 g_375 g_329 g_35
 * writes: g_35
 */
static int32_t  func_17(int32_t  p_18)
{ /* block id: 337 */
    int32_t ***l_776 = &g_376;
    int32_t *l_778 = &g_35[4];
    (*l_778) = ((*g_374) == l_776);
    return (*g_329);
}


/* ------------------------------------------ */
/* 
 * reads : g_13 g_310 g_35
 * writes:
 */
inline static int32_t  func_25(uint8_t  p_26, int16_t  p_27)
{ /* block id: 1 */
    int32_t *l_33 = &g_13;
    int32_t l_37 = 0x7C242EA6;
    const int16_t l_656[5][5] = {{(-3),(-9),(-3),0x9550,0xCAE3},{0x9E39,0x771E,0x771E,0x9E39,0x771E},{0xCAE3,(-9),(-1),(-9),0xCAE3},{0x771E,0x9E39,0x771E,0x771E,0x9E39},{0xCAE3,0x9550,(-3),(-9),(-3)}};
    int32_t ***l_686 = (void*)0;
    struct S0 *l_720 = &g_175;
    int i, j;
    for (p_27 = 0; (p_27 > (-16)); p_27 -= 7)
    { /* block id: 4 */
        int16_t l_36[8][4][8] = {{{(-1),0x1355,1,0,0xCAB3,0x35DD,0,9},{(-3),0xCAB3,0xB0BA,3,0x91F3,0xB0BA,0xB05E,(-6)},{(-6),0x0B31,(-1),(-1),0xB05E,(-8),0xEED1,(-8)},{(-1),0x9751,1,0x9751,(-1),0x14A3,0x1355,0xCAB3}},{{(-1),0,1,0,0xEED1,0xB0BA,0,0x9751},{0xCAB3,0xB05E,1,(-6),(-1),3,0x1355,(-1)},{0xEED1,0x1355,1,1,(-1),(-6),0,(-1)},{0x3020,0xB0BA,1,0xE352,0,0x57F5,0x57F5,0}},{{0xB05E,0x494D,0x494D,0xB05E,0x1500,0x14A3,(-1),0x57F5},{(-3),(-1),0x91F3,0,(-1),0x1355,3,(-1)},{0x494D,(-1),0x57F5,0x35DD,0x6D7D,0x14A3,0xE352,0x0B31},{1,0x494D,0,0xB0BA,0x494D,0x57F5,0x0B31,0}},{{(-1),0xB0BA,0x9751,(-8),3,(-6),3,(-8)},{0x35DD,(-3),0x35DD,0x14A3,1,0,1,(-1)},{0x0B31,0x57F5,0x494D,0xB0BA,0,0x494D,1,0xE352},{0x0B31,(-8),9,3,1,0xBD12,0,(-1)}},{{0x35DD,0,0,0x1500,3,0xF079,0x3020,1},{(-1),0x14A3,0x1500,0xB05E,0x494D,0x494D,0xB05E,0x1500},{1,1,0x1355,0x0B31,0x6D7D,0xEED1,(-3),(-1)},{0x494D,(-3),0,0x57F5,(-1),0x3020,0x494D,(-1)}},{{(-3),0,1,0x0B31,0x1500,0x57F5,1,0x1500},{0xB05E,0,0x7268,0xB05E,0,0,(-1),1},{0x3020,(-1),0x35DD,0x1500,(-1),0x1500,0x35DD,(-1)},{0,0xF079,0x57F5,3,1,0x14A3,0x0B31,0xE352}},{{1,0,0xEED1,0xB0BA,0,0x9751,0x0B31,(-1)},{1,0xB0BA,0x57F5,0x14A3,3,0x3020,0x35DD,(-8)},{3,0x3020,0x35DD,(-8),0x57F5,0,(-1),0},{0x0B31,1,0x7268,0xB0BA,0xB0BA,0x7268,1,0x0B31}},{{0xE352,(-8),1,0x35DD,1,0xF079,0x494D,(-1)},{3,0x1500,0,0,0x35DD,0xF079,(-3),0x57F5},{(-1),(-8),(-3),0x57F5,9,0xB05E,0x57F5,0x3020},{0x1355,0x1500,(-6),0,0,0x7268,0,0x35DD}}};
        const int32_t *l_50 = &g_13;
        int32_t *l_663 = &g_13;
        uint32_t l_685 = 0x4A60314E;
        int32_t *l_689 = &g_35[4];
        struct S1 ***l_710 = &g_315;
        struct S0 *l_722 = &g_723;
        int i, j, k;
        if ((-(uint32_t)((int16_t)g_13 << (int16_t)(p_27 <= (&g_13 == l_33)))))
        { /* block id: 5 */
            int32_t *l_34[4][5] = {{&g_35[4],&g_35[2],&g_13,&g_35[4],(void*)0},{&g_35[4],&g_35[4],&g_35[4],&g_35[4],&g_35[4]},{&g_13,&g_13,&g_35[2],(void*)0,&g_13},{&g_35[4],&g_35[2],&g_35[2],&g_35[4],(void*)0}};
            int i, j;
            l_36[2][2][7] = (-1);
            l_37 = l_36[7][2][3];
        }
        else
        { /* block id: 8 */
            return (*l_33);
        }
    }
    return (*g_310);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_41(uint8_t  p_42, int32_t * p_43, int32_t * p_44, uint32_t  p_45, int16_t  p_46)
{ /* block id: 278 */
    const int32_t l_664 = 1;
    (*p_44) = l_664;
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_35 g_58 g_76 g_77 g_13 g_92 g_93 g_147 g_148 g_183.f0 g_171.f0 g_183.f1 g_183.f4 g_183.f3.f0 g_228 g_183.f2 g_175.f0 g_310 g_329 g_349 g_350 g_374 g_423 g_471 g_229 g_489 g_375 g_376 g_12 g_313 g_314 g_642 g_646
 * writes: g_58 g_77 g_93 g_35 g_229 g_313 g_349 g_375 g_329 g_647
 */
inline static uint8_t  func_47(const int32_t * p_48, uint32_t  p_49)
{ /* block id: 11 */
    int32_t *l_80 = (void*)0;
    uint32_t l_87 = 4294967292U;
    int32_t **l_108 = &g_77;
    struct S0 *l_172 = &g_92;
    struct S0 *l_178 = &g_92;
    const struct S1 *l_182 = &g_183[2][4][1];
    uint16_t l_306 = 0U;
    uint8_t l_397 = 0x3B;
    uint32_t l_457[1][5];
    int i, j;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 5; j++)
            l_457[i][j] = 4294967290U;
    }
    (*l_108) = func_51(func_56(g_35[4]), &g_13, ((int8_t)(((((l_80 == &g_35[4]) > (*p_48)) | ((uint8_t)((int16_t)((p_49 | ((uint8_t)l_87 + (uint8_t)(((uint16_t)((int8_t)(-1) - (int8_t)p_49) << (uint16_t)14) != l_87))) || l_87) + (int16_t)4) / (uint8_t)p_49)) == p_49) >= 0x0DD2C8CC) * (int8_t)l_87), g_92);
    /* statement id: 29 */
    assert ((g_77 >= &g_35[0] && g_77 <= &g_35[6]) || g_77 == 0);
    for (g_58 = 0; (g_58 <= (-27)); g_58 -= 6)
    { /* block id: 32 */
        int16_t l_130 = 0x3985;
        int32_t l_132 = 1;
        uint16_t l_166 = 0xD7FA;
        int32_t l_167 = 0x71A4F7F7;
        for (l_87 = 1; (l_87 <= 8); l_87 += 1)
        { /* block id: 35 */
            const uint32_t l_129 = 1U;
            int32_t *l_131[1];
            struct S0 **l_173[3];
            struct S0 *l_174[1];
            int i;
            for (i = 0; i < 1; i++)
                l_131[i] = &g_35[4];
            for (i = 0; i < 3; i++)
                l_173[i] = &l_172;
            for (i = 0; i < 1; i++)
                l_174[i] = &g_175;
            l_132 = ((int16_t)((uint16_t)(((uint8_t)(247U <= ((uint8_t)(246U || ((int32_t)(((int16_t)((*p_48) >= ((uint8_t)((uint32_t)((((uint16_t)(((*l_108) == (void*)0) | p_49) << (uint16_t)1) <= (g_35[6] >= ((g_58 == g_35[6]) | p_49))) & g_58) + (uint32_t)l_129) - (uint8_t)p_49)) + (int16_t)(-1)) < 4294967295U) % (int32_t)g_35[4])) - (uint8_t)p_49)) * (uint8_t)p_49) ^ l_130) - (uint16_t)0xE01D) >> (int16_t)l_129);
        }
    }
    if (((uint16_t)(l_172 != l_178) * (uint16_t)0x1503))
    { /* block id: 59 */
        struct S0 l_179[2][3] = {{{246U},{246U},{246U}},{{0xFA},{0xFA},{0xFA}}};
        const int32_t **l_180 = (void*)0;
        int i, j;
        p_48 = p_48;
    }
    else
    { /* block id: 61 */
        const struct S1 **l_184[3];
        struct S0 **l_194 = &l_178;
        const int32_t l_195 = 0x894F7204;
        int32_t l_206 = 0;
        uint8_t l_260 = 0x20;
        struct S1 ***l_312 = (void*)0;
        struct S1 ****l_311 = &l_312;
        int32_t ***l_476 = &l_108;
        int32_t l_583[10];
        uint8_t l_627 = 1U;
        int16_t l_638 = 1;
        const int32_t *l_645 = (void*)0;
        int i;
        for (i = 0; i < 3; i++)
            l_184[i] = &l_182;
        for (i = 0; i < 10; i++)
            l_583[i] = 0x7B3243C5;
        l_182 = l_182;
        if (((uint16_t)(((void*)0 != (*g_147)) > p_49) * (uint16_t)((int16_t)((((int8_t)(~g_13) % (int8_t)g_35[3]) == ((uint8_t)((&l_172 == l_194) > l_195) * (uint8_t)((uint8_t)((uint8_t)(0xC9B6 > 0x3A6A) - (uint8_t)(-6)) << (uint8_t)g_183[2][4][1].f0))) || p_49) << (int16_t)3)))
        { /* block id: 63 */
            int32_t ***l_207 = &l_108;
            int32_t l_226 = (-9);
            const struct S1 **l_247 = &l_182;
            uint32_t l_279[10][5][5] = {{{0U,0U,0U,0xE5ECC3E4,0x4CB03ED4},{0x53B305B9,4294967288U,4294967288U,0x53B305B9,0U},{0x53B305B9,0xE5ECC3E4,4294967295U,4294967295U,0xE5ECC3E4},{0U,4294967288U,4294967295U,0U,0U},{4294967288U,0U,4294967288U,4294967295U,0U}},{{0xE5ECC3E4,0x53B305B9,0U,0x53B305B9,0xE5ECC3E4},{4294967288U,0x53B305B9,0U,0xE5ECC3E4,0U},{0U,0U,0U,0xE5ECC3E4,0x4CB03ED4},{0x53B305B9,4294967288U,4294967288U,0x53B305B9,0U},{0x53B305B9,0xE5ECC3E4,4294967295U,4294967295U,0xE5ECC3E4}},{{0U,4294967288U,4294967295U,0U,0U},{4294967288U,0U,4294967288U,4294967295U,0U},{0xE5ECC3E4,0x53B305B9,0U,0x53B305B9,0xE5ECC3E4},{4294967288U,0x53B305B9,0U,0xE5ECC3E4,0U},{0U,0U,0U,0xE5ECC3E4,0x4CB03ED4}},{{0x53B305B9,4294967288U,4294967288U,0x53B305B9,0U},{0x53B305B9,0xE5ECC3E4,4294967295U,4294967295U,0xE5ECC3E4},{0U,4294967288U,4294967295U,0U,0U},{4294967288U,0U,4294967288U,4294967295U,0U},{0xE5ECC3E4,0x53B305B9,0U,0x53B305B9,0xE5ECC3E4}},{{4294967288U,0x53B305B9,0U,0xE5ECC3E4,0U},{0U,0U,0U,0xE5ECC3E4,0x4CB03ED4},{0x53B305B9,4294967288U,4294967288U,0x53B305B9,0U},{0x53B305B9,0xE5ECC3E4,4294967295U,4294967295U,0xE5ECC3E4},{0U,4294967288U,4294967295U,0U,0U}},{{4294967288U,0U,4294967288U,4294967295U,0U},{0xE5ECC3E4,0x53B305B9,0U,0x53B305B9,0xE5ECC3E4},{4294967288U,0x53B305B9,0U,0xE5ECC3E4,0U},{0U,0U,0U,0xE5ECC3E4,0x4CB03ED4},{0x53B305B9,4294967288U,4294967288U,0x53B305B9,0U}},{{4294967288U,4294967295U,0U,0U,4294967295U},{0x4CB03ED4,0xE5ECC3E4,0U,0U,0U},{0xE5ECC3E4,0x4CB03ED4,0xE5ECC3E4,0U,0U},{4294967295U,4294967288U,0U,4294967288U,4294967295U},{0xE5ECC3E4,4294967288U,0x4CB03ED4,4294967295U,0x4CB03ED4}},{{0x4CB03ED4,0x4CB03ED4,0U,4294967295U,0x53B305B9},{4294967288U,0xE5ECC3E4,0xE5ECC3E4,4294967288U,0x4CB03ED4},{4294967288U,4294967295U,0U,0U,4294967295U},{0x4CB03ED4,0xE5ECC3E4,0U,0U,0U},{0xE5ECC3E4,0x4CB03ED4,0xE5ECC3E4,0U,0U}},{{4294967295U,4294967288U,0U,4294967288U,4294967295U},{0xE5ECC3E4,4294967288U,0x4CB03ED4,4294967295U,0x4CB03ED4},{0x4CB03ED4,0x4CB03ED4,0U,4294967295U,0x53B305B9},{4294967288U,0xE5ECC3E4,0xE5ECC3E4,4294967288U,0x4CB03ED4},{4294967288U,4294967295U,0U,0U,4294967295U}},{{0x4CB03ED4,0xE5ECC3E4,0U,0U,0U},{0xE5ECC3E4,0x4CB03ED4,0xE5ECC3E4,0U,0U},{4294967295U,4294967288U,0U,4294967288U,4294967295U},{0xE5ECC3E4,4294967288U,0x4CB03ED4,4294967295U,0x4CB03ED4},{0x4CB03ED4,0x4CB03ED4,0U,4294967295U,0x53B305B9}}};
            struct S0 l_281 = {255U};
            uint32_t l_372 = 4294967294U;
            int32_t *l_498 = &l_206;
            int i, j, k;
            if ((*p_48))
            { /* block id: 64 */
                (*g_148) = (**g_147);
                for (g_58 = (-29); (g_58 == (-16)); g_58++)
                { /* block id: 68 */
                    uint16_t l_227[10] = {0xA4BA,0xA4BA,0xA4BA,0xA4BA,0xA4BA,0xA4BA,0xA4BA,0xA4BA,0xA4BA,0xA4BA};
                    int i;
                    l_206 = ((uint16_t)((((void*)0 != &g_77) && ((uint16_t)0xAD1B >> (uint16_t)g_171.f0)) || g_183[2][4][1].f1) - (uint16_t)0U);
                    if (((l_207 == &g_76) >= g_183[2][4][1].f4))
                    { /* block id: 70 */
                        int32_t *l_208 = &g_35[4];
                        (*l_208) = ((g_35[0] > (*p_48)) >= (0 < p_49));
                        l_206 = ((uint16_t)(0xB4871747 | 0x5B839079) * (uint16_t)((int16_t)((uint8_t)(((int8_t)((uint8_t)((int8_t)(g_183[2][4][1].f3.f0 != (g_35[3] > ((!(((254U != (((uint16_t)((int32_t)(-2) / (int32_t)l_226) >> (uint16_t)7) == 4294967295U)) >= g_183[2][4][1].f4) <= p_49)) < p_49))) * (int8_t)l_227[2]) * (uint8_t)0U) % (int8_t)p_49) || p_49) % (uint8_t)7U) / (int16_t)p_49));
                        (*l_208) = 0x9018F33F;
                    }
                    else
                    { /* block id: 74 */
                        int8_t l_230 = 0x2D;
                        (*g_228) = l_227[2];
                        if ((*p_48))
                            continue;
                        l_226 = (0x729903A5 | (*p_48));
                        l_206 = l_230;
                    }
                }
            }
            else
            { /* block id: 81 */
                struct S0 *l_239 = &g_175;
                int32_t l_280 = 0xE4855E6F;
                int32_t l_286 = (-6);
                int8_t l_295 = (-1);
                for (l_87 = 0; (l_87 >= 19); l_87 += 1)
                { /* block id: 84 */
                    for (p_49 = 0; (p_49 <= 7); p_49 += 1)
                    { /* block id: 87 */
                        (*g_148) = (*g_148);
                    }
                }
                for (g_58 = 25; (g_58 != (-23)); g_58 -= 8)
                { /* block id: 93 */
                    struct S0 *l_238 = &g_171;
                    int32_t l_240 = 0x2FBA135B;
                    struct S1 *l_246 = (void*)0;
                    struct S1 **l_245 = &l_246;
                    uint32_t l_259[1][4] = {{0U,0U,0U,0U}};
                    int i, j;
                    (*l_108) = func_62((((((*g_147) != (void*)0) ^ ((g_183[2][4][1].f0 | (-(uint16_t)((uint8_t)(p_48 == (void*)0) + (uint8_t)(l_238 == &g_92)))) < (g_92.f0 || ((0x9F < p_49) == 0x527ECB84)))) > 0x382E4A64) == 3U), &g_35[6]);
                    /* statement id: 94 */
                    assert ((g_77 >= &g_35[0] && g_77 <= &g_35[6]));
                    for (l_206 = 7; (l_206 >= 0); l_206 -= 1)
                    { /* block id: 97 */
                        int i;
                        (*l_194) = l_239;
                        /* statement id: 98 */
                        assert (l_178 == &g_175);
                        g_229[l_206] = (void*)0;
                        (*g_77) = l_240;
                    }
                    (***l_207) = (((**l_108) == ((uint8_t)(((0xAB55 | ((int8_t)((l_245 != l_247) ^ (((int8_t)((int32_t)l_195 + (int32_t)((uint16_t)(-(int8_t)(((((((int16_t)l_195 - (int16_t)l_195) & ((int16_t)((&g_169 == (void*)0) | p_49) * (int16_t)l_240)) == p_49) & 0x7B) & p_49) && 0x4D)) * (uint16_t)p_49)) / (int8_t)l_240) > g_58)) - (int8_t)g_183[2][4][1].f2)) | (**l_108)) >= 65528U) << (uint8_t)3)) ^ l_259[0][3]);
                    l_260 = (*g_228);
                }
                /* facts after for loop */
                assert (l_178 == &g_175 || l_178 == &g_92);
                //assert (g_229[0] == 0 || g_229[0] == &g_13 || (g_229[0] >= &g_35[0] && g_229[0] <= &g_35[6]));
                (**l_207) = func_51((**l_207), func_62(((int8_t)(((uint16_t)(g_183[2][4][1].f1 >= (((uint16_t)((uint32_t)((int32_t)(!((((int8_t)0x73 / (int8_t)g_58) < ((int16_t)p_49 * (int16_t)p_49)) & (~0x5E30))) / (int32_t)0x8B5B5E61) / (uint32_t)((int8_t)0xA4 + (int8_t)g_183[2][4][1].f4)) / (uint16_t)(-10)) > l_279[8][4][1])) * (uint16_t)(-1)) != (*p_48)) / (int8_t)255U), (*l_108)), l_280, l_281);
                l_206 = ((((int8_t)((((int16_t)0 + (int16_t)(p_49 <= l_286)) == 0xC01D) < ((int8_t)((uint16_t)g_175.f0 - (uint16_t)1) % (int8_t)((int16_t)((int8_t)l_295 / (int8_t)((uint32_t)(p_49 >= (-(int32_t)(*p_48))) / (uint32_t)p_49)) / (int16_t)p_49))) + (int8_t)g_183[2][4][1].f4) == l_260) | 0x4D78);
            }
            /* facts after branching */
            assert (l_178 == &g_175 || l_178 == &g_92);
            //assert (g_229[0] == 0 || g_229[0] == &g_13 || (g_229[0] >= &g_35[0] && g_229[0] <= &g_35[6]));
            if ((l_260 & ((l_206 != ((uint16_t)l_260 << (uint16_t)((((g_175.f0 <= (((uint8_t)((void*)0 != &l_108) - (uint8_t)0U) ^ p_49)) > 4294967295U) || p_49) >= g_175.f0))) >= 1U)))
            { /* block id: 108 */
                const uint8_t l_309 = 0xB9;
                struct S1 *l_327 = &g_183[2][4][1];
                struct S0 *l_370 = &l_281;
                int32_t *l_371 = &l_206;
                l_226 = (*p_48);
                if ((*g_228))
                { /* block id: 110 */
                    (*g_310) = (!(((((uint8_t)(((4294967294U >= (-1)) != l_306) == 1) / (uint8_t)((int32_t)(*p_48) + (int32_t)(-1))) == 0x2E3B) & (l_309 <= 1)) >= 0x034DBA47));
                    g_313 = l_311;
                    /* statement id: 112 */
                    assert (g_313 == &l_312);
                }
                else
                { /* block id: 113 */
                    return g_13;
                }
                /* facts after branching */
                assert (g_313 == &l_312);
                if (((uint16_t)(4294967295U != (g_13 < (((0xB46C >= ((uint32_t)((&g_228 == (void*)0) >= g_183[2][4][1].f3.f0) / (uint32_t)((int16_t)0x63BB * (int16_t)((uint32_t)(g_13 & (~((g_183[2][4][1].f2 <= g_171.f0) == 0xEF))) + (uint32_t)(*p_48))))) > l_309) < g_13))) * (uint16_t)l_206))
                { /* block id: 116 */
                    (**l_207) = (*g_76);
                    for (l_206 = 0; (l_206 > 27); l_206 += 2)
                    { /* block id: 120 */
                        int32_t *l_328 = (void*)0;
                        (*l_247) = l_327;
                        (*g_329) = (*p_48);
                    }
                    for (p_49 = 0; (p_49 <= 8); p_49 += 1)
                    { /* block id: 126 */
                        int8_t l_336 = 0xCC;
                        int32_t *l_348 = &l_226;
                        (*l_348) = (((int16_t)(((uint8_t)(((g_183[2][4][1].f0 >= ((uint16_t)p_49 - (uint16_t)g_183[2][4][1].f3.f0)) & (l_336 && (*p_48))) <= ((int16_t)((uint8_t)(((uint16_t)((int8_t)g_13 - (int8_t)(l_260 < (l_309 == (-(int32_t)((int8_t)g_183[2][4][1].f2 % (int8_t)0x33))))) * (uint16_t)0x1433) & g_58) << (uint8_t)g_183[2][4][1].f2) + (int16_t)0x8BAB)) * (uint8_t)p_49) != 7) - (int16_t)p_49) && p_49);
                        if ((*g_329))
                            break;
                    }
                    (*g_350) = g_349;
                }
                else
                { /* block id: 131 */
                    int32_t *l_353 = &l_226;
                    struct S1 * volatile l_354[4] = {(void*)0,(void*)0,(void*)0,(void*)0};
                    int i;
                    for (l_226 = 15; (l_226 != 6); l_226--)
                    { /* block id: 134 */
                        (*l_194) = (*l_194);
                        (**l_207) = func_51((*g_76), func_62((*p_48), &l_206), p_49, l_281);
                    }
                    (*l_353) = (&g_181 == &g_350);
                    l_354[3] = (**g_147);
                    if (((int16_t)p_49 << (int16_t)0))
                    { /* block id: 140 */
                        const int32_t l_361 = 0x243FBC65;
                        l_226 = (*p_48);
                        (*l_371) = ((uint16_t)g_13 + (uint16_t)((int8_t)0 << (int8_t)(l_361 && ((uint16_t)((uint16_t)((uint8_t)((l_370 != l_172) == (&g_314 == &g_314)) >> (uint8_t)4) * (uint16_t)1) * (uint16_t)((void*)0 != l_371)))));
                        (*l_371) = (*g_228);
                        (*l_353) = (*p_48);
                    }
                    else
                    { /* block id: 145 */
                        int32_t ***l_373 = (void*)0;
                        l_372 = (*g_329);
                        (*g_374) = l_373;
                        /* statement id: 147 */
                        assert (g_375 == 0);
                    }
                    /* facts after branching */
                    assert (g_375 == 0 || g_375 == &g_376);
                }
                /* facts after branching */
                assert (g_375 == 0 || g_375 == &g_376);
            }
            else
            { /* block id: 150 */
                const int32_t l_381 = (-1);
                int32_t l_399 = (-1);
                int16_t l_442 = 0x9CAA;
                const int16_t l_458 = (-9);
                int32_t *l_481 = &g_58;
                if ((((-1) && g_183[2][4][1].f2) != 0xB5F6773E))
                { /* block id: 151 */
                    return g_58;
                }
                else
                { /* block id: 153 */
                    uint8_t l_384[5] = {6U,6U,6U,6U,6U};
                    struct S1 *l_386 = (void*)0;
                    struct S1 **l_385 = &l_386;
                    int32_t l_398[8];
                    int32_t *l_470 = (void*)0;
                    int i;
                    for (i = 0; i < 8; i++)
                        l_398[i] = (-1);
                    l_399 = ((int8_t)(((int16_t)(&g_314 != &g_314) >> (int16_t)(l_381 || (((((((((uint32_t)((l_384[1] | g_183[2][4][1].f4) & (((void*)0 == l_385) < ((-1) <= ((int32_t)((uint8_t)((int16_t)((int32_t)((int8_t)p_49 >> (int8_t)g_183[2][4][1].f3.f0) + (int32_t)5) % (int16_t)0x6545) % (uint8_t)1) % (int32_t)l_381)))) - (uint32_t)0xD7C64DFF) && g_183[2][4][1].f0) < l_397) == l_381) != 0xA1) & l_195) || g_175.f0) == p_49))) == g_13) >> (int8_t)l_398[3]);
                    if ((*p_48))
                    { /* block id: 155 */
                        return g_92.f0;
                    }
                    else
                    { /* block id: 157 */
                        int16_t l_406 = (-7);
                        int32_t l_429 = 0x74E9201B;
                        l_399 = (((uint8_t)((((int8_t)((uint16_t)(l_406 & (0xBB2D718F <= ((int8_t)0x61 + (int8_t)l_206))) << (uint16_t)g_183[2][4][1].f2) / (int8_t)((int16_t)((int32_t)l_381 - (int32_t)(((int16_t)(0 || (((uint16_t)(((p_49 || ((~((int8_t)((uint16_t)(g_13 ^ (-1)) << (uint16_t)p_49) % (int8_t)(-4))) && g_13)) && p_49) != 1U) << (uint16_t)6) | l_195)) * (int16_t)0x2CCC) || g_92.f0)) >> (int16_t)1)) <= l_381) ^ 0xBC095B8E) - (uint8_t)g_183[2][4][1].f4) || (-2));
                        (*g_423) = (&p_48 != &l_80);
                        l_429 = ((((int32_t)(p_49 ^ (p_49 > (p_49 && (((((uint8_t)g_183[2][4][1].f4 * (uint8_t)0xFB) && (0x16B0B04B > (0xB83C || l_406))) == (~(p_49 ^ 0x8003))) == p_49)))) - (int32_t)(-6)) & l_406) != 0xD1);
                        p_48 = func_62((*p_48), (*l_108));
                        /* statement id: 161 */
                        assert ((p_48 >= &g_35[0] && p_48 <= &g_35[6]));
                    }
                    /* facts after branching */
                    assert ((p_48 >= &g_35[0] && p_48 <= &g_35[6]));
                    if ((*g_228))
                    { /* block id: 163 */
                        l_399 = (((int8_t)p_49 * (int8_t)(((int32_t)((-(uint8_t)((~((int32_t)((int16_t)g_183[2][4][1].f1 << (int16_t)6) % (int32_t)0x08064E77)) ^ p_49)) & ((uint16_t)0x3BAC * (uint16_t)(l_260 & g_92.f0))) / (int32_t)l_442) | l_260)) > g_183[2][4][1].f2);
                    }
                    else
                    { /* block id: 165 */
                        uint8_t l_459 = 0x2A;
                        (*l_108) = (*g_76);
                        l_459 = ((uint16_t)((uint32_t)((uint16_t)((uint8_t)((uint32_t)(l_442 < ((g_92.f0 != p_49) < ((p_49 | ((p_49 ^ ((int8_t)((int8_t)0x2A >> (int8_t)p_49) * (int8_t)(((0x0B818053 | l_457[0][4]) >= p_49) != g_183[2][4][1].f0))) == (-1))) && g_58))) / (uint32_t)l_458) / (uint8_t)p_49) >> (uint16_t)p_49) % (uint32_t)p_49) >> (uint16_t)4);
                    }
                    (*g_471) = ((uint8_t)p_49 + (uint8_t)((((int16_t)(p_49 || (((uint32_t)(g_58 <= ((int8_t)((&p_48 == &p_48) >= (p_49 ^ (p_49 < (((((1U <= ((((uint8_t)255U >> (uint8_t)6) == l_442) & 0x0527925C)) != 1) != 1) && (-3)) ^ g_175.f0)))) % (int8_t)1)) - (uint32_t)(-1)) == 0xA7F8)) % (int16_t)0x2804) >= p_49) ^ 0x8521));
                }
                /* facts after branching */
                assert ((p_48 >= &g_35[0] && p_48 <= &g_35[6]));
                (*l_481) = (((int32_t)(*p_48) + (int32_t)((int32_t)9 + (int32_t)((65532U && (l_399 < (p_49 & ((((void*)0 != l_476) & ((g_92.f0 | ((uint16_t)(((int8_t)(0x15 < p_49) * (int8_t)p_49) != g_175.f0) / (uint16_t)l_399)) | 65535U)) >= p_49)))) && p_49))) < l_372);
                (*l_194) = (void*)0;
                /* statement id: 172 */
                assert (l_178 == 0);
            }
            /* facts after branching */
            assert ((p_48 >= &g_35[0] && p_48 <= &g_35[6]) || p_48 == &g_13);
            assert (l_178 == 0 || l_178 == &g_175 || l_178 == &g_92);
            assert (g_313 == &g_314 || g_313 == &l_312);
            assert (g_375 == 0 || g_375 == &g_376);
            for (l_306 = 0; (l_306 <= 8); l_306 += 1)
            { /* block id: 176 */
                uint16_t l_485[10] = {0x5478,0x5478,1U,0x5478,0x5478,1U,0x5478,0x5478,1U,0x5478};
                int32_t l_488 = (-4);
                int32_t *l_494[7][1][3] = {{{&g_35[4],(void*)0,&g_35[4]}},{{&l_488,&l_488,&l_488}},{{&g_35[4],(void*)0,&g_35[4]}},{{&l_488,&l_488,&l_488}},{{&g_35[4],(void*)0,&g_35[4]}},{{&l_488,&l_488,&l_488}},{{&g_35[4],(void*)0,&g_35[4]}}};
                struct S0 *l_497 = &g_171;
                int i, j, k;
                for (l_206 = 0; (l_206 >= 0); l_206 -= 1)
                { /* block id: 179 */
                    int32_t l_490 = (-1);
                    int32_t l_493[6];
                    int i;
                    for (i = 0; i < 6; i++)
                        l_493[i] = 1;
                    l_488 = (-(uint8_t)(p_49 || (((uint32_t)(4294967291U && g_183[2][4][1].f1) + (uint32_t)l_485[1]) || ((uint8_t)p_49 % (uint8_t)g_58))));
                    for (l_397 = 0; (l_397 <= 7); l_397 += 1)
                    { /* block id: 183 */
                        int i;
                        (*g_489) = g_229[(l_206 + 2)];
                        (*g_423) = l_490;
                    }
                    for (l_490 = 9; (l_490 >= 0); l_490 -= 1)
                    { /* block id: 189 */
                        int i;
                        l_493[4] = ((int16_t)((*g_374) != &g_376) >> (int16_t)11);
                        return l_485[l_306];
                        /* statement id: 191 */
                        //assert (g_77 == dangling || (g_77 >= &g_35[0] && g_77 <= &g_35[6]) || g_77 == 0);
                        //assert (g_313 == &g_314 || g_313 == dangling);
                    }
                    if ((**g_376))
                        continue;
                }
                l_226 = (l_178 == &l_281);
                l_226 = (p_49 && ((p_49 && (1U >= ((uint16_t)((&g_314 != &g_314) && ((void*)0 != l_497)) * (uint16_t)0x5D79))) && (0x1ABCB779 == (*p_48))));
                (*l_108) = l_498;
                /* statement id: 197 */
                assert (g_77 == &l_206);
            }
            /* facts after for loop */
            assert (g_77 == &l_206 || (g_77 >= &g_35[0] && g_77 <= &g_35[6]) || g_77 == 0);
            assert (g_329 == 0 || g_329 == &g_13 || (g_329 >= &g_35[0] && g_329 <= &g_35[6]));
            (**l_207) = (*g_376);
            /* statement id: 199 */
            assert (g_77 == &g_13);
        }
        else
        { /* block id: 200 */
            uint8_t l_501 = 3U;
            struct S0 *l_523[1][8][9] = {{{&g_92,&g_171,&g_171,&g_92,&g_171,&g_171,&g_92,&g_171,&g_171},{&g_171,(void*)0,(void*)0,&g_171,(void*)0,(void*)0,&g_171,(void*)0,(void*)0},{&g_92,&g_171,&g_171,&g_92,&g_171,&g_171,&g_92,&g_171,&g_171},{&g_171,(void*)0,(void*)0,&g_171,(void*)0,(void*)0,&g_171,(void*)0,(void*)0},{&g_92,&g_175,&g_175,&g_171,&g_175,&g_175,&g_171,&g_175,&g_175},{(void*)0,&g_92,&g_92,(void*)0,&g_92,&g_92,(void*)0,&g_92,&g_92},{&g_171,&g_175,&g_175,&g_171,&g_175,&g_175,&g_171,&g_175,&g_175},{(void*)0,&g_92,&g_92,(void*)0,&g_92,&g_92,(void*)0,&g_92,&g_92}}};
            struct S1 *l_596 = &g_183[2][5][0];
            struct S1 **l_595 = &l_596;
            int32_t l_632 = 0x7B5D0421;
            int32_t ****l_633 = &l_476;
            struct S1 ****l_643 = (void*)0;
            int i, j, k;
            if ((&l_476 != (void*)0))
            { /* block id: 201 */
                const int32_t l_508 = (-1);
                int32_t l_527 = 0;
                struct S1 **l_559 = (void*)0;
                struct S0 l_560[8][10] = {{{1U},{0xB0},{0x2F},{0x13},{0x13},{0x2F},{0xB0},{1U},{0x22},{0x6E}},{{0x5F},{0x13},{0xB0},{0xED},{0x8C},{1U},{0x8C},{0xED},{0xB0},{0x13}},{{0x2F},{255U},{0xB0},{0x8C},{0xB0},{0xED},{1U},{1U},{0xED},{0xB0}},{{0x6E},{0x2F},{0x2F},{0x6E},{7U},{0xED},{0x5F},{0xB0},{0xB0},{0xB0}},{{0x2F},{1U},{0x22},{0xB0},{0x22},{1U},{0x2F},{0x5F},{0xB0},{255U}},{{0x5F},{0xED},{7U},{0x6E},{0x2F},{0x2F},{0x6E},{7U},{0xED},{0x5F}},{{1U},{0xED},{0xB0},{0x8C},{0xB0},{255U},{0x2F},{255U},{0xB0},{0x8C}},{{0x8C},{1U},{0x8C},{0xED},{0xB0},{0x13},{0x5F},{0x22},{0x22},{0x5F}}};
                int i, j;
                if (((uint16_t)l_501 >> (uint16_t)((uint16_t)((uint8_t)(l_508 || ((p_49 & (((uint16_t)(((((uint32_t)(((((uint8_t)((int8_t)(~(5U > ((*g_374) == l_476))) + (int8_t)0xB2) << (uint8_t)g_171.f0) < g_171.f0) || 0xC1879012) == g_35[6]) - (uint32_t)p_49) || 252U) < p_49) != 0x5D25) % (uint16_t)65528U) < 0x8532F8F7)) == p_49)) + (uint8_t)g_58) * (uint16_t)p_49)))
                { /* block id: 202 */
                    uint32_t l_526 = 0xF19C15CD;
                    (**l_476) = (void*)0;
                    /* statement id: 203 */
                    assert (g_77 == 0);
                    l_527 = (((((int8_t)(0U != (!((int8_t)(l_523[0][5][7] == l_172) << (int8_t)(!((~((p_49 <= p_49) < ((g_183[2][4][1].f4 == l_526) == g_183[2][4][1].f2))) == g_13))))) >> (int8_t)0) != p_49) & p_49) & (-5));
                }
                else
                { /* block id: 205 */
                    uint32_t l_534 = 4294967295U;
                    int32_t l_563 = 0x9AB098BF;
                    for (l_87 = 0; (l_87 <= 2); l_87 += 1)
                    { /* block id: 208 */
                        int i;
                        (*l_108) = func_56(g_35[(l_87 + 4)]);
                    }
                    /* facts after for loop */
                    assert ((g_77 >= &g_35[0] && g_77 <= &g_35[6]) || g_77 == 0 || g_77 == &g_13);
                    for (l_306 = 0; (l_306 <= 2); l_306 += 1)
                    { /* block id: 213 */
                        int32_t *l_549 = &l_206;
                        int i;
                        (*l_549) = ((-(uint8_t)p_49) == (((int32_t)1 - (int32_t)(!((int32_t)l_534 + (int32_t)(((uint16_t)65528U / (uint16_t)p_49) < g_13)))) & ((int8_t)((uint8_t)((uint8_t)((uint8_t)((uint16_t)p_49 % (uint16_t)((int16_t)0xE51C >> (int16_t)(((p_49 & 255U) == l_501) <= l_501))) << (uint8_t)2) - (uint8_t)0x58) / (uint8_t)p_49) + (int8_t)g_183[2][4][1].f1)));
                        if (l_501)
                            continue;
                        g_229[(l_306 + 3)] = func_62(((int8_t)g_35[4] << (int8_t)4), (*g_76));
                        l_563 = ((5U > p_49) ^ ((int16_t)g_183[2][4][1].f4 * (int16_t)l_534));
                    }
                }
                /* facts after branching */
                assert ((g_77 >= &g_35[0] && g_77 <= &g_35[6]) || g_77 == 0 || g_77 == &g_13);
            }
            else
            { /* block id: 220 */
                struct S1 *l_576 = (void*)0;
                int32_t l_580 = 2;
                struct S1 ****l_584 = &l_312;
                struct S0 *l_605 = &g_171;
                (*l_108) = (void*)0;
                /* statement id: 221 */
                assert (g_77 == 0);
                for (p_49 = 0; (p_49 < 36); p_49 += 2)
                { /* block id: 224 */
                    int32_t l_575 = 0xDC235667;
                    const struct S1 *l_577[2];
                    int i;
                    for (i = 0; i < 2; i++)
                        l_577[i] = &g_183[0][6][2];
                    if ((*p_48))
                        break;
                    l_575 = (~((uint16_t)1U + (uint16_t)(((((uint32_t)(((int16_t)((uint16_t)l_575 * (uint16_t)((*p_48) >= 0x5FAFA227)) >> (int16_t)6) < (l_576 == l_577[1])) - (uint32_t)((int16_t)l_580 % (int16_t)((((int8_t)p_49 / (int8_t)0x6B) || l_501) || (*p_48)))) <= l_583[6]) != (-4)) != 0xECEE)));
                }
                if ((l_584 != (void*)0))
                { /* block id: 228 */
                    int32_t l_599 = 0;
                    if ((((uint16_t)(l_580 == (((uint8_t)(g_183[2][4][1].f1 || ((&p_48 != (void*)0) <= ((int16_t)p_49 << (int16_t)(((int8_t)((int16_t)(((((void*)0 != l_595) < (((((int16_t)(-7) >> (int16_t)0) <= (p_49 >= 4294967295U)) <= 0x4A) >= 0x4B7EB845)) ^ p_49) | 0x1E52B521) + (int16_t)g_13) << (int8_t)l_599) > l_599)))) << (uint8_t)l_599) && g_183[2][4][1].f0)) >> (uint16_t)1) > l_580))
                    { /* block id: 229 */
                        uint32_t l_604 = 4294967295U;
                        int32_t l_614 = 1;
                        (*g_310) = (*p_48);
                        l_614 = (((uint32_t)g_183[2][4][1].f3.f0 + (uint32_t)(((((0 < (65535U | ((uint16_t)((l_604 > l_501) & (((&g_171 != l_605) || (((int8_t)((uint32_t)4294967295U - (uint32_t)(((uint16_t)(((((uint16_t)((0xDD ^ 0x3C) <= 0x91) >> (uint16_t)7) & p_49) == l_580) | g_175.f0) - (uint16_t)0x056F) & 0xE7)) >> (int8_t)g_58) != l_599)) & (-1))) - (uint16_t)0x6E59))) | l_599) == (*p_48)) <= 4294967293U) || p_49)) >= p_49);
                        return p_49;
                    }
                    else
                    { /* block id: 233 */
                        uint8_t l_615 = 0U;
                        l_615 = (-2);
                        (**l_476) = &l_580;
                        /* statement id: 235 */
                        assert (g_77 == &l_580);
                    }
                    /* facts after branching */
                    assert (g_77 == &l_580);
                }
                else
                { /* block id: 237 */
                    int32_t l_628[1];
                    int i;
                    for (i = 0; i < 1; i++)
                        l_628[i] = 0x89FAE308;
                    for (l_87 = 0; (l_87 <= 6); l_87 += 1)
                    { /* block id: 240 */
                        int i;
                        return g_35[l_87];
                    }
                    l_628[0] = (5U > ((((uint8_t)g_171.f0 << (uint8_t)2) != (((uint16_t)(~((((int8_t)((int16_t)l_580 % (int16_t)(65531U && p_49)) % (int8_t)g_35[0]) < g_183[2][4][1].f4) | (((int32_t)(p_49 < (((l_627 > g_183[2][4][1].f4) & l_580) && p_49)) + (int32_t)g_58) < 7))) >> (uint16_t)11) <= p_49)) & 0xE4029C27));
                    for (l_260 = 0; (l_260 >= 22); l_260 += 1)
                    { /* block id: 246 */
                        int32_t *l_639 = &g_35[4];
                        (*l_194) = (void*)0;
                        /* statement id: 247 */
                        assert (l_178 == 0);
                        (**l_476) = (**l_476);
                        l_632 = (-(int32_t)(***g_375));
                        (*l_639) = ((l_632 & (((l_633 != (void*)0) >= ((uint8_t)p_49 << (uint8_t)l_628[0])) ^ ((g_183[2][4][1].f3.f0 > g_58) ^ ((uint8_t)254U << (uint8_t)(l_638 <= g_183[2][4][1].f2))))) ^ 0x66);
                    }
                    /* facts after for loop */
                    assert (l_178 == 0 || l_178 == &g_92);
                    (*l_311) = (*g_313);
                    /* statement id: 252 */
                    assert (l_312 == &g_315);
                }
                /* facts after branching */
                assert (g_77 == 0 || g_77 == &l_580);
                assert (l_178 == 0 || l_178 == &g_92);
                assert (l_312 == &g_315 || l_312 == 0);
                for (l_206 = 0; (l_206 >= 0); l_206 -= 1)
                { /* block id: 256 */
                    struct S1 ***l_640 = &g_315;
                    const uint8_t l_641 = 0xF5;
                    l_640 = (*g_313);
                    for (l_397 = 3; (l_397 <= 8); l_397 += 1)
                    { /* block id: 260 */
                        int i, j;
                        (*g_642) = (l_457[l_206][l_206] || ((0x966393AD ^ 4U) != l_641));
                    }
                    for (l_580 = 5; (l_580 >= 2); l_580 -= 1)
                    { /* block id: 265 */
                        int32_t l_644 = 4;
                        l_644 = ((void*)0 == l_643);
                        return l_641;
                        /* statement id: 267 */
                        //assert (g_77 == 0 || g_77 == dangling);
                    }
                }
            }
            /* facts after branching */
            //assert (g_77 == 0 || g_77 == dangling || (g_77 >= &g_35[0] && g_77 <= &g_35[6]) || g_77 == &g_13);
            assert (l_178 == 0 || l_178 == &g_92);
            assert (l_312 == &g_315 || l_312 == 0);
            l_645 = p_48;
            /* statement id: 271 */
            assert (l_645 == &g_13);
            (*l_108) = (void*)0;
            /* statement id: 272 */
            assert (g_77 == 0);
            (*g_646) = p_48;
            /* statement id: 273 */
            assert (g_647 == &g_13);
        }
        /* facts after branching */
        assert ((p_48 >= &g_35[0] && p_48 <= &g_35[6]) || p_48 == &g_13);
        assert (g_77 == 0 || g_77 == &g_13);
        assert (l_178 == 0 || l_178 == &g_175 || l_178 == &g_92);
        //assert (g_229[0] == 0 || g_229[0] == &g_13 || (g_229[0] >= &g_35[0] && g_229[0] <= &g_35[6]));
        assert (l_312 == &g_315 || l_312 == 0);
        assert (g_313 == &g_314 || g_313 == &l_312);
        assert (g_329 == 0 || g_329 == &g_13 || (g_329 >= &g_35[0] && g_329 <= &g_35[6]));
        assert (g_375 == 0 || g_375 == &g_376);
        assert (l_645 == &g_13 || l_645 == 0);
        assert (g_647 == &g_13 || (g_647 >= &g_35[0] && g_647 <= &g_35[6]));
        (**l_476) = func_56(g_92.f0);
    }
    /* facts after branching */
    assert ((p_48 >= &g_35[0] && p_48 <= &g_35[6]) || p_48 == &g_13);
    assert (g_77 == 0 || g_77 == &g_13 || (g_77 >= &g_35[0] && g_77 <= &g_35[6]));
    assert (l_178 == 0 || l_178 == &g_175 || l_178 == &g_92);
    //assert (g_229[0] == 0 || g_229[0] == &g_13 || (g_229[0] >= &g_35[0] && g_229[0] <= &g_35[6]));
    //assert (g_313 == &g_314 || g_313 == dangling);
    assert (g_329 == 0 || g_329 == &g_13 || (g_329 >= &g_35[0] && g_329 <= &g_35[6]));
    assert (g_375 == 0 || g_375 == &g_376);
    assert (g_647 == &g_13 || (g_647 >= &g_35[0] && g_647 <= &g_35[6]));
    return g_183[2][4][1].f3.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_93 g_35 g_92.f0 g_13 g_76 g_77
 * writes: g_93 g_58
 */
static int32_t * func_51(int32_t * p_52, int32_t * p_53, uint32_t  p_54, struct S0  p_55)
{ /* block id: 25 */
    struct S1 * volatile *l_94 = &g_93[2];
    int32_t **l_97 = (void*)0;
    int32_t **l_98 = &g_77;
    int32_t **l_103 = &g_77;
    int32_t *l_106 = (void*)0;
    int32_t *l_107 = &g_58;
    (*l_94) = g_93[7];
    (*l_107) = ((int16_t)((l_97 != l_98) & (((int8_t)((int8_t)p_54 << (int8_t)(l_103 != (void*)0)) << (int8_t)6) && g_35[4])) % (int16_t)((uint32_t)g_92.f0 % (uint32_t)(((*p_53) | ((void*)0 != &g_93[2])) || 4294967295U)));
    return (*g_76);
    /* statement id: 28 */
    //assert ((func_51_rv >= &g_35[0] && func_51_rv <= &g_35[6]) || func_51_rv == 0 || func_51_rv == &g_13);
}


/* ------------------------------------------ */
/* 
 * reads : g_58 g_76 g_77
 * writes: g_58 g_77
 */
static int32_t * func_56(const int32_t  p_57)
{ /* block id: 12 */
    const int32_t l_61[10] = {0xBF520F09,0xBF520F09,(-1),0xBF520F09,0xBF520F09,(-1),0xBF520F09,0xBF520F09,(-1),0xBF520F09};
    int i;
    for (g_58 = 0; (g_58 == 19); g_58++)
    { /* block id: 15 */
        int32_t *l_65 = &g_13;
        if (l_61[8])
            break;
        (*g_76) = func_62(p_57, l_65);
        /* statement id: 21 */
        assert ((g_77 >= &g_35[0] && g_77 <= &g_35[6]));
        return l_65;
        /* statement id: 22 */
        //assert (func_56_rv == &g_13);
    }
    return (*g_76);
    /* statement id: 24 */
    //assert (func_56_rv == 0 || (func_56_rv >= &g_35[0] && func_56_rv <= &g_35[6]) || func_56_rv == &g_13);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_62(int32_t  p_63, int32_t * p_64)
{ /* block id: 17 */
    uint8_t l_74 = 1U;
    int32_t *l_75 = &g_35[4];
    p_63 = (((int16_t)(&g_35[4] == &p_63) * (int16_t)(&p_63 == &p_63)) | (&g_58 == &g_13));
    l_74 = (((uint16_t)(&p_63 != (void*)0) * (uint16_t)(p_63 != (((int16_t)(&p_63 != &p_63) - (int16_t)((&p_63 != (void*)0) == (&g_35[4] != (void*)0))) > p_63))) == p_63);
    return l_75;
    /* statement id: 20 */
    //assert ((func_62_rv >= &g_35[0] && func_62_rv <= &g_35[6]));
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_13, "g_13", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        transparent_crc(g_35[i], "g_35[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_58, "g_58", print_hash_value);
    transparent_crc(g_92.f0, "g_92.f0", print_hash_value);
    transparent_crc(g_171.f0, "g_171.f0", print_hash_value);
    transparent_crc(g_175.f0, "g_175.f0", print_hash_value);
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 9; j++)
        {
            for (k = 0; k < 3; k++)
            {
                transparent_crc(g_183[i][j][k].f0, "g_183[i][j][k].f0", print_hash_value);
                transparent_crc(g_183[i][j][k].f1, "g_183[i][j][k].f1", print_hash_value);
                transparent_crc(g_183[i][j][k].f2, "g_183[i][j][k].f2", print_hash_value);
                transparent_crc(g_183[i][j][k].f3.f0, "g_183[i][j][k].f3.f0", print_hash_value);
                transparent_crc(g_183[i][j][k].f4, "g_183[i][j][k].f4", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_687, "g_687", print_hash_value);
    transparent_crc(g_723.f0, "g_723.f0", print_hash_value);
    transparent_crc(g_930, "g_930", print_hash_value);
    transparent_crc(g_1257, "g_1257", print_hash_value);
    transparent_crc(g_1371, "g_1371", print_hash_value);
    transparent_crc(g_1377.f0, "g_1377.f0", print_hash_value);
    transparent_crc(g_1377.f1, "g_1377.f1", print_hash_value);
    transparent_crc(g_1377.f2, "g_1377.f2", print_hash_value);
    transparent_crc(g_1377.f3.f0, "g_1377.f3.f0", print_hash_value);
    transparent_crc(g_1377.f4, "g_1377.f4", print_hash_value);
    transparent_crc(g_1410, "g_1410", print_hash_value);
    transparent_crc(g_1469, "g_1469", print_hash_value);
    transparent_crc(g_1472.f0, "g_1472.f0", print_hash_value);
    transparent_crc(g_1472.f1, "g_1472.f1", print_hash_value);
    transparent_crc(g_1472.f2, "g_1472.f2", print_hash_value);
    transparent_crc(g_1472.f3.f0, "g_1472.f3.f0", print_hash_value);
    transparent_crc(g_1472.f4, "g_1472.f4", print_hash_value);
    transparent_crc(g_1505, "g_1505", print_hash_value);
    transparent_crc(g_1542, "g_1542", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        for (j = 0; j < 4; j++)
        {
            transparent_crc(g_1563[i][j], "g_1563[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 5; j++)
        {
            for (k = 0; k < 5; k++)
            {
                transparent_crc(g_1706[i][j][k].f0, "g_1706[i][j][k].f0", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_1735.f0, "g_1735.f0", print_hash_value);
    transparent_crc(g_1750.f0, "g_1750.f0", print_hash_value);
    transparent_crc(g_1750.f1, "g_1750.f1", print_hash_value);
    transparent_crc(g_1750.f2, "g_1750.f2", print_hash_value);
    transparent_crc(g_1750.f3.f0, "g_1750.f3.f0", print_hash_value);
    transparent_crc(g_1750.f4, "g_1750.f4", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 333
   depth: 1, occurrence: 9
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 307
   depth: 2, occurrence: 77
   depth: 3, occurrence: 16
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3
   depth: 6, occurrence: 4
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 8
   depth: 12, occurrence: 4
   depth: 13, occurrence: 1
   depth: 14, occurrence: 5
   depth: 15, occurrence: 6
   depth: 16, occurrence: 3
   depth: 17, occurrence: 5
   depth: 18, occurrence: 5
   depth: 19, occurrence: 2
   depth: 20, occurrence: 4
   depth: 21, occurrence: 3
   depth: 22, occurrence: 4
   depth: 23, occurrence: 2
   depth: 24, occurrence: 3
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 264

XXX times a variable address is taken: 513
XXX times a pointer is dereferenced on RHS: 216
breakdown:
   depth: 1, occurrence: 180
   depth: 2, occurrence: 26
   depth: 3, occurrence: 10
XXX times a pointer is dereferenced on LHS: 153
breakdown:
   depth: 1, occurrence: 118
   depth: 2, occurrence: 27
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 86
XXX times a pointer is compared with address of another variable: 34
XXX times a pointer is compared with another pointer: 40
XXX times a pointer is qualified to be dereferenced: 1766

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 490
   level: 2, occurrence: 203
   level: 3, occurrence: 156
   level: 4, occurrence: 45
   level: 5, occurrence: 29
XXX number of pointers point to pointers: 126
XXX number of pointers point to scalars: 84
XXX number of pointers point to structs: 54
XXX percent of pointers has null in alias set: 33
XXX average alias set size: 1.41

XXX times a non-volatile is read: 1585
XXX times a non-volatile is write: 454
XXX times a volatile is read: 134
XXX    times read thru a pointer: 18
XXX times a volatile is write: 82
XXX    times written thru a pointer: 29
XXX times a volatile is available for access: 1.01e+03
XXX percentage of non-volatile access: 90.4

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 301
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 24
   depth: 2, occurrence: 37
   depth: 3, occurrence: 53
   depth: 4, occurrence: 70
   depth: 5, occurrence: 87

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
********************* end of statistics **********************/

