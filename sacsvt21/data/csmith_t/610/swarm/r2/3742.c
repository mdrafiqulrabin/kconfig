/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3453509072
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint8_t  f1;
   uint32_t  f2;
   int16_t  f3;
   unsigned f4 : 5;
   int64_t  f5;
   int32_t  f6;
   unsigned f7 : 19;
   unsigned f8 : 14;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_29(void);
static int32_t * func_30(uint16_t  p_31, uint64_t  p_32, int32_t * p_33, uint64_t  p_34, int64_t  p_35);
static struct S0  func_46(int32_t * p_47, int32_t * p_48);
static int32_t * func_49(uint16_t  p_50, int32_t * p_51);
static uint16_t  func_63(int32_t * p_64, uint16_t  p_65, int16_t  p_66, uint32_t  p_67, uint32_t  p_68);
static int32_t * func_80(int32_t * p_81, int32_t  p_82);
static int32_t * func_83(int32_t  p_84, int32_t * p_85);
static int32_t  func_86(uint32_t  p_87, int32_t * p_88);
static int32_t * func_89(int32_t  p_90, int32_t * p_91, int32_t * p_92);
static int32_t * func_93(struct S0  p_94);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_29(void)
{ /* block id: 36 */
    int32_t l_41 = 0x4129B857L;
    int32_t *l_40 = &l_41;
    int64_t l_42[6] = {(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)};
    int32_t *l_43 = (void*)0;
    int32_t *l_44 = &l_41;
    uint8_t l_45 = 0xAFL;
    int32_t **l_628[9][4][6] = {{{&l_44,&l_40,&l_44,&l_43,(void*)0,&l_40},{&l_44,&l_43,&l_43,&l_44,&l_44,&l_44},{&l_44,&l_44,&l_44,&l_44,&l_44,(void*)0},{&l_40,&l_43,&l_40,&l_44,&l_44,&l_40}},{{&l_44,&l_40,&l_44,(void*)0,&l_44,&l_40},{&l_43,&l_44,&l_43,&l_43,&l_44,&l_44},{&l_44,&l_40,&l_40,&l_43,&l_44,&l_43},{(void*)0,&l_43,(void*)0,&l_40,&l_43,&l_43}},{{&l_40,&l_44,&l_44,&l_44,&l_43,&l_40},{&l_43,&l_40,&l_40,&l_44,&l_40,&l_40},{&l_40,&l_43,&l_40,&l_40,&l_40,&l_44},{(void*)0,&l_43,&l_44,&l_43,&l_40,&l_44}},{{&l_44,&l_43,&l_43,&l_43,&l_44,&l_44},{&l_44,&l_43,&l_44,&l_44,&l_43,&l_40},{&l_44,(void*)0,&l_44,(void*)0,&l_44,&l_44},{&l_40,&l_43,(void*)0,&l_43,&l_44,&l_44}},{{&l_43,&l_43,&l_43,&l_43,&l_40,&l_44},{&l_44,&l_40,&l_43,&l_44,&l_43,&l_43},{&l_43,&l_44,&l_43,&l_44,&l_43,&l_40},{&l_43,&l_40,(void*)0,&l_44,&l_40,&l_44}},{{&l_44,&l_43,&l_40,&l_43,&l_44,&l_40},{&l_43,&l_43,&l_44,&l_44,&l_44,&l_43},{(void*)0,(void*)0,&l_43,&l_44,&l_43,&l_44},{&l_40,&l_43,&l_43,&l_40,&l_44,&l_40}},{{&l_43,&l_43,(void*)0,&l_44,&l_40,&l_44},{&l_40,&l_43,&l_44,&l_43,&l_40,&l_43},{&l_43,&l_43,&l_43,&l_43,&l_40,&l_44},{&l_43,&l_40,&l_40,&l_43,&l_43,&l_44}},{{&l_40,&l_44,&l_43,&l_40,&l_43,&l_43},{&l_43,&l_43,&l_44,&l_44,&l_44,&l_44},{&l_40,(void*)0,(void*)0,&l_43,&l_43,&l_40},{&l_40,&l_43,&l_43,(void*)0,&l_40,&l_44}},{{&l_43,(void*)0,&l_43,&l_40,&l_44,&l_43},{&l_43,&l_40,&l_44,&l_40,&l_43,&l_40},{&l_44,&l_43,&l_40,&l_40,&l_43,&l_44},{&l_44,&l_44,(void*)0,&l_43,&l_44,&l_40}}};
    int32_t *l_629[2];
    int32_t ****l_631 = (void*)0;
    int32_t *****l_630[8][5][6];
    uint64_t l_635 = 0xD6D21A7548B3A6A9LL;
    int i, j, k;
    for (i = 0; i < 2; i++)
        l_629[i] = &l_41;
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 5; j++)
        {
            for (k = 0; k < 6; k++)
                l_630[i][j][k] = &l_631;
        }
    }
    l_629[1] = func_30(((uint16_t)((uint64_t)((void*)0 != l_40) + (uint64_t)(((*l_40) & 0UL) | (&l_41 == &l_41))) + (uint16_t)l_42[5]), (l_43 == l_44), &l_41, (*l_44), l_45);
    l_630[1][1][4] = l_630[0][4][4];
    for (l_41 = 0; (l_41 == (-15)); l_41 -= 1)
    { /* block id: 464 */
        int32_t *l_634 = &l_41;
        l_634 = l_634;
    }
    return l_635;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(uint16_t  p_31, uint64_t  p_32, int32_t * p_33, uint64_t  p_34, int64_t  p_35)
{ /* block id: 37 */
    int32_t l_52 = 0xC1E183A0L;
    int32_t *l_485 = (void*)0;
    struct S0 l_600[2][3] = {{{0x31AD093BL,0xF6L,4294967289UL,0x5338L,0,0xC5E3DA605AFD9570LL,3L,308,89},{0x31AD093BL,0xF6L,4294967289UL,0x5338L,0,0xC5E3DA605AFD9570LL,3L,308,89},{0x31AD093BL,0xF6L,4294967289UL,0x5338L,0,0xC5E3DA605AFD9570LL,3L,308,89}},{{0x31AD093BL,0xF6L,4294967289UL,0x5338L,0,0xC5E3DA605AFD9570LL,3L,308,89},{0x31AD093BL,0xF6L,4294967289UL,0x5338L,0,0xC5E3DA605AFD9570LL,3L,308,89},{0x31AD093BL,0xF6L,4294967289UL,0x5338L,0,0xC5E3DA605AFD9570LL,3L,308,89}}};
    struct S0 *l_599 = &l_600[0][0];
    int32_t **l_627 = &l_485;
    int i, j;
    (*l_599) = func_46(func_49(l_52, &l_52), l_485);
    for (p_34 = 0; (p_34 <= 1); p_34 += 1)
    { /* block id: 423 */
        struct S0 l_601 = {1L,1UL,5UL,-1L,2,0L,8L,133,127};
        int32_t ****l_611 = (void*)0;
        (*l_599) = l_601;
        for (l_601.f1 = 0; (l_601.f1 <= 1); l_601.f1 += 1)
        { /* block id: 427 */
            uint16_t l_624 = 4UL;
            int i, j;
            l_600[p_34][p_34] = l_600[l_601.f1][(p_34 + 1)];
            for (l_601.f0 = 0; (l_601.f0 > 28); l_601.f0++)
            { /* block id: 431 */
                int32_t ****l_605 = (void*)0;
                int32_t *****l_604 = &l_605;
                struct S0 l_610[4] = {{0x0F560C3EL,7UL,9UL,-7L,3,0x4B75CC7119B55087LL,1L,500,8},{0x0F560C3EL,7UL,9UL,-7L,3,0x4B75CC7119B55087LL,1L,500,8},{0x0F560C3EL,7UL,9UL,-7L,3,0x4B75CC7119B55087LL,1L,500,8},{0x0F560C3EL,7UL,9UL,-7L,3,0x4B75CC7119B55087LL,1L,500,8}};
                int i;
                for (l_601.f6 = 1; (l_601.f6 >= 0); l_601.f6 -= 1)
                { /* block id: 434 */
                    int32_t *****l_606 = &l_605;
                    (*p_33) = (*p_33);
                    l_606 = l_604;
                    if (l_600[l_601.f1][(p_34 + 1)].f4)
                        break;
                }
                for (l_52 = 0; (l_52 <= 10); l_52++)
                { /* block id: 441 */
                    int32_t *l_609 = (void*)0;
                    struct S0 l_626 = {9L,0x40L,0x3DD629E9L,0L,3,-2L,0x4DDBE7C7L,270,32};
                    (*l_599) = l_610[0];
                    if (__builtin_clzl(p_34))
                    { /* block id: 443 */
                        l_600[l_601.f1][(p_34 + 1)].f0 = (*p_33);
                        if ((*p_33))
                            break;
                    }
                    else
                    { /* block id: 446 */
                        int64_t l_625 = 0x0BB96BE44B78A24BLL;
                        (*l_604) = l_611;
                        if (l_601.f7)
                            continue;
                        (*p_33) = (((int16_t)((*p_33) < (((int16_t)((uint64_t)((int32_t)0L % (int32_t)__builtin_bswap64(p_32)) + (uint64_t)0xC93F723C941BCD8BLL) / (int16_t)p_34) >= (((uint16_t)((uint16_t)9UL << (uint16_t)4) + (uint16_t)(func_86(p_35, p_33) >= p_35)) == l_624))) << (int16_t)p_34) == l_625);
                    }
                    p_33 = p_33;
                    l_626 = func_46(p_33, func_93(l_601));
                }
                return p_33;
                /* statement id: 454 */
                //assert (func_30_rv == &l_41);
            }
        }
    }
    (*l_627) = p_33;
    /* statement id: 458 */
    //assert (l_485 == &l_41);
    return p_33;
    /* statement id: 459 */
    //assert (func_30_rv == &l_41);
}


/* ------------------------------------------ */
/* 
 * reads : l_41
 * writes: l_41
 */
static struct S0  func_46(int32_t * p_47, int32_t * p_48)
{ /* block id: 307 */
    int16_t l_486 = 0xCB5FL;
    int32_t l_524 = 0xBD29D54AL;
    int32_t *l_523 = &l_524;
    struct S0 l_536 = {1L,0xCFL,0x81192501L,1L,3,0x1598E2B06D622000LL,0x54BF2DDCL,531,116};
    struct S0 *l_538 = &l_536;
    struct S0 **l_537[1][2][8] = {{{&l_538,&l_538,&l_538,&l_538,&l_538,&l_538,&l_538,&l_538},{&l_538,&l_538,&l_538,&l_538,&l_538,&l_538,&l_538,&l_538}}};
    uint32_t l_547[1][9][6];
    struct S0 l_598 = {0x947D46E0L,0x80L,0xCAAE84D5L,6L,2,0x0365707230330809LL,0xED6EB20BL,135,53};
    int i, j, k;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 9; j++)
        {
            for (k = 0; k < 6; k++)
                l_547[i][j][k] = 0xB4AD4235L;
        }
    }
    if ((l_486 != ((!((uint32_t)l_486 - (uint32_t)((int16_t)(((0x99EC872CF7CFBFDBLL == l_486) > l_486) < 0L) >> (int16_t)0))) ^ l_486)))
    { /* block id: 308 */
        int32_t l_494 = 0x646DAC0EL;
        int32_t *l_493 = &l_494;
        int32_t **l_492 = &l_493;
        (*l_492) = p_48;
        /* statement id: 309 */
        assert (l_493 == 0);
    }
    else
    { /* block id: 310 */
        int32_t l_501 = (-3L);
        int32_t *l_500 = &l_501;
        int32_t **l_504[10][2][10] = {{{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0},{&l_500,(void*)0,(void*)0,(void*)0,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500}},{{&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500,(void*)0,&l_500,&l_500},{&l_500,(void*)0,&l_500,(void*)0,(void*)0,(void*)0,&l_500,&l_500,&l_500,&l_500}},{{&l_500,(void*)0,(void*)0,&l_500,(void*)0,&l_500,&l_500,(void*)0,&l_500,&l_500},{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500,&l_500,&l_500}},{{&l_500,&l_500,(void*)0,(void*)0,&l_500,&l_500,&l_500,(void*)0,(void*)0,&l_500},{&l_500,&l_500,&l_500,(void*)0,&l_500,(void*)0,&l_500,&l_500,(void*)0,(void*)0}},{{&l_500,&l_500,&l_500,(void*)0,&l_500,(void*)0,&l_500,(void*)0,&l_500,&l_500},{&l_500,&l_500,&l_500,(void*)0,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500}},{{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500,&l_500},{&l_500,&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500}},{{&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0,(void*)0,(void*)0,&l_500,&l_500},{&l_500,&l_500,&l_500,(void*)0,&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500}},{{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500},{&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500}},{{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500},{(void*)0,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500}},{{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0},{&l_500,&l_500,&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500}}};
        int32_t ***l_503 = &l_504[3][1][2];
        struct S0 l_505 = {0x06B94084L,0UL,0x75D1EF86L,2L,1,0L,0x9DC16A3EL,660,6};
        struct S0 *l_518 = &l_505;
        struct S0 **l_533 = &l_518;
        struct S0 ***l_532 = &l_533;
        int32_t l_582[9][9] = {{(-2L),0x91D2207AL,0xD7300A49L,0x9D1439ACL,1L,0x611E914FL,0x9D1439ACL,(-1L),0x56CE36EBL},{0xD95A8A8EL,(-1L),(-2L),(-2L),(-1L),1L,1L,(-1L),(-1L)},{0xD95A8A8EL,(-1L),(-1L),1L,0x9D1439ACL,(-2L),4L,4L,(-2L)},{(-2L),(-1L),(-1L),(-1L),(-2L),(-1L),(-1L),1L,1L},{(-1L),0x91D2207AL,(-2L),1L,(-2L),0x56CE36EBL,(-1L),0x9D1439ACL,0x611E914FL},{4L,1L,0xD7300A49L,(-2L),0x9D1439ACL,(-1L),(-1L),1L,0x956EA87BL},{0x91D2207AL,(-2L),0x956EA87BL,0x9D1439ACL,(-1L),(-2L),(-1L),0x9D1439ACL,0x956EA87BL},{(-1L),(-1L),0x56CE36EBL,0xD95A8A8EL,1L,1L,4L,1L,0x611E914FL},{0x91D2207AL,(-1L),(-9L),0x91D2207AL,0xD95A8A8EL,0x611E914FL,1L,4L,1L}};
        int i, j, k;
        for (l_486 = 0; (l_486 <= (-14)); l_486 -= 4)
        { /* block id: 313 */
            int16_t l_502[7][3][8] = {{{(-1L),(-1L),3L,0x84B7L,0x8C25L,(-1L),(-1L),0x8C25L},{0L,0x8C25L,0xE8BFL,0L,7L,0L,0xE8BFL,0x8C25L},{0x8C25L,1L,0L,0x84B7L,1L,0xE8BFL,7L,0L}},{{0x634EL,7L,7L,0x8C25L,0x8C25L,7L,7L,0x634EL},{(-3L),0x8C25L,0L,0xE8BFL,(-1L),(-3L),0xE8BFL,0x84B7L},{(-1L),(-3L),0xE8BFL,0x84B7L,0xE8BFL,(-3L),(-1L),0xE8BFL}},{{0x634EL,0x8C25L,3L,0x634EL,7L,7L,0x8C25L,0x8C25L},{0xE8BFL,7L,0L,0L,7L,0xE8BFL,1L,0x84B7L},{0x634EL,1L,0L,0x8C25L,0xE8BFL,0L,7L,0L}},{{(-1L),0x8C25L,(-7L),0x8C25L,(-1L),(-1L),0x8C25L,0x84B7L},{(-3L),(-1L),0xE8BFL,0L,0x8C25L,(-3L),(-3L),0x8C25L},{0x634EL,7L,7L,0L,(-1L),(-7L),0L,7L}},{{0L,(-3L),7L,1L,(-3L),0x634EL,(-3L),1L},{(-7L),(-3L),(-7L),7L,0L,(-7L),(-1L),0L},{0xE8BFL,7L,0x2C30L,0L,3L,3L,0L,0x2C30L}},{{0xE8BFL,0xE8BFL,0x634EL,1L,0L,0x8C25L,0xE8BFL,0L},{(-7L),0L,7L,(-7L),(-3L),(-7L),7L,0L},{0L,(-1L),0x2C30L,1L,(-1L),7L,(-3L),0x2C30L}},{{0L,(-3L),0x84B7L,0L,0L,0x84B7L,(-3L),0L},{3L,0L,0x2C30L,7L,0xE8BFL,3L,7L,1L},{0xE8BFL,3L,7L,1L,7L,3L,0xE8BFL,7L}}};
            struct S0 *l_516[8] = {&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505};
            struct S0 **l_515[4] = {&l_516[1],&l_516[1],&l_516[1],&l_516[1]};
            struct S0 ***l_514 = &l_515[3];
            int i, j, k;
            if ((((uint64_t)(!((void*)0 == l_500)) / (uint64_t)l_486) < ((l_486 < l_502[1][2][7]) ^ (l_503 == &l_504[9][0][1]))))
            { /* block id: 314 */
                if (l_502[6][1][2])
                { /* block id: 315 */
                    struct S0 *l_506 = (void*)0;
                    struct S0 *l_507[6];
                    int i;
                    for (i = 0; i < 6; i++)
                        l_507[i] = &l_505;
                    l_505 = l_505;
                    for (l_505.f0 = (-15); (l_505.f0 != 13); l_505.f0++)
                    { /* block id: 319 */
                        if (l_486)
                            break;
                    }
                }
                else
                { /* block id: 322 */
                    struct S0 l_510 = {0x1E461C94L,254UL,4294967287UL,3L,0,1L,0x24CA3CA8L,74,115};
                    return l_510;
                }
            }
            else
            { /* block id: 325 */
                int64_t l_512 = 0x88064B3E79E45040LL;
                int32_t *l_513 = &l_501;
                struct S0 l_527 = {-8L,255UL,0xC60A059FL,-1L,1,0xC62B32FD3F6AA859LL,-1L,459,31};
                if ((-(uint32_t)l_512))
                { /* block id: 326 */
                    struct S0 ****l_517 = &l_514;
                    p_48 = l_513;
                    /* statement id: 327 */
                    assert (p_48 == &l_501);
                    if (l_502[1][2][7])
                        continue;
                    (*l_517) = l_514;
                    for (l_505.f3 = 0; l_505.f3 < 4; l_505.f3 += 1)
                    {
                        l_515[l_505.f3] = &l_518;
                    }
                    //assert (l_515[0] == &l_518 || (l_515[0] >= &l_516[0] && l_515[0] <= &l_516[7]) || l_515[0] == 0);
                }
                else
                { /* block id: 331 */
                    struct S0 ****l_525 = (void*)0;
                    if (((~l_502[1][2][7]) || ((0xB450L <= (0x65B01A7FL || ((*l_513) != (*l_513)))) == ((uint16_t)0x3733L << (uint16_t)0))))
                    { /* block id: 332 */
                        int32_t *l_522 = &l_505.f0;
                        p_48 = l_522;
                        /* statement id: 333 */
                        assert (p_48 == &l_505.f0);
                    }
                    else
                    { /* block id: 334 */
                        struct S0 *****l_526 = &l_525;
                        l_523 = p_47;
                        /* statement id: 335 */
                        //assert (l_523 == &l_52 || l_523 == &l_41);
                        (*l_526) = l_525;
                    }
                    /* facts after branching */
                    assert (p_48 == &l_501 || p_48 == 0 || p_48 == &l_505.f0);
                    //assert (l_523 == &l_52 || l_523 == &l_524 || l_523 == &l_41);
                    return l_527;
                }
                /* facts after branching */
                assert (p_48 == &l_501);
                //assert (l_515[0] == &l_518 || (l_515[0] >= &l_516[0] && l_515[0] <= &l_516[7]) || l_515[0] == 0);
                for (l_527.f0 = 0; (l_527.f0 <= 3); l_527.f0 += 1)
                { /* block id: 342 */
                    int64_t l_534[10][10][2] = {{{4L,0x0515BC77D33AFD4CLL},{0x7D9AE1EF33258146LL,5L},{(-1L),0L},{4L,0L},{0L,0xCC63F308271C9458LL},{(-9L),1L},{0x54A7FEDD1781A2C8LL,(-1L)},{(-8L),(-1L)},{3L,0x7F1105FF6A7CA8ECLL},{0L,(-1L)}},{{0x2ADD07DE999B76A7LL,5L},{0L,(-1L)},{(-1L),0x21CB21747D367885LL},{0x4C0A0851C7AA1577LL,0x21CB21747D367885LL},{(-1L),(-1L)},{0L,5L},{0x2ADD07DE999B76A7LL,(-1L)},{0L,0x7F1105FF6A7CA8ECLL},{3L,(-1L)},{(-8L),(-1L)}},{{0x54A7FEDD1781A2C8LL,1L},{(-9L),0xCC63F308271C9458LL},{0L,0L},{4L,0L},{(-1L),5L},{0x7D9AE1EF33258146LL,0x0515BC77D33AFD4CLL},{4L,(-1L)},{0x0515BC77D33AFD4CLL,0xCC63F308271C9458LL},{(-10L),0L},{0x54A7FEDD1781A2C8LL,(-8L)}},{{(-1L),(-1L)},{(-1L),3L},{0L,0x7D9AE1EF33258146LL},{0L,5L},{1L,0x5D82A794E77618C1LL},{(-1L),0L},{5L,0x21CB21747D367885LL},{0x38588B50552F21D3LL,0x5D82A794E77618C1LL},{0L,0x4C0A0851C7AA1577LL},{0L,(-1L)}},{{0xDB6751E6E577B36FLL,3L},{3L,0x38588B50552F21D3LL},{(-1L),(-1L)},{0xA1689FA06F48A93DLL,0L},{(-9L),1L},{0x0515BC77D33AFD4CLL,0L},{0x1E9C7087AEA02C45LL,0x0515BC77D33AFD4CLL},{(-1L),0xF56F0EE09E703182LL},{(-1L),0x0515BC77D33AFD4CLL},{0x1E9C7087AEA02C45LL,0L}},{{0x2ADD07DE999B76A7LL,0x4C5289B28D741ABFLL},{(-1L),0x38588B50552F21D3LL},{(-9L),0xFF3E48AEC0CA3845LL},{0xFF3E48AEC0CA3845LL,0x152F62680E869EB9LL},{0x0C21575A922C9906LL,0xF56F0EE09E703182LL},{0x83002A9CEC29815FLL,0xA1689FA06F48A93DLL},{0x7D9AE1EF33258146LL,1L},{0x38588B50552F21D3LL,0xDB6751E6E577B36FLL},{0x152F62680E869EB9LL,0x7F1105FF6A7CA8ECLL},{1L,0x474502B8F4B44E84LL}},{{0x8519B97B3AF6EA48LL,0xDB6751E6E577B36FLL},{0x2F7CD7A0C9CC59AELL,1L},{0x7D9AE1EF33258146LL,0x714DF50196CCCDC0LL},{(-8L),0xF56F0EE09E703182LL},{0x2F56DDEC077EBAD1LL,0x8519B97B3AF6EA48LL},{0xFF3E48AEC0CA3845LL,(-1L)},{0x4C0A0851C7AA1577LL,0x38588B50552F21D3LL},{(-1L),0L},{0x2ADD07DE999B76A7LL,0xA19B8762EF2367A9LL},{(-1L),0x2ADD07DE999B76A7LL}},{{0x714DF50196CCCDC0LL,0x1E9C7087AEA02C45LL},{0xA1689FA06F48A93DLL,0xF03871125067DC0ELL},{(-1L),0L},{0xF03871125067DC0ELL,0L},{(-1L),0x2F7CD7A0C9CC59AELL},{0x4C0A0851C7AA1577LL,0xFF3E48AEC0CA3845LL},{(-1L),0x8519B97B3AF6EA48LL},{0x0C21575A922C9906LL,1L},{(-8L),0xA1689FA06F48A93DLL},{2L,1L}},{{0x38588B50552F21D3LL,(-1L)},{0x8519B97B3AF6EA48LL,0x7F1105FF6A7CA8ECLL},{1L,0x7F1105FF6A7CA8ECLL},{0x8519B97B3AF6EA48LL,(-1L)},{0x38588B50552F21D3LL,1L},{2L,0xA1689FA06F48A93DLL},{(-8L),1L},{0x0C21575A922C9906LL,0x8519B97B3AF6EA48LL},{(-1L),0xFF3E48AEC0CA3845LL},{0x4C0A0851C7AA1577LL,0x2F7CD7A0C9CC59AELL}},{{(-1L),0L},{0xF03871125067DC0ELL,0L},{(-1L),0xF03871125067DC0ELL},{0xA1689FA06F48A93DLL,0x1E9C7087AEA02C45LL},{0x714DF50196CCCDC0LL,0x2ADD07DE999B76A7LL},{(-1L),0xA19B8762EF2367A9LL},{0x2ADD07DE999B76A7LL,0L},{(-1L),0x38588B50552F21D3LL},{0x4C0A0851C7AA1577LL,(-1L)},{0xFF3E48AEC0CA3845LL,0x8519B97B3AF6EA48LL}}};
                    struct S0 l_535[9] = {{0x4617245DL,9UL,0xDDA70958L,0x1E99L,4,0x92BEB2506BE9C097LL,0L,509,71},{9L,4UL,7UL,0x399BL,4,-3L,1L,189,93},{0x4617245DL,9UL,0xDDA70958L,0x1E99L,4,0x92BEB2506BE9C097LL,0L,509,71},{9L,4UL,7UL,0x399BL,4,-3L,1L,189,93},{0x4617245DL,9UL,0xDDA70958L,0x1E99L,4,0x92BEB2506BE9C097LL,0L,509,71},{9L,4UL,7UL,0x399BL,4,-3L,1L,189,93},{0x4617245DL,9UL,0xDDA70958L,0x1E99L,4,0x92BEB2506BE9C097LL,0L,509,71},{9L,4UL,7UL,0x399BL,4,-3L,1L,189,93},{0x4617245DL,9UL,0xDDA70958L,0x1E99L,4,0x92BEB2506BE9C097LL,0L,509,71}};
                    int i, j, k;
                    if (((((uint16_t)__builtin_popcountl((*l_523)) >> (uint16_t)7) < ((uint16_t)0xCDB5L >> (uint16_t)2)) && func_63(p_47, (*l_513), ((void*)0 != l_532), func_63(p_47, (*l_523), l_502[2][1][2], l_534[7][4][1], (*l_523)), l_502[6][1][7])))
                    { /* block id: 343 */
                        return l_535[1];
                    }
                    else
                    { /* block id: 345 */
                        l_513 = p_47;
                        /* statement id: 346 */
                        //assert (l_513 == &l_52 || l_513 == &l_41);
                        if (l_535[1].f4)
                            break;
                        (*l_500) = ((&p_48 == &l_513) == 65533UL);
                        (*l_533) = &l_535[1];
                        /* statement id: 349 */
                        assert ((l_518 >= &l_535[0] && l_518 <= &l_535[8]));
                    }
                    /* facts after branching */
                    //assert (l_513 == &l_52 || l_513 == &l_41);
                    assert ((l_518 >= &l_535[0] && l_518 <= &l_535[8]));
                    (***l_532) = l_536;
                    for (l_512 = 0; (l_512 <= 2); l_512 += 1)
                    { /* block id: 354 */
                        int i, j, k;
                        (*p_48) = (l_502[(l_527.f0 + 2)][l_512][l_512] && l_502[(l_527.f0 + 2)][l_512][(l_512 + 1)]);
                        (**l_533) = l_527;
                        (*l_500) = (l_502[1][0][0] | ((void*)0 == p_47));
                    }
                }
                /* facts after for loop */
                //assert (l_513 == &l_52 || l_513 == &l_501 || l_513 == &l_41);
                if ((*l_513))
                    continue;
            }
            /* facts after branching */
            //assert (l_515[0] == &l_518 || (l_515[0] >= &l_516[0] && l_515[0] <= &l_516[7]) || l_515[0] == 0);
        }
        /* facts after for loop */
        assert (p_48 == &l_501 || p_48 == 0);
        //assert (l_518 == dangling || l_518 == &l_505);
        (*l_532) = l_537[0][0][6];
        /* statement id: 363 */
        assert (l_533 == &l_538);
lbl_560:
        (*l_523) = (*p_47);
        for (l_536.f6 = 0; (l_536.f6 != 18); l_536.f6 += 6)
        { /* block id: 367 */
            int32_t l_557 = 0x8041A340L;
            int32_t *l_576 = &l_501;
            int32_t *l_594 = (void*)0;
            struct S0 l_597 = {0xD3E2EB77L,0x86L,4UL,-3L,0,0x4F0161AB48150AE8LL,0L,582,108};
            if ((*p_47))
            { /* block id: 368 */
                int32_t ****l_541[10][7] = {{&l_503,&l_503,&l_503,&l_503,&l_503,&l_503,&l_503},{&l_503,&l_503,(void*)0,&l_503,&l_503,(void*)0,&l_503},{&l_503,&l_503,&l_503,&l_503,&l_503,&l_503,&l_503},{&l_503,(void*)0,&l_503,&l_503,&l_503,&l_503,&l_503},{&l_503,&l_503,&l_503,&l_503,&l_503,(void*)0,&l_503},{&l_503,&l_503,(void*)0,&l_503,&l_503,(void*)0,&l_503},{&l_503,&l_503,(void*)0,(void*)0,&l_503,&l_503,&l_503},{&l_503,&l_503,(void*)0,&l_503,&l_503,&l_503,&l_503},{&l_503,&l_503,&l_503,&l_503,&l_503,&l_503,&l_503},{&l_503,&l_503,&l_503,&l_503,(void*)0,&l_503,&l_503}};
                int32_t *****l_542 = &l_541[7][3];
                int i, j;
                (*l_542) = l_541[5][5];
                for (l_505.f1 = (-14); (l_505.f1 >= 53); l_505.f1 += 3)
                { /* block id: 372 */
                    struct S0 l_545 = {-4L,0x2DL,0xE5419767L,0xAAB5L,1,8L,0x4ABFF246L,129,119};
                    for (l_505.f0 = 0; (l_505.f0 <= 6); l_505.f0 += 1)
                    { /* block id: 375 */
                        return l_545;
                    }
                }
                for (l_505.f0 = 0; (l_505.f0 <= 0); l_505.f0 += 1)
                { /* block id: 381 */
                    uint64_t l_559 = 5UL;
                    if ((0L || 0xD66CL))
                    { /* block id: 382 */
                        uint64_t l_546 = 5UL;
                        (*p_47) = (l_546 == (((l_547[0][5][1] || ((((int16_t)((int64_t)(((int16_t)(-(int32_t)0x1CECA72EL) << (int16_t)2) <= ((&l_504[5][0][1] != &l_504[9][1][7]) && (((int64_t)l_557 + (int64_t)(*l_523)) || (~l_546)))) - (int64_t)l_546) >> (int16_t)(*l_500)) && l_546) <= 65526UL)) && 0L) == l_559));
                        (*p_47) = 0x51E72DBEL;
                    }
                    else
                    { /* block id: 385 */
                        uint64_t l_563 = 1UL;
                        if (l_536.f0)
                            goto lbl_560;
                        p_47 = func_89((((*l_523) > ((uint16_t)l_563 << (uint16_t)8)) ^ ((int64_t)func_63(p_47, l_559, l_557, (!(((!l_557) || 0x451E212AL) && (l_563 <= (((int32_t)((int16_t)((uint64_t)l_557 - (uint64_t)0xDEE4480774A50C4CLL) + (int16_t)0L) - (int32_t)l_559) >= l_563)))), (*l_523)) / (int64_t)7UL)), l_576, l_576);
                        /* statement id: 387 */
                        assert (p_47 == &l_501);
                    }
                    l_582[6][7] = ((l_559 || (((*l_576) == l_559) == ((*l_576) && (*l_500)))) && (!((uint64_t)(*l_576) - (uint64_t)((*l_503) == &p_47))));
                    for (l_524 = 0; (l_524 >= 0); l_524 -= 1)
                    { /* block id: 392 */
                        if ((*l_523))
                            break;
                    }
                }
                if ((*p_47))
                    continue;
            }
            else
            { /* block id: 397 */
                uint64_t l_584 = 18446744073709551614UL;
                struct S0 ***l_595 = (void*)0;
                struct S0 ****l_596 = &l_532;
                for (l_536.f0 = 2; (l_536.f0 <= 8); l_536.f0 += 1)
                { /* block id: 400 */
                    int32_t ***l_583[1][1];
                    int i, j;
                    for (i = 0; i < 1; i++)
                    {
                        for (j = 0; j < 1; j++)
                            l_583[i][j] = &l_504[1][0][5];
                    }
                    l_582[l_536.f0][l_536.f0] = ((void*)0 == l_583[0][0]);
                    (*l_576) = (((void*)0 != &l_582[l_536.f0][l_536.f0]) ^ l_584);
                    for (l_505.f6 = 0; (l_505.f6 <= 0); l_505.f6 += 1)
                    { /* block id: 405 */
                        int i, j, k;
                        (*l_576) = l_547[l_505.f6][l_536.f0][(l_505.f6 + 2)];
                    }
                }
                if (l_584)
                    break;
                p_47 = func_89((*l_523), l_576, l_576);
                /* statement id: 410 */
                assert (p_47 == &l_501);
                (*l_596) = l_595;
                /* statement id: 411 */
                assert (l_532 == 0);
            }
            if ((*p_47))
                continue;
            if ((*p_47))
                break;
            l_597 = l_597;
        }
    }
    /* facts after branching */
    //assert (p_47 == dangling || p_47 == &l_52 || p_47 == &l_41);
    //assert (p_48 == dangling || p_48 == 0);
    (*l_523) = (*l_523);
    return l_598;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_49(uint16_t  p_50, int32_t * p_51)
{ /* block id: 38 */
    int64_t l_53 = 0x05618D7C584EDB55LL;
    int32_t *l_72 = (void*)0;
    struct S0 ****l_474 = (void*)0;
    struct S0 *****l_473 = &l_474;
    struct S0 l_482[3] = {{0x8962ACFEL,0xA8L,0xDF4B1FA8L,0xB8F6L,3,-1L,4L,97,28},{0x8962ACFEL,0xA8L,0xDF4B1FA8L,0xB8F6L,3,-1L,4L,97,28},{0x8962ACFEL,0xA8L,0xDF4B1FA8L,0xB8F6L,3,-1L,4L,97,28}};
    struct S0 *l_483 = &l_482[0];
    int i;
    if (__builtin_bswap64(l_53))
    { /* block id: 39 */
        int64_t l_60 = 2L;
        int32_t *l_69 = (void*)0;
        int32_t **l_466[5][3] = {{&l_69,&l_72,&l_69},{&l_72,&l_72,&l_72},{&l_69,&l_72,&l_69},{&l_72,&l_72,&l_72},{&l_69,&l_72,&l_69}};
        int i, j;
        (*p_51) = ((int16_t)((uint64_t)(((int64_t)p_50 % (int64_t)l_60) ^ ((int16_t)p_50 >> (int16_t)func_63(l_69, p_50, ((*p_51) | ((uint32_t)(l_72 == p_51) / (uint32_t)((!((!((void*)0 == l_69)) && l_53)) || (*p_51)))), p_50, p_50))) / (uint64_t)p_50) >> (int16_t)15);
        l_72 = p_51;
        /* statement id: 287 */
        //assert (l_72 == &l_52);
        (*l_72) = ((uint64_t)(*l_72) + (uint64_t)((int16_t)(*l_72) + (int16_t)((uint16_t)p_50 >> (uint16_t)2)));
        p_51 = p_51;
    }
    else
    { /* block id: 290 */
        uint16_t l_475 = 65527UL;
        uint32_t l_476 = 18446744073709551615UL;
        (*p_51) = func_63(func_83(((l_473 == &l_474) == func_63(l_72, p_50, p_50, __builtin_ctzl(p_50), l_475)), p_51), l_476, p_50, p_50, p_50);
        return p_51;
        /* statement id: 292 */
        //assert (func_49_rv == &l_52);
    }
    /* facts after branching */
    //assert (l_72 == &l_52);
    for (l_53 = 14; (l_53 == 21); l_53 += 1)
    { /* block id: 296 */
        int32_t l_480 = 0L;
        int32_t *l_479 = &l_480;
        int32_t **l_481 = (void*)0;
        p_51 = l_479;
        /* statement id: 297 */
        assert (p_51 == &l_480);
    }
    /* facts after for loop */
    //assert (p_51 == dangling || p_51 == &l_52);
    (*l_483) = l_482[0];
    for (l_53 = 0; (l_53 <= 2); l_53 += 1)
    { /* block id: 302 */
        int32_t *l_484[1];
        int i;
        for (i = 0; i < 1; i++)
            l_484[i] = &l_482[0].f0;
        l_482[l_53] = l_482[l_53];
        l_484[0] = l_72;
        /* statement id: 304 */
        //assert (l_484[0] == &l_52 || (l_484[0] >= &l_482[0].f0 && l_484[0] <= &l_482[2].f0));
    }
    return l_72;
    /* statement id: 306 */
    //assert (func_49_rv == &l_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_63(int32_t * p_64, uint16_t  p_65, int16_t  p_66, uint32_t  p_67, uint32_t  p_68)
{ /* block id: 40 */
    int32_t l_76 = 0x86225270L;
    int32_t *l_75 = &l_76;
    struct S0 l_137 = {0xE4515CB4L,0xB8L,0x489E7F0AL,0xD097L,3,-10L,0x11020B4DL,593,127};
    int32_t **l_370 = &l_75;
    int32_t ***l_369[4] = {&l_370,&l_370,&l_370,&l_370};
    int32_t ****l_368[9] = {&l_369[3],&l_369[3],&l_369[3],&l_369[3],&l_369[3],&l_369[3],&l_369[3],&l_369[3],&l_369[3]};
    int32_t *****l_396[4];
    struct S0 *l_433 = &l_137;
    struct S0 **l_432 = &l_433;
    struct S0 ***l_431 = &l_432;
    struct S0 ****l_430 = &l_431;
    int32_t *l_464 = &l_76;
    uint64_t l_465[9][6] = {{0xE273E507135FE190LL,0xD1E963A6868F39C9LL,0x300DDB63E37F816BLL,6UL,0x300DDB63E37F816BLL,0xD1E963A6868F39C9LL},{0x300DDB63E37F816BLL,0xE273E507135FE190LL,0UL,18446744073709551609UL,18446744073709551609UL,0UL},{0x300DDB63E37F816BLL,0x300DDB63E37F816BLL,18446744073709551609UL,6UL,18446744073709551615UL,6UL},{0xE273E507135FE190LL,0x300DDB63E37F816BLL,0xE273E507135FE190LL,0UL,18446744073709551609UL,18446744073709551609UL},{0xD1E963A6868F39C9LL,0xE273E507135FE190LL,0xE273E507135FE190LL,0xD1E963A6868F39C9LL,0x300DDB63E37F816BLL,6UL},{6UL,0xD1E963A6868F39C9LL,18446744073709551609UL,0xD1E963A6868F39C9LL,6UL,0UL},{0xD1E963A6868F39C9LL,6UL,0UL,0UL,6UL,0xD1E963A6868F39C9LL},{0xE273E507135FE190LL,0xD1E963A6868F39C9LL,0x300DDB63E37F816BLL,6UL,0x300DDB63E37F816BLL,0xD1E963A6868F39C9LL},{0x300DDB63E37F816BLL,0xE273E507135FE190LL,0UL,18446744073709551609UL,18446744073709551609UL,0UL}};
    int i, j;
    for (i = 0; i < 4; i++)
        l_396[i] = &l_368[0];
lbl_400:
    l_75 = l_75;
    for (p_67 = 21; (p_67 < 16); p_67 -= 6)
    { /* block id: 44 */
        int32_t l_79 = 0x28784865L;
        int32_t ***l_327[1];
        int32_t ****l_326 = &l_327[0];
        uint16_t l_447[9] = {65531UL,0xA9BFL,65531UL,0xA9BFL,65531UL,0xA9BFL,65531UL,0xA9BFL,65531UL};
        struct S0 **l_448 = &l_433;
        int i;
        for (i = 0; i < 1; i++)
            l_327[i] = (void*)0;
        if (l_79)
        { /* block id: 45 */
            struct S0 l_95 = {-3L,0xBFL,0x8EAF5359L,0L,3,0x915D48947DE68BD5LL,0x5709715BL,643,77};
            int32_t **l_321 = (void*)0;
            int32_t **l_322[4][9];
            struct S0 *l_323 = (void*)0;
            struct S0 *l_324 = (void*)0;
            struct S0 *l_325 = &l_95;
            int i, j;
            for (i = 0; i < 4; i++)
            {
                for (j = 0; j < 9; j++)
                    l_322[i][j] = (void*)0;
            }
            p_64 = func_80(func_83(func_86(l_79, func_89(p_66, func_93(l_95), func_93(l_137))), &l_76), p_66);
            /* statement id: 210 */
            assert (p_64 == &l_76);
            if ((*l_75))
                continue;
            (*l_325) = l_137;
        }
        else
        { /* block id: 213 */
            struct S0 l_332 = {0x61A39073L,0UL,0x7A70FA91L,0x836BL,0,0x9FC1B61811629752LL,-6L,405,57};
            int32_t l_356 = 0x59CEDBF0L;
            uint32_t l_357 = 0x937039E1L;
            int32_t *l_363 = &l_332.f0;
            int64_t l_374[9] = {(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)};
            int32_t *l_393 = &l_76;
            struct S0 *l_418 = &l_332;
            struct S0 **l_417 = &l_418;
            struct S0 ***l_428 = &l_417;
            struct S0 ****l_427 = &l_428;
            struct S0 *****l_426 = &l_427;
            uint8_t l_434 = 0x79L;
            int i;
            if (__builtin_bswap64(__builtin_ffsl((l_326 == &l_327[0]))))
            { /* block id: 214 */
                int32_t *l_338 = &l_76;
                for (l_137.f1 = 0; (l_137.f1 == 43); l_137.f1 += 5)
                { /* block id: 217 */
                    struct S0 l_331 = {5L,253UL,0x35E3FC06L,2L,2,-10L,7L,720,55};
                    struct S0 *l_330 = &l_331;
                    (*l_330) = l_137;
                }
                p_64 = func_93(l_332);
                /* statement id: 220 */
                assert (p_64 == 0);
                for (l_332.f5 = 26; (l_332.f5 <= 29); l_332.f5 += 1)
                { /* block id: 223 */
                    uint16_t l_358 = 0x4903L;
                    p_64 = &l_76;
                    /* statement id: 224 */
                    assert (p_64 == &l_76);
                    for (p_66 = 0; (p_66 == 24); p_66++)
                    { /* block id: 227 */
                        int32_t *l_337 = &l_76;
                        struct S0 *l_352 = &l_137;
                        struct S0 **l_351 = &l_352;
                        struct S0 ***l_350 = &l_351;
                        l_338 = l_337;
                        if ((*p_64))
                            continue;
                        (*p_64) = ((uint16_t)(((int16_t)((*p_64) && (((uint64_t)((-(uint32_t)((((((int16_t)(*l_337) >> (int16_t)7) || 5L) == ((((uint16_t)((*l_75) && ((void*)0 == l_350)) >> (uint16_t)((*l_338) > ((uint16_t)(-(uint64_t)(*l_337)) / (uint16_t)p_68))) > p_67) & l_356)) ^ 65533UL) < l_357)) | p_67) - (uint64_t)p_67) || p_65)) << (int16_t)7) < l_358) << (uint16_t)p_67);
                    }
                }
                /* facts after for loop */
                assert (p_64 == &l_76 || p_64 == 0);
            }
            else
            { /* block id: 233 */
                struct S0 *l_359 = &l_137;
                int32_t l_362 = 0x76B3C505L;
                int32_t *l_371 = (void*)0;
                struct S0 ****l_378 = (void*)0;
                int16_t l_397 = 0x792EL;
                (*l_359) = l_332;
                if ((((int16_t)0xECB2L % (int16_t)func_86((*l_75), p_64)) == l_362))
                { /* block id: 235 */
                    p_64 = &l_76;
                    /* statement id: 236 */
                    assert (p_64 == &l_76);
                    l_363 = (void*)0;
                    /* statement id: 237 */
                    assert (l_363 == 0);
                    for (l_137.f1 = 22; (l_137.f1 <= 30); l_137.f1 += 8)
                    { /* block id: 240 */
                        (*p_64) = (__builtin_bswap32((l_362 & ((uint16_t)((void*)0 != l_368[0]) - (uint16_t)p_68))) > (**l_370));
                        if ((*p_64))
                            break;
                    }
                    l_371 = &l_362;
                    /* statement id: 244 */
                    assert (l_371 == &l_362);
                }
                else
                { /* block id: 245 */
                    for (l_137.f2 = 0; (l_137.f2 > 59); l_137.f2 += 3)
                    { /* block id: 248 */
                        int32_t l_375 = 0x3E69EFEEL;
                        (**l_370) = (((l_374[7] || ((l_375 ^ ((uint64_t)(p_67 != p_68) + (uint64_t)__builtin_parityl(p_65))) < ((void*)0 == l_378))) <= (__builtin_clz(p_66) >= p_65)) >= p_68);
                        (*l_370) = p_64;
                        /* statement id: 250 */
                        //assert (l_75 == &l_76 || l_75 == 0 || l_75 == &l_52 || l_75 == &l_501 || l_75 == &l_41);
                        return p_67;
                    }
                }
                /* facts after branching */
                assert (l_363 == &l_332.f0 || l_363 == 0);
                assert (l_371 == 0 || l_371 == &l_362);
                if ((-(int32_t)((((((!((uint64_t)((uint16_t)(((int16_t)((int16_t)((int32_t)((uint16_t)(func_86(p_65, l_393) || __builtin_ffsl(((-(int32_t)(((!p_65) || ((l_396[2] != &l_326) == 0L)) ^ p_65)) && 65534UL))) + (uint16_t)p_65) + (int32_t)0xBBFEBDD0L) >> (int16_t)11) << (int16_t)(*l_393)) >= l_362) / (uint16_t)8L) + (uint64_t)p_65)) | 0x2261DB9AL) && l_397) <= p_68) ^ 0x492D31B66011E23ALL) < 0xA5990F09L)))
                { /* block id: 254 */
                    struct S0 *l_419[5] = {&l_137,&l_137,&l_137,&l_137,&l_137};
                    int32_t l_429 = 0xD41A6D21L;
                    int i;
                    for (l_332.f2 = (-5); (l_332.f2 == 57); l_332.f2 += 7)
                    { /* block id: 257 */
                        int32_t *l_406[1];
                        uint32_t l_411 = 0UL;
                        int i;
                        for (i = 0; i < 1; i++)
                            l_406[i] = &l_137.f0;
                        if (l_137.f2)
                            goto lbl_400;
                        (*l_393) = ((uint32_t)((int64_t)((-(uint64_t)func_86(p_65, l_406[0])) >= 0UL) - (int64_t)(func_86(((uint16_t)((uint64_t)(l_411 ^ 0x91139D9AL) - (uint64_t)((uint32_t)p_68 - (uint32_t)(p_65 || p_65))) << (uint16_t)p_67), l_406[0]) != p_67)) / (uint32_t)p_65);
                        return p_66;
                    }
                    for (l_332.f3 = 1; (l_332.f3 <= 8); l_332.f3 += 1)
                    { /* block id: 264 */
                        struct S0 **l_416 = &l_359;
                        int i;
                    }
                    (*l_393) = (p_67 && (((l_430 == l_378) ^ (p_65 == l_434)) || ((int32_t)(*l_393) / (int32_t)(~p_66))));
                    for (l_332.f0 = 0; (l_332.f0 > 26); l_332.f0 += 8)
                    { /* block id: 273 */
                        l_362 = ((uint16_t)(((int64_t)((p_65 < (-(uint32_t)(p_66 == ((int16_t)p_65 >> (int16_t)9)))) || ((p_67 | 1UL) == (l_447[3] | (l_448 != l_448)))) + (int64_t)((uint64_t)func_86(func_86(p_67, &l_429), p_64) % (uint64_t)5L)) < p_67) << (uint16_t)8);
                    }
                }
                else
                { /* block id: 276 */
                    int64_t l_457 = 0x544F09820A1D9EA8LL;
                    struct S0 *l_463[9];
                    int i;
                    for (i = 0; i < 9; i++)
                        l_463[i] = &l_332;
                    (**l_370) = ((1L > ((uint32_t)((int16_t)(-3L) >> (int16_t)p_67) + (uint32_t)((uint32_t)l_457 % (uint32_t)(-(int16_t)func_86(p_65, p_64))))) == ((uint16_t)(((uint16_t)((l_463[7] != (*l_432)) && p_66) << (uint16_t)11) < (*l_393)) >> (uint16_t)p_66));
                    (****l_430) = (**l_448);
                }
            }
            /* facts after branching */
            assert (l_363 == &l_332.f0 || l_363 == 0);
        }
        p_64 = l_464;
        /* statement id: 282 */
        assert (p_64 == &l_76);
        return p_65;
    }
    return l_465[5][2];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_80(int32_t * p_81, int32_t  p_82)
{ /* block id: 192 */
    int64_t l_296 = 0L;
    uint32_t l_297 = 0x55DD7CDDL;
    int32_t l_299 = 0x7AFBABFCL;
    int32_t *l_298 = &l_299;
    int32_t l_302[9] = {0L,0L,0L,0L,0L,0L,0L,0L,0L};
    int32_t *****l_318 = (void*)0;
    int i;
    l_298 = func_89((((p_82 | (l_296 > l_297)) & (-7L)) >= l_296), p_81, func_89(l_296, l_298, func_83(__builtin_ffsl(p_82), &l_299)));
    (*p_81) = (p_82 ^ ((int32_t)(*l_298) / (int32_t)(*l_298)));
    (*l_298) = 0x7F9CA66AL;
    for (l_299 = 0; (l_299 <= 8); l_299 += 1)
    { /* block id: 198 */
        int32_t ****l_320 = (void*)0;
        int32_t *****l_319 = &l_320;
        int i;
        if (l_302[l_299])
            break;
        for (p_82 = 7; (p_82 >= 0); p_82 -= 1)
        { /* block id: 202 */
            struct S0 l_303 = {-1L,8UL,0xC3B42ED0L,0xAEB5L,2,-1L,1L,144,101};
            struct S0 *l_304 = (void*)0;
            int32_t **l_305 = &l_298;
            int i;
            l_303 = l_303;
            (*l_305) = &l_302[l_299];
            /* statement id: 204 */
            assert ((l_298 >= &l_302[0] && l_298 <= &l_302[8]));
        }
        if (l_302[l_299])
            break;
        l_302[l_299] = (((((((int16_t)((int16_t)(((int16_t)((*l_298) < ((uint64_t)((l_302[l_299] || (-3L)) ^ ((int32_t)(*p_81) + (int32_t)((uint16_t)0x2A02L >> (uint16_t)((1L == (func_86((*l_298), func_83((l_318 == l_319), p_81)) & 65529UL)) | (-1L))))) + (uint64_t)p_82)) << (int16_t)5) > 0xC7653ECA8A1A81AFLL) << (int16_t)1) << (int16_t)p_82) <= 1L) || 8L) || p_82) <= 1L) >= (*l_298));
    }
    /* facts after for loop */
    assert ((l_298 >= &l_302[0] && l_298 <= &l_302[8]) || l_298 == &l_299);
    return p_81;
    /* statement id: 209 */
    //assert (func_80_rv == &l_76);
}


/* ------------------------------------------ */
/* 
 * reads : l_76 l_52
 * writes:
 */
static int32_t * func_83(int32_t  p_84, int32_t * p_85)
{ /* block id: 188 */
    int32_t l_290 = 0L;
    int32_t *l_289 = &l_290;
    struct S0 l_292[10] = {{-1L,0x65L,0x5B507F08L,-1L,3,0L,0L,362,13},{-2L,1UL,0x93E933A9L,0x3DB2L,0,0x1B7860BB8B317F35LL,0xC7D61086L,527,108},{-1L,0x65L,0x5B507F08L,-1L,3,0L,0L,362,13},{-2L,1UL,0x93E933A9L,0x3DB2L,0,0x1B7860BB8B317F35LL,0xC7D61086L,527,108},{-1L,0x65L,0x5B507F08L,-1L,3,0L,0L,362,13},{-2L,1UL,0x93E933A9L,0x3DB2L,0,0x1B7860BB8B317F35LL,0xC7D61086L,527,108},{-1L,0x65L,0x5B507F08L,-1L,3,0L,0L,362,13},{-2L,1UL,0x93E933A9L,0x3DB2L,0,0x1B7860BB8B317F35LL,0xC7D61086L,527,108},{-1L,0x65L,0x5B507F08L,-1L,3,0L,0L,362,13},{-2L,1UL,0x93E933A9L,0x3DB2L,0,0x1B7860BB8B317F35LL,0xC7D61086L,527,108}};
    struct S0 *l_291 = &l_292[9];
    struct S0 **l_293 = &l_291;
    int i;
    (*l_289) = ((p_84 < ((int32_t)(*p_85) - (int32_t)(__builtin_popcount((func_86(p_84, l_289) | ((*l_289) & p_84))) != (0UL <= (*l_289))))) | 0x8913L);
    (*l_293) = l_291;
    return p_85;
    /* statement id: 191 */
    //assert (func_83_rv == &l_76 || func_83_rv == &l_299 || func_83_rv == &l_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_86(uint32_t  p_87, int32_t * p_88)
{ /* block id: 185 */
    struct S0 l_284 = {0x040179BDL,255UL,0x9029FDCDL,0xE3D4L,1,3L,0x420560C5L,142,126};
    int32_t *l_285 = &l_284.f0;
    int32_t **l_286 = &l_285;
    (*l_286) = func_89(p_87, func_93(l_284), func_89(__builtin_ctz(p_87), l_285, l_285));
    return p_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_89(int32_t  p_90, int32_t * p_91, int32_t * p_92)
{ /* block id: 80 */
    struct S0 l_138 = {0x0DCD5FEEL,0x2DL,4294967289UL,9L,1,-2L,1L,27,78};
    int32_t *l_140 = (void*)0;
    int32_t **l_139 = &l_140;
    struct S0 *l_224 = &l_138;
    struct S0 **l_223 = &l_224;
    struct S0 ***l_222 = &l_223;
    struct S0 ****l_221 = &l_222;
    (*l_139) = func_93(l_138);
    if (l_138.f4)
        goto lbl_141;
lbl_141:
    (*l_139) = (void*)0;
    p_91 = (*l_139);
    /* statement id: 84 */
    assert (p_91 == 0);
    for (l_138.f3 = 0; (l_138.f3 != 21); l_138.f3++)
    { /* block id: 87 */
        int16_t l_144[8][9][3] = {{{7L,0xB7AFL,0x49A4L},{1L,1L,3L},{(-1L),0xE65BL,0xFE17L},{0xFA69L,0xFE17L,0x4225L},{3L,0x82F6L,0xC5E2L},{1L,1L,0x3BE2L},{0L,0x2F96L,0x3BE2L},{0x3F16L,0L,0xC5E2L},{(-4L),0x0BF3L,0x4225L}},{{0x49A4L,0x9429L,0xFE17L},{0x911BL,(-1L),3L},{1L,5L,0x49A4L},{(-1L),0x858CL,0x858CL},{(-8L),0xD4D5L,(-1L)},{0xC5E2L,0x49A4L,1L},{0xE65BL,4L,0x0BF3L},{(-1L),0x7DDDL,5L},{(-1L),4L,0x5888L}},{{1L,0x49A4L,0xA813L},{9L,0xD4D5L,7L},{0x5888L,0x858CL,4L},{(-3L),5L,0x911BL},{5L,(-1L),(-8L)},{0x454CL,0x9429L,(-1L)},{0xD4D5L,0x0BF3L,3L},{0xAD67L,7L,(-8L)},{0x3F16L,(-1L),1L}},{{0x3F16L,0xE65BL,5L},{0xAD67L,(-1L),0xFA69L},{5L,0x7DDDL,(-1L)},{(-8L),0x4EC9L,0x2F96L},{0xC5E2L,0x60EDL,(-1L)},{0xFE17L,1L,0xAD67L},{9L,9L,0xB7AFL},{0xB7AFL,(-3L),8L},{(-1L),0xD4D5L,0x49A4L}},{{1L,0x6655L,0x0BF3L},{0x944CL,(-1L),0x49A4L},{0x4EC9L,0xC7EDL,8L},{7L,3L,0xB7AFL},{0x858CL,0x4225L,0xAD67L},{0x5444L,(-8L),(-1L)},{0xE65BL,0xAD67L,0x2F96L},{0x5888L,3L,(-1L)},{0x4F60L,0x944CL,0xFA69L}},{{(-1L),4L,5L},{0x911BL,1L,1L},{0xC7EDL,1L,(-8L)},{(-1L),4L,5L},{0x3BE2L,0x944CL,0L},{0L,3L,0x858CL},{8L,0xAD67L,0x5888L},{0L,(-8L),0x454CL},{0x6655L,0x4225L,0x6655L}},{{0x4225L,3L,0x82F6L},{(-1L),0xC7EDL,9L},{(-3L),(-1L),0xC5E2L},{(-1L),0x6655L,0x3F16L},{(-3L),0xD4D5L,1L},{(-1L),(-3L),0x5444L},{0x4225L,9L,(-1L)},{0x6655L,1L,0x4F60L},{0L,0x60EDL,0xA813L}},{{8L,0x4EC9L,0x7DDDL},{0L,0x7DDDL,3L},{0x3BE2L,(-1L),7L},{(-1L),0xE65BL,0x9429L},{0xC7EDL,(-1L),0x9429L},{0x911BL,7L,7L},{(-1L),0x3F16L,3L},{0x4F60L,(-8L),0x7DDDL},{0x5888L,0L,0xA813L}}};
        struct S0 ***l_155 = (void*)0;
        int32_t l_159 = (-10L);
        int32_t l_186[9][7][4] = {{{0xF2620083L,0xA83F5918L,0x92809C4DL,(-1L)},{5L,0x454160E1L,0xF0341802L,0xF0341802L},{0x677040BDL,0x677040BDL,(-1L),0x454160E1L},{0x454160E1L,5L,0x5AC8D5ACL,0x89876BB3L},{0xA83F5918L,0xF2620083L,0xF0341802L,0x5AC8D5ACL},{0x89876BB3L,0xF2620083L,0L,0x89876BB3L},{0xF2620083L,5L,0xA83F5918L,0x454160E1L}},{{0x92809C4DL,0x677040BDL,0x92809C4DL,0xF0341802L},{0x89876BB3L,0x454160E1L,(-5L),(-1L)},{0x677040BDL,0xA83F5918L,0x5AC8D5ACL,0x454160E1L},{(-1L),0x89876BB3L,0x5AC8D5ACL,5L},{0x677040BDL,0xF2620083L,(-5L),(-10L)},{0x89876BB3L,0x92809C4DL,0x625EF2E4L,0x92809C4DL},{0x625EF2E4L,0x92809C4DL,0x926D7F8DL,(-5L)}},{{(-1L),(-10L),0x454160E1L,0x5AC8D5ACL},{0x92809C4DL,(-5L),(-1L),0x5AC8D5ACL},{0x926D7F8DL,(-10L),0x52800829L,(-5L)},{0xF0341802L,0x92809C4DL,0x677040BDL,0x92809C4DL},{(-10L),0x625EF2E4L,(-1L),0xA83F5918L},{0L,(-1L),0x625EF2E4L,0L},{(-1L),0x92809C4DL,0L,0xF0341802L}},{{(-1L),0x926D7F8DL,0x625EF2E4L,0x5AC8D5ACL},{0L,0xF0341802L,(-1L),(-1L)},{(-10L),(-10L),0x677040BDL,0xF0341802L},{0xF0341802L,0L,0x52800829L,0x92809C4DL},{0x926D7F8DL,(-1L),(-1L),0x52800829L},{0x92809C4DL,(-1L),0x454160E1L,0x92809C4DL},{(-1L),0L,0x926D7F8DL,0xF0341802L}},{{0x625EF2E4L,(-10L),0x625EF2E4L,(-1L)},{0x92809C4DL,0xF0341802L,(-10L),0x5AC8D5ACL},{(-10L),0x926D7F8DL,0x52800829L,0xF0341802L},{(-5L),0x92809C4DL,0x52800829L,0L},{(-10L),(-1L),(-10L),0xA83F5918L},{0x92809C4DL,0x625EF2E4L,0x625EF2E4L,0x92809C4DL},{0x625EF2E4L,0x92809C4DL,0x926D7F8DL,(-5L)}},{{(-1L),(-10L),0x454160E1L,0x5AC8D5ACL},{0x92809C4DL,(-5L),(-1L),0x5AC8D5ACL},{0x926D7F8DL,(-10L),0x52800829L,(-5L)},{0xF0341802L,0x92809C4DL,0x677040BDL,0x92809C4DL},{(-10L),0x625EF2E4L,(-1L),0xA83F5918L},{0L,(-1L),0x625EF2E4L,0L},{(-1L),0x92809C4DL,0L,0xF0341802L}},{{(-1L),0x926D7F8DL,0x625EF2E4L,0x5AC8D5ACL},{0L,0xF0341802L,(-1L),(-1L)},{(-10L),(-10L),0x677040BDL,0xF0341802L},{0xF0341802L,0L,0x52800829L,0x92809C4DL},{0x926D7F8DL,(-1L),(-1L),0x52800829L},{0x92809C4DL,(-1L),0x454160E1L,0x92809C4DL},{(-1L),0L,0x926D7F8DL,0xF0341802L}},{{0x625EF2E4L,(-10L),0x625EF2E4L,(-1L)},{0x92809C4DL,0xF0341802L,(-10L),0x5AC8D5ACL},{(-10L),0x926D7F8DL,0x52800829L,0xF0341802L},{(-5L),0x92809C4DL,0x52800829L,0L},{(-10L),(-1L),(-10L),0xA83F5918L},{0x92809C4DL,0x625EF2E4L,0x625EF2E4L,0x92809C4DL},{0x625EF2E4L,0x92809C4DL,0x926D7F8DL,(-5L)}},{{(-1L),(-10L),0x454160E1L,0x5AC8D5ACL},{0x92809C4DL,(-5L),(-1L),0x5AC8D5ACL},{0x926D7F8DL,(-10L),0x52800829L,(-5L)},{0xF0341802L,0x92809C4DL,0x677040BDL,0x92809C4DL},{(-10L),(-1L),0x677040BDL,0x926D7F8DL},{0x454160E1L,(-5L),(-1L),0x454160E1L},{(-5L),0x625EF2E4L,5L,(-1L)}}};
        int32_t l_220 = 0x234616B0L;
        struct S0 ****l_226 = &l_222;
        int32_t *l_283 = &l_138.f0;
        int i, j, k;
    }
    return p_92;
    /* statement id: 184 */
    //assert (func_89_rv == 0 || func_89_rv == &l_284.f0 || func_89_rv == &l_299 || func_89_rv == &l_76 || func_89_rv == &l_501);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_93(struct S0  p_94)
{ /* block id: 46 */
    int64_t l_96[8] = {0x2962DE1B453F4779LL,0x2962DE1B453F4779LL,0x2962DE1B453F4779LL,0x2962DE1B453F4779LL,0x2962DE1B453F4779LL,0x2962DE1B453F4779LL,0x2962DE1B453F4779LL,0x2962DE1B453F4779LL};
    int32_t *l_97 = (void*)0;
    int16_t l_99 = 0x636BL;
    int32_t *l_100 = (void*)0;
    int32_t l_102 = 2L;
    int32_t *l_101 = &l_102;
    struct S0 *l_122 = (void*)0;
    struct S0 **l_121 = &l_122;
    int32_t *l_124[3];
    int32_t *l_125 = &l_102;
    int32_t *l_126 = &l_102;
    int32_t *l_127 = &l_102;
    int32_t *l_128 = &l_102;
    int32_t *l_129[10] = {&l_102,&l_102,&l_102,&l_102,&l_102,&l_102,&l_102,&l_102,&l_102,&l_102};
    int32_t *l_130 = &l_102;
    int32_t *l_131 = &l_102;
    int32_t *l_132 = &l_102;
    int32_t *l_133[10][9][1] = {{{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102}},{{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102}},{{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102}},{{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102}},{{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102}},{{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102}},{{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102}},{{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102}},{{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102}},{{&l_102},{(void*)0},{&l_102},{&l_102},{&l_102},{&l_102},{&l_102},{(void*)0},{&l_102}}};
    int32_t *l_134 = &l_102;
    int32_t *l_135 = &l_102;
    int32_t *l_136 = (void*)0;
    int i, j, k;
    for (i = 0; i < 3; i++)
        l_124[i] = &l_102;
    (*l_101) = (((((l_96[4] | ((((void*)0 == l_97) < p_94.f6) | 0x6D3C1D26L)) != 4UL) ^ (!p_94.f8)) | (l_99 ^ l_96[4])) | p_94.f2);
    (*l_101) = (*l_101);
    for (l_99 = 0; (l_99 <= 7); l_99 += 1)
    { /* block id: 51 */
        int32_t l_103 = 0xB68985BBL;
        struct S0 ***l_123 = &l_121;
        for (p_94.f2 = 2; (p_94.f2 <= 7); p_94.f2 += 1)
        { /* block id: 54 */
            int32_t *l_106[5][7] = {{&l_102,(void*)0,&l_103,(void*)0,&l_103,&l_103,(void*)0},{&l_102,(void*)0,&l_102,(void*)0,(void*)0,&l_102,&l_102},{(void*)0,(void*)0,&l_103,&l_102,(void*)0,&l_103,(void*)0},{&l_103,(void*)0,(void*)0,&l_103,&l_102,&l_102,(void*)0},{&l_103,&l_102,(void*)0,&l_103,(void*)0,&l_103,&l_103}};
            int i, j;
            if (l_96[l_99])
                break;
            for (p_94.f6 = 6; (p_94.f6 >= 1); p_94.f6 -= 1)
            { /* block id: 58 */
                struct S0 l_115 = {0x38A40F94L,0UL,3UL,0L,0,0x0DA5F02B52C7FF41LL,0x0E74272AL,723,13};
                struct S0 *l_114 = &l_115;
                int32_t **l_118 = &l_100;
                for (p_94.f0 = 7; (p_94.f0 >= 0); p_94.f0 -= 1)
                { /* block id: 61 */
                    int16_t l_107 = 1L;
                    (*l_101) = (l_103 ^ (((void*)0 == l_106[3][2]) || ((-10L) == ((l_107 && ((uint16_t)((int16_t)(((((l_107 == ((((p_94.f2 || p_94.f3) <= (((uint16_t)0xD2A5L << (uint16_t)p_94.f5) >= (-1L))) && p_94.f4) >= 0xE132E46AL)) ^ p_94.f5) == (-1L)) ^ p_94.f4) & p_94.f1) + (int16_t)0x8760L) >> (uint16_t)p_94.f5)) > 4UL))));
                }
                (*l_114) = p_94;
                (*l_101) = ((uint16_t)p_94.f8 >> (uint16_t)p_94.f4);
                (*l_118) = (void*)0;
                /* statement id: 66 */
                assert (l_100 == 0);
            }
            for (p_94.f0 = 4; (p_94.f0 >= 0); p_94.f0 -= 1)
            { /* block id: 70 */
                int32_t **l_119 = (void*)0;
                int32_t **l_120[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                int i, j;
                l_103 = (l_96[p_94.f2] > l_96[p_94.f2]);
                l_100 = l_106[p_94.f0][p_94.f0];
                /* statement id: 72 */
                assert (l_100 == 0 || l_100 == &l_102 || l_100 == &l_103);
                if (l_103)
                    break;
            }
        }
        /* facts after for loop */
        //assert (l_100 == 0 || l_100 == &l_102 || l_100 == &l_103 || l_100 == dangling);
        (*l_123) = l_121;
        if (p_94.f4)
            continue;
        //assert (l_100 == 0 || l_100 == &l_102 || l_100 == dangling);
    }
    /* facts after for loop */
    //assert (l_100 == 0 || l_100 == &l_102 || l_100 == dangling);
    return l_136;
    /* statement id: 79 */
    //assert (func_93_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 152
   depth: 1, occurrence: 22
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 42
breakdown:
   indirect level: 0, occurrence: 22
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 21
XXX times a bitfields struct on LHS: 7
XXX times a bitfields struct on RHS: 34
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 9

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 200
   depth: 2, occurrence: 45
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 20, occurrence: 3
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 167

XXX times a variable address is taken: 320
XXX times a pointer is dereferenced on RHS: 76
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 4
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 68
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 494

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1075
   level: 2, occurrence: 63
   level: 3, occurrence: 17
   level: 4, occurrence: 13
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 74
XXX number of pointers point to scalars: 71
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 34.7
XXX average alias set size: 1.44

XXX times a non-volatile is read: 701
XXX times a non-volatile is write: 250
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 187
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 39
   depth: 1, occurrence: 27
   depth: 2, occurrence: 16
   depth: 3, occurrence: 28
   depth: 4, occurrence: 41
   depth: 5, occurrence: 36

XXX percentage a fresh-made variable is used: 15.8
XXX percentage an existing variable is used: 84.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

