/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2210989252
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 16;
   uint32_t  f1;
   signed f2 : 19;
   unsigned f3 : 19;
   const signed f4 : 22;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_25(void);
inline static int16_t  func_28(uint32_t  p_29, uint32_t  p_30, uint16_t  p_31, uint32_t  p_32);
inline static const uint16_t  func_36(struct S0  p_37);
static uint16_t  func_62(struct S0  p_63, uint16_t  p_64);
static uint32_t  func_69(uint8_t  p_70);
static float  func_76(int32_t  p_77, uint32_t  p_78);
inline static uint32_t  func_81(const uint32_t  p_82, uint16_t  p_83, uint16_t  p_84, uint32_t  p_85);
static uint16_t  func_92(int32_t  p_93, uint16_t  p_94);
static int32_t  func_101(int16_t  p_102, int16_t  p_103);
static int32_t  func_115(int32_t  p_116, uint32_t  p_117, int32_t  p_118, uint8_t  p_119, int16_t  p_120);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_25(void)
{ /* block id: 36 */
    uint16_t l_35 = 0xD102;
    struct S0 l_38 = {-209,1U,-15,622,-1711};
    int32_t l_299 = 0x7920057B;
    int16_t l_300 = 1;
    float l_308 = 0x2.AE3911p+86;
    int16_t l_309 = 9;
    l_299 = ((int16_t)func_28(((((int16_t)l_35 + (int16_t)func_36(l_38)) && (((int16_t)l_38.f0 >> (int16_t)14) > (!(l_38.f4 != (((__builtin_parityl(((l_38.f4 , (l_38.f2 , ((int16_t)l_38.f1 >> (int16_t)8))) , (func_115(((l_299 || l_38.f1) , 5), l_35, l_38.f4, l_299, l_38.f2) | l_38.f2))) && l_38.f1) >= l_300) | l_38.f2))))) , 1U), l_300, l_38.f2, l_38.f0) >> (int16_t)4);
    l_299 = ((uint16_t)(((func_101((l_38.f2 || ((l_38.f0 != (-(uint16_t)l_309)) , ((uint16_t)l_38.f1 >> (uint16_t)8))), (l_309 && ((int32_t)(8U ^ (((int16_t)((l_300 , ((-1) | ((int32_t)0xB7C0F15A + (int32_t)4294967286U))) && 0xA7C91920) % (int16_t)l_38.f0) != l_309)) - (int32_t)l_38.f1))) <= l_300) , l_38.f4) , 0xE91B) - (uint16_t)l_38.f3);
    return l_38.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_28(uint32_t  p_29, uint32_t  p_30, uint16_t  p_31, uint32_t  p_32)
{ /* block id: 143 */
    struct S0 l_301 = {-137,4294967294U,-524,415,-1126};
    l_301.f2 = ((l_301 , ((uint32_t)l_301.f3 + (uint32_t)1U)) <= (-6));
    l_301.f2 = 1;
    l_301.f2 = (~func_81(p_30, l_301.f0, p_29, p_30));
    return l_301.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_36(struct S0  p_37)
{ /* block id: 37 */
    int32_t l_216 = 1;
    int32_t l_291 = (-10);
    const int32_t l_293 = (-4);
    p_37.f0 = (-1);
    for (p_37.f1 = 0; (p_37.f1 > 10); p_37.f1 += 2)
    { /* block id: 41 */
        int32_t l_41 = 7;
        int32_t l_229 = 1;
        for (l_41 = 0; (l_41 > (-13)); l_41 -= 1)
        { /* block id: 44 */
            int32_t l_44 = 1;
            struct S0 l_292 = {152,0x81A7D4A4,-153,268,-1152};
            for (l_44 = 6; (l_44 >= (-12)); l_44 -= 1)
            { /* block id: 47 */
                int16_t l_215 = 0x2153;
                p_37.f2 = ((uint16_t)((uint16_t)p_37.f3 + (uint16_t)(((int16_t)(((uint16_t)0U / (uint16_t)(~(0xBDD86BDA == p_37.f0))) && (((int16_t)((uint32_t)((int32_t)((func_62(p_37, ((int16_t)0x7BA2 / (int16_t)((uint32_t)p_37.f2 + (uint32_t)p_37.f1))) == l_215) >= p_37.f4) / (int32_t)l_216) % (uint32_t)l_216) - (int16_t)0x15F6) ^ 0xAB8F)) << (int16_t)l_41) == l_44)) / (uint16_t)l_215);
            }
            for (l_44 = 14; (l_44 == (-4)); l_44 -= 1)
            { /* block id: 110 */
                float l_221 = 0xA.5F74D8p+79;
                int32_t l_224 = 6;
                float l_265 = 0x3.F51604p-40;
                if (l_216)
                    break;
                l_224 = ((int16_t)((4294967293U >= (func_101(p_37.f2, l_44) <= (0 | ((uint32_t)l_41 % (uint32_t)func_69(p_37.f0))))) ^ ((p_37.f2 || 0x1F33) || p_37.f2)) % (int16_t)0x0035);
                for (l_216 = (-30); (l_216 >= (-16)); l_216 += 9)
                { /* block id: 115 */
                    float l_227 = 0x8.BA18CCp-7;
                    int32_t l_228 = 1;
                    uint16_t l_266 = 65531U;
                    l_229 = (((p_37.f0 < __builtin_ctzl(l_228)) , ((p_37.f4 == 0U) , func_115(l_224, l_44, p_37.f2, p_37.f2, p_37.f2))) & p_37.f2);
                    for (l_224 = (-11); (l_224 >= 11); l_224 += 1)
                    { /* block id: 119 */
                        uint32_t l_233 = 1U;
                        uint32_t l_267 = 0U;
                        p_37.f0 = ((__builtin_popcount(p_37.f2) , (0U == (!((((((l_233 | (((uint32_t)((func_101(l_233, ((__builtin_clzll(p_37.f3) & (p_37.f1 == 4U)) || 0x58433A3D)) >= l_229) > p_37.f4) % (uint32_t)l_233) < l_224)) <= p_37.f1) , 0U) && l_228) == l_41) , p_37.f4)))) || 0xA774E767);
                        p_37.f0 = l_229;
                        l_267 = (-(int16_t)((int16_t)((int16_t)p_37.f4 + (int16_t)(((int32_t)(((uint16_t)((int16_t)((uint32_t)((((uint32_t)(p_37.f0 <= (p_37.f0 , (((int32_t)((uint16_t)((int32_t)((int16_t)0x941B - (int16_t)0U) - (int32_t)(p_37.f2 < ((((int32_t)(__builtin_popcountl(((uint32_t)((int32_t)l_228 / (int32_t)(p_37.f2 , p_37.f4)) + (uint32_t)p_37.f3)) | p_37.f1) / (int32_t)4294967290U) > 1) | p_37.f1))) % (uint16_t)p_37.f4) - (int32_t)l_41) , 0x2120))) / (uint32_t)l_233) <= l_266) | p_37.f4) - (uint32_t)l_233) + (int16_t)p_37.f3) / (uint16_t)l_229) , l_224) % (int32_t)(-1)) & p_37.f2)) >> (int16_t)l_216));
                    }
                    return p_37.f2;
                }
            }
            if (l_41)
            { /* block id: 127 */
                for (l_229 = 7; (l_229 > (-26)); l_229 -= 1)
                { /* block id: 130 */
                    float l_273 = 0x9.0p+1;
                    l_44 = ((uint16_t)(!p_37.f0) << (uint16_t)l_229);
                    return l_44;
                }
            }
            else
            { /* block id: 134 */
                uint32_t l_290 = 0xC1C66876;
                p_37.f0 = ((p_37 , ((-(uint16_t)((uint32_t)0x3313E7CB / (uint32_t)l_229)) || ((int16_t)(__builtin_clzl((((((((__builtin_ffs((((int16_t)1 << (int16_t)15) ^ (p_37.f3 >= (((((((float)p_37.f1 / (float)0x0.0p-1) == (p_37.f2 == (((float)(((((float)((float)((~p_37.f0) , l_41) - (float)l_290) / (float)0xB.9BC731p-47) < p_37.f4) != l_216) == p_37.f2) / (float)0x1.2p+1) != p_37.f1))) >= l_44) >= l_290) , 0xF4BAEF7A) >= l_216)))) , l_41) && l_229) || 0x6D30B18F) || p_37.f0) | 1) != 0x525E4907) >= l_216)) , (-10)) << (int16_t)p_37.f0))) <= l_44);
                l_291 = (((l_216 , 0x5.5B4BAFp-70) >= ((l_41 , (0xB.62704Dp-26 == l_229)) > __builtin_popcountl((l_216 , p_37.f2)))) , func_92(p_37.f2, p_37.f3));
                l_229 = func_62(l_292, p_37.f0);
            }
        }
        return p_37.f2;
    }
    return l_293;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_62(struct S0  p_63, uint16_t  p_64)
{ /* block id: 48 */
    uint32_t l_210 = 0x489111B8;
    int32_t l_211 = (-1);
    p_63.f2 = (((func_69(p_63.f0) || p_63.f0) >= __builtin_clzll(l_210)) || p_63.f0);
    l_211 = p_63.f4;
    for (l_210 = 0; (l_210 < 9); l_210 += 1)
    { /* block id: 102 */
        float l_214 = 0xD.DB69EBp-38;
        l_214 = p_64;
    }
    return l_210;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_69(uint8_t  p_70)
{ /* block id: 49 */
    int16_t l_71 = (-1);
    int32_t l_187 = 0xA3428438;
    uint32_t l_209 = 0x04E7F97F;
    l_71 = p_70;
    l_187 = ((float)l_71 - (float)((float)func_76((((uint32_t)func_81(p_70, l_71, p_70, ((uint16_t)0x6E0A / (uint16_t)p_70)) + (uint32_t)(((uint16_t)(func_115(l_71, ((((-(int16_t)(((-10) != p_70) == 0xFC97D5E0)) > 0U) <= 0xE77A) < 4294967295U), p_70, l_71, l_71) , p_70) / (uint16_t)l_71) > l_71)) , l_71), l_71) + (float)p_70));
    l_187 = (((((l_187 == 4294967290U) | (((((uint32_t)((int16_t)((uint16_t)(((int16_t)p_70 % (int16_t)p_70) || (!((int16_t)(((func_115((((uint16_t)p_70 % (uint16_t)(__builtin_popcount(l_71) || 1U)) >= (l_187 & p_70)), p_70, p_70, l_71, l_71) == 0U) != (-10)) && 5U) << (int16_t)l_71))) << (uint16_t)14) << (int16_t)8) / (uint32_t)l_187) , 0x8CC23DAE) , l_71) , p_70)) , p_70) != 0xE.7C3C58p+1) == 0x0.9p-1);
    l_187 = (0x1.Bp+1 >= (((float)((((float)(l_187 <= (((((int32_t)((int16_t)__builtin_ia32_crc32qi(p_70, p_70) + (int16_t)65535U) + (int32_t)0x7BC72429) < func_81((p_70 , (((l_71 || l_71) && 9) == l_209)), l_71, l_71, l_187)) || l_71) , l_209)) - (float)p_70) , p_70) < l_187) - (float)p_70) <= l_71));
    return l_187;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_76(int32_t  p_77, uint32_t  p_78)
{ /* block id: 78 */
    uint32_t l_171 = 4294967286U;
    int32_t l_172 = 0xD662417A;
    struct S0 l_183 = {-150,4294967295U,-14,212,172};
    for (p_77 = 16; (p_77 == 4); p_77 -= 3)
    { /* block id: 81 */
        int16_t l_170 = 1;
        l_171 = (p_77 , l_170);
        l_172 = (0xE.FE84F9p-39 == l_170);
    }
    l_172 = (l_171 | p_78);
    l_183.f0 = (((l_171 > (((uint16_t)(((int32_t)((int16_t)((int16_t)((__builtin_popcountl(p_77) ^ ((uint32_t)0xDFB547BD % (uint32_t)p_77)) , p_78) >> (int16_t)1) << (int16_t)12) - (int32_t)((l_172 == l_171) || l_172)) , p_77) + (uint16_t)l_172) | l_171)) , l_183) , l_183.f1);
    for (p_77 = 21; (p_77 >= 16); p_77 -= 1)
    { /* block id: 89 */
        int16_t l_186 = 0xB3A4;
        l_172 = (l_183.f1 <= l_183.f0);
        l_186 = (-0x1.9p+1);
    }
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_81(const uint32_t  p_82, uint16_t  p_83, uint16_t  p_84, uint32_t  p_85)
{ /* block id: 51 */
    int32_t l_95 = 0x43232AF7;
    uint16_t l_164 = 6U;
    l_95 = (p_82 , ((((((uint16_t)((uint16_t)0x6516 >> (uint16_t)3) + (uint16_t)(p_84 , (func_92(__builtin_parityl(l_95), p_84) & (((p_85 == (0x6.41CCEBp-13 > 0x5.Ap-1)) , l_95) >= l_95)))) || l_164) , l_164) ^ 0) , l_95));
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_92(int32_t  p_93, uint16_t  p_94)
{ /* block id: 52 */
    uint16_t l_96 = 0x7069;
    int32_t l_125 = 0x85683D52;
    int32_t l_130 = (-2);
    l_96 = p_94;
    l_130 = ((uint16_t)(((int16_t)(func_101((((-10) == (l_96 >= __builtin_ffsl((((int16_t)((0xF0F9AB13 ^ ((int16_t)((int32_t)__builtin_ctz(p_94) + (int32_t)(((int16_t)(~func_115(((int32_t)(((l_96 && l_96) | p_94) || ((uint16_t)p_94 >> (uint16_t)14)) % (int32_t)l_96), l_125, p_93, p_94, p_93)) << (int16_t)5) | l_125)) % (int16_t)l_96)) == l_96) - (int16_t)l_96) , 0x0EDDB647)))) <= p_94), l_130) != p_94) / (int16_t)l_96) , p_94) + (uint16_t)(-1));
    if (l_125)
    { /* block id: 63 */
        uint32_t l_140 = 4294967295U;
        int32_t l_154 = (-6);
        l_125 = ((int16_t)l_140 >> (int16_t)(((uint32_t)0x92391BE1 + (uint32_t)((int16_t)p_94 - (int16_t)((((float)(p_94 != 0x2.98D290p-32) / (float)((!0x4.C1765Dp-65) != l_140)) , l_140) <= __builtin_parityll(((uint16_t)((l_96 && p_94) > l_140) + (uint16_t)l_130))))) == l_125));
        l_154 = (((((-4) < p_94) >= __builtin_parity(l_96)) <= 1) != func_101(p_94, ((((int16_t)__builtin_ctzl(((uint16_t)p_94 << (uint16_t)1)) >> (int16_t)p_93) && 0xE32F9EFC) > l_125)));
    }
    else
    { /* block id: 66 */
        uint32_t l_155 = 0x0566CB4C;
        l_155 = l_130;
        for (p_93 = 0; (p_93 > 24); p_93 += 1)
        { /* block id: 70 */
            int32_t l_158 = 0x78FF3A18;
            l_158 = l_155;
            l_125 = (0xA2F0F6D1 == (0xAFD9 == func_115((l_155 , ((uint16_t)l_155 / (uint16_t)l_125)), (l_155 || (p_94 || ((~((int32_t)l_155 % (int32_t)p_94)) | 0xA4ECE64C))), l_158, l_155, p_94)));
        }
    }
    return p_93;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_101(int16_t  p_102, int16_t  p_103)
{ /* block id: 57 */
    uint8_t l_131 = 255U;
    int32_t l_132 = 1;
    struct S0 l_135 = {-132,0x186C96E7,-707,38,1588};
    int32_t l_136 = 0x3B6D3E8D;
    l_132 = l_131;
    l_135.f2 = (l_132 <= func_115(l_132, ((int16_t)((((p_103 | l_131) ^ 4U) != (l_135 , (l_136 ^ 0x25EC3E4F))) <= (-(uint16_t)l_132)) - (int16_t)(-1)), l_135.f0, l_136, p_102));
    l_135.f0 = (4294967291U | 4U);
    return p_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_115(int32_t  p_116, uint32_t  p_117, int32_t  p_118, uint8_t  p_119, int16_t  p_120)
{ /* block id: 54 */
    uint32_t l_128 = 0x8A300FF6;
    int32_t l_129 = 0xE6AC9C4B;
    l_129 = ((int32_t)p_117 - (int32_t)l_128);
    return l_129;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 49
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 12
XXX times a single bitfield on RHS: 68

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 2
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 324
XXX times a non-volatile is write: 52
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 68
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 11
   depth: 2, occurrence: 5
   depth: 3, occurrence: 8
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 15
XXX percentage an existing variable is used: 85
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

