/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3668352728
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 26;
   signed f1 : 7;
   signed f2 : 13;
   unsigned f3 : 5;
   unsigned : 0;
   const signed f4 : 23;
   const signed f5 : 25;
   unsigned f6 : 10;
   const unsigned f7 : 6;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_31(void);
inline static int32_t  func_32(int8_t  p_33, uint16_t  p_34, uint16_t  p_35, struct S0  p_36, float  p_37);
inline static int32_t  func_38(int16_t  p_39, struct S0  p_40, const int16_t  p_41, int8_t  p_42);
inline static struct S0  func_45(int8_t  p_46, const int32_t  p_47, uint16_t  p_48, int16_t  p_49, int16_t  p_50);
inline static int16_t  func_73(int16_t  p_74);
inline static int16_t  func_75(uint16_t  p_76, int32_t  p_77, uint32_t  p_78, struct S0  p_79);
static int16_t  func_85(const uint32_t  p_86, const uint32_t  p_87, struct S0  p_88, int16_t  p_89);
static int16_t  func_109(uint16_t  p_110);
static uint16_t  func_115(const uint32_t  p_116, uint32_t  p_117, int16_t  p_118);
inline static int32_t  func_133(int32_t  p_134, int32_t  p_135, const uint32_t  p_136, uint32_t  p_137, uint32_t  p_138);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_31(void)
{ /* block id: 36 */
    float l_43 = 0xD.52F093p+70;
    int32_t l_44 = 2L;
    const uint32_t l_51 = 0UL;
    uint32_t l_54 = 0x4B505D01L;
    int32_t l_60 = 0x32E88240L;
    int32_t l_173 = 0xAB730D59L;
    struct S0 l_174 = {1573,4,-38,1,2244,-5695,24,0};
    uint16_t l_182 = 0UL;
    float l_187 = 0x3.Ap-1;
    int32_t l_188 = 0L;
    int32_t l_189 = (-1L);
    uint32_t l_197 = 1UL;
    l_174.f1 = func_32(((func_38(l_44, func_45(l_44, l_51, ((int16_t)l_51 << (int16_t)3), l_51, l_54), ((((0xBA8A7E8BL & ((uint16_t)l_51 % (uint16_t)l_51)) || l_60) < l_60) & l_44), l_60) && 0x9DAF5B91L) && l_54), l_173, l_54, l_174, l_174.f0);
    l_44 = ((uint32_t)((uint16_t)(((int16_t)l_54 * (int16_t)(l_54 >= ((((l_174.f1 == ((((4294967295UL <= func_32((l_182 >= ((((int16_t)l_174.f7 % (int16_t)l_174.f3) && ((uint16_t)(((__builtin_parity(((((0xB26D052DL > (((-1L) <= l_60) > l_174.f5)) | (-8L)) ^ l_174.f5) >= l_174.f3)) != (-9L)) & l_174.f5) | 0x1988898DL) << (uint16_t)11)) | 0x8A0DB83AL)), l_174.f4, l_174.f4, l_174, l_174.f0)) < l_174.f6) == 0UL) | l_54)) > l_60) || (-8L)) & 7UL))) <= l_174.f2) % (uint16_t)l_188) / (uint32_t)(-2L));
    l_189 = (__builtin_popcount(l_189) != ((func_38(l_174.f6, l_174, ((l_174.f0 && (!(l_188 <= ((((int32_t)l_44 - (int32_t)(((int16_t)((-8L) > ((((int16_t)l_174.f5 + (int16_t)0UL) && l_44) && 0xD2CFL)) << (int16_t)6) != l_197)) >= 0x5677DB30L) || l_174.f3)))) && 5L), l_174.f7) == l_188) <= 0x7.E0A69Ap-30));
    return l_174;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_32(int8_t  p_33, uint16_t  p_34, uint16_t  p_35, struct S0  p_36, float  p_37)
{ /* block id: 101 */
    uint16_t l_175 = 0x9906L;
    return l_175;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_38(int16_t  p_39, struct S0  p_40, const int16_t  p_41, int8_t  p_42)
{ /* block id: 40 */
    int16_t l_63 = 0L;
    int32_t l_172 = 1L;
    for (p_42 = (-1); (p_42 >= (-4)); p_42 -= 4)
    { /* block id: 43 */
        int32_t l_66 = 0L;
        int8_t l_84 = (-2L);
        p_40.f2 = __builtin_ctz(l_63);
        l_66 = ((l_66 ^ ((((((uint16_t)l_66 % (uint16_t)((int16_t)(((uint32_t)(((p_42 != func_73(func_75(l_63, p_40.f5, (((int16_t)((int16_t)l_84 << (int16_t)__builtin_clz(l_84)) << (int16_t)6) & func_85(p_40.f1, l_63, p_40, p_42)), p_40))) < l_66) | l_63) + (uint32_t)p_40.f1) || l_63) >> (int16_t)l_63)) > l_84) != l_66) >= 0UL) <= 0xF5692BD2L)) ^ 0x1F1E8637L);
        p_40.f2 = ((uint16_t)65534UL >> (uint16_t)((l_63 == 9L) == ((3L <= l_84) <= (8UL < p_40.f5))));
    }
    return l_172;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_45(int8_t  p_46, const int32_t  p_47, uint16_t  p_48, int16_t  p_49, int16_t  p_50)
{ /* block id: 37 */
    int8_t l_55 = 0x41L;
    int32_t l_56 = (-1L);
    struct S0 l_57 = {1998,-3,-76,3,-792,-1168,2,4};
    l_56 = l_55;
    return l_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_73(int16_t  p_74)
{ /* block id: 94 */
    int32_t l_169 = 0xBD0B17AAL;
    l_169 = p_74;
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_75(uint16_t  p_76, int32_t  p_77, uint32_t  p_78, struct S0  p_79)
{ /* block id: 76 */
    int32_t l_162 = 5L;
    for (p_77 = 0; (p_77 != 12); p_77 += 1)
    { /* block id: 79 */
        float l_165 = (-0x1.1p-1);
        int32_t l_166 = (-4L);
        for (p_76 = 0; (p_76 != 23); p_76 += 1)
        { /* block id: 82 */
            return p_79.f7;
        }
        l_162 = p_79.f2;
        p_79.f2 = (((int16_t)l_166 >> (int16_t)4) | p_76);
        for (p_76 = (-29); (p_76 == 30); p_76 += 1)
        { /* block id: 89 */
            p_79.f1 = l_162;
        }
    }
    return l_162;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_85(const uint32_t  p_86, const uint32_t  p_87, struct S0  p_88, int16_t  p_89)
{ /* block id: 45 */
    int8_t l_94 = 0xB3L;
    const int32_t l_155 = 0x53E36E8DL;
    float l_156 = 0x6.65F2B7p-92;
    for (p_89 = 0; (p_89 >= 24); p_89 += 1)
    { /* block id: 48 */
        uint16_t l_92 = 4UL;
        int32_t l_93 = 0x4A170516L;
        uint16_t l_129 = 0x3439L;
        l_93 = __builtin_ffsl(l_92);
        if (l_94)
        { /* block id: 50 */
            int8_t l_95 = 0L;
            l_93 = l_95;
        }
        else
        { /* block id: 52 */
            float l_96 = 0xD.A80087p-64;
            const int32_t l_97 = 0xD061DAE5L;
            int32_t l_157 = 0x93423A38L;
            if (l_92)
                break;
            p_88.f2 = p_88.f2;
            if (l_97)
                continue;
            l_157 = (((int32_t)((uint16_t)((!((uint16_t)(((int16_t)(((uint32_t)0xB0FACDC9L - (uint32_t)(func_109((__builtin_bswap32(((uint16_t)__builtin_popcountll((l_94 < ((uint16_t)func_115(p_88.f6, (((int16_t)p_88.f6 - (int16_t)(((uint16_t)(((4294967295UL | ((int16_t)__builtin_parityll(p_88.f1) - (int16_t)((uint16_t)((int32_t)1L - (int32_t)(p_88.f0 && l_97)) << (uint16_t)p_88.f0))) && 1UL) ^ 7L) + (uint16_t)l_129) & l_97)) | l_97), l_94) % (uint16_t)p_88.f2))) - (uint16_t)p_88.f6)) < 0xA40DL)) <= (-4L))) >= 0x2B77L) >> (int16_t)p_88.f4) >= l_94) - (uint16_t)l_155)) | 1UL) / (uint16_t)0x2C3AL) + (int32_t)p_88.f3) || 0x9730A75DL);
        }
    }
    return l_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_109(uint16_t  p_110)
{ /* block id: 59 */
    float l_143 = (-0x7.4p+1);
    int32_t l_144 = (-1L);
    uint32_t l_154 = 0x552C1979L;
    l_144 = func_133(((uint16_t)(((p_110 >= (((p_110 || ((int32_t)(p_110 | l_144) + (int32_t)(p_110 ^ ((int16_t)func_115(((int32_t)l_144 % (int32_t)p_110), l_144, p_110) << (int16_t)4)))) | l_144) != p_110)) & l_144) < p_110) << (uint16_t)5), l_144, l_144, l_144, p_110);
    l_144 = ((uint16_t)(p_110 != ((((__builtin_clzll(l_154) != l_154) == p_110) > l_154) | l_144)) >> (uint16_t)0);
    l_144 = p_110;
    return p_110;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_115(const uint32_t  p_116, uint32_t  p_117, int16_t  p_118)
{ /* block id: 56 */
    uint32_t l_132 = 0x5C111017L;
    l_132 = ((uint32_t)0xAED54F57L + (uint32_t)p_116);
    return p_118;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_133(int32_t  p_134, int32_t  p_135, const uint32_t  p_136, uint32_t  p_137, uint32_t  p_138)
{ /* block id: 60 */
    for (p_135 = 0; (p_135 == (-4)); p_135 -= 1)
    { /* block id: 63 */
        int16_t l_151 = 0xBD2FL;
        p_134 = (0xFD2206DCL && p_136);
        l_151 = 0x1.5p-1;
    }
    return p_138;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 48
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 34

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 43
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 27, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 162
XXX times a non-volatile is write: 27
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 41
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 23
   depth: 1, occurrence: 11
   depth: 2, occurrence: 7

XXX percentage a fresh-made variable is used: 27
XXX percentage an existing variable is used: 73
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

