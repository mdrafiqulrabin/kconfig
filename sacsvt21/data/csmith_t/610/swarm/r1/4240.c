/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      1048129802
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static volatile int32_t g_2 = 0xB110C93B;/* VOLATILE GLOBAL g_2 */
static int32_t g_3 = 0xA3622BA3;
static int32_t g_44 = 1;
static int32_t *g_57 = &g_3;
static int32_t **g_56 = &g_57;
static float g_65 = 0x8.8p-1;
static uint16_t g_71 = 65531U;
static int32_t g_103 = 1;
static int32_t *g_114 = &g_103;
static uint16_t g_135 = 65535U;
static volatile float g_167 = 0x0.E5992Bp-28;/* VOLATILE GLOBAL g_167 */
static volatile float *g_166 = &g_167;
static volatile float **g_165 = &g_166;
static volatile int32_t ****g_185 = (void*)0;
static float g_347 = (-0x1.Dp-1);
static volatile float ***g_373 = &g_165;
static volatile float ****g_372 = &g_373;
static volatile float *****g_371 = &g_372;
static float ****g_607 = (void*)0;
static float *****g_606 = &g_607;
static float ***g_668 = (void*)0;
static float ****g_667 = &g_668;


/* --- FORWARD DECLARATIONS --- */
static float  func_1(void);
static int32_t  func_8(uint32_t  p_9, int16_t  p_10, int32_t  p_11, uint32_t  p_12);
static int16_t  func_21(float  p_22, int32_t  p_23);
static int32_t * func_29(int32_t * p_30, uint16_t  p_31, float  p_32, int32_t * p_33, int32_t * p_34);
static int32_t * func_35(int32_t  p_36);
static int32_t * func_39(int32_t  p_40, int32_t * p_41);
static int32_t * func_42(int32_t * p_43);
static int32_t ** func_47(uint16_t  p_48, uint32_t  p_49, uint16_t  p_50, int32_t  p_51, int32_t * p_52);
static uint32_t  func_53(int32_t ** p_54, int32_t * p_55);
static int32_t * func_58(int16_t  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_44 g_56 g_371 g_372 g_373 g_165 g_166 g_167 g_103 g_57 g_114 g_135 g_2 g_71 g_667
 * writes: g_3 g_57 g_103 g_167 g_44 g_65 g_71
 */
static float  func_1(void)
{ /* block id: 0 */
    int32_t *l_412 = &g_103;
    uint32_t l_471 = 1U;
    int32_t l_474 = 0x2C64FC77;
    int32_t l_590 = (-7);
    float ****l_605 = (void*)0;
    float *****l_604 = &l_605;
    float *l_635 = &g_347;
    float **l_634 = &l_635;
    float ***l_633 = &l_634;
    float l_639 = (-0x7.9p-1);
    int32_t ***l_684 = &g_56;
    float l_718 = 0x9.F200BEp-73;
    for (g_3 = (-22); (g_3 == 24); g_3 += 1)
    { /* block id: 3 */
        int32_t l_215 = (-1);
        float l_406 = 0xD.0AEEF7p+70;
        int32_t l_407 = 0x8BA18F78;
        int32_t *l_435 = &g_103;
        int32_t ***l_456 = &g_56;
        int32_t ****l_455 = &l_456;
        uint32_t l_480 = 0U;
        uint32_t l_483 = 0x1AF92099;
        float *l_523 = &l_406;
        float **l_522 = &l_523;
        float ***l_521 = &l_522;
        int32_t l_559 = 0xBB034093;
    }
    if (((uint16_t)g_44 / (uint16_t)0x91D3))
    { /* block id: 282 */
        (*g_56) = &l_474;
        return (*****g_371);
    }
    else
    { /* block id: 285 */
        int32_t **l_573 = &g_114;
        uint32_t l_600 = 0x66DC7A78;
lbl_627:
        for (g_103 = 0; (g_103 != 0); g_103 += 5)
        { /* block id: 288 */
            int32_t l_572 = (-1);
            float *l_586 = &g_347;
            float **l_585 = &l_586;
            float ***l_584 = &l_585;
            float ****l_583 = &l_584;
            int32_t l_589 = 0x3CA0FBA8;
            (*g_57) = (*g_57);
            if (g_3)
                goto lbl_627;
        }
        (*g_57) = ((uint16_t)((uint16_t)0x8ACA >> (uint16_t)15) * (uint16_t)0x120A);
        (**g_165) = (**l_573);
        (*g_166) = (**l_573);
    }
    if (((-(uint16_t)(((void*)0 != l_633) > (!((((***g_372) == (*l_634)) < (*l_412)) > g_135)))) ^ ((uint16_t)(((0xE080BFE1 & 0x17B55F81) || (g_2 && 6)) ^ 0xB4E70756) * (uint16_t)g_3)))
    { /* block id: 339 */
        int32_t *l_644 = (void*)0;
        int32_t l_679 = 0xF633E30A;
        int32_t ***l_692 = &g_56;
        int32_t ***l_693 = &g_56;
        int32_t l_696 = 1;
        if (((uint16_t)(-(int32_t)(*g_114)) >> (uint16_t)(!(((void*)0 != l_644) <= (g_71 > g_71)))))
        { /* block id: 340 */
            int32_t ***l_650 = &g_56;
            int16_t l_662 = 0x9DA3;
            for (g_44 = 0; (g_44 != 15); g_44 += 1)
            { /* block id: 343 */
                (*g_56) = &l_590;
                (**g_56) = ((((~g_2) && 4294967292U) ^ (((int16_t)((void*)0 != l_650) + (int16_t)(***l_650)) >= (((((uint16_t)(-(uint16_t)(*l_412)) * (uint16_t)g_135) & ((g_103 > 9) >= g_71)) < 0x2AC3BA0A) || (*l_412)))) ^ g_103);
                for (l_471 = 0; (l_471 < 24); l_471 += 1)
                { /* block id: 348 */
                    uint32_t l_660 = 0xBA886B4C;
                    for (g_3 = 0; (g_3 != (-29)); g_3 -= 1)
                    { /* block id: 351 */
                        float l_661 = 0x8.2729B1p-16;
                        (*g_56) = l_644;
                        if (l_660)
                            continue;
                        (*g_114) = l_662;
                    }
                    for (g_3 = (-9); (g_3 < (-14)); g_3 -= 1)
                    { /* block id: 358 */
                        (*g_56) = (void*)0;
                    }
                    if (l_660)
                        break;
                    if ((*g_114))
                        continue;
                }
                (****g_372) = 0x6.CF3599p-15;
            }
            (*l_412) = (*g_114);
            (*g_166) = ((****g_372) >= 0xD.F7AB69p-26);
            (*g_56) = (*g_56);
        }
        else
        { /* block id: 369 */
            float l_673 = 0x2.2FA665p-66;
            int32_t l_678 = 0xDE0CB771;
            (*g_56) = (*g_56);
            (*g_114) = (((*g_114) ^ (((uint16_t)(((void*)0 == g_667) <= (((int16_t)(((((int16_t)g_44 / (int16_t)g_135) != (*g_114)) || g_71) ^ (g_135 || ((((((((int16_t)(((uint16_t)(((g_2 > g_71) == g_3) == l_678) << (uint16_t)10) <= 0x3E01) + (int16_t)0xF7C3) <= g_135) > 4294967295U) > 2U) != (*g_57)) & l_679) && (-1)))) >> (int16_t)g_71) && l_678)) << (uint16_t)10) < g_3)) || 6U);
        }
        for (g_44 = 0; (g_44 == (-27)); g_44 -= 9)
        { /* block id: 375 */
            float l_697 = 0x8.B0D71Ep+8;
            (*****g_371) = ((float)(*****g_371) / (float)(&g_114 == &l_644));
            if ((*g_114))
                continue;
            if ((l_684 != l_684))
            { /* block id: 378 */
                (*g_114) = (!(((&g_185 != &g_185) < (g_103 > g_44)) || ((uint16_t)((uint16_t)((int16_t)(g_44 > (l_692 != l_693)) + (int16_t)((int16_t)(l_696 != g_2) / (int16_t)0xEA4B)) << (uint16_t)g_103) >> (uint16_t)g_44)));
                (*l_412) = ((*l_412) > g_103);
            }
            else
            { /* block id: 381 */
                (****g_372) = l_697;
            }
            (**l_693) = (**l_684);
        }
    }
    else
    { /* block id: 386 */
        float *l_705 = (void*)0;
        uint32_t l_708 = 7U;
        int16_t l_711 = 0xA110;
        for (l_474 = 2; (l_474 <= (-21)); l_474 -= 1)
        { /* block id: 389 */
            int32_t *l_700 = &g_3;
            (*g_56) = l_700;
        }
        (*g_166) = (((((((((float)((float)(l_705 == (***g_372)) / (float)(((((((float)l_708 - (float)((float)(((**g_165) >= l_711) <= (-0x1.4p-1)) / (float)((float)((float)((float)(***l_684) - (float)(***l_684)) - (float)l_711) / (float)0xC.DA3BFDp-69))) >= (***l_684)) == (***l_684)) != l_711) == (-0x2.4p+1)) <= l_711)) + (float)l_718) != l_708) < (***l_684)) == 0x2.0FEDEDp-89) > (-0x1.1p+1)) > (-0x1.4p-1)) >= (*l_412)) != l_708);
        (*g_56) = func_42((**l_684));
    }
    return (*l_412);
}


/* ------------------------------------------ */
/* 
 * reads : g_56 g_103 g_165 g_166 g_167 g_44 g_57 g_185 g_114 g_71 g_3 g_135 g_371
 * writes: g_44 g_57 g_167 g_103 g_65 g_71 g_185 g_135
 */
static int32_t  func_8(uint32_t  p_9, int16_t  p_10, int32_t  p_11, uint32_t  p_12)
{ /* block id: 94 */
    int32_t ***l_221 = (void*)0;
    float **l_242 = (void*)0;
    float l_252 = 0x5.699ED9p-68;
    int32_t l_336 = 1;
    int32_t l_348 = 0x3A189BEC;
    int32_t l_351 = 1;
    uint32_t l_352 = 0U;
    float *****l_370 = (void*)0;
    uint32_t l_391 = 0x6CF9FAFD;
    uint16_t l_392 = 0U;
    int32_t l_405 = 0xDDE9A8AC;
lbl_353:
    for (g_44 = 1; (g_44 != 20); g_44 += 1)
    { /* block id: 97 */
        int32_t ***l_220 = (void*)0;
        float *l_266 = &l_252;
        float **l_265 = &l_266;
        uint32_t l_269 = 0U;
        float *l_270 = (void*)0;
        (*g_56) = &p_11;
        (*g_56) = &p_11;
        if (((((uint16_t)(l_220 != l_221) % (uint16_t)((uint16_t)p_11 * (uint16_t)0x1160)) ^ p_11) || (0xB239F508 <= (g_103 || ((int16_t)p_12 + (int16_t)(-(uint32_t)p_9))))))
        { /* block id: 100 */
            return p_10;
        }
        else
        { /* block id: 102 */
            int32_t **l_231 = &g_57;
            float ***l_243 = &l_242;
            (**g_165) = ((float)(p_10 <= ((**g_165) >= ((float)(((l_231 != &g_57) == ((float)((float)((float)((float)((((float)(l_242 == l_242) - (float)(0x4.3A44C3p+86 > 0x7.8p-1)) < (((l_243 == l_243) <= g_44) < 0x7.F22598p+50)) <= p_9) * (float)p_12) / (float)g_44) * (float)g_103) - (float)(-0x7.3p+1))) != (**l_231)) - (float)(**l_231)))) / (float)p_10);
        }
        if (((!p_12) | (g_185 == &l_220)))
        { /* block id: 105 */
            int16_t l_251 = 0x0007;
            for (g_103 = (-5); (g_103 >= (-24)); g_103 -= 1)
            { /* block id: 108 */
                (*g_56) = &p_11;
                return p_12;
            }
            for (p_10 = 0; (p_10 != (-6)); p_10 -= 1)
            { /* block id: 114 */
                (**g_165) = l_251;
                (*g_56) = func_58(p_12);
            }
            return p_9;
        }
        else
        { /* block id: 119 */
            int32_t l_253 = (-8);
            float *l_271 = &l_252;
            int32_t ****l_308 = &l_221;
            int32_t l_342 = (-5);
            if (l_253)
                break;
            if (((int32_t)(-(int32_t)((uint32_t)(((int32_t)(((uint16_t)1U << (uint16_t)3) ^ (((((void*)0 == l_265) || ((uint32_t)l_269 % (uint32_t)l_253)) == 0x62416D9B) < (l_270 == l_271))) + (int32_t)((int16_t)0x6630 >> (int16_t)g_44)) & p_9) % (uint32_t)1)) - (int32_t)(*g_57)))
            { /* block id: 121 */
                if ((*g_57))
                    break;
                (*g_114) = ((int16_t)(((&p_11 != (*g_56)) || (((*g_114) >= ((*g_165) == (*g_165))) == (&l_221 != (void*)0))) && (*g_57)) * (int16_t)p_12);
                p_11 = (-(int16_t)g_71);
            }
            else
            { /* block id: 125 */
                (*g_57) = ((((int16_t)g_3 << (int16_t)0) >= (p_9 || l_253)) < (~0x1D8D));
            }
            for (p_10 = 8; (p_10 != 8); p_10 += 6)
            { /* block id: 130 */
                float ***l_305 = &l_265;
                int32_t ****l_316 = &l_221;
                int32_t *l_317 = &l_253;
                int32_t *l_323 = &l_253;
                if (p_11)
                { /* block id: 131 */
                    float l_284 = (-0x1.Bp+1);
                    float **l_320 = &l_271;
                    if (l_253)
                    { /* block id: 132 */
                        (*g_114) = p_12;
                        (*g_57) = ((((((uint16_t)0x4F1E >> (uint16_t)((uint16_t)(l_242 != &g_166) / (uint16_t)((int16_t)p_9 >> (int16_t)((int16_t)(!((uint16_t)((((int16_t)(((int16_t)((((int32_t)p_12 / (int32_t)((uint16_t)(-(uint32_t)(&l_265 == l_305)) - (uint16_t)(l_253 && 0xC750724E))) || p_9) ^ p_9) % (int16_t)p_12) <= 4294967295U) % (int16_t)g_71) > g_135) || p_12) >> (uint16_t)g_71)) - (int16_t)3U)))) || p_10) > p_11) ^ 0xEA3EF8AB) & p_11);
                    }
                    else
                    { /* block id: 135 */
                        volatile float ***l_307 = &g_165;
                        volatile float ****l_306 = &l_307;
                        int32_t *****l_309 = &l_308;
                        (*l_306) = &g_165;
                        (*l_309) = l_308;
                        (**g_56) = ((uint32_t)(&g_56 != (void*)0) - (uint32_t)((int16_t)g_103 - (int16_t)0x4F40));
                    }
                    (*g_56) = func_58((0xEFDA != ((uint16_t)g_135 << (uint16_t)13)));
                    if ((l_316 == &l_220))
                    { /* block id: 141 */
                        l_317 = (*g_56);
                    }
                    else
                    { /* block id: 143 */
                        (*g_56) = func_58(p_9);
                        g_185 = g_185;
                        (**g_56) = 1;
                        (*g_57) = (((p_12 <= ((-7) != g_71)) || (((uint16_t)(l_320 != l_242) >> (uint16_t)((*l_308) == (void*)0)) && ((void*)0 == &p_11))) && p_10);
                    }
                }
                else
                { /* block id: 149 */
                    uint32_t l_341 = 0xAAAE0652;
                    for (g_103 = 0; (g_103 == (-13)); g_103 -= 4)
                    { /* block id: 152 */
                        (*g_56) = l_323;
                        (*l_266) = ((float)(*g_166) * (float)((float)((float)((((-0x1.Bp-1) <= (((float)(&g_56 == (*l_308)) - (float)(((*l_323) != (((float)p_12 - (float)g_3) != 0x1.8p-1)) != ((float)g_103 / (float)p_11))) <= (-0x1.Bp-1))) >= g_71) >= l_336) - (float)0x6.8F65C0p+33) / (float)0x1.8502B3p+20));
                        (**g_165) = (*g_166);
                        (*l_266) = (((float)((((float)((**g_165) <= g_3) / (float)p_10) >= l_341) > g_103) * (float)l_342) > (l_341 != 0xC.6213B6p-99));
                    }
                    if (g_3)
                        goto lbl_353;
                }
                if (((int16_t)g_135 - (int16_t)((0x9916 | (&g_166 == &g_166)) < ((int16_t)l_348 << (int16_t)12))))
                { /* block id: 159 */
                    if ((**g_56))
                        break;
                    for (l_348 = 0; (l_348 < 2); l_348 += 1)
                    { /* block id: 163 */
                        return l_351;
                    }
                }
                else
                { /* block id: 166 */
                    return l_352;
                }
            }
            p_11 = (((*g_165) != l_271) < ((void*)0 != &g_185));
        }
    }
    for (g_44 = 0; (g_44 == (-10)); g_44 -= 2)
    { /* block id: 176 */
        for (p_9 = (-23); (p_9 < 44); p_9 += 1)
        { /* block id: 179 */
            float ***l_365 = &l_242;
            float ****l_364 = &l_365;
            float *****l_363 = &l_364;
            for (g_135 = (-28); (g_135 > 19); g_135++)
            { /* block id: 182 */
                float l_360 = 0x8.3055ACp+45;
                return (*g_114);
            }
            for (g_135 = (-4); (g_135 != 27); g_135 += 1)
            { /* block id: 187 */
                float *****l_366 = (void*)0;
                int32_t l_367 = 0xD8232C72;
                l_366 = l_363;
                return l_367;
            }
            if ((*g_114))
                break;
        }
    }
    for (l_351 = 0; (l_351 > 25); l_351 += 1)
    { /* block id: 196 */
        float ***l_374 = &l_242;
        int32_t l_375 = 0x72562192;
        int32_t ****l_404 = &l_221;
        (**g_165) = (l_370 == g_371);
        (*g_56) = &g_44;
        (*g_114) = (((((l_374 != &l_242) >= g_44) & (*g_114)) == (*g_114)) & (l_375 == (((((uint32_t)(g_71 > (((((int32_t)p_9 - (int32_t)((((int16_t)((int16_t)((uint32_t)(!((uint32_t)(p_9 ^ g_3) % (uint32_t)l_375)) + (uint32_t)p_11) / (int16_t)g_44) * (int16_t)0xFEBD) < 0x61073647) != p_11)) || l_375) && l_391) <= 0xAE59654C)) % (uint32_t)(*g_57)) | l_375) != g_44) >= l_392)));
        for (l_348 = 0; (l_348 > 4); l_348 += 6)
        { /* block id: 202 */
            int32_t *l_395 = &l_375;
            (*g_56) = l_395;
            l_395 = func_39(((uint32_t)((int32_t)0xEC59F230 - (int32_t)(~((g_3 <= (((*l_395) | (!g_44)) == ((uint32_t)(0x92DF != 0x361D) / (uint32_t)(0x3CC0 ^ (l_404 == (void*)0))))) < p_11))) / (uint32_t)p_12), (*g_56));
        }
    }
    return l_405;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_44 g_56 g_57 g_114 g_103 g_135 g_71 g_165 g_185
 * writes: g_44 g_65 g_71 g_57 g_165 g_103
 */
static int16_t  func_21(float  p_22, int32_t  p_23)
{ /* block id: 6 */
    int32_t l_115 = 0;
    int32_t *l_116 = (void*)0;
    float *l_213 = (void*)0;
    float *l_214 = &g_65;
    (*g_56) = func_29(func_35(p_23), l_115, p_22, &g_103, l_116);
    (*l_214) = ((float)(((float)(((float)p_22 / (float)((float)((float)p_23 * (float)p_23) / (float)0x0.Ap+1)) != p_23) - (float)0x8.D19200p+38) > (g_3 < g_44)) - (float)0x2.Ep-1);
    (*g_56) = &l_115;
    return l_115;
}


/* ------------------------------------------ */
/* 
 * reads : g_56 g_57 g_44 g_103 g_3 g_135 g_71 g_165 g_185
 * writes: g_65 g_71 g_44 g_57 g_165 g_103
 */
static int32_t * func_29(int32_t * p_30, uint16_t  p_31, float  p_32, int32_t * p_33, int32_t * p_34)
{ /* block id: 46 */
    int16_t l_121 = 0x4C77;
    int16_t l_124 = 0xFAD6;
    int32_t **l_151 = &g_57;
    int32_t *l_169 = &g_44;
    float *l_197 = &g_65;
    float **l_196 = &l_197;
    float **l_198 = &l_197;
    float l_201 = 0x6.C328A7p-21;
    int32_t *l_202 = &g_44;
    p_33 = func_58(p_31);
    for (g_44 = 0; (g_44 != (-2)); g_44 -= 1)
    { /* block id: 50 */
        int32_t l_142 = 9;
        uint32_t l_143 = 4294967291U;
        int32_t ***l_184 = &l_151;
        if (((uint32_t)(l_121 | ((uint16_t)(l_124 > (g_103 & ((int16_t)((int32_t)(((uint16_t)(g_3 < ((uint16_t)((((uint16_t)(g_135 == ((int16_t)(((((&g_114 == &p_34) >= ((uint16_t)((int16_t)p_31 % (int16_t)g_103) + (uint16_t)l_142)) == (*p_30)) ^ g_103) == 0x811F) * (int16_t)0x0C24)) >> (uint16_t)p_31) && (*p_30)) != 0U) - (uint16_t)0U)) << (uint16_t)11) || l_143) % (int32_t)p_31) * (int16_t)1))) - (uint16_t)l_121)) - (uint32_t)0x2083236D))
        { /* block id: 51 */
            float *l_144 = &g_65;
            int32_t l_159 = 2;
            (*l_144) = l_124;
            if (((((uint16_t)p_31 - (uint16_t)((uint16_t)((g_103 || ((uint16_t)g_103 >> (uint16_t)12)) != (p_31 & (&p_33 == l_151))) + (uint16_t)(((uint32_t)((uint16_t)((uint16_t)(p_31 ^ (0U < ((-(uint16_t)(p_31 <= 0xDE18)) == 1))) << (uint16_t)g_71) >> (uint16_t)15) - (uint32_t)l_159) ^ l_159))) == 6) != g_44))
            { /* block id: 53 */
                int32_t ***l_161 = &g_56;
                int32_t ****l_160 = &l_161;
                (*l_160) = &g_56;
            }
            else
            { /* block id: 55 */
                int32_t *l_162 = &g_44;
                (*g_56) = p_30;
                return l_162;
            }
            if ((**g_56))
                continue;
        }
        else
        { /* block id: 60 */
            for (l_142 = 0; (l_142 == 18); l_142 += 4)
            { /* block id: 63 */
                volatile float ***l_168 = &g_165;
                (*l_168) = g_165;
                (*l_168) = &g_166;
                (*l_151) = l_169;
            }
        }
        for (l_143 = 0; (l_143 == 28); l_143 += 1)
        { /* block id: 71 */
            int32_t l_178 = 0x88670043;
            if (((int32_t)((uint32_t)((uint16_t)((l_178 ^ 0x2B5FAC05) && l_143) * (uint16_t)((((int16_t)(((!l_142) < ((((uint16_t)l_143 * (uint16_t)((&g_56 != l_184) != ((void*)0 == g_185))) & g_103) || g_44)) & g_3) + (int16_t)p_31) && (*l_169)) ^ p_31)) % (uint32_t)(*l_169)) - (int32_t)(*p_30)))
            { /* block id: 72 */
                for (l_178 = 0; (l_178 > (-8)); l_178 -= 1)
                { /* block id: 75 */
                    (*g_56) = (*l_151);
                }
                (*g_56) = func_58(g_135);
            }
            else
            { /* block id: 79 */
                for (l_142 = 0; (l_142 >= 3); l_142 += 6)
                { /* block id: 82 */
                    return p_30;
                }
            }
        }
    }
    (*p_30) = ((int16_t)((int16_t)(g_44 && ((int32_t)(l_196 == l_198) % (int32_t)(((0x1B0195B8 & ((uint16_t)((void*)0 == &p_33) + (uint16_t)((void*)0 != (*l_196)))) | g_135) || p_31))) << (int16_t)g_3) * (int16_t)g_103);
    return l_202;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_44 g_56 g_57 g_114
 * writes: g_44 g_65 g_71 g_57 g_114
 */
static int32_t * func_35(int32_t  p_36)
{ /* block id: 7 */
    float l_112 = 0x9.E16152p-15;
    int32_t l_113 = 0;
    for (p_36 = 7; (p_36 <= (-13)); p_36 -= 4)
    { /* block id: 10 */
        int32_t **l_109 = (void*)0;
        (*g_56) = func_39(g_3, func_42(&g_3));
        l_113 = (((((void*)0 == &g_57) > (p_36 ^ (!(((l_109 != (void*)0) ^ ((int16_t)g_3 * (int16_t)(((*g_56) != (*g_56)) & (g_3 >= 1)))) != 0xCE94)))) >= p_36) >= 2U);
    }
    return g_114;
}


/* ------------------------------------------ */
/* 
 * reads : g_56 g_57 g_44 g_114
 * writes: g_57 g_44 g_114
 */
static int32_t * func_39(int32_t  p_40, int32_t * p_41)
{ /* block id: 33 */
    int32_t l_106 = 0x298A7B98;
lbl_107:
    (*g_56) = (*g_56);
    for (g_44 = 0; (g_44 > (-11)); g_44 -= 1)
    { /* block id: 37 */
        l_106 = 0;
        if (g_44)
            goto lbl_107;
    }
    return (*g_56);
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_3 g_56 g_57 g_114
 * writes: g_44 g_65 g_71
 */
static int32_t * func_42(int32_t * p_43)
{ /* block id: 11 */
    int32_t l_60 = (-9);
    for (g_44 = (-18); (g_44 != (-3)); g_44 += 5)
    { /* block id: 14 */
        uint32_t l_73 = 0xF4802D14;
        uint16_t l_77 = 0x1021;
        int32_t **l_78 = &g_57;
        l_78 = func_47(g_3, func_53(g_56, func_58(l_60)), g_44, (((l_73 ^ (-(uint16_t)((uint16_t)l_73 * (uint16_t)l_73))) <= l_77) >= 1U), p_43);
    }
    return (*g_56);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_47(uint16_t  p_48, uint32_t  p_49, uint16_t  p_50, int32_t  p_51, int32_t * p_52)
{ /* block id: 22 */
    return &g_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_53(int32_t ** p_54, int32_t * p_55)
{ /* block id: 20 */
    uint16_t l_72 = 1U;
    return l_72;
}


/* ------------------------------------------ */
/* 
 * reads : g_56 g_57 g_114
 * writes: g_65 g_71
 */
static int32_t * func_58(int16_t  p_59)
{ /* block id: 15 */
    float *l_63 = (void*)0;
    float *l_64 = &g_65;
    int32_t l_70 = 0xA2AAFA0B;
    (*l_64) = ((float)p_59 - (float)0xF.9A325Cp-91);
    (*l_64) = ((float)0x4.D219FAp-0 + (float)((float)(-0x4.4p-1) * (float)p_59));
    g_71 = l_70;
    return (*g_56);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_44, "g_44", print_hash_value);
    transparent_crc_bytes (&g_65, sizeof(g_65), "g_65", print_hash_value);
    transparent_crc(g_71, "g_71", print_hash_value);
    transparent_crc(g_103, "g_103", print_hash_value);
    transparent_crc(g_135, "g_135", print_hash_value);
    transparent_crc_bytes (&g_167, sizeof(g_167), "g_167", print_hash_value);
    transparent_crc_bytes (&g_347, sizeof(g_347), "g_347", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 138
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 152
   depth: 2, occurrence: 40
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 3
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 4
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 107

XXX times a variable address is taken: 124
XXX times a pointer is dereferenced on RHS: 142
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 25
   depth: 3, occurrence: 19
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 103
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 13
   depth: 3, occurrence: 5
   depth: 4, occurrence: 6
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 27
XXX times a pointer is compared with address of another variable: 20
XXX times a pointer is compared with another pointer: 18
XXX times a pointer is qualified to be dereferenced: 472

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 255
   level: 2, occurrence: 67
   level: 3, occurrence: 46
   level: 4, occurrence: 20
   level: 5, occurrence: 24
XXX number of pointers point to pointers: 63
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.1
XXX average alias set size: 1.41

XXX times a non-volatile is read: 754
XXX times a non-volatile is write: 293
XXX times a volatile is read: 32
XXX    times read thru a pointer: 20
XXX times a volatile is write: 17
XXX    times written thru a pointer: 17
XXX times a volatile is available for access: 223
XXX percentage of non-volatile access: 95.5

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 150
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 27
   depth: 2, occurrence: 32
   depth: 3, occurrence: 29
   depth: 4, occurrence: 14
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 18.7
XXX percentage an existing variable is used: 81.3
********************* end of statistics **********************/

