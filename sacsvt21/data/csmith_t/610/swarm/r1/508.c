/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --compound-assignment --consts --no-divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3512008572
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const unsigned f0 : 12;
   unsigned f1 : 17;
   const signed f2 : 15;
   signed f3 : 31;
   signed f4 : 18;
   volatile signed f5 : 1;
   volatile signed f6 : 27;
};
#pragma pack(pop)

struct S1 {
   struct S0  f0;
   int32_t  f1;
   volatile uint32_t  f2;
   uint32_t  f3;
   volatile float  f4;
   volatile int8_t  f5;
   int8_t  f6;
   uint16_t  f7;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_8 = 3U;
static int32_t g_29 = 0;
static volatile int32_t g_30 = 0x28D5FEAF;/* VOLATILE GLOBAL g_30 */
static int32_t g_31[6] = {(-1),(-1),(-1),(-1),(-1),(-1)};
static uint32_t g_41 = 0xAB83EB61;
static uint32_t g_45 = 1U;
static float g_48[1] = {0xB.16971Dp+25};
static int16_t g_50[7][6] = {{0xB398,0xE10E,4,0xDF15,0x3CFE,1},{1,0,5,0,1,0xE10E},{1,0xB398,0,0xDF15,0x7D59,0x7D59},{0xB398,0x3CFE,0x3CFE,0xB398,5,0x7D59},{4,0x7D59,0,0xE10E,0xDF15,0xE10E},{5,0x6AC3,5,(-2),0xDF15,1},{0,0x7D59,4,0xE10E,0xE10E,5}};
static int32_t g_55[2][6][5] = {{{(-8),0x0CE61FA7,0x0CE61FA7,(-8),(-4)},{0,0x6910C334,0xF28D0D4A,0xF28D0D4A,0x6910C334},{(-4),0x0CE61FA7,0x81FFDE63,0x53D47EBD,0x53D47EBD},{(-1),0x53E8AF80,(-1),0xF28D0D4A,1},{0x98A597FB,(-8),0x53D47EBD,(-8),0x98A597FB},{(-1),0,0x53E8AF80,0x6910C334,0x53E8AF80}},{{(-4),(-4),0x53D47EBD,0x98A597FB,6},{0,(-1),(-1),0,0x53E8AF80},{(-8),0x98A597FB,0x81FFDE63,0x81FFDE63,0x98A597FB},{0x53E8AF80,(-1),0xF28D0D4A,1,1},{0x0CE61FA7,(-4),0x0CE61FA7,0x81FFDE63,0x53D47EBD},{0x6910C334,0,1,0,0x6910C334}}};
static uint16_t g_64[9] = {0x7181,0x7181,0x7181,0x7181,0x7181,0x7181,0x7181,0x7181,0x7181};
static float *g_69 = (void*)0;
static float *g_70 = &g_48[0];
static volatile int32_t g_81 = 0x574C5516;/* VOLATILE GLOBAL g_81 */
static int32_t *g_109 = &g_55[1][2][3];
static int32_t * const * const g_108 = &g_109;
static float **g_144 = &g_69;
static int8_t g_148 = 0x14;
static uint32_t g_150 = 0x6BD755E5;
static uint16_t *g_158 = &g_64[4];
static struct S1 g_179[2][5] = {{{{37,345,62,14852,-251,-0,-8890},0,3U,0x0A175524,-0x1.Dp-1,0x37,-5,0x295B},{{37,345,62,14852,-251,-0,-8890},0,3U,0x0A175524,-0x1.Dp-1,0x37,-5,0x295B},{{37,345,62,14852,-251,-0,-8890},0,3U,0x0A175524,-0x1.Dp-1,0x37,-5,0x295B},{{37,345,62,14852,-251,-0,-8890},0,3U,0x0A175524,-0x1.Dp-1,0x37,-5,0x295B},{{37,345,62,14852,-251,-0,-8890},0,3U,0x0A175524,-0x1.Dp-1,0x37,-5,0x295B}},{{{17,75,144,-6997,120,0,-9277},0x72CE6AA6,0xA2ED1A2A,0xA7F0C487,0x7.5A5224p+30,0x53,0x5E,65535U},{{17,75,144,-6997,120,0,-9277},0x72CE6AA6,0xA2ED1A2A,0xA7F0C487,0x7.5A5224p+30,0x53,0x5E,65535U},{{17,75,144,-6997,120,0,-9277},0x72CE6AA6,0xA2ED1A2A,0xA7F0C487,0x7.5A5224p+30,0x53,0x5E,65535U},{{17,75,144,-6997,120,0,-9277},0x72CE6AA6,0xA2ED1A2A,0xA7F0C487,0x7.5A5224p+30,0x53,0x5E,65535U},{{17,75,144,-6997,120,0,-9277},0x72CE6AA6,0xA2ED1A2A,0xA7F0C487,0x7.5A5224p+30,0x53,0x5E,65535U}}};
static struct S1 *g_178 = &g_179[0][1];
static int32_t g_227 = (-9);
static struct S1 g_310 = {{32,361,89,-26153,-392,-0,9254},-6,0xF3FEC6A3,0xFF9E5C04,0x0.1C507Ep+24,0x3E,-6,5U};/* VOLATILE GLOBAL g_310 */
static int32_t g_335 = 1;
static int16_t g_336 = 0xE775;
static int32_t g_337[7] = {(-9),(-9),(-9),(-9),(-9),(-9),(-9)};
static int32_t g_342 = 3;


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_27(void);
inline static uint32_t  func_42(int32_t  p_43);
static int32_t  func_58(uint16_t  p_59, const float * p_60, uint16_t  p_61, uint32_t  p_62);
static int32_t * const  func_65(int8_t  p_66);
static int32_t * func_74(int16_t  p_75);
inline static uint16_t  func_94(float  p_95, int8_t  p_96, uint32_t  p_97, float  p_98);
static uint16_t * func_112(int8_t  p_113, uint32_t  p_114, uint32_t * const  p_115);
inline static int8_t  func_116(uint32_t * p_117);
inline static int32_t  func_120(float * p_121, float ** const  p_122, uint16_t * const  p_123, int32_t  p_124);
inline static uint16_t * const  func_126(int16_t * p_127, float * p_128, uint16_t  p_129, int16_t  p_130);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_31 g_30 g_29 g_55 g_70 g_48 g_109 g_108 g_158 g_64 g_45 g_144
 * writes: g_8 g_29 g_31 g_41 g_48 g_55 g_109 g_335 g_336 g_337 g_45 g_69 g_144
 */
inline static int16_t  func_27(void)
{ /* block id: 36 */
    int32_t l_28[9][6] = {{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5},{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5},{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5},{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5},{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5},{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5},{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5},{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5},{0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5,0xE19F23E5}};
    float *l_254[7][7] = {{(void*)0,&g_48[0],(void*)0,&g_48[0],&g_48[0],&g_48[0],&g_48[0]},{&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0]},{&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0]},{(void*)0,&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0]},{&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0]},{&g_48[0],&g_48[0],&g_48[0],&g_48[0],&g_48[0],(void*)0,&g_48[0]},{(void*)0,&g_48[0],&g_48[0],&g_48[0],&g_48[0],(void*)0,&g_48[0]}};
    int16_t l_302 = (-3);
    struct S1 *l_309 = &g_310;
    uint32_t l_318[8][4] = {{0x8DF0F728,4294967295U,4294967295U,0x8DF0F728},{4294967295U,0x8DF0F728,0x8B2F874E,1U},{4294967295U,0x8B2F874E,4294967295U,0x88EBBB52},{0x8DF0F728,1U,0x88EBBB52,0x88EBBB52},{0x8B2F874E,0x8B2F874E,0x72AB70C2,1U},{1U,0x8DF0F728,0x72AB70C2,0x8DF0F728},{0x8B2F874E,4294967295U,0x88EBBB52,0x72AB70C2},{0x8DF0F728,4294967295U,4294967295U,0x8DF0F728}};
    uint32_t *l_355 = &g_8;
    uint32_t **l_354 = &l_355;
    int i, j;
    for (g_8 = 0; (g_8 <= 5); g_8 += 1)
    { /* block id: 39 */
        float l_38 = (-0x1.5p+1);
        int32_t l_57 = (-1);
        int32_t l_270 = 0xAA5BAC8D;
        int32_t l_271[4][10][6] = {{{0,0xE355F6F7,5,0x9134BECE,0x387B3942,(-3)},{0x387D95BD,0,0x22DBC187,0xA35BAF04,0x02853F57,0x39E502F8},{(-2),0x70421DA1,0x67EC7303,0x491BDF67,0x88D00478,0},{0,0x41AECE32,0x7DB7B880,0x7DB7B880,0x41AECE32,0},{0x64468A4D,0xE5F9E585,0x1D817BE3,(-9),1,0},{(-1),0x9134BECE,6,0xBA43773C,0x00B51BC1,(-1)},{(-1),5,0xBA43773C,(-9),0,1},{0x64468A4D,1,0xF279EA1C,0x7DB7B880,1,0xE5F9E585},{0,0x93415F8F,0x00B51BC1,0x491BDF67,0x01CF61BE,0x07FCD2D7},{(-2),4,0xE355F6F7,0xA35BAF04,0x187F322E,0x1D817BE3}},{{0x387D95BD,0x00B51BC1,5,0x9134BECE,(-2),(-2)},{0,0,(-1),0x70421DA1,1,0x02853F57},{(-9),(-2),0x33707525,(-7),(-10),0xA35BAF04},{0x39E502F8,0x187F322E,(-1),0x187F322E,0x39E502F8,1},{0x59372C8F,(-1),0x387D95BD,0x02853F57,0x07FCD2D7,0},{(-7),0x64468A4D,0x01CF61BE,(-1),0x93415F8F,0},{0,(-9),0x387D95BD,5,0xE355F6F7,1},{0x93415F8F,(-3),(-1),5,0,0xA35BAF04},{0x22DBC187,0x3DCB5FB8,0x33707525,0x7DDA2134,(-3),0x02853F57},{1,0x39E502F8,(-1),6,0x59372C8F,(-2)}},{{0x7DDA2134,0x7DB7B880,5,0,0x9F5E573C,0x1D817BE3},{0x02853F57,0x0DB0851E,0xE355F6F7,0x64468A4D,(-1),0x07FCD2D7},{0x0DB0851E,(-1),0x00B51BC1,(-1),0xE5F9E585,0xE5F9E585},{0x67EC7303,0xF279EA1C,0xF279EA1C,0x67EC7303,5,1},{1,(-10),0xBA43773C,0xE5F9E585,(-9),(-1)},{0,0x387D95BD,6,0x33707525,(-9),0},{0x9134BECE,(-1),0xE355F6F7,0,0x70421DA1,0},{(-1),0xA35BAF04,0x01CF61BE,5,0x1D817BE3,0x02853F57},{5,0x9F5E573C,5,0x59372C8F,0x33707525,0},{(-1),0x3DCB5FB8,(-2),6,0x0DB0851E,0xB84A3F23}},{{0,0x01CF61BE,0xBA43773C,0x491BDF67,0x187F322E,(-1)},{0x07FCD2D7,0,0x59372C8F,(-9),0xB84A3F23,0x64468A4D},{5,0,0x187F322E,0x0DB0851E,0x59372C8F,0x0DB0851E},{0x1D817BE3,0xB84A3F23,0x1D817BE3,0x41AECE32,(-1),0x59372C8F},{0x01CF61BE,(-2),(-1),0,1,0},{0x70421DA1,(-1),0,0,5,0x41AECE32},{0x01CF61BE,0x39E502F8,(-10),0x41AECE32,0,(-3)},{0x1D817BE3,0x387D95BD,1,0x0DB0851E,(-1),(-1)},{5,0x7DB7B880,0x491BDF67,(-9),(-10),0x187F322E},{0x07FCD2D7,0x59372C8F,0x22DBC187,0x491BDF67,1,(-1)}}};
        int32_t l_275 = (-1);
        int8_t l_276[3];
        uint32_t *l_288 = (void*)0;
        int32_t **l_300 = &g_109;
        int32_t *l_314[5][6] = {{&l_270,&g_55[1][2][3],&l_270,&l_270,&g_55[1][2][3],&l_270},{&l_270,&g_55[1][2][3],&l_270,&l_270,&g_55[1][2][3],&l_270},{&l_270,&g_55[1][2][3],&l_270,&l_270,&g_55[1][2][3],&l_270},{&l_270,&g_55[1][2][3],&l_270,&l_270,&g_55[1][2][3],&l_270},{&l_270,&g_55[1][2][3],&l_270,&l_270,&g_55[1][2][3],&l_270}};
        float * const *l_332 = &l_254[6][3];
        float * const **l_331[7][2][3] = {{{&l_332,(void*)0,&l_332},{&l_332,&l_332,(void*)0}},{{&l_332,&l_332,&l_332},{&l_332,(void*)0,&l_332}},{{&l_332,&l_332,(void*)0},{&l_332,&l_332,&l_332}},{{&l_332,(void*)0,&l_332},{&l_332,&l_332,(void*)0}},{{&l_332,&l_332,&l_332},{&l_332,(void*)0,&l_332}},{{&l_332,&l_332,(void*)0},{&l_332,&l_332,&l_332}},{{&l_332,(void*)0,&l_332},{&l_332,&l_332,(void*)0}}};
        int8_t l_338 = 0;
        int16_t l_341 = 1;
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_276[i] = 9;
        for (g_29 = 0; (g_29 <= 5); g_29 += 1)
        { /* block id: 42 */
            int32_t l_39 = 0x0C857617;
            int16_t *l_53 = &g_50[6][5];
            int32_t *l_56 = &g_55[1][2][3];
            struct S1 **l_237 = &g_178;
            uint32_t l_313[4][3][10] = {{{0x90B672C7,1U,4294967295U,4294967295U,4294967295U,0x107A1075,1U,1U,4294967290U,4294967290U},{1U,0x0C2E2896,0x107A1075,4294967292U,4294967292U,0x107A1075,0x0C2E2896,1U,4294967295U,1U},{0x90B672C7,4294967295U,0x72C20F67,1U,0x322F5E96,4294967292U,0x6EAC7139,1U,0x6EAC7139,4294967292U}},{{0xAB64B319,0x322F5E96,0x72C20F67,0x322F5E96,0xAB64B319,1U,0x90B672C7,4294967295U,0x6EAC7139,4294967295U},{0x90B672C7,9U,4294967295U,0x72C20F67,4294967292U,4294967295U,4294967295U,4294967292U,0x72C20F67,4294967295U},{0x72C20F67,0x72C20F67,0x0C2E2896,4294967295U,0U,4294967290U,4294967292U,1U,1U,0xAB64B319}},{{1U,0x322F5E96,4294967292U,0x6EAC7139,1U,0x6EAC7139,4294967292U,0x322F5E96,1U,0x72C20F67},{9U,0x72C20F67,1U,0U,0xAB64B319,0x107A1075,4294967295U,1U,1U,4294967295U},{0x322F5E96,9U,0U,0U,9U,0x322F5E96,0x90B672C7,0x107A1075,1U,4294967290U}},{{4294967290U,1U,0x72C20F67,0x6EAC7139,1U,0x0C2E2896,0x322F5E96,0x0C2E2896,1U,0x6EAC7139},{4294967290U,0x0C2E2896,4294967290U,4294967295U,4294967295U,0x322F5E96,0x6EAC7139,0xAB64B319,0x72C20F67,0x107A1075},{0x322F5E96,0x6EAC7139,0xAB64B319,0x72C20F67,0x107A1075,0x107A1075,0x72C20F67,0xAB64B319,0x6EAC7139,0x322F5E96}}};
            int i, j, k;
            for (g_31[4] = 5; (g_31[4] >= 0); g_31[4] -= 1)
            { /* block id: 45 */
                uint32_t *l_40 = &g_41;
                int16_t *l_49[9];
                int32_t l_51 = 0x63F3734B;
                int32_t *l_54 = &g_55[1][2][3];
                int i, j;
                for (i = 0; i < 9; i++)
                    l_49[i] = &g_50[6][5];
                (*l_54) |= ((safe_rshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_s(l_28[(g_31[4] + 1)][g_31[4]], (l_51 = (safe_add_func_uint32_t_u_u((__builtin_clzll(l_39) ^ (((*l_40) = 9U) & g_30)), func_42(l_28[8][5])))))), (safe_unary_minus_func_uint16_t_u((g_8 | (l_53 == l_53)))))) | g_29);
                (*l_54) ^= 0x817BB5C0;
            }
            (*l_56) ^= __builtin_clzl(l_28[(g_8 + 3)][g_8]);
        }
        (*l_300) = l_314[3][4];
        /* statement id: 211 */
        assert (g_109 == &l_270 || (g_109 >= &g_31[0] && g_109 <= &g_31[5]) || (g_109 >= &g_55[0][0][0] && g_109 <= &g_55[1][5][4]));
        for (l_57 = 5; (l_57 >= 0); l_57 -= 1)
        { /* block id: 214 */
            int32_t l_339[6] = {0x8856C5A7,0x8856C5A7,0x8856C5A7,0x8856C5A7,0x8856C5A7,0x8856C5A7};
            int8_t l_343 = 0xFF;
            uint16_t l_344 = 65527U;
            uint32_t **l_356 = &l_288;
            uint16_t * const l_358 = &g_64[7];
            int i, j;
            (*g_70) = ((!l_28[g_8][g_8]) > (safe_add_func_float_f_f(((l_318[6][0] > (safe_sub_func_float_f_f(((safe_sub_func_float_f_f((*g_70), ((g_337[4] = (safe_add_func_float_f_f((g_336 = (safe_add_func_float_f_f(((safe_sub_func_float_f_f((*g_70), (g_335 = (safe_sub_func_float_f_f(((__builtin_popcount((7 || (&g_144 != l_331[0][1][0]))) == (safe_add_func_float_f_f((l_302 != (**l_300)), l_28[7][0]))) == (**l_300)), l_28[g_8][g_8]))))) == 0xC.E58BCAp+60), 0x1.7p-1))), l_28[2][4]))) < l_302))) > 0xC.1F9464p+73), (*g_70)))) != (-0x1.7p+1)), l_302)));
            if ((*g_109))
                continue;
            for (g_45 = 0; (g_45 <= 5); g_45 += 1)
            { /* block id: 222 */
                int32_t l_340[6][2] = {{1,8},{0,8},{1,0},{0x776B1995,0x776B1995},{0x776B1995,0},{1,8}};
                uint32_t **l_352 = (void*)0;
                uint32_t ***l_353[5] = {&l_352,&l_352,&l_352,&l_352,&l_352};
                int i, j;
                l_344--;
                if ((**g_108))
                    continue;
                l_340[5][1] ^= func_120(((*g_144) = func_74(__builtin_parityl((safe_unary_minus_func_uint32_t_u((safe_mod_func_int32_t_s_s((l_28[(g_45 + 1)][g_45] &= (safe_lshift_func_uint16_t_u_u((((&l_288 == (l_356 = (l_354 = l_352))) & 2) | ((*g_109) > 0x09A4EDE9)), (!(*g_158))))), 0x2E93A806))))))), &g_70, l_358, l_318[1][0]);
                /* statement id: 229 */
                assert ((g_69 >= &g_55[0][0][0] && g_69 <= &g_55[1][5][4]));
                assert (l_354 == 0);
                assert (l_356 == 0);
            }
            /* facts after for loop */
            assert (l_356 == 0 || l_356 == &l_288);
            l_28[(l_57 + 2)][g_8] = 0x9450E936;
        }
    }
    /* facts after for loop */
    assert ((g_69 >= &g_55[0][0][0] && g_69 <= &g_55[1][5][4]) || g_69 == 0);
    //assert (g_109 == dangling || (g_109 >= &g_31[0] && g_109 <= &g_31[5]) || (g_109 >= &g_55[0][0][0] && g_109 <= &g_55[1][5][4]));
    assert (l_354 == 0 || l_354 == &l_355);
    return l_28[3][0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_48
 */
inline static uint32_t  func_42(int32_t  p_43)
{ /* block id: 47 */
    uint32_t *l_44 = &g_45;
    float *l_46 = (void*)0;
    float *l_47 = &g_48[0];
    (*l_47) = (l_44 != &g_45);
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_45 g_50 g_108 g_8 g_31 g_109 g_150 g_64 g_158 g_178 g_179.f7 g_179.f2 g_179.f0.f0
 * writes: g_69 g_70 g_45 g_50 g_48 g_55 g_41 g_144 g_109 g_148 g_150 g_158 g_178 g_64
 */
static int32_t  func_58(uint16_t  p_59, const float * p_60, uint16_t  p_61, uint32_t  p_62)
{ /* block id: 58 */
    int32_t **l_234 = &g_109;
    const int32_t *l_236 = (void*)0;
    const int32_t **l_235 = &l_236;
    (*l_234) = func_65(g_55[0][3][4]);
    /* statement id: 141 */
    assert (g_70 == 0);
    assert ((g_109 >= &g_55[0][0][0] && g_109 <= &g_55[1][5][4]) || g_109 == 0);
    (*l_235) = p_60;
    /* statement id: 142 */
    assert ((l_236 >= &g_55[0][0][0] && l_236 <= &g_55[1][5][4]));
    (*l_235) = (*l_235);
    return (*l_236);
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_55 g_50 g_108 g_8 g_31 g_109 g_150 g_64 g_158 g_178 g_179.f7 g_179.f2 g_179.f0.f0
 * writes: g_69 g_70 g_45 g_50 g_48 g_55 g_41 g_144 g_109 g_148 g_150 g_158 g_178 g_64
 */
static int32_t * const  func_65(int8_t  p_66)
{ /* block id: 59 */
    float *l_68 = &g_48[0];
    float **l_67[5][5][7] = {{{&l_68,(void*)0,&l_68,&l_68,&l_68,&l_68,&l_68},{&l_68,&l_68,(void*)0,(void*)0,(void*)0,&l_68,&l_68},{&l_68,&l_68,&l_68,&l_68,&l_68,(void*)0,&l_68},{&l_68,&l_68,(void*)0,&l_68,&l_68,(void*)0,&l_68},{&l_68,&l_68,&l_68,&l_68,&l_68,&l_68,&l_68}},{{&l_68,&l_68,&l_68,&l_68,&l_68,(void*)0,(void*)0},{&l_68,&l_68,&l_68,&l_68,(void*)0,(void*)0,&l_68},{&l_68,&l_68,&l_68,&l_68,(void*)0,(void*)0,(void*)0},{&l_68,&l_68,&l_68,(void*)0,&l_68,(void*)0,&l_68},{&l_68,(void*)0,(void*)0,(void*)0,&l_68,(void*)0,(void*)0}},{{&l_68,&l_68,&l_68,&l_68,&l_68,(void*)0,&l_68},{&l_68,(void*)0,(void*)0,&l_68,&l_68,(void*)0,(void*)0},{(void*)0,&l_68,&l_68,&l_68,&l_68,&l_68,&l_68},{(void*)0,&l_68,(void*)0,(void*)0,(void*)0,&l_68,&l_68},{&l_68,&l_68,&l_68,&l_68,(void*)0,&l_68,&l_68}},{{&l_68,&l_68,&l_68,(void*)0,&l_68,&l_68,&l_68},{&l_68,&l_68,&l_68,&l_68,&l_68,&l_68,&l_68},{(void*)0,&l_68,&l_68,&l_68,(void*)0,&l_68,&l_68},{(void*)0,(void*)0,(void*)0,&l_68,&l_68,&l_68,&l_68},{(void*)0,&l_68,(void*)0,&l_68,(void*)0,&l_68,(void*)0}},{{&l_68,&l_68,&l_68,(void*)0,&l_68,&l_68,&l_68},{&l_68,&l_68,&l_68,&l_68,(void*)0,&l_68,(void*)0},{&l_68,&l_68,&l_68,(void*)0,(void*)0,&l_68,&l_68},{(void*)0,&l_68,&l_68,&l_68,&l_68,&l_68,(void*)0},{&l_68,&l_68,(void*)0,&l_68,&l_68,(void*)0,&l_68}}};
    float * const l_71 = &g_48[0];
    int32_t l_101 = 0xAC62AC5C;
    int32_t **l_110[6] = {&g_109,(void*)0,&g_109,&g_109,(void*)0,&g_109};
    uint16_t l_210 = 1U;
    uint16_t l_231 = 0xFB05;
    int i, j, k;
    if (((g_70 = (g_69 = (void*)0)) != l_71))
    { /* block id: 62 */
        int8_t l_105 = (-1);
        int32_t l_177[1][1][10] = {{{(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)}}};
        struct S1 *l_181 = (void*)0;
        int32_t l_192 = 0x18ADAF65;
        int32_t l_193 = (-1);
        int i, j, k;
        for (g_45 = (-18); (g_45 == 45); g_45 = safe_add_func_uint32_t_u_u(g_45, 7))
        { /* block id: 65 */
            int32_t *l_89 = (void*)0;
            int32_t **l_88 = &l_89;
            int16_t *l_102 = &g_50[6][5];
            int32_t l_190 = (-5);
            int32_t l_191[7][9] = {{0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31},{0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34},{0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31},{0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34},{0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31},{0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34,0xA9FA5B34},{0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31,0xC345CE31}};
            uint16_t l_194 = 0xF7DE;
            int i, j;
            (*l_88) = func_74(p_66);
            /* statement id: 69 */
            assert ((l_89 >= &g_55[0][0][0] && l_89 <= &g_55[1][5][4]));
            if ((l_177[0][0][5] ^= (safe_mod_func_int32_t_s_s(0x3BF82D50, (safe_mod_func_uint16_t_u_u(func_94((**l_88), ((safe_mul_func_int16_t_s_s(((*l_102) &= (l_101 > (-1))), ((safe_mul_func_uint16_t_u_u((((p_66 < l_105) && 8U) & ((safe_mul_func_int16_t_s_s((g_108 != l_110[4]), 0x1217)) && 2U)), g_45)) || p_66))) || p_66), p_66, (**l_88)), l_105))))))
            { /* block id: 112 */
                struct S1 **l_180 = &g_178;
                int32_t l_188[1];
                uint32_t *l_189 = &g_8;
                int i;
                for (i = 0; i < 1; i++)
                    l_188[i] = 0;
                l_181 = ((*l_180) = g_178);
                /* statement id: 114 */
                assert ((l_181 >= &g_179[0][0] && l_181 <= &g_179[1][4]));
                (*g_109) = (**g_108);
                g_109 = func_74(((safe_sub_func_int32_t_s_s((l_188[0] = ((**g_108) = (safe_lshift_func_uint16_t_u_u(((safe_mul_func_int16_t_s_s(g_179[0][1].f7, g_55[0][4][3])) <= p_66), 4)))), 0xC0A512BF)) == ((&g_150 == l_189) >= 0x7896BA19)));
            }
            else
            { /* block id: 119 */
                return (*g_108);
                /* statement id: 120 */
                //assert ((func_65_rv >= &g_55[0][0][0] && func_65_rv <= &g_55[1][5][4]));
            }
            /* facts after branching */
            assert ((l_181 >= &g_179[0][0] && l_181 <= &g_179[1][4]));
            l_194++;
            if ((p_66 & ((safe_sub_func_int16_t_s_s(0xED04, (&g_64[2] == (void*)0))) ^ (safe_mul_func_int16_t_s_s((((((*g_158) && l_177[0][0][3]) > (**g_108)) || ((*g_158)--)) & (safe_rshift_func_uint16_t_u_u(65530U, ((~((safe_sub_func_int32_t_s_s((safe_sub_func_int32_t_s_s(0xD4B14A06, l_210)), p_66)) == p_66)) & p_66)))), p_66)))))
            { /* block id: 124 */
                float * const *l_212 = (void*)0;
                float * const **l_211 = &l_212;
                float * const * const *l_220 = &l_212;
                float * const * const **l_219 = &l_220;
                float * const * const ***l_221 = &l_219;
                float * const * const **l_223 = &l_220;
                float * const * const ***l_222 = &l_223;
                (**l_88) = ((p_66 >= (p_66 > (g_179[0][1].f2 && (((*l_211) = &l_68) != (void*)0)))) <= ((l_177[0][0][5] &= g_179[0][1].f0.f0) != (safe_mul_func_int16_t_s_s((safe_sub_func_uint32_t_u_u((**l_88), (safe_sub_func_int16_t_s_s(((((*l_102) = g_45) | ((p_66 != (**g_108)) & 1U)) >= p_66), 0x9E56)))), 9))));
                /* statement id: 128 */
                assert (l_212 == 0 || l_212 == &l_68);
                (*l_222) = ((*l_221) = l_219);
            }
            else
            { /* block id: 131 */
                return (*g_108);
                /* statement id: 132 */
                //assert ((func_65_rv >= &g_55[0][0][0] && func_65_rv <= &g_55[1][5][4]));
            }
        }
        /* facts after for loop */
        assert ((l_181 >= &g_179[0][0] && l_181 <= &g_179[1][4]) || l_181 == 0);
        g_109 = (void*)0;
        /* statement id: 135 */
        assert (g_109 == 0);
    }
    else
    { /* block id: 136 */
        struct S1 *l_224[1][3];
        int32_t l_225 = 0;
        int32_t l_226 = 0x954E7B07;
        int32_t l_228 = 0x3C4206CA;
        int32_t l_229 = 0x8E79C5C2;
        int32_t l_230 = (-4);
        int i, j;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 3; j++)
                l_224[i][j] = &g_179[1][2];
        }
        (*l_71) = (l_224[0][0] != (void*)0);
        l_231++;
    }
    /* facts after branching */
    assert (g_70 == 0);
    assert ((g_109 >= &g_55[0][0][0] && g_109 <= &g_55[1][5][4]) || g_109 == 0);
    return (*g_108);
    /* statement id: 140 */
    //assert ((func_65_rv >= &g_55[0][0][0] && func_65_rv <= &g_55[1][5][4]) || func_65_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_74(int16_t  p_75)
{ /* block id: 66 */
    int32_t *l_76 = &g_55[0][0][2];
    int32_t *l_77 = &g_31[4];
    int32_t *l_78[4] = {&g_55[1][2][3],&g_55[1][2][3],&g_55[1][2][3],&g_55[1][2][3]};
    int32_t l_79 = 0x16B4C8AB;
    int32_t l_80 = 0xAF0D9658;
    int8_t l_82 = 2;
    int32_t l_83 = 6;
    int32_t l_84 = 0x0CD53C73;
    uint32_t l_85 = 1U;
    int i;
    l_85--;
    return &g_55[1][3][4];
    /* statement id: 68 */
    //assert ((func_74_rv >= &g_55[0][0][0] && func_74_rv <= &g_55[1][5][4]));
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_31 g_55 g_108 g_109 g_50 g_41 g_150 g_64 g_158
 * writes: g_48 g_55 g_41 g_144 g_109 g_148 g_150 g_158
 */
inline static uint16_t  func_94(float  p_95, int8_t  p_96, uint32_t  p_97, float  p_98)
{ /* block id: 71 */
    uint16_t *l_111[9][1][5] = {{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}},{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}},{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}},{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}},{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}},{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}},{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}},{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}},{{&g_64[1],&g_64[1],&g_64[1],&g_64[1],&g_64[1]}}};
    uint32_t *l_118[4];
    int8_t *l_147 = &g_148;
    uint32_t *l_149 = &g_150;
    float *l_159 = &g_48[0];
    int32_t l_169 = (-6);
    int32_t l_170[6][7] = {{0x4343CAFA,9,1,1,0xDCBB3E87,(-1),0x86E15FCF},{0xB06FFBB3,(-1),(-1),1,(-1),(-1),0xB06FFBB3},{(-4),0xB06FFBB3,(-1),1,1,0x86E15FCF,1},{0x164AEADB,0xF426AAB0,0x51996EC3,1,(-4),0xDCBB3E87,0xDCBB3E87},{0x51996EC3,0x5D945D53,(-1),0x5D945D53,0x51996EC3,0x4343CAFA,9},{9,0x5D945D53,(-1),0xB06FFBB3,1,2,(-4)}};
    int16_t l_171[6][10][4] = {{{0xF983,0x557D,0xC628,0xB684},{0x758B,0xD343,0x423A,0x8F0A},{(-7),(-1),1,0x8D22},{(-1),(-1),0x30B6,0x3399},{0x8114,0x7953,0x9544,0x7953},{0xE834,1,0xF861,(-1)},{(-7),0,0x5F7E,0xD47E},{0xC628,0x0BA2,1,(-5)},{0xC628,0x58A2,0x5F7E,0x30B6},{(-7),(-5),0xF861,0x43D2}},{{0xE834,(-1),0x9544,1},{0x8114,0x46CA,0x30B6,0x3DD7},{(-1),0xCF54,1,0},{(-7),(-1),0x423A,0xF983},{0x758B,(-1),0xC628,6},{0xF983,0x3009,0x557D,(-1)},{0xB148,0xEF5F,(-1),0x7F10},{0x423A,0xE834,0x7F10,1},{0xCAB4,0,0xB148,0xF1EA},{0x995B,0,(-8),(-1)}},{{0xD343,0x43D2,(-5),0x331D},{1,5,0x5E74,0x0BA2},{(-10),(-1),(-1),(-8)},{0xFDBE,0xF983,0x87E6,0x14A4},{0x58A2,0xB604,0xFDBE,0x3A58},{5,(-1),0xD47E,0x767E},{0x3F33,0xDD38,(-3),(-1)},{0x11DF,(-8),0x758B,0x557D},{(-1),(-1),1,0xDD38},{0x8F0A,0x14A4,0x41FB,5}},{{0,1,1,0},{0x8D22,0x0BA2,0x58A2,0x767E},{5,0xB684,0x8114,0xEF5F},{1,0,0x9544,0xEF5F},{0x3DD7,0xB684,0xCEAC,0x767E},{0x2515,0x0BA2,8,0},{0x758B,1,0x43D2,0x7F10},{5,1,0x3921,0xF912},{0x3A58,0x3DD7,0xEF5F,0xD47E},{7,0x6152,0xA8F4,0x3921}},{{0x6A3D,0xF912,(-1),(-8)},{1,0x3009,0x46CA,(-1)},{(-1),0x8D22,0x209A,1},{0,0xCAB4,0xDE8A,0x6152},{(-1),0x46CA,0x3DD7,8},{6,0x7F10,0xCAB4,0xF1EA},{1,0x7953,(-1),0x557D},{0xD47E,0xC628,0x91A3,1},{0x6152,0x995B,0x331D,(-1)},{0x6718,0x91A3,6,(-7)}},{{0xE834,(-1),0xC628,5},{0xF1EA,0x6718,0xDD45,0xB148},{(-1),(-1),(-1),0xCAB4},{(-1),(-1),2,(-1)},{0xD343,0xEF5F,0x7F10,0x2515},{0x5E74,0xA5A2,1,(-7)},{0xB604,0x8FF8,0xB604,0x7953},{(-1),0x11DF,0x3F33,0x4309},{0x995B,(-5),0x3399,0x11DF},{0x46CA,8,0x3399,(-1)}}};
    int8_t l_173 = 1;
    int i, j, k;
    for (i = 0; i < 4; i++)
        l_118[i] = &g_41;
    (*l_159) = (l_111[0][0][2] == (g_158 = func_112(((*l_147) = func_116(l_118[3])), (++(*l_149)), func_74((safe_mul_func_uint16_t_u_u(g_64[8], p_96))))));
    for (g_41 = (-30); (g_41 != 26); g_41 = safe_add_func_int32_t_s_s(g_41, 7))
    { /* block id: 105 */
        int32_t *l_162 = (void*)0;
        int32_t *l_163 = &g_31[0];
        int32_t *l_164 = &g_31[4];
        int32_t *l_165 = &g_55[1][2][3];
        int32_t *l_166 = (void*)0;
        int32_t *l_167 = &g_55[0][5][0];
        int32_t *l_168[10] = {&g_31[4],&g_31[4],&g_55[0][5][0],&g_55[0][5][0],&g_31[4],&g_31[4],&g_31[4],&g_55[0][5][0],&g_55[0][5][0],&g_31[4]};
        int16_t l_172 = 7;
        uint32_t l_174[6] = {0xAE6DF44F,0xAE6DF44F,0xAE6DF44F,0xAE6DF44F,0xAE6DF44F,0xAE6DF44F};
        int i;
        l_174[5]--;
    }
    (*g_109) |= (&l_159 == &l_159);
    (*g_109) |= (__builtin_popcount((0xC9770E6C & (0x61A26EF9 || ((void*)0 == l_159)))) < ((l_111[0][0][0] != l_111[0][0][2]) && l_173));
    return (*g_158);
}


/* ------------------------------------------ */
/* 
 * reads : g_108 g_109 g_55
 * writes: g_55
 */
static uint16_t * func_112(int8_t  p_113, uint32_t  p_114, uint32_t * const  p_115)
{ /* block id: 97 */
    uint32_t *l_156 = &g_150;
    uint32_t **l_155 = &l_156;
    uint16_t *l_157 = &g_64[1];
    (**g_108) ^= (((*l_155) = (void*)0) == (void*)0);
    /* statement id: 99 */
    assert (l_156 == 0);
    return l_157;
    /* statement id: 100 */
    //assert ((func_112_rv >= &g_64[0] && func_112_rv <= &g_64[8]));
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_31 g_55 g_108 g_109 g_50 g_41
 * writes: g_48 g_55 g_41 g_144 g_109
 */
inline static int8_t  func_116(uint32_t * p_117)
{ /* block id: 72 */
    float ** const l_125 = &g_70;
    int16_t *l_131 = &g_50[1][2];
    int32_t l_132[1];
    int32_t l_145 = 0xA9791142;
    int32_t **l_146 = &g_109;
    int i;
    for (i = 0; i < 1; i++)
        l_132[i] = 9;
    (*l_146) = func_74((safe_unary_minus_func_int32_t_s((l_145 &= __builtin_clzl(func_42(((*g_109) = func_120(p_117, l_125, func_126(l_131, func_74(func_42(l_132[0])), l_132[0], l_132[0]), l_132[0]))))))));
    return g_31[4];
}


/* ------------------------------------------ */
/* 
 * reads : g_41 g_109 g_55 g_31
 * writes: g_41 g_144
 */
inline static int32_t  func_120(float * p_121, float ** const  p_122, uint16_t * const  p_123, int32_t  p_124)
{ /* block id: 79 */
    float **l_143 = &g_70;
    float ***l_142[2][3][6] = {{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}}};
    int i, j, k;
    for (g_41 = (-21); (g_41 < 13); g_41++)
    { /* block id: 82 */
        for (p_124 = 0; (p_124 != (-26)); p_124 = safe_sub_func_int32_t_s_s(p_124, 1))
        { /* block id: 85 */
            return (*g_109);
        }
    }
    g_144 = &g_69;
    return (*g_109);
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_31 g_55 g_108 g_109 g_50
 * writes: g_55 g_48
 */
inline static uint16_t * const  func_126(int16_t * p_127, float * p_128, uint16_t  p_129, int16_t  p_130)
{ /* block id: 73 */
    float **l_133 = (void*)0;
    int32_t l_136 = 0xD722C878;
    int32_t l_137 = 0x49CB1593;
    (*p_128) = ((void*)0 != l_133);
    l_137 = ((safe_sub_func_float_f_f((l_136 = func_42(((__builtin_ctzll(l_136) ^ (g_31[4] < g_55[0][1][0])) > (((**g_108) > g_50[5][3]) | 1U)))), l_137)) == l_137);
    (*p_128) = l_137;
    return &g_64[6];
    /* statement id: 78 */
    //assert ((func_126_rv >= &g_64[0] && func_126_rv <= &g_64[8]));
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_29, "g_29", print_hash_value);
    transparent_crc(g_30, "g_30", print_hash_value);
    for (i = 0; i < 6; i++)
    {
        transparent_crc(g_31[i], "g_31[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_41, "g_41", print_hash_value);
    transparent_crc(g_45, "g_45", print_hash_value);
    for (i = 0; i < 1; i++)
    {
        transparent_crc_bytes(&g_48[i], sizeof(g_48[i]), "g_48[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc(g_50[i][j], "g_50[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 6; j++)
        {
            for (k = 0; k < 5; k++)
            {
                transparent_crc(g_55[i][j][k], "g_55[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    for (i = 0; i < 9; i++)
    {
        transparent_crc(g_64[i], "g_64[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_81, "g_81", print_hash_value);
    transparent_crc(g_148, "g_148", print_hash_value);
    transparent_crc(g_150, "g_150", print_hash_value);
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 5; j++)
        {
            transparent_crc(g_179[i][j].f0.f0, "g_179[i][j].f0.f0", print_hash_value);
            transparent_crc(g_179[i][j].f0.f1, "g_179[i][j].f0.f1", print_hash_value);
            transparent_crc(g_179[i][j].f0.f2, "g_179[i][j].f0.f2", print_hash_value);
            transparent_crc(g_179[i][j].f0.f3, "g_179[i][j].f0.f3", print_hash_value);
            transparent_crc(g_179[i][j].f0.f4, "g_179[i][j].f0.f4", print_hash_value);
            transparent_crc(g_179[i][j].f0.f5, "g_179[i][j].f0.f5", print_hash_value);
            transparent_crc(g_179[i][j].f0.f6, "g_179[i][j].f0.f6", print_hash_value);
            transparent_crc(g_179[i][j].f1, "g_179[i][j].f1", print_hash_value);
            transparent_crc(g_179[i][j].f2, "g_179[i][j].f2", print_hash_value);
            transparent_crc(g_179[i][j].f3, "g_179[i][j].f3", print_hash_value);
            transparent_crc_bytes(&g_179[i][j].f4, sizeof(g_179[i][j].f4), "g_179[i][j].f4", print_hash_value);
            transparent_crc(g_179[i][j].f5, "g_179[i][j].f5", print_hash_value);
            transparent_crc(g_179[i][j].f6, "g_179[i][j].f6", print_hash_value);
            transparent_crc(g_179[i][j].f7, "g_179[i][j].f7", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_227, "g_227", print_hash_value);
    transparent_crc(g_310.f0.f0, "g_310.f0.f0", print_hash_value);
    transparent_crc(g_310.f0.f1, "g_310.f0.f1", print_hash_value);
    transparent_crc(g_310.f0.f2, "g_310.f0.f2", print_hash_value);
    transparent_crc(g_310.f0.f3, "g_310.f0.f3", print_hash_value);
    transparent_crc(g_310.f0.f4, "g_310.f0.f4", print_hash_value);
    transparent_crc(g_310.f0.f5, "g_310.f0.f5", print_hash_value);
    transparent_crc(g_310.f0.f6, "g_310.f0.f6", print_hash_value);
    transparent_crc(g_310.f1, "g_310.f1", print_hash_value);
    transparent_crc(g_310.f2, "g_310.f2", print_hash_value);
    transparent_crc(g_310.f3, "g_310.f3", print_hash_value);
    transparent_crc_bytes (&g_310.f4, sizeof(g_310.f4), "g_310.f4", print_hash_value);
    transparent_crc(g_310.f5, "g_310.f5", print_hash_value);
    transparent_crc(g_310.f6, "g_310.f6", print_hash_value);
    transparent_crc(g_310.f7, "g_310.f7", print_hash_value);
    transparent_crc(g_335, "g_335", print_hash_value);
    transparent_crc(g_336, "g_336", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        transparent_crc(g_337[i], "g_337[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_342, "g_342", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 107
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 5
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 4
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 1
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 2

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 3
   depth: 13, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 103

XXX times a variable address is taken: 183
XXX times a pointer is dereferenced on RHS: 40
breakdown:
   depth: 1, occurrence: 30
   depth: 2, occurrence: 10
XXX times a pointer is dereferenced on LHS: 56
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 2215

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 194
   level: 2, occurrence: 71
XXX number of pointers point to pointers: 40
XXX number of pointers point to scalars: 59
XXX number of pointers point to structs: 4
XXX percent of pointers has null in alias set: 28.2
XXX average alias set size: 1.31

XXX times a non-volatile is read: 269
XXX times a non-volatile is write: 166
XXX times a volatile is read: 4
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 1.15e+03
XXX percentage of non-volatile access: 99.1

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 60
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 9
   depth: 2, occurrence: 11
   depth: 3, occurrence: 12

XXX percentage a fresh-made variable is used: 15.2
XXX percentage an existing variable is used: 84.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

