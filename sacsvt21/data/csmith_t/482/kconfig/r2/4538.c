/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3573802724
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint8_t  f0;
   uint64_t  f1;
   uint64_t  f2;
   float  f3;
   uint16_t  f4;
};
#pragma pack(pop)

union U1 {
   uint8_t  f0;
   const signed f1 : 17;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_33(void);
static int16_t  func_41(uint64_t  p_42);
static uint64_t  func_43(int16_t  p_44, int32_t  p_45, int32_t  p_46, uint64_t  p_47);
static int32_t  func_49(uint64_t  p_50, int32_t  p_51, int16_t  p_52, struct S0  p_53);
static int16_t  func_59(union U1  p_60, uint64_t  p_61);
static union U1  func_62(int32_t  p_63, int64_t  p_64, uint32_t  p_65, const int64_t  p_66, uint8_t  p_67);
static const int64_t  func_70(float  p_71);
inline static int32_t * const  func_78(const uint32_t  p_79, uint16_t  p_80, uint8_t  p_81, int64_t  p_82);
inline static int32_t * func_85(int32_t ** p_86);
static int64_t  func_118(int32_t * p_119, int32_t * p_120);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_33(void)
{ /* block id: 36 */
    uint16_t l_34 = 0x5AF9L;
    uint16_t l_48 = 65535UL;
    struct S0 l_54 = {255UL,4UL,0x07DF7DC23988F15ELL,0xC.766593p-31,0UL};
    const struct S0 * const *l_400 = (void*)0;
    int32_t l_425 = 0L;
    int32_t *l_424 = &l_425;
    uint64_t l_429 = 0x3AF28B6AEAC0E24BLL;
    uint8_t l_437 = 0xD7L;
    float l_446 = (-0x1.Ap+1);
    int32_t **l_465 = (void*)0;
    int32_t ***l_464 = &l_465;
    union U1 l_468 = {0xE1L};
    union U1 *l_467 = &l_468;
    struct S0 l_526 = {253UL,0xC5488CFB3292310ELL,0x9FE0C1EAA6C8538BLL,0xF.759D44p+92,0x5244L};
    float **l_527 = (void*)0;
    uint32_t l_532 = 1UL;
    if ((l_34 > (((int16_t)(((uint16_t)l_34 << (uint16_t)12) < ((0x26595AD3380EE91BLL >= l_34) <= ((((uint16_t)l_34 << (uint16_t)1) || l_34) | l_34))) >> (int16_t)func_41(func_43(l_48, func_49((0L != l_48), l_48, l_48, l_54), l_54.f1, l_54.f2))) >= l_54.f1)))
    { /* block id: 260 */
        int32_t l_379 = 0x213A3953L;
        int32_t *l_378 = &l_379;
        struct S0 l_420 = {0UL,1UL,1UL,0x3.Ep+1,0UL};
        struct S0 *l_443 = &l_54;
        struct S0 **l_442 = &l_443;
        struct S0 ***l_441 = &l_442;
        int32_t l_497 = 0x2BDF68D6L;
        int16_t l_498 = 0x856EL;
        int64_t l_504 = 1L;
        for (l_54.f2 = 1; (l_54.f2 == 9); l_54.f2 += 1)
        { /* block id: 263 */
            int32_t l_386 = (-1L);
            uint32_t l_421 = 1UL;
            uint16_t l_422 = 0xB3DCL;
            struct S0 *l_428 = &l_54;
            struct S0 **l_440 = (void*)0;
            struct S0 ***l_439 = &l_440;
            int32_t *l_450 = &l_379;
            int32_t **l_462 = &l_450;
            int32_t ****l_494 = (void*)0;
            for (l_54.f4 = 0; (l_54.f4 <= 24); ++l_54.f4)
            { /* block id: 266 */
                int32_t **l_377 = (void*)0;
                int32_t **l_380 = &l_378;
                uint32_t l_387 = 0x6D35928AL;
                struct S0 l_388 = {0x99L,8UL,0x978B2285ED763521LL,0x3.22F22Ap+58,8UL};
                (*l_380) = l_378;
                for (l_54.f0 = (-10); (l_54.f0 < 40); ++l_54.f0)
                { /* block id: 270 */
                    const uint32_t l_383 = 0UL;
                    const int32_t *l_390 = (void*)0;
                    const int32_t **l_389 = &l_390;
                    (*l_389) = func_78(l_383, l_54.f1, ((uint16_t)(l_34 < (func_49(l_54.f4, l_386, l_387, l_388) || ((l_386 ^ (*l_378)) < 6L))) / (uint16_t)l_386), l_54.f0);
                }
            }
        }
    }
    else
    { /* block id: 313 */
        struct S0 *l_528 = &l_54;
        struct S0 **l_529 = (void*)0;
        struct S0 **l_530 = &l_528;
        float *l_531 = &l_446;
        l_527 = l_527;
        (*l_530) = l_528;
        (*l_531) = (&l_530 != &l_400);
    }
    return l_532;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_41(uint64_t  p_42)
{ /* block id: 217 */
    int32_t l_309 = 0x58B7C0F1L;
    float *l_313 = (void*)0;
    float **l_312 = &l_313;
    int32_t l_319 = (-10L);
    int32_t *l_318 = &l_319;
    int32_t **l_317 = &l_318;
    int32_t ***l_316 = &l_317;
    union U1 ***l_351 = (void*)0;
    float l_360 = 0xA.F29B83p+94;
    float *l_359 = &l_360;
    int32_t *l_361 = (void*)0;
    uint32_t l_372 = 0xDA07628FL;
    if (((l_309 & (((l_312 != &l_313) ^ (0x7A6DL >= 0UL)) || func_43(l_309, l_309, l_309, ((int64_t)(l_316 == &l_317) % (int64_t)(**l_317))))) | 0L))
    { /* block id: 218 */
        int32_t l_320 = 0x40A2A62FL;
        union U1 l_323 = {0xE7L};
        union U1 *l_322 = &l_323;
        union U1 **l_321 = &l_322;
        struct S0 l_331 = {0xDFL,0x1680D130F14CA189LL,0xC5BAC3DFB1DF5632LL,0xD.110C61p+41,0x7383L};
        int32_t *l_358 = (void*)0;
lbl_348:
        if (l_320)
        { /* block id: 219 */
            float l_325 = (-0x6.Dp+1);
            float *l_324 = &l_325;
            int32_t *l_326 = &l_323.f2;
            (*l_324) = ((void*)0 != l_321);
            l_326 = (*l_317);
            /* statement id: 221 */
            assert (l_326 == &l_319);
        }
        else
        { /* block id: 222 */
            float l_327 = 0x0.6p-1;
            int32_t l_328 = 1L;
            return l_328;
        }
        for (l_309 = (-18); (l_309 <= (-25)); l_309 -= 1)
        { /* block id: 227 */
            struct S0 l_332 = {0xA9L,0xB7FDA88B9B96571BLL,5UL,0xD.B05F66p+10,0x4B6CL};
            union U1 ** const * const l_333 = &l_321;
            float ** const *l_337 = &l_312;
            l_332 = l_331;
            if (((((***l_316) & (p_42 < (***l_316))) ^ p_42) >= (l_333 == l_333)))
            { /* block id: 229 */
                struct S0 *l_335 = &l_332;
                struct S0 **l_334 = &l_335;
                float *l_336 = &l_332.f3;
                (*l_334) = &l_332;
                (*l_317) = func_85((*l_316));
                (*l_335) = (*l_335);
                (*l_336) = l_331.f0;
            }
            else
            { /* block id: 234 */
                const float ****l_338 = (void*)0;
                float ***l_340 = &l_312;
                float ****l_339 = &l_340;
                (*l_339) = l_337;
                for (l_323.f0 = 0; (l_323.f0 <= 51); l_323.f0 += 5)
                { /* block id: 238 */
                    l_320 = (p_42 && ((uint16_t)65535UL << (uint16_t)15));
                    (**l_317) = (-(uint32_t)(-(uint64_t)(-(int64_t)((void*)0 == &l_313))));
                    if ((*l_318))
                        continue;
                }
            }
            if (l_331.f1)
                goto lbl_348;
            for (l_332.f4 = 0; (l_332.f4 >= 12); ++l_332.f4)
            { /* block id: 247 */
                union U1 *l_355 = &l_323;
                int32_t **l_356 = (void*)0;
                int32_t **l_357 = &l_318;
            }
        }
        l_358 = func_85((*l_316));
        /* statement id: 251 */
        assert (l_358 == &l_319);
        (**l_316) = func_85(&l_358);
    }
    else
    { /* block id: 253 */
        return p_42;
    }
    (*l_359) = (**l_317);
    (*l_317) = l_361;
    /* statement id: 257 */
    assert (l_318 == 0);
    (*l_359) = ((float)(((float)((0x2.Ap-1 == ((float)p_42 / (float)p_42)) > func_59(func_62((p_42 ^ ((uint32_t)__builtin_popcount(p_42) / (uint32_t)0x1909923CL)), __builtin_ctzl(((uint16_t)p_42 >> (uint16_t)p_42)), p_42, p_42, p_42), l_372)) + (float)p_42) != p_42) / (float)p_42);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_43(int16_t  p_44, int32_t  p_45, int32_t  p_46, uint64_t  p_47)
{ /* block id: 188 */
    uint32_t l_278 = 0xE81F14C9L;
    int32_t l_296 = 0L;
    int32_t *l_295 = &l_296;
    int32_t **l_300 = &l_295;
    float **l_304 = (void*)0;
    if ((4294967287UL ^ (18446744073709551615UL >= p_44)))
    { /* block id: 189 */
        return p_45;
    }
    else
    { /* block id: 191 */
        struct S0 l_273 = {0x5CL,0UL,0x5E963C0F9FCF56D3LL,0x9.18F1BFp-99,1UL};
        struct S0 *l_274 = &l_273;
        (*l_274) = l_273;
        (*l_274) = (*l_274);
        for (l_273.f2 = (-27); (l_273.f2 < 32); l_273.f2 += 2)
        { /* block id: 196 */
            const int16_t l_277 = 0x0934L;
            int32_t l_283 = 0L;
            int32_t *l_282 = &l_283;
            int32_t **l_281 = &l_282;
            (*l_281) = func_78(l_277, p_46, (l_273.f1 < l_278), (p_44 && (0xA00B00CFL & ((int64_t)p_45 - (int64_t)(((void*)0 == &l_274) | (-4L))))));
            /* statement id: 197 */
            assert (l_282 == 0);
        }
    }
    for (p_47 = (-26); (p_47 <= 28); p_47 += 1)
    { /* block id: 202 */
        uint16_t l_288 = 0x1327L;
        struct S0 l_289 = {250UL,0UL,0x238AD5E783D5683CLL,0x1.7p-1,0xC43DL};
        int32_t l_293 = (-4L);
        int32_t *l_292 = &l_293;
        int32_t *l_294 = &l_293;
        struct S0 *l_303 = (void*)0;
        float * const **l_305 = (void*)0;
        float ***l_306 = &l_304;
        if ((((uint16_t)(func_49((l_288 | 0xA118B2DAAAC5D9CELL), p_45, p_46, l_289) > l_278) >> (uint16_t)((int32_t)(0x8BABL || (func_118(l_292, l_294) >= 4294967288UL)) + (int32_t)0L)) && (*l_294)))
        { /* block id: 203 */
            int32_t **l_297 = &l_294;
            (*l_297) = func_78(p_47, p_45, p_44, ((*l_292) < (func_118(l_295, &l_296) <= ((0x5D75L || p_45) || (*l_292)))));
            /* statement id: 204 */
            assert (l_294 == 0);
            (*l_297) = &l_293;
            /* statement id: 205 */
            assert (l_294 == &l_293);
            (*l_294) = ((p_44 >= p_44) || ((((*l_295) | p_46) > p_46) != (*l_292)));
            (**l_300) = (((int64_t)(-6L) / (int64_t)func_118(&l_296, func_85(l_300))) <= (*l_294));
        }
        else
        { /* block id: 208 */
            struct S0 *l_302 = &l_289;
            struct S0 **l_301 = &l_302;
            (*l_301) = &l_289;
            return p_47;
        }
        l_289 = l_289;
        (*l_306) = l_304;
    }
    (*l_300) = (*l_300);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_49(uint64_t  p_50, int32_t  p_51, int16_t  p_52, struct S0  p_53)
{ /* block id: 37 */
    float l_68 = 0x1.4p+1;
    int32_t l_69 = (-1L);
    if (((uint16_t)(0x849FL == ((uint16_t)p_50 << (uint16_t)func_59(func_62(p_52, (0x1418E8DCE9DB3FA3LL | p_53.f2), l_69, func_70(p_51), l_69), p_53.f2))) << (uint16_t)l_69))
    { /* block id: 180 */
        const union U1 l_266 = {1UL};
        const union U1 *l_265 = &l_266;
        const union U1 **l_264 = &l_265;
        const union U1 ***l_263 = &l_264;
        (*l_263) = (void*)0;
        /* statement id: 181 */
        assert (l_264 == 0);
        return l_69;
    }
    else
    { /* block id: 183 */
        int64_t l_267 = (-1L);
        float *l_268 = &l_68;
        int32_t *l_270 = &l_69;
        int32_t **l_269 = &l_270;
        (*l_268) = l_267;
        (*l_269) = l_268;
        /* statement id: 185 */
        assert (l_270 == &l_68);
    }
    return l_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_59(union U1  p_60, uint64_t  p_61)
{ /* block id: 176 */
    int32_t ** const *l_258 = (void*)0;
    int32_t ***l_260 = (void*)0;
    int32_t ****l_259 = &l_260;
    struct S0 **l_261 = (void*)0;
    struct S0 *l_262 = (void*)0;
    (*l_259) = l_258;
    l_262 = (void*)0;
    return p_60.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_62(int32_t  p_63, int64_t  p_64, uint32_t  p_65, const int64_t  p_66, uint8_t  p_67)
{ /* block id: 41 */
    struct S0 l_74 = {0xAFL,0x2DA61EB613644CADLL,4UL,0x1.8p-1,0x5314L};
    int32_t l_76 = 6L;
    int32_t *l_75 = &l_76;
    int32_t **l_77 = (void*)0;
    int32_t **l_115 = &l_75;
    int32_t **l_121 = &l_75;
    union U1 *l_200 = (void*)0;
    union U1 **l_199 = &l_200;
    const uint32_t l_228 = 4UL;
    union U1 l_257 = {7UL};
    l_74 = l_74;
    l_75 = l_75;
    (*l_115) = func_78(((-7L) > (0xD870105C6596AAD9LL != p_65)), (*l_75), p_67, (*l_75));
    /* statement id: 58 */
    assert (l_75 == 0);
    if (((int64_t)func_118((*l_115), &p_63) % (int64_t)p_66))
    { /* block id: 104 */
        float *l_195 = &l_74.f3;
        float **l_194 = &l_195;
        union U1 l_206 = {0x8AL};
        uint32_t l_230 = 18446744073709551609UL;
        int32_t *l_247 = &l_76;
        for (p_63 = 0; (p_63 == (-6)); --p_63)
        { /* block id: 107 */
            int64_t l_193 = 0xDB1F33D140ED9186LL;
            float ***l_196 = (void*)0;
            float ***l_197 = &l_194;
            int32_t **l_198 = (void*)0;
            union U1 *l_214 = &l_206;
            for (p_65 = (-13); (p_65 >= 32); ++p_65)
            { /* block id: 110 */
                if (l_193)
                    break;
            }
            (*l_197) = l_194;
        }
        for (l_206.f0 = 0; (l_206.f0 >= 28); l_206.f0 += 1)
        { /* block id: 169 */
            union U1 l_255 = {0x64L};
            return l_255;
            /* statement id: 170 */
                    }
    }
    else
    { /* block id: 172 */
        union U1 l_256 = {0xB2L};
        return l_256;
        /* statement id: 173 */
            }
    return l_257;
    /* statement id: 175 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int64_t  func_70(float  p_71)
{ /* block id: 38 */
    struct S0 l_72 = {0x3AL,18446744073709551615UL,0x2777FC3FE767E792LL,0x0.4p-1,0xC9A7L};
    struct S0 *l_73 = &l_72;
    (*l_73) = l_72;
    return l_72.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_78(const uint32_t  p_79, uint16_t  p_80, uint8_t  p_81, int64_t  p_82)
{ /* block id: 44 */
    int32_t l_89 = 0xEDEBCD59L;
    int32_t *l_88 = &l_89;
    int32_t **l_87 = &l_88;
    float l_100 = 0x1.7B0CB4p+92;
    float *l_99 = &l_100;
    int32_t * const l_103 = &l_89;
    int32_t * const l_104 = &l_89;
    int32_t * const l_105 = &l_89;
    int32_t * const l_106 = &l_89;
    int32_t * const l_107 = &l_89;
    int32_t * const l_108 = &l_89;
    int32_t * const l_109 = &l_89;
    int32_t * const l_110 = &l_89;
    int32_t * const l_111 = &l_89;
    int32_t * const l_112 = &l_89;
    int32_t * const l_113 = &l_89;
    int32_t * const l_114 = (void*)0;
    for (p_80 = (-19); (p_80 > 10); p_80 += 8)
    { /* block id: 47 */
        float l_98 = (-0x1.0p+1);
        float *l_97 = &l_98;
        (*l_87) = func_85(l_87);
        (*l_97) = ((*l_87) == (void*)0);
    }
    (*l_99) = (&l_88 != &l_88);
    (*l_88) = p_79;
    (**l_87) = ((uint64_t)0xF9076B3EC5F66244LL / (uint64_t)p_79);
    return l_114;
    /* statement id: 57 */
    //assert (func_78_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_85(int32_t ** p_86)
{ /* block id: 48 */
    const uint8_t l_90 = 0xDDL;
    int32_t *l_94 = (void*)0;
    int32_t ** const l_93 = &l_94;
    int32_t l_96 = 4L;
    int32_t *l_95 = &l_96;
    (**p_86) = (l_90 > ((uint16_t)__builtin_parity(l_90) >> (uint16_t)((void*)0 == l_93)));
    return (*p_86);
    /* statement id: 50 */
    //assert (func_85_rv == &l_89 || func_85_rv == &l_296 || func_85_rv == &l_319 || func_85_rv == &l_379);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_118(int32_t * p_119, int32_t * p_120)
{ /* block id: 59 */
    const uint16_t l_122 = 0UL;
    float l_128 = 0xD.EB6193p-40;
    float *l_127 = &l_128;
    int32_t l_131 = (-1L);
    int32_t *l_130 = &l_131;
    int32_t **l_129 = &l_130;
    struct S0 l_133 = {247UL,18446744073709551615UL,0UL,0x0.C97D5Ep+55,4UL};
    struct S0 *l_132 = &l_133;
    uint8_t l_136 = 0xA0L;
    int32_t **l_139 = &l_130;
    uint32_t l_140 = 0x8A8D7FAAL;
    struct S0 l_160 = {0xF5L,1UL,18446744073709551615UL,0x5.6105D7p+26,65535UL};
    int64_t l_188 = 0x25B173B0BAAB2A12LL;
    (*l_129) = func_78(l_122, (l_122 > (p_119 != (void*)0)), (((int16_t)func_70(__builtin_ffs((((l_122 & ((int16_t)func_70((l_127 != p_119)) + (int16_t)(1L & l_122))) & l_122) > l_122))) >> (int16_t)13) || 0xF1A0L), l_122);
    /* statement id: 60 */
    assert (l_130 == 0);
    (*l_139) = func_78(l_131, (p_119 == p_120), (((void*)0 == l_132) ^ ((int32_t)(l_131 & l_136) + (int32_t)(((l_131 > ((int16_t)0x027DL / (int16_t)l_133.f1)) && l_133.f1) > l_133.f4))), l_122);
    if (l_140)
    { /* block id: 62 */
        union U1 l_142 = {0xE1L};
        union U1 *l_141 = &l_142;
        struct S0 l_175 = {5UL,6UL,0xE7F97FD67A201F26LL,0xF.C48AF1p-84,5UL};
        l_141 = l_141;
        for (l_133.f1 = (-30); (l_133.f1 >= 22); l_133.f1 += 6)
        { /* block id: 66 */
            int64_t l_149 = (-6L);
            int32_t l_158 = 2L;
            struct S0 l_163 = {255UL,18446744073709551614UL,0x2CDD91CD6C83836BLL,0xE.FFA272p+34,65529UL};
            float *l_167 = (void*)0;
            int32_t **l_174 = &l_130;
            if ((*p_120))
            { /* block id: 67 */
                const int32_t *l_151 = &l_131;
                struct S0 l_153 = {0x62L,0x336EAB1F273F2F43LL,7UL,0xA.8ACE59p+75,65527UL};
                struct S0 *l_154 = &l_153;
                for (l_133.f2 = 28; (l_133.f2 < 59); l_133.f2++)
                { /* block id: 70 */
                    int16_t l_148 = (-1L);
                    int32_t **l_150 = &l_130;
                    int32_t **l_152 = &l_130;
                    (*l_150) = func_78((-(int32_t)0x70DEC899L), l_148, l_149, l_149);
                    /* statement id: 71 */
                    assert (l_130 == 0);
                    (*l_152) = l_151;
                    /* statement id: 72 */
                    assert (l_130 == &l_131);
                }
                /* facts after for loop */
                assert (l_130 == &l_131 || l_130 == 0);
                (*l_127) = l_142.f0;
                (*l_139) = p_119;
                /* statement id: 75 */
                //assert (l_130 == 0 || l_130 == &p_63 || l_130 == &l_293 || l_130 == &l_296);
                (*l_154) = l_153;
            }
            else
            { /* block id: 77 */
                uint8_t l_157 = 6UL;
                const struct S0 l_159 = {255UL,0x2BF5F293FBD44C09LL,0x5FC1EA649016727ELL,0xF.908CCFp-67,6UL};
                l_158 = (((uint16_t)l_157 >> (uint16_t)3) && 0x7A10L);
                l_160 = l_159;
            }
            /* facts after branching */
            //assert (l_130 == 0 || l_130 == &p_63 || l_130 == &l_293 || l_130 == &l_296);
            for (l_133.f4 = 17; (l_133.f4 != 8); l_133.f4--)
            { /* block id: 83 */
                l_163 = l_163;
            }
            (*l_174) = func_78((+(l_163.f0 >= l_163.f1)), (((int16_t)((((void*)0 != l_167) <= l_131) ^ l_142.f0) >> (int16_t)10) <= ((uint16_t)l_163.f4 << (uint16_t)9)), l_142.f0, ((((((uint32_t)(((uint16_t)l_142.f0 - (uint16_t)l_142.f0) <= l_142.f0) - (uint32_t)0x429456BCL) ^ 0x55B1A04533268B7DLL) ^ l_142.f0) && l_163.f0) | l_163.f2));
            /* statement id: 86 */
            assert (l_130 == 0);
            l_175 = l_163;
        }
        for (l_140 = (-15); (l_140 == 58); ++l_140)
        { /* block id: 91 */
            (*l_127) = l_175.f0;
            (*l_132) = (*l_132);
        }
    }
    else
    { /* block id: 95 */
        union U1 *l_180 = (void*)0;
        int32_t l_185 = 0x6710E112L;
        (*p_120) = 0xE5584E04L;
        if ((((int16_t)(l_180 != (void*)0) << (int16_t)((int32_t)((uint16_t)(l_185 || ((int16_t)(l_185 != 1L) << (int16_t)10)) >> (uint16_t)6) / (int32_t)l_185)) > (l_188 < l_160.f0)))
        { /* block id: 97 */
            l_180 = l_180;
        }
        else
        { /* block id: 99 */
            return l_185;
        }
    }
    return l_133.f2;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 141
   depth: 1, occurrence: 16
XXX total union variables: 6

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 6
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 8
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 26
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1

XXX total number of pointers: 150

XXX times a variable address is taken: 134
XXX times a pointer is dereferenced on RHS: 72
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 79
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 7
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 621

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 217
   level: 2, occurrence: 67
   level: 3, occurrence: 22
   level: 4, occurrence: 5
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 73
XXX number of pointers point to scalars: 55
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 29.3
XXX average alias set size: 1.19

XXX times a non-volatile is read: 555
XXX times a non-volatile is write: 218
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 112
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 30
   depth: 2, occurrence: 26
   depth: 3, occurrence: 16
   depth: 4, occurrence: 6

XXX percentage a fresh-made variable is used: 17.9
XXX percentage an existing variable is used: 82.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

