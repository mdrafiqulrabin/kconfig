/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2864229420
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 4;
   signed f1 : 9;
   unsigned f2 : 7;
   int32_t  f3;
   unsigned f4 : 8;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 26;
   unsigned f1 : 9;
   unsigned f2 : 12;
   signed f3 : 28;
   unsigned f4 : 24;
   signed f5 : 22;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_30(void);
static uint16_t  func_49(uint16_t  p_50, int32_t  p_51);
inline static struct S1  func_57(uint32_t  p_58, int32_t  p_59, uint32_t  p_60);
inline static uint32_t  func_70(int32_t  p_71, int8_t  p_72);
static struct S1  func_76(int8_t  p_77, int32_t  p_78);
inline static int32_t  func_87(int8_t  p_88, struct S0  p_89);
inline static struct S0  func_90(int32_t  p_91, uint32_t  p_92);
inline static int32_t  func_93(uint32_t  p_94, int8_t  p_95, int32_t  p_96, struct S0  p_97, int8_t  p_98);
static uint32_t  func_99(int32_t  p_100);
static uint16_t  func_105(uint32_t  p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_30(void)
{ /* block id: 36 */
    uint16_t l_35 = 0U;
    int8_t l_42 = 0x26;
    int32_t l_653 = (-4);
    uint32_t l_654 = 4294967289U;
    int32_t l_655 = 0x505FB3C2;
    uint32_t l_656 = 0xD4158D25;
    int8_t l_657 = 0;
    int32_t l_658 = 0xA5699BB9;
    int16_t l_659 = 0x77FF;
    struct S0 l_664 = {3,-13,6,0x8D044825,2};
    uint32_t l_665 = 0x37426520;
    if (((int16_t)((uint16_t)l_35 - (uint16_t)((int32_t)((uint16_t)(l_659 = (l_658 = (((__builtin_ctzl((((uint16_t)0x223D + (uint16_t)l_42) , (((uint16_t)((((uint16_t)((l_656 = (l_655 = (((l_654 = (l_653 ^= ((uint16_t)l_42 * (uint16_t)func_49(l_42, __builtin_bswap32(l_42))))) <= l_42) && l_35))) , l_655) - (uint16_t)0U) == 0x9694) | l_42) - (uint16_t)l_657) & l_42))) , l_656) && l_657) || l_654))) % (uint16_t)l_35) - (int32_t)0U)) - (int16_t)0))
    { /* block id: 412 */
        uint32_t l_660 = 4294967287U;
        int32_t l_661 = 0xD0007790;
        l_661 = (l_660 = l_42);
    }
    else
    { /* block id: 415 */
        int32_t l_662 = (-1);
        int32_t l_663 = 0x10F7CB18;
        l_664 = func_90(__builtin_ffsll((l_655 = (((func_105(l_662) <= (l_663 = l_653)) < func_99(l_662)) <= l_654))), l_662);
    }
    l_665 = l_657;
    return l_664.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_49(uint16_t  p_50, int32_t  p_51)
{ /* block id: 37 */
    int32_t l_52 = 0x1CAF1E2C;
    uint32_t l_61 = 1U;
    int32_t l_547 = 1;
    int32_t l_548 = 0xD93F11F2;
    struct S0 l_554 = {2,-19,10,7,4};
    uint16_t l_649 = 0xE96C;
    struct S1 l_652 = {7428,13,38,11962,1027,-202};
    if (l_52)
    { /* block id: 38 */
        int8_t l_53 = 0x1D;
        struct S1 l_534 = {3683,8,37,-2827,97,-790};
        p_51 = l_53;
        for (l_53 = 0; (l_53 < 9); l_53 += 1)
        { /* block id: 42 */
            uint32_t l_56 = 0xB4763523;
            int32_t l_535 = 0x3A74014E;
            if (p_51)
                break;
            l_56 &= 0;
            l_534 = func_57(p_50, l_61, l_53);
            l_535 = func_105(l_534.f1);
        }
    }
    else
    { /* block id: 352 */
        int8_t l_536 = (-4);
        int32_t l_546 = 0xBC6F3C4F;
        int8_t l_549 = 0xC7;
        int32_t l_583 = 0x48C5094D;
        int8_t l_634 = 0xB1;
        uint32_t l_648 = 0x7F173E63;
        struct S1 l_650 = {4654,14,39,9375,1741,-1194};
        if ((l_548 ^= (l_536 , ((((int16_t)(0x7245 >= ((l_547 = (p_51 ^= ((1U >= ((int16_t)(l_52 = ((uint32_t)((uint16_t)((l_61 & 0x5F9EFB79) < (~l_536)) % (uint16_t)p_50) - (uint32_t)(l_546 = __builtin_popcount(l_536)))) << (int16_t)p_50)) && l_52))) , l_547)) - (int16_t)l_536) != 0) ^ (-1)))))
        { /* block id: 358 */
            uint32_t l_555 = 4294967286U;
            l_549 &= p_51;
            p_51 = (1U > p_51);
            p_51 = ((uint16_t)((uint16_t)p_50 * (uint16_t)p_50) << (uint16_t)__builtin_popcountl(func_87(l_536, l_554)));
            l_555 = (p_51 <= l_546);
        }
        else
        { /* block id: 363 */
            int32_t l_561 = (-5);
            int8_t l_586 = (-1);
            int32_t l_600 = 0x6B2A26A3;
            struct S1 l_651 = {7659,8,40,-10769,3610,58};
            for (l_536 = (-17); (l_536 <= 23); l_536 += 1)
            { /* block id: 366 */
                uint16_t l_580 = 7U;
                int32_t l_587 = 0x88FA4A87;
                uint32_t l_625 = 0x5726BCB5;
                if (l_554.f4)
                { /* block id: 367 */
                    uint32_t l_560 = 5U;
                    for (l_554.f3 = 2; (l_554.f3 > 27); l_554.f3 += 6)
                    { /* block id: 370 */
                        struct S0 l_567 = {2,-19,3,0xEE94C0DC,10};
                        l_587 &= ((l_560 , (l_561 || (((uint16_t)(l_546 &= p_50) * (uint16_t)((((-(uint32_t)(((uint16_t)((l_567 , ((((((uint32_t)((uint16_t)((uint16_t)(p_51 && ((uint16_t)((int16_t)((int32_t)l_580 % (int32_t)((int16_t)((l_583 |= 0xE2B8) || p_50) + (int16_t)((int16_t)p_50 >> (int16_t)3))) * (int16_t)0xE422) >> (uint16_t)l_560)) << (uint16_t)7) * (uint16_t)l_554.f0) % (uint32_t)l_567.f0) , l_586) , l_580) <= 4294967288U) < 0x6F98)) ^ l_536) << (uint16_t)0) , l_549)) != p_51) && p_51) > p_50)) == l_580))) , p_50);
                    }
                    if ((((l_554 = func_90(l_549, (((uint16_t)(0xB38D >= (-(uint32_t)(l_586 && (4294967289U & (p_51 , ((uint32_t)((int32_t)((l_560 | ((l_547 |= (p_51 || 1U)) <= (((uint32_t)((((-(uint16_t)((uint16_t)((l_600 = l_580) != p_51) - (uint16_t)0x43D5)) >= l_586) | l_560) || l_587) % (uint32_t)0x09D5CAE7) > p_50))) & l_554.f2) - (int32_t)l_561) + (uint32_t)l_560)))))) * (uint16_t)1) & 0))) , 0xC74303A7) > 0xFD0ECDA6))
                    { /* block id: 378 */
                        if (l_549)
                            break;
                    }
                    else
                    { /* block id: 380 */
                        return p_51;
                    }
                    if (l_587)
                        continue;
                }
                else
                { /* block id: 384 */
                    int8_t l_606 = 0;
                    int32_t l_609 = 0x83E67CE0;
                    p_51 = ((l_546 = ((uint16_t)(!(l_61 && (((uint16_t)(l_606 < ((l_609 = ((uint16_t)p_51 << (uint16_t)p_51)) >= __builtin_ctz(p_51))) << (uint16_t)4) , ((uint16_t)(!l_561) << (uint16_t)2)))) % (uint16_t)l_606)) || ((!p_50) ^ p_51));
                    l_554 = l_554;
                }
                p_51 = ((int32_t)((-(int32_t)((uint32_t)((uint32_t)l_561 - (uint32_t)1U) + (uint32_t)((uint32_t)0x01C10BEC - (uint32_t)((uint32_t)(l_587 > l_625) % (uint32_t)p_51)))) , p_51) + (int32_t)p_51);
                for (l_583 = 0; (l_583 < (-21)); l_583 -= 7)
                { /* block id: 393 */
                    int32_t l_635 = 0xF3ED9D5C;
                    l_635 ^= ((int16_t)((uint16_t)p_51 << (uint16_t)(p_51 != __builtin_bswap32((((uint16_t)(l_561 >= 0xACD9) << (uint16_t)3) && l_634)))) << (int16_t)l_554.f3);
                    l_546 ^= (l_635 > ((int32_t)p_50 - (int32_t)((int16_t)((uint16_t)((uint16_t)(((int32_t)__builtin_parityll(p_51) - (int32_t)0xAEC5E84F) , ((l_648 = ((uint32_t)p_51 - (uint32_t)0xA56D9D09)) || (-6))) >> (uint16_t)(l_649 < p_50)) >> (uint16_t)l_625) >> (int16_t)l_547)));
                    l_600 ^= l_549;
                }
                l_652 = (l_651 = l_650);
            }
            return p_51;
        }
    }
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_57(uint32_t  p_58, int32_t  p_59, uint32_t  p_60)
{ /* block id: 45 */
    int32_t l_520 = 0x0D939E87;
    int32_t l_522 = 8;
    struct S0 l_525 = {3,-10,1,0x85D70777,10};
    struct S1 l_533 = {6262,0,40,13486,1975,812};
    for (p_58 = 17; (p_58 > 53); p_58 += 6)
    { /* block id: 48 */
        uint16_t l_511 = 0xE674;
        int32_t l_521 = 0x1C1FCB65;
        int32_t l_523 = 0;
        uint32_t l_524 = 0xA91C9A9B;
        int32_t l_526 = 0xCC7CE0DF;
        int32_t l_527 = 0xE08BEC18;
        l_527 |= (l_525.f1 = ((uint16_t)((l_526 = ((((((int16_t)(((uint32_t)func_70(((int16_t)p_58 >> (int16_t)14), p_60) - (uint32_t)p_59) != __builtin_clzll(l_511)) * (int16_t)(func_76((((uint16_t)(func_93(((uint32_t)p_59 - (uint32_t)(l_523 = ((l_522 &= ((int32_t)(l_521 = (((-4) ^ (((uint32_t)((func_105(l_520) < l_520) && l_511) + (uint32_t)(-5)) >= l_520)) && 3)) - (int32_t)0x9304A438)) == p_60))), l_524, p_60, l_525, l_526) || p_59) - (uint16_t)0xD34C) >= p_60), l_526) , p_58)) < p_60) == l_525.f2) || 7U) , 4294967287U)) | l_525.f2) * (uint16_t)l_524));
    }
    l_520 |= (l_525.f2 && (-(int32_t)((uint16_t)p_60 >> (uint16_t)(p_60 && ((int16_t)(p_58 && p_59) << (int16_t)14)))));
    return l_533;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_70(int32_t  p_71, int8_t  p_72)
{ /* block id: 49 */
    int32_t l_75 = 0x80B0DEBF;
    int32_t l_81 = 0;
    struct S1 l_507 = {1504,4,51,-1171,2034,-161};
    l_75 = 1;
    l_507 = func_76(((((uint16_t)l_75 - (uint16_t)(l_81 = p_71)) != (65535U >= p_71)) <= (-5)), p_72);
    for (p_72 = 0; (p_72 <= (-16)); p_72 -= 5)
    { /* block id: 336 */
        uint32_t l_510 = 4294967294U;
        return l_510;
    }
    return l_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_76(int8_t  p_77, int32_t  p_78)
{ /* block id: 52 */
    int16_t l_82 = 0;
    struct S0 l_431 = {0,-13,0,0xE1867BA5,1};
    int32_t l_432 = 1;
    int32_t l_433 = 0x2772443C;
    struct S1 l_506 = {3387,1,9,16222,431,-985};
    l_82 &= p_78;
    l_431.f1 = (l_82 || (((((int32_t)(((int32_t)func_87(p_77, func_90(func_93(func_99(l_82), p_78, l_82, l_431, (__builtin_parity((l_431.f2 ^ ((l_433 ^= ((l_432 |= (8 < p_77)) || 65535U)) == 8U))) >= p_78)), l_431.f3)) - (int32_t)p_77) >= l_431.f2) - (int32_t)p_78) ^ p_78) | l_431.f2) != l_431.f0));
    return l_506;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_87(int8_t  p_88, struct S0  p_89)
{ /* block id: 329 */
    uint16_t l_505 = 0x17E4;
    return l_505;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_90(int32_t  p_91, uint32_t  p_92)
{ /* block id: 276 */
    uint32_t l_443 = 9U;
    int32_t l_448 = 4;
    uint32_t l_449 = 7U;
    struct S0 l_450 = {2,20,6,0x8947E936,4};
    int32_t l_503 = (-1);
    int32_t l_504 = 0xED4A7A37;
    if (((int16_t)(l_450.f1 = (((int16_t)((((__builtin_parity(((int16_t)(((((int16_t)p_91 % (int16_t)65535U) & (l_443 , (l_443 || (l_443 && 4294967295U)))) ^ (((int16_t)p_91 >> (int16_t)10) > (func_93(p_91, (l_449 = __builtin_ffs(((l_448 = ((((int16_t)__builtin_clzll(l_443) >> (int16_t)5) == 0U) || l_443)) != 0x4441))), p_92, l_450, p_91) & l_443))) >= l_450.f3) - (int16_t)p_92)) , l_450.f1) , p_92) < 0x73B80C86) | (-1)) + (int16_t)p_91) && 0xB8BE)) >> (int16_t)4))
    { /* block id: 280 */
        int32_t l_457 = 0x2C5EA47B;
        struct S0 l_463 = {2,-6,7,0,4};
        int32_t l_465 = 2;
        struct S1 l_466 = {6928,17,26,2062,1851,835};
        uint32_t l_472 = 0x496D7EAB;
        for (l_448 = 6; (l_448 != 5); l_448 -= 1)
        { /* block id: 283 */
            struct S1 l_467 = {543,11,4,10165,1605,495};
            for (l_443 = 15; (l_443 != 21); l_443 += 6)
            { /* block id: 286 */
                uint16_t l_489 = 65535U;
                for (l_450.f3 = 0; (l_450.f3 > (-2)); l_450.f3 -= 1)
                { /* block id: 289 */
                    struct S0 l_464 = {3,-11,10,-1,6};
                    l_467 = (func_99(((l_457 >= (!(__builtin_clzl(__builtin_popcountl(p_91)) | ((int32_t)((((int16_t)(l_463 , ((l_457 , 65535U) >= ((l_464 = l_463) , l_464.f4))) << (int16_t)15) == 0xB6336E16) != p_91) + (int32_t)l_465)))) | 0xA38C4A00)) , l_466);
                }
                l_467.f5 = (-2);
                if (l_443)
                    break;
                for (l_465 = (-5); (l_465 < 5); l_465 += 1)
                { /* block id: 297 */
                    uint16_t l_482 = 0x014E;
                    l_467.f3 &= (-(uint16_t)p_92);
                    if (((((p_91 <= 6U) <= (-(int16_t)(l_472 == ((uint16_t)((int16_t)(!((uint16_t)(l_450.f3 < 0x00C2) + (uint16_t)((uint32_t)(((l_482 , (6 != l_466.f4)) < l_450.f0) || p_92) % (uint32_t)p_92))) << (int16_t)l_466.f4) >> (uint16_t)4)))) , 0x9B8E3C38) , p_91))
                    { /* block id: 299 */
                        struct S0 l_483 = {0,10,2,0,6};
                        l_450.f1 = 0xE423A54D;
                        return l_483;
                    }
                    else
                    { /* block id: 302 */
                        l_466.f5 = (-7);
                    }
                    l_489 = (((int32_t)((uint16_t)(p_91 > (-3)) << (uint16_t)(4294967287U <= (-(uint16_t)l_482))) - (int32_t)(0x859CBEDF > l_467.f4)) & l_482);
                }
            }
            l_467.f5 = (0xEAA82E65 && ((((-1) || p_91) , l_450.f2) < l_466.f0));
        }
        if (p_92)
        { /* block id: 310 */
            struct S0 l_490 = {1,20,4,0xC75AE303,8};
            return l_490;
        }
        else
        { /* block id: 312 */
            struct S0 l_491 = {1,-20,8,0x9B72CFEC,7};
            l_463 = l_491;
        }
        l_450.f1 &= p_91;
        l_450 = l_463;
    }
    else
    { /* block id: 317 */
        uint16_t l_492 = 0x4E0B;
        l_492 |= p_91;
    }
    l_504 = ((l_450.f1 = l_450.f2) , ((uint32_t)(l_450 , l_450.f1) + (uint32_t)((int32_t)l_443 % (int32_t)((int16_t)(((int16_t)(l_503 |= ((l_448 = ((int16_t)p_92 % (int16_t)l_448)) && ((l_448 = p_92) > p_92))) % (int16_t)(-8)) | l_443) << (int16_t)p_91))));
    l_448 = __builtin_popcountl(l_450.f3);
    l_448 = (l_504 = l_503);
    return l_450;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_93(uint32_t  p_94, int8_t  p_95, int32_t  p_96, struct S0  p_97, int8_t  p_98)
{ /* block id: 271 */
    int16_t l_434 = 0x25D8;
    p_97.f1 |= __builtin_clzll(p_97.f2);
    l_434 = (p_96 || (p_97.f0 , p_95));
    p_97.f1 |= l_434;
    return l_434;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_99(int32_t  p_100)
{ /* block id: 54 */
    struct S0 l_118 = {3,15,1,0xDC13529C,6};
    int32_t l_129 = 0;
    int32_t l_133 = 0;
    uint16_t l_143 = 0x0964;
    struct S1 l_149 = {3608,10,52,219,2073,-1338};
    uint32_t l_197 = 0x482B3DB3;
    int16_t l_376 = (-1);
    uint32_t l_405 = 6U;
    for (p_100 = 13; (p_100 >= (-21)); p_100 -= 3)
    { /* block id: 57 */
        int8_t l_107 = 0x66;
        int32_t l_124 = (-10);
        int8_t l_132 = 0x46;
        int32_t l_144 = 0x182763D2;
        if (((uint16_t)func_105(l_107) << (uint16_t)13))
        { /* block id: 64 */
            struct S0 l_121 = {3,-9,3,-8,14};
            int32_t l_122 = 0x1B5D7EC3;
            l_118.f1 = (l_118 , ((uint32_t)l_107 - (uint32_t)(func_105((l_122 ^= (l_107 || (l_121 , p_100)))) < 0xDF25B48F)));
        }
        else
        { /* block id: 67 */
            int32_t l_123 = 0;
            struct S1 l_142 = {3324,1,34,-12143,823,-116};
            int32_t l_145 = 7;
            struct S0 l_146 = {1,-13,9,0x4249AA0F,8};
            l_124 ^= (l_123 & p_100);
            l_145 |= ((l_144 &= (((uint16_t)(((l_133 = ((l_129 &= (l_118.f1 &= 9)) <= (l_124 >= ((uint16_t)func_105((l_132 && p_100)) >> (uint16_t)0)))) <= p_100) >= ((uint16_t)(((int16_t)l_118.f2 >> (int16_t)0) && ((int32_t)l_123 + (int32_t)(((((((uint32_t)4294967295U % (uint32_t)l_123) == l_132) < l_118.f2) , l_142) , l_143) , p_100))) >> (uint16_t)0)) - (uint16_t)0) && 0U)) >= p_100);
            l_118 = l_146;
            return p_100;
        }
    }
    for (l_118.f3 = (-3); (l_118.f3 == (-19)); l_118.f3 -= 1)
    { /* block id: 80 */
        uint32_t l_157 = 4294967289U;
        struct S0 l_173 = {0,-6,8,0x2332C83D,2};
        struct S1 l_179 = {395,19,1,-5056,3132,1279};
        int32_t l_203 = 0x55FCFD51;
        struct S1 l_265 = {1100,7,21,10575,3293,-669};
        struct S1 l_290 = {388,2,26,-1920,1890,-640};
        if (l_143)
        { /* block id: 81 */
            int32_t l_152 = 1;
            l_157 |= (p_100 != (((l_149 , ((l_152 != ((p_100 & (p_100 || p_100)) > (l_129 >= 0x19B67119))) && ((uint32_t)((int16_t)l_118.f3 << (int16_t)l_152) % (uint32_t)0x17EF1465))) , (-1)) <= l_118.f1));
        }
        else
        { /* block id: 83 */
            uint32_t l_170 = 0x36986BD0;
            int32_t l_171 = 0x4D72531C;
            int32_t l_182 = 0x86C87C1B;
            int32_t l_186 = 0x4033A2A3;
            struct S1 l_206 = {6664,17,30,-10705,698,1245};
            struct S0 l_219 = {3,10,2,0xDBC5227D,8};
            if (((l_171 = ((((uint16_t)((int16_t)((int32_t)((uint16_t)(!(p_100 && (~p_100))) >> (uint16_t)p_100) - (int32_t)p_100) * (int16_t)l_157) << (uint16_t)4) , (p_100 > (l_133 ^= (l_149.f5 = (l_157 > func_105(l_170)))))) == l_170)) < 0))
            { /* block id: 87 */
                struct S0 l_172 = {0,-6,4,3,2};
                int32_t l_183 = (-4);
                l_173 = l_172;
                l_183 &= func_105((l_173.f2 & ((-(int32_t)((int16_t)((l_182 |= (l_172.f1 >= (((l_149.f2 != ((uint32_t)((l_179 = l_179) , __builtin_popcountll((l_170 || (l_149.f5 = (func_105((l_173.f1 |= (0x677A == (((-1) | (l_179.f3 |= ((int16_t)p_100 % (int16_t)l_171))) && p_100)))) & 4294967288U))))) % (uint32_t)l_172.f2)) || l_171) <= 0xB5FE))) & l_118.f1) + (int16_t)p_100)) && l_170)));
                l_186 = (l_171 = (p_100 > ((l_182 , (((uint16_t)(__builtin_clzl((l_179.f5 = l_183)) , 6U) % (uint16_t)(l_149.f0 || (((l_182 ^= (((l_172.f1 = p_100) , p_100) ^ (l_179.f3 = 0x5094A51A))) ^ p_100) || p_100))) || p_100)) & 4294967295U)));
                l_173 = l_118;
            }
            else
            { /* block id: 102 */
                uint32_t l_187 = 0U;
                int32_t l_196 = 0x66566E71;
                struct S1 l_213 = {970,0,44,11082,844,1588};
                struct S1 l_231 = {3659,17,47,5956,377,730};
                p_100 = (p_100 != l_187);
                l_197 = (p_100 != (((l_196 = ((((int32_t)func_105((__builtin_parityll(l_179.f3) == ((uint16_t)((uint32_t)(((uint16_t)p_100 << (uint16_t)p_100) ^ (l_173.f1 |= ((l_187 | (l_149.f2 || p_100)) | ((l_187 & l_149.f1) < p_100)))) - (uint32_t)l_187) << (uint16_t)14))) + (int32_t)l_187) || 0) , p_100)) >= l_173.f4) , 1));
                if ((l_118.f1 = l_179.f5))
                { /* block id: 108 */
                    uint32_t l_212 = 0xCFA7979A;
                    for (l_157 = 0; (l_157 <= 20); l_157 += 1)
                    { /* block id: 111 */
                        l_118.f1 ^= (~(l_203 = ((int16_t)(l_171 = __builtin_clzl(__builtin_ffs(l_196))) * (int16_t)p_100)));
                        l_212 = (((uint16_t)(__builtin_ffsll((l_206 , (-1))) , ((-(uint32_t)1U) > (l_173.f1 = func_105(l_182)))) << (uint16_t)5) ^ (l_196 |= __builtin_clz(((int16_t)((int16_t)3 + (int16_t)(p_100 < l_179.f0)) * (int16_t)0xC837))));
                    }
                }
                else
                { /* block id: 119 */
                    int8_t l_222 = 4;
                    int32_t l_230 = (-1);
                    struct S1 l_232 = {7220,13,55,-10484,4011,-846};
                    l_179 = l_213;
                    l_232 = (l_231 = ((~(l_213.f5 = (l_173 , (l_230 = ((int16_t)(((uint16_t)p_100 % (uint16_t)(l_219 , l_206.f1)) >= ((uint16_t)(l_222 || 8U) % (uint16_t)((int16_t)((int16_t)(l_196 = (l_222 > ((uint32_t)(((-(int16_t)(l_219 , 0)) | l_219.f3) , p_100) % (uint32_t)0xD4E58FD3))) + (int16_t)0xEFAB) >> (int16_t)5))) << (int16_t)6))))) , l_149));
                    if (l_231.f4)
                        continue;
                }
            }
            l_173.f1 = l_179.f0;
            if ((((int16_t)p_100 >> (int16_t)(((((int16_t)(((l_133 ^= (((l_179.f3 = func_105(__builtin_ctz(((func_105((!((uint16_t)(((((uint32_t)p_100 - (uint32_t)(((uint32_t)((func_105(((uint16_t)(p_100 , (((uint16_t)l_149.f5 + (uint16_t)p_100) & l_118.f2)) << (uint16_t)0)) && (l_129 &= (((((l_186 >= p_100) | p_100) , p_100) ^ 0xF61C0A83) , l_173.f4))) , l_219.f0) % (uint32_t)0x7E5EAF47) & l_186)) < l_149.f0) < l_171) > 0x69658B35) + (uint16_t)1U))) & l_206.f1) , p_100)))) , l_157) <= p_100)) > l_179.f2) && l_206.f5) >> (int16_t)7) | l_206.f1) ^ 7) ^ l_170)) && p_100))
            { /* block id: 133 */
                int8_t l_248 = (-3);
                struct S0 l_256 = {0,14,4,0x1438CF6D,10};
                uint32_t l_259 = 0xDA87189E;
                struct S1 l_262 = {6859,3,48,307,2923,1452};
                l_248 = p_100;
                for (l_182 = (-26); (l_182 > 26); l_182 += 1)
                { /* block id: 137 */
                    int8_t l_251 = 0xA8;
                    struct S1 l_263 = {2821,12,13,15161,92,-221};
                    if (l_251)
                        break;
                    if ((((uint16_t)((uint16_t)((((((l_173 = l_256) , (p_100 , p_100)) && 0x0FFD) || ((((int16_t)(l_179.f5 = p_100) + (int16_t)0x825A) < p_100) > (__builtin_ffsl(p_100) || 4294967293U))) | (-9)) >= 6U) << (uint16_t)p_100) >> (uint16_t)l_259) & 65535U))
                    { /* block id: 141 */
                        struct S1 l_264 = {5615,1,32,4379,1523,-23};
                        int32_t l_266 = 0x529F8FE3;
                        l_173.f1 = ((int16_t)(__builtin_bswap64((l_179.f3 = p_100)) ^ (__builtin_ctzl(func_105((((p_100 , l_262) , (l_266 ^= (l_264.f3 = (l_263 , (l_264 , ((l_265 , __builtin_parityll(p_100)) < l_118.f2)))))) , 0x38C47E81))) && l_256.f0)) + (int16_t)l_256.f1);
                        l_264.f3 ^= (__builtin_bswap32(p_100) > ((int32_t)p_100 + (int32_t)((uint16_t)p_100 % (uint16_t)func_105((l_118 , p_100)))));
                        return p_100;
                    }
                    else
                    { /* block id: 148 */
                        return l_206.f2;
                    }
                }
            }
            else
            { /* block id: 152 */
                int16_t l_279 = 0x5CF6;
                int32_t l_286 = 0x98E07820;
                int32_t l_287 = 0x7AA3E9DA;
                l_118.f1 = ((((uint16_t)(l_133 = (0x05AABCAB && (__builtin_bswap32(((l_149.f3 = l_206.f1) && ((int16_t)((((uint16_t)p_100 * (uint16_t)((uint16_t)l_279 % (uint16_t)((uint16_t)(l_129 = (((int32_t)l_206.f4 - (int32_t)((int16_t)(l_219.f1 &= (l_287 = (0 ^ (l_286 = 4294967294U)))) << (int16_t)((uint16_t)((((l_173.f4 , ((0x3753 <= p_100) , 8U)) , l_279) , l_279) & l_197) % (uint16_t)p_100))) , l_118.f0)) * (uint16_t)0xDCB5))) , 0xCB81) != 1U) % (int16_t)p_100))) == 65528U))) * (uint16_t)l_197) <= 1U) >= 0xC260BCB5);
            }
            l_179 = l_290;
        }
    }
    if (l_118.f0)
    { /* block id: 164 */
        struct S0 l_291 = {3,-12,1,-8,7};
        struct S1 l_295 = {6476,21,21,1092,1942,-706};
        uint32_t l_324 = 0xFC918A1D;
        uint32_t l_352 = 0xCA8C57EA;
        int32_t l_414 = (-1);
        if ((l_291 , 0))
        { /* block id: 165 */
            uint32_t l_292 = 0xBF6FE1F7;
            int32_t l_306 = 1;
            int32_t l_307 = (-1);
            struct S1 l_330 = {5167,15,56,-2900,1936,-47};
            if (l_292)
            { /* block id: 166 */
                uint32_t l_304 = 0xFAC234BB;
                int32_t l_305 = 0x7D0461C5;
                int32_t l_325 = 1;
                p_100 = ((((l_291.f1 >= (((uint16_t)(l_305 &= ((l_295 , ((0x41E1 && __builtin_ctzl(func_105((1 != 1U)))) && (((int16_t)(((int16_t)(((((int16_t)9 << (int16_t)4) , ((int32_t)(l_133 ^ 0xA2884712) % (int32_t)0xAA62EC7B)) >= 0xC267) < l_292) * (int16_t)l_304) > l_304) - (int16_t)p_100) >= 0))) != p_100)) << (uint16_t)p_100) , (-4))) , 0x80E5CDF0) & l_292) > 0x13F5);
                l_305 ^= (func_105((l_306 &= (func_105(l_295.f5) & ((l_295.f3 |= (l_295.f5 == (l_149.f4 == p_100))) ^ p_100)))) > (l_307 = l_118.f3));
                l_325 &= ((((int16_t)(((int32_t)(p_100 | p_100) % (int32_t)((uint32_t)__builtin_popcountll((l_324 = (l_295.f2 && (((int16_t)l_306 * (int16_t)((l_149 , 1U) || (((int32_t)((l_149.f5 = (l_305 |= (l_118.f1 = ((uint32_t)((int32_t)((uint32_t)__builtin_ctzl(l_292) - (uint32_t)__builtin_bswap64((p_100 < p_100))) - (int32_t)0) - (uint32_t)l_292)))) == l_149.f2) + (int32_t)0xD590934E) ^ l_295.f1))) > 0x29FDDACF)))) % (uint32_t)p_100)) && l_305) % (int16_t)4) ^ 4) & 0);
            }
            else
            { /* block id: 178 */
                int32_t l_343 = 0xF24BCD46;
                for (l_306 = 0; (l_306 == (-15)); l_306 -= 1)
                { /* block id: 181 */
                    struct S1 l_334 = {7646,14,0,7915,2551,-1109};
                    uint32_t l_344 = 0xC9D936B8;
                    for (l_292 = (-15); (l_292 >= 46); l_292 += 4)
                    { /* block id: 184 */
                        p_100 = p_100;
                        p_100 = p_100;
                        l_295 = l_330;
                        return l_330.f5;
                    }
                    if (l_330.f2)
                        break;
                    for (p_100 = (-23); (p_100 <= 25); p_100 += 5)
                    { /* block id: 193 */
                        struct S1 l_333 = {42,20,39,-1710,1302,-875};
                        int32_t l_345 = (-8);
                        l_334 = l_333;
                        if (p_100)
                            continue;
                        l_133 = (0x6AB84D60 > (l_345 = ((int16_t)((l_334.f2 <= l_334.f2) ^ (l_344 = (p_100 == (((l_291.f4 ^ ((l_330.f3 = ((((((l_333.f5 |= (p_100 < ((uint16_t)(((uint16_t)(l_334.f5 = (l_129 |= 0xCA22)) >> (uint16_t)1) <= ((uint16_t)p_100 << (uint16_t)(l_333.f3 = 0x9BF1))) % (uint16_t)l_334.f3))) && l_295.f3) >= 0xE7D97D77) & p_100) >= l_333.f1) <= l_334.f4)) > l_343)) , p_100) || 0)))) * (int16_t)l_295.f4)));
                        l_307 = (l_334.f3 = (l_333.f3 = l_333.f2));
                    }
                    l_334.f3 = (p_100 && l_291.f2);
                }
            }
        }
        else
        { /* block id: 211 */
            int8_t l_350 = 0x90;
            struct S0 l_351 = {1,16,8,0xE952AF1B,3};
            l_149.f5 = (p_100 = ((int16_t)((0x3531 > (p_100 < (((int16_t)(l_350 = func_105(p_100)) * (int16_t)(l_351 , ((p_100 >= (l_351.f1 ^= ((((((65535U <= 0x2A50) < (p_100 == l_149.f2)) | p_100) | l_352) , l_351.f4) , 6))) , 5U))) ^ l_118.f4))) > (-1)) >> (int16_t)l_352));
            for (l_197 = 0; (l_197 >= 43); l_197 += 7)
            { /* block id: 218 */
                struct S0 l_355 = {3,3,10,0x9CE2A3B5,9};
                struct S0 l_356 = {3,-6,4,-5,9};
                if (p_100)
                    break;
                l_356 = (l_355 = l_355);
                l_355.f1 &= p_100;
            }
        }
        l_291.f1 ^= ((l_149.f5 ^ ((l_295 , l_291.f0) && (((uint32_t)((l_118.f1 = (l_149.f0 != 0xD601)) || l_324) % (uint32_t)((2 > p_100) , 0xF560B452)) != p_100))) | l_291.f2);
        for (l_197 = 0; (l_197 <= 45); l_197 += 1)
        { /* block id: 229 */
            for (l_324 = 11; (l_324 != 12); l_324 += 1)
            { /* block id: 232 */
                int16_t l_365 = 0xBF5C;
                int32_t l_377 = 0xCFFACD87;
                uint32_t l_382 = 0x2DAAF693;
                l_377 &= ((uint16_t)l_365 % (uint16_t)((uint16_t)((l_133 ^ ((int32_t)(p_100 , ((uint16_t)(p_100 , ((((uint16_t)p_100 - (uint16_t)l_295.f0) , (l_118.f4 < (l_149.f1 != ((int16_t)l_118.f4 << (int16_t)l_376)))) || p_100)) % (uint16_t)0xDDDD)) - (int32_t)0)) && l_133) * (uint16_t)65535U));
                l_295.f5 = ((l_129 = 0xCFAE2E04) <= ((int32_t)p_100 + (int32_t)((uint16_t)p_100 >> (uint16_t)4)));
                l_377 = (l_133 |= (l_382 & 0x09BB));
            }
        }
        if (((l_133 = l_295.f5) <= l_295.f1))
        { /* block id: 241 */
            int8_t l_385 = (-10);
            struct S0 l_395 = {2,9,2,0x1BA66277,13};
            int32_t l_404 = 3;
            int32_t l_406 = 1;
            l_291 = l_291;
            l_406 &= (p_100 = ((uint32_t)(l_385 >= __builtin_popcountl(((uint16_t)((func_105(((int32_t)(-4) - (int32_t)(l_118.f1 ^= (((p_100 & ((uint16_t)0x2A76 - (uint16_t)0xE93D)) <= (((int16_t)(!(((l_395 , (((uint16_t)(l_395.f1 = ((int16_t)0x0AED + (int16_t)((int16_t)((l_118.f3 , (~(((~0xF11D) != l_295.f3) & l_395.f2))) && l_404) + (int16_t)l_385))) >> (uint16_t)5) , 0)) > p_100) != p_100)) >> (int16_t)l_149.f1) < 0x749FE29D)) <= 0x0496602C)))) > l_405) < p_100) + (uint16_t)0xCD4D))) + (uint32_t)l_395.f2));
        }
        else
        { /* block id: 247 */
            int32_t l_419 = 4;
            struct S1 l_420 = {7228,10,58,-5318,3021,-1430};
            l_295.f3 = (-(uint16_t)((uint32_t)p_100 - (uint32_t)(((uint16_t)(p_100 && ((p_100 , p_100) && (0x9E3D < __builtin_popcountl(l_414)))) >> (uint16_t)(((int32_t)l_118.f1 - (int32_t)((int16_t)p_100 * (int16_t)p_100)) && p_100)) >= 0x4D4A)));
            p_100 = (((func_105((p_100 == ((0xB6892B8C >= (p_100 ^ p_100)) < (l_291.f1 |= (l_118.f1 = (l_419 = (p_100 == (p_100 || (l_295 , (((l_133 ^= p_100) , ((l_118.f3 > 0x686F) , l_149.f5)) & 4294967287U)))))))))) != l_149.f2) || (-7)) <= p_100);
            l_149 = l_420;
            l_118.f1 = (p_100 = l_133);
        }
    }
    else
    { /* block id: 258 */
        int32_t l_425 = 0x02A5E161;
        struct S0 l_426 = {1,12,9,7,9};
        int8_t l_428 = (-6);
        l_149.f5 |= (1 > ((((__builtin_ffsll((((uint32_t)(p_100 && ((int16_t)l_425 - (int16_t)func_105(p_100))) % (uint32_t)(l_426 , (-(int16_t)(l_428 , func_105(((l_118 , 0xC626A049) && 0x5071BD91)))))) || p_100)) || 0xAEA2844B) > p_100) & p_100) , l_133));
        for (l_376 = 0; (l_376 < (-23)); l_376 -= 6)
        { /* block id: 262 */
            p_100 = l_118.f0;
        }
        p_100 = l_376;
    }
    l_149 = l_149;
    return p_100;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_105(uint32_t  p_106)
{ /* block id: 58 */
    uint32_t l_111 = 4294967291U;
    int32_t l_112 = 0x5145DB5E;
    int16_t l_115 = 0x93AA;
    int32_t l_116 = 0x83651A33;
    int32_t l_117 = 0;
    l_117 = (!((int32_t)(l_112 = l_111) + (int32_t)((p_106 < p_106) , (0x4211 & ((uint16_t)((l_115 = 0x8A331708) == (l_116 = l_111)) << (uint16_t)12)))));
    return p_106;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 136
   depth: 1, occurrence: 50
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 50
breakdown:
   indirect level: 0, occurrence: 50
XXX full-bitfields structs in the program: 26
breakdown:
   indirect level: 0, occurrence: 26
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 27
XXX times a bitfields struct on RHS: 54
XXX times a single bitfield on LHS: 59
XXX times a single bitfield on RHS: 101

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 159
   depth: 2, occurrence: 36
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 2
   depth: 8, occurrence: 4
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 2
   depth: 25, occurrence: 3
   depth: 26, occurrence: 1
   depth: 27, occurrence: 3
   depth: 29, occurrence: 3
   depth: 31, occurrence: 1
   depth: 34, occurrence: 1
   depth: 38, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 600
XXX times a non-volatile is write: 231
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 158
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 21
   depth: 2, occurrence: 35
   depth: 3, occurrence: 28
   depth: 4, occurrence: 22
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 23.4
XXX percentage an existing variable is used: 76.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

