/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3269804654
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int16_t  f0;
   const uint8_t  f1;
   int32_t  f2;
   uint32_t  f3;
   uint64_t  f4;
   uint64_t  f5;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   const unsigned f0 : 2;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S2 {
   signed f0 : 5;
   signed f1 : 17;
   signed f2 : 25;
   signed f3 : 19;
   unsigned f4 : 29;
   unsigned f5 : 26;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S3 {
   signed f0 : 21;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_31(void);
static int32_t  func_32(uint32_t  p_33, struct S2  p_34, const uint8_t  p_35, uint64_t  p_36);
inline static uint32_t  func_39(int16_t  p_40, const uint32_t  p_41, uint32_t  p_42, struct S0  p_43);
static uint16_t  func_48(int32_t  p_49, uint32_t  p_50, uint16_t  p_51, int32_t  p_52, int64_t  p_53);
inline static uint32_t  func_54(int16_t  p_55, int16_t  p_56, uint32_t  p_57, int16_t  p_58);
static uint64_t  func_59(const uint32_t  p_60, uint32_t  p_61);
static uint16_t  func_65(int32_t  p_66, uint8_t  p_67);
inline static int64_t  func_72(uint32_t  p_73, float  p_74, struct S0  p_75, const int32_t  p_76, uint8_t  p_77);
inline static float  func_79(struct S1  p_80, int32_t  p_81, const struct S2  p_82);
inline static int32_t * func_90(uint32_t  p_91, float  p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_31(void)
{ /* block id: 36 */
    int16_t l_44 = 0xD8C6L;
    uint32_t l_62 = 4294967292UL;
    int64_t l_326 = 0x547E73FD26EDBF72LL;
    struct S0 l_386 = {0x80BFL,0x12L,0x38A6AAD2L,0x5BDA2F7AL,0xA2C9F24EA310EAAELL,6UL};
    struct S2 l_395 = {-3,264,5011,475,22641,8165};
    struct S2 *l_405 = &l_395;
    struct S2 **l_404 = &l_405;
    int32_t l_455 = 0xD1249C85L;
    int32_t *l_454 = &l_455;
    struct S3 l_457 = {-1332};
    int64_t l_465 = 0x1ABD8A15FCD97547LL;
    int32_t l_470 = 0x50826CEAL;
    float l_479 = 0x1.6p+1;
    float *l_478 = &l_479;
    int16_t l_480 = 1L;
    if (func_32(((uint64_t)(func_39((l_44 && (!(((uint16_t)(func_48(l_44, func_54((func_59(((0x74BB9CEC02DFCE95LL ^ l_62) | (-10L)), ((uint16_t)func_65(l_44, l_62) % (uint16_t)((int32_t)((uint32_t)l_326 + (uint32_t)0x3F702E61L) / (int32_t)l_44))) && l_62), l_326, l_326, l_44), l_326, l_326, l_326) <= 5UL) >> (uint16_t)15) & 1L))), l_62, l_62, l_386) != l_386.f2) + (uint64_t)0x7D78C674DE13DCA1LL), l_395, l_386.f4, l_395.f0))
    { /* block id: 208 */
        struct S2 * const l_403 = &l_395;
        struct S2 * const *l_402 = &l_403;
        int32_t l_406 = 0xDBD902C9L;
        int16_t l_414 = 0x46B7L;
        struct S3 *l_424 = (void*)0;
        struct S3 ** const l_423 = &l_424;
        struct S3 ** const *l_422 = &l_423;
        float l_448 = 0x0.0p-1;
        float *l_447 = &l_448;
        float **l_446 = &l_447;
        if (((int16_t)(__builtin_ffsl((l_402 != l_404)) && l_326) / (int16_t)l_406))
        { /* block id: 209 */
            struct S2 * const **l_407 = (void*)0;
            struct S2 ***l_409 = &l_404;
            struct S2 ****l_408 = &l_409;
            (*l_408) = l_407;
            /* statement id: 210 */
            assert (l_409 == 0);
        }
        else
        { /* block id: 211 */
            uint16_t l_415 = 0x2B4AL;
            struct S2 l_428 = {3,-47,-2154,-509,230,4599};
            struct S0 *l_431 = &l_386;
            struct S0 **l_430 = &l_431;
            int32_t *l_437 = (void*)0;
            int32_t **l_436 = &l_437;
            int32_t ***l_435 = &l_436;
            int32_t ****l_434 = &l_435;
            int32_t *****l_433 = &l_434;
            if ((((__builtin_ctz(l_395.f5) < ((int16_t)((int16_t)0xAEC1L >> (int16_t)9) + (int16_t)((l_414 & l_386.f0) > l_415))) > (((uint16_t)((uint16_t)((((int64_t)((l_422 == (void*)0) && __builtin_parity(l_395.f1)) % (int64_t)l_415) && l_415) | 0xDCAE9CAECE9F2422LL) >> (uint16_t)9) << (uint16_t)6) >= 0L)) != l_395.f2))
            { /* block id: 212 */
                struct S2 ***l_425 = &l_404;
                struct S2 ****l_426 = &l_425;
                int32_t l_427 = (-1L);
                struct S0 ***l_432 = &l_430;
                (*l_426) = l_425;
                if ((l_414 || __builtin_popcountll(((l_386.f2 <= (l_427 < 0L)) < __builtin_popcount(l_414)))))
                { /* block id: 214 */
                    return l_326;
                }
                else
                { /* block id: 216 */
                    int32_t *l_429 = &l_406;
                    (*l_403) = l_428;
                    (*l_429) = l_395.f4;
                }
                (*l_432) = l_430;
            }
            else
            { /* block id: 221 */
                l_433 = l_433;
            }
            for (l_406 = 0; (l_406 < (-23)); l_406--)
            { /* block id: 226 */
                int32_t *l_440 = &l_406;
                const struct S0 *l_451 = &l_386;
                const struct S0 **l_450 = &l_451;
                (***l_434) = l_440;
                /* statement id: 227 */
                assert (l_437 == &l_406);
                if (l_414)
                    continue;
                for (l_386.f2 = 0; (l_386.f2 < (-19)); l_386.f2 -= 8)
                { /* block id: 231 */
                    struct S2 **l_443 = &l_405;
                    (*l_443) = (*l_402);
                    if ((*l_440))
                        continue;
                }
                if (((int32_t)l_386.f4 / (int32_t)__builtin_ctzll((*l_440))))
                { /* block id: 235 */
                    float ***l_449 = &l_446;
                    (*l_449) = l_446;
                }
                else
                { /* block id: 237 */
                    int32_t l_453 = 6L;
                    int32_t *l_452 = &l_453;
                    (*l_452) = ((&l_431 == l_450) && l_44);
                    return l_406;
                }
                if (l_428.f1)
                    goto lbl_456;
            }
            /* facts after for loop */
            assert (l_437 == &l_406 || l_437 == 0);
            (**l_435) = l_454;
            /* statement id: 242 */
            assert (l_437 == &l_455);
        }
lbl_456:
        (*l_447) = l_414;
        l_457 = l_457;
    }
    else
    { /* block id: 247 */
        const int32_t **l_460 = (void*)0;
        const int32_t ***l_459 = &l_460;
        const int32_t ****l_458 = &l_459;
        int32_t l_461 = 0x5F58C2DDL;
        int32_t **l_462 = &l_454;
        l_454 = func_90((((((void*)0 != l_458) || func_65(l_461, (*l_454))) || __builtin_ffsll(((0x3403350E35CE9EFBLL <= ((*l_454) || (1UL != (*l_454)))) ^ (*l_454)))) >= 1L), l_461);
        /* statement id: 248 */
        assert (l_454 == 0);
        (*l_462) = &l_455;
        /* statement id: 249 */
        assert (l_454 == &l_455);
        (*l_462) = (void*)0;
        /* statement id: 250 */
        assert (l_454 == 0);
    }
    /* facts after branching */
    assert (l_454 == 0 || l_454 == &l_455);
    for (l_386.f2 = (-15); (l_386.f2 >= (-25)); --l_386.f2)
    { /* block id: 254 */
        uint32_t l_473 = 4294967295UL;
        struct S2 *l_474 = &l_395;
        int32_t *l_475 = (void*)0;
        int32_t *l_476 = (void*)0;
        int32_t l_477 = 1L;
        l_477 = ((0x3309E014EA22C1ADLL & l_465) != ((uint16_t)(((uint16_t)((l_470 > l_470) >= ((uint16_t)(l_473 ^ __builtin_ctzll((((l_474 == (*l_404)) || (l_473 < l_473)) ^ l_473))) / (uint16_t)l_473)) << (uint16_t)l_473) && l_473) << (uint16_t)5));
    }
    (*l_478) = (l_386.f2 == (l_395.f5 > l_395.f0));
    return l_480;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_32(uint32_t  p_33, struct S2  p_34, const uint8_t  p_35, uint64_t  p_36)
{ /* block id: 205 */
    int32_t l_396 = 0L;
    int32_t l_399 = 0L;
    int32_t *l_398 = &l_399;
    int32_t **l_397 = &l_398;
    (*l_397) = func_90(l_396, p_34.f1);
    /* statement id: 206 */
    assert (l_398 == 0);
    return p_34.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_39(int16_t  p_40, const uint32_t  p_41, uint32_t  p_42, struct S0  p_43)
{ /* block id: 201 */
    struct S3 l_389 = {-777};
    struct S3 *l_388 = &l_389;
    struct S3 **l_387 = &l_388;
    int32_t l_392 = (-6L);
    int32_t *l_391 = &l_392;
    int32_t **l_390 = &l_391;
    struct S0 l_394 = {-3L,0x41L,3L,4294967295UL,18446744073709551615UL,1UL};
    const struct S0 *l_393 = &l_394;
    (*l_390) = func_90(((l_387 == &l_388) <= p_43.f0), p_43.f5);
    /* statement id: 202 */
    assert (l_391 == 0);
    l_393 = (void*)0;
    /* statement id: 203 */
    assert (l_393 == 0);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_48(int32_t  p_49, uint32_t  p_50, uint16_t  p_51, int32_t  p_52, int64_t  p_53)
{ /* block id: 197 */
    float l_378 = 0x1.369F49p-34;
    int32_t l_379 = 0x35307B5EL;
    struct S3 l_383 = {-47};
    struct S3 *l_382 = &l_383;
    struct S3 **l_381 = &l_382;
    struct S3 ** const *l_380 = &l_381;
    int32_t *l_385 = &l_379;
    int32_t **l_384 = &l_385;
    (*l_384) = func_90(l_379, (((l_380 != (void*)0) > __builtin_ia32_crc32qi(l_379, l_383.f0)) < 0xE.B2535Bp+1));
    /* statement id: 198 */
    assert (l_385 == 0);
    p_52 = p_49;
    return l_379;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_54(int16_t  p_55, int16_t  p_56, uint32_t  p_57, int16_t  p_58)
{ /* block id: 166 */
    float l_350 = 0x1.642408p+39;
    struct S1 l_352 = {0};
    struct S1 *l_351 = &l_352;
    struct S2 *l_360 = (void*)0;
    int32_t l_365 = 0xC55E803DL;
    int32_t *l_364 = &l_365;
    struct S2 l_377 = {-3,-252,-5207,605,13248,4407};
    struct S2 *l_376 = &l_377;
    if (p_56)
    { /* block id: 167 */
        struct S1 **l_353 = &l_351;
        int32_t l_355 = (-10L);
        int32_t *l_354 = &l_355;
        (*l_353) = l_351;
        if (((*l_353) == &l_352))
        { /* block id: 169 */
            int32_t **l_356 = &l_354;
            (*l_356) = l_354;
        }
        else
        { /* block id: 171 */
            for (p_56 = 0; (p_56 > (-13)); p_56--)
            { /* block id: 174 */
                uint8_t l_359 = 1UL;
                (*l_354) = (p_58 == 0x378EE980L);
                if (l_359)
                    continue;
                return l_359;
            }
            return l_352.f0;
        }
        l_354 = func_90(p_56, (*l_354));
        /* statement id: 181 */
        assert (l_354 == 0);
    }
    else
    { /* block id: 182 */
        struct S3 l_362 = {-141};
        struct S1 **l_371 = &l_351;
        struct S1 *** const l_370 = &l_371;
        struct S2 l_375 = {-2,-94,-3255,122,21771,3259};
        struct S2 *l_374 = &l_375;
        if ((l_360 == l_360))
        { /* block id: 183 */
            float *l_361 = &l_350;
            struct S3 *l_363 = &l_362;
            (*l_361) = 0x0.E144FAp-48;
            (*l_363) = l_362;
            if (p_56)
            { /* block id: 186 */
                int32_t **l_366 = &l_364;
                (*l_366) = l_364;
                (*l_366) = l_361;
                /* statement id: 188 */
                assert (l_364 == &l_350);
            }
            else
            { /* block id: 189 */
                int32_t *l_367 = &l_365;
                l_367 = func_90(p_57, (p_58 >= p_56));
                /* statement id: 190 */
                assert (l_367 == 0);
            }
            /* facts after branching */
            assert (l_364 == &l_365 || l_364 == &l_350);
        }
        else
        { /* block id: 192 */
            struct S1 **l_369 = &l_351;
            struct S1 ***l_368 = &l_369;
            (*l_364) = (((l_368 == l_370) < (p_56 < (&l_352 == &l_352))) == (~__builtin_bswap64(((-(int32_t)((0xA70B46EAL < (l_374 == l_376)) == (p_56 || 0xC95829EE725D3417LL))) <= 1L))));
        }
        /* facts after branching */
        assert (l_364 == &l_365 || l_364 == &l_350);
    }
    /* facts after branching */
    assert (l_364 == &l_365 || l_364 == &l_350);
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_59(const uint32_t  p_60, uint32_t  p_61)
{ /* block id: 163 */
    int32_t l_341 = (-1L);
    int64_t l_347 = 1L;
    int32_t l_349 = 4L;
    int32_t *l_348 = &l_349;
    (*l_348) = ((uint16_t)(((uint32_t)((uint16_t)((uint16_t)((int16_t)(((uint32_t)(((uint64_t)p_60 - (uint64_t)(l_341 & 0UL)) & (((int32_t)(+65535UL) % (int32_t)(l_341 & l_341)) > ((int16_t)((l_341 >= (p_61 == (l_347 && l_341))) > p_61) << (int16_t)p_61))) - (uint32_t)p_60) <= p_60) << (int16_t)5) << (uint16_t)6) + (uint16_t)l_347) % (uint32_t)l_341) != l_341) << (uint16_t)9);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_65(int32_t  p_66, uint8_t  p_67)
{ /* block id: 37 */
    uint64_t l_78 = 18446744073709551615UL;
    struct S1 l_83 = {0};
    const struct S2 l_88 = {-0,-12,-1821,355,16395,2727};
    struct S0 l_161 = {0x35F2L,0x76L,0x25F51048L,0x48039CC8L,0xD979A8B53E2DD196LL,0x61E54E034D058532LL};
    int32_t l_321 = 0L;
    int32_t *l_320 = &l_321;
    (*l_320) = ((uint16_t)((uint32_t)((__builtin_ctz((0x7160C637L == p_67)) && p_67) > func_72(l_78, (func_79(l_83, ((int32_t)__builtin_parityl(p_66) - (int32_t)((int16_t)(l_78 != p_66) << (int16_t)l_78)), l_88) == p_67), l_161, p_67, p_67)) / (uint32_t)1UL) >> (uint16_t)l_161.f1);
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_72(uint32_t  p_73, float  p_74, struct S0  p_75, const int32_t  p_76, uint8_t  p_77)
{ /* block id: 75 */
    struct S1 l_163 = {0};
    struct S1 *l_162 = &l_163;
    struct S3 l_217 = {386};
    int32_t l_230 = (-8L);
    int32_t *l_229 = &l_230;
    int32_t **l_228 = &l_229;
    struct S2 l_249 = {2,120,3936,-638,2579,4021};
    const struct S2 *l_248 = &l_249;
    l_162 = l_162;
    for (p_75.f4 = 0; (p_75.f4 <= 5); p_75.f4 += 6)
    { /* block id: 79 */
        uint32_t l_166 = 0x1BBB9F26L;
        int32_t l_168 = 0x41C76BB4L;
        int32_t *l_167 = &l_168;
        int32_t *l_197 = (void*)0;
        const struct S2 l_224 = {0,203,1155,-462,1503,7022};
        uint16_t l_225 = 65535UL;
        struct S3 *l_250 = &l_217;
        struct S3 *l_251 = &l_217;
        uint32_t l_279 = 18446744073709551615UL;
        struct S2 *l_287 = &l_249;
        struct S2 **l_286 = &l_287;
        struct S2 l_300 = {-3,83,-2615,297,16902,1569};
        int32_t l_316 = 8L;
        (*l_167) = l_166;
    }
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_79(struct S1  p_80, int32_t  p_81, const struct S2  p_82)
{ /* block id: 38 */
    uint8_t l_89 = 255UL;
    uint64_t l_108 = 0UL;
    int32_t l_121 = 9L;
    int32_t *l_120 = &l_121;
    int32_t ***l_124 = (void*)0;
    uint8_t l_134 = 0xC5L;
    struct S1 *l_147 = (void*)0;
    struct S1 **l_146 = &l_147;
    int64_t l_150 = 0x16C98A276184417FLL;
    float l_158 = 0x6.6A1522p+87;
    int32_t **l_160 = &l_120;
    if (l_89)
    { /* block id: 39 */
        uint32_t l_101 = 0xA37A5474L;
        int32_t l_107 = 0x1C80F86AL;
        int32_t * const l_106 = &l_107;
        int32_t *l_115 = &l_107;
        int32_t **l_114 = &l_115;
        (*l_114) = func_90((l_89 == (((uint16_t)((((int16_t)(((int16_t)((uint16_t)l_101 >> (uint16_t)((uint32_t)p_82.f3 - (uint32_t)(((uint16_t)l_89 << (uint16_t)l_89) | (p_82.f0 <= p_82.f1)))) >> (int16_t)12) != (l_106 == &l_107)) << (int16_t)(*l_106)) | l_108) >= p_82.f3) << (uint16_t)6) == p_82.f3)), p_80.f0);
        /* statement id: 48 */
        assert (l_115 == 0);
        (*l_106) = (0x384E059069C78C3DLL && ((int16_t)((uint64_t)(l_120 == (void*)0) + (uint64_t)18446744073709551615UL) << (int16_t)(*l_120)));
    }
    else
    { /* block id: 50 */
        int32_t **l_123 = (void*)0;
        int32_t ***l_122 = &l_123;
        int32_t ** const *l_125 = (void*)0;
        float l_127 = 0xC.00BAF9p-22;
        float *l_126 = &l_127;
        (*l_122) = &l_120;
        /* statement id: 51 */
        assert (l_123 == &l_120);
        (*l_126) = (l_124 == l_125);
        for (p_81 = 0; (p_81 >= (-20)); p_81--)
        { /* block id: 55 */
            (*l_123) = func_90(p_81, ((p_82.f0 < (-0x1.Ap-1)) == (p_82.f0 != ((((((***l_122) >= (((float)((float)l_134 / (float)(&l_121 == (void*)0)) + (float)(&l_123 != (void*)0)) == (*l_120))) == 0x1.7p+1) >= p_82.f5) > p_82.f2) > (***l_122)))));
            /* statement id: 56 */
            assert (l_120 == 0);
            return p_82.f0;
        }
        if (p_82.f0)
        { /* block id: 59 */
            int64_t l_137 = (-1L);
            int32_t *l_138 = &l_121;
            l_138 = func_90(((p_81 <= ((((1UL | (p_82.f3 || ((int16_t)((***l_122) <= (0x87E9A703L || ((**l_122) != (*l_123)))) >> (int16_t)(*l_120)))) <= (*l_120)) || l_137) & p_82.f0)) > 6L), p_82.f5);
            /* statement id: 60 */
            assert (l_138 == 0);
        }
        else
        { /* block id: 61 */
            const struct S1 l_144 = {1};
            const struct S1 *l_143 = &l_144;
            const struct S1 **l_142 = &l_143;
            for (l_121 = 0; (l_121 != 15); ++l_121)
            { /* block id: 64 */
                uint32_t l_141 = 0xF1C15673L;
                return l_141;
            }
            if (l_108)
                goto lbl_145;
lbl_145:
            (*l_142) = &p_80;
            /* statement id: 67 */
            assert (l_143 == &p_80);
            (**l_122) = &l_121;
        }
    }
    (*l_146) = &p_80;
    /* statement id: 72 */
    assert (l_147 == &p_80);
    (*l_160) = func_90(((int16_t)l_150 + (int16_t)((((int32_t)(((uint16_t)p_82.f3 << (uint16_t)((uint16_t)((~__builtin_clzl((*l_120))) ^ p_82.f4) >> (uint16_t)10)) > ((((*l_146) != (void*)0) || (~__builtin_bswap64(p_82.f4))) | 0UL)) % (int32_t)4294967289UL) & (*l_120)) < p_82.f3)), (*l_120));
    /* statement id: 73 */
    assert (l_120 == 0);
    return p_82.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_90(uint32_t  p_91, float  p_92)
{ /* block id: 40 */
    int32_t *l_113 = (void*)0;
    for (p_91 = 0; (p_91 >= 23); p_91 += 1)
    { /* block id: 43 */
        int32_t l_112 = 0x7A4FD34EL;
        int32_t *l_111 = &l_112;
        (*l_111) = p_91;
        return l_113;
        /* statement id: 45 */
        //assert (func_90_rv == 0);
    }
    return l_113;
    /* statement id: 47 */
    //assert (func_90_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 101
   depth: 1, occurrence: 18
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 41
breakdown:
   indirect level: 0, occurrence: 16
   indirect level: 1, occurrence: 12
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 6
XXX full-bitfields structs in the program: 16
breakdown:
   indirect level: 0, occurrence: 16
XXX times a bitfields struct's address is taken: 28
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 31
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 43

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 12
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 2
   depth: 34, occurrence: 1

XXX total number of pointers: 126

XXX times a variable address is taken: 130
XXX times a pointer is dereferenced on RHS: 39
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 4
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 62
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 167

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 105
   level: 2, occurrence: 21
   level: 3, occurrence: 14
   level: 4, occurrence: 5
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 63
XXX number of pointers point to scalars: 36
XXX number of pointers point to structs: 27
XXX percent of pointers has null in alias set: 25.4
XXX average alias set size: 1.13

XXX times a non-volatile is read: 459
XXX times a non-volatile is write: 163
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 0

XXX stmts: 89
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 20
   depth: 2, occurrence: 18
   depth: 3, occurrence: 16
   depth: 4, occurrence: 8

XXX percentage a fresh-made variable is used: 25.3
XXX percentage an existing variable is used: 74.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

