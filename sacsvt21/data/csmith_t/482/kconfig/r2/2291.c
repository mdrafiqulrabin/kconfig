/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      713914156
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_33(void);
inline static int32_t * func_40(int16_t  p_41, int32_t * p_42, int16_t  p_43, uint32_t  p_44);
static uint16_t  func_60(float  p_61, int32_t * p_62, int32_t  p_63, int32_t  p_64, int32_t * p_65);
inline static int32_t * func_67(int32_t * p_68, uint32_t  p_69, int32_t * p_70);
inline static int32_t * func_71(int32_t  p_72);
inline static int32_t * func_73(int32_t  p_74);
static int32_t ** func_75(int32_t  p_76, int32_t  p_77, int32_t  p_78, uint16_t  p_79, int16_t  p_80);
static int32_t * func_94(int16_t  p_95, int16_t  p_96);
static int16_t  func_99(float  p_100);
inline static int32_t * func_110(uint32_t  p_111, uint32_t  p_112);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_33(void)
{ /* block id: 36 */
    int32_t l_34 = 0xD0890515L;
    int16_t l_286 = 0xAD04L;
    int32_t l_296 = (-6L);
    for (l_34 = 0; (l_34 > (-28)); l_34 -= 8)
    { /* block id: 39 */
        int32_t l_37 = 0xAB6DAD81L;
        int32_t l_278 = 6L;
        float l_289 = 0x0.9p-1;
        int32_t l_290 = 1L;
        int32_t ***l_291 = (void*)0;
        int32_t ***l_292 = (void*)0;
        int32_t **l_294 = (void*)0;
        int32_t ***l_293 = &l_294;
        uint32_t l_295 = 0x53347AF6L;
        for (l_37 = (-7); (l_37 >= 27); l_37 += 1)
        { /* block id: 42 */
            int32_t *l_52 = &l_37;
            if (l_37)
            { /* block id: 43 */
                int32_t l_49 = 0xFBA2522AL;
                int32_t *l_55 = &l_37;
                int32_t l_274 = 5L;
                int32_t *l_273 = &l_274;
                if (l_34)
                    break;
                l_273 = func_40(((uint16_t)1UL % (uint16_t)((int32_t)((l_49 || 2UL) <= ((uint16_t)0UL >> (uint16_t)1)) + (int32_t)l_37)), l_52, ((uint16_t)(((&l_37 != l_55) < (&l_37 != (void*)0)) != (*l_55)) << (uint16_t)9), l_37);
            }
            else
            { /* block id: 165 */
                int16_t l_275 = (-1L);
                int32_t *l_276 = (void*)0;
                int32_t *l_277 = (void*)0;
                uint16_t l_279 = 0x3DCBL;
                float l_281 = 0xC.D8338Cp-93;
                float *l_280 = &l_281;
                l_278 = l_275;
                (*l_280) = l_279;
                if (l_37)
                    break;
                if (l_37)
                    continue;
            }
            if ((*l_52))
                continue;
            if (l_34)
                break;
            if (l_34)
                continue;
        }
        for (l_278 = 0; (l_278 <= 22); l_278 += 4)
        { /* block id: 177 */
            return l_34;
        }
        (*l_293) = func_75(l_34, (((l_278 <= 2L) <= (65526UL || l_37)) <= (((int16_t)((l_286 > l_278) == ((func_99(((((float)l_37 - (float)(l_37 > l_34)) == (-0x1.6p+1)) < l_286)) <= 0x60B6L) != l_286)) % (int16_t)l_290) == l_37)), l_34, l_34, l_286);
        l_296 = (0x9F5BL < l_295);
    }
    return l_296;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_40(int16_t  p_41, int32_t * p_42, int16_t  p_43, uint32_t  p_44)
{ /* block id: 45 */
    uint16_t l_56 = 65526UL;
    int32_t l_57 = 0xA7C76986L;
    float l_66 = 0x1.0p-1;
    int32_t *l_258 = &l_57;
    int32_t ****l_267 = (void*)0;
    int32_t **l_272 = &l_258;
    l_57 = l_56;
    (*l_258) = ((uint16_t)func_60(l_66, p_42, l_57, __builtin_clzll(l_57), func_67(func_71((p_42 == p_42)), l_56, &l_57)) >> (uint16_t)l_56);
    for (p_41 = 0; (p_41 < (-17)); p_41 -= 8)
    { /* block id: 159 */
        l_258 = p_42;
    }
    (*l_272) = func_110((((-(uint32_t)((uint16_t)__builtin_bswap64((-(int16_t)(((uint32_t)((void*)0 != l_267) % (uint32_t)((uint16_t)0xB939L % (uint16_t)p_43)) == __builtin_popcountl((*l_258))))) + (uint16_t)__builtin_ctz((((int32_t)(__builtin_popcountll(((l_267 != (void*)0) > 6L)) ^ (*p_42)) % (int32_t)0x82091717L) != p_44)))) >= p_41) != (*l_258)), p_41);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads : l_37
 * writes:
 */
static uint16_t  func_60(float  p_61, int32_t * p_62, int32_t  p_63, int32_t  p_64, int32_t * p_65)
{ /* block id: 112 */
    uint32_t l_214 = 18446744073709551615UL;
    uint32_t l_240 = 18446744073709551615UL;
    int32_t **l_245 = (void*)0;
    int32_t ***l_244 = &l_245;
    int32_t ****l_243 = &l_244;
    int32_t l_253 = (-1L);
    int32_t *l_252 = &l_253;
    if (((int16_t)((((0x1D64L == ((uint16_t)l_214 - (uint16_t)0xC0A8L)) && (0xF5E1A509L ^ 0x7E5EAF47L)) && 0x046C6167L) < func_99(p_64)) >> (int16_t)0))
    { /* block id: 113 */
        int32_t ****l_246 = &l_244;
        int32_t **l_255 = &l_252;
        for (p_64 = (-23); (p_64 != (-23)); p_64 += 5)
        { /* block id: 116 */
            for (p_63 = 0; (p_63 >= (-27)); p_63 -= 1)
            { /* block id: 119 */
                int32_t l_222 = 0x108BF7B5L;
                int32_t *l_221 = &l_222;
                for (l_214 = 0; (l_214 <= 41); l_214 += 4)
                { /* block id: 122 */
                    int32_t **l_223 = &l_221;
                    (*l_223) = l_221;
                    for (l_222 = 0; (l_222 >= (-5)); l_222 -= 1)
                    { /* block id: 126 */
                        (*l_223) = (void*)0;
                    }
                    if (l_214)
                    { /* block id: 129 */
                        (*l_223) = func_94((p_64 && func_99(p_61)), ((uint32_t)((uint32_t)(0xDB04L ^ ((((int16_t)p_63 << (int16_t)((-(uint16_t)((~0x77572B0FL) & ((uint16_t)(((int16_t)__builtin_clz(p_64) >> (int16_t)5) | ((int16_t)((1UL <= 0L) == p_64) >> (int16_t)5)) << (uint16_t)8))) | p_63)) | p_63) > l_240)) + (uint32_t)l_240) % (uint32_t)0x371BD32CL));
                        if ((*p_62))
                            break;
                    }
                    else
                    { /* block id: 132 */
                        uint32_t l_241 = 0xCB8965CCL;
                        int32_t *l_242 = &l_222;
                        (*l_223) = p_65;
                        l_241 = (p_63 ^ (0x747B503CL | (func_99((*l_221)) <= p_64)));
                        (*l_223) = l_242;
                    }
                }
            }
            if (((&p_62 == (void*)0) || 9UL))
            { /* block id: 139 */
                float l_248 = 0x2.Fp+1;
                float *l_247 = &l_248;
                (*l_247) = (l_243 != l_246);
            }
            else
            { /* block id: 141 */
                int16_t l_249 = 7L;
                if (l_249)
                    break;
            }
        }
        for (p_64 = 24; (p_64 == (-23)); p_64 -= 1)
        { /* block id: 147 */
            uint16_t l_254 = 5UL;
            l_252 = p_62;
            return l_254;
        }
        (*l_255) = p_62;
    }
    else
    { /* block id: 152 */
        (*p_65) = (0xB481F414L != ((uint32_t)__builtin_popcount(p_64) - (uint32_t)0x7E9F7C02L));
    }
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_67(int32_t * p_68, uint32_t  p_69, int32_t * p_70)
{ /* block id: 103 */
    int32_t l_208 = 2L;
    int32_t l_209 = 0x2479E727L;
    for (p_69 = 16; (p_69 > 45); p_69 += 1)
    { /* block id: 106 */
        int32_t l_207 = 0xB63C3F2BL;
        if (l_207)
            break;
        return p_70;
    }
    l_209 = l_208;
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_71(int32_t  p_72)
{ /* block id: 47 */
    int32_t *l_181 = (void*)0;
    int32_t **l_180 = &l_181;
    int32_t ***l_184 = &l_180;
    int32_t ****l_183 = &l_184;
    int32_t *****l_182 = &l_183;
    int32_t l_185 = 0L;
    int16_t l_188 = 3L;
    int32_t *l_202 = &l_185;
    int32_t *l_203 = &l_185;
    int32_t *l_204 = (void*)0;
    (*l_180) = func_73(p_72);
    l_185 = __builtin_ctzl((__builtin_ctzl(p_72) && ((void*)0 == l_182)));
    if ((((((0x7A455DDAL || p_72) & (&l_183 != &l_183)) < ((int16_t)l_188 << (int16_t)5)) < func_99((p_72 > p_72))) & 0L))
    { /* block id: 93 */
        uint32_t l_191 = 1UL;
        float l_193 = 0x1.3p+1;
        float *l_192 = &l_193;
        (**l_184) = func_94(((uint16_t)(__builtin_parity(p_72) ^ l_191) % (uint16_t)(p_72 && p_72)), p_72);
        p_72 = (p_72 || 0x275D6FB8L);
        (**l_184) = func_73(p_72);
        (*l_192) = p_72;
    }
    else
    { /* block id: 98 */
        uint32_t l_195 = 0UL;
        p_72 = ((!(p_72 | l_195)) | (0x744FL >= p_72));
        (*l_180) = func_73(((0xD11ADAB7L <= ((uint32_t)(((uint16_t)((l_195 < p_72) != ((*l_180) == &p_72)) - (uint16_t)((int16_t)(__builtin_clz(l_195) && (-1L)) >> (int16_t)12)) && ((l_195 != p_72) <= 0UL)) % (uint32_t)l_195)) == p_72));
    }
    return l_204;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_73(int32_t  p_74)
{ /* block id: 48 */
    uint32_t l_81 = 1UL;
    int32_t l_85 = 1L;
    int32_t *l_84 = &l_85;
    int32_t **l_93 = &l_84;
    int32_t ***l_92 = &l_93;
    int32_t **l_134 = &l_84;
    uint32_t l_135 = 0x12332C83L;
    int16_t l_138 = 0x22D3L;
    int32_t l_140 = 0x975BB608L;
    int16_t l_143 = (-2L);
    int32_t *l_153 = &l_140;
    int32_t *l_154 = &l_140;
    int32_t *l_155 = &l_85;
    int32_t *l_156 = &l_140;
    int32_t *l_158 = &l_85;
    int32_t *l_159 = (void*)0;
    uint32_t l_175 = 4294967295UL;
    int16_t l_177 = 0xEE8AL;
    int32_t *l_178 = &l_85;
    int32_t *l_179 = (void*)0;
    (*l_92) = func_75((p_74 != __builtin_bswap64(l_81)), l_81, l_81, ((uint16_t)p_74 << (uint16_t)3), (l_84 == &l_85));
    (*l_134) = func_94(p_74, p_74);
    if (((l_135 && ((int16_t)(((l_138 & p_74) < (-(int16_t)__builtin_ctz(p_74))) < l_140) << (int16_t)2)) | ((uint16_t)(l_143 | ((int32_t)0x12AA013FL + (int32_t)(((uint16_t)(&l_92 != (void*)0) % (uint16_t)65535UL) && p_74))) + (uint16_t)p_74)))
    { /* block id: 72 */
        int32_t ****l_150 = &l_92;
        int32_t *l_152 = &l_140;
        int32_t *l_157 = &l_140;
        for (l_81 = (-30); (l_81 > 56); l_81 += 1)
        { /* block id: 75 */
            int32_t *****l_151 = &l_150;
            (*l_151) = l_150;
        }
        return l_159;
    }
    else
    { /* block id: 79 */
        float l_160 = 0x2.5917A2p-83;
        float *l_161 = &l_160;
        int32_t l_162 = 0x9C145D4FL;
        int32_t **l_176 = &l_156;
        (*l_161) = l_160;
        if (l_162)
        { /* block id: 81 */
            int32_t *l_163 = (void*)0;
            return l_163;
        }
        else
        { /* block id: 83 */
            int32_t *l_164 = &l_85;
            (*l_134) = l_164;
        }
        (*l_161) = func_99((*l_84));
        (**l_176) = (((float)(l_162 < (p_74 == ((float)((float)((float)((*l_155) <= 0x1.7p+1) - (float)((float)(0x9.Dp-1 != l_175) - (float)(((*l_92) != l_176) == ((((**l_176) == (**l_134)) == 0x4.D5121Ep+15) > (**l_176))))) - (float)(*l_154)) - (float)p_74))) - (float)l_177) != (**l_176));
    }
    (*l_134) = (*l_134);
    return l_179;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_75(int32_t  p_76, int32_t  p_77, int32_t  p_78, uint16_t  p_79, int16_t  p_80)
{ /* block id: 49 */
    int32_t l_88 = 0x8E480B0DL;
    int32_t *l_87 = &l_88;
    int32_t **l_86 = &l_87;
    int32_t **l_89 = &l_87;
    int32_t **l_90 = &l_87;
    int32_t **l_91 = (void*)0;
    return l_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_94(int16_t  p_95, int16_t  p_96)
{ /* block id: 52 */
    uint16_t l_101 = 0x3343L;
    int32_t l_109 = 0xFB601BA2L;
    int32_t *l_108 = &l_109;
    float l_114 = (-0x1.Bp+1);
    float *l_113 = &l_114;
    int32_t **l_121 = (void*)0;
    int32_t **l_122 = &l_108;
    int32_t ***l_124 = &l_121;
    int32_t ****l_123 = &l_124;
    int32_t *l_125 = &l_109;
    int32_t *l_126 = &l_109;
    int32_t *l_127 = &l_109;
    int32_t *l_128 = &l_109;
    int32_t *l_129 = &l_109;
    int32_t *l_130 = &l_109;
    int32_t *l_131 = &l_109;
    int32_t *l_132 = &l_109;
    int32_t *l_133 = (void*)0;
    (*l_108) = ((int16_t)func_99(l_101) >> (int16_t)5);
    (*l_122) = func_110((*l_108), (l_108 == l_113));
    (*l_123) = &l_122;
    return l_133;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_99(float  p_100)
{ /* block id: 53 */
    int32_t l_102 = 3L;
    float l_107 = 0x1.1p-1;
    float *l_106 = &l_107;
    for (l_102 = 0; (l_102 < (-3)); l_102 -= 1)
    { /* block id: 56 */
        float l_105 = 0x3.EE8DA5p-33;
        if (l_102)
            break;
    }
    (*l_106) = 0x0.Ep-1;
    return l_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_110(uint32_t  p_111, uint32_t  p_112)
{ /* block id: 62 */
    int32_t l_116 = (-1L);
    int32_t *l_115 = &l_116;
    int32_t **l_117 = &l_115;
    float l_119 = 0xA.E74433p+32;
    float *l_118 = &l_119;
    int32_t *l_120 = (void*)0;
    (*l_117) = l_115;
    (*l_117) = (*l_117);
    (*l_117) = (*l_117);
    (*l_118) = (*l_115);
    return l_120;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 92
XXX total union variables: 0

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 18
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1

XXX total number of pointers: 83

XXX times a variable address is taken: 71
XXX times a pointer is dereferenced on RHS: 21
breakdown:
   depth: 1, occurrence: 17
   depth: 2, occurrence: 4
XXX times a pointer is dereferenced on LHS: 33
breakdown:
   depth: 1, occurrence: 30
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 754

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 52
   level: 2, occurrence: 21
   level: 3, occurrence: 14
   level: 4, occurrence: 4
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 28
XXX number of pointers point to scalars: 55
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.1
XXX average alias set size: 1.1

XXX times a non-volatile is read: 239
XXX times a non-volatile is write: 92
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 88
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 24
   depth: 2, occurrence: 12
   depth: 3, occurrence: 9
   depth: 4, occurrence: 3
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 9.37
XXX percentage an existing variable is used: 90.6
********************* end of statistics **********************/

