/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3464918658
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 15;
   signed f1 : 8;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_3 = 0xE76F;
static uint32_t g_85 = 7U;
static int32_t g_118 = 1;
static int16_t g_128 = 0x5EB7;
static uint32_t g_129 = 4294967288U;
static struct S0 g_131 = {121,4};
static uint16_t g_152 = 65530U;
static int32_t g_203 = 0;
static uint32_t g_379 = 0x07E403E4;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_31(void);
static int32_t  func_36(int32_t  p_37, int32_t  p_38, uint16_t  p_39, uint32_t  p_40);
static int32_t  func_49(int32_t  p_50, uint16_t  p_51, struct S0  p_52, uint16_t  p_53);
static uint32_t  func_56(int16_t  p_57, uint32_t  p_58, int32_t  p_59, int32_t  p_60);
static uint32_t  func_69(uint32_t  p_70);
static uint16_t  func_71(struct S0  p_72);
static struct S0  func_91(int32_t  p_92, int32_t  p_93, int32_t  p_94, uint16_t  p_95, int32_t  p_96);
static int32_t  func_98(uint16_t  p_99, struct S0  p_100, int32_t  p_101, int16_t  p_102);
static uint32_t  func_106(struct S0  p_107, int32_t  p_108, int16_t  p_109);
static struct S0  func_110(int32_t  p_111, uint32_t  p_112, int16_t  p_113);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_85 g_131 g_128 g_152 g_129 g_118 g_203 g_379
 * writes: g_3 g_85 g_118 g_128 g_129 g_131.f1 g_203 g_152 g_131
 */
static uint32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_44 = 0xCCD20446;
    struct S0 l_380 = {85,-1};
    for (g_3 = 0; (g_3 > (-23)); g_3 -= 1)
    { /* block id: 39 */
        int32_t l_41 = 8;
        struct S0 l_376 = {73,15};
        if (((((int32_t)func_36((l_41 && ((int16_t)l_44 << (int16_t)3)), (~g_3), __builtin_popcountl((g_3 | g_3)), g_3) + (int32_t)(0x4360 || 0x003E)) != l_41) || l_44))
        { /* block id: 160 */
            int32_t l_375 = 0xD80145DC;
            l_380 = func_91(l_44, ((l_375 <= (g_118 == l_41)) & func_71(l_376)), l_376.f0, (((uint16_t)g_152 >> (uint16_t)4) ^ g_379), g_128);
            if (l_375)
                break;
        }
        else
        { /* block id: 163 */
            int32_t l_384 = 0xF1AAAB00;
            int32_t l_387 = 0;
            struct S0 l_392 = {72,-13};
            if (g_379)
                break;
            if (g_129)
                continue;
            for (g_152 = 2; (g_152 == 6); g_152 += 1)
            { /* block id: 168 */
                int16_t l_383 = 0x46FE;
                g_131 = func_110(g_131.f0, l_380.f0, l_383);
                g_131 = func_110(l_380.f1, g_129, ((4294967295U != 0xE9974B31) >= ((0x8589 && __builtin_ctzl(l_383)) && (l_384 || g_128))));
            }
            g_131 = func_91(g_118, (((uint16_t)l_387 + (uint16_t)l_380.f0) ^ ((uint16_t)((func_71(g_131) >= 0x096B) != l_384) % (uint16_t)func_98(((uint32_t)g_118 + (uint32_t)0xA55781F0), l_392, g_128, g_3))), g_131.f1, g_131.f1, l_384);
        }
        g_131 = g_131;
        for (g_152 = 10; (g_152 > 38); g_152 += 1)
        { /* block id: 177 */
            g_131.f1 = 0x51EA8057;
        }
        l_380.f1 = l_41;
    }
    g_131 = g_131;
    return l_380.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_85 g_131 g_128 g_152 g_129 g_118 g_203
 * writes: g_85 g_118 g_128 g_129 g_131.f1 g_203 g_152 g_131
 */
static int32_t  func_36(int32_t  p_37, int32_t  p_38, uint16_t  p_39, uint32_t  p_40)
{ /* block id: 40 */
    int32_t l_48 = 0;
    struct S0 l_73 = {71,3};
    uint16_t l_90 = 65531U;
    int16_t l_248 = 0;
    int16_t l_374 = 0x7634;
    l_374 = ((0xD743CCC0 ^ ((uint16_t)(((l_48 >= func_49(((uint32_t)func_56(p_38, l_48, ((((uint32_t)(g_3 <= ((int32_t)((int16_t)((uint32_t)(func_69(((func_71(l_73) <= 0x1DEC) == ((uint32_t)(((int16_t)l_48 << (int16_t)l_90) >= 0x32B8) % (uint32_t)p_40))) < 0x6DC5B995) % (uint32_t)0x13BAA924) + (int16_t)p_39) % (int32_t)l_48)) + (uint32_t)(-6)) < 1U) != l_73.f1), p_40) % (uint32_t)0x34F96D8E), l_73.f0, l_73, l_248)) >= g_3) >= p_37) << (uint16_t)4)) > l_48);
    return g_129;
}


/* ------------------------------------------ */
/* 
 * reads : g_152 g_131.f0 g_3 g_131 g_128 g_85 g_129 g_203 g_118
 * writes: g_152 g_118 g_128 g_129 g_85 g_131.f1 g_203
 */
static int32_t  func_49(int32_t  p_50, uint16_t  p_51, struct S0  p_52, uint16_t  p_53)
{ /* block id: 115 */
    int32_t l_257 = 8;
    int32_t l_258 = 0;
    for (g_152 = (-6); (g_152 < 28); g_152 += 1)
    { /* block id: 118 */
        struct S0 l_253 = {114,3};
        int16_t l_256 = 0x258D;
        int32_t l_263 = 8;
        p_52 = func_110((g_131.f0 | (func_71(func_110((func_98(g_131.f0, l_253, g_3, func_71(func_110(((int16_t)((func_106(g_131, l_256, p_50) ^ g_203) < l_253.f1) % (int16_t)l_257), g_131.f0, p_52.f1))) && l_258), p_53, g_3)) >= 0x57D1)), l_258, g_3);
        p_52.f1 = (((0x8A0C == g_129) & (-(int32_t)(((!l_253.f1) ^ (((((uint16_t)3U >> (uint16_t)l_257) >= (l_258 != (65535U >= (g_129 != l_263)))) ^ g_3) <= p_51)) < 4294967295U))) | 1U);
        if (((uint16_t)p_52.f1 - (uint16_t)((func_71(p_52) && ((uint16_t)p_52.f0 + (uint16_t)(__builtin_parity(l_258) == ((uint32_t)((uint16_t)0xA86C << (uint16_t)9) % (uint32_t)p_51)))) > (((int32_t)g_152 + (int32_t)p_52.f0) ^ 1U))))
        { /* block id: 121 */
            int32_t l_274 = (-1);
            g_131.f1 = (l_274 == p_52.f1);
        }
        else
        { /* block id: 123 */
            int32_t l_277 = (-1);
            int32_t l_291 = (-9);
            int32_t l_319 = (-1);
            struct S0 l_351 = {64,-13};
            g_131.f1 = (((g_129 != ((uint16_t)(__builtin_ctzl(l_263) || p_53) >> (uint16_t)4)) == l_277) || (0x29C7E725 < ((-(int16_t)((p_53 >= (-3)) || 1U)) > p_51)));
            if (((int16_t)(((int16_t)((p_53 == p_52.f0) ^ l_258) - (int16_t)((int16_t)((uint16_t)(g_3 <= ((uint16_t)(((g_3 ^ g_128) & g_131.f1) && (((((int16_t)l_291 - (int16_t)(~l_256)) && l_253.f0) | 4294967293U) < p_51)) << (uint16_t)7)) << (uint16_t)14) % (int16_t)1)) == 0x0B0B6E22) % (int16_t)p_51))
            { /* block id: 125 */
                uint32_t l_323 = 0U;
                struct S0 l_350 = {80,-1};
                l_253 = g_131;
                if (l_253.f0)
                { /* block id: 127 */
                    int32_t l_293 = (-8);
                    l_293 = (0xF972EF30 & p_52.f0);
                }
                else
                { /* block id: 129 */
                    int16_t l_302 = 0;
                    if (((int16_t)((int16_t)(l_256 == ((((uint16_t)g_131.f1 % (uint16_t)(-10)) > func_71(p_52)) || g_152)) - (int16_t)((int32_t)p_50 - (int32_t)((func_98(((g_152 ^ p_51) ^ (-1)), p_52, g_131.f1, l_277) == l_291) | 0xCD262044))) + (int16_t)l_302))
                    { /* block id: 130 */
                        g_131.f1 = 0x6647A815;
                        if (p_53)
                            break;
                        l_253.f1 = (p_52.f0 != (((int16_t)1 >> (int16_t)4) & ((p_53 > ((int32_t)((p_52.f0 == ((uint16_t)(((((int16_t)((((uint16_t)l_277 >> (uint16_t)10) & ((uint16_t)((uint16_t)func_106(l_253, ((int16_t)l_319 << (int16_t)g_131.f1), p_52.f0) << (uint16_t)g_131.f0) >> (uint16_t)2)) & (-1)) << (int16_t)2) || p_52.f0) >= g_3) & 0) - (uint16_t)l_258)) >= p_52.f0) + (int32_t)5U)) | 0xA498)));
                        p_52 = p_52;
                    }
                    else
                    { /* block id: 135 */
                        g_131.f1 = (((~(5U | g_129)) <= g_3) && l_302);
                        return p_52.f0;
                    }
                    if (p_50)
                    { /* block id: 139 */
                        uint32_t l_343 = 4294967288U;
                        p_50 = ((uint32_t)0xC4A7E46A - (uint32_t)(l_323 > ((((uint16_t)l_256 >> (uint16_t)6) | ((int16_t)(-(uint32_t)p_50) + (int16_t)(((uint16_t)((uint32_t)((int16_t)g_128 - (int16_t)((int16_t)(((int16_t)((uint16_t)func_98(p_51, g_131, ((int16_t)p_51 >> (int16_t)9), ((0x07350B06 >= p_51) & l_302)) + (uint16_t)0x22BA) + (int16_t)l_343) != l_302) << (int16_t)9)) - (uint32_t)l_256) - (uint16_t)l_263) && 1U))) < 0x14A86286)));
                    }
                    else
                    { /* block id: 141 */
                        p_50 = 0xFDDDD462;
                        p_50 = ((p_50 <= g_129) >= (-4));
                        l_351 = func_110(__builtin_clzll((6 && ((0xCC34450B == ((p_52.f1 == (((uint16_t)((p_52.f0 != ((int16_t)((int16_t)p_53 % (int16_t)func_98(func_71(p_52), l_350, p_52.f0, p_52.f1)) >> (int16_t)14)) >= g_152) << (uint16_t)2) >= l_277)) != p_52.f0)) < 0xCC11))), p_51, g_128);
                        if (p_53)
                            break;
                    }
                }
                g_131.f1 = ((l_253.f0 | ((((-1) && (g_128 <= p_53)) && (((int32_t)0x41EEDB1D + (int32_t)((int16_t)(g_118 != ((((uint16_t)(g_203 >= ((int32_t)(p_50 ^ p_53) % (int32_t)0x961F1A68)) + (uint16_t)g_128) | p_52.f1) >= l_350.f1)) << (int16_t)p_53)) || g_85)) <= g_3)) <= g_118);
                p_52 = func_110(g_3, l_277, (7 & (((int16_t)((int16_t)((uint16_t)((uint16_t)g_3 - (uint16_t)((int16_t)(g_3 ^ g_203) + (int16_t)(func_71(p_52) & (l_253.f1 && l_257)))) >> (uint16_t)g_203) + (int16_t)0x88DA) >> (int16_t)g_118) <= 0xAD8C169C)));
            }
            else
            { /* block id: 150 */
                p_50 = ((uint16_t)0xC893 << (uint16_t)1);
                p_52.f1 = 5;
            }
            return l_291;
        }
    }
    return g_152;
}


/* ------------------------------------------ */
/* 
 * reads : g_131.f0 g_152 g_128 g_85 g_131.f1 g_203 g_118 g_129 g_3 g_131
 * writes: g_203 g_118 g_128 g_129 g_131.f1 g_152 g_85 g_131
 */
static uint32_t  func_56(int16_t  p_57, uint32_t  p_58, int32_t  p_59, int32_t  p_60)
{ /* block id: 111 */
    uint16_t l_233 = 0x7FE2;
    int32_t l_234 = 0xBFE8D434;
    int32_t l_245 = 0x7848F6BB;
    struct S0 l_247 = {18,-8};
    g_131 = func_91(g_131.f0, g_152, l_233, g_152, (p_58 > ((l_234 >= (((uint32_t)((int16_t)(0x8041 >= ((((int16_t)0x6254 << (int16_t)9) != (g_131.f0 | 4294967295U)) ^ 0U)) + (int16_t)p_60) % (uint32_t)g_128) == g_85)) ^ 1)));
    g_131 = func_91(((((uint32_t)(g_203 || ((uint16_t)p_60 << (uint16_t)9)) - (uint32_t)l_245) > (-(uint16_t)(__builtin_bswap64((func_71(l_247) && l_247.f0)) & (l_247.f0 > (p_60 || l_245))))) <= l_245), g_131.f0, p_59, g_118, l_247.f0);
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_85 g_131 g_128 g_152 g_129 g_118 g_203
 * writes: g_85 g_118 g_128 g_129 g_131.f1 g_203 g_152
 */
static uint32_t  func_69(uint32_t  p_70)
{ /* block id: 45 */
    uint32_t l_103 = 4294967295U;
    struct S0 l_114 = {29,-11};
    l_114 = func_91((~(g_3 == func_98(((l_103 | ((int16_t)0xDC67 << (int16_t)8)) & func_106(func_110(g_3, (g_3 > func_71(l_114)), ((int16_t)l_114.f0 << (int16_t)14)), p_70, l_114.f0)), l_114, l_114.f0, l_114.f0))), l_114.f0, g_131.f0, g_152, l_114.f1);
    return l_114.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes: g_85
 */
static uint16_t  func_71(struct S0  p_72)
{ /* block id: 41 */
    int16_t l_84 = (-1);
    p_72.f1 = p_72.f0;
    g_85 = (p_72.f1 || ((~((uint16_t)((uint32_t)p_72.f1 - (uint32_t)g_3) >> (uint16_t)(1 || (~4U)))) != (((uint32_t)0xE6A83B1D + (uint32_t)(((((int16_t)p_72.f1 >> (int16_t)3) != (l_84 > 6U)) && g_3) | p_72.f0)) > p_72.f1)));
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_85 g_131.f1 g_203 g_152 g_118 g_129 g_3 g_131 g_128
 * writes: g_203 g_118 g_128 g_129 g_131.f1 g_152 g_85
 */
static struct S0  func_91(int32_t  p_92, int32_t  p_93, int32_t  p_94, uint16_t  p_95, int32_t  p_96)
{ /* block id: 81 */
    uint32_t l_212 = 0xF227D72C;
    struct S0 l_213 = {129,-15};
    uint16_t l_219 = 0x6FCD;
    struct S0 l_227 = {148,5};
    if (((p_93 > ((uint16_t)(((int16_t)((-1) < g_85) << (int16_t)2) >= 1U) << (uint16_t)((((int16_t)g_131.f1 >> (int16_t)14) <= ((int16_t)p_94 >> (int16_t)12)) != l_212))) | func_98(p_94, l_213, g_203, p_95)))
    { /* block id: 82 */
        uint32_t l_214 = 0x10FF70A8;
        struct S0 l_215 = {136,10};
        l_213 = func_110((l_213.f0 || p_96), g_203, l_212);
        l_213.f1 = (0x2BE3B962 <= g_85);
        g_131.f1 = ((-1) > 65533U);
        l_215 = func_110(l_214, p_96, l_212);
    }
    else
    { /* block id: 87 */
        uint32_t l_220 = 0x4356CBF8;
        for (p_94 = (-23); (p_94 < (-12)); p_94 += 1)
        { /* block id: 90 */
            int32_t l_218 = 0;
            struct S0 l_221 = {153,-4};
            p_92 = (g_152 && (l_218 < g_131.f0));
            l_221 = func_110(l_219, l_220, p_92);
            l_213 = l_221;
            l_213 = func_110(l_213.f0, g_203, p_94);
        }
    }
    for (g_203 = 0; (g_203 >= (-29)); g_203 -= 4)
    { /* block id: 99 */
        for (g_152 = 11; (g_152 < 38); g_152 += 1)
        { /* block id: 102 */
            struct S0 l_226 = {54,-2};
            l_226 = g_131;
            p_94 = g_128;
            p_92 = (func_106(l_227, l_226.f0, g_152) | ((int16_t)(((0x9A2E6310 == g_152) && g_203) >= (!l_227.f0)) >> (int16_t)((((uint16_t)l_227.f0 + (uint16_t)p_92) <= g_131.f0) != p_94)));
        }
    }
    return l_213;
}


/* ------------------------------------------ */
/* 
 * reads : g_152 g_118 g_129 g_3
 * writes: g_203
 */
static int32_t  func_98(uint16_t  p_99, struct S0  p_100, int32_t  p_101, int16_t  p_102)
{ /* block id: 67 */
    int16_t l_189 = 0x9FAF;
    if ((g_152 && 1U))
    { /* block id: 68 */
        int32_t l_185 = 0xE9718D2E;
        p_100.f1 = l_185;
        return p_102;
    }
    else
    { /* block id: 71 */
        int32_t l_198 = (-1);
        int32_t l_200 = 0xBB261D96;
        l_200 = (!((uint32_t)(g_118 > (7U || ((l_189 & p_102) <= 0xD721))) - (uint32_t)(((int16_t)((int16_t)0 >> (int16_t)(((uint16_t)((uint16_t)l_198 >> (uint16_t)p_101) >> (uint16_t)(-(uint16_t)g_129)) <= 0x7C9332BA)) % (int16_t)l_198) > 8)));
        for (l_189 = 0; (l_189 != (-7)); l_189 -= 7)
        { /* block id: 75 */
            return p_99;
        }
    }
    g_203 = p_101;
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_131 g_3 g_128 g_152 g_85 g_129
 * writes: g_118 g_128 g_129 g_85 g_131.f1
 */
static uint32_t  func_106(struct S0  p_107, int32_t  p_108, int16_t  p_109)
{ /* block id: 52 */
    struct S0 l_132 = {85,-12};
    int32_t l_135 = (-10);
    int32_t l_142 = 0x8E54FB19;
    int32_t l_145 = 1;
    int32_t l_178 = 0x2B1B449E;
    int16_t l_182 = (-8);
    int32_t l_183 = 0xD48EE826;
    uint32_t l_184 = 1U;
    l_132 = g_131;
    p_107 = g_131;
    if ((0x566EC8B7 >= (((uint16_t)l_135 - (uint16_t)((int32_t)__builtin_ctzl(((((uint16_t)7U << (uint16_t)l_132.f1) ^ ((((((uint16_t)l_132.f1 + (uint16_t)0x562E) ^ l_142) | ((int16_t)(l_145 >= g_3) >> (int16_t)8)) && l_145) | l_142)) != 0x6223)) % (int32_t)l_145)) & g_128)))
    { /* block id: 55 */
        p_107.f1 = ((uint16_t)0xFD0B >> (uint16_t)8);
        p_107.f1 = 0;
    }
    else
    { /* block id: 58 */
        uint32_t l_159 = 0xC80A0586;
        uint32_t l_160 = 4294967287U;
        int32_t l_161 = 0x57DFA0F4;
        if ((g_131.f0 < ((int16_t)(0x1D701D6B != (((((uint16_t)g_152 << (uint16_t)1) >= ((__builtin_bswap64(l_145) || __builtin_ctzl(func_71(func_110((l_132.f0 <= (((int16_t)func_71(func_110((((uint32_t)p_107.f1 - (uint32_t)__builtin_popcount((l_159 >= (((0xAE5FB077 >= 0U) || g_131.f1) > l_159)))) <= g_128), p_107.f1, l_160)) % (int16_t)g_3) < p_107.f0)), p_109, p_107.f0)))) & 2U)) >= l_159) >= p_107.f0)) << (int16_t)6)))
        { /* block id: 59 */
            g_131.f1 = l_135;
        }
        else
        { /* block id: 61 */
            l_161 = 7;
        }
    }
    g_131.f1 = (0xB929 < (~((((uint32_t)((((int32_t)0xC710B0AC - (int32_t)(((int32_t)(~((uint16_t)(((((uint16_t)(g_131.f1 != g_85) >> (uint16_t)13) & g_128) < ((int16_t)(((((int32_t)l_178 + (int32_t)p_108) >= (__builtin_ctzl((((((-(int32_t)(((int16_t)((g_129 < __builtin_ffs((__builtin_ctz(l_135) & p_107.f0))) & p_107.f0) >> (int16_t)p_109) | p_107.f1)) & p_107.f0) | 0xF6DF) & g_3) == l_182)) <= g_152)) & l_182) < 4294967294U) - (int16_t)g_129)) >= p_107.f0) % (uint16_t)p_109)) + (int32_t)0x5411A662) >= g_129)) <= 0U) ^ l_132.f0) % (uint32_t)l_183) >= p_107.f0) == (-1))));
    return l_184;
}


/* ------------------------------------------ */
/* 
 * reads : g_85 g_3 g_131
 * writes: g_118 g_128 g_129
 */
static struct S0  func_110(int32_t  p_111, uint32_t  p_112, int16_t  p_113)
{ /* block id: 46 */
    int32_t l_117 = (-3);
    struct S0 l_130 = {89,-13};
    g_118 = l_117;
    g_128 = ((p_112 < ((int16_t)(g_85 == (((-(uint16_t)((int32_t)((p_113 && (l_117 == (((uint32_t)l_117 % (uint32_t)0xEFF8EE85) >= (((uint16_t)(p_111 <= 1U) >> (uint16_t)12) || p_111)))) == g_85) - (int32_t)0xC803B8C7)) && g_3) ^ 65526U)) >> (int16_t)p_113)) <= 0x4927B923);
    g_129 = p_112;
    l_130 = l_130;
    return g_131;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_85, "g_85", print_hash_value);
    transparent_crc(g_118, "g_118", print_hash_value);
    transparent_crc(g_128, "g_128", print_hash_value);
    transparent_crc(g_129, "g_129", print_hash_value);
    transparent_crc(g_131.f0, "g_131.f0", print_hash_value);
    transparent_crc(g_131.f1, "g_131.f1", print_hash_value);
    transparent_crc(g_152, "g_152", print_hash_value);
    transparent_crc(g_203, "g_203", print_hash_value);
    transparent_crc(g_379, "g_379", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 65
   depth: 1, occurrence: 17
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 17
XXX full-bitfields structs in the program: 17
breakdown:
   indirect level: 0, occurrence: 17
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 23
XXX times a bitfields struct on RHS: 31
XXX times a single bitfield on LHS: 18
XXX times a single bitfield on RHS: 90

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 4
   depth: 13, occurrence: 3
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 6
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 25, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 401
XXX times a non-volatile is write: 65
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 20
   depth: 2, occurrence: 21
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

