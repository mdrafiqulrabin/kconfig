/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1880307453
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const uint16_t  f0;
   int16_t  f1;
   int32_t  f2;
   const int32_t  f3;
   int32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_26(void);
inline static uint16_t  func_31(uint16_t  p_32, uint16_t  p_33, uint32_t  p_34, int32_t  p_35);
inline static const int16_t  func_40(uint16_t  p_41, uint32_t  p_42, uint32_t  p_43, uint16_t  p_44);
static int32_t * func_46(const int32_t  p_47);
static float  func_60(int32_t  p_61, float * p_62);
static int16_t  func_63(union U0  p_64, union U0  p_65, uint16_t  p_66);
inline static union U0  func_67(int16_t  p_68, int32_t * p_69, int32_t * p_70);
static int32_t  func_74(uint32_t  p_75, uint32_t  p_76);
static int32_t * func_83(int32_t  p_84, int32_t * p_85, union U0  p_86, uint32_t  p_87, int32_t ** const  p_88);
inline static union U0  func_90(int32_t  p_91, union U0  p_92, int32_t * p_93, int32_t  p_94);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_26(void)
{ /* block id: 36 */
    uint32_t l_45 = 0x96A0B597;
    int32_t *l_841 = (void*)0;
    int32_t l_842 = 0xC0F813A7;
    int32_t *l_843 = &l_842;
    uint16_t l_844 = 65535U;
    l_842 = (((int16_t)((uint16_t)func_31(((int16_t)(-5) << (int16_t)(((uint16_t)1U << (uint16_t)(func_40(l_45, l_45, l_45, l_45) >= l_45)) == (0x432F >= l_45))), l_45, l_45, l_45) >> (uint16_t)5) >> (int16_t)2) > l_45);
    (*l_843) = l_842;
    return l_844;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_31(uint16_t  p_32, uint16_t  p_33, uint32_t  p_34, int32_t  p_35)
{ /* block id: 559 */
    int32_t l_836 = 0x6099BA1B;
    int32_t *l_835 = &l_836;
    int32_t **l_834 = &l_835;
    float *l_838 = (void*)0;
    float **l_837 = &l_838;
    float **** const l_839 = (void*)0;
    int32_t *l_840 = &l_836;
    (*l_834) = func_46(p_33);
    /* statement id: 560 */
    assert (l_835 == 0);
    (*l_840) = (((l_837 == (void*)0) > __builtin_clzl(p_34)) <= (l_839 == (void*)0));
    (*l_834) = func_46(((void*)0 == &l_839));
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_40(uint16_t  p_41, uint32_t  p_42, uint32_t  p_43, uint16_t  p_44)
{ /* block id: 37 */
    int32_t l_54 = 0x005D9C72;
    int32_t *l_53 = &l_54;
    int32_t **l_52 = &l_53;
    int32_t l_673 = 1;
    union U0 ****l_681 = (void*)0;
    float l_700 = (-0x1.Bp+1);
    float *l_699 = &l_700;
    float **l_698 = &l_699;
    float ***l_697 = &l_698;
    float ****l_696 = &l_697;
    float *****l_695 = &l_696;
    uint32_t l_713 = 0x716E1B50;
    const int32_t l_729 = 0xD0DEDBBB;
    union U0 l_742 = {65528U};
    union U0 *****l_793 = &l_681;
lbl_728:
    (*l_52) = func_46(p_42);
    /* statement id: 41 */
    assert (l_53 == 0);
    if (((void*)0 != (*l_52)))
    { /* block id: 42 */
        uint32_t l_666 = 0U;
        int32_t *l_674 = &l_54;
        for (p_41 = 0; (p_41 <= 56); ++p_41)
        { /* block id: 45 */
            int16_t l_57 = 7;
            int32_t *l_71 = &l_54;
            union U0 l_356 = {65528U};
            float l_668 = 0x3.9A5998p-26;
            float *l_667 = &l_668;
            (*l_667) = (0x3.4184EBp+8 != ((l_57 != ((float)func_60((func_63(func_67(l_57, l_71, func_46(((uint16_t)(*l_71) + (uint16_t)7))), l_356, p_42) != 0xDB9D), l_71) + (float)p_42)) < l_666));
            return l_666;
        }
        (*l_674) = ((uint16_t)((uint32_t)0x11D6F992 - (uint32_t)((l_673 | p_44) != __builtin_parity((p_41 < l_666)))) + (uint16_t)p_44);
    }
    else
    { /* block id: 455 */
        int32_t *l_682 = &l_54;
        union U0 l_683 = {0xDE84};
        float l_685 = 0xE.50FEE3p-3;
        float *l_684 = &l_685;
        float *****l_694 = (void*)0;
        int32_t * const ***l_721 = (void*)0;
        int16_t l_749 = 0xC357;
        const int32_t l_824 = 1;
        const union U0 *l_829 = (void*)0;
        const union U0 **l_828 = &l_829;
        const union U0 ***l_827 = &l_828;
lbl_778:
        (*l_682) = ((int32_t)((int16_t)p_43 + (int16_t)p_44) % (int32_t)((int32_t)((((void*)0 == l_681) | (-4)) >= func_63(func_67((1U < p_43), l_682, l_682), l_683, l_683.f0)) + (int32_t)p_44));
        (*l_684) = func_63(l_683, l_683, (*l_682));
        for (p_43 = 24; (p_43 != 31); p_43++)
        { /* block id: 460 */
            int32_t l_688 = (-1);
            union U0 * const l_689 = &l_683;
            const int32_t l_701 = (-1);
            union U0 *l_702 = (void*)0;
            float *** const *l_718 = &l_697;
            float *** const **l_717 = &l_718;
            int32_t ***l_720 = &l_52;
            int32_t ****l_719 = &l_720;
            float *l_730 = (void*)0;
            uint32_t l_745 = 4294967288U;
            int32_t l_750 = 4;
            union U0 l_758 = {65535U};
            int32_t l_786 = 0xCE7ECFCD;
            int32_t l_808 = 0x034D1B38;
            if ((l_688 >= 0x51BB5A0D))
            { /* block id: 461 */
                const int16_t l_693 = 0xFC65;
                if (((l_688 || l_688) >= (l_689 == &l_683)))
                { /* block id: 462 */
                    const float l_692 = 0x2.B2507Ap-8;
                    for (p_42 = 0; (p_42 < 7); p_42 += 1)
                    { /* block id: 465 */
                        (*l_682) = p_42;
                        return l_693;
                    }
                }
                else
                { /* block id: 469 */
                    l_695 = l_694;
                    /* statement id: 470 */
                    assert (l_695 == 0);
                }
                /* facts after branching */
                assert (l_695 == 0 || l_695 == &l_696);
                return l_701;
            }
            else
            { /* block id: 473 */
                l_702 = l_689;
                /* statement id: 474 */
                assert (l_702 == &l_683);
            }
            /* facts after branching */
            assert (l_702 == &l_683);
            if ((1U && (&l_689 == (void*)0)))
            { /* block id: 476 */
                union U0 **l_705 = &l_702;
                union U0 ***l_704 = &l_705;
                union U0 ****l_703 = &l_704;
                union U0 * const ****l_706 = (void*)0;
                union U0 *****l_707 = &l_703;
                int32_t l_710 = 0x78F99922;
                uint32_t l_712 = 0x8275D7CE;
                float *****l_716 = (void*)0;
                (*l_707) = l_703;
                if ((((int32_t)p_43 + (int32_t)l_710) && ((((4294967295U >= (l_701 && (l_688 && 1U))) >= ((l_710 & p_41) > (!__builtin_clz(func_74(l_710, l_712))))) ^ l_712) & p_41)))
                { /* block id: 478 */
                    (*l_684) = 0xA.65C92Ep+45;
                }
                else
                { /* block id: 480 */
                    uint16_t l_723 = 65535U;
                    (*l_682) = l_713;
                    (*****l_717) = ((float)(l_716 != l_717) - (float)(p_43 > (l_719 == l_721)));
                    if (((void*)0 == l_721))
                    { /* block id: 483 */
                        union U0 l_722 = {0x2BCB};
                        (**l_698) = (func_63(l_722, (*l_702), l_723) != (((((((((float)p_44 - (float)0x0.398FE9p+71) != ((float)0x7.A04783p-98 + (float)p_43)) != l_723) < (-0x1.7p-1)) >= l_722.f0) > p_44) <= 0x1.2F0660p-28) < (-0x4.7p-1)));
                        if (l_683.f0)
                            goto lbl_728;
                        //assert (l_53 == dangling || l_53 == 0);
                        return l_729;
                    }
                    else
                    { /* block id: 487 */
                        l_710 = l_701;
                        if (p_44)
                            continue;
                    }
                    (***l_719) = (**l_720);
                }
                (***l_719) = (***l_719);
            }
            else
            { /* block id: 494 */
                float *l_731 = &l_700;
                int32_t l_734 = 0;
                if ((0x9E358A47 & ((0x445139D3 || ((l_730 == l_731) || (((int16_t)(-1) >> (int16_t)0) | (p_43 != p_41)))) ^ (l_734 != (__builtin_ffs(((-(int16_t)((p_43 < 0x76FFACA1) >= 2U)) | 0xF6295F00)) <= p_44)))))
                { /* block id: 495 */
                    uint32_t l_739 = 6U;
                    for (l_688 = (-28); (l_688 < (-9)); l_688++)
                    { /* block id: 498 */
                        union U0 *****l_738 = &l_681;
                        (*l_738) = l_681;
                        if (l_683.f0)
                            goto lbl_728;
                        //assert (l_53 == dangling || l_53 == 0);
                    }
                    (*l_52) = func_83(__builtin_parityl(l_739), (**l_720), l_683, l_739, (*l_720));
                }
                else
                { /* block id: 503 */
                    (*l_682) = func_74(p_42, (1U >= ((uint16_t)(4294967291U ^ p_41) << (uint16_t)0)));
                }
            }
            if (((func_63(l_742, l_742, p_43) & ((uint32_t)(p_44 && l_745) - (uint32_t)(((int16_t)__builtin_bswap32(((void*)0 == (*l_698))) >> (int16_t)p_41) > 0xF5466685))) & p_44))
            { /* block id: 507 */
                uint16_t l_748 = 65532U;
                (*l_682) = (1 != l_748);
                (****l_696) = (l_749 > (*l_682));
                if (l_748)
                    continue;
                l_750 = l_748;
            }
            else
            { /* block id: 512 */
                float l_754 = (-0x4.Ap+1);
                union U0 l_757 = {0x05B5};
                if ((+(((uint16_t)p_41 + (uint16_t)(p_43 < __builtin_parityl((((uint32_t)func_63(l_757, (*l_702), (((0xE6B15642 < l_757.f0) <= p_43) < p_42)) % (uint32_t)(*l_682)) | p_42)))) & 0U)))
                { /* block id: 513 */
                    uint16_t l_775 = 65529U;
                    if (p_44)
                    { /* block id: 514 */
                        (*l_682) = p_41;
                        (*l_52) = (void*)0;
                        /* statement id: 516 */
                        assert (l_53 == 0);
                    }
                    else
                    { /* block id: 517 */
                        const int16_t l_767 = 0x1843;
                        int32_t **l_772 = &l_53;
                        (**l_720) = func_83(p_42, l_684, l_758, ((uint16_t)((((int32_t)((uint16_t)((int32_t)((l_767 || (__builtin_clzll((((int16_t)((int16_t)(*l_682) >> (int16_t)((void*)0 == l_772)) >> (int16_t)((int32_t)((*l_682) & p_43) % (int32_t)1U)) <= p_44)) < p_43)) & p_43) - (int32_t)0xAC4D2896) << (uint16_t)l_757.f1) % (int32_t)l_775) >= p_44) < p_44) >> (uint16_t)3), (*l_720));
                        /* statement id: 518 */
                        assert (l_53 == &l_685);
                        (**l_772) = ((uint16_t)__builtin_parityll(l_775) << (uint16_t)12);
                    }
                    if (l_701)
                        goto lbl_778;
                }
                else
                { /* block id: 522 */
                    uint16_t l_781 = 0x204C;
                    for (l_683.f1 = (-30); (l_683.f1 == (-29)); ++l_683.f1)
                    { /* block id: 525 */
                        l_781 = 0x47316B0A;
                    }
                    /* facts after for loop */
                                    }
            }
            for (p_41 = 0; (p_41 < 2); ++p_41)
            { /* block id: 532 */
                int32_t l_785 = 0xD870287A;
                float ***l_787 = (void*)0;
                int32_t ** const l_810 = (void*)0;
                union U0 l_819 = {0U};
                (**l_698) = (!0x3.6217F9p+89);
                l_750 = l_785;
                (*l_682) = (((l_786 <= 0x52B24F0E) & l_785) == ((l_787 == (**l_695)) & 0U));
                for (l_688 = (-14); (l_688 == (-8)); ++l_688)
                { /* block id: 538 */
                    union U0 **** const *l_792 = &l_681;
                    const uint32_t l_796 = 0xD224A540;
                    union U0 l_809 = {1U};
                    (*l_682) = ((int16_t)p_43 - (int16_t)(l_792 == l_793));
                    for (l_683.f4 = 0; (l_683.f4 != 28); l_683.f4 += 4)
                    { /* block id: 542 */
                        if (l_796)
                            break;
                    }
                    /* facts after for loop */
                                        if (l_796)
                    { /* block id: 545 */
                        (*l_52) = func_83(((p_44 == p_41) ^ (((void*)0 != &l_702) & l_796)), func_46((p_41 || (((uint16_t)func_63(func_67(((int32_t)(-(int32_t)((((uint32_t)p_42 - (uint32_t)(p_43 <= ((uint16_t)((uint16_t)(*l_682) << (uint16_t)5) >> (uint16_t)l_742.f1))) || p_42) ^ p_42)) + (int32_t)p_44), l_682, (***l_719)), l_683, p_42) << (uint16_t)l_808) <= p_41))), l_809, p_41, l_810);
                        /* statement id: 546 */
                        assert (l_53 == 0);
                        if (p_41)
                            continue;
                    }
                    else
                    { /* block id: 548 */
                        uint16_t l_815 = 0x9F5E;
                        int32_t *l_818 = &l_750;
                        (*l_682) = (l_809.f0 == (((((int32_t)((uint32_t)__builtin_popcountl(l_815) % (uint32_t)((uint32_t)p_41 - (uint32_t)0x83885166)) + (int32_t)(0xB2B1F175 == p_43)) && func_63(func_67(p_42, l_818, l_682), l_819, (*l_682))) != 1U) && (*l_818)));
                        (*l_818) = p_42;
                    }
                    return p_42;
                }
            }
        }
        (*l_682) = __builtin_ctz((((uint16_t)p_41 % (uint16_t)((int16_t)(1U <= l_824) % (int16_t)((uint16_t)(((void*)0 != l_827) || (((int32_t)(__builtin_bswap64(p_44) == ((p_43 != ((uint16_t)__builtin_ctzl(p_42) >> (uint16_t)3)) > p_41)) + (int32_t)(*l_682)) & (*l_682))) >> (uint16_t)p_41))) & p_44));
    }
    /* facts after branching */
    //assert (l_53 == dangling || l_53 == 0);
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_46(const int32_t  p_47)
{ /* block id: 38 */
    int16_t l_48 = 0;
    float l_50 = 0x1.Ep-1;
    float *l_49 = &l_50;
    int32_t *l_51 = (void*)0;
    (*l_49) = l_48;
    return l_51;
    /* statement id: 40 */
    //assert (func_46_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_60(int32_t  p_61, float * p_62)
{ /* block id: 312 */
    uint32_t l_523 = 4294967294U;
    int32_t l_529 = (-1);
    const int16_t l_549 = 1;
    int16_t l_555 = (-6);
    float l_557 = (-0x7.5p+1);
    float *l_556 = &l_557;
    int32_t l_563 = 0x17723F62;
    int32_t *l_562 = &l_563;
    int32_t **l_561 = &l_562;
    int32_t ***l_560 = &l_561;
    uint32_t l_585 = 4294967295U;
    union U0 **l_587 = (void*)0;
    uint16_t l_605 = 1U;
    int32_t *** const *l_659 = &l_560;
    int32_t *** const **l_658 = &l_659;
    for (p_61 = 29; (p_61 != 7); p_61 -= 2)
    { /* block id: 315 */
        int32_t l_522 = 0x4852E81B;
        int32_t *l_521 = &l_522;
        union U0 l_548 = {0xFFEC};
        const union U0 *l_547 = &l_548;
        const union U0 **l_546 = &l_547;
        int32_t l_575 = 1;
        int32_t ****l_627 = &l_560;
        int32_t *****l_626 = &l_627;
        float ****l_631 = (void*)0;
        (*l_521) = (!0x1C0AF538);
        if (((((0x1D83 ^ l_523) >= 0xA590) < p_61) > ((-(uint16_t)((int16_t)(0 > p_61) >> (int16_t)5)) == (((p_61 ^ (*l_521)) <= (((uint16_t)((*l_521) != 0) << (uint16_t)13) || 0x3704)) ^ (-4)))))
        { /* block id: 317 */
            (*l_521) = ((p_61 < l_529) < ((int16_t)((int32_t)p_61 + (int32_t)(*l_521)) - (int16_t)l_529));
        }
        else
        { /* block id: 319 */
            uint32_t l_538 = 8U;
            int32_t *l_539 = (void*)0;
            int32_t l_545 = 0xE16218FC;
            if ((p_61 == l_529))
            { /* block id: 320 */
                const int32_t *l_541 = (void*)0;
                int32_t **l_542 = (void*)0;
                int32_t **l_543 = &l_521;
                for (l_529 = 0; (l_529 >= (-23)); l_529 -= 4)
                { /* block id: 323 */
                    (*l_521) = 1;
                }
                if (((int16_t)p_61 >> (int16_t)0))
                { /* block id: 326 */
                    return l_538;
                }
                else
                { /* block id: 328 */
                    int32_t **l_540 = &l_539;
                    (*l_540) = l_539;
                    if (p_61)
                        break;
                    if (p_61)
                        break;
                }
                (*l_543) = l_541;
                /* statement id: 333 */
                assert (l_521 == 0);
                if (l_522)
                { /* block id: 334 */
                    l_539 = &l_522;
                    /* statement id: 335 */
                    assert (l_539 == &l_522);
                }
                else
                { /* block id: 336 */
                    int32_t * const l_544 = &l_522;
                    (*l_543) = func_46((l_539 != l_544));
                }
                /* facts after branching */
                assert (l_539 == 0 || l_539 == &l_522);
            }
            else
            { /* block id: 339 */
                l_545 = 0x16C76ABF;
                (*l_521) = ((void*)0 != l_546);
            }
            /* facts after branching */
            assert (l_521 == &l_522 || l_521 == 0);
            assert (l_539 == 0 || l_539 == &l_522);
        }
        /* facts after branching */
        assert (l_521 == &l_522 || l_521 == 0);
    }
    (*p_62) = (**l_561);
    (*p_62) = ((((float)(*p_62) + (float)(l_658 != &l_659)) == ((-0x1.Dp-1) == (__builtin_ia32_crc32qi(__builtin_ctz(((uint32_t)(((((int32_t)p_61 + (int32_t)((***l_560) == ((int16_t)((****l_659) | p_61) << (int16_t)__builtin_ctzll((*l_562))))) <= p_61) && (****l_659)) > 1) - (uint32_t)0x92E97ACB)), (*l_562)) <= (*****l_658)))) < (*p_62));
    (****l_659) = (***l_560);
    return (*p_62);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_63(union U0  p_64, union U0  p_65, uint16_t  p_66)
{ /* block id: 233 */
    float l_357 = 0x9.683604p-6;
    int32_t l_359 = 0xE48C0DEF;
    int32_t *l_358 = &l_359;
    int32_t **l_379 = &l_358;
    int32_t ** const *l_378 = &l_379;
    uint32_t l_380 = 4294967293U;
    int32_t ** const l_396 = (void*)0;
    union U0 *l_409 = (void*)0;
    float l_429 = 0x1.Cp+1;
    float l_441 = (-0x8.6p+1);
    uint16_t l_500 = 0U;
    union U0 **l_515 = &l_409;
    union U0 *** const l_514 = &l_515;
    union U0 ***l_517 = &l_515;
    union U0 ****l_516 = &l_517;
    (*l_358) = 2;
    for (p_65.f1 = 0; (p_65.f1 >= 22); p_65.f1 += 2)
    { /* block id: 237 */
        int16_t l_369 = (-5);
        int32_t ***l_385 = &l_379;
        int32_t ****l_384 = &l_385;
        int32_t *****l_383 = &l_384;
        union U0 * const ****l_428 = (void*)0;
        int32_t l_498 = 0xA44A33EA;
        float *l_510 = &l_441;
        float **l_509 = &l_510;
        float ***l_508 = &l_509;
        float ****l_511 = &l_508;
    }
    /* facts after for loop */
        (***l_378) = ((uint16_t)__builtin_parityl(((***l_378) > func_74(p_64.f1, p_64.f0))) >> (uint16_t)6);
    (*l_516) = l_514;
    return p_65.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_67(int16_t  p_68, int32_t * p_69, int32_t * p_70)
{ /* block id: 46 */
    float l_78 = 0x2.168459p-10;
    float *l_77 = &l_78;
    int32_t l_332 = 0x2D4F081F;
    const int32_t *l_335 = &l_332;
    const int32_t **l_334 = &l_335;
    union U0 l_343 = {0xD0FD};
    union U0 *l_342 = &l_343;
    union U0 **l_341 = &l_342;
    union U0 ***l_340 = &l_341;
    union U0 ****l_339 = &l_340;
    union U0 *****l_338 = &l_339;
    int32_t *l_346 = &l_332;
    int32_t **l_345 = &l_346;
    int32_t ***l_344 = &l_345;
    int32_t l_351 = (-1);
    float **l_354 = &l_77;
    union U0 l_355 = {65532U};
    (*p_69) = func_74(p_68, (l_77 == p_70));
    (*l_334) = func_46(((+l_332) >= (!l_332)));
    /* statement id: 229 */
    assert (l_335 == 0);
    (*l_346) = ((uint32_t)(((l_338 != &l_339) || ((l_344 != (void*)0) != ((int16_t)((*p_69) && (((-10) || p_68) & p_68)) >> (int16_t)0))) != (((&l_344 != &l_344) >= (**l_345)) != (*l_346))) - (uint32_t)(*l_346));
    (*l_346) = ((uint32_t)func_74(p_68, (**l_345)) + (uint32_t)(__builtin_ia32_crc32qi((**l_345), l_351) | ((int32_t)(l_354 != &l_77) + (int32_t)(((p_68 ^ p_68) && (*p_69)) == p_68))));
    return l_355;
    /* statement id: 232 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_74(uint32_t  p_75, uint32_t  p_76)
{ /* block id: 47 */
    union U0 l_96 = {0xD40F};
    uint32_t l_175 = 6U;
    int32_t *l_194 = (void*)0;
    union U0 *l_214 = (void*)0;
    union U0 **l_213 = &l_214;
    union U0 ***l_212 = &l_213;
    float **l_215 = (void*)0;
    int32_t l_290 = 1;
    int32_t *l_289 = &l_290;
    int32_t **l_330 = &l_194;
    for (p_75 = 0; (p_75 != 24); p_75++)
    { /* block id: 50 */
        int32_t *l_89 = (void*)0;
        union U0 *** const l_177 = (void*)0;
        union U0 *** const *l_176 = &l_177;
        union U0 *l_193 = &l_96;
        union U0 **l_192 = &l_193;
        union U0 ***l_191 = &l_192;
        union U0 **** const l_190 = &l_191;
        union U0 **** const *l_189 = &l_190;
        int32_t **l_246 = &l_194;
        int32_t ***l_245 = &l_246;
        int32_t ****l_244 = &l_245;
        const int32_t l_279 = (-10);
        for (p_76 = (-27); (p_76 != 43); p_76++)
        { /* block id: 53 */
            int32_t l_95 = 0;
            int32_t ** const l_172 = (void*)0;
            l_89 = func_83(p_75, l_89, func_90(l_95, l_96, func_46(p_76), l_96.f0), l_95, l_172);
        }
    }
    (*l_330) = &l_290;
    /* statement id: 226 */
    assert (l_194 == &l_290);
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_83(int32_t  p_84, int32_t * p_85, union U0  p_86, uint32_t  p_87, int32_t ** const  p_88)
{ /* block id: 118 */
    int32_t l_174 = 8;
    int32_t *l_173 = &l_174;
    return p_85;
    /* statement id: 119 */
    //assert (func_83_rv == 0 || func_83_rv == &l_181 || func_83_rv == &l_359 || func_83_rv == &l_451 || func_83_rv == &l_563 || func_83_rv == &l_54 || func_83_rv == &l_685);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_90(int32_t  p_91, union U0  p_92, int32_t * p_93, int32_t  p_94)
{ /* block id: 54 */
    float l_97 = 0x0.4p+1;
    int32_t l_98 = 0xB2CBD72F;
    float l_104 = 0x7.9p-1;
    uint32_t l_120 = 8U;
    int32_t *l_128 = &l_98;
    int32_t **l_127 = &l_128;
    int32_t *** const l_126 = &l_127;
    union U0 l_146 = {0x1B67};
    uint16_t l_147 = 0xB973;
    union U0 **l_156 = (void*)0;
    union U0 ***l_155 = &l_156;
    int32_t l_168 = 0x9C4F6A9E;
    if ((p_92.f0 < ((p_94 > ((l_98 || (~(((uint16_t)((int32_t)(l_98 | ((int16_t)(((((uint16_t)l_98 << (uint16_t)2) ^ ((((l_98 > p_94) > (p_92.f1 <= 0x6DE0)) && 0x380B773B) && 65535U)) > p_91) || l_98) >> (int16_t)11)) + (int32_t)p_92.f1) - (uint16_t)0x7E0E) >= l_98))) <= l_98)) ^ 0U)))
    { /* block id: 55 */
        int32_t l_123 = 0x287D282E;
        union U0 l_137 = {0x16FB};
        union U0 *l_136 = &l_137;
        float l_142 = 0x2.1D9E46p+74;
        if (((&p_91 != (void*)0) > ((void*)0 == &p_91)))
        { /* block id: 56 */
            for (p_94 = 0; (p_94 <= (-10)); p_94 -= 3)
            { /* block id: 59 */
                int16_t l_111 = 8;
                union U0 l_133 = {0xB930};
                float *l_148 = (void*)0;
                float *l_149 = (void*)0;
                float *l_150 = &l_97;
                int32_t ***l_151 = &l_127;
                if (l_111)
                { /* block id: 60 */
                    int16_t l_114 = 0x2D20;
                    union U0 l_135 = {65526U};
                    union U0 *l_134 = &l_135;
                    for (p_92.f1 = (-16); (p_92.f1 == (-16)); ++p_92.f1)
                    { /* block id: 63 */
                        union U0 **l_115 = (void*)0;
                        union U0 l_118 = {65535U};
                        union U0 *l_117 = &l_118;
                        union U0 **l_116 = &l_117;
                        int32_t *l_124 = (void*)0;
                        int32_t *l_125 = &l_118.f4;
                        int32_t ***l_130 = &l_127;
                        int32_t ****l_129 = &l_130;
                        if (l_114)
                            break;
                        (*l_116) = &p_92;
                        /* statement id: 65 */
                        assert (l_117 == &p_92);
                        (*l_125) = ((-(int32_t)l_118.f1) ^ ((0x2727C38D >= ((__builtin_popcountl(((void*)0 != &p_91)) < (l_98 >= __builtin_ia32_crc32qi(__builtin_bswap64(((l_120 >= ((l_114 || ((((int16_t)l_114 << (int16_t)15) | p_92.f0) | 65535U)) | p_94)) && 5U)), p_91))) || p_94)) >= l_123));
                        /* statement id: 66 */
                                                (*l_129) = l_126;
                    }
                    /* facts after for loop */
                                        for (p_92.f2 = 0; (p_92.f2 != 11); p_92.f2++)
                    { /* block id: 71 */
                        return l_133;
                        /* statement id: 72 */
                                            }
                    /* facts after for loop */
                                        (*l_127) = &p_91;
                    /* statement id: 74 */
                    assert (l_128 == &p_91);
                    l_134 = &l_133;
                    /* statement id: 75 */
                    assert (l_134 == &l_133);
                }
                else
                { /* block id: 76 */
                    l_136 = &l_133;
                    /* statement id: 77 */
                    assert (l_136 == &l_133);
                    for (l_123 = 27; (l_123 <= 13); --l_123)
                    { /* block id: 80 */
                        int32_t l_144 = 0xE6A7F8EC;
                        float *l_145 = &l_97;
                        (*l_145) = ((float)((l_142 != (+l_144)) <= 0xD.1B41FDp-50) - (float)(p_92.f1 >= (-0x1.Ep-1)));
                        return l_146;
                        /* statement id: 82 */
                                            }
                }
                /* facts after branching */
                //assert (l_136 == &l_133 || l_136 == dangling || l_136 == &l_137);
                (*l_150) = (l_111 == l_147);
                (***l_151) = ((l_137.f0 ^ (0 ^ (0xA5B4 <= (**l_127)))) != ((void*)0 == l_151));
                (*l_150) = p_92.f1;
            }
            /* facts after for loop */
            assert (l_128 == &l_98 || l_128 == &p_91);
            //assert (l_136 == dangling || l_136 == &l_137);
            (*l_127) = &p_91;
            /* statement id: 89 */
            assert (l_128 == &p_91);
        }
        else
        { /* block id: 90 */
            const int32_t l_152 = 0x9AD14953;
            (**l_126) = func_46(l_152);
            /* statement id: 91 */
            assert (l_128 == 0);
        }
        /* facts after branching */
        assert (l_128 == 0 || l_128 == &p_91);
        //assert (l_136 == dangling || l_136 == &l_137);
    }
    else
    { /* block id: 93 */
        union U0 l_164 = {65533U};
        union U0 ****l_165 = &l_155;
        (*l_127) = &p_91;
        /* statement id: 94 */
        assert (l_128 == &p_91);
        for (p_92.f4 = 14; (p_92.f4 == 15); p_92.f4++)
        { /* block id: 97 */
            union U0 * const l_160 = &l_146;
            union U0 * const *l_159 = &l_160;
            union U0 * const **l_158 = &l_159;
            union U0 * const ***l_157 = &l_158;
            (*l_157) = l_155;
            /* statement id: 98 */
            assert (l_158 == &l_156);
            for (l_120 = (-15); (l_120 >= 12); l_120 += 5)
            { /* block id: 101 */
                float *l_163 = &l_97;
                (*l_163) = (*l_128);
                (*l_163) = p_92.f4;
                return l_164;
                /* statement id: 104 */
                            }
        }
        /* facts after for loop */
                (*l_165) = &l_156;
    }
    /* facts after branching */
    assert (l_128 == 0 || l_128 == &p_91);
    p_92.f4 = ((uint16_t)p_92.f1 << (uint16_t)p_91);
    /* statement id: 109 */
        if ((l_168 != (p_92.f4 < 0x10D5)))
    { /* block id: 110 */
        return p_92;
        /* statement id: 111 */
            }
    else
    { /* block id: 112 */
        int32_t *l_169 = &l_98;
        float *l_170 = (void*)0;
        union U0 *l_171 = &l_146;
        (**l_126) = l_169;
        /* statement id: 113 */
        assert (l_128 == &l_98);
        (*l_128) = (*l_169);
        (***l_126) = (l_171 == &p_92);
    }
    /* facts after branching */
    assert (l_128 == &l_98);
    return p_92;
    /* statement id: 117 */
    }




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 223
XXX total union variables: 18

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 161
   depth: 2, occurrence: 33
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3
   depth: 6, occurrence: 5
   depth: 7, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 5
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 210

XXX times a variable address is taken: 206
XXX times a pointer is dereferenced on RHS: 127
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 17
   depth: 3, occurrence: 15
   depth: 4, occurrence: 11
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 138
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 20
   depth: 3, occurrence: 11
   depth: 4, occurrence: 7
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 31
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 528

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 299
   level: 2, occurrence: 105
   level: 3, occurrence: 62
   level: 4, occurrence: 54
   level: 5, occurrence: 14
XXX number of pointers point to pointers: 126
XXX number of pointers point to scalars: 68
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.2
XXX average alias set size: 1.2

XXX times a non-volatile is read: 1115
XXX times a non-volatile is write: 408
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 151
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 17
   depth: 2, occurrence: 14
   depth: 3, occurrence: 29
   depth: 4, occurrence: 30
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 20.2
XXX percentage an existing variable is used: 79.8
********************* end of statistics **********************/

