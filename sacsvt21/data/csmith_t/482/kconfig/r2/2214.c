/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      3023438944
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = (-1);
static struct S0 g_62[4][6] = {{{0xEB856A75},{0xF121F205},{0xEB856A75},{0xEB856A75},{0xF121F205},{0xEB856A75}},{{0xEB856A75},{0xF121F205},{0xEB856A75},{0xEB856A75},{0xF121F205},{0xEB856A75}},{{0xEB856A75},{0xF121F205},{0xEB856A75},{0xEB856A75},{0xF121F205},{0xEB856A75}},{{0xEB856A75},{0xF121F205},{0xEB856A75},{0xEB856A75},{0xF121F205},{0xEB856A75}}};
static const int32_t *g_67 = (void*)0;
static int32_t g_97[8] = {0,5,0,0,5,0,0,5};
static struct S0 * const g_105 = (void*)0;
static struct S0 * const *g_104 = &g_105;
static struct S0 * const **g_103 = &g_104;
static uint8_t g_264 = 0x74;
static struct S0 *g_332 = &g_62[1][4];
static struct S0 **g_331 = &g_332;
static struct S0 ***g_330 = &g_331;
static struct S0 ****g_329[3][1] = {{&g_330},{&g_330},{&g_330}};
static int32_t **g_471 = (void*)0;
static int32_t ***g_470 = &g_471;
static int32_t ****g_469 = &g_470;
static uint8_t g_754 = 255U;
static int32_t *g_944 = &g_97[3];
static int32_t g_971 = 6;
static const struct S0 *g_999 = &g_62[3][3];
static const struct S0 **g_998 = &g_999;


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
static int16_t  func_8(int32_t  p_9, uint32_t  p_10);
static const uint16_t  func_15(int8_t  p_16, uint8_t  p_17);
static uint16_t  func_22(int32_t  p_23, int16_t  p_24, struct S0  p_25);
static int32_t  func_30(int16_t  p_31, int8_t  p_32, int32_t  p_33);
inline static int8_t  func_34(int16_t  p_35, int32_t  p_36, uint16_t  p_37);
static const int8_t  func_42(uint32_t  p_43, uint16_t  p_44);
inline static int32_t  func_47(int32_t  p_48, int16_t  p_49, uint32_t  p_50, uint32_t  p_51);
static int32_t * func_55(struct S0  p_56, int32_t * p_57, uint8_t  p_58);
inline static int32_t * func_60(struct S0  p_61);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_97
 * writes: g_3
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_2[1];
    int8_t l_54 = 0xB6;
    int32_t l_323[5];
    int32_t *l_1016[4];
    int32_t *l_1017 = &g_97[3];
    int8_t l_1076 = 0x98;
    struct S0 * const ***l_1112 = &g_103;
    int32_t **** const l_1192 = &g_470;
    int i;
    for (i = 0; i < 1; i = i + 1)
        l_2[i] = 255U;
    for (i = 0; i < 5; i = i + 1)
        l_323[i] = 1;
    for (i = 0; i < 4; i = i + 1)
        l_1016[i] = (void*)0;
    for (g_3 = 0; (g_3 <= 0); g_3 += 1)
    { /* block id: 3 */
        struct S0 l_324 = {0x0492FC4D};
        int32_t l_1054 = 0x24E157E1;
        uint16_t l_1074 = 0xF12D;
        struct S0 ***l_1158 = (void*)0;
        int32_t * const *l_1176 = (void*)0;
        int i;
    }
    return (*l_1017);
}


/* ------------------------------------------ */
/* 
 * reads : g_330 g_331 g_332 g_67 g_3 g_264 g_62 g_97 g_103 g_104 g_105 g_754 g_944
 * writes: g_97 g_62 g_264 g_67 g_103 g_971 g_998 g_754
 */
static int16_t  func_8(int32_t  p_9, uint32_t  p_10)
{ /* block id: 273 */
    int16_t l_519 = 0x9099;
    struct S0 *l_562[9];
    int32_t *l_563 = &g_97[5];
    int32_t ****l_630[6][7] = {{&g_470,&g_470,&g_470,&g_470,&g_470,(void*)0,&g_470},{&g_470,&g_470,&g_470,&g_470,(void*)0,&g_470,&g_470},{&g_470,&g_470,(void*)0,&g_470,&g_470,&g_470,&g_470},{&g_470,&g_470,&g_470,&g_470,&g_470,&g_470,&g_470},{&g_470,&g_470,&g_470,(void*)0,&g_470,(void*)0,&g_470},{&g_470,&g_470,(void*)0,&g_470,(void*)0,&g_470,&g_470}};
    uint32_t l_656 = 0x4994364C;
    struct S0 ****l_687[8];
    uint8_t l_952 = 0x80;
    int i, j;
    for (i = 0; i < 9; i = i + 1)
        l_562[i] = &g_62[3][3];
    for (i = 0; i < 8; i = i + 1)
        l_687[i] = &g_330;
    if (l_519)
    { /* block id: 274 */
        struct S0 l_525 = {0U};
        int32_t *l_527 = &g_97[3];
        for (p_9 = 0; (p_9 == (-17)); --p_9)
        { /* block id: 277 */
            int32_t *l_522 = &g_97[3];
            (*l_522) = 0x8BDFED1B;
            for (l_519 = 10; (l_519 == 9); l_519--)
            { /* block id: 281 */
                (***g_330) = l_525;
            }
        }
        (*l_527) = (~0U);
        for (p_10 = (-14); (p_10 <= 26); p_10 = safe_add_func_int32_t_s_s(p_10, 8))
        { /* block id: 288 */
            if ((*g_67))
                break;
        }
    }
    else
    { /* block id: 291 */
        int8_t l_557 = 0x75;
        int32_t l_558 = 0x977ADD14;
        struct S0 l_572 = {4294967292U};
        uint16_t l_593 = 0xBED4;
        struct S0 *****l_597 = &g_329[1][0];
        struct S0 ** const ***l_602[4][1] = {{(void*)0},{(void*)0},{(void*)0},{(void*)0}};
        struct S0 l_603 = {0x9867E898};
        struct S0 l_606 = {0U};
        int32_t ** const l_709 = &l_563;
        int32_t ***l_803 = &g_471;
        int8_t l_831[7][1][2] = {{{1,1}},{{0,1}},{{1,0x4A}},{{0x4A,1}},{{1,0}},{{1,1}},{{0x4A,0x4A}}};
        const uint32_t l_861 = 0xA47669F8;
        int i, j, k;
        for (l_519 = 0; (l_519 < (-15)); l_519--)
        { /* block id: 294 */
            struct S0 l_532 = {2U};
            int32_t *l_533 = &g_97[3];
        }
        l_562[3] = (*g_331);
    }
    for (g_264 = 8; (g_264 != 55); ++g_264)
    { /* block id: 500 */
        struct S0 l_882[7][8][2] = {{{{4294967295U},{0U}},{{0x573BDD2B},{1U}},{{0x5C47C55F},{0x573BDD2B}},{{1U},{0U}},{{1U},{0x573BDD2B}},{{0x5C47C55F},{1U}},{{0x573BDD2B},{0U}},{{4294967295U},{4294967295U}}},{{{0x5C47C55F},{4294967295U}},{{4294967295U},{0U}},{{0x573BDD2B},{1U}},{{0x5C47C55F},{0x573BDD2B}},{{1U},{0U}},{{1U},{0x573BDD2B}},{{0x5C47C55F},{1U}},{{0x573BDD2B},{0U}}},{{{4294967295U},{4294967295U}},{{0x5C47C55F},{4294967295U}},{{4294967295U},{0U}},{{0x573BDD2B},{1U}},{{0x5C47C55F},{0x573BDD2B}},{{1U},{0U}},{{1U},{0x573BDD2B}},{{0x5C47C55F},{1U}}},{{{0x573BDD2B},{0U}},{{4294967295U},{4294967295U}},{{0x5C47C55F},{4294967295U}},{{4294967295U},{0U}},{{0x573BDD2B},{1U}},{{0x5C47C55F},{0x573BDD2B}},{{1U},{0U}},{{1U},{0x573BDD2B}}},{{{0x5C47C55F},{1U}},{{0x573BDD2B},{0U}},{{4294967295U},{4294967295U}},{{0x5C47C55F},{4294967295U}},{{4294967295U},{0U}},{{0x573BDD2B},{1U}},{{0x5C47C55F},{0x573BDD2B}},{{1U},{0U}}},{{{1U},{0x573BDD2B}},{{0x5C47C55F},{1U}},{{0x573BDD2B},{0U}},{{4294967295U},{4294967295U}},{{0x5C47C55F},{4294967295U}},{{4294967295U},{0U}},{{0x573BDD2B},{1U}},{{0x5C47C55F},{0x573BDD2B}}},{{{1U},{0U}},{{1U},{0x573BDD2B}},{{0x5C47C55F},{1U}},{{0x573BDD2B},{0U}},{{4294967295U},{4294967295U}},{{0x5C47C55F},{4294967295U}},{{4294967295U},{0U}},{{0x573BDD2B},{1U}}}};
        int32_t *l_892 = &g_97[5];
        struct S0 ***l_949 = &g_331;
        int32_t *l_978[6][5][5] = {{{&g_97[3],&g_97[3],&g_3,&g_3,&g_97[3]},{&g_3,&g_97[3],&g_97[3],&g_3,&g_3},{&g_3,&g_3,&g_97[3],&g_3,&g_97[3]},{&g_97[2],&g_3,&g_3,&g_3,&g_97[3]},{(void*)0,&g_97[3],&g_97[3],&g_3,&g_97[3]}},{{&g_97[3],&g_97[3],&g_3,&g_3,&g_97[3]},{&g_3,&g_3,&g_3,&g_3,&g_97[0]},{&g_97[3],&g_97[3],&g_97[2],&g_3,&g_97[0]},{&g_3,(void*)0,&g_97[3],&g_3,&g_97[3]},{(void*)0,&g_97[2],&g_3,&g_3,&g_97[6]}},{{&g_3,&g_3,(void*)0,&g_3,&g_97[7]},{&g_3,&g_3,&g_3,&g_3,&g_97[0]},{&g_97[3],&g_97[3],&g_97[2],&g_3,&g_97[0]},{&g_3,(void*)0,&g_97[3],&g_3,&g_97[3]},{(void*)0,&g_97[2],&g_3,&g_3,&g_97[6]}},{{&g_3,&g_3,(void*)0,&g_3,&g_97[7]},{&g_3,&g_3,&g_3,&g_3,&g_97[0]},{&g_97[3],&g_97[3],&g_97[2],&g_3,&g_97[0]},{&g_3,(void*)0,&g_97[3],&g_3,&g_97[3]},{(void*)0,&g_97[2],&g_3,&g_3,&g_97[6]}},{{&g_3,&g_3,(void*)0,&g_3,&g_97[7]},{&g_3,&g_3,&g_3,&g_3,&g_97[0]},{&g_97[3],&g_97[3],&g_97[2],&g_3,&g_97[0]},{&g_3,(void*)0,&g_97[3],&g_3,&g_97[3]},{(void*)0,&g_97[2],&g_3,&g_3,&g_97[6]}},{{&g_3,&g_3,(void*)0,&g_3,&g_97[7]},{&g_3,&g_3,&g_3,&g_3,&g_97[0]},{&g_97[3],&g_97[3],&g_97[2],&g_3,&g_97[0]},{&g_3,(void*)0,&g_97[3],&g_3,&g_97[3]},{(void*)0,&g_97[2],&g_3,&g_3,&g_97[6]}}};
        struct S0 **l_979 = &l_562[3];
        int i, j, k;
        (***g_330) = l_882[4][4][1];
        for (l_519 = 16; (l_519 < 6); l_519 = safe_sub_func_int32_t_s_s(l_519, 1))
        { /* block id: 504 */
            struct S0 *l_890 = &l_882[4][4][1];
            int32_t l_918 = 1;
        }
        l_892 = func_55((***g_330), l_978[2][3][1], (*l_563));
        /* statement id: 569 */
        assert ((l_892 >= &g_97[0] && l_892 <= &g_97[7]) || l_892 == &g_3);
        (*l_979) = (**g_103);
    }
    /* facts after for loop */
    //assert (l_562[0] == 0 || (l_562[0] >= &g_62[0][0] && l_562[0] <= &g_62[3][5]));
    for (l_656 = 2; (l_656 <= 7); l_656 += 1)
    { /* block id: 574 */
        int32_t l_988 = 0x20193C50;
        int32_t *l_994 = &g_97[6];
        struct S0 * const l_1000 = &g_62[3][1];
        int32_t *** const l_1009 = &g_471;
        int i;
        if (((&l_687[l_656] == &g_329[2][0]) || (safe_mod_func_uint32_t_u_u((((safe_mod_func_uint32_t_u_u(p_10, (g_754 & (p_9 <= (((((-1) <= (p_10 < ((safe_add_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u((l_988 | (safe_unary_minus_func_uint16_t_u((safe_add_func_int32_t_s_s((0xE6CFBDBB || 4294967288U), 1U))))), g_97[3])), l_988)) == p_10))) ^ 0xC344) | 0x6ABE614A) <= p_9))))) == g_264) > p_9), 0x835515C1))))
        { /* block id: 575 */
            uint32_t l_992 = 0xED42B45B;
            const struct S0 l_993[2] = {{0xEED04222},{0xEED04222}};
            int i;
            if (l_992)
                break;
            for (g_971 = 0; (g_971 <= 7); g_971 += 1)
            { /* block id: 579 */
                return p_10;
            }
            for (g_971 = 5; (g_971 >= 0); g_971 -= 1)
            { /* block id: 584 */
                int i;
                (*g_332) = l_993[1];
            }
            for (l_992 = 2; (l_992 <= 7); l_992 += 1)
            { /* block id: 589 */
                const struct S0 *l_996 = &l_993[0];
                const struct S0 **l_995 = &l_996;
                const struct S0 ***l_997[6] = {&l_995,&l_995,&l_995,&l_995,&l_995,&l_995};
                struct S0 **l_1001[8][2][9] = {{{&l_562[3],(void*)0,(void*)0,(void*)0,&l_562[1],&g_332,&g_332,&g_332,(void*)0},{&g_332,&l_562[3],&l_562[2],(void*)0,&l_562[2],&l_562[3],&g_332,&l_562[2],&g_332}},{{&g_332,(void*)0,(void*)0,&l_562[3],&g_332,(void*)0,&g_332,(void*)0,&g_332},{&l_562[3],&l_562[2],&l_562[2],&l_562[3],&g_332,&l_562[7],(void*)0,&l_562[2],&l_562[7]}},{{&g_332,&g_332,(void*)0,&l_562[3],&l_562[4],&g_332,&l_562[3],&g_332,&g_332},{(void*)0,&g_332,&g_332,(void*)0,&g_332,&l_562[2],&l_562[3],&g_332,&g_332}},{{&g_332,&g_332,&g_332,(void*)0,&g_332,&g_332,&g_332,&g_332,(void*)0},{&g_332,&l_562[4],&l_562[7],&l_562[7],&l_562[8],&l_562[7],&l_562[3],&l_562[7],&l_562[8]}},{{(void*)0,&l_562[3],&l_562[3],&g_332,&l_562[5],&l_562[3],(void*)0,&l_562[3],&l_562[3]},{&l_562[2],&l_562[8],&l_562[6],&l_562[7],(void*)0,(void*)0,&l_562[7],&l_562[6],&l_562[8]}},{{(void*)0,&l_562[5],(void*)0,(void*)0,&l_562[5],&l_562[3],&l_562[4],&g_332,(void*)0},{&l_562[2],(void*)0,&l_562[8],&g_332,&l_562[8],(void*)0,&l_562[2],&l_562[8],&l_562[6]}},{{(void*)0,&l_562[5],&l_562[3],(void*)0,&l_562[3],&l_562[3],&l_562[4],&l_562[3],&l_562[3]},{&g_332,&l_562[8],&l_562[8],&g_332,&l_562[4],&l_562[7],&l_562[7],&l_562[8],&l_562[7]}},{{&g_332,&l_562[3],(void*)0,(void*)0,&g_332,&g_332,(void*)0,&g_332,&l_562[3]},{&l_562[7],&l_562[4],&l_562[6],&g_332,&l_562[4],&l_562[8],&l_562[3],&l_562[6],&l_562[6]}}};
                struct S0 **l_1002 = &l_562[3];
                int i, j, k;
                l_994 = &p_9;
                /* statement id: 590 */
                assert (l_994 == &p_9);
                g_998 = l_995;
                /* statement id: 591 */
                assert (g_998 == &l_996);
                (*l_1002) = l_1000;
            }
            /* facts after for loop */
            assert (l_994 == &p_9 || (l_994 >= &g_97[0] && l_994 <= &g_97[7]));
        }
        else
        { /* block id: 594 */
            int32_t l_1003 = 0;
            p_9 = (l_1003 < 9);
        }
        /* facts after branching */
        assert (l_994 == &p_9 || (l_994 >= &g_97[0] && l_994 <= &g_97[7]));
        for (g_754 = 0; (g_754 <= 7); g_754 += 1)
        { /* block id: 599 */
            int16_t l_1004[7][5][2] = {{{0,(-1)},{0xEB66,0x5D5C},{4,0xEB66},{0x5D5C,(-1)},{0x5D5C,0xEB66}},{{4,0x5D5C},{0xEB66,(-1)},{0,0},{4,0},{0,(-1)}},{{0xEB66,0x5D5C},{4,0xEB66},{0x5D5C,(-1)},{0x5D5C,0xEB66},{4,0x5D5C}},{{0xEB66,(-1)},{0,0},{4,0},{0,(-1)},{0xEB66,0x5D5C}},{{4,0xEB66},{0x5D5C,(-1)},{0x5D5C,0xEB66},{4,0x5D5C},{0xEB66,(-1)}},{{0,0},{4,0},{0,(-1)},{0xEB66,0x5D5C},{4,0xEB66}},{{0x5D5C,(-1)},{0x5D5C,0xEB66},{4,0x5D5C},{0xEB66,(-1)},{0,0}}};
            struct S0 l_1005 = {0xC9717F21};
            int32_t ***l_1010 = (void*)0;
            int i, j, k;
            if (p_9)
            { /* block id: 600 */
                (***g_330) = (***g_330);
                for (p_9 = 8; (p_9 >= 1); p_9 -= 1)
                { /* block id: 604 */
                    int i;
                    if (g_97[g_754])
                        break;
                    if ((l_1004[0][0][0] && (&p_9 != (void*)0)))
                    { /* block id: 606 */
                        return p_9;
                    }
                    else
                    { /* block id: 608 */
                        int32_t *l_1006 = &l_988;
                        l_1006 = func_60(l_1005);
                        /* statement id: 609 */
                        assert (l_1006 == &g_3);
                        return p_10;
                    }
                }
            }
            else
            { /* block id: 613 */
                struct S0 *l_1014 = &g_62[0][0];
                (*g_944) = (safe_add_func_int32_t_s_s(p_9, ((l_1009 != l_1010) == ((safe_mul_func_int16_t_s_s((+(g_97[3] | ((1 | (&l_1005 == l_1014)) != (-6)))), (0xB734 == p_10))) ^ g_62[3][3].f0))));
            }
        }
        (*l_994) = p_9;
    }
    /* facts after for loop */
    //assert (g_998 == dangling || g_998 == &g_999);
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads : g_264 g_97 g_67 g_3 g_330 g_331 g_332 g_62.f0 g_62 g_103 g_104 g_105 g_329
 * writes: g_67 g_97 g_264 g_62 g_103
 */
static const uint16_t  func_15(int8_t  p_16, uint8_t  p_17)
{ /* block id: 179 */
    struct S0 l_333[8] = {{0x06EB511B},{0x06EB511B},{0x06EB511B},{0x06EB511B},{0x06EB511B},{0x06EB511B},{0x06EB511B},{0x06EB511B}};
    int32_t *l_335 = &g_97[3];
    int32_t **l_334 = &l_335;
    struct S0 * const ** const l_340 = (void*)0;
    struct S0 *****l_349 = &g_329[1][0];
    int32_t l_363 = 0x3E20B615;
    uint32_t l_474[2];
    uint32_t l_499[6];
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_474[i] = 1U;
    for (i = 0; i < 6; i = i + 1)
        l_499[i] = 0xFFA1354D;
    (*l_334) = func_60(l_333[2]);
    /* statement id: 180 */
    assert (g_67 == &g_3);
    assert (l_335 == &g_3);
    (*l_334) = &g_97[1];
    /* statement id: 181 */
    assert ((l_335 >= &g_97[0] && l_335 <= &g_97[7]));
    if ((safe_div_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u((((void*)0 == l_340) >= g_264), (p_17 == ((safe_mul_func_int16_t_s_s(g_97[2], ((safe_sub_func_uint8_t_u_u(((((safe_div_func_uint16_t_u_u(p_16, (safe_sub_func_uint32_t_u_u((*l_335), (l_349 != l_349))))) && p_16) != 1U) < (**l_334)), 0x6E)) >= (**l_334)))) || (**l_334))))) >= g_97[2]), p_17)))
    { /* block id: 182 */
        const int8_t l_350 = 0x97;
        return l_350;
    }
    else
    { /* block id: 184 */
        (*l_335) = (safe_div_func_int16_t_s_s((safe_sub_func_uint8_t_u_u((((1U | (safe_mod_func_int8_t_s_s((safe_rshift_func_uint8_t_u_s((((~(p_17 && (p_17 && (g_264 <= (**l_334))))) || 0x43) <= (safe_rshift_func_uint16_t_u_s((0U < 0xD097FBBC), (+(*g_67))))), (**l_334))), 1U))) ^ l_363) == p_17), 0x82)), (*l_335)));
        for (p_17 = 0; (p_17 > 34); p_17 = safe_add_func_int8_t_s_s(p_17, 9))
        { /* block id: 188 */
            return g_97[3];
        }
    }
    for (g_264 = (-15); (g_264 > 28); ++g_264)
    { /* block id: 194 */
        const struct S0 l_368 = {0x047791FE};
        struct S0 *****l_443 = &g_329[1][0];
        uint16_t l_502 = 0x9135;
        int32_t l_503 = 4;
        (***g_330) = l_368;
        for (p_17 = 0; (p_17 >= 14); p_17 = safe_add_func_uint16_t_u_u(p_17, 4))
        { /* block id: 198 */
            int32_t l_391 = 8;
            struct S0 **** const *l_393 = &g_329[0][0];
            int32_t *l_405 = &g_97[3];
            int32_t l_473[4] = {0,0,0,0};
            int i;
            for (p_16 = 7; (p_16 >= 0); p_16 -= 1)
            { /* block id: 201 */
                const uint32_t l_387 = 1U;
                struct S0 *****l_392 = &g_329[1][0];
                for (l_363 = 7; (l_363 >= 0); l_363 -= 1)
                { /* block id: 204 */
                    uint32_t l_388 = 0x09DD38E6;
                    int i;
                    g_97[p_16] = ((safe_lshift_func_int8_t_s_s(p_16, 5)) | ((safe_mul_func_int16_t_s_s(((((safe_sub_func_uint8_t_u_u(g_97[2], g_62[3][3].f0)) | (safe_mod_func_int32_t_s_s((((safe_rshift_func_int8_t_s_u((safe_add_func_int16_t_s_s(p_17, (&g_330 != (void*)0))), ((**l_334) && 0x5F))) & (safe_sub_func_uint16_t_u_u(((safe_div_func_int16_t_s_s(0xBF7E, l_387)) & g_264), p_17))) >= (-1)), p_16))) <= 65531U) > l_388), g_62[3][3].f0)) <= 0x1BD201EB));
                    if (p_16)
                        continue;
                }
                if ((safe_rshift_func_int8_t_s_u((l_391 | (l_392 != l_393)), 5)))
                { /* block id: 208 */
                    struct S0 l_394 = {1U};
                    (***g_330) = l_394;
                }
                else
                { /* block id: 210 */
                    struct S0 l_395 = {1U};
                    (*l_334) = func_60(l_395);
                    /* statement id: 211 */
                    assert (l_335 == &g_3);
                }
                for (l_363 = 0; (l_363 > 23); l_363 = safe_add_func_uint8_t_u_u(l_363, 8))
                { /* block id: 215 */
                    struct S0 l_400 = {4294967295U};
                    for (l_391 = 23; (l_391 > 19); l_391 = safe_sub_func_uint32_t_u_u(l_391, 3))
                    { /* block id: 218 */
                        (*l_334) = func_55(l_400, &g_97[3], l_400.f0);
                    }
                    g_97[3] = p_17;
                }
            }
            (*l_405) = (safe_mul_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((*l_349) != &g_330), p_16)), (((p_16 && (p_16 | p_16)) && 65535U) >= 0xDDE07FD6)));
            for (l_363 = 0; (l_363 < (-3)); --l_363)
            { /* block id: 227 */
                int16_t l_432 = (-8);
                int32_t ***l_447[4];
                int32_t ****l_446 = &l_447[3];
                int32_t l_472[7];
                int i;
                for (i = 0; i < 4; i = i + 1)
                    l_447[i] = &l_334;
                for (i = 0; i < 7; i = i + 1)
                    l_472[i] = 5;
                for (l_391 = 0; (l_391 >= 3); l_391 = safe_add_func_uint32_t_u_u(l_391, 1))
                { /* block id: 230 */
                    int32_t ***l_424 = &l_334;
                }
            }
        }
        for (l_363 = 0; (l_363 >= 12); l_363 = safe_add_func_int8_t_s_s(l_363, 1))
        { /* block id: 253 */
            struct S0 *****l_482 = &g_329[1][0];
            uint8_t l_490 = 3U;
            l_490 = (l_368.f0 ^ (safe_lshift_func_uint16_t_u_u(((safe_mod_func_int8_t_s_s((((void*)0 != l_482) & (+(**l_334))), ((0xA7E6 | l_368.f0) & 0x8C))) <= (255U < (safe_mod_func_int16_t_s_s((safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(0x4978, 3)), l_368.f0)), 0xD04A)))), p_17)));
            l_503 = (((safe_sub_func_int32_t_s_s((safe_rshift_func_int8_t_s_u((safe_lshift_func_int16_t_s_u(0x55AA, (((safe_div_func_int32_t_s_s((l_499[1] | (safe_div_func_uint32_t_u_u((0x09C7C716 & (-1)), (-9)))), 1U)) <= l_502) >= (*g_67)))), l_368.f0)), p_17)) != g_62[3][3].f0) < p_17);
        }
        for (p_17 = 0; (p_17 != 49); p_17 = safe_add_func_uint16_t_u_u(p_17, 1))
        { /* block id: 259 */
            int8_t l_509 = 8;
            struct S0 *****l_512 = &g_329[1][0];
            int32_t *l_518 = &g_97[1];
            for (l_502 = (-11); (l_502 != 1); l_502 = safe_add_func_int16_t_s_s(l_502, 3))
            { /* block id: 262 */
                uint8_t l_508[5][2][3] = {{{0x52,0xE3,0x4E},{248U,0U,0x4E}},{{0xC6,0x4E,0x52},{0x66,0x52,0xE5}},{{0x4E,0x4E,0x52},{0x85,0U,0x84}},{{0x85,0xE3,0x66},{0x4E,0x52,0U}},{{0x66,0x85,0x66},{251U,0xE3,0xE5}}};
                struct S0 ***l_515 = &g_331;
                int i, j, k;
                (*l_334) = func_60((**g_331));
                /* statement id: 263 */
                assert (l_335 == &g_3);
                l_508[0][0][2] = (p_17 == ((0xD2 >= p_16) & p_17));
                l_509 = 0x4D21402C;
                l_503 = (safe_add_func_uint16_t_u_u((l_512 == &g_329[1][0]), ((0x3F ^ (l_515 == (void*)0)) || l_508[1][0][0])));
            }
            (*l_518) = (safe_sub_func_int32_t_s_s((-7), 0xFED956FE));
            if (p_17)
                continue;
        }
    }
    /* facts after for loop */
    assert (l_335 == &g_3 || (l_335 >= &g_97[0] && l_335 <= &g_97[7]));
    return (**l_334);
}


/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes: g_329
 */
static uint16_t  func_22(int32_t  p_23, int16_t  p_24, struct S0  p_25)
{ /* block id: 171 */
    const struct S0 ****l_328 = (void*)0;
    const struct S0 *****l_327[2];
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_327[i] = &l_328;
    for (p_23 = 0; (p_23 >= 28); p_23 = safe_add_func_uint16_t_u_u(p_23, 7))
    { /* block id: 174 */
        if (g_3)
            break;
    }
    g_329[1][0] = (void*)0;
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_67
 */
static int32_t  func_30(int16_t  p_31, int8_t  p_32, int32_t  p_33)
{ /* block id: 167 */
    struct S0 l_320 = {0x0311EA46};
    struct S0 *l_321 = &l_320;
    const int32_t *l_322 = (void*)0;
    (*l_321) = l_320;
    g_67 = l_322;
    /* statement id: 169 */
    assert (g_67 == 0);
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads : g_97 g_3 g_62 g_104 g_105 g_264 g_67 g_103
 * writes: g_97 g_67 g_62 g_103 g_264
 */
inline static int8_t  func_34(int16_t  p_35, int32_t  p_36, uint16_t  p_37)
{ /* block id: 123 */
    const struct S0 * const l_243 = &g_62[3][3];
    int32_t l_244 = 4;
    struct S0 l_253[3][4][4] = {{{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}}},{{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}}},{{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}},{{0x38AAF256},{4294967287U},{0x38AAF256},{4294967287U}}}};
    int32_t l_297[7];
    int i, j, k;
    for (i = 0; i < 7; i = i + 1)
        l_297[i] = 0;
    g_97[3] = ((safe_unary_minus_func_uint32_t_u((g_97[3] <= (safe_mul_func_uint8_t_u_u((l_243 != l_243), (l_244 | ((safe_rshift_func_int16_t_s_u(0xC1DD, (safe_lshift_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_u(l_244, 5)), p_37)))) && (p_37 <= g_3)))))))) <= 0);
    for (p_35 = (-20); (p_35 > 16); ++p_35)
    { /* block id: 127 */
        uint16_t l_287 = 0xADBF;
        struct S0 l_299 = {4294967286U};
        int32_t *l_302 = &l_244;
        l_253[0][1][1] = (*l_243);
        for (p_36 = 0; (p_36 <= 2); p_36 += 1)
        { /* block id: 131 */
            int32_t l_265 = 0x4C53010F;
            int32_t *l_301 = &g_97[3];
            int i, j;
            l_265 = (safe_mod_func_int8_t_s_s((((safe_div_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u(g_97[1], (safe_rshift_func_uint16_t_u_u(((&g_62[(p_36 + 1)][(p_36 + 3)] != (*g_104)) > (l_253[0][1][1].f0 || l_244)), ((&g_62[(p_36 + 1)][(p_36 + 3)] != (void*)0) <= ((safe_lshift_func_int8_t_s_u(g_264, 1)) != p_35)))))), 0x24)) && (-6)) & 0x51EA), g_62[(p_36 + 1)][(p_36 + 3)].f0));
            for (l_265 = 2; (l_265 >= 0); l_265 -= 1)
            { /* block id: 135 */
                int32_t *l_278 = &g_97[3];
                struct S0 ***l_284 = (void*)0;
                struct S0 ****l_283 = &l_284;
                int16_t l_310[3];
                int i;
                for (i = 0; i < 3; i = i + 1)
                    l_310[i] = 0;
                if ((safe_unary_minus_func_int32_t_s((~((p_36 <= ((p_36 & (safe_add_func_uint16_t_u_u(((*g_67) == (safe_div_func_int8_t_s_s((safe_mod_func_int32_t_s_s((safe_sub_func_uint8_t_u_u(p_35, (safe_mod_func_uint8_t_u_u((l_278 == &g_3), (safe_sub_func_int16_t_s_s(((safe_add_func_uint16_t_u_u((l_283 != (void*)0), (safe_sub_func_uint16_t_u_u(p_35, g_97[6])))) >= 0U), l_287)))))), p_35)), g_97[0]))), 0x410F))) <= p_37)) <= p_36)))))
                { /* block id: 136 */
                    int16_t l_288 = 0x3612;
                    return l_288;
                }
                else
                { /* block id: 138 */
                    int32_t **l_294 = &l_278;
                    int32_t ***l_293 = &l_294;
                    int32_t *l_298 = &l_297[2];
                    for (l_244 = 0; (l_244 <= 7); l_244 += 1)
                    { /* block id: 141 */
                        int32_t **l_291 = (void*)0;
                        int32_t **l_292 = &l_278;
                        int32_t ****l_295 = (void*)0;
                        int32_t ***l_296[2];
                        int i, j, k;
                        for (i = 0; i < 2; i = i + 1)
                            l_296[i] = (void*)0;
                        (*l_292) = func_55(l_253[p_36][(p_36 + 1)][(l_265 + 1)], &g_97[3], (g_97[l_244] > (safe_rshift_func_int8_t_s_u(g_97[3], 5))));
                        l_296[0] = l_293;
                        /* statement id: 143 */
                        //assert (l_296[0] == &l_294 || l_296[0] == 0);
                        (**l_293) = func_55(g_62[(p_36 + 1)][(p_36 + 3)], &g_97[3], l_297[2]);
                    }
                    /* facts after for loop */
                    assert ((l_278 >= &g_97[0] && l_278 <= &g_97[7]) || l_278 == &g_3);
                    (*l_298) = (*g_67);
                    (*l_294) = &g_3;
                    /* statement id: 147 */
                    assert (l_278 == &g_3);
                }
                /* facts after branching */
                assert (l_278 == &g_3);
                l_278 = func_60(g_62[(p_36 + 1)][(p_36 + 3)]);
                for (l_287 = 0; (l_287 <= 2); l_287 += 1)
                { /* block id: 152 */
                    int32_t **l_300[4][10][6] = {{{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278},{&l_278,&l_278,&l_278,(void*)0,&l_278,&l_278},{&l_278,&l_278,&l_278,(void*)0,&l_278,&l_278},{&l_278,(void*)0,&l_278,(void*)0,(void*)0,(void*)0},{&l_278,&l_278,&l_278,(void*)0,&l_278,&l_278},{&l_278,(void*)0,&l_278,&l_278,&l_278,(void*)0},{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278},{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278},{&l_278,(void*)0,&l_278,(void*)0,&l_278,&l_278},{&l_278,&l_278,&l_278,&l_278,(void*)0,&l_278}},{{&l_278,(void*)0,&l_278,&l_278,&l_278,&l_278},{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278},{&l_278,&l_278,&l_278,(void*)0,&l_278,&l_278},{&l_278,&l_278,&l_278,(void*)0,&l_278,&l_278},{&l_278,(void*)0,&l_278,(void*)0,(void*)0,(void*)0},{&l_278,&l_278,&l_278,(void*)0,&l_278,&l_278},{&l_278,(void*)0,&l_278,&l_278,&l_278,(void*)0},{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278},{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278},{&l_278,(void*)0,&l_278,(void*)0,&l_278,&l_278}},{{&l_278,&l_278,&l_278,&l_278,(void*)0,&l_278},{&l_278,(void*)0,&l_278,&l_278,&l_278,&l_278},{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278},{&l_278,&l_278,&l_278,(void*)0,(void*)0,&l_278},{&l_278,&l_278,&l_278,&l_278,&l_278,(void*)0},{&l_278,(void*)0,&l_278,&l_278,&l_278,(void*)0},{&l_278,(void*)0,&l_278,(void*)0,&l_278,(void*)0},{&l_278,&l_278,&l_278,&l_278,&l_278,(void*)0},{&l_278,&l_278,&l_278,(void*)0,&l_278,(void*)0},{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278}},{{&l_278,&l_278,&l_278,&l_278,&l_278,&l_278},{&l_278,(void*)0,&l_278,&l_278,&l_278,&l_278},{&l_278,(void*)0,&l_278,(void*)0,&l_278,&l_278},{&l_278,&l_278,&l_278,&l_278,(void*)0,&l_278},{&l_278,&l_278,&l_278,(void*)0,(void*)0,&l_278},{&l_278,&l_278,&l_278,&l_278,&l_278,(void*)0},{&l_278,(void*)0,&l_278,&l_278,&l_278,(void*)0},{&l_278,(void*)0,&l_278,(void*)0,&l_278,(void*)0},{&l_278,&l_278,&l_278,&l_278,&l_278,(void*)0},{&l_278,&l_278,&l_278,(void*)0,&l_278,(void*)0}}};
                    int i, j, k;
                    l_301 = func_55(l_299, &l_244, g_3);
                    for (g_264 = 0; (g_264 <= 2); g_264 += 1)
                    { /* block id: 156 */
                        const struct S0 *l_319 = &l_253[0][1][1];
                        const struct S0 **l_318 = &l_319;
                        const struct S0 ***l_317[5][6][2] = {{{&l_318,&l_318},{&l_318,&l_318},{&l_318,&l_318},{(void*)0,&l_318},{&l_318,&l_318},{&l_318,&l_318}},{{&l_318,&l_318},{&l_318,(void*)0},{&l_318,&l_318},{&l_318,&l_318},{&l_318,&l_318},{&l_318,&l_318}},{{&l_318,&l_318},{&l_318,&l_318},{&l_318,&l_318},{&l_318,(void*)0},{&l_318,&l_318},{&l_318,&l_318}},{{&l_318,&l_318},{&l_318,&l_318},{(void*)0,&l_318},{&l_318,&l_318},{&l_318,&l_318},{&l_318,&l_318}},{{&l_318,(void*)0},{&l_318,&l_318},{&l_318,&l_318},{&l_318,&l_318},{&l_318,&l_318},{&l_318,&l_318}}};
                        int i, j, k;
                        l_302 = func_60(l_299);
                        /* statement id: 157 */
                        assert (l_302 == &g_3);
                        l_297[1] = ((g_3 && ((((void*)0 == &l_300[g_264][(p_36 + 5)][(p_36 + 2)]) && (((safe_add_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u(((~l_310[0]) == (safe_add_func_uint8_t_u_u((safe_rshift_func_int16_t_s_s((p_36 < g_62[3][3].f0), 5)), (safe_mul_func_uint16_t_u_u((((l_317[4][0][1] == (void*)0) <= (*g_67)) <= (-1)), 65531U))))), g_62[3][3].f0)), 10)), 0xE9E38342)) || (*l_278)) > p_35)) >= p_37)) | 0);
                        if (l_253[0][1][1].f0)
                            break;
                        if ((*g_67))
                            continue;
                    }
                }
            }
            /* facts after for loop */
            assert ((l_301 >= &g_97[0] && l_301 <= &g_97[7]) || l_301 == &g_3);
        }
        /* facts after for loop */
        assert (l_302 == &g_3 || l_302 == &l_244);
    }
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_62.f0 g_97 g_67 g_3
 * writes: g_97
 */
static const int8_t  func_42(uint32_t  p_43, uint16_t  p_44)
{ /* block id: 115 */
    int32_t l_237 = (-9);
    for (p_44 = 0; (p_44 == 6); p_44 = safe_add_func_uint8_t_u_u(p_44, 6))
    { /* block id: 118 */
        struct S0 ** const l_224 = (void*)0;
        uint16_t l_229 = 0xCB3E;
        int32_t *l_236 = (void*)0;
        int32_t *l_238 = (void*)0;
        int32_t *l_239[5];
        int i;
        for (i = 0; i < 5; i = i + 1)
            l_239[i] = &g_97[0];
        g_97[3] = (safe_rshift_func_uint8_t_u_u(((void*)0 != l_224), (safe_add_func_int32_t_s_s(((0xBB1F != g_62[3][3].f0) >= ((safe_div_func_int32_t_s_s(l_229, (p_43 || 0x176E))) && (safe_mul_func_uint16_t_u_u((safe_mul_func_int8_t_s_s((safe_lshift_func_int8_t_s_u(((void*)0 != l_236), 4)), g_62[3][3].f0)), g_97[3])))), l_237))));
        if ((*g_67))
            continue;
    }
    return l_237;
}


/* ------------------------------------------ */
/* 
 * reads : g_62 g_67 g_3 g_103 g_97 g_104 g_105
 * writes: g_67 g_62 g_97 g_103
 */
inline static int32_t  func_47(int32_t  p_48, int16_t  p_49, uint32_t  p_50, uint32_t  p_51)
{ /* block id: 4 */
    struct S0 l_59 = {0xFFBE6269};
    int32_t *l_204 = &g_97[7];
    int32_t l_207 = 0xDD9E1A7E;
    int32_t *l_208 = &g_97[4];
    int8_t l_216 = (-7);
    l_204 = func_55(l_59, &g_3, p_49);
    /* statement id: 111 */
    assert (g_67 == &g_3);
    assert (l_204 == &g_3 || (l_204 >= &g_97[0] && l_204 <= &g_97[7]));
    (*l_208) = (safe_add_func_int8_t_s_s((l_204 != (void*)0), (g_97[3] == (p_48 | l_207))));
    (*l_208) = (safe_add_func_int32_t_s_s((safe_unary_minus_func_int16_t_s((safe_sub_func_int32_t_s_s(0x37B64F65, ((*l_204) && ((safe_rshift_func_int16_t_s_s((((((0xB329 & l_216) | (+((g_62[3][3].f0 > ((void*)0 != (*g_103))) & (safe_div_func_int8_t_s_s((&l_59 != &l_59), (*l_208)))))) == g_97[0]) < p_50) ^ g_3), 0)) == 6)))))), g_97[3]));
    return (*g_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_62 g_67 g_3 g_103 g_97 g_104 g_105
 * writes: g_67 g_62 g_97 g_103
 */
static int32_t * func_55(struct S0  p_56, int32_t * p_57, uint8_t  p_58)
{ /* block id: 5 */
    uint16_t l_84[4][3] = {{0xD3F7,0xD3F7,65535U},{0x5B49,65535U,65535U},{65535U,0x6D54,0xAE89},{0x5B49,0x6D54,0x5B49}};
    uint32_t l_89 = 4294967295U;
    uint16_t l_90[4][1][6] = {{{4U,0xE71D,0x63D1,0xE71D,4U,4U}},{{0x345D,0xE71D,0xE71D,0x345D,5U,0x345D}},{{0x345D,5U,0x345D,0xE71D,0xE71D,0x345D}},{{4U,0xE71D,0x345D,5U,0x345D,0xE71D}}};
    struct S0 *l_169[4] = {&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]};
    int32_t *l_203 = &g_97[3];
    int i, j, k;
lbl_95:
    p_57 = func_60(g_62[3][3]);
    /* statement id: 10 */
    assert (p_57 == &g_3);
    assert (g_67 == &g_3);
    for (p_58 = 0; (p_58 == 43); ++p_58)
    { /* block id: 13 */
        int32_t *l_72 = (void*)0;
        int32_t **l_71 = &l_72;
        struct S0 l_114 = {8U};
        uint32_t l_145 = 5U;
        (*l_71) = func_60(p_56);
        /* statement id: 14 */
        assert (l_72 == &g_3);
        if (((((((safe_add_func_uint8_t_u_u((safe_mul_func_uint16_t_u_u(((p_58 >= (((void*)0 != &p_57) >= (safe_mod_func_int16_t_s_s(((safe_mod_func_int16_t_s_s((((*g_67) && (((*l_72) <= p_56.f0) >= ((safe_lshift_func_uint8_t_u_u(((safe_unary_minus_func_uint16_t_u((l_84[0][2] ^ 0x7221))) & ((((safe_rshift_func_int8_t_s_u((safe_mod_func_uint16_t_u_u((*l_72), p_56.f0)), g_62[3][3].f0)) < (**l_71)) | 0x0016C6A4) || l_89)), l_90[3][0][0])) != 0x8BFD1E45))) & 0xF9), 0xEB5F)) | g_62[3][3].f0), (-1))))) < g_62[3][3].f0), p_56.f0)), g_62[3][3].f0)) & p_56.f0) < 1U) < 0x2E) == (*p_57)) > g_3))
        { /* block id: 15 */
            (*l_71) = (*l_71);
            for (l_89 = (-8); (l_89 > 11); ++l_89)
            { /* block id: 19 */
                struct S0 *l_93 = (void*)0;
                struct S0 *l_94 = &g_62[3][0];
                (*l_94) = p_56;
            }
            if ((0 <= p_58))
            { /* block id: 22 */
                int32_t *l_96 = &g_97[3];
                if (g_3)
                    goto lbl_95;
                (*l_96) = 0x8392DDE9;
                for (p_56.f0 = 0; (p_56.f0 <= 37); ++p_56.f0)
                { /* block id: 27 */
                    if (p_56.f0)
                        goto lbl_95;
                }
                if ((*p_57))
                { /* block id: 30 */
                    struct S0 *l_100[8][7] = {{&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]},{&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]},{&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]},{&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]},{&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]},{&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]},{&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]},{&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3],&g_62[3][3]}};
                    int i, j;
                    (*l_96) = 0x6C4802A3;
                    p_56 = p_56;
                    if ((*g_67))
                        continue;
                    for (p_56.f0 = 24; (p_56.f0 != 9); p_56.f0 = safe_sub_func_uint8_t_u_u(p_56.f0, 5))
                    { /* block id: 36 */
                        struct S0 * const ***l_106[9][6] = {{&g_103,&g_103,&g_103,&g_103,&g_103,&g_103},{&g_103,&g_103,&g_103,&g_103,&g_103,&g_103},{&g_103,&g_103,&g_103,&g_103,&g_103,&g_103},{&g_103,(void*)0,&g_103,&g_103,&g_103,&g_103},{&g_103,&g_103,&g_103,&g_103,&g_103,&g_103},{&g_103,&g_103,&g_103,&g_103,&g_103,&g_103},{&g_103,&g_103,&g_103,(void*)0,&g_103,(void*)0},{&g_103,&g_103,&g_103,&g_103,&g_103,&g_103},{&g_103,&g_103,&g_103,&g_103,&g_103,&g_103}};
                        int i, j;
                        (*l_71) = l_96;
                        /* statement id: 37 */
                        assert ((l_72 >= &g_97[0] && l_72 <= &g_97[7]));
                        (*l_71) = (void*)0;
                        /* statement id: 38 */
                        assert (l_72 == 0);
                        g_103 = g_103;
                    }
                    /* facts after for loop */
                    assert (l_72 == 0 || l_72 == &g_3);
                }
                else
                { /* block id: 41 */
                    int16_t l_111[5][2] = {{9,5},{9,5},{9,5},{9,5},{9,5}};
                    int i, j;
                    for (p_56.f0 = 0; (p_56.f0 != 42); p_56.f0 = safe_add_func_int32_t_s_s(p_56.f0, 2))
                    { /* block id: 44 */
                        (*l_96) = (g_97[3] & 0x8F33);
                    }
                    if ((*g_67))
                        continue;
                    (*l_96) = (safe_sub_func_uint8_t_u_u((p_56.f0 >= l_111[2][0]), l_111[2][0]));
                }
                /* facts after branching */
                assert (l_72 == 0 || l_72 == &g_3);
            }
            else
            { /* block id: 50 */
                struct S0 *l_112 = &g_62[2][2];
                int32_t l_113 = (-1);
                (*l_112) = p_56;
                l_113 = (8U <= l_84[2][1]);
                for (l_113 = 3; (l_113 >= 0); l_113 -= 1)
                { /* block id: 55 */
                    return p_57;
                    /* statement id: 56 */
                    //assert (func_55_rv == &g_3);
                }
                return &g_3;
                /* statement id: 58 */
                //assert (func_55_rv == &g_3);
            }
            /* facts after branching */
            assert (l_72 == 0 || l_72 == &g_3);
        }
        else
        { /* block id: 60 */
            struct S0 *l_116 = &g_62[3][2];
            struct S0 **l_115 = &l_116;
            int32_t l_138 = 0xBB848F33;
            (*l_71) = func_60(l_114);
            (*l_115) = (*g_104);
            /* statement id: 62 */
            assert (l_116 == 0);
            if ((!((safe_mul_func_uint16_t_u_u(1U, g_97[7])) > (safe_sub_func_int8_t_s_s((safe_lshift_func_uint16_t_u_s((!0x3CABD61F), ((safe_lshift_func_uint16_t_u_s((safe_div_func_int8_t_s_s(((safe_sub_func_int8_t_s_s(((safe_rshift_func_uint8_t_u_s((safe_mod_func_int32_t_s_s((safe_rshift_func_int16_t_s_s((~((l_138 != p_58) != (safe_mul_func_uint16_t_u_u(((**l_71) ^ (safe_mul_func_uint16_t_u_u((l_84[3][2] != (((safe_div_func_int16_t_s_s(((void*)0 != &p_56), g_97[3])) || g_3) >= 0x86)), p_56.f0))), (**l_71))))), 0)), (*g_67))), g_97[4])) >= 0xA02A5551), l_84[0][2])) > 1), l_90[2][0][3])), l_145)) ^ 3))), l_138)))))
            { /* block id: 63 */
                for (l_89 = 0; (l_89 <= 40); l_89 = safe_add_func_int32_t_s_s(l_89, 1))
                { /* block id: 66 */
                    struct S0 ***l_153[3];
                    struct S0 *** const *l_152 = &l_153[0];
                    int32_t *l_162 = (void*)0;
                    int32_t *l_163 = &g_97[3];
                    int i;
                    for (i = 0; i < 3; i = i + 1)
                        l_153[i] = (void*)0;
                    (*l_163) = (safe_lshift_func_int8_t_s_s(g_62[3][3].f0, (safe_mod_func_uint16_t_u_u((((void*)0 == l_152) != g_3), (safe_add_func_int32_t_s_s(((safe_mul_func_int8_t_s_s((safe_rshift_func_uint16_t_u_s((g_3 && (&p_57 == (void*)0)), ((**l_71) & ((g_97[3] || 0x85) <= p_56.f0)))), l_138)) < p_58), 0xDA28E2A2))))));
                    (*l_163) = (&l_114 != (*g_104));
                    for (l_138 = (-19); (l_138 != 15); ++l_138)
                    { /* block id: 71 */
                        (*l_71) = (void*)0;
                        /* statement id: 72 */
                        assert (l_72 == 0);
                        return &g_97[2];
                        /* statement id: 73 */
                        //assert ((func_55_rv >= &g_97[0] && func_55_rv <= &g_97[7]));
                    }
                    for (p_56.f0 = 0; (p_56.f0 <= 3); p_56.f0 += 1)
                    { /* block id: 77 */
                        int i, j;
                        g_62[p_56.f0][p_56.f0] = g_62[p_56.f0][(p_56.f0 + 2)];
                        if ((*g_67))
                            continue;
                        (*l_163) = (safe_rshift_func_int16_t_s_s(((0x1A791DEB == p_58) || (!(g_97[3] ^ ((*g_103) == (*g_103))))), 0));
                    }
                }
                l_169[0] = (void*)0;
                for (p_56.f0 = (-9); (p_56.f0 < 1); ++p_56.f0)
                { /* block id: 86 */
                    (*l_71) = p_57;
                    if ((*p_57))
                        break;
                }
            }
            else
            { /* block id: 90 */
                (*l_71) = func_60(p_56);
            }
            for (l_114.f0 = 0; (l_114.f0 >= 45); l_114.f0 = safe_add_func_uint8_t_u_u(l_114.f0, 1))
            { /* block id: 95 */
                if (p_58)
                    goto lbl_95;
            }
        }
        /* facts after branching */
        assert (l_72 == 0 || l_72 == &g_3);
    }
    for (l_89 = 10; (l_89 < 32); ++l_89)
    { /* block id: 102 */
        const uint8_t l_183 = 0x73;
        int32_t *l_199 = &g_97[3];
        (*l_199) = (safe_sub_func_int32_t_s_s((safe_lshift_func_int8_t_s_s(0xCC, 6)), (safe_unary_minus_func_uint16_t_u((safe_add_func_int16_t_s_s((l_183 ^ l_183), (safe_mod_func_int8_t_s_s((safe_unary_minus_func_uint16_t_u(0x662A)), ((safe_sub_func_uint32_t_u_u((safe_add_func_uint8_t_u_u((g_62[3][3].f0 < (safe_div_func_int32_t_s_s((safe_rshift_func_uint16_t_u_u(0U, 6)), (safe_add_func_int8_t_s_s((0x79 | (l_169[0] != (**g_103))), g_97[1]))))), g_62[3][3].f0)), g_3)) && 255U)))))))));
        for (p_58 = (-30); (p_58 == 27); p_58 = safe_add_func_int16_t_s_s(p_58, 8))
        { /* block id: 106 */
            int32_t **l_202 = &l_199;
            (*l_202) = func_60(p_56);
            /* statement id: 107 */
            assert (l_199 == &g_3);
        }
        /* facts after for loop */
        assert (l_199 == &g_3 || (l_199 >= &g_97[0] && l_199 <= &g_97[7]));
    }
    return l_203;
    /* statement id: 110 */
    //assert ((func_55_rv >= &g_97[0] && func_55_rv <= &g_97[7]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_67
 */
inline static int32_t * func_60(struct S0  p_61)
{ /* block id: 6 */
    struct S0 *l_64[5] = {&g_62[3][2],&g_62[3][2],&g_62[3][2],&g_62[3][2],&g_62[3][2]};
    struct S0 **l_63 = &l_64[2];
    const int32_t *l_65 = &g_3;
    const int32_t **l_66[7][2][4] = {{{&l_65,&l_65,&l_65,(void*)0},{&l_65,&l_65,&l_65,&l_65}},{{&l_65,&l_65,&l_65,&l_65},{&l_65,&l_65,&l_65,&l_65}},{{&l_65,&l_65,&l_65,&l_65},{&l_65,&l_65,&l_65,&l_65}},{{&l_65,&l_65,(void*)0,&l_65},{&l_65,&l_65,&l_65,&l_65}},{{&l_65,&l_65,(void*)0,&l_65},{&l_65,&l_65,&l_65,(void*)0}},{{&l_65,&l_65,&l_65,&l_65},{&l_65,&l_65,&l_65,&l_65}},{{&l_65,&l_65,&l_65,&l_65},{&l_65,&l_65,&l_65,&l_65}}};
    int32_t *l_68 = &g_3;
    int i, j, k;
    (*l_63) = &p_61;
    /* statement id: 7 */
    //assert (l_64[0] == &p_61 || (l_64[0] >= &g_62[0][0] && l_64[0] <= &g_62[3][5]));
    g_67 = l_65;
    /* statement id: 8 */
    assert (g_67 == &g_3);
    return l_68;
    /* statement id: 9 */
    //assert (func_60_rv == &g_3);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_3, "g_3", print_hash_value);
    for (i = 0; i < 4; i = i + 1)
    {
        for (j = 0; j < 6; j = j + 1)
        {
            transparent_crc(g_62[i][j].f0, "g_62[i][j].f0", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 8; i = i + 1)
    {
        transparent_crc(g_97[i], "g_97[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_264, "g_264", print_hash_value);
    transparent_crc(g_754, "g_754", print_hash_value);
    transparent_crc(g_971, "g_971", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 192
   depth: 1, occurrence: 33
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 158
   depth: 2, occurrence: 63
   depth: 3, occurrence: 2
   depth: 4, occurrence: 7
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 179

XXX times a variable address is taken: 594
XXX times a pointer is dereferenced on RHS: 167
breakdown:
   depth: 1, occurrence: 120
   depth: 2, occurrence: 40
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 116
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 11
   depth: 3, occurrence: 10
XXX times a pointer is compared with null: 51
XXX times a pointer is compared with address of another variable: 20
XXX times a pointer is compared with another pointer: 22
XXX times a pointer is qualified to be dereferenced: 1391

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1695
   level: 2, occurrence: 336
   level: 3, occurrence: 118
   level: 4, occurrence: 37
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 103
XXX number of pointers point to scalars: 51
XXX number of pointers point to structs: 25
XXX percent of pointers has null in alias set: 29.6
XXX average alias set size: 1.45

XXX times a non-volatile is read: 1223
XXX times a non-volatile is write: 433
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 172
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 28
   depth: 2, occurrence: 28
   depth: 3, occurrence: 34
   depth: 4, occurrence: 29
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 17.6
XXX percentage an existing variable is used: 82.4
********************* end of statistics **********************/

