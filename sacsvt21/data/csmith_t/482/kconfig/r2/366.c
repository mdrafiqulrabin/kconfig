/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1737213992
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int64_t  f0;
   uint16_t  f1;
   unsigned f2 : 26;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   unsigned f0 : 30;
   uint64_t  f1;
   signed f2 : 20;
   signed f3 : 16;
   signed f4 : 21;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_1(void);
inline static int32_t * const  func_2(int32_t * p_3, int64_t  p_4, int32_t * const  p_5);
inline static int32_t * func_6(uint32_t  p_7, int32_t  p_8, int32_t * p_9, int32_t * p_10, struct S1  p_11);
inline static struct S1  func_15(const int32_t * p_16, int32_t * p_17, int32_t  p_18);
inline static int32_t * func_19(float  p_20);
static int32_t * func_36(int32_t * const  p_37, uint16_t  p_38);
static const int32_t * func_41(const int32_t  p_42);
inline static struct S0  func_44(int32_t * p_45, int32_t * p_46, uint16_t  p_47, int32_t * p_48);
inline static float  func_81(int32_t * p_82, struct S1  p_83, uint16_t  p_84, uint32_t  p_85, int16_t  p_86);
static int32_t * func_87(int32_t ** p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_1(void)
{ /* block id: 0 */
    int64_t l_12 = 0xBBE56890C5440874LL;
    int32_t l_14 = 1L;
    int32_t *l_13 = &l_14;
    int32_t **l_545[6][8] = {{&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13,&l_13}};
    int32_t **l_546 = &l_13;
    uint32_t l_561 = 0x4CF1BBF3L;
    int32_t ****l_567 = (void*)0;
    int32_t *****l_566 = &l_567;
    struct S1 l_574 = {25823,18446744073709551608UL,-6,19,164};
    struct S1 *l_573 = &l_574;
    struct S1 **l_596[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    struct S1 ***l_595[7] = {(void*)0,&l_596[6],&l_596[6],(void*)0,&l_596[6],&l_596[6],(void*)0};
    int16_t l_612 = (-10L);
    const uint32_t l_631 = 0x4B0178D5L;
    struct S0 l_637 = {-7L,0xB8E5L,2374};
    float l_641 = 0x0.Fp+1;
    uint16_t l_642 = 9UL;
    struct S1 ** const *l_643[1];
    int16_t l_644 = 0L;
    uint8_t l_660 = 0UL;
    uint32_t l_662 = 0x7356B8C0L;
    const int64_t l_663 = 9L;
    int32_t l_665 = 0x7073861CL;
    int32_t **l_671 = &l_13;
    int64_t l_694 = 0xA3D19DAEE33F77F9LL;
    int32_t l_721 = 0x4214ED8FL;
    int32_t l_722 = 1L;
    int32_t l_726 = 7L;
    const uint8_t l_732 = 2UL;
    const int32_t *l_746 = &l_721;
    int32_t *l_747 = &l_14;
    int32_t l_754 = 0x3336A3DBL;
    uint32_t l_755 = 0x9255CDB4L;
    int64_t l_760[5][2][7] = {{{0xA84CD487F4C30130LL,0x883EC8D5C547451FLL,0xA84CD487F4C30130LL,0x4ADF5D18B406BDD8LL,0x4ADF5D18B406BDD8LL,0xA84CD487F4C30130LL,0x883EC8D5C547451FLL},{0x4ADF5D18B406BDD8LL,0x883EC8D5C547451FLL,0xA14C960DE7DAAE85LL,0xA14C960DE7DAAE85LL,0x883EC8D5C547451FLL,0x4ADF5D18B406BDD8LL,0x883EC8D5C547451FLL}},{{0xA84CD487F4C30130LL,0x4ADF5D18B406BDD8LL,0x4ADF5D18B406BDD8LL,0xA84CD487F4C30130LL,0x883EC8D5C547451FLL,0xA84CD487F4C30130LL,0x4ADF5D18B406BDD8LL},{0x259DACB73B6427ABLL,0x259DACB73B6427ABLL,0x4ADF5D18B406BDD8LL,0xA14C960DE7DAAE85LL,0x4ADF5D18B406BDD8LL,0x259DACB73B6427ABLL,0x259DACB73B6427ABLL}},{{0x259DACB73B6427ABLL,0x4ADF5D18B406BDD8LL,0xA14C960DE7DAAE85LL,0x4ADF5D18B406BDD8LL,0x259DACB73B6427ABLL,0x259DACB73B6427ABLL,0x4ADF5D18B406BDD8LL},{0xA84CD487F4C30130LL,0x883EC8D5C547451FLL,0xA84CD487F4C30130LL,0x4ADF5D18B406BDD8LL,0x4ADF5D18B406BDD8LL,0xA84CD487F4C30130LL,0x883EC8D5C547451FLL}},{{0x4ADF5D18B406BDD8LL,0x883EC8D5C547451FLL,0xA14C960DE7DAAE85LL,0xA14C960DE7DAAE85LL,0x883EC8D5C547451FLL,0x4ADF5D18B406BDD8LL,0x883EC8D5C547451FLL},{0xA84CD487F4C30130LL,0x4ADF5D18B406BDD8LL,0x4ADF5D18B406BDD8LL,0xA84CD487F4C30130LL,0x883EC8D5C547451FLL,0xA84CD487F4C30130LL,0x4ADF5D18B406BDD8LL}},{{0x259DACB73B6427ABLL,0x259DACB73B6427ABLL,0x4ADF5D18B406BDD8LL,0xA14C960DE7DAAE85LL,0x4ADF5D18B406BDD8LL,0x259DACB73B6427ABLL,0x259DACB73B6427ABLL},{0x259DACB73B6427ABLL,0x4ADF5D18B406BDD8LL,0xA14C960DE7DAAE85LL,0x4ADF5D18B406BDD8LL,0x259DACB73B6427ABLL,0x259DACB73B6427ABLL,0x4ADF5D18B406BDD8LL}}};
    uint32_t l_761 = 0x1365AE47L;
    struct S1 l_762 = {1645,18446744073709551615UL,753,144,-1396};
    uint64_t l_763 = 0UL;
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_643[i] = &l_596[0];
    return l_763;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_2(int32_t * p_3, int64_t  p_4, int32_t * const  p_5)
{ /* block id: 295 */
    int32_t l_511 = 0xE6B0D0ACL;
    int32_t *l_510 = &l_511;
    int32_t **l_512 = &l_510;
    uint16_t l_537 = 0UL;
    int16_t l_538 = (-9L);
    struct S1 l_543 = {7102,0UL,331,-82,575};
    struct S1 *l_544 = &l_543;
lbl_542:
    (*l_512) = l_510;
    for (l_511 = 0; (l_511 == 4); l_511 = safe_add_func_uint64_t_u_u(l_511, 1))
    { /* block id: 299 */
        int32_t * const *l_529 = &l_510;
        int32_t * const **l_528 = &l_529;
        int32_t * const ** const *l_527 = &l_528;
        float l_540[9] = {0x7.0DC504p+15,(-0x1.Ap+1),0x7.0DC504p+15,(-0x1.Ap+1),0x7.0DC504p+15,(-0x1.Ap+1),0x7.0DC504p+15,(-0x1.Ap+1),0x7.0DC504p+15};
        float *l_539 = &l_540[7];
        int32_t **l_541 = &l_510;
        int i;
        (*p_5) = (safe_rshift_func_uint8_t_u_u((safe_lshift_func_int8_t_s_u((safe_mod_func_int8_t_s_s(((((*p_5) < (safe_add_func_int8_t_s_s(((safe_sub_func_int32_t_s_s((safe_div_func_uint32_t_u_u((((0x39FCL <= (l_527 == (void*)0)) < (safe_rshift_func_uint8_t_u_s(((**l_512) <= (((((((p_4 != (-4L)) == (safe_add_func_uint8_t_u_u((safe_sub_func_int8_t_s_s(0x40L, ((((+p_4) | p_4) < 18446744073709551612UL) && (**l_529)))), 0xAFL))) | 0xE57200D2AF56BBDELL) <= l_537) | p_4) != 1UL) == p_4)), (****l_527)))) ^ 0x33C63A25L), 3UL)), (**l_529))) & 0xB87EL), p_4))) < p_4) >= p_4), l_538)), (*l_510))), (**l_512)));
        (*l_539) = 0xB.009A47p+78;
        (*l_541) = p_5;
        /* statement id: 302 */
        //assert (l_510 == &l_14);
        if (p_4)
            goto lbl_542;
    }
    (*l_512) = (void*)0;
    /* statement id: 305 */
    assert (l_510 == 0);
    (*l_544) = l_543;
    return p_3;
    /* statement id: 307 */
    //assert (func_2_rv == &l_14);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_6(uint32_t  p_7, int32_t  p_8, int32_t * p_9, int32_t * p_10, struct S1  p_11)
{ /* block id: 293 */
    return p_9;
    /* statement id: 294 */
    //assert (func_6_rv == &l_14 || func_6_rv == &l_560);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_15(const int32_t * p_16, int32_t * p_17, int32_t  p_18)
{ /* block id: 36 */
    int32_t l_76[7] = {(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)};
    struct S1 l_123[3] = {{27549,18446744073709551607UL,-776,172,767},{27549,18446744073709551607UL,-776,172,767},{27549,18446744073709551607UL,-776,172,767}};
    struct S1 **l_355 = (void*)0;
    struct S1 *l_357[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    struct S1 **l_356[2];
    struct S1 *l_358[8] = {&l_123[1],&l_123[1],&l_123[1],&l_123[1],&l_123[1],&l_123[1],&l_123[1],&l_123[1]};
    int32_t l_395 = (-1L);
    struct S0 * const l_464 = (void*)0;
    uint64_t l_496 = 0x87EB44AD30C9E96CLL;
    struct S1 l_509 = {4421,18446744073709551615UL,-41,153,-652};
    int i;
    for (i = 0; i < 2; i++)
        l_356[i] = &l_357[7];
    for (p_18 = 6; (p_18 >= 0); p_18 -= 1)
    { /* block id: 39 */
        struct S0 l_354 = {0xD6B8274297AA096ELL,0x2DC9L,6644};
        struct S0 *l_353 = &l_354;
        int i;
        (*l_353) = func_44(&l_76[0], &l_76[3], ((safe_add_func_uint64_t_u_u(l_76[p_18], (safe_add_func_int32_t_s_s(l_76[p_18], 0x97282F80L)))) || p_18), func_19(func_81(func_87(&p_17), l_123[1], l_76[2], l_123[1].f3, l_76[p_18])));
    }
    /* facts after for loop */
    //assert (p_17 == dangling || p_17 == 0 || p_17 == &l_14);
    l_358[1] = &l_123[1];
    for (p_18 = 0; (p_18 != (-24)); p_18 = safe_sub_func_uint8_t_u_u(p_18, 8))
    { /* block id: 232 */
        struct S1 *l_363 = &l_123[1];
        struct S1 *l_364[1];
        int32_t l_382 = 0x4CE8A4B9L;
        int32_t *l_414 = (void*)0;
        int32_t **l_503 = &l_414;
        int i;
        for (i = 0; i < 1; i++)
            l_364[i] = &l_123[1];
        if ((safe_lshift_func_uint8_t_u_s((l_363 != l_364[0]), p_18)))
        { /* block id: 233 */
            float l_366[7] = {0x3.0AE7E3p-63,0x3.0AE7E3p-63,0x1.Ep-1,0x3.0AE7E3p-63,0x3.0AE7E3p-63,0x1.Ep-1,0x3.0AE7E3p-63};
            float *l_365 = &l_366[2];
            int i;
            (*l_365) = p_18;
        }
        else
        { /* block id: 235 */
            struct S1 l_367 = {2986,18446744073709551611UL,-935,-3,-560};
            return l_367;
        }
        if ((((safe_lshift_func_int16_t_s_s(((((safe_rshift_func_int8_t_s_u((safe_rshift_func_int8_t_s_s((safe_add_func_uint16_t_u_u((safe_div_func_uint16_t_u_u(p_18, ((safe_sub_func_uint64_t_u_u(l_123[1].f4, (((l_382 >= l_123[1].f4) != (l_382 | (p_16 == p_16))) & ((p_18 != ((safe_rshift_func_int16_t_s_s(((safe_rshift_func_uint8_t_u_u((safe_mod_func_uint32_t_u_u(((safe_add_func_uint8_t_u_u(l_123[1].f4, l_76[3])) | 0L), 0x183D2D2BL)), l_123[1].f3)) == l_382), l_382)) != 0x5402L)) == l_123[1].f2)))) && l_395))), 65532UL)), p_18)), p_18)) | 0x0E0FE30266327F81LL) >= l_123[1].f2) >= p_18), p_18)) || l_76[5]) ^ 6UL))
        { /* block id: 238 */
            struct S1 ***l_396 = (void*)0;
            int32_t *l_397 = &l_382;
            float l_409[7][4] = {{(-0x4.Cp-1),0x1.387CF7p+69,0x1.387CF7p+69,(-0x4.Cp-1)},{(-0x4.Cp-1),0x1.387CF7p+69,0x1.387CF7p+69,(-0x4.Cp-1)},{(-0x4.Cp-1),0x1.387CF7p+69,0x1.387CF7p+69,(-0x4.Cp-1)},{(-0x4.Cp-1),0x1.387CF7p+69,0x1.387CF7p+69,(-0x4.Cp-1)},{(-0x4.Cp-1),0x1.387CF7p+69,0x1.387CF7p+69,(-0x4.Cp-1)},{(-0x4.Cp-1),0x1.387CF7p+69,0x1.387CF7p+69,(-0x4.Cp-1)},{(-0x4.Cp-1),0x1.387CF7p+69,0x1.387CF7p+69,(-0x4.Cp-1)}};
            float *l_408 = &l_409[2][2];
            int i, j;
            (*l_397) = (l_396 == &l_355);
            (*l_408) = ((-0x9.9p-1) >= ((0x1.Fp+1 > (safe_div_func_float_f_f((safe_div_func_float_f_f(0xB.9B9D1Ep+82, ((0x2.6C45A1p-7 == p_18) >= l_382))), (((safe_sub_func_float_f_f(l_382, (safe_div_func_float_f_f(((safe_sub_func_float_f_f(((0x0.5p+1 < (p_18 >= p_18)) != p_18), (-0x4.7p+1))) != 0xA.F82760p-33), p_18)))) == l_382) != (*l_397))))) <= (-0x1.0p-1)));
            (*l_363) = (*l_363);
        }
        else
        { /* block id: 242 */
            const int8_t l_422 = 0x12L;
            int32_t ****l_424 = (void*)0;
            int32_t *****l_423 = &l_424;
            struct S1 l_497[1][7] = {{{27392,18446744073709551615UL,-945,113,-1334},{5960,0x45A2E24881A1E6C8LL,559,-84,1380},{27392,18446744073709551615UL,-945,113,-1334},{27392,18446744073709551615UL,-945,113,-1334},{5960,0x45A2E24881A1E6C8LL,559,-84,1380},{27392,18446744073709551615UL,-945,113,-1334},{27392,18446744073709551615UL,-945,113,-1334}}};
            int i, j;
            for (l_395 = (-20); (l_395 != (-25)); --l_395)
            { /* block id: 245 */
                int32_t *** const *l_413 = (void*)0;
                int32_t *** const **l_412 = &l_413;
                float l_452[6];
                float * const l_451 = &l_452[0];
                float * const * const l_450 = &l_451;
                int i;
                for (i = 0; i < 6; i++)
                    l_452[i] = 0xD.2C7864p-88;
                l_412 = (void*)0;
                /* statement id: 246 */
                assert (l_412 == 0);
                l_414 = &p_18;
                /* statement id: 247 */
                assert (l_414 == &p_18);
                for (l_382 = 20; (l_382 >= (-21)); l_382 = safe_sub_func_int8_t_s_s(l_382, 8))
                { /* block id: 250 */
                    int32_t l_421[2][7][10] = {{{0x6BEDF1BFL,0xA21CE6FCL,(-1L),0x8C037808L,0L,(-1L),0x839F4D44L,(-9L),0x6671C1E4L,1L},{(-1L),0xE4D90370L,(-1L),0L,(-5L),(-9L),0xD69E62C4L,1L,0xB89E422EL,0x595FBE27L},{(-6L),(-1L),0x908D176DL,(-6L),0xC1255270L,0L,0x839F4D44L,0xA21CE6FCL,0x40FF2E7EL,0xC1255270L},{(-6L),0xD69E62C4L,(-1L),0xC1255270L,9L,0xE088B177L,9L,0xC1255270L,(-1L),0xD69E62C4L},{0xC1255270L,(-1L),0x6BEDF1BFL,(-5L),0x17FE4AA0L,0xEB0F8DDCL,(-8L),0x6671C1E4L,(-6L),1L},{(-8L),0x6BEDF1BFL,0x10935329L,0L,0x6671C1E4L,0xEB0F8DDCL,0x40FF2E7EL,1L,0xA21CE6FCL,0L},{0xC1255270L,(-6L),(-1L),1L,0x595FBE27L,0xE088B177L,(-1L),0x10935329L,(-5L),0x40FF2E7EL}},{{(-6L),(-5L),1L,0x0094E848L,0x908D176DL,(-10L),0x8C037808L,0x8C037808L,(-10L),0x908D176DL},{(-6L),0xA3A7C934L,0xA3A7C934L,(-6L),0x10935329L,0xB89E422EL,(-9L),0xE4D90370L,0x595FBE27L,(-10L)},{4L,(-1L),0L,0x6671C1E4L,1L,(-8L),0xA3A7C934L,(-9L),0x595FBE27L,0x0094E848L},{0xE088B177L,(-1L),0x0094E848L,(-6L),0L,1L,(-1L),0L,(-10L),0x839F4D44L},{0x924840EAL,0x839F4D44L,(-1L),0x0094E848L,0xEB0F8DDCL,0x17EEFC13L,(-6L),0x595FBE27L,(-5L),0x595FBE27L},{0L,0x924840EAL,(-1L),1L,(-1L),0x924840EAL,0L,1L,0xA21CE6FCL,4L},{0xA3A7C934L,0x17FE4AA0L,0xB89E422EL,0L,0xC1255270L,(-6L),0x908D176DL,(-1L),(-6L),1L}}};
                    int32_t *l_430 = (void*)0;
                    int32_t *l_431 = &l_76[0];
                    struct S1 l_440[7] = {{9155,0x3328BE9F7AADC6A7LL,76,98,1112},{12540,7UL,109,-21,-1109},{9155,0x3328BE9F7AADC6A7LL,76,98,1112},{9155,0x3328BE9F7AADC6A7LL,76,98,1112},{12540,7UL,109,-21,-1109},{9155,0x3328BE9F7AADC6A7LL,76,98,1112},{9155,0x3328BE9F7AADC6A7LL,76,98,1112}};
                    int32_t **l_456 = &l_414;
                    float ***l_462 = (void*)0;
                    int i, j, k;
                    (*l_431) = (((safe_add_func_int8_t_s_s(((l_421[1][3][8] ^ l_422) != p_18), p_18)) && (l_423 != &l_424)) > (safe_unary_minus_func_uint64_t_u(((safe_rshift_func_uint16_t_u_s((safe_lshift_func_uint16_t_u_s(p_18, 12)), 13)) & p_18))));
                }
                for (l_382 = 6; (l_382 >= 0); l_382 -= 1)
                { /* block id: 269 */
                    int32_t **l_481 = (void*)0;
                    const int32_t **l_482 = (void*)0;
                    int32_t **l_483 = (void*)0;
                    int32_t **l_484 = &l_414;
                    struct S1 l_495 = {3859,1UL,454,-93,1124};
                    int i;
                }
            }
            /* facts after for loop */
            assert (l_414 == &p_18 || l_414 == 0);
            l_497[0][1] = (*l_363);
        }
        /* facts after branching */
        assert (l_414 == &p_18 || l_414 == 0);
        if (p_18)
            break;
        (*l_503) = func_36(&l_395, ((l_123[1].f3 >= p_18) | ((((safe_lshift_func_uint16_t_u_u((+(-1L)), p_18)) > l_395) >= p_18) < (p_18 | ((safe_add_func_uint64_t_u_u(p_18, 18446744073709551615UL)) > 0x6DF3298DL)))));
        /* statement id: 284 */
        assert (l_414 == 0);
    }
    for (l_395 = 6; (l_395 >= 2); l_395 -= 1)
    { /* block id: 288 */
        int32_t *l_506 = &l_76[3];
        struct S0 l_507 = {3L,0UL,4157};
        struct S0 *l_508 = &l_507;
        (*l_506) = (safe_add_func_uint64_t_u_u(l_123[1].f2, 0UL));
        (*l_508) = l_507;
    }
    return l_509;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_19(float  p_20)
{ /* block id: 1 */
    uint32_t l_21[6];
    int32_t l_22 = (-10L);
    int32_t *l_33 = &l_22;
    int32_t *l_34 = &l_22;
    int32_t *l_35 = (void*)0;
    int i;
    for (i = 0; i < 6; i++)
        l_21[i] = 0x1E2DB80EL;
    for (l_22 = 0; l_22 < 6; l_22 += 1)
    {
        l_21[l_22] = 0x3398963EL;
    }
    if ((0xF3L == l_21[4]))
    { /* block id: 3 */
        uint32_t l_23 = 18446744073709551613UL;
        int32_t *l_30 = &l_22;
        (*l_30) = ((l_23 || (l_23 > (((l_22 || l_23) != (safe_mod_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_u((((safe_lshift_func_int16_t_s_s(l_23, 14)) == (((-1L) == l_23) != l_22)) && 4294967289UL), l_23)), l_23))) || l_23))) & l_21[1]);
    }
    else
    { /* block id: 5 */
        int32_t *l_31 = &l_22;
        int32_t *l_32 = (void*)0;
        return l_32;
        /* statement id: 6 */
        //assert (func_19_rv == 0);
    }
    return l_35;
    /* statement id: 8 */
    //assert (func_19_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(int32_t * const  p_37, uint16_t  p_38)
{ /* block id: 9 */
    const uint8_t l_43 = 0UL;
    const int32_t **l_68 = (void*)0;
    const int32_t *l_69 = (void*)0;
    int32_t l_71 = 5L;
    int32_t *l_70 = &l_71;
    int32_t *l_72 = &l_71;
    int32_t *l_73[3];
    int32_t *l_74 = &l_71;
    int32_t *l_75[1];
    int i;
    for (i = 0; i < 3; i++)
        l_73[i] = &l_71;
    for (i = 0; i < 1; i++)
        l_75[i] = (void*)0;
    l_69 = func_41(l_43);
    return l_75[0];
    /* statement id: 35 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_41(const int32_t  p_42)
{ /* block id: 10 */
    int32_t l_50[8] = {0x39A24791L,0x39A24791L,0x39A24791L,0x39A24791L,0x39A24791L,0x39A24791L,0x39A24791L,0x39A24791L};
    int32_t *l_49[8] = {&l_50[3],&l_50[3],&l_50[3],&l_50[3],&l_50[3],&l_50[3],&l_50[3],&l_50[3]};
    int32_t *l_51 = &l_50[3];
    struct S0 l_62 = {0x178D33F623BA0E38LL,0x99A8L,5302};
    struct S0 *l_61[9];
    struct S0 l_63 = {0x6C6C4C54CFDD0FD0LL,65535UL,4149};
    const int32_t *l_64[5];
    const int32_t *l_65 = &l_50[3];
    const int32_t *l_66 = &l_50[2];
    const int32_t *l_67[1];
    int i;
    for (i = 0; i < 9; i++)
        l_61[i] = &l_62;
    for (i = 0; i < 5; i++)
        l_64[i] = &l_50[5];
    for (i = 0; i < 1; i++)
        l_67[i] = (void*)0;
    l_63 = func_44(l_49[2], l_51, p_42, &l_50[4]);
    return l_67[0];
    /* statement id: 33 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_44(int32_t * p_45, int32_t * p_46, uint16_t  p_47, int32_t * p_48)
{ /* block id: 11 */
    uint8_t l_52[4][7][6] = {{{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL}},{{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL}},{{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL}},{{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL},{255UL,255UL,255UL,255UL,255UL,255UL}}};
    struct S0 l_56[4] = {{1L,1UL,3711},{1L,1UL,3711},{1L,1UL,3711},{1L,1UL,3711}};
    int32_t l_60 = 0xB8EBACA8L;
    int32_t *l_59 = &l_60;
    int32_t **l_58[6][9][1] = {{{&l_59},{&l_59},{&l_59},{&l_59},{&l_59},{(void*)0},{&l_59},{&l_59},{&l_59}},{{&l_59},{&l_59},{&l_59},{&l_59},{&l_59},{&l_59},{&l_59},{(void*)0},{&l_59}},{{&l_59},{&l_59},{&l_59},{&l_59},{(void*)0},{&l_59},{&l_59},{&l_59},{(void*)0}},{{&l_59},{&l_59},{&l_59},{&l_59},{&l_59},{(void*)0},{&l_59},{&l_59},{&l_59}},{{&l_59},{&l_59},{&l_59},{&l_59},{&l_59},{&l_59},{&l_59},{(void*)0},{&l_59}},{{&l_59},{&l_59},{&l_59},{&l_59},{(void*)0},{&l_59},{&l_59},{&l_59},{(void*)0}}};
    int i, j, k;
    for (p_47 = 0; (p_47 <= 3); p_47 += 1)
    { /* block id: 14 */
        int32_t l_54 = 0xC310705EL;
        int32_t *l_53 = &l_54;
        struct S0 l_57 = {-8L,0x6445L,1786};
        if ((l_53 == p_46))
        { /* block id: 15 */
            struct S0 l_55[4][5] = {{{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383}},{{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383}},{{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383}},{{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383},{0x359916A5C54CD8D2LL,1UL,1383}}};
            int i, j;
            return l_55[0][3];
        }
        else
        { /* block id: 17 */
            for (l_54 = 0; (l_54 <= 3); l_54 += 1)
            { /* block id: 20 */
                return l_56[0];
            }
        }
        for (l_54 = 3; (l_54 >= 0); l_54 -= 1)
        { /* block id: 26 */
            return l_57;
        }
    }
    p_45 = p_48;
    /* statement id: 30 */
    //assert ((p_45 >= &l_50[0] && p_45 <= &l_50[7]) || p_45 == 0);
    return l_56[0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_81(int32_t * p_82, struct S1  p_83, uint16_t  p_84, uint32_t  p_85, int16_t  p_86)
{ /* block id: 79 */
    uint32_t l_126 = 4294967295UL;
    int32_t l_133 = 0L;
    int32_t *l_132 = &l_133;
    int32_t **l_131 = &l_132;
    const int32_t l_134 = 0x50500D59L;
    uint8_t l_135[9][6] = {{3UL,3UL,3UL,3UL,3UL,3UL},{3UL,3UL,3UL,3UL,3UL,3UL},{3UL,3UL,3UL,3UL,3UL,3UL},{3UL,3UL,3UL,3UL,3UL,3UL},{3UL,3UL,3UL,3UL,3UL,3UL},{3UL,3UL,3UL,3UL,3UL,3UL},{3UL,3UL,3UL,3UL,3UL,3UL},{3UL,3UL,3UL,3UL,3UL,3UL},{3UL,3UL,3UL,3UL,3UL,3UL}};
    int32_t ***l_136 = (void*)0;
    int32_t ***l_137 = &l_131;
    int32_t l_140 = 0L;
    int16_t l_144 = 0xD736L;
    int8_t l_198 = 0x0AL;
    struct S1 l_206 = {13637,0x0C17DBC78BEF3854LL,323,-120,-1274};
    struct S1 *l_205[7][8][4] = {{{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206}},{{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206}},{{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206}},{{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206}},{{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206}},{{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206}},{{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206},{&l_206,&l_206,&l_206,&l_206}}};
    const struct S0 l_278 = {7L,0UL,3936};
    const struct S0 *l_277 = &l_278;
    int32_t *** const *l_312 = &l_136;
    int32_t *** const * const *l_311 = &l_312;
    uint32_t l_335 = 0x77EC04D9L;
    int i, j, k;
    return p_83.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_87(int32_t ** p_88)
{ /* block id: 40 */
    int32_t l_89 = 9L;
    struct S1 l_102 = {19776,0x4350B5FE46E9995DLL,397,16,1113};
    int32_t *l_110 = (void*)0;
    int32_t *l_121[7] = {&l_89,&l_89,&l_89,&l_89,&l_89,&l_89,&l_89};
    int32_t *l_122 = (void*)0;
    int i;
    for (l_89 = 0; (l_89 == 16); l_89 = safe_add_func_uint32_t_u_u(l_89, 1))
    { /* block id: 43 */
        uint16_t l_92[8];
        int32_t l_93 = 1L;
        int32_t *l_98 = &l_93;
        struct S1 l_101 = {1048,3UL,-933,143,786};
        int i;
        for (i = 0; i < 8; i++)
            l_92[i] = 0xECA9L;
        for (l_93 = 6; (l_93 >= 0); l_93 -= 1)
        { /* block id: 46 */
            int32_t l_95 = 1L;
            int32_t *l_94 = &l_95;
            int i;
            (*l_94) = l_92[l_93];
            for (l_95 = 0; (l_95 <= 7); l_95 += 1)
            { /* block id: 50 */
                (*p_88) = &l_95;
                /* statement id: 51 */
                //assert (p_17 == &l_95);
                (*p_88) = (*p_88);
            }
            /* facts after for loop */
            //assert (p_17 == &l_95 || p_17 == dangling || p_17 == 0 || p_17 == &l_14);
        }
        l_93 = l_93;
        (*l_98) = (safe_rshift_func_uint8_t_u_s(l_89, 6));
        for (l_93 = 7; (l_93 >= 0); l_93 -= 1)
        { /* block id: 59 */
            int32_t l_99 = 1L;
            int32_t *l_105 = &l_93;
            uint64_t l_118 = 0x1D7ECA506553B860LL;
            for (l_99 = 7; (l_99 >= 1); l_99 -= 1)
            { /* block id: 62 */
                int32_t l_100 = 0x6058BBDFL;
                int32_t *l_104 = &l_93;
                int32_t *l_106 = &l_93;
                int32_t *l_107 = &l_93;
                int32_t *l_108 = &l_99;
                int32_t *l_109 = &l_89;
                float l_120 = (-0x7.5p-1);
                float *l_119 = &l_120;
                int i;
                for (l_100 = 0; (l_100 <= 7); l_100 += 1)
                { /* block id: 65 */
                    l_102 = l_101;
                }
                for (l_100 = 7; (l_100 >= 0); l_100 -= 1)
                { /* block id: 70 */
                    int32_t *l_103 = &l_89;
                    return l_110;
                    /* statement id: 71 */
                    //assert (func_87_rv == 0);
                }
                if (l_92[l_93])
                    break;
                (*l_119) = (((((*l_105) != ((*l_98) != ((void*)0 == &l_100))) != (safe_sub_func_float_f_f(((void*)0 != p_88), (safe_sub_func_float_f_f(0xC.E7BD33p+78, (!(((*l_98) == (safe_sub_func_float_f_f(((void*)0 == &l_93), (*l_106)))) <= (*l_105)))))))) >= (*l_106)) >= l_118);
            }
        }
    }
    return l_122;
    /* statement id: 78 */
    //assert (func_87_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 191
   depth: 1, occurrence: 23
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 48
breakdown:
   indirect level: 0, occurrence: 23
   indirect level: 1, occurrence: 15
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 58
XXX times a bitfields struct on LHS: 6
XXX times a bitfields struct on RHS: 39
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 55

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 23
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 206

XXX times a variable address is taken: 457
XXX times a pointer is dereferenced on RHS: 61
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 67
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 18
XXX times a pointer is qualified to be dereferenced: 1125

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 208
   level: 2, occurrence: 80
   level: 3, occurrence: 51
   level: 4, occurrence: 44
   level: 5, occurrence: 37
XXX number of pointers point to pointers: 92
XXX number of pointers point to scalars: 82
XXX number of pointers point to structs: 32
XXX percent of pointers has null in alias set: 34
XXX average alias set size: 1.29

XXX times a non-volatile is read: 703
XXX times a non-volatile is write: 222
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 71
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 19
   depth: 2, occurrence: 13
   depth: 3, occurrence: 11
   depth: 4, occurrence: 3

XXX percentage a fresh-made variable is used: 14.9
XXX percentage an existing variable is used: 85.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

