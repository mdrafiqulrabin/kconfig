/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1927867181
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   const int16_t  f2;
   const uint16_t  f3;
   uint16_t  f4;
   int32_t  f5;
};
#pragma pack(pop)

union U1 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_33(void);
inline static int32_t  func_34(uint32_t  p_35, int32_t  p_36, union U1  p_37, struct S0  p_38, uint32_t  p_39);
static uint16_t  func_44(union U1  p_45, int16_t  p_46, int16_t  p_47);
static union U1  func_48(int32_t  p_49, const uint32_t  p_50);
static uint32_t  func_51(int32_t  p_52);
static const int32_t  func_55(float  p_56, float  p_57, union U1  p_58);
inline static const uint16_t  func_70(uint16_t  p_71, union U1  p_72, struct S0  p_73, struct S0  p_74);
inline static int16_t  func_84(uint32_t  p_85, float  p_86, uint32_t  p_87, int16_t  p_88, float  p_89);
static union U1 * func_100(int32_t  p_101, int32_t ** p_102, const union U1 * const  p_103, int32_t * p_104);
static int32_t ** func_107(union U1  p_108, const int32_t  p_109, uint32_t  p_110, int16_t  p_111);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_33(void)
{ /* block id: 36 */
    float l_42 = 0x1.Ep+1;
    int32_t l_43 = 0xC3B7C39C;
    union U1 l_59 = {0x8072F259};
    int32_t *l_268 = &l_43;
    int32_t **l_267 = &l_268;
    int32_t l_269 = 0x863D7CA0;
    float l_313 = 0x0.D54F81p+56;
    uint32_t l_324 = 4294967295U;
    struct S0 l_325 = {0xB4317193,0x937FBBC7,0x9E7B,1U,65527U,1};
    union U1 l_339 = {4294967295U};
    int32_t l_374 = 0x01E680CE;
    union U1 **l_376 = (void*)0;
    float l_422 = 0x1.Cp+1;
    int16_t l_423 = 0xDF80;
    int32_t * const *l_431 = &l_268;
    int32_t * const **l_430 = &l_431;
    int32_t * const ***l_429 = &l_430;
    int32_t l_434 = 1;
    (**l_267) = func_34(((uint32_t)(l_43 || func_44(func_48(l_43, func_51((((((uint32_t)l_43 + (uint32_t)(func_55(l_43, (0x5.Fp+1 < 0x0.Bp-1), l_59) | ((uint16_t)((uint16_t)((void*)0 != l_267) << (uint16_t)(*l_268)) + (uint16_t)1))) < (*l_268)) | (-1)) & l_269))), (**l_267), (*l_268))) - (uint32_t)l_324), (**l_267), l_59, l_325, (*l_268));
    return l_434;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_34(uint32_t  p_35, int32_t  p_36, union U1  p_37, struct S0  p_38, uint32_t  p_39)
{ /* block id: 173 */
    float l_326 = (-0x9.1p-1);
    int32_t l_327 = 0x59065AF7;
    union U1 l_332 = {0x649E8291};
    union U1 *l_331 = &l_332;
    union U1 **l_330 = &l_331;
    int32_t *l_333 = &l_327;
    int32_t l_334 = 0;
    p_36 = (((((p_38.f0 <= l_327) < ((int16_t)(l_327 && (l_327 > (l_330 == &l_331))) << (int16_t)14)) == (p_37.f0 && p_36)) >= l_327) || l_327);
    l_333 = &l_327;
    l_333 = &p_36;
    /* statement id: 176 */
    assert (l_333 == &p_36);
    (*l_333) = 0x9.0p+1;
    return l_334;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_44(union U1  p_45, int16_t  p_46, int16_t  p_47)
{ /* block id: 159 */
    int32_t l_315 = 0xDA1FC9DC;
    int32_t *l_314 = &l_315;
    struct S0 l_319 = {1U,4294967295U,0x24FA,65535U,0x9A5B,0xB5662893};
    struct S0 *l_318 = &l_319;
    l_314 = l_314;
    if (p_47)
    { /* block id: 161 */
        const uint32_t l_317 = 0x992F350E;
        if ((p_46 & (1U && 0x2368)))
        { /* block id: 162 */
            uint16_t l_316 = 0xFE10;
            (*l_314) = (l_316 && (p_47 && ((p_47 != (l_317 & (*l_314))) || 0x23FE)));
        }
        else
        { /* block id: 164 */
            int32_t *l_320 = &l_319.f5;
            int32_t **l_321 = &l_320;
            float l_323 = 0xA.886E6Cp+43;
            float *l_322 = &l_323;
            l_318 = l_318;
            (*l_321) = l_320;
            (*l_322) = __builtin_popcount(l_317);
        }
        return p_46;
    }
    else
    { /* block id: 170 */
        return p_47;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_48(int32_t  p_49, const uint32_t  p_50)
{ /* block id: 132 */
    union U1 l_271 = {4294967295U};
    int32_t l_275 = 0x6DC1AFD6;
    int32_t *l_274 = &l_275;
    int32_t **l_273 = &l_274;
    int32_t ***l_272 = &l_273;
    float l_278 = 0x1.C4ECCFp+65;
    float *l_277 = &l_278;
    float **l_276 = &l_277;
    struct S0 l_300 = {0xF7A6630A,0xC780974C,0,0U,0xAC92,0x1E62006A};
    union U1 l_312 = {0xF7BF0A0A};
    (*l_272) = func_107(l_271, ((((void*)0 == &l_271) > (l_272 == &l_273)) ^ ((l_276 == &l_277) && (***l_272))), (((((int32_t)((***l_272) & 0x0624) - (int32_t)(*l_274)) > 0x7333C25E) <= 0xE350B082) ^ p_49), p_49);
    /* statement id: 133 */
    assert (l_273 == 0);
    if (l_271.f0)
        goto lbl_311;
lbl_311:
    if (((uint16_t)((0xCA6D92C2 && p_50) == (((*l_274) ^ ((((!0x8243B38C) > (((void*)0 == &l_271) < (*l_274))) >= (*l_274)) < p_50)) != p_49)) + (uint16_t)p_49))
    { /* block id: 134 */
        int32_t *l_284 = &l_275;
        int32_t **l_285 = &l_284;
        (*l_274) = __builtin_ctz((*l_274));
        (*l_285) = l_284;
    }
    else
    { /* block id: 137 */
        int32_t l_290 = (-6);
        struct S0 l_299 = {0xC2C39DB3,0x4FCFE38B,0xF829,65533U,65535U,0x5CC26826};
        float l_310 = (-0x9.1p+1);
    }
    return l_312;
    /* statement id: 158 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_51(int32_t  p_52)
{ /* block id: 129 */
    int32_t l_270 = 0x9F2B4189;
    l_270 = p_52;
    return l_270;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_55(float  p_56, float  p_57, union U1  p_58)
{ /* block id: 37 */
    int32_t l_79 = (-1);
    struct S0 l_94 = {0U,4294967295U,0,65535U,0xDB7B,4};
    struct S0 *l_219 = &l_94;
    struct S0 * const *l_218 = &l_219;
    union U1 l_228 = {0x2024EE24};
    union U1 *l_227 = &l_228;
    union U1 **l_226 = &l_227;
    int32_t *l_261 = (void*)0;
    int32_t *l_262 = &l_94.f5;
    if ((1U ^ ((~((int16_t)(((int16_t)(-(uint16_t)((uint16_t)65535U - (uint16_t)(65534U & ((uint16_t)(func_70(((((int32_t)(((uint16_t)l_79 - (uint16_t)(((int16_t)(((uint16_t)(__builtin_ffs(l_79) != ((0xEB13 & func_84((-(int16_t)(0xEA21F9F6 > (((int16_t)(p_58.f0 >= p_58.f0) - (int16_t)p_58.f0) && l_79))), l_79, l_79, l_79, p_56)) && l_79)) >> (uint16_t)6) ^ 4294967294U) << (int16_t)l_79) ^ 4294967287U)) || l_79) - (int32_t)(-1)) != l_79) <= l_79), p_58, l_94, l_94) != 0x0F79) + (uint16_t)0x3985)))) % (int16_t)0xE702) <= p_58.f0) >> (int16_t)15)) ^ 1U)))
    { /* block id: 42 */
        int32_t *l_97 = &l_79;
        int32_t **l_96 = &l_97;
        union U1 *l_114 = (void*)0;
        struct S0 l_193 = {1U,0xF203FFEE,0x2BCD,0U,0xDADC,0xCC9C5E52};
        float ** const l_202 = (void*)0;
        uint32_t l_203 = 0U;
lbl_183:
        (*l_96) = &l_79;
lbl_173:
        if (((uint16_t)9U << (uint16_t)12))
        { /* block id: 44 */
            float l_117 = 0x7.8p+1;
            const union U1 l_143 = {0x2D299328};
            const union U1 * const l_142 = &l_143;
            union U1 **l_169 = (void*)0;
            union U1 **l_170 = &l_114;
            (*l_170) = func_100(((uint16_t)0x5890 - (uint16_t)p_58.f0), func_107(p_58, (((int32_t)p_58.f0 - (int32_t)(&p_58 != l_114)) < (((*l_97) == 65532U) < ((uint16_t)__builtin_bswap32(l_94.f3) >> (uint16_t)6))), l_94.f2, p_58.f0), l_142, (*l_96));
        }
        else
        { /* block id: 67 */
            const int32_t ***l_172 = (void*)0;
            const int32_t ****l_171 = &l_172;
            (*l_171) = &l_96;
            /* statement id: 68 */
            assert (l_172 == &l_96);
            if (l_94.f2)
                goto lbl_173;
            return p_58.f0;
        }
        if (__builtin_ctzll((func_84((*l_97), ((float)((l_79 == 0xC.445A64p-74) >= (func_84(l_94.f1, (!(__builtin_ia32_crc32qi((((uint32_t)((*l_96) != (*l_96)) + (uint32_t)(l_97 == l_97)) >= (65530U < l_79)), (*l_97)) < 0x1.6p+1)), p_58.f0, p_58.f0, p_57) < 0x1.BE705Bp-40)) - (float)(*l_97)), (*l_97), l_94.f0, (*l_97)) < p_58.f0)))
        { /* block id: 72 */
            float l_189 = 0x0.6p-1;
            struct S0 l_194 = {0xCAFA75C3,4294967290U,0x86D6,65532U,0x1BF8,6};
            int32_t *l_199 = &l_94.f5;
            for (p_58.f0 = (-17); (p_58.f0 < 12); p_58.f0 += 3)
            { /* block id: 75 */
                int32_t l_195 = 0x6B43409B;
                int32_t **l_196 = &l_97;
                const int32_t ***l_197 = (void*)0;
                int32_t ***l_198 = &l_196;
                if (p_58.f0)
                    break;
                for (l_94.f4 = 0; (l_94.f4 < 22); l_94.f4 += 7)
                { /* block id: 79 */
                    const int32_t l_188 = 0x64C4BAC2;
                    union U1 l_192 = {4294967295U};
                    if (l_79)
                        goto lbl_173;
                    if (l_94.f2)
                        goto lbl_183;
                    l_195 = ((float)((float)(0x8.E23DBEp-26 != (((l_188 < (l_189 == l_188)) >= ((float)((func_70(l_188, l_192, l_193, l_194) == (-0x1.Fp-1)) > l_94.f0) - (float)0x0.8p-1)) <= 0x1.Fp-1)) - (float)(-0x10.Ep-1)) - (float)l_195);
                }
                (*l_198) = l_196;
                if (p_58.f0)
                    continue;
            }
            l_199 = (*l_96);
            /* statement id: 87 */
            assert (l_199 == &l_79);
        }
        else
        { /* block id: 88 */
            return l_94.f5;
        }
        if (func_84(((uint16_t)(((void*)0 == l_202) ^ p_58.f0) >> (uint16_t)8), l_203, (p_58.f0 ^ (*l_97)), (3U && (*l_97)), ((float)((float)(((!((float)((float)p_56 + (float)0x3.AC53F8p+72) - (float)l_94.f4)) <= p_57) <= p_58.f0) + (float)(**l_96)) + (float)0x1.4p-1)))
        { /* block id: 91 */
            int32_t * const l_213 = (void*)0;
            int32_t **l_214 = &l_97;
            union U1 **l_215 = (void*)0;
            (*l_214) = l_213;
            /* statement id: 92 */
            assert (l_97 == 0);
            l_114 = &p_58;
            /* statement id: 93 */
            assert (l_114 == &p_58);
        }
        else
        { /* block id: 94 */
            int32_t **l_220 = (void*)0;
            int32_t l_251 = (-1);
            (*l_96) = (void*)0;
            /* statement id: 95 */
            assert (l_97 == 0);
            for (p_58.f0 = (-7); (p_58.f0 > 32); p_58.f0++)
            { /* block id: 98 */
                float l_243 = (-0x1.Ep+1);
                int32_t l_244 = 1;
                (*l_96) = (void*)0;
                if ((l_218 == (void*)0))
                { /* block id: 100 */
                    union U1 **l_223 = &l_114;
                    int32_t *l_229 = &l_193.f5;
                    l_220 = l_220;
                    for (l_203 = 20; (l_203 >= 42); ++l_203)
                    { /* block id: 104 */
                        union U1 ***l_224 = (void*)0;
                        union U1 * const **l_225 = (void*)0;
                        const int32_t *l_230 = &l_94.f5;
                        int32_t **l_231 = &l_229;
                        l_226 = l_223;
                        /* statement id: 105 */
                        assert (l_226 == &l_114);
                        l_229 = (*l_96);
                        /* statement id: 106 */
                        assert (l_229 == 0);
                        (*l_231) = l_230;
                        /* statement id: 107 */
                        assert (l_229 == &l_94.f5);
                    }
                    /* facts after for loop */
                    assert (l_229 == &l_94.f5 || l_229 == &l_193.f5);
                    (*l_229) = (*l_229);
                }
                else
                { /* block id: 110 */
                    int32_t ***l_232 = &l_96;
                    p_56 = 0xC.5A9904p+94;
                    if (p_58.f0)
                        continue;
                    if (((l_232 != &l_220) != (((int16_t)(((uint16_t)((uint32_t)p_58.f0 + (uint32_t)((p_58.f0 & p_58.f0) >= p_58.f0)) >> (uint16_t)(p_58.f0 | ((int32_t)p_58.f0 % (int32_t)__builtin_clz(((int16_t)l_244 - (int16_t)p_58.f0))))) ^ l_244) >> (int16_t)l_94.f5) > p_58.f0)))
                    { /* block id: 113 */
                        int32_t l_246 = 0x80E76C45;
                        l_94.f5 = ((~__builtin_popcountl(l_94.f2)) >= l_246);
                    }
                    else
                    { /* block id: 115 */
                        (**l_232) = (**l_232);
                    }
                }
            }
            /* facts after for loop */
            assert (l_226 == &l_114 || l_226 == &l_227);
            l_251 = ((int16_t)func_70(p_58.f0, (*l_227), (*l_219), l_193) << (int16_t)func_84(p_58.f0, l_94.f0, p_58.f0, ((uint32_t)0x99ECA850 % (uint32_t)p_58.f0), p_56));
        }
        /* facts after branching */
        assert (l_97 == 0);
        assert (l_114 == 0 || l_114 == &p_58);
        assert (l_226 == &l_114 || l_226 == &l_227);
    }
    else
    { /* block id: 122 */
        int32_t *l_252 = &l_94.f5;
        int32_t **l_253 = &l_252;
        struct S0 *l_254 = &l_94;
        struct S0 **l_255 = &l_219;
        (*l_253) = l_252;
        (*l_253) = (*l_253);
        (*l_255) = l_254;
    }
    /* facts after branching */
    //assert (l_226 == dangling || l_226 == &l_227);
    (*l_262) = ((__builtin_ffsl(l_94.f5) | (p_58.f0 == l_94.f0)) ^ ((int32_t)(l_94.f0 | (4U > func_70(((uint16_t)(~(p_58.f0 | p_58.f0)) >> (uint16_t)15), p_58, (**l_218), (**l_218)))) % (int32_t)p_58.f0));
    return p_58.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_70(uint16_t  p_71, union U1  p_72, struct S0  p_73, struct S0  p_74)
{ /* block id: 40 */
    const int32_t l_95 = 0x6980504C;
    return l_95;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_84(uint32_t  p_85, float  p_86, uint32_t  p_87, int16_t  p_88, float  p_89)
{ /* block id: 38 */
    int32_t l_93 = 0xC83BDEEF;
    return l_93;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1 * func_100(int32_t  p_101, int32_t ** p_102, const union U1 * const  p_103, int32_t * p_104)
{ /* block id: 51 */
    int32_t l_147 = 0x5AADBCCD;
    int32_t *l_146 = &l_147;
    struct S0 l_156 = {4294967295U,0x1B9A2A75,-10,0x8011,0x228B,-1};
    float **l_167 = (void*)0;
    union U1 *l_168 = (void*)0;
    for (p_101 = 0; (p_101 >= 19); ++p_101)
    { /* block id: 54 */
        uint16_t l_150 = 0xBA81;
        float l_158 = 0xB.051206p+10;
        float *l_157 = &l_158;
        l_146 = l_146;
        (*l_157) = ((float)l_150 + (float)((float)((float)0x0.BFE3AEp-58 + (float)(((((-0x1.8p-1) <= (0x0.9A0614p+74 > (((!func_70(p_101, (*p_103), l_156, l_156)) < p_101) <= (-0x1.Fp+1)))) < (*l_146)) == (-0x6.Ap-1)) < 0xA.A515F4p-37)) + (float)l_150));
        for (l_150 = 0; (l_150 >= 11); l_150 += 5)
        { /* block id: 59 */
            int32_t **l_161 = (void*)0;
            int32_t **l_162 = &l_146;
            (*l_162) = &p_101;
            /* statement id: 60 */
            assert (l_146 == &p_101);
            (*l_157) = (((**l_162) != ((float)(**l_162) - (float)(-0x1.Ap-1))) < ((float)p_101 - (float)p_101));
        }
    }
    /* facts after for loop */
    assert (l_146 == &p_101 || l_146 == &l_147);
    l_167 = l_167;
    return l_168;
    /* statement id: 65 */
    //assert (func_100_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_107(union U1  p_108, const int32_t  p_109, uint32_t  p_110, int16_t  p_111)
{ /* block id: 45 */
    const int32_t l_119 = 0;
    const int32_t *l_118 = &l_119;
    const struct S0 l_121 = {4294967286U,2U,0x186D,65528U,0x25B9,0x7DCD999C};
    const struct S0 *l_120 = &l_121;
    struct S0 l_124 = {0xA6BD2E77,4294967289U,0xA852,0x6FDD,0U,0x3DE64C94};
    struct S0 *l_123 = &l_124;
    struct S0 **l_122 = &l_123;
    int32_t *l_131 = &l_124.f5;
    int32_t **l_135 = &l_131;
    int32_t **l_136 = &l_131;
    int32_t **l_137 = &l_131;
    int32_t **l_138 = &l_131;
    int32_t **l_139 = &l_131;
    int32_t **l_140 = &l_131;
    int32_t **l_141 = (void*)0;
    l_118 = &p_109;
    /* statement id: 46 */
    assert (l_118 == &p_109);
    (*l_122) = l_120;
    /* statement id: 47 */
    assert (l_123 == &l_121);
    (*l_131) = ((((&l_120 == &l_123) <= ((int16_t)(((2 != (7U && ((int16_t)(-1) % (int16_t)((uint16_t)(*l_118) % (uint16_t)(*l_118))))) ^ p_108.f0) & p_109) - (int16_t)p_110)) >= p_111) == (*l_118));
    (*l_131) = ((int32_t)(0 >= func_84(((&l_119 != &p_109) | ((*l_118) ^ (*l_118))), __builtin_bswap64((65528U || 0x2822)), ((+(&l_123 == (void*)0)) == 0xD3C6BE40), p_111, (*l_118))) + (int32_t)1);
    return l_141;
    /* statement id: 50 */
    //assert (func_107_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 114
   depth: 1, occurrence: 8
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 100

XXX times a variable address is taken: 103
XXX times a pointer is dereferenced on RHS: 67
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 18
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 56
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 180

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 116
   level: 2, occurrence: 38
   level: 3, occurrence: 6
XXX number of pointers point to pointers: 56
XXX number of pointers point to scalars: 27
XXX number of pointers point to structs: 8
XXX percent of pointers has null in alias set: 27
XXX average alias set size: 1.18

XXX times a non-volatile is read: 481
XXX times a non-volatile is write: 149
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 4

XXX stmts: 81
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 15
   depth: 2, occurrence: 18
   depth: 3, occurrence: 6
   depth: 4, occurrence: 9
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 20
XXX percentage an existing variable is used: 80
********************* end of statistics **********************/

