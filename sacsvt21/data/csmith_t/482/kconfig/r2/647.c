/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1440055158
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 9;
   unsigned f1 : 26;
   signed f2 : 20;
   const signed f3 : 16;
   unsigned f4 : 31;
   unsigned f5 : 26;
};
#pragma pack(pop)

struct S1 {
   uint16_t  f0;
   unsigned f1 : 9;
   const signed f2 : 5;
   int32_t  f3;
   int32_t  f4;
   uint16_t  f5;
};

struct S2 {
   const signed f0 : 18;
   float  f1;
   int32_t  f2;
   uint32_t  f3;
   const uint32_t  f4;
   int32_t  f5;
   unsigned f6 : 2;
   struct S0  f7;
   const int32_t  f8;
   int32_t  f9;
};

union U3 {
   signed f0 : 8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U3  func_35(void);
static float  func_37(union U3  p_38, float  p_39, const int32_t  p_40, struct S2  p_41, struct S2  p_42);
static union U3  func_43(struct S0  p_44, int32_t  p_45, float  p_46, uint32_t  p_47);
inline static struct S0  func_48(float  p_49, float  p_50);
static float  func_51(float  p_52, struct S2  p_53, const struct S2  p_54, int32_t  p_55, int16_t  p_56);
inline static struct S2  func_58(float  p_59, int16_t  p_60, uint16_t  p_61);
static int32_t  func_63(union U3  p_64, struct S1  p_65);
static union U3  func_66(struct S1  p_67, uint32_t  p_68, int32_t  p_69, uint32_t  p_70);
static struct S1  func_71(int32_t  p_72);
inline static int32_t  func_79(uint32_t  p_80, int32_t * p_81, int32_t * p_82, struct S1  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U3  func_35(void)
{ /* block id: 36 */
    int16_t l_36 = 2;
    struct S2 l_57 = {-381,0x3.80E44Ep-86,-2,1U,2U,0x17E40D8E,1,{-10,5976,464,122,36999,7750},0x8D46D8DA,3};
    uint32_t l_244 = 4294967289U;
    int16_t l_245 = (-1);
    float l_246 = 0x0.54238Fp+31;
    float l_247 = 0x1.194119p+23;
    struct S1 l_260 = {3U,7,-1,0x4BD559E1,-2,65535U};
    struct S2 l_516 = {-18,0xC.90A701p+54,0x29363A9B,4294967286U,0x20B9FA81,0x6CA8B886,1,{-10,2413,172,27,14245,4080},8,0xFC5A0136};
    float *l_534 = &l_516.f1;
    union U3 l_535 = {0x051EA069};
    (*l_534) = ((((((l_36 <= func_37(func_43(func_48(func_51(l_36, l_57, func_58(l_57.f7.f2, ((2 <= 2U) >= (-(int32_t)func_63(func_66(func_71(l_57.f4), (l_244 || l_245), l_57.f7.f4, l_57.f6), l_260))), l_57.f2), l_57.f8, l_260.f0), l_57.f2), l_57.f7.f0, l_260.f1, l_260.f0), l_260.f0, l_57.f7.f3, l_516, l_57)) < l_260.f1) == l_260.f3) == l_516.f3) <= l_244) != l_57.f7.f1);
    return l_535;
    /* statement id: 303 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_37(union U3  p_38, float  p_39, const int32_t  p_40, struct S2  p_41, struct S2  p_42)
{ /* block id: 295 */
    const uint16_t l_521 = 0x194C;
    int32_t l_523 = 0x0DDE0092;
    int32_t *l_522 = &l_523;
    struct S1 l_524 = {65534U,8,-1,0x7A3259C2,0xEC99B4E2,7U};
    struct S1 *l_530 = &l_524;
    struct S1 **l_529 = &l_530;
    struct S1 ***l_528 = &l_529;
    for (p_42.f2 = 0; (p_42.f2 != 26); p_42.f2++)
    { /* block id: 298 */
        const uint16_t l_527 = 0xE785;
        struct S1 ***l_531 = &l_529;
        float l_533 = 0xB.7A45DEp-63;
        float *l_532 = &l_533;
        (*l_532) = ((float)(l_521 == ((func_79(p_40, l_522, &l_523, l_524) > ((float)(l_527 == (l_528 == l_531)) + (float)l_527)) >= p_42.f4)) - (float)l_524.f0);
    }
    return p_42.f9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U3  func_43(struct S0  p_44, int32_t  p_45, float  p_46, uint32_t  p_47)
{ /* block id: 278 */
    int32_t l_498 = (-1);
    int32_t *l_497 = &l_498;
    struct S1 l_499 = {5U,17,0,0x77BB3A24,-1,0x610D};
    uint16_t l_500 = 0x3930;
    union U3 l_501 = {0x1D3D2D05};
    struct S1 l_507 = {0xFB4D,9,2,7,1,1U};
lbl_515:
    (*l_497) = (((int16_t)((((((int16_t)func_79(p_44.f4, l_497, &p_45, l_499) << (int16_t)(l_500 < func_63(l_501, l_499))) || (*l_497)) & l_501.f0) ^ 0x79D9A955) < l_500) >> (int16_t)p_45) ^ p_44.f2);
    for (l_498 = 0; (l_498 == 15); l_498 += 2)
    { /* block id: 282 */
        uint16_t l_504 = 0x8B5C;
        const int32_t l_505 = 0;
        union U3 l_506 = {0x5749F27D};
        float *l_508 = (void*)0;
        float l_510 = 0xB.D72819p-60;
        float *l_509 = &l_510;
        (*l_509) = ((l_504 != (((p_47 <= p_47) <= l_505) > ((*l_497) != func_63(l_506, l_507)))) == l_505);
    }
    for (l_507.f5 = 0; (l_507.f5 <= 58); l_507.f5++)
    { /* block id: 287 */
        for (l_498 = 0; (l_498 >= (-10)); l_498 -= 1)
        { /* block id: 290 */
            if (p_47)
                goto lbl_515;
        }
    }
    return l_501;
    /* statement id: 294 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_48(float  p_49, float  p_50)
{ /* block id: 267 */
    int32_t l_478 = (-9);
    union U3 l_488 = {0x804F274E};
    union U3 *l_487 = &l_488;
    union U3 **l_486 = &l_487;
    union U3 ***l_485 = &l_486;
    union U3 ****l_484 = &l_485;
    union U3 *****l_489 = &l_484;
    int32_t *l_491 = &l_478;
    int32_t **l_490 = &l_491;
    struct S0 l_492 = {-2,7664,380,229,39238,7549};
    for (l_478 = 0; (l_478 != (-7)); l_478--)
    { /* block id: 270 */
        int32_t *l_481 = &l_478;
        int32_t **l_482 = &l_481;
        struct S0 l_483 = {10,6885,-104,58,35942,2282};
        (*l_482) = l_481;
        if ((*l_481))
            continue;
        return l_483;
    }
    (*l_489) = l_484;
    (*l_490) = &l_478;
    return l_492;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_51(float  p_52, struct S2  p_53, const struct S2  p_54, int32_t  p_55, int16_t  p_56)
{ /* block id: 264 */
    struct S2 l_476 = {15,0x1.4p-1,0xADC625F9,0x78336A11,1U,0,0,{19,6713,916,163,20379,2170},0,0x16301E9A};
    struct S2 *l_475 = &l_476;
    struct S2 **l_474 = &l_475;
    struct S2 ***l_477 = &l_474;
    (*l_477) = l_474;
    return l_476.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S2  func_58(float  p_59, int16_t  p_60, uint16_t  p_61)
{ /* block id: 255 */
    struct S2 l_463 = {188,0xA.23BE1Cp+21,0x6792CEC7,0x47FC0E88,0x5051286D,0x8EE1040B,0,{15,7091,-81,-67,42281,3633},0x5822A963,0xC159B5B0};
    struct S2 *l_462 = &l_463;
    struct S2 **l_464 = (void*)0;
    const struct S2 *l_466 = &l_463;
    const struct S2 **l_465 = &l_466;
    float **l_472 = (void*)0;
    struct S2 l_473 = {308,0x0.9p-1,-2,0xA41F3AFE,0x64774B79,-3,1,{-18,4980,543,166,15505,2800},0xFEEABDCE,3};
    (*l_465) = l_462;
    for (p_60 = (-30); (p_60 <= (-18)); p_60++)
    { /* block id: 259 */
        struct S0 **l_470 = (void*)0;
        struct S0 *** const l_469 = &l_470;
        struct S0 ***l_471 = &l_470;
        l_471 = l_469;
    }
    l_472 = l_472;
    return l_473;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_63(union U3  p_64, struct S1  p_65)
{ /* block id: 142 */
    struct S1 **l_262 = (void*)0;
    struct S1 ***l_261 = &l_262;
    int32_t l_263 = 0xEC3E4385;
    struct S1 l_267 = {65535U,20,-0,0xF99CA2A9,0x56A48319,0xEF01};
    struct S1 *l_266 = &l_267;
    int32_t l_285 = 0x3B8899DC;
    int32_t *l_305 = &l_263;
    int32_t **l_304 = &l_305;
    const int32_t *l_378 = &l_263;
    struct S0 l_383 = {-10,5904,-350,50,7679,5079};
    struct S0 *l_382 = &l_383;
    int16_t l_392 = (-9);
    struct S1 l_415 = {0xB5E4,5,-0,0xEAA28D7F,1,1U};
    int32_t * const *l_435 = &l_305;
    uint16_t l_450 = 0x14CA;
    float l_455 = (-0x8.4p+1);
    uint32_t l_461 = 0U;
    if (((void*)0 == l_261))
    { /* block id: 143 */
        int32_t *l_264 = (void*)0;
        int32_t *l_265 = &l_263;
        union U3 *l_272 = (void*)0;
        struct S2 l_287 = {401,0x4.A9E41Cp-93,1,1U,0x8629F829,0x7E045539,0,{-18,7525,-713,-87,29114,1284},0x47EB15AC,0xE3CE139A};
        struct S2 *l_286 = &l_287;
        int32_t l_328 = 0xAF094154;
        struct S1 **l_348 = (void*)0;
        struct S0 *l_358 = &l_287.f7;
lbl_293:
        (*l_265) = l_263;
        l_266 = &p_65;
        /* statement id: 145 */
        assert (l_266 == &p_65);
        for (l_267.f0 = 0; (l_267.f0 >= 4); l_267.f0++)
        { /* block id: 148 */
            union U3 l_271 = {0xDAB2478D};
            union U3 *l_270 = &l_271;
            struct S1 * const *l_277 = &l_266;
            struct S1 * const * const *l_276 = &l_277;
            struct S1 * const * const **l_275 = &l_276;
            int32_t *l_278 = &l_263;
            int16_t l_376 = 7;
            int32_t **l_379 = &l_265;
            l_271.f0 = (0x1.Cp+1 < (l_270 == l_272));
            if ((~((~(((l_275 != &l_261) ^ __builtin_ffsl(((void*)0 != l_278))) > (((2U != (0x99C51B16 > (*l_265))) >= p_65.f1) || p_65.f0))) ^ (*l_265))))
            { /* block id: 150 */
                union U3 **l_283 = &l_270;
                int32_t **l_284 = &l_278;
                struct S2 *l_289 = (void*)0;
                float l_314 = 0x8.612B3Ap+96;
                p_64.f0 = ((uint16_t)((int32_t)p_65.f2 - (int32_t)p_65.f5) + (uint16_t)(-2));
                (*l_283) = &p_64;
                /* statement id: 152 */
                assert (l_270 == &p_64);
                (*l_284) = l_278;
                if (((*l_265) <= ((p_65.f1 ^ (*l_278)) == ((*l_265) & __builtin_ffsll(l_285)))))
                { /* block id: 154 */
                    struct S2 **l_288 = &l_286;
                    (*l_288) = l_286;
                    (*l_288) = l_289;
                    /* statement id: 156 */
                    assert (l_286 == 0);
                    for (l_287.f2 = (-1); (l_287.f2 <= 28); l_287.f2 += 2)
                    { /* block id: 159 */
                        int16_t l_292 = 3;
                        (*l_278) = ((l_292 <= p_65.f1) >= 1U);
                    }
                    (*l_284) = l_264;
                    /* statement id: 162 */
                    assert (l_278 == 0);
                }
                else
                { /* block id: 163 */
                    float l_296 = 0x9.F4B22Bp+75;
                    int32_t **l_303 = &l_264;
                    if (l_285)
                        goto lbl_293;
                    (*l_265) = ((uint32_t)0U + (uint32_t)((**l_284) ^ (((!((int16_t)(*l_278) >> (int16_t)((int32_t)(+((p_65.f3 == (((p_64.f0 >= (l_303 != l_304)) | ((int16_t)((uint32_t)(**l_284) - (uint32_t)0xE78B5091) - (int16_t)(-1))) < 1)) ^ 0U)) + (int32_t)(*l_305)))) ^ (**l_304)) > 0U)));
                    if (((((uint16_t)__builtin_clz((*l_305)) << (uint16_t)p_65.f5) & ((p_65.f1 <= p_65.f2) <= ((((int32_t)(&p_65 == (void*)0) + (int32_t)(((**l_284) < p_65.f3) | (-4))) > p_65.f5) != (**l_304)))) & p_65.f1))
                    { /* block id: 166 */
                        float *l_315 = (void*)0;
                        float *l_316 = &l_287.f1;
                        (*l_305) = p_65.f2;
                        (*l_265) = p_64.f0;
                        if (p_65.f4)
                            continue;
                        (*l_316) = p_65.f5;
                    }
                    else
                    { /* block id: 171 */
                        if (p_65.f5)
                            break;
                        p_64.f0 = 0xAE3D4CD0;
                        if (p_64.f0)
                            continue;
                        (*l_305) = __builtin_ctzll((((**l_304) & ((int16_t)(((*l_284) == (*l_304)) <= (((((uint16_t)(*l_265) << (uint16_t)13) == 0x0637) && 1U) <= ((*l_278) > ((**l_304) & (-2))))) << (int16_t)13)) <= p_65.f3));
                    }
                }
                /* facts after branching */
                assert (l_278 == &l_263 || l_278 == 0);
            }
            else
            { /* block id: 178 */
                struct S2 *l_323 = &l_287;
                const int32_t l_340 = (-1);
                struct S1 ****l_342 = (void*)0;
                float l_365 = (-0x3.2p-1);
                float *l_377 = &l_287.f1;
                for (p_65.f0 = 0; (p_65.f0 <= 4); p_65.f0 += 1)
                { /* block id: 181 */
                    return p_64.f0;
                }
                if ((l_323 == (void*)0))
                { /* block id: 184 */
                    (*l_305) = (((uint16_t)(p_65.f3 <= 4294967290U) - (uint16_t)((uint32_t)l_328 - (uint32_t)0x27B2AF5F)) <= (*l_305));
                }
                else
                { /* block id: 186 */
                    float l_337 = 0x1.Ap+1;
                    struct S1 *l_341 = &l_267;
                    struct S1 *****l_343 = &l_342;
                    int32_t *l_349 = &l_287.f2;
                    if (((((0x7FE8 >= __builtin_parity((((uint16_t)(*l_278) % (uint16_t)((((int16_t)(((uint16_t)65530U << (uint16_t)p_65.f1) == ((((int16_t)(((p_65.f4 <= 0U) <= (p_64.f0 < p_65.f0)) || p_65.f3) % (int16_t)p_65.f3) <= (-8)) || p_65.f4)) - (int16_t)p_65.f3) || (*l_265)) | 0xC527838C)) != 0U))) || 0) < p_65.f1) <= (*l_278)))
                    { /* block id: 187 */
                        float *l_338 = (void*)0;
                        float *l_339 = &l_337;
                        (*l_339) = (*l_278);
                        if ((*l_305))
                            continue;
                    }
                    else
                    { /* block id: 190 */
                        (*l_278) = l_340;
                        if (p_65.f0)
                            goto lbl_293;
                        l_341 = l_341;
                    }
                    (*l_304) = l_278;
                    /* statement id: 195 */
                    assert (l_305 == &l_263);
                    (*l_343) = l_342;
                    if (p_65.f2)
                    { /* block id: 197 */
                        union U3 **l_344 = &l_272;
                        struct S0 *l_345 = &l_287.f7;
                        const struct S0 *l_347 = (void*)0;
                        const struct S0 **l_346 = &l_347;
                        (*l_344) = &p_64;
                        /* statement id: 198 */
                        assert (l_272 == &p_64);
                        (*l_346) = l_345;
                        /* statement id: 199 */
                        assert (l_347 == &l_287.f7);
                        (*l_261) = l_348;
                    }
                    else
                    { /* block id: 201 */
                        int16_t l_366 = 0;
                        int32_t *l_367 = (void*)0;
                        (*l_304) = l_349;
                        /* statement id: 202 */
                        assert (l_305 == &l_287.f2);
                        if ((*l_349))
                            continue;
                        (*l_349) = ((&p_65 != (void*)0) ^ (((uint32_t)(((int32_t)(*l_265) + (int32_t)(*l_349)) || (p_65.f1 | __builtin_ffsl(p_65.f5))) + (uint32_t)0x82EB3382) > __builtin_ctzl(((*l_278) != 0x24E7))));
                        (**l_304) = ((uint16_t)((l_358 == (void*)0) | (8 && ((uint32_t)p_65.f5 + (uint32_t)p_65.f1))) - (uint16_t)p_65.f2);
                    }
                    /* facts after branching */
                    assert (l_305 == &l_287.f2 || l_305 == &l_263);
                }
                for (l_263 = (-3); (l_263 < (-29)); l_263 -= 2)
                { /* block id: 210 */
                    return l_340;
                }
                (*l_377) = ((float)((float)p_65.f1 + (float)(((float)p_65.f0 + (float)(0x0.4p-1 < l_376)) < l_340)) - (float)0x9.7p-1);
            }
            /* facts after branching */
            assert (l_270 == &l_271 || l_270 == &p_64);
            assert (l_278 == &l_263 || l_278 == 0);
            (*l_379) = l_378;
        }
    }
    else
    { /* block id: 217 */
        struct S2 *l_380 = (void*)0;
        struct S2 **l_381 = &l_380;
        (*l_381) = l_380;
    }
    /* facts after branching */
    assert (l_266 == &l_267 || l_266 == &p_65);
    //assert (l_305 == dangling || l_305 == &l_263);
    if ((0x4421 <= (((l_382 == &l_383) != (p_65.f2 >= ((uint16_t)((uint16_t)(*l_378) + (uint16_t)p_65.f5) + (uint16_t)((uint16_t)(&l_383 == &l_383) << (uint16_t)7)))) & ((int16_t)(__builtin_clzl(l_392) < (*l_378)) >> (int16_t)14))))
    { /* block id: 220 */
        float l_396 = 0x8.0064E3p+56;
        float *l_395 = &l_396;
        int32_t l_401 = 0x9BE3B201;
        int32_t *l_408 = &l_401;
        const int16_t l_420 = 0xD75C;
        union U3 * const *l_446 = (void*)0;
        union U3 * const **l_445 = &l_446;
        union U3 * const ***l_444 = &l_445;
        int32_t *l_453 = (void*)0;
        (*l_395) = ((float)p_65.f0 - (float)p_65.f1);
        if (p_65.f2)
            goto lbl_409;
lbl_409:
        (*l_408) = ((((int16_t)(((uint32_t)l_401 % (uint32_t)((uint32_t)(l_401 >= (p_65.f0 & ((uint16_t)((__builtin_ffsll(p_64.f0) ^ ((int16_t)p_65.f5 << (int16_t)((((void*)0 != &l_401) > 0) & l_401))) != p_65.f3) + (uint16_t)0U))) + (uint32_t)l_401)) || 0x90DF19C7) << (int16_t)3) != 4294967293U) >= l_401);
        (*l_304) = (void*)0;
        /* statement id: 224 */
        assert (l_305 == 0);
        for (l_267.f4 = 0; (l_267.f4 >= 11); l_267.f4 += 4)
        { /* block id: 227 */
            uint16_t l_414 = 0xF454;
            struct S1 l_454 = {0x862A,3,0,0x5395134A,-9,0xD7E8};
            int16_t l_456 = 0x3928;
            p_64.f0 = ((l_414 && p_65.f0) ^ (((uint16_t)7U << (uint16_t)0) < p_65.f4));
            for (l_401 = (-10); (l_401 == (-16)); l_401 -= 4)
            { /* block id: 231 */
                union U3 *l_424 = (void*)0;
                union U3 **l_423 = &l_424;
                int32_t l_452 = 0;
                struct S1 l_457 = {0x4C39,16,1,0x03BE6789,0x11451A78,0xEB2C};
                const uint32_t l_458 = 0xB3AD1DF4;
                int32_t *l_459 = &l_452;
                if (p_65.f2)
                { /* block id: 232 */
                    int32_t l_436 = (-1);
                    union U3 * const ***l_447 = &l_445;
                    for (l_392 = 0; (l_392 <= 29); ++l_392)
                    { /* block id: 235 */
                        int32_t * const *l_432 = &l_408;
                        int32_t ***l_433 = (void*)0;
                        int32_t * const **l_434 = (void*)0;
                        l_435 = l_432;
                        /* statement id: 236 */
                        assert (l_435 == &l_408);
                        if (l_436)
                            continue;
                    }
                    p_64.f0 = ((int16_t)((((uint16_t)(__builtin_clz(l_436) < l_436) >> (uint16_t)12) & (((int32_t)p_65.f3 % (int32_t)p_64.f0) & (-8))) & (-(uint16_t)65531U)) + (int16_t)(*l_408));
                    if (l_436)
                        break;
                    l_447 = l_444;
                }
                else
                { /* block id: 242 */
                    p_64.f0 = 6;
                    (*l_395) = ((float)(l_450 < ((+l_452) == p_65.f0)) + (float)p_65.f3);
                }
                if (l_452)
                    continue;
                p_64.f0 = ((p_65.f1 || (((void*)0 == &l_424) && (((((*l_408) && p_65.f5) >= p_64.f0) > l_454.f0) ^ 0x2999A3F5))) & l_452);
                (*l_459) = ((4294967295U == l_414) && ((p_65.f2 || __builtin_parityll(func_79(l_456, &l_452, &l_401, l_457))) != l_458));
            }
        }
        /* facts after for loop */
        assert (l_435 == &l_408 || l_435 == &l_305);
    }
    else
    { /* block id: 251 */
        int32_t *l_460 = (void*)0;
        (*l_304) = l_460;
        /* statement id: 252 */
        assert (l_305 == 0);
    }
    /* facts after branching */
    assert (l_305 == 0);
    //assert (l_435 == dangling || l_435 == &l_305);
    return l_461;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U3  func_66(struct S1  p_67, uint32_t  p_68, int32_t  p_69, uint32_t  p_70)
{ /* block id: 138 */
    struct S1 **l_251 = (void*)0;
    struct S1 ***l_250 = &l_251;
    int32_t l_252 = 1;
    int32_t *l_254 = (void*)0;
    union U3 *l_256 = (void*)0;
    union U3 **l_255 = &l_256;
    union U3 ***l_257 = (void*)0;
    union U3 ***l_258 = &l_255;
    union U3 l_259 = {0x64FF1D34};
    l_252 = ((p_67.f1 ^ (((uint16_t)((l_250 != &l_251) <= l_252) << (uint16_t)1) > 0U)) & ((+func_79(l_252, &p_69, &l_252, p_67)) & 1));
    (*l_258) = l_255;
    return l_259;
    /* statement id: 141 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_71(int32_t  p_72)
{ /* block id: 37 */
    int16_t l_73 = 0;
    int32_t l_86 = (-1);
    int32_t *l_85 = &l_86;
    struct S1 l_87 = {0x8D80,6,0,0xA8E06690,-1,0U};
    struct S1 *l_242 = (void*)0;
    struct S1 **l_241 = &l_242;
    struct S1 ***l_240 = &l_241;
    struct S1 ****l_243 = &l_240;
    if ((l_73 ^ l_73))
    { /* block id: 38 */
        int32_t l_77 = 0;
        int32_t *l_76 = &l_77;
        struct S1 *l_228 = &l_87;
        struct S1 **l_229 = &l_228;
        for (p_72 = 11; (p_72 <= (-19)); p_72 -= 3)
        { /* block id: 41 */
            int32_t **l_78 = &l_76;
            int32_t *l_84 = &l_77;
            float l_227 = 0x0.Fp+1;
            float *l_226 = &l_227;
            (*l_78) = l_76;
            (*l_85) = func_79((**l_78), l_84, l_85, l_87);
            (*l_226) = ((*l_85) > ((*l_76) <= 0x1.4p+1));
        }
        (*l_229) = l_228;
        (*l_85) = ((int16_t)p_72 >> (int16_t)(((int16_t)(p_72 | ((int32_t)0x1ADAEAB5 + (int32_t)p_72)) >> (int16_t)11) || p_72));
    }
    else
    { /* block id: 132 */
        uint32_t l_238 = 0x85D862F8;
        int32_t *l_239 = (void*)0;
        (*l_85) = ((((uint32_t)l_238 % (uint32_t)func_79((*l_85), &l_86, l_239, l_87)) & p_72) ^ p_72);
    }
    (*l_85) = p_72;
    (*l_243) = l_240;
    return l_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_79(uint32_t  p_80, int32_t * p_81, int32_t * p_82, struct S1  p_83)
{ /* block id: 43 */
    struct S1 *l_88 = (void*)0;
    struct S1 **l_89 = &l_88;
    const int32_t l_90 = 0x1D8DD584;
    int32_t l_109 = 0x9A04901E;
    int32_t *l_108 = &l_109;
    float l_160 = 0x2.43F700p-33;
    union U3 l_163 = {0xF8FB61F0};
    union U3 *l_162 = &l_163;
    (*l_89) = l_88;
    if (l_90)
    { /* block id: 45 */
        uint32_t l_101 = 1U;
        int32_t l_120 = 0x29669FAE;
        int32_t **l_123 = &l_108;
        struct S1 l_125 = {0xB3B0,4,-1,0x39DC62CB,0x5F0EDF42,65527U};
        struct S1 * const l_124 = &l_125;
        float l_146 = 0x1.1p-1;
        float *l_145 = &l_146;
        for (p_83.f0 = (-21); (p_83.f0 > 59); ++p_83.f0)
        { /* block id: 48 */
            float l_104 = (-0x1.Ep-1);
            const int32_t l_105 = 0x769F55D1;
            float *l_106 = &l_104;
            struct S1 **l_165 = &l_88;
            (*l_106) = (l_90 == (((float)(((float)(((((float)(((float)l_101 + (float)l_90) > (__builtin_bswap32(l_90) <= l_101)) + (float)((float)p_83.f0 + (float)(p_80 == p_83.f0))) < l_104) == l_105) > (-0x1.8p-1)) + (float)0xF.3785E6p-18) >= (-0x9.4p+1)) - (float)0x1.3p-1) == p_83.f5));
        }
        (*l_145) = ((float)(p_83.f0 == (**l_123)) - (float)((float)(p_83.f2 <= (((float)(*l_108) + (float)((((((float)(p_83.f5 != ((*l_89) == &l_125)) - (float)((p_80 == p_83.f1) <= (**l_123))) < 0x1.F4DB29p-32) >= (**l_123)) <= 0x1.170D4Cp-81) >= (*l_108))) > (-0x1.0p-1))) - (float)(*l_108)));
        p_82 = (*l_123);
        /* statement id: 101 */
        assert (p_82 == &l_109);
        (*l_123) = p_82;
    }
    else
    { /* block id: 103 */
        uint32_t l_192 = 0xED6AE4A7;
        return l_192;
    }
    /* facts after branching */
    assert (p_82 == &l_109);
    if (((*l_108) >= __builtin_bswap32((((int16_t)(*l_108) >> (int16_t)13) | ((uint16_t)p_83.f3 >> (uint16_t)14)))))
    { /* block id: 106 */
        struct S1 ***l_198 = &l_89;
        struct S1 ****l_197 = &l_198;
        int32_t l_202 = 0xCBF5BA50;
        (*l_197) = &l_89;
        if ((*l_108))
        { /* block id: 108 */
            int32_t **l_199 = &l_108;
            (*l_199) = (void*)0;
            /* statement id: 109 */
            assert (l_108 == 0);
            if (p_83.f3)
                goto lbl_203;
lbl_203:
            (*p_82) = ((uint16_t)(((*p_81) <= l_202) > p_83.f0) >> (uint16_t)p_83.f4);
            return (*p_81);
        }
        else
        { /* block id: 113 */
            uint32_t l_208 = 1U;
            (**l_197) = &l_88;
            for (l_202 = (-9); (l_202 >= 3); l_202++)
            { /* block id: 117 */
                float *l_219 = &l_160;
                (*l_219) = (((float)l_208 + (float)((void*)0 == &l_202)) >= ((float)((float)p_83.f0 + (float)((float)(+(((float)(*l_108) + (float)0xC.1E6F47p-23) > (+l_208))) + (float)(*l_108))) - (float)l_208));
                (*p_81) = ((l_202 || ((int16_t)p_83.f2 % (int16_t)p_83.f0)) < (l_208 >= ((*p_81) && (((int32_t)0x22E11841 + (int32_t)0x7E7D1A18) | 65535U))));
            }
        }
    }
    else
    { /* block id: 122 */
        float *l_224 = &l_160;
        (*l_224) = p_83.f5;
        (*p_82) = ((~p_83.f3) || (&l_108 == (void*)0));
    }
    return (*p_81);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_35();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 126
   depth: 1, occurrence: 10
   depth: 2, occurrence: 3
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 11
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 52
breakdown:
   indirect level: 0, occurrence: 17
   indirect level: 1, occurrence: 17
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 5
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 27
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 47
XXX times a single bitfield on LHS: 7
XXX times a single bitfield on RHS: 54

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 156
   depth: 2, occurrence: 20
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 5
   depth: 8, occurrence: 2
   depth: 9, occurrence: 4
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 132

XXX times a variable address is taken: 133
XXX times a pointer is dereferenced on RHS: 74
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 12
XXX times a pointer is dereferenced on LHS: 76
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 252

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 434
   level: 2, occurrence: 83
   level: 3, occurrence: 3
   level: 4, occurrence: 1
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 67
XXX number of pointers point to scalars: 40
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 28
XXX average alias set size: 1.22

XXX times a non-volatile is read: 539
XXX times a non-volatile is write: 193
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 4

XXX stmts: 135
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 30
   depth: 2, occurrence: 16
   depth: 3, occurrence: 14
   depth: 4, occurrence: 20
   depth: 5, occurrence: 23

XXX percentage a fresh-made variable is used: 25.3
XXX percentage an existing variable is used: 74.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

