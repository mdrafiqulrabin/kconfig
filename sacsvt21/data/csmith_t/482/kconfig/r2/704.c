/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2812667013
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 1;
   unsigned f1 : 20;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_32(void);
static uint32_t  func_37(int32_t  p_38, struct S0  p_39, int32_t  p_40);
inline static struct S0  func_41(uint16_t  p_42, uint32_t  p_43, int16_t  p_44, int32_t  p_45, int32_t  p_46);
inline static int16_t  func_47(int32_t  p_48, uint32_t  p_49);
inline static uint32_t  func_52(int32_t  p_53, int32_t  p_54, uint32_t  p_55, int32_t  p_56, struct S0  p_57);
inline static int16_t  func_62(uint32_t  p_63, uint16_t  p_64, int32_t  p_65, int16_t  p_66, int32_t  p_67);
static int32_t  func_68(int32_t  p_69, uint32_t  p_70, uint16_t  p_71, uint32_t  p_72);
inline static int32_t  func_82(uint32_t  p_83, int16_t  p_84, uint32_t  p_85, int16_t  p_86, uint32_t  p_87);
static int32_t  func_95(int16_t  p_96, int32_t  p_97, int32_t  p_98);
static int32_t  func_104(int16_t  p_105, struct S0  p_106, uint32_t  p_107, uint16_t  p_108, uint16_t  p_109);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_32(void)
{ /* block id: 36 */
    int16_t l_33 = 0;
    uint16_t l_34 = 0U;
    uint16_t l_50 = 65535U;
    uint32_t l_77 = 4294967295U;
    int32_t l_78 = 5;
    int32_t l_79 = 1;
    uint16_t l_217 = 0U;
    int32_t l_228 = 9;
    int32_t l_229 = 0;
    struct S0 l_230 = {0,25};
    int32_t l_373 = (-4);
    int32_t l_374 = 3;
    int32_t l_389 = 0x39418A6E;
    int16_t l_390 = 0x1C69;
    l_34 = l_33;
    l_230.f0 = ((uint32_t)((l_229 = __builtin_popcount(__builtin_ia32_crc32qi((l_373 |= func_37(l_34, func_41((((l_33 , l_34) > func_47(l_33, l_50)) > (func_52((((int16_t)((int16_t)func_62(l_50, l_34, func_68(((int32_t)((((l_79 ^= (l_78 = ((((l_77 = (((int16_t)(l_33 & l_34) << (int16_t)15) ^ l_33)) , l_77) < l_50) || 0xBBD2))) , l_79) < l_34) > l_50) - (int32_t)l_50), l_50, l_34, l_33), l_50, l_217) << (int16_t)l_217) >> (int16_t)l_34) | 65531U), l_33, l_228, l_229, l_230) & l_217)), l_230.f0, l_228, l_33, l_228), l_228)), l_374))) > l_228) + (uint32_t)0);
    l_390 |= (l_229 = ((uint32_t)l_33 % (uint32_t)(__builtin_ffsl(l_228) , ((uint16_t)func_104(l_217, l_230, l_229, (((int16_t)((uint16_t)l_77 * (uint16_t)((l_78 = (((int16_t)((int32_t)l_50 % (int32_t)((int32_t)(l_374 > 0xF764) - (int32_t)1)) >> (int16_t)l_79) == l_50)) != l_217)) * (int16_t)l_229) , l_217), l_389) << (uint16_t)l_33))));
    for (l_77 = 0; (l_77 == 7); l_77 += 8)
    { /* block id: 248 */
        struct S0 l_393 = {-0,267};
        return l_393;
    }
    return l_230;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_37(int32_t  p_38, struct S0  p_39, int32_t  p_40)
{ /* block id: 228 */
    int32_t l_357 = 6;
    uint16_t l_367 = 0x68AC;
    int32_t l_368 = 0x5808BEAA;
    for (p_40 = 0; (p_40 >= 3); p_40 += 1)
    { /* block id: 231 */
        struct S0 l_356 = {0,768};
        uint32_t l_366 = 0U;
        p_38 = (p_39.f0 &= (l_356 , l_357));
        l_368 = ((((int32_t)l_357 + (int32_t)l_356.f1) , ((l_357 = ((int16_t)p_39.f1 + (int16_t)((int32_t)0x899527F4 % (int32_t)(l_356.f0 , (((l_356.f0 = p_39.f0) && 0x34A0) && ((func_41(((int16_t)l_366 * (int16_t)(l_357 == l_356.f1)), l_367, l_357, p_40, p_40) , l_356.f0) > l_357)))))) , 0x81381FAF)) , l_356.f0);
        l_356.f0 = ((((p_39 , func_95(l_356.f1, (__builtin_popcountll(((((((0x5E8F >= p_39.f0) == (p_39.f1 & ((uint16_t)(p_40 < (-7)) + (uint16_t)(p_38 , ((int32_t)((p_39 , 0xF54270C1) , l_368) - (int32_t)l_366))))) , 4294967287U) | p_39.f0) == p_39.f1) , l_356.f0)) <= p_40), l_368)) <= l_366) <= 0) , l_367);
    }
    return p_39.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_41(uint16_t  p_42, uint32_t  p_43, int16_t  p_44, int32_t  p_45, int32_t  p_46)
{ /* block id: 155 */
    uint32_t l_273 = 0xD00F8FBD;
    int32_t l_274 = 0xAB3622FC;
    struct S0 l_275 = {-0,622};
    int16_t l_351 = 0xB473;
    for (p_45 = 0; (p_45 > 18); p_45 += 1)
    { /* block id: 158 */
        int32_t l_268 = (-1);
        struct S0 l_276 = {0,712};
        int32_t l_277 = 6;
        p_46 = ((int16_t)(__builtin_clz(p_43) | (__builtin_ffs((((uint16_t)(((uint16_t)0x97C5 + (uint16_t)(((((int16_t)(((int16_t)(l_268 , (l_268 && l_268)) << (int16_t)l_268) > (p_45 < (l_274 = ((uint16_t)((int16_t)__builtin_ffsl((p_45 , p_43)) >> (int16_t)l_273) - (uint16_t)2U)))) - (int16_t)l_273) , 1U) == (-1)) && l_268)) , p_45) * (uint16_t)l_273) , 0x6A7BBD49)) ^ p_43)) << (int16_t)2);
        l_276 = l_275;
        l_277 = p_45;
        return l_275;
    }
    for (p_43 = 0; (p_43 != 36); p_43 += 1)
    { /* block id: 167 */
        uint16_t l_280 = 0x513E;
        int32_t l_281 = 0xC90E3653;
        struct S0 l_282 = {0,404};
        int32_t l_337 = 0x34715A6F;
        int16_t l_338 = 0x28E1;
        l_281 = (l_274 = l_280);
        l_275 = l_282;
        for (p_44 = (-8); (p_44 < 26); p_44 += 6)
        { /* block id: 173 */
            int16_t l_293 = 0;
            int32_t l_294 = 0;
            int32_t l_295 = 0xAC026DA2;
            struct S0 l_296 = {0,665};
            for (p_45 = 0; (p_45 < (-9)); p_45 -= 1)
            { /* block id: 176 */
                l_295 = ((uint32_t)(l_294 ^= ((int16_t)((uint16_t)(l_293 |= (l_274 ^ l_282.f1)) << (uint16_t)3) << (int16_t)15)) + (uint32_t)l_275.f0);
                return l_282;
            }
            if (p_42)
            { /* block id: 182 */
                return l_296;
            }
            else
            { /* block id: 184 */
                int32_t l_297 = 0xC1005395;
                l_297 |= p_44;
            }
            if (p_43)
            { /* block id: 187 */
                int32_t l_304 = (-7);
                int32_t l_305 = 0x5F6443CE;
                struct S0 l_307 = {0,880};
                struct S0 l_309 = {0,86};
                uint32_t l_319 = 4294967295U;
                if (p_45)
                { /* block id: 188 */
                    uint16_t l_306 = 0x3013;
                    struct S0 l_308 = {0,442};
                    if ((((int16_t)((((int16_t)l_296.f1 << (int16_t)l_273) != (func_62(((uint16_t)0x86E9 << (uint16_t)__builtin_bswap32(l_294)), p_43, (l_274 = p_44), ((l_304 & (l_304 || 0x6B59)) , p_46), l_305) , l_282.f0)) | l_306) * (int16_t)l_294) == 1U))
                    { /* block id: 190 */
                        return l_282;
                    }
                    else
                    { /* block id: 192 */
                        l_307 = l_275;
                    }
                    return l_308;
                }
                else
                { /* block id: 196 */
                    uint32_t l_314 = 0x115C216B;
                    l_296 = l_296;
                    if (p_44)
                    { /* block id: 198 */
                        l_309 = l_296;
                        p_45 = ((uint16_t)0xB1E7 * (uint16_t)l_309.f0);
                    }
                    else
                    { /* block id: 201 */
                        l_309.f0 = (((uint16_t)(p_43 < ((p_45 , 6U) < (0x6EC7 == (((l_314 = p_42) || ((int32_t)((uint16_t)(p_42 = l_319) - (uint16_t)(!(((uint32_t)((l_275.f0 = ((uint16_t)((func_47(((int16_t)((uint16_t)__builtin_ctzl(((uint32_t)p_46 % (uint32_t)((l_282.f1 < ((int32_t)l_281 - (int32_t)p_44)) , 1))) * (uint16_t)l_295) % (int16_t)l_314), p_43) ^ p_43) < 0x34EF21C7) * (uint16_t)l_314)) | 0xFC6D) % (uint32_t)p_44) != 9U))) + (int32_t)p_43)) <= (-1))))) % (uint16_t)1) > p_46);
                    }
                    l_275.f0 = (l_275.f0 , (((p_46 < (((int16_t)p_43 * (int16_t)l_275.f0) ^ ((int16_t)((func_104(l_337, l_296, (l_275 , ((p_45 = __builtin_clzl((l_314 ^ (((l_274 = (l_282.f1 != l_314)) ^ l_304) >= p_42)))) < 0xB069A3F8)), p_43, l_281) || 4294967292U) != 0x67BC636B) >> (int16_t)13))) > l_275.f1) <= l_282.f0));
                }
                p_45 = l_293;
            }
            else
            { /* block id: 212 */
                uint32_t l_350 = 0x4C9D8C37;
                l_274 |= (((l_338 = l_275.f0) , (l_351 = ((1U || (!((((l_275.f0 = l_337) < p_45) < (((uint16_t)l_295 % (uint16_t)(((int16_t)((uint16_t)((0xC58B == p_45) < (-1)) % (uint16_t)((int16_t)(((int16_t)__builtin_popcountl(p_43) - (int16_t)0x394F) ^ p_43) << (int16_t)9)) >> (int16_t)15) , l_350)) | 0xE90C)) && p_46))) ^ p_46))) || l_294);
                for (l_351 = 0; (l_351 != 4); l_351 += 1)
                { /* block id: 219 */
                    p_46 = l_274;
                    if (p_44)
                        break;
                }
            }
            p_45 |= 0x38B637A0;
        }
    }
    return l_275;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_47(int32_t  p_48, uint32_t  p_49)
{ /* block id: 38 */
    int16_t l_51 = 0;
    p_48 = p_49;
    l_51 = __builtin_ffsl(p_48);
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_52(int32_t  p_53, int32_t  p_54, uint32_t  p_55, int32_t  p_56, struct S0  p_57)
{ /* block id: 139 */
    int32_t l_234 = 0x45E3B42F;
    struct S0 l_235 = {0,119};
    int32_t l_246 = 0x83C189D4;
    int32_t l_247 = 0x5BC35386;
    int32_t l_250 = 0xA939D389;
    uint32_t l_251 = 4294967295U;
    int32_t l_252 = (-3);
    int16_t l_253 = 0x0F0B;
    uint16_t l_254 = 0xA812;
    int32_t l_255 = (-1);
    for (p_53 = 0; (p_53 <= 26); p_53 += 1)
    { /* block id: 142 */
        int32_t l_233 = 0x7F7EF872;
        p_57.f0 = l_233;
        if (p_55)
            continue;
        return p_57.f0;
    }
    l_253 |= func_68(func_95((((p_57.f1 , l_234) , l_235) , p_57.f1), p_57.f0, func_95(((uint16_t)(l_252 = func_82(((p_53 = (((uint16_t)0x53AF - (uint16_t)p_57.f0) , ((int16_t)__builtin_popcountl(((int16_t)(l_247 = ((uint16_t)(l_246 = 0x8298) >> (uint16_t)1)) + (int16_t)((__builtin_ffsll((l_250 = func_47((((((((uint16_t)l_235.f0 % (uint16_t)l_235.f1) < 0U) > 0x4FC2) , p_56) < l_234) || p_54), p_54))) , l_234) | p_56))) << (int16_t)p_54))) <= p_55), l_251, l_251, l_235.f1, l_251)) >> (uint16_t)3), l_234, p_54)), l_235.f1, l_234, l_235.f0);
    l_254 = (-1);
    return l_255;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_62(uint32_t  p_63, uint16_t  p_64, int32_t  p_65, int16_t  p_66, int32_t  p_67)
{ /* block id: 125 */
    uint16_t l_218 = 0x8173;
    struct S0 l_223 = {0,775};
    if (((0x6D25A9A4 & (p_67 >= l_218)) >= (((uint16_t)l_218 * (uint16_t)p_66) | ((int16_t)((func_104(l_218, l_223, l_223.f1, ((uint16_t)0xBFDB + (uint16_t)0x197D), l_218) == l_218) && 4294967295U) % (int16_t)0x58A5))))
    { /* block id: 126 */
        p_67 = p_64;
        p_67 ^= p_66;
        return p_67;
    }
    else
    { /* block id: 130 */
        l_223.f0 = p_66;
        for (p_66 = (-9); (p_66 > 18); p_66 += 6)
        { /* block id: 134 */
            return p_65;
        }
    }
    return l_223.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_68(int32_t  p_69, uint32_t  p_70, uint16_t  p_71, uint32_t  p_72)
{ /* block id: 45 */
    uint32_t l_90 = 0x92197989;
    int32_t l_93 = (-1);
    int32_t l_137 = 0xF827A0C9;
    int32_t l_150 = (-1);
    uint32_t l_182 = 1U;
    int32_t l_193 = 0xE16A3E7E;
    struct S0 l_206 = {-0,670};
    struct S0 l_207 = {-0,662};
    uint32_t l_208 = 4294967291U;
    for (p_70 = (-6); (p_70 <= 14); p_70 += 1)
    { /* block id: 48 */
        uint32_t l_88 = 1U;
        int32_t l_94 = 0;
        int32_t l_99 = 0;
        l_137 = func_82(p_71, p_72, l_88, (((l_93 = (((-(int16_t)(l_90 &= (-1))) & (l_94 = __builtin_bswap64(((uint16_t)l_93 >> (uint16_t)13)))) > func_95((p_72 != p_69), l_88, l_99))) , l_94) > l_88), l_99);
        l_94 = (-3);
        if (l_90)
            continue;
    }
    for (l_137 = 12; (l_137 > (-27)); l_137 -= 1)
    { /* block id: 79 */
        int32_t l_147 = 8;
        int32_t l_148 = 0x3955FA40;
        int32_t l_149 = 1;
        int32_t l_175 = (-1);
        struct S0 l_204 = {-0,400};
        if ((0x509B || ((uint16_t)(((!func_47((l_93 = ((int16_t)0x1383 >> (int16_t)1)), (l_150 = __builtin_popcount(((l_149 |= ((uint16_t)((l_148 ^= l_147) <= p_71) + (uint16_t)(p_70 != 0x2D72378B))) , 4294967295U))))) >= l_90) && l_93) >> (uint16_t)l_137)))
        { /* block id: 84 */
            int32_t l_151 = 0x78BFD083;
            int32_t l_169 = 6;
            int16_t l_181 = 0;
            struct S0 l_205 = {0,988};
            l_151 |= (0xB5AB != p_71);
            if (l_147)
            { /* block id: 86 */
                int32_t l_170 = 0xA39686C7;
                int32_t l_174 = 0x8D0C3C17;
                int32_t l_180 = 0xEB9ED40C;
                l_151 = ((((int16_t)__builtin_parityl(l_151) << (int16_t)3) < ((uint16_t)(~0xFD8C3401) - (uint16_t)l_147)) != __builtin_popcountll((func_82(p_70, (((((((((((int16_t)((l_147 , (((int16_t)((uint16_t)((int32_t)(((((((int32_t)(l_90 != (l_169 = (l_151 == ((uint16_t)((p_70 & 0x63B3) >= l_151) + (uint16_t)0x08B7)))) + (int32_t)0x22CD61D1) , l_170) | 0U) && l_170) , l_169) || (-1)) + (int32_t)0x6D62ACC6) << (uint16_t)2) << (int16_t)l_170) < l_151)) & 0x1F09) >> (int16_t)p_72) , p_70) , p_72) >= p_71) , l_90) <= p_70) | l_151) ^ l_93) & l_137) != l_137), l_170, l_151, p_72) < p_70)));
                l_174 ^= (((!__builtin_ctz(p_70)) ^ ((p_70 < (p_69 <= ((uint32_t)(p_69 != (l_148 = (l_93 = l_148))) % (uint32_t)(-1)))) || ((4294967295U <= (p_72 ^ l_170)) != p_70))) >= 0x1CCB);
                l_150 = (l_148 = ((l_169 = ((__builtin_ffsll(((l_175 > ((((l_149 = l_170) ^ (l_180 ^= ((p_71 = ((int16_t)(p_72 | ((p_72 , ((p_69 ^ ((int16_t)0xDE4F - (int16_t)l_174)) , 0x2080)) ^ l_174)) * (int16_t)0x979E)) || l_174))) , l_181) , l_182)) >= l_169)) | p_72) , p_69)) <= l_150));
                l_148 |= ((l_90 != (func_47(l_169, p_70) & l_175)) < ((((int16_t)((int16_t)(l_149 ^= ((int16_t)(~5U) - (int16_t)(((l_151 = (((((int16_t)(l_150 = (~__builtin_clzl(l_174))) >> (int16_t)l_175) , l_193) , p_69) >= p_72)) <= 0x18D1) || 0x60E83F79))) + (int16_t)6U) * (int16_t)0x6938) <= l_147) < p_69));
            }
            else
            { /* block id: 102 */
                int32_t l_198 = 0xA8828670;
                int32_t l_199 = 1;
                l_148 = p_72;
                l_149 = (((uint16_t)(__builtin_clz(l_149) >= (l_182 & ((int16_t)(l_150 = p_70) * (int16_t)((p_70 , l_198) && ((l_199 &= (0x4ED9 == (__builtin_ctzll(p_70) & 65535U))) == p_70))))) - (uint16_t)p_69) , 0);
                if (p_70)
                    break;
                return l_198;
            }
            l_150 &= (((l_193 = (9U && ((int16_t)((p_71 || ((int16_t)(func_104(p_69, (l_204 , (l_207 = (l_206 = l_205))), (l_151 || p_69), (l_169 &= ((l_148 = p_69) <= p_69)), p_71) , (-1)) % (int16_t)0x35B3)) , l_208) << (int16_t)5))) <= p_72) , l_147);
        }
        else
        { /* block id: 116 */
            uint16_t l_213 = 0U;
            struct S0 l_216 = {0,384};
            l_213 = ((int16_t)((p_69 != l_206.f0) || ((uint16_t)l_175 + (uint16_t)l_207.f1)) << (int16_t)15);
            l_204.f0 &= ((int32_t)(l_93 = l_207.f1) + (int32_t)p_72);
            l_216 = l_204;
            l_204 = l_204;
        }
    }
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_82(uint32_t  p_83, int16_t  p_84, uint32_t  p_85, int16_t  p_86, uint32_t  p_87)
{ /* block id: 54 */
    int32_t l_101 = 0xC4FBB7F4;
    int32_t l_112 = 6;
    uint32_t l_123 = 0xCF258FD7;
    int32_t l_124 = 1;
    int32_t l_125 = 0x5FC6D38C;
    struct S0 l_126 = {-0,553};
    int32_t l_135 = 0xD4CC67FD;
    uint32_t l_136 = 1U;
    l_136 |= func_47(l_101, (func_95(__builtin_clz(((((uint32_t)1U % (uint32_t)(l_126.f0 = func_104(((uint16_t)(l_112 = (p_84 , p_86)) * (uint16_t)(l_125 |= (l_101 ^ (((((uint16_t)0x501D << (uint16_t)13) , (0xEBC01830 || (l_124 = ((int16_t)((((uint16_t)((uint16_t)p_85 * (uint16_t)((__builtin_bswap32(((int16_t)l_101 >> (int16_t)l_101)) || p_84) && 0)) * (uint16_t)p_85) | l_123) & p_87) % (int16_t)p_83)))) , l_124) , l_101)))), l_126, l_101, l_126.f0, l_126.f0))) , 1) , 1U)), l_135, p_84) , p_86));
    l_126 = l_126;
    l_126.f0 ^= p_85;
    l_124 = (-9);
    return p_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_95(int16_t  p_96, int32_t  p_97, int32_t  p_98)
{ /* block id: 51 */
    uint32_t l_100 = 0xD553B787;
    return l_100;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_104(int16_t  p_105, struct S0  p_106, uint32_t  p_107, uint16_t  p_108, uint16_t  p_109)
{ /* block id: 58 */
    int16_t l_130 = 0;
    struct S0 l_131 = {0,337};
    int32_t l_134 = 0xAA3B2A51;
    p_106.f0 = (((int16_t)(func_95((-(uint32_t)0x9925C1F9), ((((((p_105 = __builtin_clzll((l_130 = p_107))) , ((((l_131 , p_106.f1) || (l_131.f0 = (p_108 = ((int16_t)l_131.f1 + (int16_t)l_131.f1)))) != (l_134 = (l_130 & l_131.f1))) , 0xA62A)) , l_131.f1) >= p_107) & p_106.f0) | p_109), p_106.f0) && 0x20A8E5F8) >> (int16_t)3) , l_130);
    l_131 = l_131;
    return p_108;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 93
   depth: 1, occurrence: 19
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 19
XXX full-bitfields structs in the program: 19
breakdown:
   indirect level: 0, occurrence: 19
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 30
XXX times a single bitfield on LHS: 15
XXX times a single bitfield on RHS: 51

XXX max expression depth: 52
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 3
   depth: 29, occurrence: 1
   depth: 37, occurrence: 1
   depth: 41, occurrence: 1
   depth: 43, occurrence: 1
   depth: 52, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 409
XXX times a non-volatile is write: 125
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 23
   depth: 2, occurrence: 12
   depth: 3, occurrence: 16
   depth: 4, occurrence: 7
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 21.4
XXX percentage an existing variable is used: 78.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

