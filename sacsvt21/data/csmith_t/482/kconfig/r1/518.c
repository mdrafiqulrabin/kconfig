/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2308928820
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   float  f1;
   uint8_t  f2;
   int32_t  f3;
   uint64_t  f4;
   int32_t  f5;
   const uint8_t  f6;
   int32_t  f7;
   const int32_t  f8;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const int16_t  func_29(void);
static int32_t  func_30(int64_t  p_31, int64_t  p_32, int16_t  p_33, const int32_t  p_34, int32_t  p_35);
static int64_t  func_37(int16_t  p_38, int32_t  p_39, struct S0  p_40);
static uint16_t  func_48(uint16_t  p_49);
inline static uint16_t  func_50(uint64_t  p_51, float  p_52);
static float  func_55(int16_t  p_56, float  p_57, const uint64_t  p_58, int32_t  p_59, const uint32_t  p_60);
static uint64_t  func_67(uint8_t  p_68, uint16_t  p_69, const struct S0  p_70, int16_t  p_71);
inline static int32_t * func_74(int16_t  p_75, const uint32_t  p_76);
inline static int16_t  func_80(int32_t  p_81, int32_t * p_82, int32_t * p_83, int32_t  p_84);
static int64_t  func_87(int32_t * p_88, uint64_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_29(void)
{ /* block id: 36 */
    int64_t l_43 = (-4L);
    float l_72 = 0xF.25DC8Fp+23;
    const struct S0 l_73 = {0x77F0A061L,0x6.6p-1,0UL,-1L,18446744073709551608UL,0x98BE49C9L,0x60L,-1L,-7L};
    int16_t l_287 = 0x2B58L;
    int16_t l_357 = 0xF704L;
    int32_t *l_364 = (void*)0;
    struct S0 l_371 = {-1L,0x2.123F75p-54,0x31L,0x1EDF93BDL,0x4A38D7EE5ECC3E4ELL,0L,0x3BL,1L,8L};
    struct S0 * const l_370 = &l_371;
    struct S0 * const *l_369 = &l_370;
    struct S0 * const **l_368 = &l_369;
    const int32_t *l_372 = &l_73.f3;
    const int16_t l_375 = 2L;
    if (func_30((~(((((func_37(__builtin_clzll((((uint16_t)0UL >> (uint16_t)l_43) & ((uint16_t)((uint16_t)(l_43 <= func_48(func_50((l_43 && 4294967295UL), ((float)func_55((((int64_t)((int64_t)l_43 - (int64_t)(l_43 != 0UL)) - (int64_t)((uint64_t)func_67(l_43, l_43, l_73, l_73.f2) - (uint64_t)l_287)) && l_73.f7), l_287, l_73.f6, l_73.f6, l_73.f8) + (float)l_73.f0)))) + (uint16_t)l_73.f5) >> (uint16_t)14))), l_73.f4, l_73) ^ l_357) & l_357) && 0L) != l_73.f2) || 18446744073709551613UL)), l_73.f0, l_73.f4, l_73.f5, l_357))
    { /* block id: 188 */
        int32_t **l_365 = (void*)0;
        int32_t **l_366 = &l_364;
        int32_t l_367 = (-1L);
        (*l_366) = l_364;
        (*l_366) = func_74(l_367, (l_368 != (void*)0));
    }
    else
    { /* block id: 191 */
        int32_t **l_373 = &l_364;
        const int64_t l_374 = 2L;
        (*l_373) = l_372;
        /* statement id: 192 */
        assert (l_364 == &l_73.f3);
        return l_374;
    }
    return l_375;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_30(int64_t  p_31, int64_t  p_32, int16_t  p_33, const int32_t  p_34, int32_t  p_35)
{ /* block id: 183 */
    int32_t l_359 = 1L;
    int32_t *l_358 = &l_359;
    int32_t **l_360 = &l_358;
    float *l_361 = (void*)0;
    float l_363 = 0x0.8p+1;
    float *l_362 = &l_363;
    (*l_360) = l_358;
    (*l_360) = (*l_360);
    (*l_362) = (-0x5.6p+1);
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_37(int16_t  p_38, int32_t  p_39, struct S0  p_40)
{ /* block id: 180 */
    float l_355 = 0x0.Dp-1;
    float *l_354 = &l_355;
    int32_t l_356 = 0x20A70311L;
    (*l_354) = 0xD.7B4E46p-64;
    return l_356;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_48(uint16_t  p_49)
{ /* block id: 175 */
    uint64_t l_340 = 0x9AC3D86706A4F0F9LL;
    int32_t l_341 = 0x64B05119L;
    int32_t l_345 = (-7L);
    int32_t * const l_344 = &l_345;
    int32_t * const *l_343 = &l_344;
    int32_t * const **l_342 = &l_343;
    const struct S0 l_346 = {1L,-0x9.3p+1,9UL,8L,18446744073709551612UL,0x35BB748AL,0x12L,0x6B3610BEL,1L};
    int64_t l_347 = (-5L);
    int32_t *l_350 = &l_345;
    float ***l_351 = (void*)0;
    float ** const *l_353 = (void*)0;
    float ** const **l_352 = &l_353;
    (**l_343) = (func_67(__builtin_bswap64(((uint16_t)((uint16_t)((0x34DD0C72L <= l_340) && (l_340 != l_341)) >> (uint16_t)((void*)0 == l_342)) << (uint16_t)(*l_344))), ((*l_344) >= p_49), l_346, (**l_343)) > l_347);
    l_350 = func_74(((uint16_t)((((p_49 > p_49) <= (**l_343)) | p_49) || (*l_344)) >> (uint16_t)3), ((**l_343) ^ 3UL));
    /* statement id: 177 */
    assert (l_350 == 0);
    (*l_352) = l_351;
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_50(uint64_t  p_51, float  p_52)
{ /* block id: 171 */
    float l_329 = (-0x9.9p-1);
    float *l_328 = &l_329;
    int32_t l_330 = 1L;
    int32_t **l_331 = (void*)0;
    int32_t *l_333 = &l_330;
    int32_t **l_332 = &l_333;
    (*l_328) = 0x4.40AC31p-68;
    (*l_332) = func_74(l_330, l_330);
    /* statement id: 173 */
    assert (l_333 == 0);
    return l_330;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_55(int16_t  p_56, float  p_57, const uint64_t  p_58, int32_t  p_59, const uint32_t  p_60)
{ /* block id: 140 */
    const int32_t l_292 = 4L;
    const int32_t *l_291 = &l_292;
    const int32_t **l_290 = &l_291;
    const int32_t ***l_289 = &l_290;
    int32_t l_296 = 0x20D3CC9FL;
    int32_t *l_295 = &l_296;
    int32_t **l_294 = &l_295;
    int32_t ***l_293 = &l_294;
    int32_t *l_297 = &l_296;
    struct S0 l_304 = {1L,0x1.4p+1,6UL,1L,0x609877FA435BA57CLL,-1L,0x7FL,1L,0xDA90051DL};
    struct S0 *l_303 = &l_304;
    struct S0 *l_306 = &l_304;
    if ((~(0xB9B6F4331D11E76FLL == (0x94F7L && (l_289 != l_293)))))
    { /* block id: 141 */
        int32_t *l_298 = (void*)0;
        float l_300 = (-0x1.1p-1);
        float *l_299 = &l_300;
        l_298 = l_297;
        /* statement id: 142 */
        assert (l_298 == &l_296);
        (*l_290) = l_298;
        /* statement id: 143 */
        assert (l_291 == &l_296);
        (*l_298) = (*l_291);
        (*l_299) = (***l_293);
    }
    else
    { /* block id: 146 */
        struct S0 l_308 = {0xABED47C3L,-0x7.Fp+1,0x3DL,-8L,0x2D61EB4871747DE5LL,0x83907937L,255UL,-5L,-1L};
        struct S0 *l_307 = &l_308;
        int32_t *l_311 = &l_308.f7;
        float *l_326 = (void*)0;
        float **l_325 = &l_326;
        float ***l_324 = &l_325;
        float ****l_327 = (void*)0;
        for (p_56 = 10; (p_56 > (-16)); p_56 -= 1)
        { /* block id: 149 */
            struct S0 **l_305 = &l_303;
            (**l_294) = p_58;
            (*l_305) = l_303;
            l_307 = l_306;
            /* statement id: 152 */
            assert (l_307 == &l_304);
            (**l_289) = (*l_290);
        }
        /* facts after for loop */
        assert (l_307 == &l_304 || l_307 == &l_308);
        for (p_56 = (-16); (p_56 != (-25)); p_56 -= 3)
        { /* block id: 157 */
            struct S0 ** const l_322 = &l_306;
            struct S0 ** const *l_321 = &l_322;
            int32_t l_323 = 0L;
            (*l_290) = l_311;
            /* statement id: 158 */
            assert (l_291 == &l_308.f7);
            for (l_304.f5 = 0; (l_304.f5 > (-3)); l_304.f5 -= 1)
            { /* block id: 161 */
                const struct S0 ***l_320 = (void*)0;
                (**l_294) = (!(((p_59 || 8L) && (((uint64_t)((int32_t)(((-(uint16_t)65528UL) & (p_58 < p_60)) || (l_320 == l_321)) - (int32_t)func_87(l_311, p_56)) / (uint64_t)0xC5ADFD7D043DD9BALL) > l_323)) & p_58));
                (***l_293) = (*l_311);
            }
            return p_60;
        }
        l_324 = l_324;
    }
    /* facts after branching */
    assert (l_291 == &l_292 || l_291 == &l_296);
    (*l_290) = (**l_289);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_67(uint8_t  p_68, uint16_t  p_69, const struct S0  p_70, int16_t  p_71)
{ /* block id: 37 */
    int32_t l_91 = 0L;
    int32_t *l_90 = &l_91;
    const struct S0 l_109 = {0L,0x0.4p-1,1UL,0x2D295891L,0x928D85E26160D4A0LL,0x6EE5324EL,0UL,0x86553ECFL,0x843C9D40L};
    const struct S0 * const l_108 = &l_109;
    int64_t l_110 = 0L;
    float l_111 = 0xA.C9AF00p-71;
    uint8_t l_112 = 9UL;
    const uint8_t l_127 = 0x3EL;
    const int32_t *l_286 = &l_109.f7;
    const int32_t **l_285 = &l_286;
    (*l_285) = func_74(((+((int16_t)func_80((p_71 >= ((int64_t)func_87(l_90, (*l_90)) / (int64_t)1L)), l_90, l_90, ((uint16_t)(__builtin_ia32_crc32qi((((uint64_t)(((p_70.f6 < ((int64_t)((int16_t)(((void*)0 == l_108) & 0x74057392L) << (int16_t)p_70.f5) % (int64_t)l_109.f4)) >= 0x31361057L) | p_70.f6) - (uint64_t)l_110) || 0x7EDFL), p_70.f2) | 0xDC0990E41E6F706CLL) / (uint16_t)l_112)) << (int16_t)p_71)) == p_70.f7), l_127);
    /* statement id: 138 */
    assert (l_286 == 0);
    return p_70.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_74(int16_t  p_75, const uint32_t  p_76)
{ /* block id: 52 */
    int32_t l_131 = 0x0C33ADB5L;
    int32_t * const l_130 = &l_131;
    int32_t *l_136 = (void*)0;
    int32_t l_166 = 0xDFAB55DAL;
    int32_t l_178 = 1L;
    struct S0 *l_220 = (void*)0;
    struct S0 **l_219 = &l_220;
    struct S0 ***l_218 = &l_219;
    int32_t ***l_221 = (void*)0;
    float l_250 = 0xB.55E1EFp+89;
    float *l_249 = &l_250;
    float **l_248 = &l_249;
    const float *l_283 = &l_250;
    int32_t *l_284 = (void*)0;
    if (__builtin_popcountll(((int16_t)(l_130 == (void*)0) % (int16_t)(*l_130))))
    { /* block id: 53 */
        int32_t *l_132 = &l_131;
        int32_t **l_133 = &l_132;
        uint64_t l_177 = 0x8AD4A5CD318D08C1LL;
        (*l_133) = l_132;
        if (((int32_t)(((l_136 != (void*)0) < ((int32_t)(!(p_75 == (((int16_t)p_76 - (int16_t)(((uint32_t)__builtin_parityl(p_76) % (uint32_t)((int16_t)(((uint16_t)func_80((*l_130), (*l_133), &l_131, p_75) >> (uint16_t)1) < p_76) << (int16_t)(*l_132))) & (-3L))) ^ 1UL))) - (int32_t)p_76)) >= p_75) / (int32_t)3L))
        { /* block id: 55 */
            uint32_t l_150 = 0x077F077BL;
            float *l_151 = (void*)0;
            float l_157 = 0xB.33F915p-38;
            float *l_156 = &l_157;
            int32_t l_185 = (-8L);
            struct S0 l_207 = {0xE98D5FDBL,-0x1.8p+1,0x62L,0x39AA58BCL,0x28D9300DF10CB638LL,-7L,0x6BL,0x7537BB74L,0xFEE94D8EL};
            struct S0 *l_206 = &l_207;
            struct S0 **l_205 = &l_206;
            struct S0 ***l_204 = &l_205;
            int32_t *l_209 = &l_207.f7;
            (*l_156) = ((0xC.C1B3C7p+32 != (((float)l_150 - (float)(l_132 != l_151)) != ((float)((float)p_76 / (float)l_150) - (float)p_75))) <= (p_75 > 0x8.DDE4D7p+15));
            for (p_75 = 0; (p_75 != 14); ++p_75)
            { /* block id: 59 */
                int64_t l_168 = (-4L);
                int32_t *l_169 = &l_166;
                struct S0 l_203 = {3L,-0x1.2p-1,255UL,0x2567F932L,0xAA2BCA0CB05F2988LL,0L,0xE2L,0L,0x100BB5F2L};
                struct S0 *l_202 = &l_203;
                struct S0 **l_201 = &l_202;
                struct S0 ***l_200 = &l_201;
                for (l_131 = 4; (l_131 != (-6)); l_131 -= 5)
                { /* block id: 62 */
                    int32_t l_172 = 0L;
                    if (((int32_t)p_76 + (int32_t)((uint16_t)p_76 + (uint16_t)p_75)))
                    { /* block id: 63 */
                        uint64_t l_167 = 0xA988067FC1DF0E7DLL;
                        if (p_76)
                            break;
                        l_166 = p_75;
                        l_168 = ((p_76 | l_167) || l_150);
                    }
                    else
                    { /* block id: 67 */
                        return l_151;
                        /* statement id: 68 */
                        //assert (func_74_rv == 0);
                    }
                    (*l_133) = &l_131;
                    /* statement id: 70 */
                    assert (l_132 == &l_131);
                    if ((*l_130))
                        break;
                    if (((int16_t)(__builtin_parity(l_172) | (((uint64_t)((int16_t)(**l_133) << (int16_t)3) % (uint64_t)l_177) && (p_76 > (l_178 & p_75)))) >> (int16_t)6))
                    { /* block id: 72 */
                        const struct S0 *l_180 = (void*)0;
                        const struct S0 **l_179 = &l_180;
                        struct S0 l_184 = {3L,0xD.5CE8A8p+24,0xE8L,0xAE0A1952L,0x13B08BCBAD6A7F72LL,0xD9C3D7FAL,9UL,2L,0x01B87C57L};
                        struct S0 *l_183 = &l_184;
                        struct S0 **l_182 = &l_183;
                        struct S0 ***l_181 = &l_182;
                        (*l_181) = l_179;
                        /* statement id: 73 */
                        assert (l_182 == &l_180);
                    }
                    else
                    { /* block id: 74 */
                        int16_t l_186 = (-2L);
                        l_186 = (l_185 | p_75);
                    }
                }
                if (p_76)
                { /* block id: 78 */
                    int16_t l_197 = 0x52D8L;
                    int32_t ***l_208 = &l_133;
                    for (l_166 = 0; (l_166 >= (-23)); l_166--)
                    { /* block id: 81 */
                        uint64_t l_189 = 0xC697D3C6209D16BBLL;
                        (*l_133) = (void*)0;
                        /* statement id: 82 */
                        assert (l_132 == 0);
                        (*l_130) = ((-3L) && l_189);
                    }
                    if ((((uint32_t)p_75 - (uint32_t)(((uint64_t)l_150 / (uint64_t)(*l_130)) >= (1L >= (!(((int64_t)(l_197 | 4294967295UL) - (int64_t)l_197) == (p_76 == 18446744073709551615UL)))))) == p_75))
                    { /* block id: 85 */
                        (*l_169) = (__builtin_ctz(((int64_t)1L - (int64_t)(*l_169))) > (l_200 != l_204));
                        (*l_133) = &l_131;
                        /* statement id: 87 */
                        assert (l_132 == &l_131);
                        (*l_169) = p_76;
                    }
                    else
                    { /* block id: 89 */
                        (*l_156) = p_76;
                        if (p_76)
                            continue;
                    }
                    (*l_208) = &l_136;
                    /* statement id: 93 */
                    assert (l_133 == &l_136);
                    return l_151;
                    /* statement id: 94 */
                    //assert (func_74_rv == 0);
                }
                else
                { /* block id: 95 */
                    float ***l_210 = (void*)0;
                    float **l_212 = (void*)0;
                    float ***l_211 = &l_212;
                    int32_t l_213 = 0x5BE66359L;
                    (*l_211) = (void*)0;
                    if (l_213)
                        break;
                }
                (*l_133) = (*l_133);
            }
            /* facts after for loop */
            assert (l_132 == 0 || l_132 == &l_131);
            (*l_209) = ((l_218 != (void*)0) < ((void*)0 != l_221));
            (*l_130) = (p_76 | ((int16_t)(-6L) << (int16_t)9));
        }
        else
        { /* block id: 104 */
            int64_t l_225 = 0L;
            int32_t *l_228 = (void*)0;
            const int32_t l_251 = (-1L);
            l_225 = (-(int32_t)p_75);
            for (l_178 = 0; (l_178 <= (-8)); l_178 -= 5)
            { /* block id: 108 */
                float *l_230 = (void*)0;
                float ** const l_229 = &l_230;
                int32_t l_231 = 0L;
                struct S0 ***l_242 = &l_219;
                (*l_133) = l_228;
                /* statement id: 109 */
                assert (l_132 == 0);
                l_231 = ((void*)0 == l_229);
                l_231 = ((float)(p_75 > ((&l_231 != &l_131) <= l_231)) / (float)((float)((((float)(((float)(__builtin_ctzll((*l_130)) >= ((float)(l_242 == (void*)0) + (float)((float)0x0.0p-1 / (float)0x3.F5FF99p+46))) / (float)p_75) >= 0x2.DE78DBp+81) - (float)0x8.E13616p-77) < p_75) > (-0x1.1p-1)) - (float)(-0x10.1p-1)));
            }
            /* facts after for loop */
            assert (l_132 == 0 || l_132 == &l_131);
            (*l_133) = (*l_133);
            (*l_130) = ((+p_76) > ((p_76 || l_251) < 4294967295UL));
        }
        /* facts after branching */
        assert (l_132 == 0 || l_132 == &l_131);
    }
    else
    { /* block id: 116 */
        float l_261 = 0x3.8p-1;
        int32_t l_264 = 0x4ED1C8C2L;
        float **l_271 = (void*)0;
        float *l_282 = &l_261;
        l_248 = &l_249;
lbl_270:
        for (p_75 = 0; (p_75 > (-4)); --p_75)
        { /* block id: 120 */
            int32_t *l_263 = &l_131;
            for (l_131 = 24; (l_131 >= (-15)); l_131 -= 4)
            { /* block id: 123 */
                uint32_t l_265 = 18446744073709551612UL;
                int32_t *l_268 = &l_264;
                int32_t **l_269 = &l_136;
                for (l_166 = (-17); (l_166 < (-29)); l_166 -= 7)
                { /* block id: 126 */
                    int32_t *l_262 = &l_166;
                    int32_t *l_266 = (void*)0;
                    int32_t *l_267 = &l_264;
                    (*l_267) = (!__builtin_ctz((func_80(((uint64_t)p_75 % (uint64_t)p_76), l_262, l_263, l_264) & l_265)));
                }
                (*l_268) = l_265;
                (*l_269) = l_268;
                /* statement id: 130 */
                assert (l_136 == &l_264);
            }
            if (l_131)
                goto lbl_270;
        }
        (*l_130) = (p_75 | ((*l_130) & (l_271 != &l_249)));
        (*l_130) = (p_75 | ((int16_t)__builtin_clzll((*l_130)) / (int16_t)(((((uint16_t)((int16_t)(0xA8AAFD5AL == (p_75 | 7L)) << (int16_t)((int16_t)((int64_t)(l_282 != l_283) - (int64_t)18446744073709551614UL) << (int16_t)(*l_130))) >> (uint16_t)(*l_130)) >= p_75) < 0xC2B6535DL) & p_76)));
    }
    /* facts after branching */
    //assert (l_136 == dangling || l_136 == 0);
    return l_284;
    /* statement id: 137 */
    //assert (func_74_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_80(int32_t  p_81, int32_t * p_82, int32_t * p_83, int32_t  p_84)
{ /* block id: 42 */
    int32_t *l_121 = (void*)0;
    int32_t ** const l_120 = &l_121;
    int32_t l_124 = 0xA4458F59L;
    for (p_81 = 0; (p_81 == (-7)); --p_81)
    { /* block id: 45 */
        int32_t l_117 = 1L;
        int32_t *l_116 = &l_117;
        int32_t **l_115 = &l_116;
        float l_126 = 0xB.B5B590p-17;
        float *l_125 = &l_126;
        (*l_115) = &p_84;
        /* statement id: 46 */
        assert (l_116 == &p_84);
        (*l_125) = (func_87((*l_115), p_84) > ((float)((l_120 == &l_116) >= (((float)0x7.5CB2EAp-48 / (float)(-0x10.0p-1)) >= 0x7.Dp+1)) + (float)l_124));
        (*l_120) = &p_84;
        /* statement id: 48 */
        assert (l_121 == &p_84);
        if ((*p_82))
            continue;
    }
    /* facts after for loop */
    assert (l_121 == &p_84 || l_121 == 0);
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_87(int32_t * p_88, uint64_t  p_89)
{ /* block id: 38 */
    struct S0 l_93 = {0xD8E2DC66L,0xE.A86E60p-90,0x10L,1L,0xCCC853D3C4855F07LL,-5L,0xE6L,0L,0x1AA8C97DL};
    struct S0 *l_92 = &l_93;
    l_92 = l_92;
    (*p_88) = ((uint16_t)(l_93.f2 | ((uint16_t)((int64_t)l_93.f5 + (int64_t)p_89) >> (uint16_t)(p_88 == p_88))) << (uint16_t)14);
    return l_93.f2;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 88
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 122
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 4, occurrence: 6
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 4
   depth: 10, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 26, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 102

XXX times a variable address is taken: 86
XXX times a pointer is dereferenced on RHS: 34
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 50
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 150

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 157
   level: 2, occurrence: 22
   level: 3, occurrence: 2
XXX number of pointers point to pointers: 47
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 26.5
XXX average alias set size: 1.18

XXX times a non-volatile is read: 340
XXX times a non-volatile is write: 129
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 100
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 21
   depth: 2, occurrence: 17
   depth: 3, occurrence: 11
   depth: 4, occurrence: 11
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 27.1
XXX percentage an existing variable is used: 72.9
********************* end of statistics **********************/

