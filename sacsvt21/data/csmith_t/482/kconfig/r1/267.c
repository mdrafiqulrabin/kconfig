/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      4084137616
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_1(void);
inline static int32_t * func_2(int16_t  p_3, int32_t  p_4, int32_t  p_5);
inline static int32_t  func_7(int8_t  p_8, uint16_t  p_9, int16_t  p_10, uint64_t  p_11, int32_t  p_12);
static int64_t  func_18(uint32_t  p_19, uint32_t  p_20, int32_t * p_21);
inline static const int32_t * func_26(uint16_t  p_27, int32_t * p_28, uint32_t  p_29, int32_t * p_30);
inline static uint16_t  func_39(int32_t * p_40, int32_t * p_41, uint32_t  p_42, int32_t * p_43, int32_t * p_44);
inline static int32_t * func_45(uint16_t  p_46, int32_t  p_47, uint16_t  p_48);
static int32_t ** func_49(int32_t ** p_50, int32_t ** p_51, int32_t * p_52, int32_t ** p_53);
static int32_t ** func_54(const uint32_t  p_55, float  p_56);
static float  func_58(int32_t * p_59, uint32_t  p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_1(void)
{ /* block id: 0 */
    uint16_t l_6 = 2UL;
    int32_t l_16 = 4L;
    int32_t *l_15 = &l_16;
    int32_t * const l_17[4][5][3] = {{{&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16},{&l_16,&l_16,(void*)0},{(void*)0,(void*)0,(void*)0},{&l_16,&l_16,&l_16}},{{&l_16,(void*)0,&l_16},{&l_16,&l_16,(void*)0},{&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16},{&l_16,&l_16,(void*)0}},{{(void*)0,(void*)0,(void*)0},{&l_16,&l_16,&l_16},{&l_16,(void*)0,&l_16},{&l_16,&l_16,(void*)0},{&l_16,&l_16,&l_16}},{{(void*)0,&l_16,(void*)0},{&l_16,&l_16,(void*)0},{&l_16,&l_16,(void*)0},{&l_16,&l_16,(void*)0},{&l_16,&l_16,&l_16}}};
    int32_t **l_420 = &l_15;
    uint16_t l_421 = 65534UL;
    int i, j, k;
    (*l_420) = func_2(l_6, func_7(l_6, ((safe_rshift_func_int8_t_s_u(l_6, ((l_15 != &l_16) && (&l_16 != l_17[2][0][2])))) | ((*l_15) != func_18((safe_mod_func_int64_t_s_s(((safe_mul_func_int8_t_s_s(((0x85755261L <= 1UL) ^ (-1L)), 0xA0L)) != 0xDCDAL), (*l_15))), (*l_15), &l_16))), (*l_15), (*l_15), (*l_15)), (*l_15));
    /* statement id: 192 */
    assert (l_15 == 0);
    return l_421;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_2(int16_t  p_3, int32_t  p_4, int32_t  p_5)
{ /* block id: 182 */
    int32_t l_396[9] = {0x613CF344L,0x613CF344L,0x613CF344L,0x613CF344L,0x613CF344L,0x613CF344L,0x613CF344L,0x613CF344L,0x613CF344L};
    int32_t *l_395 = &l_396[8];
    float l_402 = 0x6.97F9CAp+49;
    float *l_401[6][5][7] = {{{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402}},{{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402}},{{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402}},{{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402}},{{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402}},{{&l_402,(void*)0,&l_402,(void*)0,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,(void*)0,&l_402,(void*)0,&l_402,&l_402,&l_402},{&l_402,&l_402,&l_402,&l_402,&l_402,&l_402,&l_402},{&l_402,(void*)0,&l_402,(void*)0,&l_402,&l_402,&l_402}}};
    float **l_400 = &l_401[3][0][0];
    float ***l_399 = &l_400;
    float ****l_398 = &l_399;
    float *****l_397 = &l_398;
    int16_t l_405[7][5] = {{(-9L),(-9L),(-1L),0xA6E1L,(-1L)},{(-9L),(-9L),(-1L),0xA6E1L,(-1L)},{(-9L),(-9L),(-1L),0xA6E1L,(-1L)},{(-9L),(-9L),(-1L),0xA6E1L,(-1L)},{(-9L),(-9L),(-1L),0xA6E1L,(-1L)},{(-9L),(-9L),(-1L),0xA6E1L,(-1L)},{(-9L),(-9L),(-1L),0xA6E1L,(-1L)}};
    int32_t **l_411 = &l_395;
    int32_t *** const l_410 = &l_411;
    int32_t ** const * const l_412 = (void*)0;
    int32_t *l_415[6][9] = {{&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8]},{&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6]},{&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8]},{&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6]},{&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8]},{&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6],&l_396[8],&l_396[6]}};
    int32_t *l_416[8][7] = {{&l_396[0],&l_396[8],&l_396[0],&l_396[8],&l_396[8],&l_396[0],&l_396[8]},{&l_396[8],&l_396[8],&l_396[8],(void*)0,(void*)0,&l_396[7],(void*)0},{&l_396[0],&l_396[8],&l_396[8],&l_396[0],&l_396[8],&l_396[0],&l_396[8]},{(void*)0,&l_396[1],&l_396[8],(void*)0,&l_396[8],&l_396[1],(void*)0},{&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8]},{&l_396[8],&l_396[8],&l_396[8],&l_396[7],&l_396[8],(void*)0,(void*)0},{&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8],&l_396[8]},{&l_396[8],&l_396[7],&l_396[8],(void*)0,(void*)0,(void*)0,&l_396[8]}};
    int32_t *l_417[6] = {&l_396[8],&l_396[8],&l_396[7],(void*)0,(void*)0,&l_396[8]};
    int32_t *l_418 = &l_396[8];
    int32_t *l_419 = (void*)0;
    int i, j, k;
    for (p_4 = 0; (p_4 != (-3)); --p_4)
    { /* block id: 185 */
        int32_t *l_394 = (void*)0;
        int32_t **l_393[2][2] = {{&l_394,&l_394},{&l_394,&l_394}};
        int i, j;
        l_395 = &p_5;
        /* statement id: 186 */
        assert (l_395 == &p_5);
        l_395 = (void*)0;
        /* statement id: 187 */
        assert (l_395 == 0);
        l_397 = l_397;
    }
    /* facts after for loop */
    assert (l_395 == 0 || (l_395 >= &l_396[0] && l_395 <= &l_396[8]));
    (*l_411) = func_45(((p_3 >= (safe_sub_func_int8_t_s_s(p_4, l_405[3][2]))) && (safe_mul_func_int16_t_s_s((safe_add_func_int16_t_s_s((l_410 != l_412), ((void*)0 != (*l_397)))), 0xB8AAL))), (safe_lshift_func_int8_t_s_s((p_3 && (-10L)), p_5)), p_3);
    /* statement id: 190 */
    assert (l_395 == 0);
    return l_419;
    /* statement id: 191 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_7(int8_t  p_8, uint16_t  p_9, int16_t  p_10, uint64_t  p_11, int32_t  p_12)
{ /* block id: 159 */
    float l_319 = 0x3.DB4905p-19;
    float *l_318[7][3];
    float **l_317 = &l_318[5][1];
    float ***l_316[2];
    int32_t l_320 = 0xB9BCCF34L;
    const int32_t *l_390 = &l_320;
    const int32_t **l_389 = &l_390;
    int i, j;
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 3; j++)
            l_318[i][j] = &l_319;
    }
    for (i = 0; i < 2; i++)
        l_316[i] = &l_317;
    if ((safe_div_func_uint16_t_u_u(((((l_316[1] == &l_317) != l_320) == (((-1L) && (&p_12 != &p_12)) != ((safe_add_func_int32_t_s_s(0x4CBC2A9CL, (safe_add_func_uint16_t_u_u(((p_11 < ((safe_div_func_uint32_t_u_u((safe_sub_func_int32_t_s_s(9L, p_11)), 0x0CE5C9CAL)) | l_320)) == 6UL), p_10)))) == l_320))) <= p_11), 0x1B35L)))
    { /* block id: 160 */
        uint16_t l_329 = 0xAE39L;
        int32_t **l_330 = (void*)0;
        int32_t *l_332 = (void*)0;
        int32_t **l_331[5][1];
        int32_t *l_333 = (void*)0;
        int i, j;
        for (i = 0; i < 5; i++)
        {
            for (j = 0; j < 1; j++)
                l_331[i][j] = &l_332;
        }
        (**l_317) = l_329;
        l_333 = &l_320;
        /* statement id: 162 */
        assert (l_333 == &l_320);
    }
    else
    { /* block id: 163 */
        uint32_t l_337 = 3UL;
        float *** const l_344 = &l_317;
        int32_t l_355 = (-6L);
        int32_t *l_354 = &l_355;
        uint16_t l_364 = 0xBCEAL;
        for (p_8 = 10; (p_8 >= (-28)); p_8 = safe_sub_func_uint8_t_u_u(p_8, 6))
        { /* block id: 166 */
            int32_t l_336[9][5] = {{0xFBABD686L,0x05B78468L,1L,0xB7A41384L,1L},{0xFBABD686L,0xFBABD686L,(-1L),0xB7A41384L,(-1L)},{0x05B78468L,0xFBABD686L,1L,(-1L),(-1L)},{0xFBABD686L,0x05B78468L,1L,0xB7A41384L,1L},{0xFBABD686L,0xFBABD686L,(-1L),0xB7A41384L,(-1L)},{0x05B78468L,0xFBABD686L,1L,(-1L),(-1L)},{0xFBABD686L,0x05B78468L,1L,0xB7A41384L,1L},{0xFBABD686L,0xFBABD686L,(-1L),0xB7A41384L,(-1L)},{0x05B78468L,0xFBABD686L,1L,(-1L),(-1L)}};
            int32_t l_351 = 0x7FF8A4D8L;
            float **l_372 = &l_318[5][1];
            int i, j;
            if (l_336[5][4])
                break;
            if (l_337)
                break;
            l_351 = ((p_8 == (((p_9 > (((((l_337 < (safe_div_func_float_f_f((p_11 > (safe_mul_func_float_f_f((safe_add_func_float_f_f(((void*)0 != l_344), (((safe_sub_func_float_f_f((safe_add_func_float_f_f((safe_mul_func_float_f_f(l_336[5][4], 0x6.47C4E9p-31)), (p_12 != 0xA.7737C8p-26))), (-0x1.2p+1))) < p_8) >= p_9))), l_337))), 0x8.4p-1))) <= l_337) >= 0xD.78794Bp+52) == p_11) != l_336[5][4])) >= p_10) != (-0x6.1p-1))) > (-0x1.5p-1));
            for (l_320 = (-25); (l_320 == 10); l_320++)
            { /* block id: 172 */
                const float l_368 = 0x0.6p+1;
                int32_t **l_369 = &l_354;
                int32_t *l_388 = &l_351;
                l_354 = &p_12;
                /* statement id: 173 */
                assert (l_354 == &p_12);
                (*l_369) = func_45((safe_rshift_func_int16_t_s_s(3L, 14)), ((l_351 < p_8) >= (p_9 <= (safe_mul_func_int8_t_s_s((safe_mod_func_int32_t_s_s(((((l_336[0][3] & (safe_mod_func_uint64_t_u_u(l_364, (((safe_sub_func_int64_t_s_s((safe_unary_minus_func_int64_t_s((p_10 && ((void*)0 == &l_317)))), p_8)) >= l_320) & p_11)))) & 0xBA4E0764L) || 0x354C98D323A33DE2LL) >= 9UL), 4L)), p_8)))), p_11);
                /* statement id: 174 */
                assert (l_354 == 0);
                if (p_10)
                    break;
                (*l_388) = ((safe_sub_func_int8_t_s_s((p_10 >= (l_372 != (void*)0)), ((safe_add_func_uint16_t_u_u(l_351, l_351)) <= (safe_add_func_uint8_t_u_u((safe_add_func_uint64_t_u_u((safe_mul_func_uint8_t_u_u(p_9, ((safe_lshift_func_uint8_t_u_u(0x9DL, p_9)) >= (safe_rshift_func_uint16_t_u_s((((safe_sub_func_int8_t_s_s(((((+(&l_355 != (void*)0)) & 0UL) ^ p_11) || p_12), p_12)) | l_320) ^ l_336[5][4]), 15))))), l_351)), l_320))))) >= 3L);
            }
        }
        /* facts after for loop */
        assert (l_354 == 0 || l_354 == &l_355);
    }
    (*l_389) = &l_320;
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_18(uint32_t  p_19, uint32_t  p_20, int32_t * p_21)
{ /* block id: 1 */
    uint64_t l_31 = 18446744073709551613UL;
    int32_t *l_32 = (void*)0;
    int32_t **l_236 = &l_32;
    float l_247 = (-0x10.6p+1);
    const float *l_246[9][8] = {{&l_247,(void*)0,&l_247,&l_247,&l_247,&l_247,(void*)0,&l_247},{&l_247,&l_247,&l_247,&l_247,(void*)0,&l_247,&l_247,&l_247},{&l_247,&l_247,&l_247,&l_247,&l_247,&l_247,&l_247,&l_247},{&l_247,&l_247,&l_247,&l_247,&l_247,&l_247,&l_247,&l_247},{&l_247,&l_247,(void*)0,&l_247,&l_247,(void*)0,&l_247,&l_247},{(void*)0,&l_247,&l_247,&l_247,&l_247,(void*)0,&l_247,&l_247},{(void*)0,&l_247,&l_247,&l_247,(void*)0,&l_247,&l_247,&l_247},{&l_247,&l_247,&l_247,&l_247,&l_247,&l_247,&l_247,(void*)0},{&l_247,&l_247,(void*)0,&l_247,&l_247,&l_247,&l_247,&l_247}};
    const float **l_245 = &l_246[4][7];
    uint8_t l_286 = 0x2AL;
    int32_t l_311 = 7L;
    int i, j;
    (*l_236) = func_26(l_31, l_32, (safe_add_func_uint32_t_u_u((((l_32 == p_21) | (safe_sub_func_uint16_t_u_u(((((void*)0 != p_21) && (safe_mul_func_uint16_t_u_u(0x30B1L, func_39(p_21, func_45(p_20, (*p_21), p_20), l_31, p_21, p_21)))) > p_20), 0x63D7L))) & l_31), 0xB0F83D54L)), l_32);
    for (p_19 = (-17); (p_19 == 51); p_19 = safe_add_func_uint16_t_u_u(p_19, 2))
    { /* block id: 106 */
        uint16_t l_239 = 0x55F2L;
        int32_t ** const *l_289 = &l_236;
        int32_t ** const ** const l_288 = &l_289;
        (*l_236) = (*l_236);
        if (l_239)
            continue;
        for (l_239 = 0; (l_239 == 6); ++l_239)
        { /* block id: 111 */
            float l_243 = 0x1.580E2Cp+66;
            float *l_242[5][6] = {{&l_243,&l_243,&l_243,&l_243,&l_243,&l_243},{&l_243,&l_243,&l_243,&l_243,&l_243,&l_243},{&l_243,&l_243,&l_243,&l_243,&l_243,&l_243},{&l_243,&l_243,&l_243,&l_243,&l_243,&l_243},{&l_243,&l_243,&l_243,&l_243,&l_243,&l_243}};
            int32_t l_244 = (-1L);
            uint8_t l_260 = 0xC2L;
            int i, j;
            l_244 = 0x1.0AEDE1p+54;
        }
    }
    return p_20;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_26(uint16_t  p_27, int32_t * p_28, uint32_t  p_29, int32_t * p_30)
{ /* block id: 16 */
    int32_t **l_87 = (void*)0;
    const int32_t l_128 = 0x62609B7AL;
    uint64_t l_148[1][10] = {{18446744073709551609UL,18446744073709551611UL,1UL,18446744073709551611UL,18446744073709551609UL,18446744073709551609UL,18446744073709551611UL,1UL,18446744073709551611UL,18446744073709551609UL}};
    float l_153 = (-0x5.8p+1);
    float *l_152 = &l_153;
    int32_t l_197 = 6L;
    int8_t l_224 = 0xC8L;
    int64_t l_227 = 0xC4C18AC3F2620083LL;
    int i, j;
    for (p_29 = 0; (p_29 < 48); p_29 = safe_add_func_uint8_t_u_u(p_29, 7))
    { /* block id: 19 */
        int32_t l_109[6];
        int32_t *l_108[10] = {(void*)0,&l_109[0],(void*)0,(void*)0,&l_109[0],(void*)0,(void*)0,&l_109[0],(void*)0,(void*)0};
        int32_t **l_107 = &l_108[9];
        int32_t l_163 = 8L;
        int i;
        for (i = 0; i < 6; i++)
            l_109[i] = 0L;
        for (p_27 = 0; (p_27 == 57); p_27++)
        { /* block id: 22 */
            const uint32_t l_88 = 0xC214255FL;
            int32_t l_90 = 0x94120B1AL;
            int32_t *l_89 = &l_90;
            uint32_t l_91[2][7][8] = {{{0xAE4C08A2L,6UL,0x0324A0BDL,0UL,0x0324A0BDL,6UL,0xAE4C08A2L,0UL},{0xAE4C08A2L,1UL,0x0324A0BDL,1UL,0x0324A0BDL,1UL,0xAE4C08A2L,1UL},{0xAE4C08A2L,6UL,0x0324A0BDL,0UL,0x0324A0BDL,6UL,0xAE4C08A2L,0UL},{0xAE4C08A2L,1UL,0x0324A0BDL,1UL,0x0324A0BDL,1UL,0xAE4C08A2L,1UL},{0xAE4C08A2L,6UL,0x0324A0BDL,0UL,0x0324A0BDL,6UL,0xAE4C08A2L,0UL},{0xAE4C08A2L,1UL,0x0324A0BDL,1UL,0x0324A0BDL,1UL,0xAE4C08A2L,1UL},{0xAE4C08A2L,6UL,0x0324A0BDL,0UL,0x0324A0BDL,6UL,0xAE4C08A2L,0UL}},{{0xAE4C08A2L,1UL,0x0324A0BDL,1UL,0x0324A0BDL,1UL,0xAE4C08A2L,1UL},{0xAE4C08A2L,6UL,0x0324A0BDL,0UL,0x0324A0BDL,6UL,0xAE4C08A2L,0UL},{0xAE4C08A2L,1UL,0x0324A0BDL,1UL,0x0324A0BDL,1UL,0xAE4C08A2L,1UL},{0xAE4C08A2L,6UL,0x0324A0BDL,0UL,0x0324A0BDL,6UL,0xAE4C08A2L,0UL},{0xAE4C08A2L,1UL,0x0324A0BDL,1UL,0x0324A0BDL,1UL,0xAE4C08A2L,1UL},{0xAE4C08A2L,6UL,0x0324A0BDL,0UL,0x0324A0BDL,6UL,0xAE4C08A2L,0UL},{0xAE4C08A2L,1UL,0x0324A0BDL,1UL,0x0324A0BDL,1UL,0xAE4C08A2L,1UL}}};
            int i, j, k;
            (*l_89) = (((l_87 != &p_30) != l_88) > l_88);
            for (l_90 = 0; (l_90 <= 1); l_90 += 1)
            { /* block id: 26 */
                int32_t l_92[7][9][2] = {{{0L,0xC87538C7L},{1L,0x607BBC66L},{0xC87538C7L,9L},{(-4L),1L},{(-9L),(-3L)},{(-3L),4L},{0x59BB015CL,0x09E68FEEL},{1L,0L},{0xB559E040L,0xBB395F0FL}},{{1L,0x1D97AAA5L},{4L,0x401CF63CL},{0xBB395F0FL,0x401CF63CL},{4L,0x1D97AAA5L},{1L,0xBB395F0FL},{0xB559E040L,0L},{1L,0x09E68FEEL},{0x59BB015CL,4L},{(-3L),(-3L)}},{{(-9L),1L},{(-4L),9L},{0xC87538C7L,0x607BBC66L},{1L,0xC87538C7L},{0L,0x948B2FD7L},{0L,0xC87538C7L},{1L,0x607BBC66L},{0xC87538C7L,9L},{(-4L),1L}},{{(-9L),(-3L)},{(-3L),4L},{0x59BB015CL,0x09E68FEEL},{1L,0L},{0xB559E040L,0xBB395F0FL},{1L,0x1D97AAA5L},{4L,0x401CF63CL},{0xBB395F0FL,0x401CF63CL},{4L,0x1D97AAA5L}},{{1L,0xBB395F0FL},{0xB559E040L,0L},{1L,0x09E68FEEL},{0x59BB015CL,4L},{(-3L),(-3L)},{(-9L),1L},{(-4L),9L},{0xC87538C7L,0x607BBC66L},{1L,0xC87538C7L}},{{0L,0x948B2FD7L},{0L,0xC87538C7L},{1L,0x607BBC66L},{0xB559E040L,0x401CF63CL},{0x607BBC66L,4L},{0xBB395F0FL,1L},{1L,(-1L)},{0x68A6AAB0L,0x948B2FD7L},{(-3L),(-9L)}},{{0L,9L},{4L,1L},{(-1L),0x09E68FEEL},{9L,0x09E68FEEL},{(-1L),1L},{4L,9L},{0L,(-9L)},{(-3L),0x948B2FD7L},{0x68A6AAB0L,(-1L)}}};
                int i, j, k;
                l_92[5][1][0] = l_91[l_90][(l_90 + 5)][(l_90 + 2)];
            }
        }
        for (p_27 = 0; (p_27 < 17); ++p_27)
        { /* block id: 32 */
            float l_95 = 0xD.7AE26Bp-15;
            int32_t l_96 = 1L;
            int32_t *l_99[5][2];
            int32_t **l_98[10] = {(void*)0,(void*)0,&l_99[3][0],&l_99[3][0],&l_99[3][0],(void*)0,(void*)0,&l_99[3][0],&l_99[3][0],&l_99[3][0]};
            int8_t l_126[5];
            uint32_t l_127 = 0xFAC948D7L;
            uint8_t l_129 = 8UL;
            float *l_130 = &l_95;
            float ***l_199 = (void*)0;
            float l_235 = 0x0.462964p+75;
            int i, j;
            for (i = 0; i < 5; i++)
            {
                for (j = 0; j < 2; j++)
                    l_99[i][j] = &l_96;
            }
            for (i = 0; i < 5; i++)
                l_126[i] = 0xECL;
            p_28 = func_45(p_29, l_96, (0x29AA74C462F11252LL < (+0x53L)));
            (*l_130) = (+(safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_div_func_float_f_f((l_107 != (void*)0), (0x8.Bp+1 != 0x2.5718CBp+89))), (safe_mul_func_float_f_f((((safe_add_func_float_f_f((0x0.353597p+81 < (((safe_mul_func_float_f_f(((safe_add_func_float_f_f((safe_sub_func_float_f_f((-0x10.Cp-1), (safe_div_func_float_f_f(((safe_mul_func_float_f_f(((0x3.49CFF1p-6 != p_29) == (safe_add_func_float_f_f(((void*)0 == p_30), l_126[4]))), l_127)) >= p_27), 0x5.DDD911p+98)))), p_29)) <= p_29), 0xD.DC9EDEp-99)) <= 0xE.A31763p+67) <= l_128)), p_27)) <= p_27) < p_29), 0xD.F6C78Dp+61)))), l_129)));
        }
    }
    return p_30;
    /* statement id: 102 */
    //assert (func_26_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_39(int32_t * p_40, int32_t * p_41, uint32_t  p_42, int32_t * p_43, int32_t * p_44)
{ /* block id: 13 */
    int32_t *l_80 = (void*)0;
    int32_t **l_79 = &l_80;
    float l_82 = 0xC.5978FFp+39;
    float *l_81 = &l_82;
    (*l_81) = (&p_43 != l_79);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_45(uint16_t  p_46, int32_t  p_47, uint16_t  p_48)
{ /* block id: 2 */
    const int16_t l_57[9] = {0L,0L,0L,0L,0L,0L,0L,0L,0L};
    int32_t l_69 = 0L;
    int32_t *l_68 = &l_69;
    int32_t **l_67[9][4][3] = {{{&l_68,&l_68,&l_68},{&l_68,&l_68,&l_68},{&l_68,&l_68,&l_68},{&l_68,&l_68,&l_68}},{{&l_68,&l_68,&l_68},{&l_68,(void*)0,&l_68},{&l_68,&l_68,&l_68},{(void*)0,&l_68,&l_68}},{{(void*)0,&l_68,&l_68},{&l_68,&l_68,(void*)0},{&l_68,&l_68,&l_68},{&l_68,&l_68,&l_68}},{{&l_68,(void*)0,&l_68},{&l_68,&l_68,(void*)0},{&l_68,(void*)0,&l_68},{&l_68,&l_68,(void*)0}},{{&l_68,(void*)0,&l_68},{&l_68,&l_68,&l_68},{&l_68,&l_68,&l_68},{(void*)0,(void*)0,&l_68}},{{(void*)0,&l_68,&l_68},{&l_68,&l_68,&l_68},{&l_68,(void*)0,&l_68},{&l_68,&l_68,&l_68}},{{&l_68,(void*)0,&l_68},{&l_68,&l_68,&l_68},{&l_68,(void*)0,&l_68},{&l_68,&l_68,(void*)0}},{{&l_68,&l_68,&l_68},{&l_68,&l_68,(void*)0},{&l_68,&l_68,&l_68},{&l_68,&l_68,&l_68}},{{&l_68,&l_68,&l_68},{&l_68,(void*)0,(void*)0},{&l_68,&l_68,&l_68},{(void*)0,(void*)0,&l_68}}};
    int32_t *l_70 = &l_69;
    const uint32_t l_71[4][8][4] = {{{1UL,0x8915D489L,0x6251CA2AL,1UL},{0x8915D489L,0x39B9AA6BL,5UL,0xC3F40837L},{0x8915D489L,3UL,0x6251CA2AL,0x6406CCCEL},{1UL,0xC3F40837L,9UL,9UL},{0x9715B7D0L,0x9715B7D0L,0xA12536DEL,0xC3F40837L},{0xC3F40837L,1UL,0x536403ACL,0x39B9AA6BL},{3UL,0x8915D489L,9UL,0x536403ACL},{0x39B9AA6BL,0x8915D489L,0xF08A7CF5L,0x39B9AA6BL}},{{0x8915D489L,1UL,18446744073709551612UL,9UL},{5UL,1UL,5UL,0xA12536DEL},{0x6251CA2AL,9UL,0xDCCC76BFL,0x536403ACL},{1UL,18446744073709551612UL,5UL,9UL},{18446744073709551608UL,0x6251CA2AL,5UL,0xF08A7CF5L},{1UL,0xF5359351L,0xDCCC76BFL,3UL},{0x6251CA2AL,5UL,5UL,0x6251CA2AL},{5UL,0x6251CA2AL,18446744073709551612UL,18446744073709551608UL}},{{0xF5359351L,1UL,0xC3F40837L,0x536403ACL},{0x6251CA2AL,18446744073709551608UL,0xA12536DEL,0x536403ACL},{18446744073709551612UL,1UL,5UL,18446744073709551608UL},{9UL,0x6251CA2AL,0x9715B7D0L,0x6251CA2AL},{1UL,5UL,0xA12536DEL,3UL},{0xF08A7CF5L,0xF5359351L,5UL,0xF08A7CF5L},{0xF5359351L,0x6251CA2AL,0x14D865E4L,9UL},{0xF5359351L,18446744073709551612UL,5UL,0x536403ACL}},{{0xF08A7CF5L,9UL,0xA12536DEL,0xA12536DEL},{1UL,1UL,0x9715B7D0L,9UL},{9UL,0xF08A7CF5L,5UL,0x6251CA2AL},{18446744073709551612UL,0xF5359351L,0xA12536DEL,5UL},{0x6251CA2AL,0xF5359351L,0xC3F40837L,0x6251CA2AL},{0xF5359351L,0xF08A7CF5L,18446744073709551612UL,9UL},{5UL,1UL,5UL,0xA12536DEL},{0x6251CA2AL,9UL,0xDCCC76BFL,0x536403ACL}}};
    uint32_t l_72 = 0x8F1D39FAL;
    int32_t ***l_77 = &l_67[1][3][2];
    int32_t *l_78 = (void*)0;
    int i, j, k;
    (*l_77) = func_49(func_54(l_57[2], func_58(&p_47, l_57[2])), l_67[1][3][2], l_70, func_54(l_71[2][6][2], l_72));
    return l_78;
    /* statement id: 12 */
    //assert (func_45_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_49(int32_t ** p_50, int32_t ** p_51, int32_t * p_52, int32_t ** p_53)
{ /* block id: 8 */
    int32_t l_74[1];
    int32_t *l_73 = &l_74[0];
    int32_t **l_75 = &l_73;
    int32_t **l_76 = (void*)0;
    int i;
    for (i = 0; i < 1; i++)
        l_74[i] = 1L;
    (*l_75) = l_73;
    return l_76;
    /* statement id: 10 */
    //assert (func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_54(const uint32_t  p_55, float  p_56)
{ /* block id: 5 */
    int32_t l_63 = 0xCDCBD5F5L;
    int32_t *l_62 = &l_63;
    int32_t **l_64 = &l_62;
    int32_t **l_65 = &l_62;
    int32_t **l_66 = (void*)0;
    (*l_64) = l_62;
    return l_66;
    /* statement id: 7 */
    //assert (func_54_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_58(int32_t * p_59, uint32_t  p_60)
{ /* block id: 3 */
    int8_t l_61[9][10] = {{(-1L),0x46L,0xB1L,0x57L,0L,0xCAL,0xA6L,1L,1L,0xA6L},{7L,(-1L),0x57L,0x57L,(-1L),7L,(-4L),0xCAL,0x64L,0xEBL},{0xEBL,1L,0x46L,0xC9L,0xB1L,3L,7L,3L,0xB1L,0xC9L},{0xEBL,3L,0xEBL,0x95L,0xA6L,7L,0xC9L,0L,0x46L,0xCAL},{7L,0xC9L,0L,0x46L,0xCAL,0xCAL,0x46L,0L,0xC9L,7L},{(-1L),0x27L,0xEBL,1L,0x46L,0xC9L,0xB1L,3L,7L,3L},{0x64L,0xEBL,0x46L,0x27L,0x46L,0xEBL,0x64L,0xCAL,(-4L),7L},{0x46L,0xB1L,0x57L,0L,0xCAL,0xA6L,1L,1L,0xA6L,0xCAL},{(-4L),0xB1L,0xB1L,(-4L),0xA6L,0x46L,0x64L,7L,0x10L,0xC9L}};
    int i, j;
    return l_61[5][0];
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 94
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 10
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 17, occurrence: 1
   depth: 20, occurrence: 2
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 100

XXX times a variable address is taken: 209
XXX times a pointer is dereferenced on RHS: 32
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 38
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 342

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 80
   level: 2, occurrence: 35
   level: 3, occurrence: 16
   level: 4, occurrence: 4
XXX number of pointers point to pointers: 55
XXX number of pointers point to scalars: 45
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 38
XXX average alias set size: 1.27

XXX times a non-volatile is read: 360
XXX times a non-volatile is write: 119
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 47
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 11
   depth: 2, occurrence: 9
   depth: 3, occurrence: 5

XXX percentage a fresh-made variable is used: 14.8
XXX percentage an existing variable is used: 85.2
********************* end of statistics **********************/

