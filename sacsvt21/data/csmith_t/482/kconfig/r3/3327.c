/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2359183131
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const unsigned f0 : 12;
   signed f1 : 19;
   const signed f2 : 10;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_32(void);
inline static int32_t  func_36(struct S0  p_37, const int32_t  p_38, int32_t  p_39, int32_t  p_40);
static struct S0  func_41(int32_t  p_42, struct S0  p_43);
static uint16_t  func_45(int16_t  p_46);
inline static int16_t  func_47(int32_t  p_48);
inline static const float  func_55(float * p_56, float * p_57, struct S0  p_58);
static float * func_61(uint32_t  p_62, uint16_t  p_63, float  p_64);
static int32_t  func_76(const int32_t  p_77, int32_t  p_78, uint16_t  p_79, uint32_t  p_80);
inline static uint32_t  func_90(float * p_91, uint32_t  p_92, struct S0  p_93, int32_t  p_94);
inline static float * func_95(float * p_96, float * p_97, int32_t  p_98, int16_t  p_99, float  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_32(void)
{ /* block id: 36 */
    int16_t l_35 = 0xEFDB;
    struct S0 l_304 = {44,-625,-14};
    struct S0 *l_303 = &l_304;
    struct S0 **l_302 = &l_303;
    int32_t l_379 = (-1);
    int32_t *l_378 = &l_379;
    int32_t l_384 = 0x6E096090;
    int32_t **l_385 = &l_378;
    int16_t l_390 = 0xA384;
    uint32_t l_391 = 0xD83DB8F6;
    float l_392 = 0x7.5p-1;
    uint16_t l_393 = 1U;
    if (((uint16_t)l_35 + (uint16_t)__builtin_ffsll(l_35)))
    { /* block id: 37 */
        uint32_t l_49 = 4294967295U;
        struct S0 l_251 = {11,400,23};
        int32_t *l_380 = &l_379;
        if (func_36(func_41((+func_45(func_47(l_49))), l_251), (__builtin_bswap32(l_35) != ((l_302 == &l_303) <= l_251.f2)), l_251.f1, l_304.f2))
        { /* block id: 239 */
            int32_t l_364 = 0xF7FE5F9F;
            int32_t *l_363 = &l_364;
            int32_t **l_365 = &l_363;
            (*l_365) = l_363;
        }
        else
        { /* block id: 241 */
            float l_368 = (-0x3.5p+1);
            int32_t l_369 = 0;
            int32_t *l_374 = &l_369;
            int32_t ** const l_377 = &l_374;
            int32_t ** const *l_376 = &l_377;
            int32_t ** const **l_375 = &l_376;
            (*l_374) = __builtin_ctzll(((uint16_t)((l_369 >= ((int16_t)(l_304.f0 ^ ((int16_t)l_369 >> (int16_t)2)) << (int16_t)15)) > l_304.f0) - (uint16_t)0U));
            (*l_375) = (void*)0;
            /* statement id: 243 */
            assert (l_376 == 0);
            l_380 = l_378;
            (*l_380) = (-1);
        }
        for (l_49 = 0; (l_49 >= 22); ++l_49)
        { /* block id: 249 */
            int32_t l_383 = (-1);
            return l_383;
        }
    }
    else
    { /* block id: 252 */
        (*l_378) = l_384;
    }
    (*l_385) = &l_379;
    (**l_385) = ((*l_378) || (((uint16_t)((((uint16_t)(**l_385) >> (uint16_t)(**l_385)) || ((*l_378) == (((&l_303 != &l_303) < __builtin_bswap32(l_390)) <= __builtin_ctz(l_391)))) & 0x2A6B) % (uint16_t)(**l_385)) == (*l_378)));
    (*l_385) = (*l_385);
    return l_393;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_36(struct S0  p_37, const int32_t  p_38, int32_t  p_39, int32_t  p_40)
{ /* block id: 223 */
    int32_t *l_309 = (void*)0;
    int32_t l_325 = 0x68C0CF1E;
    uint32_t l_327 = 0U;
    int32_t *l_328 = &l_325;
    int32_t l_332 = 5;
    int32_t l_338 = 0x16781F76;
    struct S0 *l_348 = (void*)0;
    int32_t ***l_359 = (void*)0;
    int32_t ****l_358 = &l_359;
    for (p_40 = 0; (p_40 <= (-3)); p_40 -= 6)
    { /* block id: 226 */
        int32_t l_307 = 0x42813DB6;
        int32_t *l_308 = &l_307;
        const int32_t *l_311 = &l_307;
        const int32_t **l_310 = &l_311;
        int32_t ** const l_314 = (void*)0;
        int32_t ** const *l_313 = &l_314;
        int32_t l_326 = 1;
        (*l_308) = l_307;
        (*l_310) = l_309;
        /* statement id: 228 */
        assert (l_311 == 0);
        l_328 = func_61((!(((((&l_310 == l_313) | ((int16_t)((uint16_t)65535U >> (uint16_t)2) % (int16_t)((uint16_t)(*l_308) >> (uint16_t)13))) == ((((((uint16_t)__builtin_ctzl(((*l_313) == &l_309)) >> (uint16_t)(((uint16_t)p_40 >> (uint16_t)(p_37.f0 ^ 8)) || l_325)) && l_326) > p_39) != p_37.f0) | 1U)) > 0) >= 0x89D9E5B0)), p_39, l_327);
        /* statement id: 229 */
        assert (l_328 == 0);
    }
    /* facts after for loop */
    assert (l_328 == 0 || l_328 == &l_325);
    if (((0 == func_76(p_39, p_39, p_37.f0, p_37.f0)) ^ ((+(func_45((((int32_t)((l_332 >= ((uint16_t)((-(int16_t)((((uint16_t)(__builtin_parityl(p_38) || p_37.f2) >> (uint16_t)p_37.f0) & p_37.f1) == 0xF3639B91)) <= 0xC542) + (uint16_t)p_39)) != 1) + (int32_t)0x7696D7F7) > p_37.f1)) && 6)) & l_338)))
    { /* block id: 231 */
        float l_339 = 0xE.F1D413p+33;
        const int32_t l_340 = 0x6F1CC5E1;
        int32_t *l_351 = &l_325;
        l_325 = l_340;
        l_351 = func_61(((((p_38 || (((uint32_t)((int32_t)p_37.f0 - (int32_t)l_340) + (uint32_t)0xCCB1FC8B) ^ __builtin_parityl((~((int16_t)0xE0E3 << (int16_t)(&p_37 == l_348)))))) || ((int32_t)(p_40 != p_37.f1) % (int32_t)4)) != p_38) && 0), p_37.f0, p_37.f0);
        /* statement id: 233 */
        assert (l_351 == 0);
    }
    else
    { /* block id: 234 */
        float *l_352 = (void*)0;
        int32_t l_355 = 0xD96D8BCE;
        int32_t **l_357 = &l_309;
        int32_t *****l_360 = (void*)0;
        int32_t *** const *l_362 = &l_359;
        int32_t *** const **l_361 = &l_362;
        (*l_357) = func_95(l_352, func_61((p_40 & 0x15EC), ((uint32_t)p_37.f2 + (uint32_t)l_355), p_37.f0), (~(((0x7B21AB28 == 0x0F1C9B2D) || l_355) & p_37.f1)), p_39, p_37.f1);
        (*l_361) = l_358;
    }
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_41(int32_t  p_42, struct S0  p_43)
{ /* block id: 169 */
    float l_253 = 0x3.4D4D05p-37;
    float *l_252 = &l_253;
    float *l_254 = &l_253;
    int32_t l_270 = 0xE5330FB9;
    struct S0 *l_290 = (void*)0;
    const int32_t ** const * const **l_297 = (void*)0;
    uint32_t l_300 = 0xA7CE9A38;
lbl_280:
    (*l_254) = (l_252 == l_254);
    if (p_42)
    { /* block id: 171 */
        int16_t l_257 = 0;
        float *l_281 = &l_253;
        for (p_42 = 0; (p_42 >= (-16)); p_42--)
        { /* block id: 174 */
            struct S0 l_258 = {16,558,4};
            int32_t *l_279 = &l_270;
            if (l_257)
            { /* block id: 175 */
                return l_258;
            }
            else
            { /* block id: 177 */
                const float l_259 = 0x0.8p-1;
                float *l_262 = &l_253;
                int32_t l_267 = 0x2206D238;
                int32_t **l_287 = &l_279;
                (*l_254) = l_259;
                for (l_257 = 0; (l_257 < 12); ++l_257)
                { /* block id: 181 */
                    uint16_t l_268 = 6U;
                    int32_t *l_269 = &l_267;
                    (*l_269) = (func_90(l_262, p_42, l_258, (func_47(l_258.f2) <= ((1 != __builtin_clz(((int16_t)(0x9AE6 ^ (((int16_t)(-4) >> (int16_t)l_267) <= 0x0D0B)) - (int16_t)3U))) || l_267))) ^ l_268);
                }
                if ((l_270 <= (l_257 ^ l_258.f2)))
                { /* block id: 184 */
                    for (l_270 = 0; (l_270 == (-19)); l_270--)
                    { /* block id: 187 */
                        return p_43;
                    }
                }
                else
                { /* block id: 190 */
                    const int32_t *l_273 = &l_270;
                    int32_t *l_275 = &l_267;
                    int32_t **l_274 = &l_275;
                    (*l_274) = l_273;
                    /* statement id: 191 */
                    assert (l_275 == &l_270);
                    for (l_257 = 13; (l_257 == (-19)); --l_257)
                    { /* block id: 194 */
                        int32_t l_278 = 0x602BC950;
                    }
                    if (p_42)
                    { /* block id: 198 */
                        (*l_274) = (void*)0;
                        /* statement id: 199 */
                        assert (l_275 == 0);
                        (*l_274) = l_279;
                        /* statement id: 200 */
                        assert (l_275 == &l_270);
                        if (p_42)
                            goto lbl_280;
                        (*l_274) = func_95(l_281, l_275, func_45(((uint16_t)65531U - (uint16_t)p_42)), l_270, p_43.f1);
                        /* statement id: 202 */
                        assert (l_275 == 0);
                    }
                    else
                    { /* block id: 203 */
                        (*l_279) = ((p_43.f0 ^ ((uint32_t)((l_267 == (-(int16_t)p_43.f1)) | (p_43.f0 & (p_43.f0 != func_45(p_43.f1)))) - (uint32_t)(l_257 && p_43.f2))) | 0x17C768AC);
                    }
                    /* facts after branching */
                    assert (l_275 == &l_270 || l_275 == 0);
                }
                (*l_287) = &l_267;
                /* statement id: 207 */
                assert (l_279 == &l_267);
            }
            /* facts after branching */
            //assert (l_279 == dangling);
            if (l_258.f2)
                break;
        }
    }
    else
    { /* block id: 211 */
        struct S0 *l_291 = (void*)0;
        int32_t l_292 = 0x7FBE321F;
        (*l_254) = ((((((float)func_45(((l_290 == l_291) ^ p_43.f2)) - (float)p_43.f0) >= (p_42 != func_45(l_270))) != l_292) > p_43.f0) > p_43.f2);
    }
    for (l_270 = 17; (l_270 <= 18); l_270 += 3)
    { /* block id: 216 */
        const int32_t ** const * const *l_296 = (void*)0;
        const int32_t ** const * const **l_295 = &l_296;
        uint32_t l_301 = 4294967286U;
        if (p_43.f0)
            goto lbl_280;
        l_297 = l_295;
        /* statement id: 218 */
        assert (l_297 == &l_296);
        l_301 = (((float)0xA.5790A1p-47 + (float)l_300) == p_42);
        if (l_270)
            continue;
        //assert (l_297 == dangling);
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(int16_t  p_46)
{ /* block id: 159 */
    const int32_t *l_243 = (void*)0;
    const int32_t **l_244 = &l_243;
    (*l_244) = l_243;
    (*l_244) = (*l_244);
    if (p_46)
    { /* block id: 162 */
        return p_46;
    }
    else
    { /* block id: 164 */
        int32_t l_246 = 0;
        int32_t * const l_245 = &l_246;
        int32_t *l_248 = &l_246;
        int32_t **l_247 = &l_248;
        float l_250 = 0x4.AC05CEp+53;
        float *l_249 = &l_250;
        (*l_247) = l_245;
        (*l_249) = ((**l_247) == p_46);
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_47(int32_t  p_48)
{ /* block id: 38 */
    uint16_t l_50 = 0U;
    float l_60 = 0x9.8B7212p+39;
    float *l_59 = &l_60;
    float *l_68 = &l_60;
    float * const l_69 = (void*)0;
    l_50 = p_48;
    for (p_48 = 0; (p_48 == 17); ++p_48)
    { /* block id: 42 */
        float l_54 = 0x9.3p+1;
        float *l_53 = &l_54;
        int32_t l_65 = (-1);
        float *l_70 = &l_60;
        struct S0 l_238 = {37,-240,18};
        (*l_53) = p_48;
        (*l_59) = ((func_55(l_59, func_61(l_65, (((uint16_t)(l_68 == l_69) - (uint16_t)((void*)0 == l_70)) || (-1)), ((0xC.BE90AEp+59 == (((float)(0x1.C35C24p+56 != l_65) + (float)p_48) > l_50)) < 0x4.7p+1)), l_238) > l_50) == l_65);
    }
    for (l_50 = 0; (l_50 == 10); ++l_50)
    { /* block id: 155 */
        return p_48;
    }
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const float  func_55(float * p_56, float * p_57, struct S0  p_58)
{ /* block id: 148 */
    int32_t l_240 = 0x290427E7;
    int32_t *l_239 = &l_240;
    l_239 = p_57;
    /* statement id: 149 */
    assert (l_239 == 0);
    return (*p_56);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_61(uint32_t  p_62, uint16_t  p_63, float  p_64)
{ /* block id: 44 */
    uint16_t l_81 = 0xB0A7;
    float *l_101 = (void*)0;
    struct S0 l_185 = {52,-654,-30};
    const uint32_t l_199 = 0U;
    float l_210 = (-0x9.7p-1);
    uint32_t l_212 = 0x540B5EBE;
    int32_t l_219 = 1;
    int32_t *l_218 = &l_219;
    float *l_228 = &l_210;
    float *l_229 = (void*)0;
    float l_231 = 0x6.7DB962p+79;
    int32_t *l_233 = &l_219;
    float *l_236 = &l_210;
    float *l_237 = (void*)0;
    if ((!((int16_t)((func_76(p_63, l_81, ((((uint16_t)((uint32_t)((uint32_t)((int16_t)(func_90(func_95(l_101, l_101, l_81, l_81, p_63), (-(uint16_t)p_63), l_185, p_62) != l_81) << (int16_t)p_63) % (uint32_t)p_62) % (uint32_t)l_199) >> (uint16_t)l_81) || 0xAF1AC7F9) > (-1)), p_62) & l_199) == 4294967292U) >> (int16_t)0)))
    { /* block id: 116 */
        int32_t *l_211 = (void*)0;
        int32_t **l_213 = &l_211;
        l_212 = p_62;
        (*l_213) = (void*)0;
        l_185.f1 = (((uint16_t)(p_62 ^ l_199) + (uint16_t)1U) | p_62);
    }
    else
    { /* block id: 120 */
lbl_224:
        for (p_63 = 0; (p_63 == 39); p_63 += 1)
        { /* block id: 123 */
            l_218 = (void*)0;
            /* statement id: 124 */
            assert (l_218 == 0);
        }
    }
    /* facts after branching */
    assert (l_218 == 0 || l_218 == &l_219);
    if ((p_63 < 65530U))
    { /* block id: 127 */
        int32_t * const l_222 = &l_219;
        struct S0 *l_225 = &l_185;
        struct S0 **l_226 = &l_225;
        for (p_62 = 0; (p_62 != 10); p_62 += 5)
        { /* block id: 130 */
            int32_t **l_223 = &l_218;
            (*l_223) = l_222;
            /* statement id: 131 */
            assert (l_218 == &l_219);
            if (p_63)
                break;
        }
        if (p_63)
            goto lbl_224;
        (*l_226) = l_225;
    }
    else
    { /* block id: 136 */
        float *l_227 = &l_210;
        return l_229;
        /* statement id: 137 */
        //assert (func_61_rv == 0);
    }
    (*l_233) = (((((&l_219 != &l_219) < (~(l_199 == __builtin_ia32_crc32qi(p_63, l_199)))) <= l_219) > func_76(__builtin_ctzl((p_62 & (-(int32_t)p_62))), p_63, p_63, p_63)) != p_63);
    for (l_212 = 0; (l_212 > 60); l_212 += 3)
    { /* block id: 142 */
        if ((*l_233))
            break;
        if (p_63)
            continue;
        if (p_63)
            break;
    }
    return l_237;
    /* statement id: 147 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_76(const int32_t  p_77, int32_t  p_78, uint16_t  p_79, uint32_t  p_80)
{ /* block id: 101 */
    int32_t l_206 = 0xD1E382AB;
    int32_t *l_205 = &l_206;
    for (p_78 = 0; (p_78 >= 3); p_78++)
    { /* block id: 104 */
        float l_203 = 0x2.C777C1p+85;
        float *l_202 = &l_203;
        int32_t l_204 = 0xCC1AE132;
        int32_t **l_207 = &l_205;
        (*l_202) = p_77;
        if (l_204)
            continue;
        (*l_207) = l_205;
        if (((void*)0 != l_205))
        { /* block id: 108 */
            (**l_207) = ((*l_205) ^ ((int16_t)(**l_207) >> (int16_t)5));
            (*l_205) = ((l_207 == &l_205) < 1U);
        }
        else
        { /* block id: 111 */
            (*l_207) = &l_206;
        }
    }
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_90(float * p_91, uint32_t  p_92, struct S0  p_93, int32_t  p_94)
{ /* block id: 92 */
    uint32_t l_188 = 1U;
    int32_t *l_189 = (void*)0;
    int32_t **l_197 = (void*)0;
    int32_t **l_198 = &l_189;
    if ((((((uint16_t)l_188 >> (uint16_t)3) != l_188) & (l_188 > (((__builtin_ffsll(p_93.f0) == ((l_188 < ((l_188 < ((l_189 == l_189) && l_188)) ^ l_188)) > p_93.f1)) & p_94) || 0xA230))) <= l_188))
    { /* block id: 93 */
        return p_93.f1;
    }
    else
    { /* block id: 95 */
        uint32_t l_191 = 4294967290U;
        float *l_192 = (void*)0;
        float l_194 = 0x8.3CBDCBp-4;
        float *l_193 = &l_194;
        int32_t l_195 = 0x7A66F30B;
        int32_t **l_196 = &l_189;
        (*l_193) = (!__builtin_clzl(l_191));
        (*l_196) = func_95(p_91, l_189, p_92, ((p_94 ^ p_93.f0) > ((0x7482672F <= 0x9EEB4ECF) ^ ((l_189 != l_193) == p_93.f0))), l_195);
    }
    (*l_198) = p_91;
    /* statement id: 99 */
    //assert (l_189 == 0 || l_189 == &l_253);
    return p_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_95(float * p_96, float * p_97, int32_t  p_98, int16_t  p_99, float  p_100)
{ /* block id: 45 */
    uint32_t l_104 = 0x1A7E1F4F;
    int32_t l_115 = 0x44A59A1F;
    int32_t *l_114 = &l_115;
    float l_168 = (-0x2.0p+1);
    float *l_167 = &l_168;
    float *l_170 = &l_168;
    float *l_171 = &l_168;
    int32_t ***l_176 = (void*)0;
    float *l_180 = &l_168;
    float *l_181 = &l_168;
    float *l_182 = &l_168;
    float *l_183 = (void*)0;
    if (((int32_t)0xE40466E1 + (int32_t)l_104))
    { /* block id: 46 */
        int32_t l_106 = 0;
        int32_t *l_105 = &l_106;
        const float l_130 = 0x8.35A844p+78;
        const float *l_129 = &l_130;
        int32_t ** const *l_155 = (void*)0;
        int32_t ** const **l_154 = &l_155;
    }
    else
    { /* block id: 82 */
        float l_164 = 0x5.E2BAACp+90;
        float *l_163 = &l_164;
        float *l_165 = &l_164;
        float *l_166 = &l_164;
        float *l_169 = &l_164;
        float *l_172 = &l_164;
        float *l_173 = (void*)0;
        return l_173;
        /* statement id: 83 */
        //assert (func_95_rv == 0);
    }
    for (l_115 = 0; (l_115 != 13); ++l_115)
    { /* block id: 87 */
        int32_t ****l_177 = &l_176;
        (*l_177) = l_176;
    }
    (*l_114) = ((int16_t)(*l_114) << (int16_t)2);
    return l_183;
    /* statement id: 91 */
    //assert (func_95_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 116
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 9
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 4
breakdown:
   indirect level: 0, occurrence: 4
XXX times a bitfields struct's address is taken: 3
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 9
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 40

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 118
   depth: 2, occurrence: 21
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 108

XXX times a variable address is taken: 97
XXX times a pointer is dereferenced on RHS: 24
breakdown:
   depth: 1, occurrence: 19
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 57
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 2
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 123

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 111
   level: 2, occurrence: 14
   level: 3, occurrence: 1
   level: 4, occurrence: 0
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 39
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 34.3
XXX average alias set size: 1.18

XXX times a non-volatile is read: 364
XXX times a non-volatile is write: 145
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 108
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 42
   depth: 2, occurrence: 14
   depth: 3, occurrence: 5
   depth: 4, occurrence: 5
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 17.2
XXX percentage an existing variable is used: 82.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

