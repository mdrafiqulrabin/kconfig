/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1614797812
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int16_t  f0;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
static int32_t * func_5(int32_t * p_6, uint8_t  p_7, int32_t * p_8, int16_t  p_9, union U0  p_10);
inline static uint8_t  func_13(const int32_t * p_14, uint32_t  p_15, union U0  p_16);
inline static union U0  func_17(int32_t * p_18, int32_t * p_19, int16_t  p_20, union U0  p_21, int16_t  p_22);
inline static int32_t * func_23(int32_t * p_24, int32_t * p_25, uint32_t  p_26, uint8_t  p_27, const int32_t * p_28);
inline static uint32_t  func_29(int32_t * p_30, int32_t * const  p_31, const uint32_t  p_32, int32_t * p_33);
static int32_t * func_34(int32_t * const  p_35);
inline static int8_t  func_39(int8_t  p_40, int8_t  p_41, int32_t  p_42, int32_t * p_43);
static int32_t * func_62(int32_t * p_63, uint32_t  p_64);
static int32_t ** func_81(uint32_t  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x3D8DA8E9;
    int32_t l_4 = 0x074DD032;
    int32_t *l_3 = &l_4;
    int32_t * const l_444 = &l_4;
    const int32_t *l_501 = (void*)0;
    int32_t *l_504 = &l_4;
    union U0 l_505 = {4};
    int32_t **l_945 = &l_3;
    union U0 *l_951 = (void*)0;
    union U0 **l_950 = &l_951;
    int32_t l_954 = 0x3349A2C6;
    int32_t l_955 = 0x84C86D80;
    int8_t l_956 = 0x16;
    (*l_3) = l_2;
    (*l_945) = func_5(&l_4, ((safe_div_func_uint8_t_u_u(func_13(&l_4, (*l_3), func_17(func_23(&l_4, &l_4, func_29(func_34(&l_4), l_444, (*l_3), &l_4), (*l_3), l_501), l_504, (*l_3), l_505, (*l_3))), 5)) || (*l_504)), &l_4, (*l_444), l_505);
    (*l_945) = func_23((*l_945), (*l_945), (safe_lshift_func_int16_t_s_u((((*l_3) == (safe_sub_func_int8_t_s_s(((void*)0 != l_950), ((&l_945 != &l_945) != (*l_504))))) | (((safe_add_func_int8_t_s_s(((**l_945) | (*l_444)), 0xCF)) < l_954) & 0xF3)), 8)), l_955, (*l_945));
    (*l_945) = (*l_945);
    return l_956;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_5(int32_t * p_6, uint8_t  p_7, int32_t * p_8, int16_t  p_9, union U0  p_10)
{ /* block id: 331 */
    union U0 *l_676 = (void*)0;
    union U0 **l_675 = &l_676;
    int32_t l_686 = 0x48E87C62;
    int32_t l_742 = (-1);
    int32_t *** const l_749 = (void*)0;
    int32_t l_767 = 0x28662422;
    int32_t * const l_804 = (void*)0;
    int32_t * const * const l_803 = &l_804;
    int32_t * const * const *l_802 = &l_803;
    int32_t * const * const **l_801 = &l_802;
    int32_t * const * const *** const l_800 = &l_801;
    union U0 ****l_858 = (void*)0;
    int32_t l_865 = 0;
    int32_t l_944 = 1;
    (*l_675) = &p_10;
    /* statement id: 332 */
    assert (l_676 == &p_10);
    for (p_9 = 0; (p_9 > 27); p_9 = safe_add_func_int32_t_s_s(p_9, 1))
    { /* block id: 335 */
        uint8_t l_679 = 1U;
        int32_t *l_737 = &l_686;
        int8_t l_738 = (-4);
        uint8_t l_770 = 0xE3;
        union U0 l_819 = {0xA5E3};
        union U0 *l_818 = &l_819;
        uint16_t l_844 = 0xE399;
        int32_t **l_855 = &l_737;
        int32_t ***l_854 = &l_855;
        (*p_8) = ((l_679 <= 1) ^ (p_7 != (!(safe_add_func_uint16_t_u_u((~l_686), ((safe_lshift_func_int8_t_s_s(l_686, 1)) | (safe_div_func_uint32_t_u_u((safe_div_func_int32_t_s_s((l_686 != ((~(safe_lshift_func_uint8_t_u_u(((&p_8 != (void*)0) == (safe_div_func_int16_t_s_s(l_686, l_686))), 4))) == p_9)), l_679)), l_686))))))));
    }
    (*p_8) = ((safe_unary_minus_func_int16_t_s(((safe_div_func_uint32_t_u_u((safe_sub_func_int16_t_s_s((safe_add_func_int32_t_s_s((&p_8 != (***l_800)), (safe_sub_func_uint8_t_u_u(p_9, (1U || p_9))))), 0x423E)), (safe_rshift_func_int16_t_s_u(p_10.f0, (((((safe_add_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_u((safe_lshift_func_int16_t_s_s(((!(safe_rshift_func_int8_t_s_u((safe_add_func_int32_t_s_s(0x6A92AA2B, 0U)), p_10.f0))) ^ 0xDF701A50), p_9)), p_7)), p_7)) >= p_10.f0) | p_7) && p_9) == 0x596C))))) < p_10.f0))) ^ p_10.f0);
    (*p_8) = ((((safe_rshift_func_int8_t_s_s((safe_rshift_func_uint8_t_u_s((&l_676 == &l_676), 2)), (((((safe_add_func_int16_t_s_s(((safe_mod_func_uint32_t_u_u((&l_675 != &l_675), 0x91D28F1C)) <= (safe_sub_func_uint16_t_u_u((safe_lshift_func_uint8_t_u_s((~(safe_mod_func_int8_t_s_s((p_9 != p_10.f0), (safe_mod_func_int32_t_s_s((1U || ((void*)0 != &p_6)), p_7))))), p_7)), p_7))), p_7)) >= l_742) == p_7) || 0x88) && p_10.f0))) >= p_9) & l_944) != 0x0054AD97);
    return p_6;
    /* statement id: 437 */
    //assert (func_5_rv == &l_4);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_13(const int32_t * p_14, uint32_t  p_15, union U0  p_16)
{ /* block id: 327 */
    int32_t l_642 = 7;
    int8_t l_670 = 8;
    int32_t *l_671 = (void*)0;
    int32_t *l_672 = &l_642;
    int32_t *l_673 = (void*)0;
    int32_t **l_674 = &l_672;
    (*l_672) = (safe_rshift_func_uint8_t_u_u((safe_add_func_int32_t_s_s((!p_15), ((!((l_642 && ((safe_div_func_uint8_t_u_u((safe_unary_minus_func_int32_t_s((~(l_642 < (((safe_sub_func_int32_t_s_s(((l_642 ^ (safe_sub_func_int8_t_s_s(((p_16.f0 < (safe_mod_func_int8_t_s_s(((safe_mod_func_int32_t_s_s(((safe_add_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u(l_642, (safe_add_func_uint32_t_u_u(((~(safe_rshift_func_int16_t_s_s((safe_div_func_int16_t_s_s((1U <= ((((safe_div_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((p_16.f0 != l_642), 1U)), 0xF126)) | p_16.f0) == l_642) >= l_642)), l_642)), p_15))) | 0x4AB0EB29), (*p_14))))) < (-1)), p_16.f0)) | (*p_14)), 0xC441E3E0)) && p_16.f0), l_670))) == l_670), 0x52))) < 0xC612), (*p_14))) & l_670) != l_670))))), l_642)) != (-7))) > p_16.f0)) <= (*p_14)))), l_642));
    (*l_674) = l_673;
    /* statement id: 329 */
    assert (l_672 == 0);
    return p_16.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_17(int32_t * p_18, int32_t * p_19, int16_t  p_20, union U0  p_21, int16_t  p_22)
{ /* block id: 241 */
    int32_t l_509 = (-1);
    int32_t *l_508 = &l_509;
    int32_t ** const * const *l_523 = (void*)0;
    int32_t ** const * const **l_522 = &l_523;
    int32_t l_544 = 3;
    uint32_t l_633 = 1U;
    union U0 l_635 = {6};
    for (p_21.f1 = (-25); (p_21.f1 > 35); p_21.f1 = safe_add_func_int16_t_s_s(p_21.f1, 9))
    { /* block id: 244 */
        int32_t **l_510 = (void*)0;
        int32_t **l_511 = (void*)0;
        int32_t **l_512 = (void*)0;
        int32_t **l_513 = (void*)0;
        int8_t l_549 = 0x53;
        uint16_t l_550 = 0x617B;
        uint32_t l_559 = 0x7F859E74;
        int32_t ***l_574 = &l_511;
        int32_t ****l_573 = &l_574;
        int32_t ***** const l_572 = &l_573;
        int8_t l_575 = 1;
        p_19 = l_508;
        /* statement id: 245 */
        assert (p_19 == &l_509);
        for (p_20 = (-23); (p_20 == 15); ++p_20)
        { /* block id: 248 */
            return p_21;
            /* statement id: 249 */
                    }
    }
    /* facts after for loop */
    //assert (p_19 == &l_509 || p_19 == &l_4);
        return l_635;
    /* statement id: 326 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_23(int32_t * p_24, int32_t * p_25, uint32_t  p_26, uint8_t  p_27, const int32_t * p_28)
{ /* block id: 239 */
    int32_t l_503 = (-5);
    int32_t *l_502 = &l_503;
    return p_24;
    /* statement id: 240 */
    //assert (func_23_rv == &l_4 || func_23_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_29(int32_t * p_30, int32_t * const  p_31, const uint32_t  p_32, int32_t * p_33)
{ /* block id: 218 */
    int32_t l_445 = (-1);
    int32_t *l_495 = &l_445;
    int32_t **l_494 = &l_495;
    int32_t ***l_493 = &l_494;
    int32_t ****l_492 = &l_493;
    int32_t *****l_491 = &l_492;
    for (l_445 = 28; (l_445 == (-22)); l_445 = safe_sub_func_int32_t_s_s(l_445, 1))
    { /* block id: 221 */
        int32_t l_448 = 9;
        int32_t *l_464 = &l_445;
        int32_t **l_477 = (void*)0;
        const union U0 * const l_480 = (void*)0;
        int32_t *****l_496 = &l_492;
        uint32_t l_500 = 4294967295U;
        for (l_448 = 0; (l_448 > (-12)); l_448--)
        { /* block id: 224 */
            int32_t l_451 = 0xF2678B39;
            uint16_t l_454 = 65534U;
            int32_t l_475 = 5;
            int32_t **l_476 = &l_464;
            if ((*p_33))
                break;
            for (l_451 = 11; (l_451 < 12); l_451 = safe_add_func_int8_t_s_s(l_451, 1))
            { /* block id: 228 */
                return l_454;
            }
        }
        p_30 = &l_448;
        /* statement id: 234 */
        assert (p_30 == &l_448);
        (*p_30) = (*p_30);
        (*p_30) = (safe_div_func_int8_t_s_s(((void*)0 == l_480), (safe_sub_func_int8_t_s_s(((safe_mod_func_int16_t_s_s((safe_div_func_uint16_t_u_u((((safe_mod_func_uint16_t_u_u((~(((safe_unary_minus_func_uint16_t_u((p_32 != 255U))) >= (l_445 != (l_491 == l_496))) | ((((~1) ^ (safe_sub_func_uint16_t_u_u(65529U, p_32))) >= 1) <= 0U))), l_500)) != 7U) > (*****l_491)), 0x102E)), 0x010A)) && 1U), p_32))));
    }
    /* facts after for loop */
    //assert (p_30 == dangling || p_30 == 0);
    return p_32;
}


/* ------------------------------------------ */
/* 
 * reads : l_4
 * writes:
 */
static int32_t * func_34(int32_t * const  p_35)
{ /* block id: 2 */
    uint32_t l_38 = 4294967291U;
    int32_t *l_336 = (void*)0;
    int32_t ****l_382 = (void*)0;
    int32_t ***** const l_381 = &l_382;
    union U0 l_425 = {1};
    union U0 *l_424 = &l_425;
    uint32_t l_428 = 0xB465951A;
    int32_t l_431 = 0x94C77F9D;
    int32_t *l_430 = &l_431;
    int32_t *l_432 = &l_431;
    int32_t *l_433 = &l_431;
    int32_t *l_434 = &l_431;
    int32_t *l_435 = &l_431;
    int32_t *l_436 = &l_431;
    int32_t *l_437 = &l_431;
    int32_t *l_438 = &l_431;
    int32_t *l_439 = &l_431;
    int32_t *l_440 = &l_431;
    int32_t *l_441 = &l_431;
    int32_t *l_442 = &l_431;
    int32_t *l_443 = (void*)0;
    if ((p_35 != (void*)0))
    { /* block id: 3 */
        int8_t l_46 = 0x13;
        uint8_t l_50 = 2U;
        int32_t l_52 = (-1);
        int32_t *l_51 = &l_52;
        int32_t **l_335 = &l_51;
        (*l_51) = (safe_sub_func_int8_t_s_s(l_38, func_39(((void*)0 != p_35), ((safe_add_func_int16_t_s_s((l_46 != ((!((l_38 | (safe_add_func_uint8_t_u_u(l_46, l_50))) && 1)) || 1)), l_46)) != l_38), l_38, l_51)));
        (*l_335) = func_62(&l_52, (*l_51));
        return l_336;
        /* statement id: 184 */
        //assert (func_34_rv == 0);
    }
    else
    { /* block id: 185 */
        int32_t l_339 = (-2);
        int32_t l_345 = 0x3F3D5685;
        int32_t *l_344 = &l_345;
        int8_t l_347 = 0x97;
        union U0 l_407 = {0x59E4};
        union U0 *l_406 = &l_407;
        if (((safe_sub_func_uint8_t_u_u((l_339 > (*p_35)), l_339)) && (4294967286U | ((safe_add_func_int8_t_s_s(0x61, (l_339 > (safe_add_func_uint16_t_u_u(((l_336 != l_344) != (~l_38)), (*l_344)))))) | l_347))))
        { /* block id: 186 */
            int32_t **l_348 = &l_336;
            const union U0 l_357 = {0xAB12};
            const union U0 *l_356 = &l_357;
            const union U0 ** const l_355 = &l_356;
            int32_t l_380 = 0;
            (*l_348) = p_35;
            /* statement id: 187 */
            //assert (l_336 == &l_4 || l_336 == &l_544 || l_336 == &l_509 || l_336 == &l_767);
            (*l_344) = 0x4E46D7EC;
            for (l_38 = 0; (l_38 != 40); l_38 = safe_add_func_uint8_t_u_u(l_38, 8))
            { /* block id: 191 */
                union U0 l_368 = {2};
                union U0 *l_367 = &l_368;
                union U0 **l_366 = &l_367;
                int32_t l_408 = 0xFE2B2CAF;
                (*l_348) = &l_345;
                /* statement id: 192 */
                assert (l_336 == &l_345);
                for (l_345 = 29; (l_345 == 26); l_345 = safe_sub_func_uint16_t_u_u(l_345, 8))
                { /* block id: 195 */
                    uint16_t l_379 = 0x533C;
                    int32_t *****l_383 = (void*)0;
                    int32_t *l_405 = &l_380;
                    for (l_339 = (-16); (l_339 == (-16)); l_339 = safe_add_func_int8_t_s_s(l_339, 1))
                    { /* block id: 198 */
                        int32_t l_359 = 0;
                        int32_t *l_358 = &l_359;
                        (*l_358) = ((void*)0 != l_355);
                        l_380 = ((*l_336) && ((safe_lshift_func_uint8_t_u_u((((safe_div_func_uint8_t_u_u((((&l_356 == l_366) <= (((0xE61D < (safe_lshift_func_uint16_t_u_u(((*l_344) ^ ((~(safe_lshift_func_uint16_t_u_u(((*p_35) > (**l_348)), (((safe_unary_minus_func_uint16_t_u((safe_sub_func_uint32_t_u_u((**l_348), (safe_lshift_func_int8_t_s_s(((l_368.f0 < 0x5E6FC164) < 0xEE604584), (*l_358))))))) <= l_379) != (*l_336))))) == (*l_336))), l_368.f0))) != 0) > (-1))) == (*l_358)), (*l_336))) ^ (**l_348)) > (*l_358)), (**l_348))) || (**l_348)));
                        (*l_358) = 1;
                    }
                    l_383 = l_381;
                    /* statement id: 203 */
                    assert (l_383 == &l_382);
                    (*l_405) = (safe_lshift_func_int8_t_s_s((*l_344), (safe_div_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_s((safe_sub_func_int16_t_s_s((safe_unary_minus_func_uint8_t_u((0U == l_368.f0))), ((void*)0 != (*l_355)))), 4)), (safe_lshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_u(0x7F82, 1)), (((safe_mod_func_uint8_t_u_u(((safe_div_func_int16_t_s_s((safe_add_func_int8_t_s_s((safe_add_func_int32_t_s_s((*l_344), l_368.f0)), l_379)), 0x73E8)) | l_368.f0), l_368.f0)) <= (*p_35)) & 0x1F01)))))));
                    l_408 = (l_406 != &l_407);
                }
                if ((*l_336))
                    break;
                (**l_348) = ((**l_348) != 0x9EA3);
            }
            /* facts after for loop */
            //assert (l_336 == &l_345 || l_336 == &l_4 || l_336 == &l_544 || l_336 == &l_509 || l_336 == &l_767);
            (*l_348) = (*l_348);
        }
        else
        { /* block id: 211 */
            int32_t **l_409 = &l_344;
            union U0 **l_416 = (void*)0;
            int32_t *l_429 = &l_345;
            (*l_409) = p_35;
            /* statement id: 212 */
            //assert (l_344 == &l_4 || l_344 == &l_544 || l_344 == &l_509 || l_344 == &l_767);
            (*l_429) = (safe_lshift_func_int16_t_s_s((((safe_div_func_int16_t_s_s((((void*)0 == l_416) ^ ((((((safe_lshift_func_int8_t_s_s((((safe_unary_minus_func_uint8_t_u(((safe_lshift_func_int8_t_s_s(((((*l_344) > (*l_344)) && ((*l_344) & (((safe_sub_func_int32_t_s_s(((*l_344) != (l_424 == &l_407)), ((safe_add_func_uint16_t_u_u((**l_409), (**l_409))) & 0x12))) ^ (**l_409)) <= l_428))) & 0x1A9B2B1D), (**l_409))) > (*l_344)))) != (*l_344)) || (**l_409)), 0)) <= 252U) > 2) || 1U) || (**l_409)) != (**l_409))), (*l_344))) >= (**l_409)) ^ 0U), (*l_344)));
            (*l_429) = 0x72E1F03A;
        }
        /* facts after branching */
        //assert (l_336 == 0 || l_336 == &l_345 || l_336 == &l_4 || l_336 == &l_544 || l_336 == &l_509 || l_336 == &l_767);
        //assert (l_344 == &l_4 || l_344 == &l_345 || l_344 == &l_544 || l_344 == &l_509 || l_344 == &l_767);
    }
    /* facts after branching */
    //assert (l_336 == 0 || l_336 == dangling || l_336 == &l_4 || l_336 == &l_544 || l_336 == &l_509 || l_336 == &l_767);
    return l_443;
    /* statement id: 217 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_39(int8_t  p_40, int8_t  p_41, int32_t  p_42, int32_t * p_43)
{ /* block id: 4 */
    int32_t l_61 = 1;
    int32_t *l_60 = &l_61;
    for (p_40 = 0; (p_40 < (-30)); p_40 = safe_sub_func_uint32_t_u_u(p_40, 1))
    { /* block id: 7 */
        (*p_43) = (safe_mod_func_int8_t_s_s((0 | ((p_43 != (void*)0) < (safe_unary_minus_func_int8_t_s((safe_sub_func_int8_t_s_s(1, ((void*)0 != l_60))))))), 0xF4));
        return p_41;
    }
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_62(int32_t * p_63, uint32_t  p_64)
{ /* block id: 13 */
    int32_t l_72 = (-1);
    int32_t *l_71 = &l_72;
    int32_t l_74 = (-1);
    int32_t ***l_95 = (void*)0;
    int32_t ****l_94 = &l_95;
    int32_t *****l_110 = &l_94;
    const int16_t l_165 = 0x01EF;
    int16_t l_174 = (-1);
    int32_t *****l_271 = (void*)0;
    int32_t *l_333 = &l_72;
    return p_63;
    /* statement id: 182 */
    //assert (func_62_rv == &l_52 || func_62_rv == &l_509 || func_62_rv == &l_4 || func_62_rv == &l_686);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_81(uint32_t  p_82)
{ /* block id: 22 */
    const int32_t *l_86 = (void*)0;
    const int32_t **l_85 = &l_86;
    const int32_t ***l_84 = &l_85;
    int32_t *l_90 = (void*)0;
    int32_t **l_89 = &l_90;
    int32_t ***l_88 = &l_89;
    int32_t ****l_87 = &l_88;
    int32_t **l_91 = &l_90;
    int32_t **l_92 = (void*)0;
    (*l_87) = l_84;
    /* statement id: 23 */
    assert (l_88 == &l_85);
    return l_92;
    /* statement id: 24 */
    //assert (func_81_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 191
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 14
   depth: 3, occurrence: 1
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 199

XXX times a variable address is taken: 194
XXX times a pointer is dereferenced on RHS: 181
breakdown:
   depth: 1, occurrence: 145
   depth: 2, occurrence: 29
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 117
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 51
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 983

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 536
   level: 2, occurrence: 165
   level: 3, occurrence: 59
   level: 4, occurrence: 72
   level: 5, occurrence: 79
XXX number of pointers point to pointers: 106
XXX number of pointers point to scalars: 80
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.1
XXX average alias set size: 1.27

XXX times a non-volatile is read: 1021
XXX times a non-volatile is write: 321
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 60
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 13
   depth: 2, occurrence: 10
   depth: 3, occurrence: 5
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 15.2
XXX percentage an existing variable is used: 84.8
********************* end of statistics **********************/

