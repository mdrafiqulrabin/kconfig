/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2399630515
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 24;
   signed f1 : 15;
   unsigned f2 : 22;
   signed f3 : 9;
   unsigned f4 : 22;
   unsigned f5 : 23;
   signed f6 : 26;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_14 = 4294967295U;
static int32_t g_16 = 1;
static struct S0 g_33 = {3806,-157,1346,-15,1735,1145,3414};
static int32_t g_38 = 0xEE35D5D9;
static struct S0 *g_53 = &g_33;
static int32_t g_80[4] = {0,0,0,0};
static int32_t *g_79[3] = {&g_80[3],&g_80[3],&g_80[3]};
static struct S0 **g_104 = &g_53;
static struct S0 ***g_103[2][3] = {{&g_104,&g_104,(void*)0},{&g_104,&g_104,(void*)0}};
static int32_t **g_293[7] = {&g_79[2],&g_79[2],&g_79[1],&g_79[2],&g_79[2],&g_79[1],&g_79[2]};
static int32_t ***g_292 = &g_293[5];
static int32_t ****g_368 = &g_292;
static int32_t *****g_367 = &g_368;
static int32_t g_373 = 0x4B42F1D9;
static const int32_t *g_530 = &g_80[3];
static uint8_t g_624 = 255U;
static struct S0 ****g_632 = &g_103[1][0];
static struct S0 *****g_631 = &g_632;
static struct S0 g_659 = {3555,107,2002,-7,1988,1922,-3592};
static int32_t *g_725 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_1(void);
static int32_t  func_2(uint16_t  p_3, uint32_t  p_4, int32_t  p_5, const int16_t  p_6);
static uint16_t  func_7(const int8_t  p_8, int32_t  p_9, uint32_t  p_10);
static const int32_t * func_19(int16_t  p_20);
static int16_t  func_21(int16_t  p_22);
inline static int16_t  func_23(struct S0  p_24, uint32_t  p_25);
static uint32_t  func_27(int32_t * p_28, struct S0  p_29, uint32_t  p_30, const uint32_t  p_31);
static int32_t  func_34(uint16_t  p_35);
inline static uint32_t  func_43(int32_t * p_44, const int32_t  p_45, const int32_t * const  p_46, int32_t * const  p_47);
static int32_t * func_48(int32_t * p_49);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_14 g_16 g_104 g_367 g_368 g_292 g_293 g_79 g_80 g_33.f3 g_33.f0 g_33 g_38 g_624 g_631 g_373 g_659 g_632 g_725 g_530
 * writes: g_16 g_53 g_79 g_80 g_14 g_368 g_38 g_373 g_631 g_659
 */
static uint8_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_11 = 0x6141E4F1;
    int32_t *l_865 = &g_373;
    struct S0 l_866[10] = {{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676},{3107,48,543,-9,1731,1399,5676}};
    struct S0 *****l_897 = &g_632;
    int i;
    if (func_2(((0U && func_7((l_11 & 1), (safe_lshift_func_int8_t_s_u(g_14, 2)), g_14)) || l_11), l_11, (g_80[0] ^ l_11), g_33.f6))
    { /* block id: 718 */
        uint32_t l_875 = 4294967295U;
        int32_t *l_895 = &g_80[3];
        for (g_373 = 0; (g_373 <= (-2)); g_373 = safe_sub_func_int32_t_s_s(g_373, 9))
        { /* block id: 721 */
            struct S0 l_867[7] = {{3038,98,1696,-7,214,57,3028},{3038,98,1696,-7,214,57,3028},{3038,98,1696,-7,214,57,3028},{3038,98,1696,-7,214,57,3028},{3038,98,1696,-7,214,57,3028},{3038,98,1696,-7,214,57,3028},{3038,98,1696,-7,214,57,3028}};
            int32_t l_884 = 0x1238DD0B;
            struct S0 ***** const l_892 = (void*)0;
            int i;
            (**g_292) = l_865;
            l_867[2] = l_866[0];
            if ((65535U > g_373))
            { /* block id: 724 */
                return l_867[2].f5;
            }
            else
            { /* block id: 726 */
                uint8_t l_874[6] = {0xA3,0xA3,0xA3,0xA3,0xA3,0xA3};
                int32_t *l_876 = &g_80[2];
                int i;
                (*l_876) = ((((*l_865) >= (0U <= (safe_lshift_func_uint16_t_u_s((safe_rshift_func_int8_t_s_u(g_33.f5, ((g_33.f4 ^ (safe_lshift_func_uint16_t_u_u(((*l_865) == ((void*)0 != &g_632)), 1))) || l_874[3]))), 7)))) ^ l_875) ^ g_33.f4);
                for (l_11 = 0; (l_11 == 11); l_11 = safe_add_func_int16_t_s_s(l_11, 2))
                { /* block id: 730 */
                    uint32_t l_879[7] = {0x149E87CC,0x149E87CC,0U,0U,0U,0x149E87CC,0U};
                    int i;
                    return l_879[2];
                }
                (****g_367) = l_865;
                (*l_876) = (safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s((l_884 && (safe_mod_func_int32_t_s_s((0xFD ^ (g_659.f2 && ((*g_530) > (((+((safe_lshift_func_uint16_t_u_s(0xED84, g_373)) & (l_892 != (void*)0))) ^ (safe_mod_func_uint16_t_u_u((8U | g_38), 0x3B54))) & 0x4D)))), 1))), l_884)), g_659.f0));
            }
        }
        /* facts after for loop */
        //assert (g_79[0] == &g_373 || g_79[0] == dangling || g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
        (***g_368) = l_895;
    }
    else
    { /* block id: 738 */
        int32_t *l_896 = &g_80[3];
        l_865 = l_896;
        /* statement id: 739 */
        assert ((l_865 >= &g_80[0] && l_865 <= &g_80[3]));
        l_897 = &g_632;
    }
    /* facts after branching */
    //assert (g_53 == &g_33 || g_53 == dangling);
    //assert (g_79[0] == &g_373 || g_79[0] == dangling || g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
    //assert (g_631 == dangling || g_631 == &g_632);
    assert ((l_865 >= &g_80[0] && l_865 <= &g_80[3]) || l_865 == &g_373);
    (*g_104) = &l_866[6];
    /* statement id: 742 */
    assert ((g_53 >= &l_866[0] && g_53 <= &l_866[9]));
    return g_659.f4;
    /* statement id: 743 */
    //assert (g_53 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_292 g_293 g_79 g_16 g_80 g_14 g_33.f6 g_33.f5 g_367 g_368 g_38 g_624 g_631 g_33 g_373 g_659 g_632 g_725
 * writes: g_16 g_80 g_14 g_79 g_53 g_368 g_38 g_373 g_631 g_659
 */
static int32_t  func_2(uint16_t  p_3, uint32_t  p_4, int32_t  p_5, const int16_t  p_6)
{ /* block id: 448 */
    uint16_t l_550 = 1U;
    struct S0 ** const *l_572 = (void*)0;
    struct S0 ** const ** const l_571 = &l_572;
    int32_t ****l_583 = &g_292;
    struct S0 * const ****l_602 = (void*)0;
    struct S0 l_660 = {643,-27,1956,5,642,2580,3814};
    uint32_t l_674[1][3];
    uint8_t l_675 = 255U;
    struct S0 ****l_701 = &g_103[1][0];
    uint32_t l_702 = 0x25AC8A32;
    uint8_t l_723 = 0x0A;
    int32_t *l_746 = &g_373;
    int32_t ***l_825[9] = {&g_293[0],&g_293[0],&g_293[0],&g_293[0],&g_293[0],&g_293[0],&g_293[0],&g_293[0],&g_293[0]};
    uint8_t l_850 = 249U;
    int i, j;
    for (i = 0; i < 1; i = i + 1)
    {
        for (j = 0; j < 3; j = j + 1)
            l_674[i][j] = 4294967289U;
    }
    for (p_4 = 1; (p_4 <= 6); p_4 += 1)
    { /* block id: 451 */
        int32_t ****l_555 = &g_292;
        const int16_t l_601 = 0x6A39;
        struct S0 ***l_623[7] = {&g_104,&g_104,&g_104,&g_104,&g_104,&g_104,&g_104};
        const struct S0 *l_627 = &g_33;
        struct S0 *****l_633 = &g_632;
        int32_t *l_636 = &g_373;
        uint16_t l_678 = 0x5145;
        int32_t l_690[2];
        int8_t l_717[2];
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_690[i] = 0x9B95EB40;
        for (i = 0; i < 2; i = i + 1)
            l_717[i] = 0xFD;
        for (p_3 = 1; (p_3 <= 6); p_3 += 1)
        { /* block id: 454 */
            int32_t *l_545 = &g_16;
            struct S0 * const *l_558 = &g_53;
            struct S0 * const ** const l_557 = &l_558;
            struct S0 * const ** const *l_556 = &l_557;
            uint32_t l_579[8] = {0x520135E2,0x520135E2,0x520135E2,0x520135E2,0x520135E2,0x520135E2,0x520135E2,0x520135E2};
            int i;
        }
        (****l_555) = (((****l_583) != (****l_555)) != (((safe_add_func_uint16_t_u_u(0xE7D8, ((safe_sub_func_int32_t_s_s((&p_5 == (***l_583)), ((safe_rshift_func_int16_t_s_s(((+l_601) <= (0x0048 >= p_6)), (****l_583))) | p_5))) < g_14))) != p_6) && 0x39F22717));
        if (((l_602 != &l_571) >= ((safe_mod_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((****l_555), (****l_583))), g_33.f6)) & g_33.f5)))
        { /* block id: 496 */
            const struct S0 *** const *l_629 = (void*)0;
            const struct S0 *** const ** const l_628 = &l_629;
            int32_t ****l_635 = &g_292;
            if ((safe_sub_func_uint16_t_u_u(1U, (safe_rshift_func_uint16_t_u_s(((safe_lshift_func_uint16_t_u_u(((****l_555) || 0x093967D4), 7)) >= (****l_555)), ((safe_mod_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(((void*)0 == (***g_367)), 65535U)), (safe_rshift_func_int8_t_s_u(0xE7, ((****l_583) <= g_14))))) == p_5))))))
            { /* block id: 497 */
                int i;
                (****l_583) = 0xE1C12C69;
            }
            else
            { /* block id: 499 */
                (*****g_367) = (g_80[3] || (safe_rshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_u(((void*)0 != l_623[1]), (****l_583))), g_38)));
            }
            for (g_14 = 0; (g_14 <= 1); g_14 += 1)
            { /* block id: 504 */
                const struct S0 *l_625 = &g_33;
                int32_t *l_637 = (void*)0;
                int8_t l_650 = 0xA5;
                int32_t **** const *l_652 = &l_635;
                struct S0 l_656 = {2911,55,380,-11,1442,2201,-143};
                struct S0 ****l_667 = &l_623[1];
                (***g_368) = &p_5;
                for (p_3 = 0; (p_3 <= 1); p_3 += 1)
                { /* block id: 508 */
                    const struct S0 *** const **l_630 = &l_629;
                    int32_t *l_634[4][9][7] = {{{(void*)0,&g_80[3],&g_80[1],&g_80[3],&g_38,&g_80[2],(void*)0},{&g_373,&g_373,(void*)0,&g_38,&g_38,&g_80[3],(void*)0},{&g_38,&g_80[3],&g_80[3],&g_38,&g_373,&g_80[3],&g_16},{&g_373,(void*)0,&g_373,&g_80[0],&g_38,(void*)0,&g_16},{&g_80[3],&g_373,(void*)0,&g_16,&g_16,&g_16,(void*)0},{&g_38,&g_38,&g_80[1],&g_373,&g_38,&g_80[3],(void*)0},{&g_38,(void*)0,(void*)0,&g_373,&g_80[2],&g_373,&g_373},{&g_80[3],&g_80[3],&g_16,&g_38,&g_38,&g_80[3],(void*)0},{&g_38,(void*)0,&g_80[3],&g_80[0],&g_16,&g_80[1],(void*)0}},{{&g_373,(void*)0,&g_80[1],&g_373,&g_38,&g_16,&g_38},{&g_373,&g_38,&g_80[1],&g_373,&g_373,&g_80[3],&g_80[3]},{&g_38,&g_38,&g_80[3],&g_38,&g_38,&g_80[3],&g_373},{&g_38,(void*)0,&g_16,&g_373,&g_38,&g_16,&g_16},{&g_80[1],&g_16,(void*)0,&g_373,&g_16,&g_38,(void*)0},{&g_38,&g_373,&g_80[1],&g_38,&g_80[3],&g_80[3],&g_38},{&g_38,&g_80[3],(void*)0,&g_373,&g_38,&g_373,&g_38},{&g_373,&g_38,&g_373,&g_38,(void*)0,&g_373,(void*)0},{&g_373,(void*)0,&g_80[3],&g_373,&g_373,&g_80[3],(void*)0}},{{&g_38,(void*)0,(void*)0,&g_80[3],&g_38,&g_38,&g_80[3]},{&g_80[3],&g_373,&g_80[1],&g_16,(void*)0,&g_16,(void*)0},{&g_38,(void*)0,&g_80[1],&g_80[3],&g_373,&g_80[3],&g_38},{&g_38,(void*)0,&g_373,&g_373,&g_80[2],&g_80[3],&g_373},{&g_80[3],&g_16,&g_16,&g_38,&g_373,&g_16,(void*)0},{&g_373,&g_16,&g_16,(void*)0,&g_80[2],&g_38,&g_80[2]},{(void*)0,&g_80[3],&g_80[3],(void*)0,&g_80[1],&g_80[2],&g_16},{&g_16,&g_38,(void*)0,&g_38,&g_16,&g_16,&g_80[1]},{&g_38,&g_16,&g_16,&g_80[3],&g_80[1],&g_373,&g_16}},{{&g_373,&g_80[3],&g_80[2],&g_16,(void*)0,&g_80[3],&g_80[2]},{&g_80[3],&g_80[3],(void*)0,&g_38,&g_80[3],&g_80[3],&g_80[3]},{(void*)0,&g_16,&g_38,&g_373,&g_80[3],&g_80[0],&g_80[3]},{&g_80[1],&g_80[1],(void*)0,&g_80[3],(void*)0,&g_80[1],&g_80[1]},{&g_16,&g_80[3],&g_80[3],(void*)0,&g_80[1],&g_80[3],&g_80[3]},{(void*)0,&g_373,&g_80[0],&g_16,&g_16,&g_80[0],&g_80[2]},{&g_16,&g_80[3],&g_80[3],(void*)0,&g_80[1],&g_80[3],&g_80[3]},{&g_80[2],&g_16,(void*)0,&g_80[3],&g_80[2],&g_80[2],&g_80[3]},{&g_38,(void*)0,&g_38,&g_80[3],&g_80[3],&g_373,(void*)0}}};
                    int i, j, k;
                    for (g_16 = 1; (g_16 >= 0); g_16 -= 1)
                    { /* block id: 511 */
                        const struct S0 **l_626[1][3][2] = {{{(void*)0,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0}}};
                        int i, j, k;
                        if (g_624)
                            break;
                        l_627 = l_625;
                        l_630 = l_628;
                        l_633 = g_631;
                    }
                    (**g_292) = func_48(l_634[3][8][4]);
                    /* statement id: 517 */
                    //assert (g_53 == dangling);
                    (*g_367) = l_635;
                    for (g_38 = 0; (g_38 <= 1); g_38 += 1)
                    { /* block id: 521 */
                        const uint32_t l_651[10][3] = {{4294967295U,4294967295U,4294967295U},{0xE16C0625,4294967295U,4294967295U},{4294967295U,4294967295U,4294967295U},{0xE16C0625,4294967295U,4294967295U},{4294967295U,4294967295U,4294967295U},{0xE16C0625,4294967295U,4294967295U},{4294967295U,4294967295U,4294967295U},{0xE16C0625,4294967295U,4294967295U},{4294967295U,4294967295U,4294967295U},{0xE16C0625,4294967295U,4294967295U}};
                        int i, j;
                        l_637 = l_636;
                        /* statement id: 522 */
                        assert (l_637 == &g_373);
                        (*l_637) = (((*l_636) >= 0x4A) >= ((safe_rshift_func_uint16_t_u_u(65535U, (((safe_add_func_uint32_t_u_u(((****l_555) == (safe_lshift_func_int16_t_s_s(p_5, ((((safe_rshift_func_int8_t_s_u(((((safe_lshift_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u(0x341E, p_3)), 6)) | (((**l_555) == (***g_367)) && g_38)) > 0) <= g_33.f6), 2)) | l_650) >= 1) <= (-1))))), l_651[0][0])) && p_5) != p_3))) & (****l_555)));
                    }
                }
                /* facts after for loop */
                assert (l_637 == &g_373 || l_637 == 0);
                if ((l_652 == &l_583))
                { /* block id: 526 */
                    struct S0 l_655 = {2147,42,102,-15,1047,531,4812};
                    for (g_38 = 0; (g_38 <= 1); g_38 += 1)
                    { /* block id: 529 */
                        int i, j;
                        (*****g_367) = (safe_lshift_func_int8_t_s_s(0, 5));
                        l_656 = l_655;
                        (****l_635) = (safe_sub_func_uint16_t_u_u((****l_583), g_624));
                        l_660 = g_659;
                    }
                    (****g_368) = (*****g_367);
                    p_5 = (safe_rshift_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u((~g_624), (((((****l_635) && (safe_unary_minus_func_int16_t_s((l_667 != (*l_628))))) ^ 0x98) | (safe_mod_func_uint16_t_u_u((9 != p_5), (4U || 0x3FC4)))) || g_16))) == 6U), 7));
                }
                else
                { /* block id: 537 */
                    for (p_3 = 0; (p_3 <= 1); p_3 += 1)
                    { /* block id: 540 */
                        int32_t l_670[7][9][2] = {{{0xE08FC5A3,(-1)},{0xC9734934,0xC9734934},{(-6),5},{0x77F21C8E,0x7E0EC1D3},{0xF227AC1E,0},{0x3E8C0B43,0xF227AC1E},{0x0482FC9F,0xC9734934},{0x0482FC9F,0xF227AC1E},{0x3E8C0B43,0}},{{0xF227AC1E,0x7E0EC1D3},{0x77F21C8E,5},{(-6),0xC9734934},{0xC9734934,(-1)},{0xE08FC5A3,1},{0xF227AC1E,(-4)},{0,0xB36CBB59},{(-1),0xC9734934},{0,0x3253FCC9}},{{0x14720AE2,5},{0xF227AC1E,5},{0x14720AE2,0x3253FCC9},{0,0xC9734934},{(-1),0xB36CBB59},{0,(-4)},{0xF227AC1E,1},{0xE08FC5A3,(-1)},{0xC9734934,0xC9734934}},{{(-6),5},{0x77F21C8E,0x7E0EC1D3},{0xF227AC1E,0},{0x3E8C0B43,0xF227AC1E},{0x0482FC9F,0xC9734934},{0x0482FC9F,0x14720AE2},{0,0},{0x14720AE2,(-1)},{(-9),0}},{{5,0xF227AC1E},{0xF227AC1E,0xE08FC5A3},{0xDA35EF6E,0xC9734934},{0x14720AE2,(-6)},{0xC9F72837,0x77F21C8E},{(-1),0xF227AC1E},{0xB36CBB59,0x3E8C0B43},{0,0x0482FC9F},{0x14720AE2,0x0482FC9F}},{{0,0x3E8C0B43},{0xB36CBB59,0xF227AC1E},{(-1),0x77F21C8E},{0xC9F72837,(-6)},{0x14720AE2,0xC9734934},{0xDA35EF6E,0xE08FC5A3},{0xF227AC1E,0xF227AC1E},{5,0},{(-9),(-1)}},{{0x14720AE2,0},{0,0x14720AE2},{0x3253FCC9,0xF227AC1E},{0x3253FCC9,0x14720AE2},{0,0},{0x14720AE2,(-1)},{(-9),0},{5,0xF227AC1E},{0xF227AC1E,0xE08FC5A3}}};
                        int i, j, k;
                        l_670[2][2][0] = (****l_583);
                    }
                    (****l_555) = 0x13F36663;
                }
                if (p_4)
                    break;
            }
            /* facts after for loop */
            assert (l_633 == &l_701 || l_633 == &g_632);
            (***g_292) = 9;
            (***g_292) = p_3;
        }
        else
        { /* block id: 549 */
            (****g_368) = (g_80[3] || g_659.f6);
        }
        /* facts after branching */
        assert (l_633 == &l_701 || l_633 == &g_632);
        for (g_14 = 0; (g_14 <= 1); g_14 += 1)
        { /* block id: 554 */
            uint16_t l_673 = 0x2300;
            struct S0 l_677 = {3756,-172,10,-3,718,894,3158};
            struct S0 *****l_724 = &l_701;
            for (g_373 = 1; (g_373 >= 0); g_373 -= 1)
            { /* block id: 557 */
                int32_t *l_679 = (void*)0;
            }
            for (g_38 = 1; (g_38 >= 0); g_38 -= 1)
            { /* block id: 600 */
                const struct S0 *l_688[10][5] = {{&l_660,&l_677,(void*)0,&l_677,&l_677},{&g_659,(void*)0,&g_659,&l_677,&g_659},{&l_677,&l_660,&g_659,(void*)0,&l_660},{(void*)0,&g_659,&l_677,&l_677,&g_659},{&g_659,&g_33,&g_659,&l_660,&l_660},{&l_677,&l_660,&g_659,&g_659,&l_660},{&g_659,&l_660,(void*)0,&l_677,&g_659},{&g_33,&g_33,&l_660,(void*)0,(void*)0},{&g_659,&g_659,&g_33,&g_659,&g_33},{&g_33,&l_660,&l_677,&l_677,(void*)0}};
                const struct S0 **l_689 = &l_688[5][0];
                int i, j;
                (*l_689) = l_688[5][0];
            }
            p_5 = ((1 > (l_690[1] != 0x69)) ^ ((((((((safe_add_func_int16_t_s_s((safe_add_func_uint8_t_u_u((g_659.f5 >= (g_33.f1 <= ((safe_mod_func_uint32_t_u_u(l_673, (safe_mod_func_uint16_t_u_u(0xD98F, g_33.f6)))) >= (((void*)0 != l_701) == p_3)))), l_677.f4)), (****l_555))) >= p_3) != g_14) > (*l_636)) && g_659.f4) >= (****l_583)) ^ (-3)) >= p_3));
            if (l_702)
            { /* block id: 604 */
                int32_t *l_718 = &g_373;
                (****g_368) = (p_5 <= ((*g_367) != (void*)0));
                if (p_6)
                { /* block id: 606 */
                    uint32_t l_716[8] = {5U,5U,4294967295U,5U,5U,4294967295U,5U,5U};
                    int i;
                    if ((*l_636))
                    { /* block id: 607 */
                        struct S0 l_719[7] = {{2815,160,380,-7,214,1088,-6753},{3386,-112,1584,-7,1091,1386,-3079},{2815,160,380,-7,214,1088,-6753},{2815,160,380,-7,214,1088,-6753},{3386,-112,1584,-7,1091,1386,-3079},{2815,160,380,-7,214,1088,-6753},{2815,160,380,-7,214,1088,-6753}};
                        int i;
                        (***g_292) = ((((*g_631) != (void*)0) | 0x8B4E1667) || ((((safe_rshift_func_uint8_t_u_s((safe_lshift_func_uint8_t_u_u(((&l_571 == l_633) && (safe_mod_func_int32_t_s_s(((1 && ((safe_add_func_int16_t_s_s((safe_unary_minus_func_uint32_t_u(((g_659.f6 <= 0x60E2) == (safe_rshift_func_uint8_t_u_s((safe_mod_func_int32_t_s_s((p_3 ^ p_3), p_3)), p_6))))), 0xFB63)) > g_33.f4)) || g_33.f6), l_716[5]))), g_659.f3)), g_33.f4)) ^ p_3) != (****l_555)) > l_717[0]));
                        l_677 = l_677;
                        (***g_368) = func_48(l_718);
                        /* statement id: 610 */
                        //assert (g_53 == dangling);
                        l_719[2] = l_677;
                    }
                    else
                    { /* block id: 612 */
                        struct S0 l_720[4][2] = {{{3847,-57,1716,20,1434,639,2152},{3847,-57,1716,20,1434,639,2152}},{{1249,0,227,7,1236,2695,-3461},{3847,-57,1716,20,1434,639,2152}},{{3847,-57,1716,20,1434,639,2152},{1249,0,227,7,1236,2695,-3461}},{{3847,-57,1716,20,1434,639,2152},{3847,-57,1716,20,1434,639,2152}}};
                        int i, j;
                        (***l_583) = (***l_555);
                        l_660 = l_720[3][1];
                        return (*l_718);
                        /* statement id: 615 */
                        //assert (g_79[0] == dangling || g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
                        //assert (g_631 == dangling || g_631 == &g_632);
                    }
                    /* facts after branching */
                    //assert (g_53 == dangling);
                    (****g_368) = (safe_rshift_func_int16_t_s_u(l_723, 6));
                }
                else
                { /* block id: 618 */
                    g_631 = l_724;
                    /* statement id: 619 */
                    assert (g_631 == &l_701);
                    (***g_368) = func_48(g_725);
                    /* statement id: 620 */
                    //assert (g_53 == dangling);
                    if (l_677.f0)
                        continue;
                    for (l_550 = 0; (l_550 <= 1); l_550 += 1)
                    { /* block id: 624 */
                        return p_4;
                        /* statement id: 625 */
                        //assert (g_79[0] == dangling || g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
                        //assert (g_631 == dangling);
                    }
                }
                /* facts after branching */
                //assert (g_53 == dangling);
                (***l_555) = &p_5;
                (***g_292) = (safe_add_func_int32_t_s_s(p_5, (((g_33.f6 == ((-1) && l_673)) && (****l_583)) || (safe_unary_minus_func_uint16_t_u(g_33.f2)))));
            }
            else
            { /* block id: 630 */
                uint8_t l_733 = 0xEE;
                for (g_16 = 1; (g_16 >= 0); g_16 -= 1)
                { /* block id: 633 */
                    int32_t l_730 = 0x4C38C3E9;
                    struct S0 *l_736 = &l_660;
                    if (l_677.f4)
                        break;
                    (*l_636) = (~(l_730 & ((safe_lshift_func_int16_t_s_u(((l_733 == (safe_add_func_int32_t_s_s((****g_368), (((void*)0 == l_736) ^ ((***g_368) == (void*)0))))) != p_5), p_6)) > l_733)));
                }
            }
        }
    }
    /* facts after for loop */
    //assert (g_79[0] == &p_5 || g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
    assert (g_631 == &l_701 || g_631 == &g_632);
    if (((safe_lshift_func_uint16_t_u_u((safe_mod_func_int8_t_s_s((safe_add_func_uint16_t_u_u((****l_583), (p_3 >= (****l_583)))), (((****l_583) <= (!((&l_571 != &g_632) || ((****l_583) || (****l_583))))) && (p_3 <= 0x7E)))), g_659.f3)) <= (****l_583)))
    { /* block id: 640 */
        int32_t **l_753 = &g_79[1];
        struct S0 ** const **l_757 = &l_572;
        int32_t ** const **l_806 = (void*)0;
        for (l_675 = 0; (l_675 >= 19); l_675 = safe_add_func_uint32_t_u_u(l_675, 1))
        { /* block id: 643 */
            int16_t l_758 = 0x95A9;
            struct S0 *l_771[8][3] = {{&g_659,&l_660,&g_33},{&l_660,&g_659,&g_659},{&l_660,&g_659,&g_33},{&g_33,(void*)0,&g_659},{&g_33,&l_660,&l_660},{&l_660,&g_33,&l_660},{&l_660,&l_660,&g_33},{&g_659,(void*)0,&g_33}};
            struct S0 *****l_783 = &l_701;
            int32_t *****l_790 = (void*)0;
            int i, j;
            (***g_292) = (((****l_583) > p_5) <= 0x3884);
            (***l_583) = func_48(func_48(l_746));
            /* statement id: 645 */
            //assert (g_53 == dangling);
            (****l_583) = ((safe_rshift_func_uint8_t_u_s((safe_add_func_uint8_t_u_u(g_659.f4, ((p_3 & (safe_lshift_func_uint16_t_u_u(p_3, ((l_753 == (*g_292)) < (253U == (p_3 >= (safe_add_func_uint8_t_u_u((((p_3 > (~(l_757 == l_757))) <= p_5) == (****l_583)), g_373)))))))) == g_38))), l_758)) == p_5);
        }
    }
    else
    { /* block id: 692 */
        for (l_702 = 0; (l_702 == 26); l_702 = safe_add_func_int32_t_s_s(l_702, 5))
        { /* block id: 695 */
            for (p_4 = 0; (p_4 != 16); ++p_4)
            { /* block id: 698 */
                struct S0 l_861 = {1067,-96,755,-11,194,2023,2513};
                struct S0 *l_862 = &g_659;
                for (l_550 = 0; (l_550 == 24); l_550 = safe_add_func_int16_t_s_s(l_550, 1))
                { /* block id: 701 */
                    if (p_6)
                        break;
                    for (g_373 = 8; (g_373 >= 0); g_373 -= 1)
                    { /* block id: 705 */
                        struct S0 l_860[8] = {{3274,-110,1958,-12,2038,951,-4343},{3274,-110,1958,-12,2038,951,-4343},{3274,-110,1958,-12,2038,951,-4343},{3274,-110,1958,-12,2038,951,-4343},{3274,-110,1958,-12,2038,951,-4343},{3274,-110,1958,-12,2038,951,-4343},{3274,-110,1958,-12,2038,951,-4343},{3274,-110,1958,-12,2038,951,-4343}};
                        int i;
                        l_861 = l_860[2];
                        if (p_5)
                            break;
                        if (p_6)
                            continue;
                    }
                }
                (*l_862) = l_861;
            }
            (***g_368) = &p_5;
            if ((****g_368))
                continue;
        }
    }
    return p_4;
    /* statement id: 717 */
    //assert (g_79[0] == dangling || g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
    //assert (g_631 == dangling || g_631 == &g_632);
}


/* ------------------------------------------ */
/* 
 * reads : g_16 g_104 g_367 g_368 g_292 g_293 g_79 g_80 g_33.f3 g_33.f0 g_33
 * writes: g_16 g_53 g_79
 */
static uint16_t  func_7(const int8_t  p_8, int32_t  p_9, uint32_t  p_10)
{ /* block id: 1 */
    int32_t *l_15 = &g_16;
    struct S0 l_26 = {1427,-114,769,-17,1730,961,7541};
    (*l_15) = p_9;
    for (g_16 = 0; (g_16 < (-22)); --g_16)
    { /* block id: 5 */
        int32_t *l_32 = &g_16;
        const int32_t *l_529 = &g_80[0];
        const int32_t **l_528[3];
        int i;
        for (i = 0; i < 3; i = i + 1)
            l_528[i] = &l_529;
    }
    (*g_104) = &l_26;
    /* statement id: 435 */
    assert (g_53 == &l_26);
    if ((*****g_367))
    { /* block id: 436 */
        int32_t ****l_536[2];
        uint8_t l_537 = 1U;
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_536[i] = &g_292;
        (*l_15) = (safe_rshift_func_int16_t_s_u(0x94B9, (((safe_rshift_func_uint8_t_u_u((*l_15), ((safe_unary_minus_func_int8_t_s(((l_536[1] != (*g_367)) ^ (l_537 < p_8)))) | (0xE6 || (safe_lshift_func_int16_t_s_u((p_8 ^ ((safe_add_func_int32_t_s_s(((void*)0 == &l_536[1]), 0x5B20059E)) || g_33.f3)), g_33.f0)))))) > p_10) & (-6))));
    }
    else
    { /* block id: 438 */
        int32_t *l_544 = &g_16;
        (**g_292) = func_48(l_15);
        /* statement id: 439 */
        //assert (g_53 == dangling);
        //assert (g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
        for (p_9 = 11; (p_9 >= 6); p_9 = safe_sub_func_uint32_t_u_u(p_9, 9))
        { /* block id: 442 */
            (****g_367) = l_544;
        }
        return p_8;
    }
    return g_80[3];
    /* statement id: 447 */
    //assert (g_53 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_14 g_104 g_367 g_368 g_292 g_293 g_79 g_38 g_373 g_33.f6 g_33.f2 g_33.f3
 * writes: g_14 g_373 g_53 g_38 g_79
 */
static const int32_t * func_19(int16_t  p_20)
{ /* block id: 407 */
    struct S0 ****l_507 = &g_103[1][0];
    int32_t *l_514 = &g_373;
    struct S0 l_526 = {3104,162,1432,-11,775,681,-5207};
    struct S0 *l_527 = &l_526;
    for (g_14 = 26; (g_14 == 7); g_14--)
    { /* block id: 410 */
        if ((safe_rshift_func_uint8_t_u_s((safe_rshift_func_int16_t_s_u((l_507 == (void*)0), 0)), 1)))
        { /* block id: 411 */
            struct S0 l_508 = {2241,151,1483,-4,443,2580,-6389};
            const int32_t *l_511 = &g_38;
            l_508 = l_508;
            for (g_373 = (-9); (g_373 <= (-2)); g_373 = safe_add_func_int16_t_s_s(g_373, 1))
            { /* block id: 415 */
                return l_511;
                /* statement id: 416 */
                //assert (func_19_rv == &g_38);
            }
            if (p_20)
                continue;
            (*g_104) = (void*)0;
            /* statement id: 419 */
            assert (g_53 == 0);
        }
        else
        { /* block id: 420 */
            return (****g_367);
            /* statement id: 421 */
            //assert (func_19_rv == &g_16 || (func_19_rv >= &g_80[0] && func_19_rv <= &g_80[3]));
        }
        /* facts after branching */
        assert (g_53 == 0);
    }
    /* facts after for loop */
    //assert (g_53 == 0 || g_53 == &g_33 || g_53 == dangling);
    for (g_38 = 0; (g_38 == 16); g_38 = safe_add_func_int32_t_s_s(g_38, 5))
    { /* block id: 426 */
        if (p_20)
            break;
        (****g_367) = l_514;
    }
    /* facts after for loop */
    //assert (g_79[0] == &g_373 || g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
    (*l_514) = (((((*l_514) >= (safe_mod_func_int8_t_s_s((safe_mod_func_uint32_t_u_u((((*l_514) == (safe_unary_minus_func_int8_t_s(g_33.f6))) == (((*l_514) >= (((safe_sub_func_uint32_t_u_u(0xCAEE6145, (safe_add_func_int16_t_s_s((*l_514), ((p_20 ^ g_33.f2) || (safe_lshift_func_int8_t_s_s((-1), (*l_514)))))))) <= g_373) && 0x7B)) != 0x51)), g_373)), 0x87))) == (*l_514)) < g_33.f3) | 0xF1D225E7);
    (*l_527) = l_526;
    return (***g_368);
    /* statement id: 432 */
    //assert (func_19_rv == &g_373 || func_19_rv == &g_16 || (func_19_rv >= &g_80[0] && func_19_rv <= &g_80[3]));
}


/* ------------------------------------------ */
/* 
 * reads : g_292 g_293 g_79 g_16 g_80
 * writes: g_38
 */
static int16_t  func_21(int16_t  p_22)
{ /* block id: 273 */
    int32_t ****l_364 = &g_292;
    int32_t *l_365 = &g_38;
    int32_t ****l_372 = &g_292;
    struct S0 * const l_395[5] = {&g_33,&g_33,&g_33,&g_33,&g_33};
    int32_t l_417 = 0xB263EEB2;
    const int32_t l_424 = 0;
    uint32_t l_443 = 0xAD4B4192;
    struct S0 ****l_448 = &g_103[0][1];
    int32_t **** const *l_461 = (void*)0;
    int16_t l_479 = 0x590D;
    int32_t l_495 = 0x9A160E4D;
    int i;
    (*l_365) = (0xA3 >= (l_364 == (void*)0));
    return (****l_364);
}


/* ------------------------------------------ */
/* 
 * reads : g_33.f3 g_79 g_14 g_33 g_292 g_293 g_80
 * writes: g_79 g_80 g_14 g_53
 */
inline static int16_t  func_23(struct S0  p_24, uint32_t  p_25)
{ /* block id: 156 */
    uint16_t l_241 = 65535U;
    int32_t *l_267 = (void*)0;
    struct S0 *l_288[4] = {&g_33,&g_33,&g_33,&g_33};
    struct S0 **l_345 = (void*)0;
    int32_t *l_363 = &g_80[1];
    int i;
    if ((!g_33.f3))
    { /* block id: 157 */
        int32_t **l_237 = (void*)0;
        int32_t **l_238 = &g_79[2];
        p_24.f6 = p_24.f0;
        (*l_238) = &g_80[3];
        for (p_25 = 13; (p_25 < 37); p_25 = safe_add_func_int32_t_s_s(p_25, 2))
        { /* block id: 162 */
            (**l_238) = p_24.f6;
            if (p_24.f5)
                break;
            if (p_24.f0)
                goto lbl_360;
        }
        (**l_238) = 0x5BE7F528;
    }
    else
    { /* block id: 167 */
        uint32_t l_242 = 0xF1367DAB;
        for (g_14 = 0; (g_14 <= 2); g_14 += 1)
        { /* block id: 170 */
            int i;
            l_241 = p_24.f0;
            if (l_242)
                continue;
            for (l_242 = 0; (l_242 <= 1); l_242 += 1)
            { /* block id: 175 */
                return g_33.f3;
            }
        }
    }
    for (p_25 = 0; (p_25 < 24); p_25 = safe_add_func_uint8_t_u_u(p_25, 1))
    { /* block id: 182 */
        int32_t **l_245 = &g_79[1];
        struct S0 ***l_295 = &g_104;
        struct S0 l_297 = {2067,-98,1296,13,1018,294,-5243};
        const struct S0 l_313[4] = {{2565,-74,1427,21,956,263,-783},{2565,-74,1427,21,956,263,-783},{2565,-74,1427,21,956,263,-783},{2565,-74,1427,21,956,263,-783}};
        int32_t l_328[4][9][4] = {{{2,0xD5D00736,(-1),0x4786584C},{0xC4B44270,0xD5D00736,0x203E24DF,0},{0xD5D00736,2,(-1),0},{4,2,0x203E24DF,0x203E24DF},{2,2,0x70AAF003,0x4786584C},{0,(-1),0x203E24DF,0x4786584C},{(-1),2,0,0x203E24DF},{0,2,0,0x4786584C},{2,(-1),0,0x4786584C}},{{4,2,0x203E24DF,0x203E24DF},{2,2,0x70AAF003,0x4786584C},{0,(-1),0x203E24DF,0x4786584C},{(-1),2,0,0x203E24DF},{0,2,0,0x4786584C},{2,(-1),0,0x4786584C},{4,2,0x203E24DF,0x203E24DF},{2,2,0x70AAF003,0x4786584C},{0,(-1),0x203E24DF,0x4786584C}},{{(-1),2,0,0x203E24DF},{0,2,0,0x4786584C},{2,(-1),0,0x4786584C},{4,2,0x203E24DF,0x203E24DF},{2,2,0x70AAF003,0x4786584C},{0,(-1),0x203E24DF,0x4786584C},{(-1),2,0,0x203E24DF},{0,2,0,0x4786584C},{2,(-1),0,0x4786584C}},{{4,2,0x203E24DF,0x203E24DF},{2,2,0x70AAF003,0x4786584C},{0,(-1),0x203E24DF,0x4786584C},{(-1),2,0,0x203E24DF},{0,2,0,0x4786584C},{2,(-1),0,0x4786584C},{4,2,0x203E24DF,0x203E24DF},{2,2,0x70AAF003,0x4786584C},{0,(-1),0x203E24DF,0x4786584C}}};
        int i, j, k;
        (*l_245) = func_48(func_48(func_48(&g_80[2])));
        /* statement id: 183 */
        //assert (g_53 == dangling);
    }
    /* facts after for loop */
    //assert (g_53 == dangling || g_53 == &g_33);
    //assert (g_79[0] == &g_16 || (g_79[0] >= &g_80[0] && g_79[0] <= &g_80[3]));
lbl_360:
    (**g_292) = func_48(l_267);
    /* statement id: 269 */
    //assert (g_53 == dangling);
    (*l_363) = (safe_sub_func_int32_t_s_s(p_24.f1, g_33.f1));
    return (*l_363);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_27(int32_t * p_28, struct S0  p_29, uint32_t  p_30, const uint32_t  p_31)
{ /* block id: 6 */
    uint32_t l_36 = 0xD6E8597A;
    int32_t *l_37 = &g_38;
    uint32_t l_70 = 0U;
    int32_t l_107 = 0xA7D7ACB2;
    uint16_t l_127[8][2] = {{1U,0xDE28},{0xDE28,1U},{0xDE28,0xDE28},{1U,0xDE28},{0xDE28,1U},{0xDE28,0xDE28},{1U,0xDE28},{0xDE28,1U}};
    struct S0 l_129 = {3319,-139,850,20,1786,1109,2616};
    struct S0 *l_130 = &l_129;
    struct S0 ****l_143 = &g_103[1][0];
    int8_t l_206 = 0xCA;
    uint32_t l_232 = 0x335C8890;
    int8_t l_235 = 0xC8;
    int i, j;
    return l_235;
}


/* ------------------------------------------ */
/* 
 * reads : g_16
 * writes:
 */
static int32_t  func_34(uint16_t  p_35)
{ /* block id: 7 */
    return g_16;
}


/* ------------------------------------------ */
/* 
 * reads : g_33 g_14 g_38
 * writes: g_53 g_14 g_33
 */
inline static uint32_t  func_43(int32_t * p_44, const int32_t  p_45, const int32_t * const  p_46, int32_t * const  p_47)
{ /* block id: 18 */
    int32_t *l_58 = &g_16;
    int32_t **l_57 = &l_58;
    (*l_57) = func_48(&g_16);
    for (g_14 = 20; (g_14 <= 9); g_14 = safe_sub_func_uint16_t_u_u(g_14, 4))
    { /* block id: 22 */
        if ((safe_rshift_func_uint8_t_u_u((((void*)0 != &g_16) <= (&g_53 != (void*)0)), 2)))
        { /* block id: 23 */
            if (g_38)
                break;
        }
        else
        { /* block id: 25 */
            struct S0 l_63 = {3738,-138,831,-8,1283,1600,-4088};
            struct S0 *l_64 = (void*)0;
            struct S0 *l_65 = (void*)0;
            struct S0 *l_66 = &g_33;
            (*l_66) = l_63;
        }
    }
    return g_14;
}


/* ------------------------------------------ */
/* 
 * reads : g_33
 * writes: g_53
 */
static int32_t * func_48(int32_t * p_49)
{ /* block id: 13 */
    struct S0 l_50 = {1586,138,979,2,787,2862,-1649};
    struct S0 *l_52 = &g_33;
    struct S0 **l_51[8] = {&l_52,&l_52,&l_52,&l_52,&l_52,&l_52,&l_52,&l_52};
    int32_t *l_54 = &g_38;
    int32_t **l_55 = (void*)0;
    int32_t **l_56 = &l_54;
    int i;
    l_50 = g_33;
    g_53 = &l_50;
    /* statement id: 15 */
    assert (g_53 == &l_50);
    (*l_56) = l_54;
    return &g_16;
    /* statement id: 17 */
    //assert (g_53 == dangling);
    //assert (func_48_rv == &g_16);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_14, "g_14", print_hash_value);
    transparent_crc(g_16, "g_16", print_hash_value);
    transparent_crc(g_33.f0, "g_33.f0", print_hash_value);
    transparent_crc(g_33.f1, "g_33.f1", print_hash_value);
    transparent_crc(g_33.f2, "g_33.f2", print_hash_value);
    transparent_crc(g_33.f3, "g_33.f3", print_hash_value);
    transparent_crc(g_33.f4, "g_33.f4", print_hash_value);
    transparent_crc(g_33.f5, "g_33.f5", print_hash_value);
    transparent_crc(g_33.f6, "g_33.f6", print_hash_value);
    transparent_crc(g_38, "g_38", print_hash_value);
    for (i = 0; i < 4; i = i + 1)
    {
        transparent_crc(g_80[i], "g_80[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_373, "g_373", print_hash_value);
    transparent_crc(g_624, "g_624", print_hash_value);
    transparent_crc(g_659.f0, "g_659.f0", print_hash_value);
    transparent_crc(g_659.f1, "g_659.f1", print_hash_value);
    transparent_crc(g_659.f2, "g_659.f2", print_hash_value);
    transparent_crc(g_659.f3, "g_659.f3", print_hash_value);
    transparent_crc(g_659.f4, "g_659.f4", print_hash_value);
    transparent_crc(g_659.f5, "g_659.f5", print_hash_value);
    transparent_crc(g_659.f6, "g_659.f6", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 184
   depth: 1, occurrence: 40
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 94
breakdown:
   indirect level: 0, occurrence: 40
   indirect level: 1, occurrence: 12
   indirect level: 2, occurrence: 9
   indirect level: 3, occurrence: 8
   indirect level: 4, occurrence: 12
   indirect level: 5, occurrence: 13
XXX full-bitfields structs in the program: 40
breakdown:
   indirect level: 0, occurrence: 40
XXX times a bitfields struct's address is taken: 54
XXX times a bitfields struct on LHS: 28
XXX times a bitfields struct on RHS: 48
XXX times a single bitfield on LHS: 9
XXX times a single bitfield on RHS: 152

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 160
   depth: 2, occurrence: 43
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 4
   depth: 13, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2

XXX total number of pointers: 183

XXX times a variable address is taken: 517
XXX times a pointer is dereferenced on RHS: 156
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 25
   depth: 3, occurrence: 16
   depth: 4, occurrence: 46
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 150
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 14
   depth: 3, occurrence: 32
   depth: 4, occurrence: 27
   depth: 5, occurrence: 4
XXX times a pointer is compared with null: 50
XXX times a pointer is compared with address of another variable: 21
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 1355

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 289
   level: 2, occurrence: 107
   level: 3, occurrence: 116
   level: 4, occurrence: 206
   level: 5, occurrence: 41
XXX number of pointers point to pointers: 103
XXX number of pointers point to scalars: 59
XXX number of pointers point to structs: 21
XXX percent of pointers has null in alias set: 31.1
XXX average alias set size: 1.51

XXX times a non-volatile is read: 1232
XXX times a non-volatile is write: 624
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 7

XXX stmts: 151
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 24
   depth: 2, occurrence: 32
   depth: 3, occurrence: 21
   depth: 4, occurrence: 20
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 18.3
XXX percentage an existing variable is used: 81.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

