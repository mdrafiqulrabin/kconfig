/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      560836931
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 8;
   signed f1 : 1;
   signed f2 : 24;
   signed f3 : 15;
   signed f4 : 14;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_28(void);
inline static struct S0  func_29(uint16_t  p_30, uint32_t  p_31, int8_t  p_32);
static int32_t  func_42(int16_t  p_43);
inline static int16_t  func_47(uint32_t  p_48);
inline static struct S0  func_49(int8_t  p_50, int32_t  p_51, struct S0  p_52, uint32_t  p_53, uint32_t  p_54);
inline static uint32_t  func_64(int32_t  p_65, uint16_t  p_66, int32_t  p_67);
inline static uint16_t  func_70(int16_t  p_71, uint16_t  p_72, struct S0  p_73, int16_t  p_74);
inline static uint16_t  func_76(int8_t  p_77, struct S0  p_78, uint32_t  p_79);
inline static int32_t  func_90(uint32_t  p_91, struct S0  p_92);
static uint32_t  func_106(uint32_t  p_107, uint16_t  p_108, struct S0  p_109);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_28(void)
{ /* block id: 36 */
    uint32_t l_33 = 0U;
    int32_t l_36 = 8;
    int32_t l_37 = 3;
    struct S0 l_44 = {9,-0,3939,-55,-16};
    struct S0 l_486 = {8,0,427,152,84};
    int32_t l_491 = 0;
    l_44 = func_29(l_33, (l_37 ^= (l_36 = (((uint16_t)65530U << (uint16_t)1) >= l_33))), ((((int16_t)((int32_t)func_42((l_44 , ((int32_t)(func_47((0x00250042 == __builtin_bswap32(l_44.f2))) >= __builtin_ctzl(l_44.f1)) - (int32_t)l_44.f0))) + (int32_t)4294967287U) % (int16_t)l_44.f4) <= 0xE3D9) , 0x98));
    l_36 &= ((((func_76(l_44.f1, l_486, l_486.f2) && ((int16_t)((((l_37 = ((uint16_t)l_491 >> (uint16_t)1)) >= func_76((l_486.f3 ^= l_486.f2), ((__builtin_ffs(((int32_t)func_42((l_486.f4 != ((l_486.f2 != l_44.f2) <= l_486.f4))) + (int32_t)l_486.f1)) != l_44.f3) , l_44), l_486.f2)) <= 0xFADD) > (-1)) << (int16_t)8)) >= 0xD271C27C) , l_44.f2) , 0x23E2E65C);
    return l_486.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_29(uint16_t  p_30, uint32_t  p_31, int8_t  p_32)
{ /* block id: 132 */
    int8_t l_218 = 0x4E;
    int32_t l_230 = 1;
    int32_t l_233 = 0xFD3730B5;
    struct S0 l_235 = {9,-0,2380,72,9};
    uint32_t l_263 = 4U;
    int8_t l_316 = 0x26;
    int8_t l_330 = 0xDE;
    int16_t l_382 = (-8);
    struct S0 l_442 = {4,-0,3708,43,-33};
    int32_t l_475 = 0x429B82F5;
    int32_t l_484 = 6;
    struct S0 l_485 = {1,-0,2783,59,-43};
    if ((((uint16_t)(func_42(l_218) > ((l_230 ^= (l_218 < ((int16_t)(((uint16_t)func_64(p_32, l_218, ((-(uint32_t)((uint32_t)((int16_t)((uint16_t)l_218 - (uint16_t)(((((p_30 || l_218) & p_32) != l_218) & 0x821130A5) < 1U)) * (int16_t)0xCF2F) + (uint32_t)4294967295U)) , 0)) << (uint16_t)3) , (-1)) >> (int16_t)l_218))) <= p_30)) * (uint16_t)1) != 65535U))
    { /* block id: 134 */
        uint32_t l_234 = 0xCEF9BD9D;
        int32_t l_236 = 0x1F7C4095;
        int8_t l_251 = (-1);
        struct S0 l_266 = {1,-0,-138,152,59};
        uint32_t l_291 = 4294967292U;
        int8_t l_318 = 0x2C;
        uint32_t l_322 = 0x70541828;
        for (l_230 = 18; (l_230 <= 14); l_230 -= 1)
        { /* block id: 137 */
            l_234 = (l_233 = p_31);
            return l_235;
        }
        l_236 = __builtin_parity(__builtin_clz(l_235.f0));
        l_230 = 0x0D88A30A;
        for (l_230 = 0; (l_230 < (-6)); l_230 -= 1)
        { /* block id: 146 */
            int8_t l_239 = 9;
            int32_t l_276 = 6;
            struct S0 l_306 = {12,-0,-3104,101,-125};
            int32_t l_317 = 0xC89DEAB6;
            int16_t l_319 = 9;
            struct S0 l_321 = {15,-0,3258,-70,117};
            int16_t l_327 = 0xEEBC;
            l_233 = l_239;
            for (p_32 = 0; (p_32 > (-10)); p_32 -= 1)
            { /* block id: 150 */
                int8_t l_250 = 0xB6;
                int32_t l_267 = 0;
                struct S0 l_320 = {6,0,2278,99,-17};
                struct S0 l_323 = {14,-0,-2085,109,-92};
                l_236 &= (p_30 == (p_31 <= (l_235.f3 |= ((uint16_t)l_239 * (uint16_t)((uint16_t)((p_32 , (((-(uint16_t)p_32) , ((l_251 = ((uint16_t)65534U << (uint16_t)(~(l_250 , p_30)))) , (((int16_t)(((uint16_t)(((int32_t)0x730F2670 + (int32_t)p_30) || (-1)) >> (uint16_t)11) && p_31) - (int16_t)l_235.f2) >= 0x081368AC))) || l_235.f1)) , 0xE45B) >> (uint16_t)3)))));
                if (p_30)
                { /* block id: 154 */
                    struct S0 l_258 = {14,0,1942,62,118};
                    int8_t l_315 = 0;
                    l_235 = func_49(p_31, p_31, l_258, (l_267 = func_76(((int32_t)((int16_t)l_263 - (int16_t)((p_31 <= ((int16_t)l_250 >> (int16_t)1)) , 0xCECD)) % (int32_t)__builtin_popcountll(p_32)), l_266, p_30)), l_258.f2);
                    if (p_32)
                        continue;
                    l_258.f3 ^= ((((uint16_t)((int16_t)(((p_31 , (p_31 >= p_31)) && (-(uint16_t)3U)) && (((((uint16_t)__builtin_ctz((!(l_276 = 0x7D475BA9))) >> (uint16_t)((int32_t)0x7A7DFD5D - (int32_t)((int16_t)(((uint16_t)0xB349 * (uint16_t)((((uint32_t)((uint16_t)((uint16_t)((int16_t)(((0x9253 >= l_258.f0) ^ l_235.f2) , l_234) + (int16_t)l_230) << (uint16_t)1) - (uint16_t)l_258.f2) + (uint32_t)p_30) > 0) , 0xAA0D)) && l_291) + (int16_t)l_267))) || 1) < 0xDD1DF32B) < 0x80712D52)) * (int16_t)0) << (uint16_t)p_30) && 0U) | p_32);
                    l_323 = func_49(((l_276 && 0x573C) , (((uint16_t)((l_306.f3 = ((((func_90((l_258.f4 >= (((int16_t)(((((int16_t)(((int32_t)(l_250 == 0x4B6B) - (int32_t)((int16_t)((int16_t)func_47((l_266.f4 = ((uint16_t)(l_306 , ((uint32_t)(l_306.f1 &= ((int16_t)(l_267 && ((int16_t)__builtin_ia32_crc32qi(((l_315 = (((int16_t)(l_233 >= p_30) >> (int16_t)p_32) && 1)) < l_258.f3), l_291) >> (int16_t)3)) % (int16_t)l_316)) % (uint32_t)p_30)) << (uint16_t)2))) - (int16_t)l_258.f1) << (int16_t)p_32)) != 0xA039) >> (int16_t)1) <= l_317) >= l_318) > p_32) % (int16_t)l_319) || 2)), l_320) & l_318) , 0) != 0xF611) , p_31)) >= l_306.f0) % (uint16_t)l_258.f3) ^ 0x89A203BC)), l_266.f0, l_321, l_322, p_31);
                }
                else
                { /* block id: 165 */
                    uint32_t l_324 = 0x7801C71F;
                    l_323.f1 = (l_324 , l_324);
                    l_323.f3 |= ((uint16_t)(l_236 ^= l_327) << (uint16_t)15);
                }
                l_320.f4 |= ((l_263 <= (__builtin_bswap32(l_323.f0) , l_306.f3)) || ((uint16_t)l_276 % (uint16_t)func_76(p_31, l_266, (l_330 = p_32))));
                if (p_30)
                { /* block id: 172 */
                    l_236 = 1;
                }
                else
                { /* block id: 174 */
                    l_323.f2 = p_32;
                }
            }
            if (l_306.f3)
                break;
        }
    }
    else
    { /* block id: 180 */
        uint16_t l_338 = 6U;
        int32_t l_353 = (-9);
        int32_t l_354 = 0x6596DC5A;
        struct S0 l_355 = {7,0,1573,-40,82};
        int32_t l_356 = 0x63186A5E;
        uint16_t l_476 = 0x46ED;
        for (l_230 = 0; (l_230 > (-17)); l_230 -= 9)
        { /* block id: 183 */
            int32_t l_337 = 0xCA923BFB;
            int32_t l_357 = 1;
            int32_t l_358 = 0x10A87234;
            int32_t l_361 = 0x026ABD10;
            int32_t l_381 = (-1);
            struct S0 l_395 = {11,0,-3321,84,96};
            l_358 |= (((uint16_t)(((1 && (__builtin_ctzll(((((int32_t)(l_338 = (l_233 < l_337)) - (int32_t)((uint32_t)func_47(p_32) % (uint32_t)4294967295U)) >= ((((int32_t)(((((int16_t)(-3) << (int16_t)8) , (l_356 &= ((int16_t)((int16_t)(l_235 , ((uint16_t)func_90((((int16_t)(l_353 = 0x07C3) * (int16_t)l_354) > (-1)), l_355) * (uint16_t)0x7405)) * (int16_t)0U) >> (int16_t)10))) & 0x2735F94A) & l_357) - (int32_t)0xB91710C8) | 0x28BEABA4) == l_337)) <= 65526U)) ^ l_230)) ^ l_230) >= 0x1049) << (uint16_t)4) >= p_30);
            l_235.f2 = ((uint16_t)((((l_230 == (((0xFAC9 > ((l_357 == (l_358 ^= l_357)) >= func_47(l_361))) ^ (((int16_t)((uint16_t)__builtin_ctzll(l_353) << (uint16_t)l_355.f1) - (int16_t)p_32) <= 0xC585)) < l_233)) , l_235.f4) > p_30) & l_361) >> (uint16_t)p_32);
            for (p_32 = 0; (p_32 < 21); p_32 += 1)
            { /* block id: 192 */
                int16_t l_376 = (-6);
                int32_t l_383 = 0x2EFF3937;
                int32_t l_429 = 2;
                uint32_t l_431 = 4294967295U;
                struct S0 l_437 = {7,0,-2801,101,-73};
                l_383 = ((uint16_t)((l_358 = (l_235.f3 = (l_355 , (l_235.f1 = p_31)))) || 9) * (uint16_t)(((int16_t)((uint16_t)(((int32_t)(l_376 | (l_376 > ((uint32_t)(l_235.f0 < ((int16_t)((l_381 |= ((l_230 != 0x472B082A) >= 0x677327F3)) | p_30) * (int16_t)l_376)) - (uint32_t)p_32))) - (int32_t)l_382) != 0x2273) << (uint16_t)7) + (int16_t)p_30) | l_376));
                for (l_361 = (-18); (l_361 != (-9)); l_361 += 9)
                { /* block id: 200 */
                    int32_t l_392 = 0x97078C29;
                    struct S0 l_394 = {4,0,1848,-177,-62};
                    if (((((uint16_t)65527U - (uint16_t)(l_358 = l_383)) , l_355) , ((((uint16_t)((uint32_t)p_30 % (uint32_t)0xAE0C315E) * (uint16_t)(l_353 , 0x6D4F)) || l_392) ^ 0x5DBEE813)))
                    { /* block id: 202 */
                        uint16_t l_393 = 0xCE38;
                        l_393 = p_30;
                        l_395 = l_394;
                    }
                    else
                    { /* block id: 205 */
                        uint32_t l_402 = 0x84BF4C25;
                        l_395.f1 ^= ((((uint32_t)4294967295U + (uint32_t)(l_330 & (p_30 , ((int32_t)((0x192EBB88 == 0) == (l_355.f1 &= (func_64((((int32_t)l_383 % (int32_t)func_47(l_383)) <= (((((p_30 | l_376) , p_32) > l_355.f2) , l_402) , l_355.f3)), l_357, p_32) , p_31))) % (int32_t)0xF1E85B63)))) | p_31) , 0xF9688DC7);
                    }
                    for (l_353 = (-15); (l_353 <= 10); l_353 += 1)
                    { /* block id: 211 */
                        l_395.f1 = p_31;
                    }
                }
                for (l_381 = (-26); (l_381 >= (-5)); l_381 += 1)
                { /* block id: 217 */
                    int32_t l_409 = 0x15371E21;
                    for (l_330 = (-9); (l_330 == (-26)); l_330 -= 3)
                    { /* block id: 220 */
                        l_409 = l_409;
                    }
                }
                for (p_31 = 18; (p_31 == 25); p_31 += 1)
                { /* block id: 226 */
                    int8_t l_419 = 0x83;
                    struct S0 l_430 = {0,0,3678,-175,-98};
                    if ((l_419 = ((int16_t)(!((uint16_t)p_30 >> (uint16_t)0)) * (int16_t)((int16_t)l_356 + (int16_t)(l_395.f4 != (p_31 , 4294967295U))))))
                    { /* block id: 228 */
                        int16_t l_428 = 0x0974;
                        l_355 = func_49(l_383, (l_429 = (l_383 , ((((uint16_t)(p_30 |= 65535U) * (uint16_t)(((int16_t)(p_31 >= ((int16_t)p_31 * (int16_t)(l_355.f4 , ((uint16_t)func_90(l_218, l_395) % (uint16_t)l_218)))) * (int16_t)(-3)) , 0xEB8C)) >= l_428) == l_330))), l_355, p_32, l_233);
                    }
                    else
                    { /* block id: 232 */
                        l_381 = (0xBC480110 && p_32);
                        l_430 = l_235;
                        if (l_431)
                            continue;
                    }
                    l_355 = l_235;
                    l_355.f3 = ((p_31 && (((uint32_t)l_430.f4 - (uint32_t)((__builtin_ctz((-(uint16_t)((uint32_t)func_90(l_330, l_437) % (uint32_t)l_233))) < l_233) != l_430.f2)) || p_32)) > 4294967295U);
                }
            }
        }
        l_235.f2 = ((uint32_t)(p_30 && 0U) - (uint32_t)(((__builtin_bswap64(l_233) && (((l_353 = ((l_355.f2 & p_31) ^ l_330)) != (l_355.f1 &= ((l_355.f2 || ((l_355.f2 , p_30) ^ l_235.f1)) > p_32))) > 0x4265742B)) == p_32) & 0x6299));
        if ((l_356 = (func_47(((((l_355.f4 <= p_31) , (func_76(((((uint16_t)l_355.f4 * (uint16_t)0x5ED6) == ((l_338 >= (1 | (l_354 = 0xBD43B4DA))) == p_30)) > (l_235.f4 |= (l_355.f0 | 0x35B1))), l_442, p_32) | p_31)) != 0xB426) >= l_263)) & l_355.f2)))
        { /* block id: 248 */
            int32_t l_443 = 0x2E147626;
            struct S0 l_448 = {9,0,3410,-132,-96};
            l_448.f4 = (((l_448.f2 = ((l_355.f1 || 0xF51FC6A9) <= (p_31 , func_76(l_443, (((uint16_t)(p_30 = 0x7146) * (uint16_t)(((((uint16_t)((p_32 , func_49(l_443, p_32, l_235, p_32, p_31)) , p_32) - (uint16_t)8U) && p_31) , p_32) != l_442.f3)) , l_448), l_316)))) , 0x8B711D74) > l_356);
        }
        else
        { /* block id: 252 */
            struct S0 l_449 = {11,-0,2594,-139,-48};
            int32_t l_474 = 0x8A75DFBF;
            l_355 = l_449;
            l_235.f1 = ((int16_t)(((((int16_t)((uint16_t)p_30 - (uint16_t)((~l_382) & ((uint16_t)(l_474 = ((uint16_t)(((int16_t)(((uint16_t)((p_30 , func_49(((((uint16_t)(l_356 |= ((uint32_t)p_32 + (uint32_t)((p_32 != __builtin_ffsl(((((uint16_t)l_449.f3 - (uint16_t)(0x0D268F88 >= (!(l_230 = ((int16_t)l_442.f2 - (int16_t)(l_235.f2 = 0x2B9C)))))) < p_30) != l_449.f3))) == p_30))) % (uint16_t)l_235.f0) == p_30) , p_31), l_442.f1, l_355, l_449.f3, l_442.f4)) , l_449.f0) >> (uint16_t)p_30) != p_30) >> (int16_t)l_235.f0) >= l_442.f0) * (uint16_t)0xF948)) - (uint16_t)l_449.f1))) * (int16_t)l_449.f3) & l_235.f1) != l_475) && l_233) - (int16_t)l_476);
            l_449 = l_235;
        }
    }
    l_235 = func_49(p_30, ((((((p_31 != 1U) == (p_31 < (((l_442.f1 = 0x2E8A3756) == ((uint32_t)(l_235 , (__builtin_parity((!(l_235 , ((l_442.f4 = ((uint16_t)((int16_t)l_263 >> (int16_t)14) << (uint16_t)9)) > ((l_235.f4 ^= 0x6376) >= p_32))))) , 4294967290U)) - (uint32_t)4294967295U)) <= l_484))) >= 0xFA78) != 0x52D9) ^ p_30) , l_218), l_485, l_442.f0, l_485.f0);
    return l_235;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_42(int16_t  p_43)
{ /* block id: 129 */
    int32_t l_215 = 1;
    l_215 = ((0xCCF155A4 == (!7U)) , p_43);
    return l_215;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_47(uint32_t  p_48)
{ /* block id: 39 */
    uint16_t l_57 = 65535U;
    int32_t l_60 = (-1);
    int32_t l_63 = 0xC8B69768;
    struct S0 l_80 = {6,-0,-2585,90,-48};
    int32_t l_82 = 0xB80730A0;
    int32_t l_98 = 7;
    struct S0 l_99 = {12,0,114,-97,79};
    int32_t l_157 = 1;
    uint32_t l_162 = 0x74F6BAD6;
    int16_t l_171 = 0xB28D;
    int16_t l_186 = 0xB831;
    int16_t l_213 = 0xAC5B;
    l_99 = func_49(((int16_t)(((l_57 == (((int16_t)((l_60 &= 6) == ((int16_t)((l_63 = (-9)) | l_57) + (int16_t)(func_64(l_57, ((int32_t)((((p_48 <= func_70((l_80.f3 = (l_98 ^= (((~func_76(l_57, l_80, ((~l_82) < l_80.f4))) == l_80.f4) >= l_82))), l_80.f1, l_99, l_80.f1)) == p_48) >= p_48) == 1U) % (int32_t)l_99.f3), p_48) , p_48))) % (int16_t)0x6801) | l_80.f2)) >= l_99.f0) > p_48) + (int16_t)0x0DA8), p_48, l_99, p_48, l_99.f2);
    l_80.f3 = p_48;
    l_80.f4 = 0x245E674C;
    if (func_64((l_80.f4 | p_48), (l_82 = p_48), (!((uint16_t)(l_63 ^= (((l_80.f1 = ((((uint16_t)(0xE1AE < l_157) << (uint16_t)l_80.f3) | (((int16_t)p_48 * (int16_t)(((int16_t)p_48 << (int16_t)(__builtin_ctzll(l_60) & p_48)) && l_162)) > p_48)) | p_48)) , 0xEB7A) | l_80.f0)) - (uint16_t)65526U))))
    { /* block id: 98 */
        uint32_t l_167 = 0x35E0B3DF;
        int32_t l_170 = 0;
        struct S0 l_172 = {14,-0,157,152,-17};
        struct S0 l_188 = {15,-0,3441,-99,15};
        if (((uint32_t)(func_64(((int16_t)(l_99.f2 = l_167) % (int16_t)func_64(p_48, ((((((__builtin_bswap32(p_48) <= ((int16_t)0xE259 * (int16_t)func_76(p_48, ((l_167 ^ l_157) , l_80), p_48))) || p_48) | p_48) , l_170) ^ l_167) && p_48), l_171)), p_48, l_80.f3) | 0xD7E7) % (uint32_t)0x90713B03))
        { /* block id: 100 */
            uint32_t l_184 = 4294967288U;
            int32_t l_187 = 0x375B8AA7;
            l_188.f2 = func_90(((0x48F91BDD <= p_48) <= (l_172 , ((l_172.f1 ^= (((int16_t)(((int16_t)((((~((uint32_t)(~(!((((uint16_t)l_184 + (uint16_t)(p_48 , (l_172.f2 = ((-(uint32_t)((l_187 = (__builtin_popcountll(l_186) >= 1U)) != p_48)) >= l_99.f4)))) , 0x1DBCDBA4) ^ 1))) - (uint32_t)p_48)) | 0x027805F1) < l_184) && p_48) + (int16_t)0x3D32) >= p_48) % (int16_t)p_48) | l_184)) , 0xC4551C73))), l_188);
            l_99.f3 |= (((uint32_t)p_48 % (uint32_t)l_99.f1) < (l_63 ^= p_48));
            for (l_170 = 26; (l_170 != (-18)); l_170 -= 2)
            { /* block id: 109 */
                return p_48;
            }
        }
        else
        { /* block id: 112 */
            uint32_t l_195 = 4294967295U;
            l_170 = ((int16_t)(-4) << (int16_t)8);
            l_188 = func_49(l_195, p_48, l_188, (p_48 <= ((__builtin_bswap64((l_99.f3 = p_48)) , ((((((uint16_t)0xD486 >> (uint16_t)((uint16_t)l_195 << (uint16_t)6)) < (l_170 , p_48)) < (-1)) == 1) & l_195)) && p_48)), l_170);
        }
        l_188.f3 = l_167;
        return l_80.f2;
    }
    else
    { /* block id: 119 */
        uint32_t l_207 = 0x5221C504;
        struct S0 l_208 = {4,0,999,-96,-7};
        l_99.f1 = (p_48 < l_60);
        l_80.f3 = __builtin_ffsll((l_98 &= __builtin_ffsll((-(int32_t)(p_48 >= (l_208.f1 = ((((((uint32_t)((l_63 = ((int16_t)(func_70((((int16_t)(l_80 , (func_76(l_207, l_208, (((int16_t)p_48 * (int16_t)func_90((l_82 = l_162), l_208)) , ((((int16_t)((((l_99 = func_49((l_99.f0 , 0x58), p_48, l_80, l_208.f3, p_48)) , l_208) , p_48) >= p_48) * (int16_t)p_48) < p_48) , l_63))) , l_57)) << (int16_t)l_80.f3) || l_57), p_48, l_80, l_207) ^ 0x8733) % (int16_t)l_213)) > 4294967295U) % (uint32_t)l_157) | 0xC394) <= l_208.f1) || l_208.f2) , 0x0129)))))));
    }
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_49(int8_t  p_50, int32_t  p_51, struct S0  p_52, uint32_t  p_53, uint32_t  p_54)
{ /* block id: 79 */
    int16_t l_138 = 3;
    struct S0 l_141 = {12,0,-2630,-129,-78};
    p_52.f1 = l_138;
    for (p_53 = 0; (p_53 <= 57); p_53 += 8)
    { /* block id: 83 */
        p_52.f1 |= 0xEE9ED184;
        l_141 = l_141;
        return p_52;
    }
    p_52.f1 = (((uint16_t)(((int16_t)0 % (int16_t)l_141.f3) | l_141.f2) << (uint16_t)((((int16_t)(4294967293U | p_52.f3) >> (int16_t)13) == ((int16_t)(p_52.f4 , l_141.f1) >> (int16_t)l_141.f1)) , ((int16_t)(l_141.f4 ^= p_54) % (int16_t)l_141.f2))) <= p_51);
    l_141.f1 ^= 9;
    return l_141;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_64(int32_t  p_65, uint16_t  p_66, int32_t  p_67)
{ /* block id: 55 */
    int8_t l_103 = 0xC0;
    int16_t l_119 = 5;
    struct S0 l_120 = {4,0,1317,121,-51};
    int32_t l_121 = 0xAC5EDFBC;
    struct S0 l_122 = {8,-0,3263,11,-44};
    int32_t l_137 = 0x0D6E1A5D;
    l_137 |= (l_120.f3 = (l_122.f1 = (((-(uint16_t)l_103) >= ((uint16_t)(func_106((l_121 ^= ((int16_t)((l_103 < (l_120.f4 = (((((int32_t)((~((0x4B0E & l_103) >= (p_67 |= p_66))) , l_103) - (int32_t)((func_70(((uint16_t)p_66 * (uint16_t)(p_65 > (((((((((int16_t)p_66 << (int16_t)14) && l_103) < p_66) || p_66) , (-10)) > p_65) && p_65) && l_119))), p_65, l_120, p_66) || l_119) , p_66)) <= 4294967295U) , l_103) > 1U))) , l_120.f3) - (int16_t)l_120.f1)), l_103, l_122) & l_122.f2) << (uint16_t)l_122.f3)) || 1U)));
    p_67 = 0xEB988110;
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_70(int16_t  p_71, uint16_t  p_72, struct S0  p_73, int16_t  p_74)
{ /* block id: 50 */
    int16_t l_100 = 0x88E9;
    int32_t l_101 = 0x8B1902DE;
    l_101 &= (p_73.f2 = l_100);
    p_73.f3 ^= l_101;
    return l_101;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_76(int8_t  p_77, struct S0  p_78, uint32_t  p_79)
{ /* block id: 42 */
    uint32_t l_89 = 1U;
    int32_t l_96 = (-8);
    int32_t l_97 = (-9);
    l_97 = ((((uint16_t)((uint16_t)p_79 - (uint16_t)((-10) & (((int16_t)(l_89 <= ((((4294967295U < func_90(l_89, p_78)) & p_79) < (((((int16_t)(-1) - (int16_t)p_79) || l_89) <= p_78.f1) < p_78.f4)) , l_89)) % (int16_t)p_78.f4) , l_89))) >> (uint16_t)1) , l_89) , l_96);
    return p_78.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_90(uint32_t  p_91, struct S0  p_92)
{ /* block id: 43 */
    uint32_t l_93 = 0xEB1080E2;
    p_92.f2 ^= 0;
    return l_93;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_106(uint32_t  p_107, uint16_t  p_108, struct S0  p_109)
{ /* block id: 59 */
    int32_t l_131 = 0xBA5D09CA;
    int32_t l_134 = 0x572ACB3E;
    int8_t l_135 = 1;
    int32_t l_136 = 0x09D46BF4;
    for (p_107 = (-30); (p_107 == 22); p_107 += 1)
    { /* block id: 62 */
        struct S0 l_128 = {0,0,3193,-48,125};
        for (p_108 = 0; (p_108 > 49); p_108 += 6)
        { /* block id: 65 */
            struct S0 l_127 = {10,0,1947,99,17};
            l_128 = l_127;
        }
    }
    p_109.f2 |= 0xC1A6072D;
    l_136 = ((l_134 = ((__builtin_bswap32(((uint16_t)(l_131 = 0x9DD7) * (uint16_t)((uint32_t)((((0xB9A4 < p_108) && p_108) , (l_134 , l_134)) , l_135) - (uint32_t)(p_108 && 4294967291U)))) , l_135) >= p_107)) , 1);
    return l_134;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 90
   depth: 1, occurrence: 28
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 28
breakdown:
   indirect level: 0, occurrence: 28
XXX full-bitfields structs in the program: 28
breakdown:
   indirect level: 0, occurrence: 28
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 15
XXX times a bitfields struct on RHS: 50
XXX times a single bitfield on LHS: 53
XXX times a single bitfield on RHS: 101

XXX max expression depth: 46
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 20
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1
   depth: 37, occurrence: 1
   depth: 38, occurrence: 1
   depth: 39, occurrence: 1
   depth: 44, occurrence: 1
   depth: 46, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 502
XXX times a non-volatile is write: 143
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 98
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 16
   depth: 2, occurrence: 18
   depth: 3, occurrence: 9
   depth: 4, occurrence: 14
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 19
XXX percentage an existing variable is used: 81
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

