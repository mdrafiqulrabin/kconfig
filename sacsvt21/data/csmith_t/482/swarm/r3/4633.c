/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      886075804
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   int32_t  f2;
   const uint32_t  f3;
   int32_t  f4;
   uint32_t  f5;
   uint32_t  f6;
};

struct S1 {
   unsigned f0 : 2;
   unsigned f1 : 11;
   unsigned f2 : 7;
   unsigned f3 : 26;
   int32_t  f4;
   const signed f5 : 12;
   int32_t  f6;
   signed f7 : 9;
   const signed f8 : 12;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = 0x3F365653L;
static uint8_t g_71 = 0UL;
static struct S1 g_86 = {0,5,8,1412,0x871EB1C2L,22,0xAA4AECA2L,-8,34};
static int32_t g_159 = 0L;
static int64_t g_211 = 0xF9674B01682E6EA6LL;
static uint16_t g_235 = 0x06A6L;
static uint32_t g_278 = 0UL;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_31(void);
static uint32_t  func_35(int64_t  p_36, uint32_t  p_37);
static uint32_t  func_39(uint32_t  p_40);
static uint16_t  func_43(int64_t  p_44, int16_t  p_45, uint64_t  p_46, const uint8_t  p_47, int64_t  p_48);
static uint64_t  func_57(struct S0  p_58, uint16_t  p_59);
static uint32_t  func_64(uint32_t  p_65, uint8_t  p_66);
static int32_t  func_67(const uint8_t  p_68);
static const int32_t  func_73(uint64_t  p_74, struct S0  p_75);
static uint64_t  func_76(int64_t  p_77, int64_t  p_78, uint32_t  p_79, uint64_t  p_80, int16_t  p_81);
static uint32_t  func_82(int32_t  p_83, int32_t  p_84, struct S1  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_71 g_86 g_159 g_211
 * writes: g_71 g_86.f7 g_159 g_211 g_235 g_3 g_278
 */
static uint32_t  func_31(void)
{ /* block id: 36 */
    uint8_t l_267 = 6UL;
    int32_t l_282 = 0xA4CF426AL;
    g_278 = (~((uint32_t)func_35(g_3, ((!((func_39(g_3) && g_86.f7) & ((((int64_t)((int16_t)(((uint64_t)(l_267 ^ g_3) + (uint64_t)((int64_t)(9UL != g_3) / (int64_t)((uint16_t)l_267 << (uint16_t)5))) | g_86.f0) - (int16_t)0x5E53L) - (int64_t)l_267) >= l_267) != 4294967295UL))) > 0L)) / (uint32_t)l_267));
    l_282 = (l_267 != ((int32_t)(~0x5DF8L) - (int32_t)(-3L)));
    g_86.f7 = g_86.f4;
    g_86.f7 = g_86.f6;
    return l_282;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_71 g_86.f7
 * writes: g_3 g_86.f7
 */
static uint32_t  func_35(int64_t  p_36, uint32_t  p_37)
{ /* block id: 91 */
    uint16_t l_272 = 0x9CB0L;
    int32_t l_277 = (-1L);
    if (l_272)
    { /* block id: 92 */
        int16_t l_273 = 0x5721L;
        int32_t l_274 = 0xBA37C6CFL;
        l_274 = (l_273 < (p_37 >= __builtin_parityl(p_37)));
    }
    else
    { /* block id: 94 */
        for (g_3 = 0; (g_3 == (-19)); g_3 -= 4)
        { /* block id: 97 */
            return p_36;
        }
    }
    g_86.f7 = __builtin_popcountl(g_71);
    l_277 = ((l_272 != l_272) || g_86.f7);
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_71 g_86 g_159 g_211
 * writes: g_71 g_86.f7 g_159 g_211 g_235
 */
static uint32_t  func_39(uint32_t  p_40)
{ /* block id: 37 */
    struct S0 l_60 = {0UL,18446744073709551615UL,0xB398EF54L,4294967291UL,4L,8UL,7UL};
    l_60.f2 = ((uint16_t)(func_43((g_3 || ((((uint16_t)((int16_t)(((uint64_t)__builtin_clzll(((uint32_t)p_40 % (uint32_t)3L)) % (uint64_t)func_57(l_60, g_3)) || (-1L)) << (int16_t)5) << (uint16_t)4) > ((((uint16_t)0x85CDL << (uint16_t)5) <= g_86.f4) == l_60.f5)) != l_60.f5)), p_40, l_60.f4, l_60.f5, g_86.f3) ^ p_40) * (uint16_t)p_40);
    g_86.f7 = g_86.f6;
    return l_60.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_159 g_211 g_86.f6 g_3 g_86.f4 g_86.f8
 * writes: g_71
 */
static uint16_t  func_43(int64_t  p_44, int16_t  p_45, uint64_t  p_46, const uint8_t  p_47, int64_t  p_48)
{ /* block id: 80 */
    uint32_t l_244 = 0x2693F941L;
    int32_t l_255 = 0xF7B5BDB7L;
    if (((uint16_t)((int16_t)((((uint16_t)g_159 * (uint16_t)(l_244 | ((uint16_t)((int16_t)g_211 << (int16_t)12) << (uint16_t)7))) > ((uint32_t)g_86.f6 - (uint32_t)((uint32_t)0xB7A3AED3L / (uint32_t)((uint16_t)l_244 << (uint16_t)(func_67(p_44) || (g_3 >= p_46)))))) == l_244) >> (int16_t)p_48) >> (uint16_t)11))
    { /* block id: 81 */
        l_255 = g_86.f4;
        return p_47;
    }
    else
    { /* block id: 84 */
        int64_t l_257 = 0x627CF3F8CE4E9EF1LL;
        int32_t l_260 = 0x0F3FEDECL;
        l_260 = (((+(g_86.f8 < g_159)) != l_257) & ((int16_t)p_46 >> (int16_t)13));
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_71 g_86 g_159 g_211
 * writes: g_71 g_86.f7 g_159 g_211 g_235
 */
static uint64_t  func_57(struct S0  p_58, uint16_t  p_59)
{ /* block id: 38 */
    int32_t l_61 = 0L;
    int32_t l_216 = 0xCDD5523DL;
    int32_t l_219 = 1L;
    l_216 = (l_61 <= (((((uint16_t)0UL >> (uint16_t)g_3) < __builtin_ffs(l_61)) & func_64(p_58.f3, g_3)) | ((uint16_t)((((((uint64_t)((-3L) > 0UL) - (uint64_t)p_58.f3) < 1L) > (-9L)) > p_58.f3) < l_61) / (uint16_t)1UL)));
    g_86.f7 = (((((l_219 <= p_58.f4) && g_3) >= (((int16_t)0x01DAL % (int16_t)(__builtin_ctzl(g_159) | (+p_58.f5))) == g_3)) == (p_58.f2 == 65535UL)) <= 7L);
    g_235 = (g_86.f0 & (((uint16_t)((uint16_t)((65534UL | ((__builtin_ffsl(g_86.f5) > (g_86.f1 | ((int64_t)(((int64_t)((int16_t)__builtin_ffs((__builtin_parityl(((uint64_t)l_216 - (uint64_t)func_64(g_211, p_58.f1))) >= 0x89D617F3L)) / (int16_t)p_58.f2) / (int64_t)g_86.f8) || g_86.f2) - (int64_t)g_86.f1))) && (-1L))) | 0xB1C4E8F1L) / (uint16_t)1L) << (uint16_t)13) && 0xABB7C243L));
    return p_58.f5;
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_86 g_3 g_159
 * writes: g_71 g_86.f7 g_159 g_211
 */
static uint32_t  func_64(uint32_t  p_65, uint8_t  p_66)
{ /* block id: 39 */
    const int32_t l_69 = 3L;
    int32_t l_72 = 0x1BBDB817L;
    uint16_t l_119 = 65528UL;
    struct S0 l_136 = {0xCB29D2F4L,18446744073709551609UL,0xC5516B95L,0xC1DD83CBL,-2L,0x11281BCFL,0x1ADC77BCL};
    l_72 = func_67(l_69);
    g_211 = func_73(func_76(g_71, l_72, func_82(p_66, g_71, g_86), ((int16_t)0x44E3L << (int16_t)((((int16_t)((uint16_t)(((((((int16_t)(((uint32_t)((((l_72 > l_69) < 4294967288UL) & l_72) && (-1L)) % (uint32_t)l_69) != p_66) * (int16_t)0xEF5DL) && l_119) < 0x9042C8AC77275A21LL) | p_66) || 0x513CL) || g_86.f2) << (uint16_t)l_119) * (int16_t)l_119) && (-1L)) <= p_65)), l_119), l_136);
    g_86.f7 = ((-1L) & p_65);
    return l_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_71
 */
static int32_t  func_67(const uint8_t  p_68)
{ /* block id: 40 */
    uint8_t l_70 = 0xB6L;
    g_71 = l_70;
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads : g_86.f8 g_86.f6 g_71 g_86.f3 g_86.f2 g_86.f4 g_86.f1 g_86.f7 g_3 g_86.f5 g_86.f0 g_159 g_86
 * writes: g_86.f7 g_159 g_71
 */
static const int32_t  func_73(uint64_t  p_74, struct S0  p_75)
{ /* block id: 52 */
    int32_t l_137 = 0xE19E2ED9L;
    struct S1 l_158 = {1,39,6,7811,0xFABF6489L,-53,0x56046493L,15,-22};
    if ((0x5684L ^ 1L))
    { /* block id: 53 */
        struct S1 l_157 = {1,4,5,1132,0x0FE1AEB3L,-11,0x1D071B3EL,15,-63};
        uint16_t l_180 = 1UL;
        int64_t l_196 = 0xE6EA00FD19F2AA79LL;
        p_75.f2 = l_137;
        g_159 = (((uint64_t)((func_82((((int16_t)((l_137 >= __builtin_bswap64((((~((int16_t)((int16_t)(((uint16_t)((uint16_t)p_74 - (uint16_t)(-1L)) * (uint16_t)0x3BB8L) && ((uint16_t)l_137 * (uint16_t)(p_75.f6 != ((int64_t)l_137 / (int64_t)0xFDCAD63BEFA01E2ALL)))) << (int16_t)((int16_t)func_82(__builtin_popcountl(g_86.f8), g_86.f6, l_157) << (int16_t)8)) >> (int16_t)8)) < g_86.f8) > g_3))) && p_75.f1) / (int16_t)g_86.f5) >= p_74), g_86.f5, l_158) ^ (-9L)) < 0UL) % (uint64_t)p_75.f1) && g_86.f6);
        if (((uint64_t)((((l_158.f2 >= (((uint16_t)p_74 + (uint16_t)0x652DL) & (l_157.f3 != g_86.f4))) && func_67(p_75.f5)) ^ 0xBEB0F35947468A15LL) != p_75.f6) % (uint64_t)p_74))
        { /* block id: 56 */
            g_86.f7 = ((int16_t)1L / (int16_t)__builtin_ia32_crc32qi(((uint16_t)g_86.f6 << (uint16_t)15), ((uint16_t)g_86.f7 * (uint16_t)(p_75.f4 <= ((uint32_t)l_158.f3 - (uint32_t)(((int64_t)p_75.f2 / (int64_t)p_75.f6) == ((int16_t)((uint32_t)((uint64_t)l_180 + (uint64_t)((uint32_t)(l_158.f3 & g_86.f0) / (uint32_t)p_75.f0)) - (uint32_t)p_75.f3) + (int16_t)0xDC19L)))))));
        }
        else
        { /* block id: 58 */
            int32_t l_186 = 4L;
            l_186 = ((+p_75.f4) & (((int16_t)__builtin_clz(g_86.f4) >> (int16_t)2) > __builtin_popcountl(l_158.f5)));
            p_75.f4 = p_75.f5;
            l_157.f7 = (9UL ^ ((int16_t)0L >> (int16_t)11));
            p_75.f4 = (((int16_t)p_75.f3 >> (int16_t)((int16_t)__builtin_popcount(l_158.f1) + (int16_t)0x8C7EL)) || (((int16_t)((((+(p_75.f3 >= (func_82(g_159, g_86.f7, g_86) | l_196))) ^ g_159) & p_75.f4) & g_86.f5) + (int16_t)0xC755L) > l_158.f4));
        }
    }
    else
    { /* block id: 64 */
        uint8_t l_210 = 0xDDL;
        for (l_158.f4 = (-27); (l_158.f4 == (-17)); l_158.f4 += 1)
        { /* block id: 67 */
            const uint16_t l_199 = 0xCE4BL;
            return l_199;
        }
        p_75.f4 = ((int16_t)__builtin_parityll(p_75.f6) >> (int16_t)(p_75.f5 && (0xE247L | ((0xEEDEE6F90CD53C73LL <= func_76(g_86.f0, p_75.f3, ((uint16_t)func_76(func_76((p_75.f3 & ((uint16_t)((uint32_t)((((uint32_t)g_71 / (uint32_t)l_210) <= g_159) ^ 0xA1140AC0L) / (uint32_t)4294967288UL) << (uint16_t)p_75.f5)), g_86.f2, g_86.f2, g_86.f7, g_86.f2), l_158.f8, l_158.f6, p_75.f2, g_86.f8) - (uint16_t)g_86.f3), l_158.f4, g_159)) == 0xA18CC6211D863500LL))));
    }
    return l_158.f5;
}


/* ------------------------------------------ */
/* 
 * reads : g_86.f4 g_86.f3 g_86.f7 g_86.f2 g_86.f5 g_86.f0
 * writes: g_86.f7 g_71
 */
static uint64_t  func_76(int64_t  p_77, int64_t  p_78, uint32_t  p_79, uint64_t  p_80, int16_t  p_81)
{ /* block id: 48 */
    int32_t l_130 = 6L;
    g_86.f7 = 0x7763B3A3L;
    g_86.f7 = ((int16_t)((((((((uint16_t)(0xC626D9AC2FE1997BLL == g_86.f4) * (uint16_t)((uint16_t)((uint32_t)1UL % (uint32_t)(g_86.f3 & ((uint16_t)(l_130 != ((uint64_t)((int32_t)p_81 + (int32_t)0x9387CB90L) + (uint64_t)((((-(uint16_t)g_86.f7) | func_67(p_79)) >= l_130) && g_86.f2))) >> (uint16_t)15))) >> (uint16_t)p_80)) ^ (-2L)) < l_130) <= g_86.f5) <= l_130) <= p_77) ^ g_86.f0) >> (int16_t)1);
    return l_130;
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_86.f3 g_86.f2 g_86.f4 g_86.f1 g_86.f7
 * writes: g_86.f7
 */
static uint32_t  func_82(int32_t  p_83, int32_t  p_84, struct S1  p_85)
{ /* block id: 44 */
    uint64_t l_91 = 0xDB650F83943CDC18LL;
    int32_t l_107 = 0xBBF0BED9L;
    l_107 = ((uint16_t)(((uint64_t)l_91 + (uint64_t)((int16_t)l_91 + (int16_t)p_85.f7)) >= ((((p_85.f8 <= ((uint16_t)l_91 - (uint16_t)(((int16_t)g_71 << (int16_t)((uint16_t)((uint64_t)((-(int64_t)(g_86.f3 < (p_84 & ((((((int16_t)((int64_t)((((1UL & p_85.f8) != l_91) > p_85.f7) == 65535UL) + (int64_t)l_91) >> (int16_t)g_86.f2) ^ 0x402BB9F80B5C327FLL) != l_107) >= g_86.f4) != g_86.f2)))) == g_71) * (uint64_t)0UL) >> (uint16_t)g_86.f1)) != g_86.f2))) || p_85.f2) != 0xA14E7E319870F1E5LL) != p_85.f2)) << (uint16_t)g_86.f7);
    g_86.f7 = (!g_71);
    return l_91;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_71, "g_71", print_hash_value);
    transparent_crc(g_86.f0, "g_86.f0", print_hash_value);
    transparent_crc(g_86.f1, "g_86.f1", print_hash_value);
    transparent_crc(g_86.f2, "g_86.f2", print_hash_value);
    transparent_crc(g_86.f3, "g_86.f3", print_hash_value);
    transparent_crc(g_86.f4, "g_86.f4", print_hash_value);
    transparent_crc(g_86.f5, "g_86.f5", print_hash_value);
    transparent_crc(g_86.f6, "g_86.f6", print_hash_value);
    transparent_crc(g_86.f7, "g_86.f7", print_hash_value);
    transparent_crc(g_86.f8, "g_86.f8", print_hash_value);
    transparent_crc(g_159, "g_159", print_hash_value);
    transparent_crc(g_211, "g_211", print_hash_value);
    transparent_crc(g_235, "g_235", print_hash_value);
    transparent_crc(g_278, "g_278", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 42
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 3
breakdown:
   indirect level: 0, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 4
XXX times a single bitfield on LHS: 11
XXX times a single bitfield on RHS: 52

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 29, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 238
XXX times a non-volatile is write: 32
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 49
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 10
   depth: 2, occurrence: 7

XXX percentage a fresh-made variable is used: 17.3
XXX percentage an existing variable is used: 82.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

