/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1170033900
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_29(void);
static int16_t  func_35(uint32_t  p_36, uint64_t  p_37, const int16_t  p_38, uint32_t  p_39, uint32_t  p_40);
inline static const uint16_t  func_44(uint32_t  p_45, int32_t  p_46, int64_t  p_47);
static int64_t  func_50(int16_t  p_51, uint32_t  p_52, const int16_t  p_53, uint64_t  p_54, int32_t  p_55);
inline static int32_t  func_56(int16_t  p_57, int16_t  p_58, uint32_t  p_59);
inline static int32_t  func_63(int64_t  p_64, int32_t  p_65);
inline static uint32_t  func_68(uint32_t  p_69, int32_t  p_70, int32_t  p_71);
inline static int32_t  func_76(uint16_t  p_77, int32_t  p_78, int64_t  p_79);
static const int16_t  func_82(uint32_t  p_83, const uint64_t  p_84);
static uint32_t  func_85(uint16_t  p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_30 = 0x9EDCA8FEL;
    uint32_t l_43 = 0xE7AD53A3L;
    uint32_t l_480 = 0x22A53195L;
    int32_t l_509 = (-4L);
    int32_t *l_508 = &l_509;
    int32_t **l_512 = (void*)0;
    int32_t *** const l_511 = &l_512;
    int64_t l_547 = 0x7ABB2BDB58E20E74LL;
    const int32_t l_577 = 0xBB867E96L;
    int32_t *l_592 = &l_509;
    uint32_t l_611 = 0xEF1A4A61L;
    uint16_t l_643 = 0xD86AL;
    int16_t l_719 = 0x12C6L;
    int16_t l_732 = 0x7002L;
    if ((l_30 , (safe_rshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(0x0890L, l_30)), ((func_35((safe_sub_func_int16_t_s_s((l_30 | l_43), ((0x084EL >= func_44(l_30, ((safe_rshift_func_uint16_t_u_u((0UL && ((func_50((func_56((__builtin_bswap64((+(-1L))) > l_30), l_30, l_43) , l_30), l_43, l_30, l_43, l_480) | l_480) <= l_30)), l_30)) ^ l_43), l_480)) == 0x961FFB1C195E6E49LL))), l_43, l_30, l_43, l_480) == l_30) && l_43)))))
    { /* block id: 332 */
        const int32_t l_505 = 0x178A0DB7L;
        uint32_t l_522 = 0xF08F745AL;
        uint64_t l_543 = 1UL;
        int32_t ***l_564 = &l_512;
        int32_t ****l_563 = &l_564;
        int32_t *****l_562 = &l_563;
        const int32_t l_576 = 5L;
        int32_t **l_587 = &l_508;
        int32_t *** const *l_591 = &l_564;
        int16_t l_623 = 0x5A71L;
        int64_t l_640 = 0x84A6A01E2B2023ECLL;
        if (l_505)
        { /* block id: 333 */
            int32_t l_519 = 1L;
            int32_t l_541 = (-1L);
            uint32_t l_545 = 0x86C42F34L;
            int32_t *l_549 = &l_509;
            int32_t ***l_554 = &l_512;
            int32_t *****l_581 = &l_563;
            int32_t l_588 = 0x118D950DL;
            for (l_480 = (-10); (l_480 <= 31); l_480++)
            { /* block id: 336 */
                int32_t *l_510 = (void*)0;
                l_510 = l_508;
                /* statement id: 337 */
                assert (l_510 == &l_509);
                if (((l_511 != (void*)0) || (((__builtin_ctz((safe_mod_func_uint64_t_u_u((__builtin_bswap64(((safe_sub_func_int16_t_s_s(0L, (safe_lshift_func_uint16_t_u_u(((l_519 > (*l_508)) > ((safe_add_func_uint64_t_u_u(0xEF53F30087316FB4LL, (l_519 , (((((*l_508) < l_519) , l_519) | (*l_510)) , 0x0F24C3A53F228538LL)))) , (*l_508))), l_522)))) ^ (*l_510))) ^ 1L), l_519))) != l_522) , 1UL) ^ (*l_510))))
                { /* block id: 338 */
                    int64_t l_533 = 1L;
                    const uint32_t l_544 = 4294967295UL;
                    int32_t **l_548 = &l_510;
                    int32_t *l_550 = &l_509;
                    for (l_30 = 0; (l_30 < 25); l_30 = safe_add_func_uint64_t_u_u(l_30, 5))
                    { /* block id: 341 */
                        uint32_t l_542 = 0x88DA7586L;
                        uint32_t l_546 = 0x3555016AL;
                        (*l_510) = ((safe_lshift_func_uint16_t_u_u((safe_unary_minus_func_int32_t_s(func_50(((safe_rshift_func_uint16_t_u_u((0xEB7A1B0EB0496D7ELL <= ((safe_sub_func_uint16_t_u_u((!l_533), func_50((((((((((safe_add_func_uint64_t_u_u((l_519 , (~(safe_add_func_int64_t_s_s((l_533 | ((safe_lshift_func_uint16_t_u_u((*l_510), 8)) & (l_541 , ((l_505 <= __builtin_parity((((l_542 ^ 0x6DA4L) < l_542) , l_533))) , l_543)))), l_542)))), l_542)) <= (*l_510)) <= l_533) >= l_542) == (*l_510)) <= 0x76B3F47C104E4ED9LL) , l_519) , l_544) >= 0x8F6FAFF0L), l_522, (*l_508), l_545, l_546))) & (*l_508))), 4)) ^ (*l_510)), l_505, l_543, (*l_510), l_505))), l_547)) & (*l_508));
                        (*l_508) = (l_548 != (void*)0);
                        (*l_548) = l_549;
                        l_550 = (*l_548);
                    }
                    (*l_508) = 0L;
                }
                else
                { /* block id: 348 */
                    uint32_t l_553 = 0x8EE16545L;
                    int32_t ** const *l_556 = (void*)0;
                    int32_t ** const **l_555 = &l_556;
                    for (l_522 = 0; (l_522 == 48); l_522 = safe_add_func_uint32_t_u_u(l_522, 5))
                    { /* block id: 351 */
                        if ((*l_510))
                            break;
                        return l_553;
                    }
                    (*l_555) = l_554;
                    /* statement id: 355 */
                    assert (l_556 == &l_512);
                    for (l_509 = 6; (l_509 > (-5)); l_509 = safe_sub_func_int32_t_s_s(l_509, 1))
                    { /* block id: 358 */
                        uint32_t l_561 = 0x9AE86E73L;
                        int32_t l_578 = 1L;
                        l_578 = (l_561 != (l_562 != (((((*l_510) == (((*l_510) & (!((((0x215E4A774B48B606LL | (func_50((((*l_554) == (*l_511)) == (safe_rshift_func_int16_t_s_u(((((((__builtin_ffsl(((safe_lshift_func_uint16_t_u_s(0x9D43L, (safe_add_func_int64_t_s_s((safe_mod_func_int64_t_s_s(l_561, (*l_549))), 1UL)))) , (*l_549))) | 0xEA9329BD9B6EDE9FLL) , 6L) || 0xE154L) >= (*l_508)) < 0L) != (*l_510)), l_576))), (*l_549), (*l_508), (*l_510), (*l_508)) , (*l_510))) && (*l_510)) ^ (*l_508)) , (*l_549)))) | (*l_549))) & l_577) , l_561) , &l_563)));
                    }
                    for (l_545 = 0; (l_545 < 24); l_545++)
                    { /* block id: 363 */
                        const int32_t *l_582 = (void*)0;
                        l_581 = (void*)0;
                        /* statement id: 364 */
                        assert (l_581 == 0);
                        if ((*l_510))
                            break;
                        if ((*l_508))
                            continue;
                        l_582 = (void*)0;
                    }
                }
                (*l_510) = ((*l_510) , l_505);
                (*l_549) = ((*l_508) | (*l_510));
            }
            /* facts after for loop */
            assert (l_581 == 0 || l_581 == &l_563);
            (**l_587) = ((safe_add_func_int64_t_s_s(0xB73A5177CF2D83C8LL, (((*l_508) && ((*l_508) && (*l_549))) == (((safe_lshift_func_int16_t_s_u((*l_549), ((**l_563) == l_587))) && func_56(__builtin_parityll((*l_549)), (*l_549), (*l_508))) >= l_588)))) >= (**l_587));
        }
        else
        { /* block id: 374 */
            int32_t l_606 = 1L;
            int16_t l_615 = 4L;
            int32_t **l_632 = (void*)0;
            int32_t l_639 = 6L;
            for (l_547 = 0; (l_547 <= 13); l_547 = safe_add_func_int16_t_s_s(l_547, 6))
            { /* block id: 377 */
                uint16_t l_613 = 0x0554L;
                int32_t *l_616 = &l_606;
                l_591 = &l_511;
                /* statement id: 378 */
                assert (l_591 == &l_511);
                (*l_587) = (void*)0;
                /* statement id: 379 */
                assert (l_508 == 0);
                (*l_587) = l_592;
                /* statement id: 380 */
                assert (l_508 == &l_509);
                for (l_522 = 0; (l_522 > 19); l_522 = safe_add_func_int32_t_s_s(l_522, 1))
                { /* block id: 383 */
                    int64_t l_603 = 1L;
                    int32_t l_614 = (-1L);
                    uint32_t l_641 = 1UL;
                    for (l_480 = (-6); (l_480 < 47); l_480++)
                    { /* block id: 386 */
                        int16_t l_612 = 0L;
                        l_614 = (safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_add_func_uint64_t_u_u((l_603 && ((!9L) && 0xFACAL)), (((safe_unary_minus_func_uint32_t_u((l_606 | (safe_add_func_int64_t_s_s((((safe_lshift_func_uint16_t_u_u(l_611, (3L ^ 4UL))) == (((((-6L) >= l_612) , (***l_562)) == (***l_562)) >= l_613)) , 0x15524EA8E5C578D2LL), (-1L)))))) <= l_613) & l_612))), l_612)), l_606));
                        (*l_508) = l_615;
                        if ((*l_508))
                            continue;
                        return l_614;
                    }
                    (*l_587) = l_616;
                    /* statement id: 392 */
                    assert (l_508 == &l_606);
                    for (l_480 = 13; (l_480 < 12); l_480 = safe_sub_func_uint16_t_u_u(l_480, 3))
                    { /* block id: 395 */
                        uint64_t l_621 = 6UL;
                        (*l_592) = func_68(l_606, l_603, (safe_mod_func_uint16_t_u_u(((((((((*l_616) <= ((*l_592) && l_621)) <= (!l_606)) && l_623) > (0xE331A505L & (-2L))) , l_614) & 0x54A946F482B1340ALL) , l_603), (*l_592))));
                        (*l_508) = (((safe_rshift_func_int16_t_s_u(l_614, ((safe_lshift_func_uint16_t_u_u((((safe_rshift_func_int16_t_s_u(((-1L) != ((safe_lshift_func_int16_t_s_u(((*l_616) == (*l_616)), 4)) , (((void*)0 == l_632) , (safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s((l_621 | ((safe_lshift_func_int16_t_s_s(((*l_616) || (l_639 , l_640)), 11)) || 1L)), (*l_616))), 1UL))))), 4)) , (void*)0) == (void*)0), l_621)) || 0xBAA7L))) <= (*l_592)) & 0x2E43DBF84F4D9183LL);
                    }
                    if (l_641)
                        break;
                }
                /* facts after for loop */
                assert (l_508 == &l_606 || l_508 == &l_509);
            }
            /* facts after for loop */
            assert (l_508 == &l_606 || l_508 == &l_509);
            assert (l_591 == &l_511 || l_591 == &l_564);
            (*l_508) = 2L;
        }
        /* facts after branching */
        //assert (l_508 == dangling || l_508 == &l_509);
        assert (l_591 == &l_511 || l_591 == &l_564);
        (*l_587) = &l_509;
        /* statement id: 404 */
        assert (l_508 == &l_509);
        (*l_587) = (*l_587);
    }
    else
    { /* block id: 406 */
        const uint32_t l_642 = 0x56006333L;
        int64_t l_653 = 0x36B34183E67CE0B8LL;
        int16_t l_658 = 2L;
        int16_t l_670 = (-8L);
        int32_t *l_686 = (void*)0;
        int32_t l_694 = 0x57950692L;
        int64_t l_707 = 0x1053D30818B4118CLL;
        if (l_642)
        { /* block id: 407 */
lbl_671:
            (*l_508) = ((*l_592) , l_643);
            for (l_480 = 0; (l_480 == 51); l_480 = safe_add_func_int16_t_s_s(l_480, 9))
            { /* block id: 411 */
                (*l_592) = __builtin_parityll((*l_592));
            }
        }
        else
        { /* block id: 414 */
            uint64_t l_646 = 0x0ACE2073D3078027LL;
            (*l_592) = (__builtin_ffsll(((*l_508) >= (l_646 > l_642))) == (safe_sub_func_int64_t_s_s((safe_add_func_int32_t_s_s(0x4FC1F835L, (safe_add_func_uint16_t_u_u(__builtin_parityl((*l_508)), l_653)))), ((&l_512 != &l_512) < 18446744073709551610UL))));
        }
        /* facts after branching */
        assert (l_686 == &l_694 || l_686 == &l_577 || l_686 == 0);
        for (l_643 = (-21); (l_643 != 44); l_643 = safe_add_func_uint32_t_u_u(l_643, 1))
        { /* block id: 419 */
            (*l_508) = 5L;
        }
        for (l_43 = (-12); (l_43 < 46); l_43 = safe_add_func_uint16_t_u_u(l_43, 1))
        { /* block id: 424 */
            uint32_t l_661 = 0x48E062CFL;
            int32_t l_662 = (-5L);
            uint32_t l_669 = 4294967295UL;
            int32_t l_684 = (-3L);
            const int32_t l_687 = 1L;
            int32_t *l_708 = &l_694;
            int32_t ***l_716 = &l_512;
            int32_t **l_720 = (void*)0;
            (*l_592) = l_658;
            if (__builtin_bswap32((safe_mod_func_uint64_t_u_u(l_661, l_662))))
            { /* block id: 426 */
                int32_t l_668 = 7L;
                l_668 = (((!(((((((safe_mod_func_uint16_t_u_u((*l_508), l_662)) , l_653) || (l_662 <= ((safe_mod_func_uint32_t_u_u(7UL, l_668)) >= (l_668 || l_661)))) >= l_662) <= l_669) >= 18446744073709551613UL) , l_669)) != l_670) | 0L);
                return l_661;
            }
            else
            { /* block id: 429 */
                int64_t l_672 = 0L;
                if (l_669)
                    goto lbl_671;
                if (func_35(((*l_592) , 4UL), ((8L || (l_669 >= 4294967286UL)) > ((void*)0 != (*l_511))), l_662, l_672, (*l_592)))
                { /* block id: 431 */
                    for (l_658 = 18; (l_658 != (-2)); l_658 = safe_sub_func_int16_t_s_s(l_658, 1))
                    { /* block id: 434 */
                        return l_672;
                    }
                }
                else
                { /* block id: 437 */
                    const uint64_t l_681 = 18446744073709551615UL;
                    int32_t *l_685 = &l_509;
                    (*l_592) = ((safe_lshift_func_int16_t_s_u((((safe_add_func_int16_t_s_s((safe_add_func_uint32_t_u_u(func_63((l_681 , func_76(((((func_76(l_681, l_672, l_642) != ((safe_lshift_func_uint16_t_u_s(((l_684 , l_685) == ((*l_685) , l_686)), l_662)) && (*l_685))) == (*l_685)) & l_653) , 0xC8C4L), (*l_592), (*l_685))), (*l_685)), l_687)), (-3L))) >= l_672) , l_672), 5)) || 8UL);
                    return l_672;
                }
            }
            if ((~__builtin_clzl(l_661)))
            { /* block id: 442 */
                int32_t **l_689 = &l_686;
                (*l_689) = &l_577;
                /* statement id: 443 */
                assert (l_686 == &l_577);
                if (l_669)
                    goto lbl_671;
            }
            else
            { /* block id: 445 */
                int32_t *l_692 = &l_509;
                int32_t ****l_728 = (void*)0;
                int32_t *l_730 = &l_509;
                int32_t **l_731 = &l_730;
                for (l_611 = 21; (l_611 != 31); l_611 = safe_add_func_uint16_t_u_u(l_611, 2))
                { /* block id: 448 */
                    uint16_t l_693 = 65526UL;
                    int32_t l_697 = 0xA9A83281L;
                    int32_t **l_709 = &l_692;
                    l_692 = l_686;
                    /* statement id: 449 */
                    assert (l_692 == &l_694 || l_692 == &l_577 || l_692 == 0);
                    (*l_592) = (__builtin_parity(l_693) ^ l_694);
                    for (l_669 = 0; (l_669 < 21); l_669 = safe_add_func_int64_t_s_s(l_669, 4))
                    { /* block id: 453 */
                        const uint32_t l_701 = 0xD0448252L;
                        uint64_t l_702 = 18446744073709551615UL;
                        (*l_508) = l_697;
                        (*l_592) = (((!(safe_lshift_func_uint16_t_u_s(0xC5E6L, 6))) | ((l_701 != l_701) || __builtin_bswap64(((l_702 && l_687) || ((safe_lshift_func_uint16_t_u_u(0x24E3L, (safe_mod_func_int64_t_s_s(l_661, l_707)))) && l_702))))) | 0x9BC6L);
                    }
                    (*l_709) = l_708;
                    /* statement id: 457 */
                    assert (l_692 == &l_694);
                }
                /* facts after for loop */
                assert (l_692 == &l_694 || l_692 == &l_509);
                l_686 = &l_694;
                /* statement id: 459 */
                assert (l_686 == &l_694);
                for (l_684 = 0; (l_684 != (-21)); l_684 = safe_sub_func_int64_t_s_s(l_684, 3))
                { /* block id: 462 */
                    const int32_t *l_713 = &l_577;
                    const int32_t **l_712 = &l_713;
                    int32_t *l_722 = (void*)0;
                    uint16_t l_727 = 1UL;
                    int16_t l_729 = 0xDC96L;
                    (*l_712) = l_692;
                    /* statement id: 463 */
                    assert (l_713 == &l_694 || l_713 == &l_509);
                    (*l_712) = l_708;
                    /* statement id: 464 */
                    assert (l_713 == &l_694);
                    if ((safe_add_func_uint64_t_u_u(func_68((*l_692), (*l_686), (l_716 != (void*)0)), ((((*l_592) && (safe_sub_func_uint64_t_u_u(func_68((*l_686), l_719, (l_720 != &l_692)), (*l_508)))) , (*l_708)) ^ (*l_686)))))
                    { /* block id: 465 */
                        int32_t *l_721 = &l_694;
                        l_721 = l_692;
                        /* statement id: 466 */
                        assert (l_721 == &l_694 || l_721 == &l_509);
                        l_721 = l_722;
                        /* statement id: 467 */
                        assert (l_721 == 0);
                    }
                    else
                    { /* block id: 468 */
                        int32_t *l_726 = &l_509;
                        (*l_726) = ((((~(*l_686)) || ((65535UL || (*l_692)) >= (safe_mod_func_int32_t_s_s(1L, (*l_692))))) , l_726) == &l_694);
                        (*l_592) = (func_35(l_727, (*l_713), (*l_713), (((&l_511 == l_728) | ((*l_592) && (*l_726))) ^ (**l_712)), ((*l_686) && l_729)) <= (**l_712));
                    }
                }
                (*l_731) = l_730;
            }
            /* facts after branching */
            assert (l_686 == &l_694 || l_686 == &l_577);
        }
    }
    (*l_511) = (*l_511);
    return l_732;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_35(uint32_t  p_36, uint64_t  p_37, const int16_t  p_38, uint32_t  p_39, uint32_t  p_40)
{ /* block id: 328 */
    int32_t l_501 = 0L;
    int32_t *l_500 = &l_501;
    int32_t **l_499 = &l_500;
    int32_t ***l_498 = &l_499;
    int32_t l_504 = 0xF76AEF64L;
    (**l_498) = ((l_498 == (((*l_500) , ((((p_37 >= (safe_sub_func_int64_t_s_s((&l_499 != (void*)0), (*l_500)))) , p_38) < 1UL) < l_504)) , &l_499)) , (**l_498));
    (**l_499) = (p_39 & (p_39 | (*l_500)));
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_44(uint32_t  p_45, int32_t  p_46, int64_t  p_47)
{ /* block id: 325 */
    int32_t l_486 = 0xC03F76D6L;
    const int32_t *l_485 = &l_486;
    const int32_t **l_484 = &l_485;
    int32_t *l_497 = &l_486;
    (*l_497) = (l_484 != ((safe_add_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u(p_47, (((**l_484) ^ (p_46 <= (**l_484))) || (safe_rshift_func_uint16_t_u_u(((((&l_485 == &l_485) , (safe_mod_func_uint64_t_u_u((((safe_mod_func_int64_t_s_s(((*l_485) != p_46), (**l_484))) , 0xD99DL) > (*l_485)), (*l_485)))) && p_46) || (*l_485)), (**l_484)))))) || p_47), 0x4FB4L)) , &l_485));
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_50(int16_t  p_51, uint32_t  p_52, const int16_t  p_53, uint64_t  p_54, int32_t  p_55)
{ /* block id: 318 */
    int64_t l_483 = (-1L);
    for (p_54 = (-5); (p_54 <= 55); p_54++)
    { /* block id: 321 */
        return p_55;
    }
    return l_483;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_56(int16_t  p_57, int16_t  p_58, uint32_t  p_59)
{ /* block id: 37 */
    int32_t l_93 = 0L;
    int32_t *l_92 = &l_93;
    int32_t **l_91 = &l_92;
    int64_t l_282 = 0x7DE68C300E812EFDLL;
    int32_t ** const *l_422 = &l_91;
    int32_t ** const **l_421 = &l_422;
    int32_t ** const ***l_420 = &l_421;
    uint16_t l_441 = 0x8520L;
    for (p_58 = 7; (p_58 <= (-28)); p_58 = safe_sub_func_uint32_t_u_u(p_58, 7))
    { /* block id: 40 */
        int32_t l_89 = 8L;
        int32_t *****l_424 = (void*)0;
        uint32_t l_444 = 0UL;
        int32_t l_453 = (-3L);
    }
    (****l_421) = ((((__builtin_clz((*****l_420)) , (p_57 , (*l_92))) && (((((void*)0 != (**l_421)) && ((*l_420) == (*l_420))) >= ((*l_92) <= 0x30E4C0C7L)) != (****l_421))) || p_58) != (*****l_420));
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_63(int64_t  p_64, int32_t  p_65)
{ /* block id: 247 */
    int16_t l_393 = 0xF0E3L;
    uint64_t l_394 = 0xD6F59A46947678D6LL;
    int32_t l_396 = 0x950CD63CL;
    int32_t *l_395 = &l_396;
    int32_t **l_398 = &l_395;
    int32_t ***l_397 = &l_398;
lbl_413:
    (*l_395) = (safe_lshift_func_uint16_t_u_s((p_64 || (safe_rshift_func_uint16_t_u_u(p_64, 11))), ((1UL & (4294967295UL == p_64)) <= ((l_393 , (0x8E06L | func_76(p_65, (l_393 , p_65), l_394))) && p_65))));
    (*l_397) = &l_395;
    if (p_65)
    { /* block id: 250 */
        uint64_t l_399 = 1UL;
        int32_t *l_402 = &l_396;
        if (((((((((l_399 , (safe_rshift_func_uint16_t_u_u(__builtin_parityll(l_399), p_65))) >= l_399) >= l_399) == (*l_395)) , (*l_398)) != &p_65) >= (*l_395)) > 7UL))
        { /* block id: 251 */
            int32_t ** const *l_411 = &l_398;
            int32_t ** const **l_410 = &l_411;
            int32_t ** const ***l_409 = &l_410;
            (*l_398) = l_402;
            if (l_393)
                goto lbl_412;
lbl_412:
            (*****l_409) = (safe_add_func_uint32_t_u_u((safe_add_func_int32_t_s_s((safe_mod_func_uint64_t_u_u((p_65 < (func_68(p_65, (((p_65 | (p_64 | (p_65 , (0x3340L < (*l_402))))) <= (((void*)0 != l_409) >= (*l_395))) , (***l_411)), (**l_398)) , (***l_411))), (***l_397))), (***l_411))), (***l_411)));
            (**l_398) = __builtin_parityll(((****l_410) , (0x3143L >= 0x007DL)));
            return p_64;
        }
        else
        { /* block id: 257 */
            if (p_65)
                goto lbl_413;
            (*l_395) = 0x4FF2353BL;
        }
    }
    else
    { /* block id: 261 */
        (**l_397) = &p_65;
        /* statement id: 262 */
        assert (l_395 == &p_65);
    }
    /* facts after branching */
    assert (l_395 == &p_65 || l_395 == &l_396);
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_68(uint32_t  p_69, int32_t  p_70, int32_t  p_71)
{ /* block id: 164 */
    uint32_t l_283 = 0x90EEBE92L;
    int32_t l_290 = 0x226D0443L;
    int32_t *l_295 = &l_290;
    int32_t **l_294 = &l_295;
    int32_t ***l_293 = &l_294;
    int32_t ****l_292 = &l_293;
    int32_t *****l_291 = &l_292;
    uint64_t l_333 = 18446744073709551608UL;
    uint64_t l_377 = 18446744073709551614UL;
    int16_t l_380 = 0xBA11L;
    int32_t *l_383 = &l_290;
    if (l_283)
    { /* block id: 165 */
        int32_t l_285 = (-10L);
        int32_t *l_284 = &l_285;
        uint32_t l_297 = 2UL;
        int32_t l_306 = 0L;
        (*l_284) = ((void*)0 != l_284);
        for (p_71 = 0; (p_71 == 9); p_71 = safe_add_func_uint16_t_u_u(p_71, 8))
        { /* block id: 169 */
            int32_t *****l_296 = &l_292;
            int16_t l_324 = 0L;
            for (l_285 = 11; (l_285 <= (-18)); l_285--)
            { /* block id: 172 */
                int64_t l_305 = 0x656022EB11DCCF77LL;
                int32_t l_307 = 0x98E07820L;
                if (l_290)
                { /* block id: 173 */
                    uint16_t l_304 = 65526UL;
                    if (func_85(l_283))
                    { /* block id: 174 */
                        l_296 = l_291;
                        (*l_295) = (l_297 != p_70);
                        (*****l_296) = ((*l_284) <= p_69);
                        l_307 = (safe_mod_func_int32_t_s_s(p_69, (safe_rshift_func_int16_t_s_u((safe_sub_func_uint32_t_u_u(l_304, ((((((p_71 , (6L | 7L)) & ((l_304 , (0x939C0F99L || (*****l_296))) <= (l_305 || 2UL))) > l_306) , 0x0B7D7F6AL) != p_69) > p_71))), 4))));
                    }
                    else
                    { /* block id: 179 */
                        int64_t l_314 = (-8L);
                        int32_t **l_315 = &l_295;
                        (*****l_296) = (safe_lshift_func_uint16_t_u_s((safe_sub_func_int64_t_s_s((safe_rshift_func_int16_t_s_s(l_307, l_314)), (l_315 == (void*)0))), ((void*)0 == (****l_296))));
                        l_284 = (****l_296);
                        /* statement id: 181 */
                        assert (l_284 == &l_290);
                    }
                    /* facts after branching */
                    assert (l_284 == &l_290 || l_284 == &l_285);
                    (*****l_291) = (safe_add_func_uint32_t_u_u((*l_284), (((safe_sub_func_int16_t_s_s((safe_mod_func_uint32_t_u_u(((*****l_291) <= ((((safe_lshift_func_uint16_t_u_s((p_70 < p_70), 6)) >= __builtin_parityl((*l_284))) , (p_69 <= (-3L))) > ((***l_293) & p_69))), 0x81C7AF72L)), l_324)) , p_71) ^ l_305)));
                    return p_69;
                }
                else
                { /* block id: 185 */
                    (****l_296) = (p_70 , ((__builtin_ffs((****l_292)) , 3L) , (***l_292)));
                    return l_307;
                }
            }
            if (p_69)
                continue;
            (***l_292) = (****l_291);
        }
    }
    else
    { /* block id: 193 */
        int32_t ****l_325 = &l_293;
        int32_t l_326 = 1L;
lbl_355:
        (**l_293) = ((((l_325 == l_325) , ((p_70 , (((((****l_292) <= (****l_292)) | p_71) || l_326) & p_70)) , ((((p_71 , 0x1E13L) , (****l_325)) , &l_325) != &l_325))) > p_71) , (***l_325));
        for (p_69 = 26; (p_69 <= 16); p_69 = safe_sub_func_uint32_t_u_u(p_69, 1))
        { /* block id: 197 */
            uint64_t l_336 = 3UL;
            int32_t **** const l_337 = &l_293;
            int16_t l_352 = 0L;
            int32_t *l_354 = &l_326;
            int64_t l_356 = 0x9090C8C004BFBC94LL;
            if ((safe_sub_func_int32_t_s_s(__builtin_parityll((p_69 || (p_70 && func_82(p_71, (safe_lshift_func_int16_t_s_s(l_333, 8)))))), func_85((*l_295)))))
            { /* block id: 198 */
                int32_t *****l_338 = &l_292;
                if ((safe_lshift_func_int16_t_s_s((((l_336 , l_337) != (void*)0) <= ((4L > (l_338 != &l_337)) < p_69)), 5)))
                { /* block id: 199 */
                    int32_t *****l_343 = (void*)0;
                    (****l_292) = (((safe_sub_func_uint32_t_u_u(((***l_337) != (***l_325)), (***l_293))) || (((func_85((safe_add_func_int32_t_s_s(p_71, ((l_343 == (p_70 , ((safe_sub_func_uint32_t_u_u(1UL, (safe_mod_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_u((*****l_338), 9)) & (safe_add_func_int32_t_s_s(__builtin_parityl((((****l_325) != (****l_292)) , (****l_337))), 0x9A8A8730L))) , (-7L)), (****l_337))))) , (void*)0))) , (***l_293))))) & (*****l_338)) > (*l_295)) == (-2L))) > (*****l_291));
                    if (func_82((&l_292 != l_338), (****l_337)))
                    { /* block id: 201 */
                        (***l_293) = (****l_337);
                        if ((*****l_338))
                            continue;
                        if (l_352)
                            continue;
                    }
                    else
                    { /* block id: 205 */
                        int32_t *****l_353 = &l_292;
                        (*****l_338) = p_71;
                        (****l_337) = p_71;
                        (***l_325) = (***l_337);
                        (*l_353) = l_337;
                    }
                }
                else
                { /* block id: 211 */
                    (***l_337) = l_354;
                    /* statement id: 212 */
                    assert (l_295 == &l_326);
                    (***l_325) = (****l_338);
                }
                if (p_69)
                    goto lbl_355;
                if (p_70)
                { /* block id: 216 */
                    (***l_325) = (***l_337);
                }
                else
                { /* block id: 218 */
                    int32_t l_359 = (-10L);
                    int32_t l_363 = 0x86B31674L;
                    if (l_356)
                    { /* block id: 219 */
                        int32_t ** const *** const l_360 = (void*)0;
                        (***l_293) = ((****l_325) >= (safe_rshift_func_uint16_t_u_u(l_359, (((-1L) & (l_360 == (void*)0)) , (****l_325)))));
                        l_363 = (safe_rshift_func_int16_t_s_u(p_70, 1));
                        if (p_70)
                            continue;
                    }
                    else
                    { /* block id: 223 */
                        (*l_294) = (***l_337);
                    }
                }
            }
            else
            { /* block id: 227 */
                int32_t l_374 = (-1L);
                int32_t l_381 = 0x6700F83CL;
                int32_t ****l_382 = &l_293;
                l_381 = (4294967295UL && ((safe_add_func_int32_t_s_s((((safe_add_func_int32_t_s_s(p_70, (safe_add_func_int64_t_s_s((safe_rshift_func_int16_t_s_s(l_374, 5)), 5UL)))) & ((p_71 || ((l_377 != (((&l_337 != ((safe_mod_func_uint16_t_u_u((l_380 ^ (****l_325)), (***l_293))) , &l_337)) , p_70) && p_71)) >= (****l_292))) < p_70)) != 5UL), 0x63181019L)) , p_70));
                (*l_354) = (l_382 != (void*)0);
            }
            (****l_291) = (***l_337);
        }
    }
    /* facts after branching */
    //assert (l_295 == dangling || l_295 == &l_290);
    l_290 = p_71;
    (*l_383) = ((*l_291) != (*l_291));
    for (l_283 = (-13); (l_283 == 33); l_283 = safe_add_func_int64_t_s_s(l_283, 1))
    { /* block id: 238 */
        int32_t l_388 = 0x379CF198L;
        for (p_69 = (-7); (p_69 >= 55); p_69 = safe_add_func_uint64_t_u_u(p_69, 1))
        { /* block id: 241 */
            return l_388;
        }
        return l_388;
    }
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_76(uint16_t  p_77, int32_t  p_78, int64_t  p_79)
{ /* block id: 155 */
    int64_t l_260 = 0xE0C3C7F25558BBB9LL;
    int64_t l_273 = 0L;
    int32_t l_281 = (-1L);
    int32_t *l_280 = &l_281;
    for (p_78 = 0; (p_78 > 0); p_78++)
    { /* block id: 158 */
        int32_t * const l_270 = (void*)0;
        int32_t * const *l_269 = &l_270;
        int32_t * const **l_268 = &l_269;
        int32_t * const ***l_267 = &l_268;
        int32_t *l_271 = (void*)0;
        int32_t l_272 = 0xBAC825AFL;
        l_272 = (l_260 <= (safe_add_func_int64_t_s_s((safe_sub_func_int64_t_s_s(((18446744073709551615UL < l_260) != (((l_260 >= ((safe_add_func_uint64_t_u_u(0x8C4D48E721F199CALL, ((((l_267 != (p_77 , (((*l_267) == (void*)0) , &l_268))) , p_78) , 6UL) , l_260))) && p_77)) == p_79) || 0x47CEFB77572B0FFDLL)), p_79)), l_260)));
        return l_260;
    }
    (*l_280) = (l_273 || ((((safe_rshift_func_uint16_t_u_u(65531UL, 9)) || (-4L)) ^ (0x1CD2L | func_82((l_260 | (safe_add_func_uint64_t_u_u((p_79 > ((0xD747B503L == (safe_add_func_int32_t_s_s((l_260 ^ l_273), p_79))) == l_260)), p_77))), l_273))) >= (-1L)));
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_82(uint32_t  p_83, const uint64_t  p_84)
{ /* block id: 44 */
    int64_t l_100 = 0x59A6287676E3B61ELL;
    int32_t l_105 = 1L;
    int32_t *l_104 = &l_105;
    int16_t l_117 = 0x179DL;
    int32_t ** const *l_123 = (void*)0;
    const int32_t ****l_146 = (void*)0;
    const int32_t *****l_145 = &l_146;
    const uint16_t l_179 = 65535UL;
    uint16_t l_219 = 0UL;
    int32_t **l_255 = &l_104;
    if ((safe_lshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_s(1L, 10)), (((((safe_mod_func_int16_t_s_s(l_100, (l_100 , 0xA880L))) && ((p_84 , (safe_unary_minus_func_uint16_t_u(l_100))) <= (safe_lshift_func_int16_t_s_u(((void*)0 != l_104), 8)))) , (safe_unary_minus_func_uint64_t_u(((safe_add_func_int16_t_s_s((&l_105 == &l_105), 1UL)) != 9L)))) <= 1L) <= 4294967295UL))))
    { /* block id: 45 */
        int32_t * const l_109 = &l_105;
        int32_t **l_110 = &l_104;
        int32_t ***l_111 = &l_110;
        (*l_110) = l_109;
        (*l_111) = &l_109;
        /* statement id: 47 */
        assert (l_110 == &l_109);
    }
    else
    { /* block id: 48 */
        int32_t **l_112 = (void*)0;
        int32_t **l_113 = (void*)0;
        int32_t **l_114 = &l_104;
        (*l_114) = (p_84 , &l_105);
        (*l_114) = (*l_114);
    }
    (*l_104) = (safe_mod_func_uint32_t_u_u((l_117 >= (-7L)), ((*l_104) | ((safe_mod_func_uint16_t_u_u((p_83 | (((((*l_104) , p_84) , (+0x433A0315L)) , &l_104) == (p_84 , &l_104))), (*l_104))) , (*l_104)))));
    if (p_84)
    { /* block id: 53 */
        int32_t l_124 = 1L;
        (*l_104) = func_85(p_84);
        (*l_104) = ((safe_add_func_int16_t_s_s(((l_123 != (func_85((((l_124 < ((p_84 && (safe_rshift_func_uint16_t_u_u(((safe_sub_func_int32_t_s_s((p_83 || (0x887233EDL && 0x56BCC6B8L)), p_84)) , (((((0xBD055D51L != (((((safe_rshift_func_int16_t_s_s((((*l_104) , l_124) > p_84), 5)) , 0x63F3D54CDCAC19DALL) ^ 0L) >= l_124) || l_124)) ^ p_84) == p_84) && p_83) == p_83)), (*l_104)))) >= l_124)) != l_124) && 1UL)) , l_123)) & l_124), p_84)) > l_124);
        (*l_104) = p_84;
    }
    else
    { /* block id: 57 */
        int32_t **l_133 = &l_104;
        int32_t ***l_132 = &l_133;
        int32_t ****l_131 = &l_132;
        int32_t * const ****l_134 = (void*)0;
        int32_t l_229 = 1L;
        int32_t ****l_248 = &l_132;
        l_131 = l_131;
        if (((0x38ADD527L != 1L) && (((***l_132) >= 65530UL) || (((!(****l_131)) < (((p_83 | 0xD4C9L) < func_85((***l_132))) , 0x7F541A3ACD9B7196LL)) , p_83))))
        { /* block id: 59 */
            int32_t **l_136 = &l_104;
            (*l_132) = l_136;
        }
        else
        { /* block id: 61 */
            int32_t l_137 = 0x0C2C5401L;
            (***l_131) = ((l_137 | p_84) , (***l_131));
            if (l_117)
                goto lbl_138;
lbl_138:
            (*l_133) = (*l_133);
            (*l_104) = ((p_83 > p_83) <= (safe_sub_func_uint32_t_u_u(__builtin_ctz(((p_84 | ((safe_lshift_func_uint16_t_u_u(0x0B43L, 14)) >= p_83)) == l_137)), 7L)));
        }
        for (l_105 = 0; (l_105 <= 13); l_105++)
        { /* block id: 69 */
            uint32_t l_147 = 0x19B67119L;
            int32_t l_148 = 0x8EB29201L;
            int32_t *l_149 = &l_148;
            l_148 = ((((void*)0 != l_145) ^ (p_83 <= func_85(p_84))) <= l_147);
            (*l_149) = p_83;
            return p_83;
        }
        for (l_100 = 0; (l_100 == (-6)); l_100 = safe_sub_func_int16_t_s_s(l_100, 3))
        { /* block id: 76 */
            int32_t ****l_154 = &l_132;
            uint32_t l_155 = 9UL;
            uint32_t l_173 = 9UL;
            const int32_t *****l_251 = &l_146;
        }
    }
    (*l_255) = (void*)0;
    /* statement id: 153 */
    assert (l_104 == 0);
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_85(uint16_t  p_86)
{ /* block id: 41 */
    int32_t *l_87 = (void*)0;
    int32_t **l_88 = &l_87;
    (*l_88) = l_87;
    return p_86;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 194
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 206
   depth: 2, occurrence: 41
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 11, occurrence: 5
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 5
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 115

XXX times a variable address is taken: 128
XXX times a pointer is dereferenced on RHS: 203
breakdown:
   depth: 1, occurrence: 130
   depth: 2, occurrence: 13
   depth: 3, occurrence: 27
   depth: 4, occurrence: 25
   depth: 5, occurrence: 8
XXX times a pointer is dereferenced on LHS: 104
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 9
   depth: 3, occurrence: 15
   depth: 4, occurrence: 6
   depth: 5, occurrence: 5
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 626

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 273
   level: 2, occurrence: 65
   level: 3, occurrence: 128
   level: 4, occurrence: 92
   level: 5, occurrence: 35
XXX number of pointers point to pointers: 75
XXX number of pointers point to scalars: 40
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.2
XXX average alias set size: 1.21

XXX times a non-volatile is read: 1166
XXX times a non-volatile is write: 352
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 5

XXX stmts: 189
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 28
   depth: 2, occurrence: 32
   depth: 3, occurrence: 25
   depth: 4, occurrence: 31
   depth: 5, occurrence: 41

XXX percentage a fresh-made variable is used: 19.7
XXX percentage an existing variable is used: 80.3
********************* end of statistics **********************/

