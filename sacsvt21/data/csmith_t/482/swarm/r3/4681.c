/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      1329328114
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int16_t  f0;
   int16_t  f1;
   int8_t * f2;
   uint16_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int32_t * func_22(float * p_23, int32_t * p_24, uint32_t  p_25, float * p_26);
static int16_t  func_30(int8_t  p_31, float * p_32, int16_t  p_33);
static uint16_t  func_46(int8_t * p_47, int16_t  p_48);
static int8_t * func_49(int32_t  p_50);
static union U0 * func_59(uint16_t  p_60, uint16_t  p_61, union U0 * p_62, uint32_t  p_63, int32_t  p_64);
static int32_t  func_66(union U0  p_67, int16_t  p_68, int32_t  p_69, int32_t  p_70);
static union U0  func_71(int32_t * p_72, uint32_t  p_73, union U0 * p_74);
static int32_t * func_75(int32_t * p_76, float * p_77, int32_t * p_78);
static int32_t * func_79(int32_t * p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 5;
    float l_369 = 0x9.50E586p+4;
    float *l_368 = &l_369;
    int32_t l_1058 = 0;
    int8_t l_1059 = 0;
    int32_t l_1079 = 0x1B0BA7DC;
    int32_t *l_1090 = &l_1058;
    int32_t **l_1089 = &l_1090;
    int32_t ***l_1088 = &l_1089;
    int32_t ****l_1087 = &l_1088;
    uint16_t l_1094 = 0xEECF;
    int8_t *l_1117 = &l_1059;
    int16_t l_1128 = 0x4E28;
    for (l_2 = (-30); (l_2 != 20); l_2 += 1)
    { /* block id: 3 */
        int32_t l_9 = 9;
        int32_t *l_8 = &l_9;
        int8_t l_11 = 0x42;
        int8_t *l_10 = &l_11;
        int32_t l_20 = 0xCA6C8490;
        int32_t l_21 = 0x0F0F5EBE;
        uint32_t l_1039 = 4294967293U;
        int32_t ***l_1095 = &l_1089;
        (*l_8) |= (!(((uint16_t)l_2 % (uint16_t)l_2) >= l_2));
        if (((void*)0 != l_10))
        { /* block id: 5 */
            int32_t *l_29 = &l_2;
            int32_t **l_1055 = &l_8;
            int32_t ***l_1054 = &l_1055;
            int32_t ****l_1053 = &l_1054;
            uint32_t l_1082 = 0U;
            union U0 l_1093 = {0x3593};
            union U0 *l_1092 = &l_1093;
            union U0 **l_1099 = &l_1092;
            union U0 ***l_1098 = &l_1099;
            for (l_9 = 0; (l_9 >= 7); l_9 += 5)
            { /* block id: 8 */
                float l_15 = 0xD.257EA0p-35;
                float *l_14 = &l_15;
                (*l_14) = 0x8.Bp+1;
            }
            for (l_9 = 0; (l_9 == (-23)); l_9 -= 1)
            { /* block id: 13 */
                int8_t *l_37 = (void*)0;
                int32_t l_361 = (-2);
                float l_363 = 0xB.CE18C4p-18;
                float *l_362 = &l_363;
                int32_t l_1025 = 0xEA56C8BB;
                union U0 *l_1026 = (void*)0;
                union U0 l_1028 = {-6};
                union U0 *l_1027 = &l_1028;
                int32_t l_1060 = 0xF5BF2376;
                union U0 **l_1062 = &l_1027;
                union U0 ***l_1061 = &l_1062;
                if (((uint32_t)0U % (uint32_t)l_20))
                { /* block id: 14 */
                    float l_28 = 0x8.Dp-1;
                    float *l_27 = &l_28;
                    int8_t *l_36 = &l_11;
                    int32_t *l_41 = &l_2;
                    union U0 l_1014 = {0};
                    union U0 *l_1013 = &l_1014;
                    union U0 **l_1012 = &l_1013;
                    if (l_21)
                    { /* block id: 15 */
                        int32_t *l_40 = &l_2;
                        uint32_t l_56 = 0x5D57D38C;
                        l_29 = func_22(l_27, l_29, ((func_30((((*l_29) >= ((((((l_36 != l_37) ^ ((uint16_t)0x91F4 >> (uint16_t)3)) < (l_40 == l_41)) != ((uint32_t)((int32_t)(func_46(func_49(((int16_t)((-(uint16_t)((uint32_t)(*l_8) + (uint32_t)2U)) ^ l_56) << (int16_t)l_2)), (*l_8)) || l_2) + (int32_t)0xFC6094E3) % (uint32_t)l_361)) || (*l_29)) <= (*l_40))) == (*l_29)), l_362, (*l_41)) >= 8) && 0x78CA0275), l_368);
                    }
                    else
                    { /* block id: 204 */
                        int16_t l_1011 = 0xE6C8;
                        int32_t l_1024 = 0x06D6DA98;
                        l_21 ^= (((uint16_t)(((((~(l_1011 | ((void*)0 == l_1012))) ^ ((uint16_t)l_361 >> (uint16_t)4)) < ((int32_t)(~(((*l_29) ^ ((*l_8) >= ((uint16_t)((l_1011 ^ 7) || ((int32_t)l_2 + (int32_t)l_1024)) >> (uint16_t)(*l_8)))) > l_1025)) % (int32_t)l_1025)) ^ 0xCCEF) == l_1011) - (uint16_t)(*l_29)) >= l_2);
                    }
                    l_1027 = l_1026;
                    /* statement id: 207 */
                    assert (l_1027 == 0);
                    for (l_11 = 15; (l_11 <= (-11)); l_11 -= 1)
                    { /* block id: 210 */
                        (*l_27) = ((((*l_29) >= (*l_8)) <= ((*l_8) <= (*l_29))) != (-0x8.Cp+1));
                        if (l_2)
                            continue;
                    }
                }
                else
                { /* block id: 214 */
                    int8_t l_1036 = 3;
                    (*l_368) = ((-0x5.1p+1) > ((*l_29) >= (!(((((((float)((void*)0 != l_37) + (float)l_2) >= ((l_2 > ((((((float)l_1036 + (float)((float)(0xB.1D5DA4p+25 >= ((*l_8) > 0x0.Cp-1)) - (float)(*l_29))) != 0x5.FC40BDp-65) != l_1028.f0) == 0x3.3C01E4p-70) <= l_1036)) > l_2)) > l_2) > l_1025) != l_1039) == l_2))));
                }
                /* facts after branching */
                assert (l_1027 == &l_1028 || l_1027 == 0);
                l_21 ^= ((uint32_t)(((int16_t)((uint16_t)((int32_t)((int16_t)0x26D3 << (int16_t)0) - (int32_t)((*l_29) != ((*l_29) > 0xBDB78435))) * (uint16_t)(((int16_t)(-(uint32_t)((void*)0 == l_1053)) << (int16_t)(((-1) && l_1028.f0) || (((uint16_t)0x7B41 << (uint16_t)l_1058) >= 1))) < l_2)) >> (int16_t)l_1059) >= l_1060) - (uint32_t)(*l_8));
                l_1058 = ((-1) && (*l_8));
                if (l_1028.f0)
                { /* block id: 219 */
                    int8_t *l_1074 = &l_1059;
                    int32_t ****l_1091 = (void*)0;
                    if ((l_1061 != &l_1062))
                    { /* block id: 220 */
                        uint16_t l_1063 = 0x47BD;
                        return l_1063;
                    }
                    else
                    { /* block id: 222 */
                        int32_t *l_1064 = &l_1058;
                        int8_t *l_1065 = &l_11;
                        (*l_1064) = (*l_29);
                        (*l_1064) |= l_1059;
                        l_1079 |= ((((void*)0 == l_1065) | ((uint16_t)((uint16_t)((int16_t)((uint16_t)(l_1074 == l_1074) + (uint16_t)((!(l_1059 > (-(uint32_t)(*l_1064)))) != ((uint32_t)(65533U | ((65532U && ((void*)0 == (*l_1055))) == (*l_1064))) % (uint32_t)0x7C0D2549))) >> (int16_t)l_1028.f0) - (uint16_t)l_2) % (uint16_t)l_1059)) == (-1));
                    }
                    (*l_1090) = (((int32_t)l_1060 + (int32_t)l_1082) | ((uint16_t)0x907D >> (uint16_t)(((((int16_t)((l_1087 == l_1091) || (l_1092 != (void*)0)) >> (int16_t)7) & ((l_1028.f3 & 0xF838D8A4) & (-7))) == (*l_8)) <= l_1094)));
                    (*l_1087) = l_1095;
                }
                else
                { /* block id: 229 */
                    uint32_t l_1104 = 0xC2887185;
                    int32_t *l_1106 = &l_1079;
                    (*l_1106) |= ((int16_t)((void*)0 == l_1098) + (int16_t)(1 != ((((int16_t)(***l_1054) % (int16_t)0x956D) < (((int32_t)l_1104 - (int32_t)(l_1104 >= ((((~((*l_8) ^ l_1028.f1)) <= l_1060) || (***l_1088)) ^ l_1028.f3))) | l_1104)) || (*l_29))));
                }
            }
        }
        else
        { /* block id: 233 */
            int32_t l_1107 = (-1);
            return l_1107;
        }
    }
    for (l_2 = (-29); (l_2 > (-19)); l_2 += 3)
    { /* block id: 239 */
        uint32_t l_1112 = 0x4EA6EF19;
        int32_t l_1115 = 0x63696280;
        int16_t l_1116 = 1;
        float **l_1120 = &l_368;
        float ***l_1119 = &l_1120;
        int32_t l_1127 = 1;
        for (l_1094 = 0; (l_1094 != 27); l_1094 += 9)
        { /* block id: 242 */
            if (l_1112)
                break;
        }
        for (l_1112 = 15; (l_1112 != 33); l_1112 += 9)
        { /* block id: 247 */
            l_1115 &= (**l_1089);
            (*l_368) = l_1116;
        }
        l_1127 ^= ((&l_1059 == l_1117) != ((-(uint16_t)(**l_1089)) < ((((((((l_1119 != &l_1120) <= (((uint16_t)((uint16_t)(*l_1090) << (uint16_t)1) << (uint16_t)3) > ((int16_t)(***l_1088) << (int16_t)l_1115))) | 0xC71C) > 1) & l_1112) != 0x9B6D16E8) & l_1116) & l_1112)));
    }
    return l_1128;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_22(float * p_23, int32_t * p_24, uint32_t  p_25, float * p_26)
{ /* block id: 156 */
    union U0 *l_386 = (void*)0;
    union U0 **l_385 = &l_386;
    union U0 ***l_384 = &l_385;
    int32_t l_387 = 0x25049E14;
    int32_t l_483 = 0xBF352B2F;
    int32_t l_488 = (-1);
    int32_t **l_513 = (void*)0;
    int32_t ***l_512 = &l_513;
    int32_t ****l_511 = &l_512;
    float l_532 = 0x1.2CBD4Fp-57;
    float *l_540 = &l_532;
    float **l_539 = &l_540;
    int16_t l_545 = (-1);
    uint16_t l_551 = 0xAD3A;
    int32_t l_615 = (-1);
    int32_t l_644 = 0;
    int32_t l_664 = 0xFBFECCAF;
    int32_t l_701 = 0x1FD59596;
    int32_t l_825 = 7;
    int32_t l_829 = 0;
    int32_t l_859 = 0xAE0B7F6A;
    int32_t l_885 = 0x18B5DF59;
    int32_t l_937 = 0x72B6EE79;
    int32_t l_1001 = 0x8D525250;
    uint32_t l_1004 = 4294967293U;
    uint32_t l_1007 = 0x684B30D6;
    for (p_25 = (-5); (p_25 > 59); p_25++)
    { /* block id: 159 */
        uint32_t l_382 = 0x53B75FD9;
        union U0 *l_383 = (void*)0;
        int32_t l_558 = 0x5B01B43F;
        int32_t l_567 = 0;
        int32_t l_656 = (-1);
        int32_t l_658 = 0x6533EEAB;
        int32_t l_659 = 9;
        int32_t l_669 = 0xD4E39346;
        int32_t l_731 = (-5);
        int32_t l_845 = 0x9EF578FA;
        int32_t l_848 = (-1);
        int32_t l_870 = 0x5F571398;
        int32_t l_877 = 0;
        int32_t l_896 = 0x345E8C4A;
        int32_t l_917 = 0x630A4816;
        int32_t l_921 = 8;
        int32_t l_936 = 4;
        int32_t l_968 = (-1);
        int32_t l_990 = 5;
    }
    l_1007 = ((void*)0 == &l_384);
    return p_24;
    /* statement id: 202 */
    //assert (func_22_rv == &l_2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_30(int8_t  p_31, float * p_32, int16_t  p_33)
{ /* block id: 152 */
    float l_364 = 0xE.1D9B12p-4;
    int32_t l_365 = 0x4DCD17E7;
    int32_t *l_366 = &l_365;
    uint32_t l_367 = 4294967287U;
    (*l_366) = l_365;
    (*l_366) = l_367;
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_46(int8_t * p_47, int16_t  p_48)
{ /* block id: 149 */
    int32_t l_346 = 0x0D91D209;
    int32_t **l_351 = (void*)0;
    int32_t ***l_350 = &l_351;
    int32_t ****l_349 = &l_350;
    int32_t *l_359 = &l_346;
    int16_t l_360 = 0x6885;
    (*l_359) = ((l_346 == 0x64BF) >= (((((int16_t)(l_349 == (void*)0) + (int16_t)p_48) == ((~p_48) != ((((((int16_t)((uint16_t)p_48 >> (uint16_t)4) >> (int16_t)6) < p_48) != p_48) | p_48) > p_48))) == p_48) != 0xC7D8));
    return l_360;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t * func_49(int32_t  p_50)
{ /* block id: 16 */
    int32_t l_58 = 0x954656E2;
    int32_t *l_57 = &l_58;
    union U0 l_104 = {-1};
    union U0 *l_103 = &l_104;
    union U0 **l_337 = (void*)0;
    union U0 **l_338 = (void*)0;
    int8_t l_340 = 1;
    int8_t *l_339 = &l_340;
    int8_t *l_341 = &l_340;
    int8_t *l_342 = &l_340;
    int8_t *l_343 = &l_340;
    int8_t *l_344 = &l_340;
    int8_t *l_345 = (void*)0;
    (*l_57) = 6;
    (*l_57) = p_50;
    l_103 = func_59((-(int32_t)func_66(func_71(func_75(func_79(&l_58), l_57, &p_50), p_50, l_103), (l_104.f1 | 0x117B57B0), l_104.f0, l_104.f0)), l_104.f3, &l_104, l_104.f0, l_104.f1);
    return l_345;
    /* statement id: 148 */
    //assert (func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_59(uint16_t  p_60, uint16_t  p_61, union U0 * p_62, uint32_t  p_63, int32_t  p_64)
{ /* block id: 128 */
    int32_t l_281 = 0;
    uint32_t l_286 = 0xE0C7EA76;
    int32_t *l_287 = (void*)0;
    int32_t l_289 = 0x5A6DD64F;
    int32_t *l_288 = &l_289;
    union U0 l_303 = {1};
    union U0 *l_302 = &l_303;
    uint32_t l_336 = 4294967287U;
    (*l_288) ^= (((uint16_t)((int16_t)l_281 + (int16_t)((int32_t)0x82E8E322 - (int32_t)4U)) >> (uint16_t)((int16_t)p_64 - (int16_t)l_286)) < 0xE11B9957);
    if ((-(int16_t)(*l_288)))
    { /* block id: 130 */
        int32_t l_295 = 1;
        uint16_t l_298 = 0x6036;
        float *l_299 = (void*)0;
        float l_301 = 0x8.6p+1;
        float *l_300 = &l_301;
        union U0 *l_304 = &l_303;
        (*l_300) = ((float)(((float)(p_64 == (p_61 < (0x5.7p-1 != l_295))) - (float)((0x7.AAFCD2p+38 >= ((((((float)(l_287 != (void*)0) + (float)((((((-0x1.Ap-1) <= (p_60 != 0x6.Dp-1)) < 0x6.7E9CDBp+99) == p_61) == 0xC.41D7ACp-52) == p_61)) > 0x0.8993ECp-35) <= l_295) != (*l_288)) > l_298)) == p_60)) <= 0x4.A4E5B7p+74) - (float)p_61);
        l_295 = (p_64 < p_60);
        return p_62;
        /* statement id: 133 */
        //assert (func_59_rv == &l_104);
    }
    else
    { /* block id: 134 */
        int32_t *l_305 = &l_289;
        union U0 *l_318 = &l_303;
        int32_t ***l_325 = (void*)0;
        if (p_60)
        { /* block id: 135 */
            float l_306 = 0xC.3E3130p-21;
            l_305 = func_79(l_305);
            (*l_305) = ((p_63 >= ((p_63 && ((int16_t)((int32_t)p_64 + (int32_t)((int16_t)(~(-1)) << (int16_t)12)) << (int16_t)1)) < (((int16_t)(1 || ((uint32_t)((*l_305) ^ (-1)) + (uint32_t)((p_64 <= 0) != 0xF329C724))) << (int16_t)4) || 0x9325))) != (*l_305));
        }
        else
        { /* block id: 138 */
            union U0 *l_319 = &l_303;
            int32_t **l_322 = &l_287;
            int32_t ***l_321 = &l_322;
            int32_t ****l_323 = (void*)0;
            int32_t ****l_324 = (void*)0;
            l_319 = l_318;
            (*l_305) = (!p_61);
            (*l_305) |= (-1);
            l_325 = l_321;
            /* statement id: 142 */
            assert (l_325 == &l_322);
        }
        /* facts after branching */
        //assert (l_325 == dangling || l_325 == 0);
    }
    (*l_288) = (((((p_64 == ((uint16_t)(*l_288) - (uint16_t)((((uint16_t)((1U ^ ((l_288 != l_288) <= (((int16_t)(((int16_t)((6U ^ 1) <= ((&l_302 == (void*)0) >= p_63)) >> (int16_t)(*l_288)) > (*l_288)) >> (int16_t)2) & 0x2F6CE27E))) ^ (*l_288)) >> (uint16_t)(*l_288)) | 0xDFEF) == l_336))) < p_64) >= 0xC94A) | p_63) <= p_61);
    return p_62;
    /* statement id: 146 */
    //assert (func_59_rv == &l_104);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_66(union U0  p_67, int16_t  p_68, int32_t  p_69, int32_t  p_70)
{ /* block id: 37 */
    int32_t l_111 = 0xBDADCC66;
    int32_t *l_110 = &l_111;
    int32_t **l_112 = &l_110;
    union U0 ***l_172 = (void*)0;
    float l_215 = 0x9.56CE49p+26;
    float *l_214 = &l_215;
    (*l_110) &= p_70;
lbl_183:
    (*l_112) = &p_70;
    /* statement id: 39 */
    assert (l_110 == &p_70);
    for (p_70 = (-28); (p_70 > (-14)); p_70 += 6)
    { /* block id: 42 */
        int32_t l_117 = 1;
        float l_126 = (-0x9.7p+1);
        float *l_125 = &l_126;
        union U0 l_154 = {0xCF24};
        union U0 *l_153 = &l_154;
        union U0 **l_203 = &l_153;
        union U0 ***l_202 = &l_203;
        if (((uint16_t)l_117 - (uint16_t)(-4)))
        { /* block id: 43 */
            int32_t *l_124 = &l_111;
            (*l_124) ^= ((int16_t)(((int16_t)l_117 - (int16_t)((((0xA070 >= p_68) < (0x06D4EB3E != ((p_69 ^ (-1)) == (l_110 != l_110)))) ^ ((0x4CD1 != p_67.f0) | p_67.f0)) >= (*l_110))) >= l_117) << (int16_t)p_69);
            (*l_112) = &p_69;
            /* statement id: 45 */
            assert (l_110 == &p_69);
        }
        else
        { /* block id: 46 */
            union U0 l_131 = {2};
            union U0 *l_130 = &l_131;
            p_69 &= (((uint16_t)(-(uint16_t)(l_130 != &p_67)) >> (uint16_t)p_70) <= (l_117 & ((l_117 | ((0 ^ (*l_110)) || l_117)) ^ (((0x5C58EAAB | l_117) < l_131.f0) && l_117))));
            for (p_69 = 0; (p_69 <= (-2)); p_69 -= 1)
            { /* block id: 50 */
                int32_t *l_134 = &l_117;
                (*l_134) = 9;
            }
        }
        /* facts after branching */
        assert (l_110 == &p_70 || l_110 == &p_69);
        if (p_68)
        { /* block id: 54 */
            return l_117;
        }
        else
        { /* block id: 56 */
            uint16_t l_142 = 0xB992;
            uint16_t l_147 = 2U;
            float *l_150 = &l_126;
            union U0 *l_166 = &l_154;
            int32_t l_180 = 0x40F41BBA;
            union U0 **l_189 = (void*)0;
            union U0 ***l_188 = &l_189;
            int32_t **l_197 = &l_110;
            int32_t *l_239 = (void*)0;
            p_69 = ((uint16_t)((uint16_t)((((int16_t)p_67.f1 << (int16_t)4) != ((((65526U || (!((((((p_69 | (*l_110)) | p_70) != ((**l_112) < (l_142 <= ((~(((~((((int32_t)(p_69 == (*l_110)) - (int32_t)l_142) != 0) <= l_117)) != l_117) || l_147)) <= p_67.f3)))) != p_67.f1) < p_67.f0) < l_117))) > l_117) && (**l_112)) || p_67.f0)) || 0U) << (uint16_t)l_142) >> (uint16_t)15);
            for (l_142 = (-7); (l_142 > 54); l_142 += 9)
            { /* block id: 60 */
                int16_t l_163 = 0x3CAE;
                int32_t l_175 = 0xBBDA2652;
                uint32_t l_179 = 0x24657F32;
                union U0 **l_187 = &l_166;
                union U0 ***l_186 = &l_187;
                float *l_227 = &l_126;
                if (p_70)
                    break;
            }
            return p_67.f3;
        }
    }
    for (p_70 = (-30); (p_70 < 21); p_70++)
    { /* block id: 111 */
        int32_t l_269 = (-8);
        (*l_214) = l_269;
        if (p_68)
            goto lbl_183;
        if (p_69)
            break;
        for (l_111 = 0; (l_111 >= (-6)); l_111 -= 1)
        { /* block id: 117 */
            int32_t *l_275 = (void*)0;
            for (l_269 = 0; (l_269 < (-28)); l_269 -= 1)
            { /* block id: 120 */
                int32_t *l_274 = &l_269;
                l_274 = l_275;
                /* statement id: 121 */
                assert (l_274 == 0);
            }
            (*l_112) = func_79(&l_269);
            /* statement id: 123 */
            assert (l_110 == &l_269);
            (*l_110) = (~4294967289U);
        }
        /* facts after for loop */
        //assert (l_110 == &l_269 || l_110 == dangling || l_110 == &p_70);
    }
    /* facts after for loop */
    //assert (l_110 == dangling || l_110 == &p_70);
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_71(int32_t * p_72, uint32_t  p_73, union U0 * p_74)
{ /* block id: 33 */
    int32_t l_106 = 9;
    int32_t *l_105 = &l_106;
    union U0 l_109 = {-1};
    l_105 = func_79(p_72);
    /* statement id: 34 */
    //assert (l_105 == &p_50);
    (*l_105) = ((int16_t)(*l_105) % (int16_t)p_73);
    return l_109;
    /* statement id: 36 */
    //assert (func_71_rv.f2 == dangling);
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_75(int32_t * p_76, float * p_77, int32_t * p_78)
{ /* block id: 27 */
    int8_t *l_92 = (void*)0;
    int32_t l_93 = 1;
    union U0 l_97 = {0x3F91};
    union U0 *l_96 = &l_97;
    float *l_99 = (void*)0;
    union U0 **l_101 = (void*)0;
    union U0 ***l_100 = &l_101;
    int32_t *l_102 = &l_93;
    (*p_76) ^= (*p_78);
    (*p_76) = 1;
    (*p_77) = ((((((float)(l_92 == l_92) + (float)(*p_77)) == (((((l_93 != ((float)(((l_96 == &l_97) > (*p_77)) > (-(float)(((void*)0 == l_99) < 0x5.ABB25Ap+98))) + (float)0xE.E4CABBp-56)) <= 0xD.28DA4Cp-95) <= 0x0.9E1B0Fp+97) <= l_97.f0) < 0x4.02D8B6p+73)) <= l_97.f1) <= 0x7.C815F7p-0) == 0x3.249A23p-3);
    (*l_100) = (void*)0;
    return p_78;
    /* statement id: 32 */
    //assert (func_75_rv == &p_50);
}


/* ------------------------------------------ */
/* 
 * reads : p_50
 * writes: p_50
 */
static int32_t * func_79(int32_t * p_80)
{ /* block id: 19 */
    int32_t l_81 = 0x87F9BD85;
    int32_t *l_89 = &l_81;
    for (l_81 = 19; (l_81 > 13); l_81 -= 1)
    { /* block id: 22 */
        int32_t *l_84 = &l_81;
        return p_80;
        /* statement id: 23 */
        //assert (func_79_rv == &l_58 || func_79_rv == &p_50 || func_79_rv == &p_69 || func_79_rv == &l_269 || func_79_rv == &l_289);
    }
    (*p_80) &= (((int16_t)(((uint16_t)l_81 - (uint16_t)l_81) < l_81) - (int16_t)(4294967295U != l_81)) == l_81);
    return p_80;
    /* statement id: 26 */
    //assert (func_79_rv == &l_58 || func_79_rv == &p_50 || func_79_rv == &p_69 || func_79_rv == &l_269 || func_79_rv == &l_289);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 212
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 26
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 18, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 621

XXX times a variable address is taken: 497
XXX times a pointer is dereferenced on RHS: 98
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 15
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 60
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 1
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 1346

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 221
   level: 2, occurrence: 48
   level: 3, occurrence: 27
   level: 4, occurrence: 18
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 58
XXX number of pointers point to scalars: 544
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.3
XXX average alias set size: 1.04

XXX times a non-volatile is read: 639
XXX times a non-volatile is write: 177
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 98
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 16
   depth: 2, occurrence: 23
   depth: 3, occurrence: 8
   depth: 4, occurrence: 8
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 25.7
XXX percentage an existing variable is used: 74.3
********************* end of statistics **********************/

