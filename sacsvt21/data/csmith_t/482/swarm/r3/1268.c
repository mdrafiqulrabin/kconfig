/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      477549796
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int16_t  f1;
   uint32_t  f2;
   float  f3;
   int8_t  f4;
};

struct S1 {
   float  f0;
   float  f1;
};

/* --- GLOBAL VARIABLES --- */
static int8_t g_4 = 0xBA;
static uint32_t g_49 = 0x57511ECB;
static struct S0 g_78 = {0x0A0C2010,0x6516,4294967295U,0xA.48ECA1p+1,1};
static uint32_t g_198 = 0x579843EB;
static int32_t g_236 = (-3);
static int8_t g_246 = 0xC3;
static int32_t g_249 = (-1);
static uint32_t g_256 = 4294967295U;


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_26(void);
static int32_t  func_29(float  p_30, int16_t  p_31, int32_t  p_32, uint32_t  p_33, int32_t  p_34);
static float  func_36(int8_t  p_37, uint32_t  p_38, int8_t  p_39, struct S0  p_40);
static struct S0  func_42(uint32_t  p_43, float  p_44);
static uint16_t  func_52(int8_t  p_53);
inline static int8_t  func_54(int8_t  p_55, int32_t  p_56, int32_t  p_57, struct S0  p_58, int32_t  p_59);
inline static uint32_t  func_72(struct S0  p_73, struct S1  p_74, struct S0  p_75, int32_t  p_76, int8_t  p_77);
inline static struct S1  func_79(uint16_t  p_80);
inline static uint16_t  func_86(uint16_t  p_87, float  p_88, int32_t  p_89);
static int32_t  func_98(int32_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_49 g_78 g_198 g_236 g_256 g_249 g_246
 * writes: g_49 g_78.f3 g_78.f2 g_78.f0 g_236 g_256
 */
static uint16_t  func_26(void)
{ /* block id: 36 */
    int32_t l_41 = 0xF7C8B166;
    int16_t l_284 = 0xD044;
    if (((int32_t)func_29((-(float)func_36(l_41, g_4, g_4, func_42((4294967295U != (((uint32_t)l_41 - (uint32_t)((uint16_t)1U % (uint16_t)l_41)) <= 0x1940)), (0x2.204102p-64 >= 0xD.7FD074p+28)))), l_284, g_246, l_284, l_41) / (int32_t)l_41))
    { /* block id: 125 */
        return g_78.f0;
    }
    else
    { /* block id: 127 */
        return g_236;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_78.f3
 */
static int32_t  func_29(float  p_30, int16_t  p_31, int32_t  p_32, uint32_t  p_33, int32_t  p_34)
{ /* block id: 121 */
    float l_285 = 0xD.5E2949p-63;
    l_285 = p_31;
    g_78.f3 = (((float)(-0x3.Ap+1) - (float)0x0.7p-1) <= p_31);
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads : g_78.f0 g_78.f2 g_4 g_249 g_78.f4
 * writes:
 */
static float  func_36(int8_t  p_37, uint32_t  p_38, int8_t  p_39, struct S0  p_40)
{ /* block id: 113 */
    int16_t l_273 = 8;
    int32_t l_283 = 0;
    for (p_40.f1 = 0; (p_40.f1 > 11); ++p_40.f1)
    { /* block id: 116 */
        return g_78.f0;
    }
    l_283 = ((uint32_t)((int16_t)((uint16_t)0x3732 / (uint16_t)l_273) % (int16_t)(((((p_37 ^ (-(uint16_t)((uint32_t)(((__builtin_popcountll(((int16_t)g_78.f2 >> (int16_t)14)) ^ l_273) != ((uint32_t)((int16_t)((g_249 ^ (1U && 0x80CF)) <= 0x43BD0F48) << (int16_t)p_38) - (uint32_t)g_78.f4)) || 0x09979B65) / (uint32_t)l_273))) && l_273) & l_273) ^ p_37) & 0x5996FE7B)) - (uint32_t)(-3));
    return p_40.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_78 g_4 g_198 g_236 g_256
 * writes: g_49 g_78.f3 g_78.f2 g_78.f0 g_236 g_256
 */
static struct S0  func_42(uint32_t  p_43, float  p_44)
{ /* block id: 37 */
    float l_68 = 0x6.ACDD1Fp+96;
    int32_t l_71 = (-9);
    struct S0 l_82 = {0xEE8E20E6,-8,0xD98C7BE4,0xC.0DB5B4p+16,0xD7};
    int32_t l_241 = 4;
    int32_t l_242 = 0x87F24904;
    int32_t l_243 = 0x2E5F2695;
    int32_t l_244 = 0xD88CF5AA;
    int32_t l_245 = 0x8A552695;
    int32_t l_247 = 9;
    int32_t l_248 = 0x74E767B0;
    int32_t l_250 = 0x67D2B290;
    int32_t l_251 = 0x8799A7C4;
    int32_t l_252 = 0xA7C66632;
    int32_t l_253 = 0;
    int32_t l_254 = 0xD661819A;
    int32_t l_255 = (-1);
    g_49 |= 0xA5D87207;
    for (g_49 = 0; (g_49 <= 49); ++g_49)
    { /* block id: 41 */
        int8_t l_60 = (-3);
        struct S0 l_222 = {-1,0x3DAB,0xF45AC62A,0xA.A11651p-54,0xD2};
        int32_t l_240 = 0xD7FE986F;
        l_240 &= ((g_49 == func_52(func_54(l_60, ((uint16_t)((uint16_t)(((~p_43) < g_49) && ((uint16_t)(l_60 ^ 0xF10DEC53) >> (uint16_t)((((uint16_t)l_71 << (uint16_t)(func_72(g_78, func_79(((g_49 ^ l_71) <= (-10))), l_82, p_43, g_78.f0) == 1)) < 1U) | p_43))) << (uint16_t)7) << (uint16_t)4), p_43, l_222, g_4))) & 0);
    }
    g_256++;
    if (g_236)
    { /* block id: 107 */
        int8_t l_263 = (-1);
        int32_t l_264 = 0x22B2D8C6;
        l_264 = ((p_43 && (((uint32_t)__builtin_clzll((__builtin_ffsl(p_43) || ((int16_t)((g_78.f1 <= p_43) & __builtin_bswap32(p_43)) >> (int16_t)func_86(g_256, g_78.f3, g_78.f2)))) - (uint32_t)l_263) == 4U)) == l_252);
    }
    else
    { /* block id: 109 */
        g_236 &= p_43;
    }
    return l_82;
}


/* ------------------------------------------ */
/* 
 * reads : g_78.f2 g_78.f1 g_78.f0 g_198 g_236 g_78 g_49
 * writes: g_78.f2 g_236 g_78.f0
 */
static uint16_t  func_52(int8_t  p_53)
{ /* block id: 93 */
    struct S0 l_224 = {0xB5F74D8A,4,0x86180D30,0xD.82E326p+54,0xC8};
    uint32_t l_237 = 0x25431BED;
    l_224 = l_224;
    for (g_78.f2 = 11; (g_78.f2 < 37); g_78.f2 += 7)
    { /* block id: 97 */
        int32_t l_229 = 0x7BA18CC8;
        struct S0 l_235 = {1,0x702A,0x049431B3,0x7.2p+1,-1};
        g_236 ^= ((int16_t)((g_78.f2 | (((0x9F1A27D7 >= l_229) <= ((int16_t)(-3) + (int16_t)0x3ABD)) || (-(int32_t)((int16_t)(g_78.f1 == func_54(g_78.f1, p_53, l_224.f1, l_235, g_78.f1)) + (int16_t)p_53)))) > g_198) >> (int16_t)14);
        l_229 = p_53;
        g_78.f0 = func_54(l_237, (4294967293U ^ g_198), ((int16_t)p_53 + (int16_t)g_236), g_78, g_49);
        l_235.f0 = p_53;
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_78.f0
 * writes:
 */
inline static int8_t  func_54(int8_t  p_55, int32_t  p_56, int32_t  p_57, struct S0  p_58, int32_t  p_59)
{ /* block id: 89 */
    int16_t l_223 = 0x123F;
    l_223 = g_78.f0;
    p_59 |= 6;
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_78.f0 g_49 g_78.f2 g_78.f1 g_78.f4 g_198
 * writes: g_78.f3 g_78.f2 g_78.f0
 */
inline static uint32_t  func_72(struct S0  p_73, struct S1  p_74, struct S0  p_75, int32_t  p_76, int8_t  p_77)
{ /* block id: 44 */
    uint16_t l_85 = 65533U;
    int32_t l_221 = 0x4F2632C0;
    g_78.f3 = ((float)l_85 / (float)p_73.f4);
    l_221 |= (func_86((((__builtin_ctzll(p_73.f2) | ((uint16_t)0U << (uint16_t)12)) != 6U) < ((int16_t)((int16_t)(((int16_t)(l_85 || __builtin_clzll(l_85)) << (int16_t)13) <= func_98(__builtin_ctzl(l_85))) / (int16_t)p_75.f1) >> (int16_t)0)), g_78.f1, g_198) | 0U);
    return l_221;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_79(uint16_t  p_80)
{ /* block id: 42 */
    struct S1 l_81 = {0x0.0p+1,0x0.1p-1};
    return l_81;
}


/* ------------------------------------------ */
/* 
 * reads : g_78.f0 g_4 g_49 g_78.f2 g_78.f1 g_78.f4 g_198
 * writes: g_78.f2 g_78.f0 g_78.f3
 */
inline static uint16_t  func_86(uint16_t  p_87, float  p_88, int32_t  p_89)
{ /* block id: 81 */
    struct S1 l_218 = {0x2.Cp+1,0x9.AF1FBAp-48};
    struct S1 l_219 = {0x6.4p+1,-0x1.Ap+1};
    struct S0 l_220 = {0x11B8B91D,0xDA0B,4294967291U,-0x8.0p-1,0x8D};
    p_89 = 0xA3D40197;
    p_88 = func_98(g_78.f0);
    l_219 = l_218;
    l_220 = l_220;
    return l_220.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_78.f0 g_4 g_49 g_78.f2 g_78.f1 g_78.f4 g_198
 * writes: g_78.f2 g_78.f0 g_78.f3
 */
static int32_t  func_98(int32_t  p_99)
{ /* block id: 46 */
    float l_104 = 0x9.4p+1;
    int32_t l_105 = 0x86846FFD;
    struct S1 l_109 = {0x0.5p+1,0x1.8p+1};
    struct S1 l_110 = {-0x10.1p+1,-0x10.2p+1};
    uint32_t l_200 = 0x2E7E9FB3;
    int32_t l_217 = 1;
    p_99 = ((int16_t)(((int16_t)((((g_78.f0 >= l_105) <= ((p_99 > (g_78.f0 ^ p_99)) && ((uint16_t)(-(int32_t)g_4) - (uint16_t)g_49))) || g_78.f2) != 65531U) + (int16_t)g_4) <= 8U) % (int16_t)g_78.f1);
    l_110 = l_109;
    if ((!(((uint32_t)(((int16_t)p_99 << (int16_t)(g_4 < p_99)) != ((int16_t)((g_78.f4 > (-1)) <= l_105) >> (int16_t)(-(int16_t)g_4))) - (uint32_t)0U) < ((uint32_t)((int32_t)(g_4 != l_105) % (int32_t)7) + (uint32_t)g_78.f1))))
    { /* block id: 49 */
        int32_t l_128 = 0;
        uint32_t l_135 = 0x98DEB230;
        int32_t l_153 = 0x5ECD179B;
        int8_t l_197 = 0x8A;
        for (g_78.f2 = 5; (g_78.f2 > 41); g_78.f2 += 4)
        { /* block id: 52 */
            for (l_105 = (-5); (l_105 >= (-9)); l_105 -= 3)
            { /* block id: 55 */
                int16_t l_133 = (-1);
                float l_134 = 0x1.Ap+1;
                g_78.f0 = (!(l_128 > (!((((uint32_t)((p_99 || g_4) || 0x792CDF46) - (uint32_t)1U) >= ((((!p_99) > l_133) < l_135) && p_99)) == p_99))));
            }
            l_153 = ((int32_t)((uint32_t)__builtin_ffsl(l_105) - (uint32_t)((p_99 == (((int16_t)((int16_t)g_78.f2 / (int16_t)(-5)) << (int16_t)(((-(uint16_t)((int16_t)((((p_99 & ((0x0511 | g_78.f0) ^ ((uint32_t)((uint32_t)((uint32_t)(0xF0DE >= (-1)) - (uint32_t)g_78.f4) / (uint32_t)p_99) / (uint32_t)g_49))) || 0x336C) > l_128) <= 0x9AC8) % (int16_t)l_135)) || p_99) < 0xE64C31C2)) == p_99)) < g_49)) + (int32_t)0x3DD5295B);
        }
        g_78.f0 = ((uint32_t)l_105 / (uint32_t)((int16_t)g_4 + (int16_t)p_99));
        if ((((l_153 > ((l_128 && 0xBD42CCF7) < (g_4 > ((int16_t)__builtin_parity(g_78.f4) >> (int16_t)15)))) == (g_78.f2 | g_4)) > p_99))
        { /* block id: 61 */
            int8_t l_162 = 0x03;
            for (l_135 = 0; (l_135 != 26); l_135++)
            { /* block id: 64 */
                uint32_t l_181 = 0xEF3A8CD9;
                int32_t l_182 = (-1);
                l_162 = g_4;
                l_153 ^= ((uint32_t)p_99 % (uint32_t)((-5) && (((int32_t)(((uint16_t)(((uint16_t)p_99 << (uint16_t)5) ^ 4294967295U) / (uint16_t)((uint16_t)g_78.f1 >> (uint16_t)(g_78.f1 & g_78.f2))) || (((uint16_t)((uint16_t)((int32_t)(__builtin_ctzl(((uint16_t)l_181 + (uint16_t)g_78.f4)) <= p_99) % (int32_t)p_99) + (uint16_t)0x3D9D) << (uint16_t)9) > p_99)) / (int32_t)0x2C44E1F5) && g_4)));
                l_182 = g_4;
                l_182 |= ((65526U != (((uint32_t)p_99 / (uint32_t)p_99) <= (((int32_t)(l_181 <= 0x8F5FB703) / (int32_t)l_162) && 1U))) == (__builtin_ctzll((l_162 & (0xFB177962 == l_181))) && 0xB1F273F2));
            }
        }
        else
        { /* block id: 70 */
            int16_t l_199 = 0x98AF;
            int32_t l_201 = 1;
            l_199 |= (((uint16_t)((((((int32_t)0 / (int32_t)(p_99 & (((l_128 == g_78.f0) == (((uint32_t)p_99 / (uint32_t)((uint16_t)((uint32_t)l_197 - (uint32_t)((0 <= __builtin_ia32_crc32qi(g_78.f0, p_99)) > p_99)) % (uint16_t)g_4)) >= g_198)) <= l_105))) ^ (-1)) ^ p_99) <= p_99) && l_135) % (uint16_t)(-9)) == l_105);
            l_153 = 0x0.Dp-1;
            l_201 |= l_200;
            g_78.f3 = ((float)(g_49 > 0x0.9p+1) / (float)0x9.C138C4p+80);
        }
    }
    else
    { /* block id: 76 */
        int32_t l_204 = 2;
        return l_204;
    }
    l_217 = ((int16_t)(~p_99) >> (int16_t)((((int16_t)((~l_105) >= (((uint32_t)(p_99 | 0x1C9D4F09) - (uint32_t)l_200) == (p_99 == (l_105 >= g_198)))) << (int16_t)((uint32_t)p_99 % (uint32_t)0xC714A41B)) < g_198) != 0x429456BC));
    return l_105;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_49, "g_49", print_hash_value);
    transparent_crc(g_78.f0, "g_78.f0", print_hash_value);
    transparent_crc(g_78.f1, "g_78.f1", print_hash_value);
    transparent_crc(g_78.f2, "g_78.f2", print_hash_value);
    transparent_crc_bytes (&g_78.f3, sizeof(g_78.f3), "g_78.f3", print_hash_value);
    transparent_crc(g_78.f4, "g_78.f4", print_hash_value);
    transparent_crc(g_198, "g_198", print_hash_value);
    transparent_crc(g_236, "g_236", print_hash_value);
    transparent_crc(g_246, "g_246", print_hash_value);
    transparent_crc(g_249, "g_249", print_hash_value);
    transparent_crc(g_256, "g_256", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 57
   depth: 1, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 8
   depth: 3, occurrence: 3
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 4
   depth: 15, occurrence: 2
   depth: 18, occurrence: 3
   depth: 20, occurrence: 2
   depth: 22, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 216
XXX times a non-volatile is write: 41
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 58
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 14
   depth: 2, occurrence: 7
   depth: 3, occurrence: 5

XXX percentage a fresh-made variable is used: 25.4
XXX percentage an existing variable is used: 74.6
********************* end of statistics **********************/

