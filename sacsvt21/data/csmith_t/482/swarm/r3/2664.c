/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      2806579958
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 9;
   signed f1 : 26;
};
#pragma pack(pop)

union U1 {
   volatile int32_t  f0;
   int32_t  f1;
   uint32_t  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_3 = 0;
static volatile int32_t g_53 = (-9);/* VOLATILE GLOBAL g_53 */
static float g_54 = 0xA.E5DE2Cp-33;
static int32_t g_87 = 0x0F60517E;
static int32_t *g_108 = &g_87;
static int32_t **g_107 = &g_108;
static struct S0 g_115 = {4,6610};
static int32_t **g_127 = &g_108;
static int32_t g_129 = 0x26E4AE47;
static int32_t g_147 = 0x28501D8D;
static union U1 g_260 = {0};/* VOLATILE GLOBAL g_260 */
static union U1 *g_259 = &g_260;
static union U1 **g_258 = &g_259;
static volatile union U1 *g_295 = (void*)0;
static volatile struct S0 g_357 = {14,-924};/* VOLATILE GLOBAL g_357 */
static volatile struct S0 *g_356 = &g_357;
static volatile struct S0 **g_355 = &g_356;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_30(void);
static struct S0  func_31(uint16_t  p_32, float  p_33, uint32_t  p_34, int16_t  p_35, float  p_36);
static uint16_t  func_44(int32_t  p_45, uint32_t  p_46, int32_t  p_47, uint16_t  p_48);
static uint16_t  func_55(uint32_t  p_56);
static struct S0  func_75(int32_t * p_76, int32_t * p_77, int32_t * p_78, uint32_t  p_79);
static int32_t * func_80(uint32_t  p_81, float  p_82, float  p_83);
static float  func_92(int16_t  p_93);
static int16_t  func_97(struct S0  p_98, struct S0  p_99);
static struct S0  func_100(int32_t * p_101, int32_t ** p_102, uint32_t  p_103);
static int32_t ** func_104(uint32_t  p_105, int32_t ** p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_53 g_115 g_87 g_127 g_129 g_147 g_108 g_107 g_260.f1 g_54 g_356 g_357 g_355
 * writes: g_87 g_129 g_54 g_127 g_147 g_115 g_108 g_357
 */
static struct S0  func_30(void)
{ /* block id: 36 */
    int16_t l_37 = (-6);
    int32_t *l_393 = &g_147;
    union U1 **l_394 = &g_259;
    int32_t *l_397 = &g_147;
    struct S0 l_398 = {13,-1924};
    (**g_355) = func_31(l_37, (safe_div_func_float_f_f((safe_div_func_float_f_f(0x7.3876A4p+1, (safe_sub_func_float_f_f(g_3, __builtin_parityll((func_44((safe_lshift_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_s((g_3 | (__builtin_parityll(l_37) > g_3)), ((0xEA3D8810 > g_53) & g_3))) && g_3), 10)), g_3, g_3, g_3) && g_129)))))), 0x6.57B057p-7)), g_3, g_260.f1, l_37);
    (*g_107) = l_393;
    (*g_107) = l_397;
    return l_398;
}


/* ------------------------------------------ */
/* 
 * reads : g_356 g_357
 * writes:
 */
static struct S0  func_31(uint16_t  p_32, float  p_33, uint32_t  p_34, int16_t  p_35, float  p_36)
{ /* block id: 300 */
    return (*g_356);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_53 g_115 g_87 g_127 g_129 g_147 g_108 g_107 g_260.f1 g_54
 * writes: g_87 g_129 g_54 g_127 g_147 g_115 g_108
 */
static uint16_t  func_44(int32_t  p_45, uint32_t  p_46, int32_t  p_47, uint16_t  p_48)
{ /* block id: 37 */
    float l_59 = (-0x1.2p+1);
    int32_t l_374 = 0x637AF094;
    struct S0 l_377 = {16,-6780};
    uint32_t l_387 = 0xB54408C5;
    (*g_108) = __builtin_ia32_crc32qi((func_55((safe_rshift_func_uint16_t_u_u(g_3, 3))) == (safe_add_func_uint16_t_u_u(0x4BEF, (p_46 < (safe_sub_func_int32_t_s_s(((safe_sub_func_int32_t_s_s(l_374, (l_374 <= (safe_rshift_func_uint16_t_u_s(func_97(g_115, l_377), 10))))) & g_3), l_377.f1)))))), l_377.f0);
    (*g_108) = (p_46 <= l_377.f0);
    if (p_46)
    { /* block id: 286 */
        uint16_t l_378 = 0x22B6;
        float *l_383 = &g_54;
        float *l_384 = &g_54;
        (*g_107) = &p_47;
        return g_129;
    }
    else
    { /* block id: 289 */
        int16_t l_388 = 1;
        float *l_389 = &g_54;
        for (l_374 = (-7); (l_374 < 5); l_374 = safe_add_func_uint32_t_u_u(l_374, 1))
        { /* block id: 292 */
            (**g_107) = (0 & l_387);
            (**g_107) = (*g_108);
            (**g_107) &= (4294967295U || g_260.f1);
        }
        (*l_389) = (g_115.f1 >= ((p_46 <= g_54) <= func_55(l_388)));
        return g_87;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_53 g_3
 * writes:
 */
static uint16_t  func_55(uint32_t  p_56)
{ /* block id: 38 */
    float l_60 = 0x1.124C6Ep-9;
    int32_t l_67 = 7;
    int32_t l_311 = 0x8C18C883;
    struct S0 l_313 = {16,-2102};
    int32_t l_322 = 0;
    int32_t **l_345 = &g_108;
    if ((__builtin_ctzll((p_56 < ((__builtin_bswap32(g_53) < ((((safe_div_func_uint32_t_u_u((((safe_add_func_int16_t_s_s((-1), (safe_sub_func_uint16_t_u_u(l_67, (safe_rshift_func_int16_t_s_u((safe_mod_func_uint32_t_u_u(((0x6047 == 0x1EBC) && 0U), ((g_3 ^ 1) | (-9)))), 13)))))) || g_3) < 0x72AB), (-3))) != 65529U) || p_56) ^ g_3)) <= 0x5F9C))) ^ g_3))
    { /* block id: 39 */
        int32_t *l_72 = &l_67;
        (*l_72) ^= 1;
    }
    else
    { /* block id: 41 */
        int32_t *l_297 = &l_67;
        int32_t l_323 = 0xB358EA86;
        for (l_67 = 18; (l_67 == 13); l_67 = safe_sub_func_uint16_t_u_u(l_67, 5))
        { /* block id: 44 */
            int32_t l_84 = 9;
            struct S0 *l_301 = &g_115;
            struct S0 *l_326 = &l_313;
            int32_t **l_340 = &l_297;
            int32_t l_361 = 0x6BECCCDA;
            int32_t *l_366 = (void*)0;
            int32_t *l_367 = &l_361;
            if (g_53)
                break;
        }
    }
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads : g_258 g_259
 * writes: g_147
 */
static struct S0  func_75(int32_t * p_76, int32_t * p_77, int32_t * p_78, uint32_t  p_79)
{ /* block id: 228 */
    int32_t *l_298 = (void*)0;
    int32_t *l_299 = &g_147;
    struct S0 l_300 = {5,1260};
    (*l_299) = ((void*)0 == (*g_258));
    return l_300;
}


/* ------------------------------------------ */
/* 
 * reads : g_107 g_147 g_127 g_108
 * writes: g_108 g_147
 */
static int32_t * func_80(uint32_t  p_81, float  p_82, float  p_83)
{ /* block id: 46 */
    int32_t *l_86 = &g_87;
    int32_t **l_85 = &l_86;
    (*l_85) = (void*)0;
    for (p_81 = (-28); (p_81 < 56); p_81 = safe_add_func_uint16_t_u_u(p_81, 1))
    { /* block id: 50 */
        float *l_296 = &g_54;
    }
    (*g_107) = (*l_85);
    g_147 ^= p_81;
    return (*g_127);
}


/* ------------------------------------------ */
/* 
 * reads : g_87 g_107 g_3 g_108 g_53 g_115 g_127 g_129 g_147 g_54 g_258 g_259 g_260.f3 g_260.f1
 * writes: g_87 g_108 g_129 g_54 g_127 g_147 g_115 g_107 g_259
 */
static float  func_92(int16_t  p_93)
{ /* block id: 51 */
    int32_t *l_94 = &g_87;
    float *l_236 = (void*)0;
    float **l_235 = &l_236;
    struct S0 l_283 = {12,-3731};
    int32_t l_284 = (-1);
    (*l_94) = 0xF6817288;
    if ((safe_div_func_int32_t_s_s((func_97(func_100(&g_87, func_104(((*l_94) && (-1)), g_107), g_3), g_115) > p_93), p_93)))
    { /* block id: 164 */
        float **l_237 = &l_236;
        int32_t l_244 = 0x66CF8E74;
        int32_t *l_280 = &l_244;
        if ((((p_93 & (safe_add_func_int32_t_s_s(0x1170D4C1, p_93))) && ((l_235 != l_237) != (*l_94))) <= (safe_div_func_uint32_t_u_u((safe_add_func_int32_t_s_s(((((safe_mod_func_int16_t_s_s(0, p_93)) != p_93) || 1U) > l_244), 0x1EFD3BF3)), l_244))))
        { /* block id: 165 */
            uint32_t l_245 = 0xC0183FCF;
            union U1 **l_261 = &g_259;
            int32_t l_262 = (-3);
            struct S0 *l_278 = &g_115;
            (*l_94) = ((*l_94) || (((*l_94) ^ l_245) && (((((((safe_add_func_int32_t_s_s((l_244 && (&l_236 != &l_236)), (safe_mod_func_int16_t_s_s((*l_94), (__builtin_ctzll(((safe_rshift_func_int16_t_s_u((*l_94), ((void*)0 == l_236))) ^ p_93)) & p_93))))) || g_115.f1) <= g_53) == g_147) > l_245) || 1) <= g_3)));
            for (l_244 = 29; (l_244 <= (-7)); l_244 = safe_sub_func_uint16_t_u_u(l_244, 1))
            { /* block id: 169 */
                return g_54;
            }
            if (p_93)
            { /* block id: 172 */
                union U1 *l_255 = (void*)0;
                union U1 **l_254 = &l_255;
                (*l_254) = (void*)0;
                if ((0 & (g_258 != l_261)))
                { /* block id: 174 */
                    int16_t l_263 = 0x073D;
                    if (l_244)
                    { /* block id: 175 */
                        l_262 |= __builtin_parityll(l_245);
                    }
                    else
                    { /* block id: 177 */
                        (*g_107) = (void*)0;
                        l_263 = 0x1.1p-1;
                    }
                }
                else
                { /* block id: 181 */
                    int32_t ***l_264 = &g_107;
                    (*l_264) = (void*)0;
                    (*g_258) = (*g_258);
                    if ((safe_unary_minus_func_int32_t_s((((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(((safe_rshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((+(((safe_sub_func_int16_t_s_s((0xB889 != (!0U)), 0x0730)) > p_93) <= p_93)), 5)), 8)) >= 4294967286U), (0xF839 < g_260.f3))), 11)) == (*l_94)) == 0x2783))))
                    { /* block id: 184 */
                        (*g_258) = (*l_261);
                        return p_93;
                    }
                    else
                    { /* block id: 187 */
                        struct S0 **l_279 = &l_278;
                        (*l_279) = l_278;
                    }
                }
                (*l_94) = p_93;
            }
            else
            { /* block id: 192 */
                l_280 = (*g_107);
            }
            (*l_278) = func_100(&l_244, &l_94, func_97(g_115, g_115));
        }
        else
        { /* block id: 196 */
            struct S0 l_281 = {16,-873};
            struct S0 *l_282 = &g_115;
            (*l_282) = l_281;
            if (func_97((*l_282), l_283))
            { /* block id: 198 */
                if (l_284)
                { /* block id: 199 */
                    int32_t *l_287 = &l_284;
                    uint32_t l_288 = 0x2F990AEC;
                    (*l_94) = (safe_lshift_func_int16_t_s_u(func_97(g_115, func_100(l_287, &g_108, g_260.f1)), 11));
                    if (l_288)
                    { /* block id: 201 */
                        return p_93;
                    }
                    else
                    { /* block id: 203 */
                        (*g_258) = (*g_258);
                        return g_54;
                    }
                }
                else
                { /* block id: 207 */
                    int32_t ***l_289 = &g_107;
                    (*l_94) |= (l_289 != &g_107);
                    return p_93;
                }
            }
            else
            { /* block id: 211 */
                int32_t **l_292 = &l_94;
                union U1 *l_293 = &g_260;
                for (l_284 = 25; (l_284 != 1); l_284 = safe_sub_func_uint32_t_u_u(l_284, 8))
                { /* block id: 214 */
                    float l_294 = 0x0.99FA3Dp-64;
                    l_281.f1 = ((l_292 != &g_108) < ((void*)0 == l_293));
                }
            }
        }
        return p_93;
    }
    else
    { /* block id: 220 */
        return g_115.f1;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_87 g_127 g_115.f0 g_129 g_147
 * writes: g_87 g_129 g_54 g_127 g_147 g_115
 */
static int16_t  func_97(struct S0  p_98, struct S0  p_99)
{ /* block id: 60 */
    uint16_t l_120 = 0xA764;
    int32_t ***l_134 = &g_127;
    int16_t l_145 = 2;
    int32_t ***l_152 = &g_127;
    int32_t *l_223 = &g_147;
    float l_229 = (-0x9.3p+1);
    int16_t l_232 = 0xA482;
    p_98.f1 = p_98.f0;
    for (g_87 = 8; (g_87 != 24); g_87 = safe_add_func_int32_t_s_s(g_87, 1))
    { /* block id: 64 */
        uint32_t l_122 = 3U;
        int32_t *l_128 = &g_129;
        int16_t l_130 = 0x8DC0;
        float *l_131 = &g_54;
        (*l_128) = (safe_sub_func_uint32_t_u_u(((l_120 & (+l_122)) >= ((safe_lshift_func_uint16_t_u_u(g_87, (0x78D1 & (g_127 == (void*)0)))) && l_120)), l_122));
        (*l_131) = (l_130 >= p_99.f0);
        for (l_130 = 26; (l_130 < (-17)); l_130 = safe_sub_func_int16_t_s_s(l_130, 1))
        { /* block id: 69 */
            return l_120;
        }
    }
    (*l_134) = (void*)0;
    for (l_120 = 2; (l_120 == 17); l_120 = safe_add_func_int32_t_s_s(l_120, 5))
    { /* block id: 76 */
        uint32_t l_153 = 0x767204C5;
        struct S0 l_161 = {19,2862};
        int32_t *l_175 = &g_87;
        uint32_t l_176 = 4294967295U;
        for (g_87 = 0; (g_87 <= 11); g_87 = safe_add_func_uint32_t_u_u(g_87, 1))
        { /* block id: 79 */
            uint32_t l_151 = 7U;
            int32_t *l_160 = &g_147;
            float *l_173 = &g_54;
            float **l_172 = &l_173;
            int32_t ***l_208 = &g_127;
            for (g_129 = 0; (g_129 > (-2)); g_129 = safe_sub_func_uint16_t_u_u(g_129, 1))
            { /* block id: 82 */
                int32_t *l_146 = &g_147;
                (*l_146) ^= (g_115.f0 < (safe_rshift_func_uint16_t_u_s(3U, (safe_div_func_int16_t_s_s(g_129, l_145)))));
            }
        }
        if ((*l_175))
        { /* block id: 149 */
            for (g_129 = 0; (g_129 < 26); g_129 = safe_add_func_uint16_t_u_u(g_129, 1))
            { /* block id: 152 */
                return p_99.f1;
            }
            (*l_175) ^= p_99.f0;
        }
        else
        { /* block id: 156 */
            struct S0 l_230 = {5,4916};
            struct S0 *l_231 = &g_115;
            (*l_231) = l_230;
            l_161 = p_99;
            return g_147;
        }
        if ((*l_223))
            break;
    }
    return l_232;
}


/* ------------------------------------------ */
/* 
 * reads : g_115
 * writes: g_108
 */
static struct S0  func_100(int32_t * p_101, int32_t ** p_102, uint32_t  p_103)
{ /* block id: 57 */
    int32_t *l_114 = (void*)0;
    (*p_102) = l_114;
    return g_115;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_107 g_108 g_87 g_53
 * writes: g_87
 */
static int32_t ** func_104(uint32_t  p_105, int32_t ** p_106)
{ /* block id: 53 */
    int16_t l_109 = 0x9D0E;
    int32_t **l_113 = &g_108;
    (**g_107) &= (g_3 | l_109);
    (**g_107) ^= ((safe_mod_func_uint32_t_u_u((safe_unary_minus_func_int16_t_s(l_109)), g_53)) & 8U);
    return l_113;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_53, "g_53", print_hash_value);
    transparent_crc_bytes (&g_54, sizeof(g_54), "g_54", print_hash_value);
    transparent_crc(g_87, "g_87", print_hash_value);
    transparent_crc(g_115.f0, "g_115.f0", print_hash_value);
    transparent_crc(g_115.f1, "g_115.f1", print_hash_value);
    transparent_crc(g_129, "g_129", print_hash_value);
    transparent_crc(g_147, "g_147", print_hash_value);
    transparent_crc(g_260.f0, "g_260.f0", print_hash_value);
    transparent_crc(g_260.f1, "g_260.f1", print_hash_value);
    transparent_crc(g_260.f2, "g_260.f2", print_hash_value);
    transparent_crc(g_260.f3, "g_260.f3", print_hash_value);
    transparent_crc(g_357.f0, "g_357.f0", print_hash_value);
    transparent_crc(g_357.f1, "g_357.f1", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 92
   depth: 1, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 14
breakdown:
   indirect level: 0, occurrence: 11
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 11
breakdown:
   indirect level: 0, occurrence: 11
XXX times a bitfields struct's address is taken: 7
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 19
XXX times a single bitfield on LHS: 7
XXX times a single bitfield on RHS: 39

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 19
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 86

XXX times a variable address is taken: 87
XXX times a pointer is dereferenced on RHS: 43
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 8
XXX times a pointer is dereferenced on LHS: 70
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 298

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 232
   level: 2, occurrence: 83
   level: 3, occurrence: 24
XXX number of pointers point to pointers: 28
XXX number of pointers point to scalars: 45
XXX number of pointers point to structs: 8
XXX percent of pointers has null in alias set: 23.3
XXX average alias set size: 1.24

XXX times a non-volatile is read: 385
XXX times a non-volatile is write: 189
XXX times a volatile is read: 14
XXX    times read thru a pointer: 1
XXX times a volatile is write: 2
XXX    times written thru a pointer: 2
XXX times a volatile is available for access: 177
XXX percentage of non-volatile access: 97.3

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 16
   depth: 2, occurrence: 17
   depth: 3, occurrence: 9
   depth: 4, occurrence: 9
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 24.2
XXX percentage an existing variable is used: 75.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

