/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --float --math64 --no-inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3923319140
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint16_t  f0;
   int8_t  f1;
   uint32_t  f2;
   uint32_t  f3;
   int16_t  f4;
   uint16_t  f5;
   const int32_t  f6;
   unsigned f7 : 21;
   uint32_t  f8;
};
#pragma pack(pop)

union U1 {
   const float  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int32_t * func_2(uint32_t  p_3, int32_t * p_4, int32_t * p_5, const uint32_t  p_6);
static uint32_t  func_7(uint32_t  p_8, int32_t  p_9, uint8_t  p_10);
static uint32_t  func_13(uint8_t  p_14, int32_t * p_15, uint32_t  p_16);
static int32_t * func_17(int8_t  p_18, uint32_t  p_19, int32_t * p_20);
static uint32_t  func_21(struct S0  p_22, union U1  p_23);
static struct S0  func_24(uint32_t  p_25);
static int32_t * const * func_35(int32_t * p_36, float  p_37);
static float  func_41(int32_t * p_42);
static int32_t * func_46(uint16_t  p_47, int32_t * p_48, int32_t * p_49, int32_t  p_50);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    float l_11 = 0xC.0CC2FDp+79;
    int32_t l_12 = 0x47C9D5FA;
    uint32_t l_34 = 0U;
    union U1 l_564 = {-0x1.6p+1};
    int32_t *l_566 = &l_12;
    int32_t **l_625 = &l_566;
    int32_t l_632 = (-1);
    struct S0 l_636 = {0x661F,-10,0U,0U,-7,1U,0xF4C952C1,122,0xEF39D5B4};
    struct S0 *l_635 = &l_636;
    uint32_t l_637 = 4U;
    uint32_t l_651 = 0x8B4CB267;
    float *l_657 = (void*)0;
    float * const *l_656 = &l_657;
    int8_t l_660 = 0x9D;
    (*l_625) = func_2(func_7(l_12, (func_13(l_12, func_17(l_12, func_21(func_24(((safe_div_func_int8_t_s_s((safe_sub_func_uint32_t_u_u((safe_rshift_func_int8_t_s_u((((void*)0 == &l_12) ^ (safe_sub_func_uint8_t_u_u(l_34, l_34))), (l_12 & (0xFC > 0xA5)))), 0x725FC1C5)), l_34)) <= l_12)), l_564), l_566), (*l_566)) != 1U), (*l_566)), &l_12, &l_12, (*l_566));
    (*l_625) = func_17(((-1) && ((safe_mod_func_int32_t_s_s((**l_625), (**l_625))) != (((*l_566) & ((*l_566) <= (safe_mod_func_int8_t_s_s((safe_add_func_uint32_t_u_u(l_632, ((-3) == (safe_add_func_int32_t_s_s((((0x806CCE8B | (l_635 == &l_636)) < 0) | (*l_566)), l_637))))), (*l_566))))) ^ (**l_625)))), (**l_625), (*l_625));
    for (l_636.f8 = (-26); (l_636.f8 > 35); l_636.f8++)
    { /* block id: 211 */
        int32_t l_646 = (-5);
        int32_t l_652 = (-8);
        int32_t *l_653 = &l_12;
        (*l_566) = (safe_sub_func_float_f_f(((((safe_mul_func_float_f_f(0x1.Ap-1, (safe_div_func_float_f_f(((*l_566) > l_646), l_646)))) < ((safe_mul_func_float_f_f(((((**l_625) > ((*l_566) != (0x1.Fp+1 != (safe_mul_func_float_f_f(l_646, l_646))))) < l_651) != (**l_625)), (**l_625))) != 0x3.Cp+1)) <= 0xB.DA7264p-86) < 0x8.5574AFp-30), (-0x2.4p-1)));
        (*l_625) = func_46(l_652, l_653, (*l_625), (*l_653));
    }
    for (l_636.f1 = 10; (l_636.f1 < (-17)); l_636.f1--)
    { /* block id: 217 */
        float ***l_658 = (void*)0;
        float * const *l_659 = &l_657;
        l_659 = l_656;
    }
    return l_660;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_2(uint32_t  p_3, int32_t * p_4, int32_t * p_5, const uint32_t  p_6)
{ /* block id: 203 */
    uint8_t l_613 = 255U;
    int32_t l_620 = 0xC9739BE8;
    int32_t *l_619 = &l_620;
    int32_t **l_618 = &l_619;
    int32_t ***l_617 = &l_618;
    float l_622 = 0x6.2E4B78p-19;
    float *l_621 = &l_622;
    union U1 ***l_624 = (void*)0;
    union U1 ****l_623 = &l_624;
    (*l_621) = (safe_sub_func_float_f_f((0x3.3BF2DEp+76 >= p_3), ((safe_div_func_float_f_f(((safe_div_func_float_f_f((p_5 != (void*)0), l_613)) <= (p_6 >= (safe_add_func_float_f_f((-(((p_6 < p_6) >= (l_617 == &l_618)) == p_6)), (*l_619))))), 0x6.Ep-1)) == (-0x6.3p-1))));
    (***l_617) = (((void*)0 == l_623) & 0xCF);
    return p_4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_7(uint32_t  p_8, int32_t  p_9, uint8_t  p_10)
{ /* block id: 200 */
    int32_t **l_603 = (void*)0;
    uint16_t l_604 = 1U;
    int32_t l_606 = 0x5AF4C30F;
    int32_t *l_605 = &l_606;
    (*l_605) = (safe_div_func_int32_t_s_s(((void*)0 != l_603), l_604));
    return p_10;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_13(uint8_t  p_14, int32_t * p_15, uint32_t  p_16)
{ /* block id: 176 */
    struct S0 l_574 = {1U,0x1D,0x6600FA4E,4294967287U,0xD518,0U,0xB5EF2E33,918,0U};
    struct S0 *l_573 = &l_574;
    struct S0 **l_572 = &l_573;
    struct S0 ***l_571 = &l_572;
    struct S0 *** const *l_570 = &l_571;
    int32_t l_585 = (-5);
    if ((((void*)0 == l_570) || l_574.f8))
    { /* block id: 177 */
        int32_t *l_575 = (void*)0;
        int32_t **l_576 = &l_575;
        (*l_576) = l_575;
    }
    else
    { /* block id: 179 */
        int32_t l_589 = (-2);
        uint32_t l_592 = 4294967295U;
        int32_t *l_597 = (void*)0;
        if (l_574.f4)
        { /* block id: 180 */
            float l_584 = (-0x1.5p+1);
            float *l_583 = &l_584;
            union U1 l_591 = {0x2.862870p+99};
            union U1 * const l_590 = &l_591;
            int32_t **l_593 = (void*)0;
            int32_t **l_594 = (void*)0;
            const int32_t *l_596 = (void*)0;
            const int32_t **l_595 = &l_596;
            for (l_574.f1 = 0; (l_574.f1 < 13); l_574.f1++)
            { /* block id: 183 */
                int32_t l_582 = (-2);
                int32_t *l_581 = &l_582;
                (*l_581) = (safe_lshift_func_uint16_t_u_u(2U, 14));
            }
            (*l_583) = p_14;
            l_585 = (*p_15);
            (*l_595) = func_46((!3U), func_46((safe_mul_func_uint16_t_u_u(l_589, (l_590 == (void*)0))), p_15, p_15, ((9 & (p_14 && 0xA2)) || p_14)), &l_585, l_592);
        }
        else
        { /* block id: 189 */
            int32_t **l_598 = &l_597;
            (*l_598) = l_597;
            for (l_589 = 0; (l_589 > 7); ++l_589)
            { /* block id: 193 */
                (*l_598) = (*l_598);
                if ((*p_15))
                    break;
            }
        }
    }
    return p_14;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_17(int8_t  p_18, uint32_t  p_19, int32_t * p_20)
{ /* block id: 173 */
    int32_t l_569 = 0xA2F5ED9F;
    int32_t *l_568 = &l_569;
    (*l_568) = (safe_unary_minus_func_int16_t_s(0x63FD));
    return p_20;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_21(struct S0  p_22, union U1  p_23)
{ /* block id: 171 */
    uint32_t l_565 = 3U;
    return l_565;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_24(uint32_t  p_25)
{ /* block id: 1 */
    int32_t *l_38 = (void*)0;
    int32_t **l_391 = &l_38;
    int32_t ***l_390 = &l_391;
    int32_t **l_392 = &l_38;
    struct S0 l_476 = {0x5086,0xCC,0x03AF28B6,0xEAC0E24B,1,65527U,0xE5C9369E,119,4294967288U};
    struct S0 *l_475 = &l_476;
    struct S0 **l_474 = &l_475;
    int16_t l_494 = 1;
    int32_t l_554 = (-1);
    int32_t *l_553 = &l_554;
    union U1 **l_555 = (void*)0;
    int32_t l_562 = 0xB66CA220;
    struct S0 l_563 = {0x057E,0x1B,0x87F41C3D,0x95D6EF24,-1,65532U,-1,1271,4294967295U};
    (*l_390) = func_35(l_38, p_25);
    (*l_392) = l_38;
    for (p_25 = (-20); (p_25 == 51); p_25++)
    { /* block id: 134 */
        int32_t l_395 = 0x0883238A;
        int32_t l_398 = 0;
        union U1 *l_399 = (void*)0;
        struct S0 l_431 = {0xC58C,-1,6U,0x04C654F5,0xE1E3,65535U,0xE9CBC892,736,0x5A51E6BD};
        struct S0 *l_430 = &l_431;
        struct S0 *l_438 = &l_431;
        union U1 **l_464 = &l_399;
        union U1 ***l_463 = &l_464;
        struct S0 ***l_523 = &l_474;
        struct S0 ****l_522 = &l_523;
        int8_t l_551 = 0xC8;
        for (l_395 = 6; (l_395 > 16); l_395 = safe_add_func_uint32_t_u_u(l_395, 5))
        { /* block id: 137 */
            struct S0 l_403 = {0x0762,0xF6,0x505ED468,0x18E075F6,0xB2FD,0xDCD5,0x0C067552,643,4294967293U};
            struct S0 *l_402 = &l_403;
            int32_t l_433 = 0;
            float l_461 = 0x4.FE4CCAp+34;
            float *l_460 = &l_461;
            const struct S0 ** const *l_503 = (void*)0;
            l_398 = p_25;
            if (((((void*)0 == l_399) >= (safe_rshift_func_uint16_t_u_s(((void*)0 != l_402), 1))) == (safe_mod_func_int16_t_s_s(l_403.f0, l_403.f2))))
            { /* block id: 139 */
                struct S0 **l_414 = &l_402;
                struct S0 ***l_413 = &l_414;
                struct S0 ****l_412 = &l_413;
                int32_t l_432 = (-7);
                float l_459 = 0x0.85D5FDp+4;
                float *l_458 = &l_459;
                int8_t l_513 = 0xB8;
                l_433 = (((safe_lshift_func_uint8_t_u_s((safe_lshift_func_int8_t_s_s((((l_399 != l_399) != ((void*)0 != l_412)) < ((safe_div_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s((&l_399 == (void*)0), (safe_mul_func_uint8_t_u_u((!(safe_mul_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u((((safe_sub_func_uint16_t_u_u((8U > (((void*)0 != l_430) | 0xF9B92B15)), (-2))) || l_432) ^ p_25), 0xC892F8CD)) > 0U), l_431.f4))), 0xD4)))), p_25)) != p_25)), p_25)), l_432)) | p_25) | l_432);
                (*l_392) = &l_395;
                for (l_432 = 0; (l_432 < 1); l_432++)
                { /* block id: 144 */
                    int32_t l_462 = 0x1F7B180F;
                    union U1 ****l_465 = &l_463;
                    int32_t **l_481 = &l_38;
                    const struct S0 *l_502 = &l_476;
                    const struct S0 **l_501 = &l_502;
                    const struct S0 ***l_500 = &l_501;
                    for (l_403.f8 = 8; (l_403.f8 < 50); l_403.f8++)
                    { /* block id: 147 */
                        float l_440 = 0xF.FCB349p+48;
                        float *l_439 = &l_440;
                        int32_t *l_441 = &l_433;
                        (*l_439) = (&l_403 != l_438);
                        l_398 = l_403.f7;
                        (*l_441) = (-3);
                        (*l_441) = (safe_mod_func_uint8_t_u_u((safe_div_func_int32_t_s_s(((((8 < (p_25 == l_432)) >= 65533U) <= ((safe_div_func_int8_t_s_s((*l_441), ((-1) || (safe_mod_func_int16_t_s_s((((6 & (safe_mod_func_int16_t_s_s((((safe_lshift_func_int8_t_s_u(((safe_div_func_int32_t_s_s((safe_sub_func_int16_t_s_s(p_25, (l_458 != l_460))), l_462)) == l_431.f2), l_432)) > l_432) & (*l_441)), p_25))) && 0xCD) != 0xE8), p_25))))) < l_403.f6)) != l_462), (**l_392))), 4));
                    }
                    (*l_465) = l_463;
                    for (l_433 = 0; (l_433 >= 25); ++l_433)
                    { /* block id: 156 */
                        uint32_t l_493 = 0x0DDC3163;
                        (*l_392) = &l_398;
                        (**l_481) = (safe_div_func_int8_t_s_s(((safe_mod_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u(((l_474 != &l_402) < (safe_lshift_func_uint16_t_u_s(p_25, ((l_462 ^ (safe_mul_func_int16_t_s_s((((void*)0 == l_481) <= (safe_lshift_func_uint8_t_u_s((safe_mod_func_uint8_t_u_u(l_431.f7, ((+(safe_mul_func_int16_t_s_s(((safe_div_func_int16_t_s_s((safe_div_func_uint8_t_u_u(l_493, ((p_25 | l_432) & (**l_392)))), 1U)) || l_494), 0x6E52))) || (**l_481)))), 6))), 1U))) > l_403.f5)))), l_403.f2)), (**l_481))) < p_25), l_432));
                        (*l_460) = (safe_sub_func_float_f_f((l_431.f5 != (safe_div_func_float_f_f((p_25 <= ((**l_481) <= (p_25 >= ((((-(0x9.DA9C6Ap-67 <= (((l_500 != l_503) >= (safe_mul_func_float_f_f(l_431.f5, 0x4.A58A44p+81))) >= p_25))) > (**l_481)) != p_25) <= l_403.f8)))), p_25))), 0x4.E8E4BBp+34));
                        (*l_38) = ((safe_sub_func_uint16_t_u_u((**l_481), p_25)) & (safe_add_func_int32_t_s_s((+(safe_rshift_func_uint8_t_u_s(l_513, 0))), (safe_sub_func_int8_t_s_s((safe_mul_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(l_431.f4, (safe_div_func_int16_t_s_s(((void*)0 != l_522), (safe_sub_func_uint8_t_u_u(l_431.f6, l_403.f2)))))), (safe_rshift_func_int16_t_s_u(0, 13)))), 0)))));
                    }
                    (*l_392) = &l_432;
                }
            }
            else
            { /* block id: 164 */
                const union U1 l_533 = {-0x1.0p+1};
                const union U1 *l_532 = &l_533;
                const union U1 **l_531 = &l_532;
                const union U1 ***l_530 = &l_531;
                int32_t l_550 = 0xFB66839C;
                int32_t *l_552 = &l_433;
                (*l_552) = (((l_403.f2 <= (p_25 < p_25)) ^ (safe_rshift_func_uint8_t_u_u(((&l_464 == l_530) && ((safe_mul_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u(((safe_mul_func_int16_t_s_s(p_25, (((p_25 != ((safe_div_func_int8_t_s_s((safe_rshift_func_uint16_t_u_s(p_25, 15)), (safe_add_func_uint32_t_u_u((safe_lshift_func_int8_t_s_s(1, p_25)), l_550)))) == l_398)) | l_403.f8) < 0xD6B1))) == l_431.f7), 2)), l_403.f0)) || l_551), (-7))) < p_25)), p_25))) >= p_25);
            }
        }
    }
    (*l_392) = func_46(p_25, l_553, func_46(((p_25 > (((((void*)0 != l_555) | (safe_rshift_func_int16_t_s_s(4, 15))) ^ (safe_lshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(p_25, ((&l_475 != (void*)0) ^ l_562))), p_25))) >= p_25)) || (*l_553)), &l_554, &l_562, p_25), p_25);
    return l_563;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const * func_35(int32_t * p_36, float  p_37)
{ /* block id: 2 */
    int32_t **l_347 = (void*)0;
    uint32_t l_354 = 0x12A27154;
    float l_361 = 0x7.1AC5B1p-21;
    float *l_360 = &l_361;
    union U1 l_372 = {0xA.E88EDFp-39};
    union U1 *l_371 = &l_372;
    union U1 ** const l_370 = &l_371;
    int32_t l_375 = 0xF315CCFE;
    int32_t *l_374 = &l_375;
    int32_t **l_373 = &l_374;
    int32_t * const *l_376 = &l_374;
    int32_t * const *l_377 = &l_374;
    int32_t * const *l_378 = &l_374;
    int32_t * const *l_379 = &l_374;
    int32_t * const *l_380 = &l_374;
    int32_t * const *l_381 = &l_374;
    int32_t * const *l_382 = &l_374;
    int32_t * const *l_383 = &l_374;
    int32_t * const *l_384 = &l_374;
    int32_t * const *l_385 = &l_374;
    int32_t * const *l_386 = &l_374;
    int32_t * const *l_387 = &l_374;
    int32_t * const *l_388 = &l_374;
    int32_t * const *l_389 = (void*)0;
    (*l_360) = ((safe_mul_func_float_f_f(func_41(p_36), 0x7.2p+1)) >= (((&p_36 != l_347) == (safe_sub_func_float_f_f((safe_div_func_float_f_f((safe_sub_func_float_f_f(0x2.50536Dp+28, l_354)), ((((safe_div_func_float_f_f(((safe_add_func_float_f_f((-0x9.0p+1), (+p_37))) < p_37), p_37)) >= p_37) < l_354) > p_37))), 0x0.0p-1))) >= p_37));
    (*l_373) = func_46((&p_36 != (void*)0), l_360, func_46(l_354, func_46((safe_add_func_uint32_t_u_u(((((safe_sub_func_int8_t_s_s((l_354 >= (((safe_add_func_uint32_t_u_u(l_354, ((l_354 & (((safe_div_func_uint32_t_u_u((((l_370 == &l_371) ^ l_354) ^ l_354), l_354)) != 0) >= l_354)) | l_354))) >= l_354) <= l_354)), l_354)) ^ l_354) >= 0U) || l_354), (-8))), p_36, p_36, l_354), p_36, l_354), l_354);
    return l_389;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_41(int32_t * p_42)
{ /* block id: 3 */
    const int32_t *l_44 = (void*)0;
    const int32_t **l_43 = &l_44;
    int32_t l_45 = (-7);
    int32_t l_230 = 0;
    struct S0 *l_343 = (void*)0;
    uint32_t l_346 = 0xE12CC2AE;
    (*l_43) = p_42;
    if (l_45)
    { /* block id: 5 */
        int32_t l_53 = 0x95C1F4AC;
        int32_t *l_59 = &l_45;
        struct S0 l_207 = {65533U,0x55,0x4E04F8DB,0x3C28B900,4,65531U,-1,1281,7U};
        struct S0 *l_206 = &l_207;
        struct S0 **l_208 = (void*)0;
        const struct S0 *l_210 = &l_207;
        const struct S0 **l_209 = &l_210;
        struct S0 ****l_211 = (void*)0;
        const struct S0 ***l_212 = &l_209;
        l_45 = 0x88F15EA3;
        (*l_43) = func_46((safe_sub_func_int32_t_s_s((l_53 < (l_53 <= (safe_sub_func_uint32_t_u_u(0x0DEC5331, ((l_53 > (safe_mul_func_uint8_t_u_u(l_53, l_53))) == ((((((safe_unary_minus_func_int8_t_s(((l_53 || (-1)) > (0xE7 < l_45)))) & l_53) > l_53) | l_45) != 0xA1AE) <= l_53)))))), l_45)), l_59, p_42, (*l_59));
        (*l_209) = l_206;
        l_212 = &l_209;
    }
    else
    { /* block id: 82 */
        int32_t l_233 = 0;
        struct S0 l_340 = {3U,6,4294967288U,0xDAC7CBAB,0,0x33CC,9,495,0x87166874};
        struct S0 *l_339 = &l_340;
        for (l_45 = 0; (l_45 >= (-20)); l_45 = safe_sub_func_uint32_t_u_u(l_45, 6))
        { /* block id: 85 */
            int32_t l_215 = 0x23DE851E;
            int32_t l_219 = 0xF3E036E8;
            struct S0 l_265 = {65531U,0x1A,4294967288U,1U,0,8U,0x74E035A3,38,0U};
            struct S0 *l_264 = &l_265;
            struct S0 **l_263 = &l_264;
            struct S0 ***l_267 = &l_263;
            struct S0 *** const *l_266 = &l_267;
            uint32_t l_311 = 0x401E5B4B;
            for (l_215 = (-8); (l_215 > 6); l_215 = safe_add_func_int32_t_s_s(l_215, 9))
            { /* block id: 88 */
                uint16_t l_218 = 0x2A12;
                int32_t *l_236 = &l_219;
                struct S0 l_250 = {4U,-1,0xE6CD1A5B,1U,0,1U,0,755,1U};
                struct S0 *l_249 = &l_250;
                struct S0 **l_248 = &l_249;
                struct S0 ***l_247 = &l_248;
                struct S0 ****l_246 = &l_247;
                int8_t l_293 = 0x7B;
                float l_295 = 0xE.75B194p+54;
                l_219 = l_218;
                (*l_236) = ((l_215 > (!((((!(safe_add_func_uint8_t_u_u((((safe_div_func_int16_t_s_s(0xD0DB, l_218)) || (safe_mul_func_int16_t_s_s(l_230, (safe_mod_func_uint8_t_u_u(254U, l_230))))) | ((l_233 ^ l_233) == (safe_lshift_func_uint16_t_u_u(65535U, l_233)))), l_233))) || l_218) < l_215) | l_219))) || 1);
            }
        }
        (*l_43) = func_46(l_233, func_46(l_233, p_42, p_42, (safe_lshift_func_uint16_t_u_s(l_233, ((l_339 == &l_340) == (((8 & l_340.f2) & l_340.f0) < l_340.f3))))), &l_45, l_340.f6);
    }
    (*l_43) = func_46((safe_sub_func_uint16_t_u_u((l_343 == l_343), (safe_add_func_uint16_t_u_u(l_230, l_230)))), p_42, p_42, l_230);
    return l_346;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_46(uint16_t  p_47, int32_t * p_48, int32_t * p_49, int32_t  p_50)
{ /* block id: 7 */
    int32_t *l_61 = (void*)0;
    int32_t **l_60 = &l_61;
    const float l_95 = 0xE.E98DF1p+47;
    const float *l_121 = (void*)0;
    (*l_60) = p_48;
    for (p_50 = 0; (p_50 == 28); ++p_50)
    { /* block id: 11 */
        int32_t *l_66 = (void*)0;
        int32_t l_93 = 0x44A2B868;
        int8_t l_114 = 0x66;
        int32_t *l_136 = &l_93;
        struct S0 l_197 = {65534U,0x75,1U,0x68E36131,0xC4F0,0x8F7B,0x3498CC23,1341,0xE7EE4AC1};
        struct S0 *l_196 = &l_197;
        struct S0 *l_201 = (void*)0;
        float l_205 = 0x0.1p+1;
    }
    return p_48;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 132
   depth: 1, occurrence: 1
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 26
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 13
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 20
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 17
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 3

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 27, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 151

XXX times a variable address is taken: 143
XXX times a pointer is dereferenced on RHS: 73
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 22
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 69
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 4
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 304

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 148
   level: 2, occurrence: 63
   level: 3, occurrence: 13
XXX number of pointers point to pointers: 75
XXX number of pointers point to scalars: 52
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 23.2
XXX average alias set size: 1.28

XXX times a non-volatile is read: 615
XXX times a non-volatile is write: 181
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 72
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 12
   depth: 2, occurrence: 9
   depth: 3, occurrence: 9
   depth: 4, occurrence: 4
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 13.5
XXX percentage an existing variable is used: 86.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

