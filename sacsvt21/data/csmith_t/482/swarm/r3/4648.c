/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1208082922
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
   int32_t  f1;
   int32_t  f2;
   uint64_t  f3;
   float  f4;
   uint32_t  f5;
};

struct S1 {
   unsigned f0 : 9;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   uint8_t  f0;
   int64_t  f1;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_25(void);
static uint64_t  func_37(uint32_t  p_38);
static int32_t *** func_40(int32_t ** p_41, float  p_42, int32_t ** p_43);
static int32_t ** func_44(int32_t *** p_45, float  p_46);
static int32_t *** func_47(int32_t  p_48, int32_t ** p_49, int16_t  p_50);
static struct S0  func_54(uint16_t  p_55, struct S1  p_56, float  p_57, uint64_t  p_58);
static int32_t **** func_61(int32_t *** p_62);
static uint32_t  func_78(int32_t * p_79, struct S2 * p_80);
static struct S2 * func_81(uint32_t  p_82, int32_t ** p_83, struct S1  p_84);
static uint32_t  func_85(uint16_t  p_86, uint32_t  p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_25(void)
{ /* block id: 36 */
    int32_t l_26 = 3L;
    int32_t *l_501 = &l_26;
    struct S1 l_530 = {9};
    struct S1 *l_529 = &l_530;
    uint32_t l_532 = 5UL;
    int32_t l_538 = 0x9CC08C7CL;
lbl_535:
    if (__builtin_popcount(l_26))
    { /* block id: 37 */
        int32_t *l_29 = &l_26;
        for (l_26 = 0; (l_26 >= 11); l_26++)
        { /* block id: 40 */
            int32_t **l_30 = (void*)0;
            int32_t **l_31 = &l_29;
            (*l_31) = l_29;
        }
    }
    else
    { /* block id: 43 */
        int64_t l_39 = (-1L);
        uint8_t l_498 = 0xE2L;
        int8_t l_511 = 0xE5L;
        struct S0 l_526 = {246UL,0L,-8L,0xC7A9D4689E1DE858LL,0xC.29333Fp+62,0xA3562F08L};
        struct S0 *l_525 = &l_526;
        if (((l_26 || (__builtin_parityl(l_26) && (!l_26))) | ((safe_lshift_func_int16_t_s_s((safe_lshift_func_int8_t_s_s(l_26, l_26)), (func_37(l_39) | ((__builtin_clzl(l_26) < l_39) || l_498)))) != 1UL)))
        { /* block id: 319 */
            int32_t *l_499 = &l_26;
            int32_t **l_500 = (void*)0;
            int32_t *l_516 = &l_26;
            struct S1 l_518 = {3};
            l_501 = l_499;
            for (l_26 = 0; (l_26 < 24); l_26++)
            { /* block id: 323 */
                int32_t l_504 = (-1L);
                int32_t *l_505 = &l_504;
                int64_t l_515 = 8L;
                (*l_505) = l_504;
                for (l_504 = (-8); (l_504 != (-22)); l_504 = safe_sub_func_int32_t_s_s(l_504, 7))
                { /* block id: 327 */
                    float l_508 = 0x0.431B28p-45;
                    int32_t l_509 = 0x57C66E66L;
                    int16_t l_510 = 0L;
                    if (((l_509 == (l_510 ^ l_511)) != (l_498 ^ (0UL >= (((safe_unary_minus_func_int32_t_s(((safe_sub_func_uint8_t_u_u(((*l_499) ^ (18446744073709551606UL | 0x0FD8510D5B57BD98LL)), l_498)) == (*l_499)))) > 18446744073709551615UL) >= l_515)))))
                    { /* block id: 328 */
                        int32_t **l_517 = &l_499;
                        (*l_517) = l_516;
                    }
                    else
                    { /* block id: 330 */
                        struct S1 l_519 = {14};
                        l_519 = l_518;
                    }
                }
                if ((*l_505))
                    break;
            }
        }
        else
        { /* block id: 336 */
            int32_t l_522 = (-3L);
            struct S1 l_528 = {19};
            struct S1 *l_527 = &l_528;
            for (l_511 = 15; (l_511 == (-30)); l_511 = safe_sub_func_int64_t_s_s(l_511, 1))
            { /* block id: 339 */
                struct S0 l_531 = {0x70L,0x0E3BC6F3L,0xC87FEB0DL,0x3AC6C3F52E7747F3LL,0x0.2E1C9Ep-30,4294967290UL};
                if (l_522)
                { /* block id: 340 */
                    struct S0 l_524 = {247UL,1L,0xE537C568L,0x63CD8DEA53E3237FLL,0xB.1201D7p-21,4294967294UL};
                    struct S0 *l_523 = &l_524;
                    (*l_523) = func_54(((l_498 | func_85((l_523 != l_525), (l_527 != l_529))) >= (l_498 & 0xED1AC72EL)), (*l_527), (*l_501), (*l_501));
                }
                else
                { /* block id: 342 */
                    (*l_525) = l_531;
                    return l_531.f0;
                }
            }
        }
    }
    if ((l_532 <= ((*l_501) <= (*l_501))))
    { /* block id: 349 */
        int32_t *l_533 = &l_26;
        int32_t **l_534 = &l_533;
        (*l_534) = l_533;
    }
    else
    { /* block id: 351 */
        int32_t **l_536 = &l_501;
        uint64_t l_537 = 7UL;
        if (l_26)
            goto lbl_535;
        (*l_536) = &l_26;
        (**l_536) = l_537;
    }
    return l_538;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_37(uint32_t  p_38)
{ /* block id: 44 */
    uint16_t l_51 = 0x213EL;
    int32_t *l_53 = (void*)0;
    int32_t **l_52 = &l_53;
    int32_t ***l_497 = &l_52;
    int32_t ****l_496 = &l_497;
    (*l_496) = func_40(func_44(func_47(l_51, l_52, p_38), l_51), p_38, &l_53);
    /* statement id: 317 */
    //assert (l_53 == dangling || l_53 == 0);
    assert (l_497 == 0);
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_40(int32_t ** p_41, float  p_42, int32_t ** p_43)
{ /* block id: 232 */
    int16_t l_345 = 0x778AL;
    int32_t *l_353 = (void*)0;
    int32_t **l_352 = &l_353;
    int32_t ***l_351 = &l_352;
    int32_t ***l_355 = &l_352;
    struct S1 l_360 = {13};
    struct S1 *l_359 = &l_360;
    struct S2 l_368 = {0x46L,1L};
    struct S2 *l_367 = &l_368;
    int8_t l_372 = 0xE7L;
    struct S2 **l_377 = &l_367;
    struct S2 ***l_376 = &l_377;
    struct S0 l_403 = {1UL,1L,-1L,0x9D97F4BBE4866000LL,0x1.9p+1,0xDA778AEBL};
    struct S0 *l_402 = &l_403;
    int32_t *l_423 = &l_403.f1;
    uint16_t l_428 = 3UL;
    int32_t ***l_444 = &l_352;
    struct S0 **l_449 = (void*)0;
    struct S0 ***l_448 = &l_449;
    int32_t l_457 = 0xF933E1EDL;
    uint8_t l_459 = 0xEBL;
    int32_t *****l_479 = (void*)0;
    int32_t ***l_480 = &l_352;
    int32_t ***l_481 = &l_352;
    int32_t ***l_482 = &l_352;
    int32_t ***l_483 = &l_352;
    int32_t ***l_484 = &l_352;
    int32_t ***l_485 = &l_352;
    int32_t ***l_486 = &l_352;
    int32_t ***l_487 = &l_352;
    int32_t ***l_488 = &l_352;
    int32_t ***l_489 = &l_352;
    int32_t ***l_490 = &l_352;
    int32_t ***l_491 = &l_352;
    int32_t ***l_492 = &l_352;
    int32_t ***l_493 = &l_352;
    int32_t ***l_494 = &l_352;
    int32_t ***l_495 = (void*)0;
    if (((l_345 || l_345) >= l_345))
    { /* block id: 233 */
        int32_t l_349 = (-7L);
        int32_t *l_348 = &l_349;
        int32_t **l_347 = &l_348;
        int32_t ***l_346 = &l_347;
        int32_t ***l_350 = &l_347;
        int32_t ***l_354 = &l_352;
        int32_t ***l_356 = (void*)0;
        return l_356;
        /* statement id: 234 */
        //assert (func_40_rv == 0);
    }
    else
    { /* block id: 235 */
        float l_363 = 0x1.8p+1;
        float *l_362 = &l_363;
        int32_t l_366 = 0x4E6A2DADL;
        struct S2 *l_371 = (void*)0;
        for (l_345 = 0; (l_345 > (-12)); --l_345)
        { /* block id: 238 */
            struct S1 **l_361 = &l_359;
            (*l_361) = l_359;
        }
        if (((void*)0 == l_362))
        { /* block id: 241 */
            l_366 = (safe_rshift_func_uint16_t_u_s(l_366, 6));
        }
        else
        { /* block id: 243 */
            l_372 = (l_366 ^ (!((~__builtin_ffsll(((void*)0 == l_371))) && l_366)));
            (*l_352) = (*p_43);
            (**l_351) = (**l_355);
        }
    }
    if ((safe_rshift_func_uint16_t_u_u((!0xEBL), 8)))
    { /* block id: 249 */
        struct S2 ***l_378 = (void*)0;
        int32_t l_385 = (-4L);
        struct S1 l_408 = {12};
        int32_t ***l_441 = &l_352;
        int16_t l_461 = 0xA41FL;
        l_378 = l_376;
        /* statement id: 250 */
        assert (l_378 == &l_377);
        if ((safe_mod_func_int8_t_s_s((safe_mod_func_uint64_t_u_u((((safe_rshift_func_uint8_t_u_s(l_385, (safe_unary_minus_func_int16_t_s(l_385)))) & (l_385 | (safe_div_func_int16_t_s_s((0x1E1AL >= l_385), 0xA9F9L)))) == 0UL), (safe_sub_func_int8_t_s_s((&l_360 == (void*)0), l_385)))), l_385)))
        { /* block id: 251 */
            int8_t l_393 = 0x98L;
            int32_t l_396 = (-1L);
            (**l_351) = &l_385;
            /* statement id: 252 */
            assert (l_353 == &l_385);
            l_396 = ((l_385 & (((safe_lshift_func_int8_t_s_s(l_393, 3)) & ((safe_lshift_func_int16_t_s_s(1L, 15)) & 0xC2L)) <= __builtin_parity(l_393))) ^ l_385);
        }
        else
        { /* block id: 254 */
            uint64_t l_399 = 0x9C7EA6E0837E1950LL;
            int32_t l_420 = 0x92E8C8DBL;
            struct S1 l_422 = {20};
            struct S2 *l_424 = &l_368;
            uint32_t l_440 = 4294967295UL;
            int32_t ***l_445 = &l_352;
            int32_t ***l_447 = (void*)0;
            struct S1 *l_463 = (void*)0;
            struct S0 l_464 = {246UL,0xDACCB832L,6L,18446744073709551608UL,0x0.414B34p+47,5UL};
            float *l_477 = &l_464.f4;
            if ((safe_lshift_func_uint8_t_u_u(l_399, 7)))
            { /* block id: 255 */
                uint64_t l_405 = 0xAB0AF10B1B94147CLL;
                float *l_409 = &l_403.f4;
                struct S2 *l_421 = (void*)0;
                for (l_399 = 0; (l_399 == 1); l_399 = safe_add_func_uint8_t_u_u(l_399, 5))
                { /* block id: 258 */
                    struct S0 **l_404 = &l_402;
                    int32_t *l_406 = &l_385;
                    struct S1 l_407 = {11};
                    (*l_404) = l_402;
                    l_404 = &l_402;
                    if (l_405)
                    { /* block id: 261 */
                        (**l_355) = (*p_43);
                    }
                    else
                    { /* block id: 263 */
                        (*p_43) = l_406;
                        /* statement id: 264 */
                        //assert (l_53 == &l_385);
                        (*l_359) = l_407;
                        (**l_351) = (*l_352);
                    }
                    (*l_359) = l_408;
                }
                /* facts after for loop */
                //assert (l_53 == &l_385 || l_53 == 0);
                assert (l_353 == &l_385 || l_353 == 0);
                (*l_409) = p_42;
                l_420 = (safe_add_func_uint8_t_u_u(((!(((((65535UL || 8UL) < (!l_405)) ^ (safe_mod_func_int8_t_s_s(l_408.f0, ((safe_lshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u((0xAFFB36650989D3A3LL == (l_405 | (l_405 & l_399))), ((0xCEL != l_385) != l_405))), l_385)) | l_385)))) < l_385) && l_405)) <= 0x250996D2L), l_399));
                (*l_402) = func_54(func_78(l_409, l_421), l_422, l_385, (func_78(l_423, l_424) | (safe_div_func_uint64_t_u_u(l_408.f0, 0x1BAA96994371F4B1LL))));
            }
            else
            { /* block id: 273 */
                int32_t l_427 = 0xBFFBD8F2L;
                int32_t ***l_443 = &l_352;
                int32_t ***l_446 = &l_352;
                int8_t l_458 = 0L;
lbl_462:
                l_428 = __builtin_ffs(l_427);
                (*p_43) = &l_385;
                /* statement id: 275 */
                //assert (l_53 == &l_385);
                for (l_403.f0 = 0; (l_403.f0 < 21); l_403.f0 = safe_add_func_uint32_t_u_u(l_403.f0, 2))
                { /* block id: 278 */
                    float *l_431 = &l_403.f4;
                    uint32_t l_439 = 4294967295UL;
                    int32_t ***l_442 = &l_352;
                    if (l_385)
                        break;
                    (*l_431) = (p_42 <= p_42);
                    if ((**p_43))
                    { /* block id: 281 */
                        int32_t l_438 = 0L;
                        l_440 = ((+__builtin_bswap32((((((safe_div_func_int64_t_s_s(l_408.f0, 1UL)) > ((((!(**p_43)) > (safe_rshift_func_uint8_t_u_s(((0x89L <= l_438) || 0x0E753FC6L), 7))) && (l_438 < l_427)) < (*l_423))) > 2L) >= l_385) || l_399))) > l_439);
                        if (l_440)
                            break;
                    }
                    else
                    { /* block id: 284 */
                        (**l_355) = (*p_43);
                        /* statement id: 285 */
                        assert (l_353 == &l_385);
                    }
                    /* facts after branching */
                    assert (l_353 == &l_385 || l_353 == 0);
                    return l_447;
                    /* statement id: 287 */
                    //assert (l_53 == dangling);
                    //assert (func_40_rv == 0);
                }
                if ((**p_43))
                { /* block id: 289 */
                    int32_t l_450 = 1L;
                    float *l_460 = &l_403.f4;
                    struct S2 l_467 = {251UL,0x2CD79FE6A86D9D58LL};
                    (*l_460) = (((p_42 > (p_42 < __builtin_bswap32((l_385 ^ (((((void*)0 == l_448) | ((*l_423) != l_450)) & (safe_lshift_func_uint8_t_u_u((safe_sub_func_int8_t_s_s(((((65532UL && (safe_sub_func_int32_t_s_s((**p_43), (**p_43)))) >= (**p_43)) < (*l_423)) & l_457), l_458)), (*l_423)))) ^ l_459))))) != 0xE.3F82FAp-17) != (-0x2.7p-1));
                    if (__builtin_ctzl(l_461))
                    { /* block id: 291 */
                        if (l_457)
                            goto lbl_462;
                    }
                    else
                    { /* block id: 293 */
                        l_463 = &l_408;
                        /* statement id: 294 */
                        assert (l_463 == &l_408);
                        l_464 = (*l_402);
                    }
                    /* facts after branching */
                    assert (l_463 == &l_408 || l_463 == 0);
                    for (l_428 = 0; (l_428 < 47); l_428++)
                    { /* block id: 299 */
                        struct S2 l_468 = {4UL,8L};
                        p_42 = func_78((*p_43), (**l_378));
                        l_468 = l_467;
                    }
                }
                else
                { /* block id: 303 */
                    struct S1 **l_470 = &l_463;
                    struct S1 ***l_469 = &l_470;
                    (*l_469) = &l_463;
                }
                /* facts after branching */
                assert (l_463 == &l_408 || l_463 == 0);
            }
            /* facts after branching */
            //assert (l_53 == &l_385 || l_53 == 0);
            assert (l_353 == &l_385 || l_353 == 0);
            assert (l_463 == &l_408 || l_463 == 0);
            (*l_477) = ((safe_add_func_float_f_f((p_42 >= (safe_div_func_float_f_f(((0x8.74E724p-54 > (safe_div_func_float_f_f(((*l_423) < p_42), 0x5.Ap+1))) <= p_42), func_85(l_461, (*l_423))))), l_385)) <= p_42);
            return l_447;
            /* statement id: 308 */
            //assert (l_53 == dangling || l_53 == 0);
            //assert (func_40_rv == 0);
        }
        /* facts after branching */
        assert (l_353 == &l_385);
        (**l_441) = (**l_355);
    }
    else
    { /* block id: 311 */
        int32_t *l_478 = &l_403.f1;
        (**l_355) = (*p_43);
        (*p_43) = l_478;
        /* statement id: 313 */
        //assert (l_53 == &l_403.f1);
    }
    /* facts after branching */
    //assert (l_53 == &l_403.f1 || l_53 == 0);
    //assert (l_353 == 0 || l_353 == dangling);
    (*l_423) = (l_479 != l_479);
    return l_495;
    /* statement id: 316 */
    //assert (l_53 == dangling || l_53 == 0);
    //assert (func_40_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_44(int32_t *** p_45, float  p_46)
{ /* block id: 125 */
    int32_t l_208 = (-7L);
    int32_t *l_207 = &l_208;
    int32_t **l_209 = &l_207;
    int32_t l_283 = (-3L);
    struct S2 *l_318 = (void*)0;
    struct S0 l_339 = {0xA5L,0x59D30CC3L,-1L,9UL,-0x1.6p+1,0x47B2E25AL};
    struct S0 *l_338 = &l_339;
    struct S0 **l_337 = &l_338;
    struct S0 ***l_336 = &l_337;
    struct S1 l_342 = {12};
    struct S1 *l_341 = &l_342;
    int32_t **l_344 = (void*)0;
    (*l_209) = l_207;
    for (l_208 = 0; (l_208 == 25); l_208 = safe_add_func_int16_t_s_s(l_208, 9))
    { /* block id: 129 */
        int32_t l_212 = 0x4AC5FBAFL;
        struct S2 l_226 = {0UL,0xC93B026917EE8902LL};
        struct S2 *l_225 = &l_226;
        struct S2 **l_224 = &l_225;
        struct S2 ***l_223 = &l_224;
        float l_233 = 0x0.0p+1;
        float *l_232 = &l_233;
        struct S1 l_234 = {1};
        int32_t **l_275 = (void*)0;
        int32_t **l_293 = &l_207;
    }
    return l_344;
    /* statement id: 231 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_47(int32_t  p_48, int32_t ** p_49, int16_t  p_50)
{ /* block id: 45 */
    struct S1 l_59 = {9};
    struct S0 l_199 = {0x1FL,0L,0L,0UL,-0x5.9p+1,0x40E0213BL};
    int32_t *l_202 = &l_199.f1;
    int32_t **l_201 = &l_202;
    int32_t ***l_200 = &l_201;
    int32_t ***l_203 = &l_201;
    int32_t ***l_204 = &l_201;
    int32_t ***l_205 = &l_201;
    int32_t ***l_206 = (void*)0;
    l_199 = func_54(p_48, l_59, (-l_59.f0), l_59.f0);
    return l_206;
    /* statement id: 124 */
    //assert (func_47_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_54(uint16_t  p_55, struct S1  p_56, float  p_57, uint64_t  p_58)
{ /* block id: 46 */
    int32_t l_66 = (-1L);
    int32_t *l_65 = &l_66;
    int32_t **l_64 = &l_65;
    int32_t ***l_63 = &l_64;
    int32_t ****l_197 = &l_63;
    int32_t *****l_196 = &l_197;
    struct S0 l_198 = {255UL,0x510376A8L,0xD7796E21L,0x60E50EEE4F3F7408LL,0x7.01113Cp+7,0UL};
    (*l_196) = func_61(l_63);
    /* statement id: 121 */
    //assert (l_65 == 0 || l_65 == &l_66 || l_65 == dangling);
    assert (l_197 == 0);
    return l_198;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t **** func_61(int32_t *** p_62)
{ /* block id: 47 */
    int32_t l_67 = (-6L);
    struct S2 l_72 = {0x2DL,-8L};
    struct S2 *l_71 = &l_72;
    struct S2 **l_70 = &l_71;
    struct S1 l_156 = {2};
    int32_t *l_185 = &l_67;
    int32_t **l_188 = &l_185;
    int32_t ***l_187 = &l_188;
    int32_t ****l_186 = &l_187;
    int32_t ****l_189 = &l_187;
    int32_t ****l_190 = &l_187;
    int32_t ****l_191 = &l_187;
    int32_t ****l_192 = &l_187;
    int32_t ****l_193 = &l_187;
    int32_t ****l_194 = &l_187;
    int32_t ****l_195 = (void*)0;
    for (l_67 = (-16); (l_67 >= 5); l_67 = safe_add_func_uint64_t_u_u(l_67, 6))
    { /* block id: 50 */
        (**p_62) = (void*)0;
        /* statement id: 51 */
        //assert (l_65 == 0);
    }
    /* facts after for loop */
    //assert (l_65 == 0 || l_65 == &l_66);
    (*l_70) = (void*)0;
    /* statement id: 53 */
    assert (l_71 == 0);
    (*l_185) = (safe_add_func_uint8_t_u_u(((!(l_72.f0 | (safe_rshift_func_int16_t_s_s((__builtin_parityll(l_72.f1) == l_67), 7)))) && (func_78(&l_67, func_81(func_85(l_72.f0, ((safe_sub_func_int8_t_s_s((safe_div_func_uint64_t_u_u((0x674DCCE65120B879LL | (+(0x369EL == l_67))), l_72.f1)), l_72.f0)) || 0x3F1863D476FC58ACLL)), (*p_62), l_156)) & l_72.f0)), l_72.f1));
    /* statement id: 119 */
    //assert (l_65 == 0 || l_65 == &l_66 || l_65 == dangling);
    return l_195;
    /* statement id: 120 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_78(int32_t * p_79, struct S2 * p_80)
{ /* block id: 102 */
    int64_t l_163 = 0xC4DE7E0673044D68LL;
    struct S1 l_184 = {21};
    if ((l_163 || l_163))
    { /* block id: 103 */
        int32_t l_166 = (-10L);
        int32_t *l_165 = &l_166;
        int32_t **l_164 = &l_165;
        (*l_164) = p_79;
        /* statement id: 104 */
        //assert (l_165 == &l_67 || l_165 == &l_212 || l_165 == &l_403.f4 || l_165 == &l_403.f1 || l_165 == &l_385);
    }
    else
    { /* block id: 105 */
        int32_t l_171 = 0x60E86605L;
        int32_t *l_175 = &l_171;
        int32_t **l_174 = &l_175;
        int32_t ***l_173 = &l_174;
        int32_t ****l_172 = &l_173;
        struct S0 l_178 = {0x3DL,0xEF88E352L,0x4D3C6A4CL,0xF9B13E4380B9C827LL,-0x6.5p+1,2UL};
        struct S1 l_182 = {6};
        struct S1 *l_183 = &l_182;
        (*p_79) = __builtin_clzl((((safe_add_func_int32_t_s_s((*p_79), 0L)) ^ 9L) && (l_171 < l_163)));
        if (((void*)0 != l_172))
        { /* block id: 107 */
            float l_176 = 0x5.500A6Bp+24;
            int32_t l_177 = 0x0828E8F0L;
            return l_177;
        }
        else
        { /* block id: 109 */
            struct S0 *l_179 = (void*)0;
            struct S0 *l_180 = &l_178;
            int32_t l_181 = 0x8BE070EAL;
            (*l_180) = l_178;
            (*p_79) = 0xAC61AB63L;
            l_181 = (*l_175);
            (***l_173) = 1L;
        }
        (*l_183) = l_182;
        (*l_183) = l_184;
    }
    return l_184.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_65
 */
static struct S2 * func_81(uint32_t  p_82, int32_t ** p_83, struct S1  p_84)
{ /* block id: 99 */
    int32_t l_158 = 0x4A66755DL;
    int32_t *l_157 = &l_158;
    struct S2 l_160 = {2UL,0xA2850EDC4196DCF8LL};
    struct S2 *l_159 = &l_160;
    struct S2 *l_161 = &l_160;
    struct S2 *l_162 = (void*)0;
    (*p_83) = l_157;
    /* statement id: 100 */
    //assert (l_65 == &l_158);
    return l_162;
    /* statement id: 101 */
    //assert (l_65 == dangling);
    //assert (func_81_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_85(uint16_t  p_86, uint32_t  p_87)
{ /* block id: 54 */
    int32_t l_94 = (-1L);
    int32_t *l_93 = &l_94;
    int32_t **l_95 = &l_93;
    struct S0 l_96 = {255UL,-9L,0xCCF76E5FL,18446744073709551615UL,-0x1.2p+1,4294967286UL};
    struct S0 *l_97 = (void*)0;
    struct S2 l_107 = {0x29L,1L};
    struct S2 *l_106 = &l_107;
    struct S2 **l_105 = &l_106;
    int32_t ***l_118 = &l_95;
    int32_t ****l_117 = &l_118;
    int32_t *****l_116 = &l_117;
    int32_t *l_145 = &l_94;
    (*l_95) = l_93;
    l_96 = l_96;
lbl_109:
    for (p_86 = 0; (p_86 <= 35); ++p_86)
    { /* block id: 59 */
        int32_t *l_103 = &l_96.f2;
        struct S0 *l_104 = (void*)0;
        for (l_94 = 23; (l_94 < 7); --l_94)
        { /* block id: 62 */
            int32_t *l_102 = &l_94;
            struct S2 ***l_108 = &l_105;
            l_103 = l_102;
            /* statement id: 63 */
            assert (l_103 == &l_94);
            l_104 = &l_96;
            /* statement id: 64 */
            assert (l_104 == &l_96);
            (*l_108) = l_105;
        }
        /* facts after for loop */
        assert (l_103 == &l_94 || l_103 == &l_96.f2);
        assert (l_104 == &l_96 || l_104 == 0);
        (*l_95) = (void*)0;
        /* statement id: 67 */
        assert (l_93 == 0);
        if (l_96.f1)
            goto lbl_109;
    }
    if ((&l_105 != (void*)0))
    { /* block id: 70 */
        int32_t ***l_115 = &l_95;
        int32_t ****l_114 = &l_115;
        int32_t *****l_113 = &l_114;
        struct S2 **l_119 = &l_106;
        struct S2 ***l_120 = &l_119;
        for (l_96.f5 = 2; (l_96.f5 <= 13); l_96.f5 = safe_add_func_uint8_t_u_u(l_96.f5, 2))
        { /* block id: 73 */
            int32_t *l_112 = &l_96.f1;
            (*l_95) = l_112;
            /* statement id: 74 */
            assert (l_93 == &l_96.f1);
            if ((*l_112))
                break;
            (*l_95) = (*l_95);
            l_116 = l_113;
            /* statement id: 77 */
            assert (l_116 == &l_114);
        }
        /* facts after for loop */
        assert (l_93 == &l_96.f1 || l_93 == 0 || l_93 == &l_94);
        assert (l_116 == &l_114 || l_116 == &l_117);
        (**l_115) = (***l_117);
        (*l_120) = l_119;
    }
    else
    { /* block id: 81 */
        int32_t *l_134 = &l_94;
        struct S2 **l_142 = &l_106;
        for (l_96.f2 = 0; (l_96.f2 == (-24)); l_96.f2 = safe_sub_func_uint64_t_u_u(l_96.f2, 8))
        { /* block id: 84 */
            float *l_124 = &l_96.f4;
            int32_t l_129 = 0L;
            struct S2 **l_141 = &l_106;
            (*l_124) = (+(-0x3.Bp-1));
            if (p_87)
                break;
            (*l_124) = (safe_sub_func_float_f_f((safe_div_func_float_f_f((0x0.6p+1 == (l_129 < ((safe_add_func_float_f_f(((safe_div_func_float_f_f((l_134 == l_134), ((safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_div_func_float_f_f(0x9.Fp+1, (l_141 == l_142))), l_129)), p_86)) >= p_87))) < 0x0.0p+1), (-0x4.9p+1))) == 0xF.C290A7p-80))), p_87)), l_129));
        }
        for (l_107.f0 = 4; (l_107.f0 != 35); ++l_107.f0)
        { /* block id: 91 */
            l_134 = l_145;
            (*l_145) = (((safe_div_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u(((-4L) || __builtin_popcountl((*l_134))), 0x6DA3L)), ((*l_134) & p_86))) & ((safe_lshift_func_uint16_t_u_s(3UL, 12)) < ((*l_134) <= 0x06303C50L))) | (*l_134));
            (*l_134) = ((-2L) < (safe_add_func_uint32_t_u_u(p_86, (safe_lshift_func_uint8_t_u_s(((*l_142) != (void*)0), 6)))));
        }
        return p_87;
    }
    /* facts after branching */
    assert (l_93 == &l_96.f1 || l_93 == 0 || l_93 == &l_94);
    //assert (l_116 == dangling || l_116 == &l_117);
    return p_87;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 167
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 5
XXX full-bitfields structs in the program: 10
breakdown:
   indirect level: 0, occurrence: 10
XXX times a bitfields struct's address is taken: 9
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 7

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 159
   depth: 2, occurrence: 28
   depth: 3, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 9, occurrence: 2
   depth: 11, occurrence: 4
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1

XXX total number of pointers: 191

XXX times a variable address is taken: 178
XXX times a pointer is dereferenced on RHS: 73
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 23
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 84
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 310

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 189
   level: 2, occurrence: 59
   level: 3, occurrence: 45
   level: 4, occurrence: 4
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 119
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 35
XXX percent of pointers has null in alias set: 20.9
XXX average alias set size: 1.16

XXX times a non-volatile is read: 513
XXX times a non-volatile is write: 232
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 132
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 29
   depth: 2, occurrence: 32
   depth: 3, occurrence: 12
   depth: 4, occurrence: 16
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 14
XXX percentage an existing variable is used: 86
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

