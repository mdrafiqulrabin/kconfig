/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --no-bitfields --no-comma-operators --compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1677366310
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   float  f4;
   int32_t  f5;
   volatile int32_t  f6;
   const float  f7;
   uint32_t  f8;
   volatile uint32_t  f9;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3[2] = {4294967292U,4294967292U};
static int32_t g_64 = 9;
static int32_t *g_63 = &g_64;
static uint32_t g_113[9][1] = {{1U},{0x2777EF5E},{1U},{0x2777EF5E},{1U},{0x2777EF5E},{1U},{0x2777EF5E},{1U}};
static int32_t g_114 = 0x360B9F0A;
static int32_t g_119 = 0xF4091208;
static float g_128 = 0xA.AA3977p+28;
static int32_t **g_152 = &g_63;
static int32_t ***g_151 = &g_152;
static struct S0 g_180[4] = {{0x11E84FFD,-4,0xE8B5CC30,0xB9D00B73,0xE.7B0691p+23,0x18053210,0xD450DD38,0xF.C0AFCBp-30,4294967295U,4294967295U},{0x11E84FFD,-4,0xE8B5CC30,0xB9D00B73,0xE.7B0691p+23,0x18053210,0xD450DD38,0xF.C0AFCBp-30,4294967295U,4294967295U},{0x11E84FFD,-4,0xE8B5CC30,0xB9D00B73,0xE.7B0691p+23,0x18053210,0xD450DD38,0xF.C0AFCBp-30,4294967295U,4294967295U},{0x11E84FFD,-4,0xE8B5CC30,0xB9D00B73,0xE.7B0691p+23,0x18053210,0xD450DD38,0xF.C0AFCBp-30,4294967295U,4294967295U}};
static struct S0 g_198[4] = {{0x384123AD,1,-2,0x242C42AF,0x1.7290ABp-41,0xCEEE4773,0xB299F902,0x8.11CDFFp+35,0xE327E5A2,4294967289U},{0x384123AD,1,-2,0x242C42AF,0x1.7290ABp-41,0xCEEE4773,0xB299F902,0x8.11CDFFp+35,0xE327E5A2,4294967289U},{0x384123AD,1,-2,0x242C42AF,0x1.7290ABp-41,0xCEEE4773,0xB299F902,0x8.11CDFFp+35,0xE327E5A2,4294967289U},{0x384123AD,1,-2,0x242C42AF,0x1.7290ABp-41,0xCEEE4773,0xB299F902,0x8.11CDFFp+35,0xE327E5A2,4294967289U}};
static struct S0 *g_197 = &g_198[3];
static int32_t g_345 = (-3);
static float **g_353[2] = {(void*)0,(void*)0};
static struct S0 **g_363 = &g_197;
static volatile int32_t *g_466 = (void*)0;
static volatile int32_t **g_465[3][9] = {{&g_466,&g_466,(void*)0,&g_466,&g_466,&g_466,&g_466,(void*)0,&g_466},{&g_466,(void*)0,&g_466,&g_466,(void*)0,&g_466,(void*)0,&g_466,&g_466},{&g_466,&g_466,&g_466,(void*)0,&g_466,&g_466,&g_466,(void*)0,(void*)0}};
static volatile int32_t ***g_464 = &g_465[2][6];
static volatile int32_t ****g_463 = &g_464;
static volatile int32_t *****g_462 = &g_463;
static struct S0 ****g_517 = (void*)0;
static int32_t *g_573 = &g_180[2].f5;
static struct S0 ***g_582 = &g_363;
static volatile uint32_t g_602 = 4294967288U;/* VOLATILE GLOBAL g_602 */
static struct S0 g_655 = {0x67F2FA86,-2,5,1,0xA.02A590p+34,-1,0xCA2F52FC,0xE.B5959Dp+23,4294967295U,0U};/* VOLATILE GLOBAL g_655 */
static uint16_t g_726 = 0xA0F5;
static uint32_t g_727 = 0xAD555067;
static uint32_t g_738 = 0xFC2234E1;
static float ***g_814 = &g_353[0];
static float ****g_813 = &g_814;
static float *****g_812 = &g_813;
static int32_t g_893 = (-3);
static volatile struct S0 g_921 = {-1,0x2BDB1CF0,0x48FB0769,0x20ED0B2D,0x4.3p+1,-8,0x1A511D12,0x2.3p+1,0x4175263E,0xD5FB12E8};/* VOLATILE GLOBAL g_921 */
static volatile struct S0 *g_920 = &g_921;


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_25(void);
inline static int32_t  func_32(float  p_33);
static int32_t  func_34(uint32_t  p_35, uint32_t  p_36);
inline static uint32_t  func_38(int32_t  p_39, uint32_t  p_40, uint32_t  p_41, uint16_t  p_42, int32_t  p_43);
static int16_t  func_46(int32_t  p_47, int32_t  p_48, uint8_t  p_49);
inline static int32_t * func_55(float  p_56, int32_t * p_57, int32_t * p_58);
static int32_t * func_59(int32_t * p_60, int32_t  p_61, uint16_t  p_62);
static uint32_t  func_70(uint32_t  p_71, uint32_t  p_72, int32_t * p_73, uint8_t  p_74);
inline static uint32_t  func_88(int32_t * p_89, int32_t * p_90, int32_t  p_91, float  p_92);
static int32_t * func_93(int32_t  p_94, int32_t * p_95, uint8_t  p_96);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_921.f6
 * writes:
 */
inline static uint16_t  func_25(void)
{ /* block id: 36 */
    uint8_t l_663 = 251U;
    int32_t l_670 = 0x4A84B937;
    int32_t *l_673 = &g_198[3].f1;
    struct S0 ***l_674 = &g_363;
    int32_t l_680 = 0x6C39AF66;
    int32_t *l_690 = &g_198[3].f1;
    int32_t * const *l_697[1];
    int32_t * const **l_696 = &l_697[0];
    int16_t l_702 = 0x9313;
    float l_728 = (-0x6.2p+1);
    struct S0 * const ***l_753 = (void*)0;
    uint32_t l_754 = 3U;
    int32_t l_757[7][7][5] = {{{0xF518558C,0,0x125B6493,0x4BAB1F60,(-3)},{0x26FCEE36,0x2B239BDD,9,0x194FE9F5,0x4B0F55EF},{0x85D7161B,0,0xDBA0B729,0,0xA2154D8C},{0x3295AA5A,0x26FCEE36,0x1E5AC13F,1,3},{0xA2154D8C,1,0x4BAB1F60,0xEB983675,0xE87C7AA2},{0xA2154D8C,(-3),0x080BBCE3,8,0x2488C096},{0x3295AA5A,7,0x39F4CF23,0xE87C7AA2,(-10)}},{{0x85D7161B,9,0x216DEE5E,(-10),0x4BAB1F60},{0x26FCEE36,(-1),0,0xB21F814F,0},{0xF518558C,0xA2154D8C,1,(-1),0xEB983675},{3,1,1,3,0x4B0F55EF},{0xB21F814F,0x7DF2E604,0,(-3),0xC78E9BBF},{(-10),6,0xD34D7BBE,1,0x194FE9F5},{(-10),0x2B239BDD,0xD3B13567,(-3),(-1)}},{{0xEB983675,(-10),0x080BBCE3,3,0x85D7161B},{1,0,0xE87C7AA2,(-1),0},{(-10),9,0xF518558C,0xB21F814F,(-1)},{8,0xB21F814F,0xDBA0B729,(-10),0x26FCEE36},{0xF518558C,1,0,0xE87C7AA2,(-10)},{0,1,0xFB30F281,8,0x4B0F55EF},{7,3,0x40ED3121,0xEB983675,1}},{{1,3,0x3295AA5A,1,6},{0xA142FEAB,1,0x4B0F55EF,0,0x4BAB1F60},{0xC78E9BBF,1,0x080BBCE3,0x194FE9F5,7},{(-10),0xB21F814F,0x8F07F60A,0x4BAB1F60,1},{0x2488C096,9,(-10),(-8),0xE87C7AA2},{(-4),0,0x40ED3121,0,(-4)},{0xF518558C,(-10),(-3),0x4BAB1F60,(-1)}},{{0x194FE9F5,0x2B239BDD,0xEC773311,0x7DF2E604,0x4B0F55EF},{(-8),6,0xDBA0B729,(-10),(-1)},{0x3295AA5A,0x7DF2E604,(-1),1,(-4)},{(-1),1,(-1),0xA142FEAB,0xE87C7AA2},{(-3),0xA2154D8C,0x080BBCE3,6,1},{0x3295AA5A,(-1),7,0xE87C7AA2,7},{0,9,1,(-1),0x4BAB1F60}},{{0x7DF2E604,7,0,1,6},{0xF518558C,(-3),0x2B239BDD,(-1),1},{1,1,0x2B239BDD,1,0xEEAFCBC6},{0x8F07F60A,0,0xC78E9BBF,0x216DEE5E,0x3295AA5A},{(-1),1,0xAAF5AAF8,(-1),0},{(-10),0xD0CEAF31,0xA299FFD0,1,0x08D9CB99},{(-1),(-10),1,0xFB30F281,0xD3B13567}},{{0x6E033816,7,0x08D9CB99,0x08D9CB99,7},{(-1),0xDBA0B729,0xCBB6F1E6,1,0x08D9CB99},{1,1,(-10),0x4BAB1F60,0xEC773311},{4,0x1E5AC13F,0,0xA16A3CD7,1},{1,0xEE715616,0x080BBCE3,1,0xEEAFCBC6},{(-1),(-3),0,(-1),0xF518558C},{0x6E033816,0xFB30F281,(-1),(-1),1}}};
    int32_t * const l_758 = &g_655.f1;
    int32_t *l_759[3][6] = {{(void*)0,&l_670,(void*)0,(void*)0,(void*)0,&l_670},{&g_180[2].f5,&l_670,&g_655.f5,&g_180[2].f5,(void*)0,(void*)0},{&g_345,&l_670,&l_670,&g_345,(void*)0,&g_655.f5}};
    uint16_t l_760 = 1U;
    float l_761 = 0x7.0334CDp+64;
    int32_t l_858 = 4;
    float l_859 = 0xD.6893C1p-64;
    float *l_897 = &g_128;
    float **l_896 = &l_897;
    float *****l_898 = &g_813;
    const uint32_t l_901 = 1U;
    float l_922 = 0x7.E639F3p+61;
    int i, j, k;
    for (i = 0; i < 1; i = i + 1)
        l_697[i] = (void*)0;
    return g_921.f6;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_63 g_64 g_114 g_119 g_113 g_151 g_152 g_180.f9 g_198.f1 g_180.f2 g_180.f6 g_198.f5 g_180.f8 g_180.f3 g_180.f1 g_198.f2 g_198.f8 g_198.f3 g_198.f9 g_180.f0 g_198.f0 g_345 g_180.f5 g_198.f6 g_462 g_517 g_353 g_655.f5
 * writes: g_64 g_113 g_114 g_119 g_128 g_63 g_197 g_198.f1 g_198.f5 g_198.f4 g_180.f1 g_151 g_363 g_345 g_180.f5 g_462 g_573 g_582 g_655.f3 g_655.f5
 */
inline static int32_t  func_32(float  p_33)
{ /* block id: 37 */
    int32_t l_37 = 0xDCEFBDE2;
    int32_t *l_658 = &g_655.f5;
    (*l_658) |= (((func_34(l_37, (func_38(((int32_t)((func_46(l_37, ((int16_t)((uint16_t)l_37 << (uint16_t)7) >> (int16_t)0), g_3[1]) < ((0x0714BA09 == (l_37 < func_46(l_37, ((g_3[1] < 5) <= l_37), l_37))) == l_37)) > l_37) - (int32_t)1U), l_37, l_37, l_37, l_37) == l_37)) != 1U) && l_37) >= l_37);
    /* statement id: 502 */
    //assert (g_63 == dangling || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64);
    assert ((g_197 >= &g_198[0] && g_197 <= &g_198[3]) || (g_197 >= &g_180[0] && g_197 <= &g_180[3]) || g_197 == 0);
    //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
    //assert (g_573 == dangling || (g_573 >= &g_180[0].f5 && g_573 <= &g_180[3].f5));
    return (*l_658);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_180.f6 g_113 g_180.f8 g_180.f1 g_198.f9 g_198.f1 g_151 g_152 g_180.f5 g_198.f8 g_64 g_345 g_119 g_198.f6 g_462 g_63 g_517 g_180.f0 g_198.f5 g_114 g_180.f2 g_180.f9 g_180.f3 g_198.f2 g_353 g_198.f3
 * writes: g_119 g_113 g_128 g_198.f1 g_63 g_345 g_180.f5 g_64 g_197 g_462 g_198.f4 g_114 g_573 g_582 g_363 g_655.f3
 */
static int32_t  func_34(uint32_t  p_35, uint32_t  p_36)
{ /* block id: 312 */
    uint32_t l_408 = 4294967295U;
    struct S0 *l_413 = &g_180[2];
    int32_t l_414 = 0xEA3E9856;
    struct S0 *** const l_425 = &g_363;
    float *l_483 = &g_198[3].f4;
    float **l_482 = &l_483;
    int16_t l_561 = 0x15A0;
    int32_t ** const **l_570 = (void*)0;
    uint16_t l_651 = 0x63A8;
lbl_628:
    l_414 &= (((int32_t)((((uint16_t)((uint16_t)p_36 >> (uint16_t)(__builtin_parityll(p_35) && p_36)) >> (uint16_t)(!(l_408 & ((int16_t)((int16_t)(p_35 | (0x00E8C5E8 != (((void*)0 == l_413) <= l_408))) + (int16_t)l_408) >> (int16_t)g_180[2].f6)))) >= g_113[5][0]) < 1U) % (int32_t)g_180[2].f8) >= p_36);
    for (p_35 = 0; (p_35 <= 0); p_35 += 1)
    { /* block id: 316 */
        float *l_418 = &g_128;
        struct S0 *l_419 = &g_198[0];
        int32_t l_432[9][8] = {{0xFCCEE249,0,0,0xFCCEE249,9,0x462BFA85,0x6881AFF9,0},{1,0xFCCEE249,0xC4158C52,0x6881AFF9,0xC4158C52,0xFCCEE249,1,0x2C9AD875},{0xC4158C52,0xFCCEE249,1,0x2C9AD875,0x462BFA85,0x462BFA85,0x2C9AD875,1},{0,0,0xFCCEE249,9,0x462BFA85,0x6881AFF9,0,0x6881AFF9},{0xC4158C52,1,9,1,0xC4158C52,0xC1427660,0,0x6881AFF9},{1,0x462BFA85,0,9,9,0,0x462BFA85,1},{0xFCCEE249,0xC1427660,0,0x2C9AD875,0,0xC4158C52,0,0x2C9AD875},{9,0x9D6E7DEB,9,0x6881AFF9,0x2C9AD875,0xC4158C52,0,0},{0,0xC1427660,0xFCCEE249,0xFCCEE249,0xC1427660,0,0x2C9AD875,0}};
        uint32_t l_530[5][8] = {{0x84396E8C,4294967286U,0xB9751C51,0x305CCDD8,0x8F30104F,0x757F54ED,4294967295U,0x757F54ED},{0x4A8FF0D8,4294967286U,0x84EF6FB8,4294967286U,0x4A8FF0D8,0xB9751C51,0x6DC3B8AC,4294967287U},{0xB9751C51,0x8F30104F,0x4A8FF0D8,4294967289U,4U,4294967286U,4294967286U,4294967286U},{4294967295U,4294967292U,0x4A8FF0D8,0x4A8FF0D8,4294967292U,4294967295U,0x6DC3B8AC,4U},{4U,0x757F54ED,0x84EF6FB8,4294967287U,4294967286U,4294967289U,4294967295U,0xB9751C51}};
        int32_t l_558 = 1;
        uint32_t l_604[10][4] = {{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U},{4294967288U,1U,4294967288U,1U}};
        float l_620 = 0x1.Cp-1;
        uint16_t l_621 = 1U;
        struct S0 ** const *l_625[4];
        struct S0 ** const **l_624 = &l_625[2];
        int i, j;
        for (i = 0; i < 4; i = i + 1)
            l_625[i] = &g_363;
        for (g_119 = 0; g_119 < 9; g_119 += 1)
        {
            for (l_408 = 0; l_408 < 1; l_408 += 1)
            {
                g_113[g_119][l_408] = 0x029AE6BF;
            }
        }
        (*l_418) = (__builtin_ffsll(g_180[2].f1) == ((-(float)func_46(g_198[3].f9, (l_408 >= (&g_353[(p_35 + 1)] == &g_353[(p_35 + 1)])), g_3[1])) < ((float)p_36 - (float)0x1.211868p+8)));
        for (g_119 = 0; (g_119 <= 1); g_119 += 1)
        { /* block id: 321 */
            int32_t *l_420[2][5][1];
            struct S0 * const *l_431 = &g_197;
            struct S0 * const **l_430 = &l_431;
            int32_t l_485 = (-5);
            int i, j, k;
            for (i = 0; i < 2; i = i + 1)
            {
                for (j = 0; j < 5; j = j + 1)
                {
                    for (k = 0; k < 1; k = k + 1)
                        l_420[i][j][k] = &g_64;
                }
            }
            g_198[3].f1 |= (l_419 == &g_180[2]);
            if ((!((int16_t)g_180[2].f1 << (int16_t)p_36)))
            { /* block id: 323 */
                int32_t *l_435[9];
                int32_t * const *l_451 = (void*)0;
                int32_t * const **l_450 = &l_451;
                int i;
                for (i = 0; i < 9; i = i + 1)
                    l_435[i] = &g_198[3].f1;
                if (p_35)
                { /* block id: 324 */
                    uint32_t l_436 = 0xB6BDC150;
                    int32_t *l_437 = &g_180[2].f5;
                    for (l_414 = 0; (l_414 >= 0); l_414 -= 1)
                    { /* block id: 327 */
                        (**g_151) = (void*)0;
                        /* statement id: 328 */
                        assert (g_63 == 0);
                    }
                    for (g_345 = 0; (g_345 <= 0); g_345 += 1)
                    { /* block id: 332 */
                        l_414 &= p_36;
                    }
                    (*l_437) = ((((uint16_t)l_432[6][7] << (uint16_t)g_198[3].f9) && g_3[0]) < p_36);
                    g_64 &= ((int32_t)__builtin_popcountl((p_36 > (__builtin_ctzll(((uint16_t)(*l_437) << (uint16_t)(0x3D3BFA65 & ((uint16_t)g_113[5][0] - (uint16_t)g_198[3].f8)))) ^ g_198[3].f9))) + (int32_t)(*l_437));
                }
                else
                { /* block id: 337 */
                    uint32_t l_452 = 7U;
                    (*l_418) = ((-0x5.7p-1) < p_36);
                    for (p_36 = 0; (p_36 <= 0); p_36 += 1)
                    { /* block id: 341 */
                        struct S0 *l_453 = &g_180[3];
                        struct S0 **l_454 = &g_197;
                        int i, j, k;
                        l_452 |= ((uint32_t)(p_36 == ((__builtin_clz(g_345) ^ ((uint32_t)g_198[3].f1 - (uint32_t)((int16_t)((0U > p_35) >= 0) % (int16_t)(-1)))) > (&g_152 == l_450))) % (uint32_t)l_432[7][0]);
                        (*l_454) = l_453;
                        /* statement id: 343 */
                        assert ((g_197 >= &g_180[0] && g_197 <= &g_180[3]));
                        if (p_35)
                            continue;
                        (*l_418) = (!func_46(g_180[2].f5, p_35, g_180[2].f5));
                    }
                }
                l_414 ^= (p_35 != ((p_35 ^ 4294967295U) != ((int16_t)(((uint32_t)p_35 + (uint32_t)((&l_419 == &g_197) || g_119)) > (-(int32_t)(&g_353[(p_35 + 1)] != &g_353[(p_35 + 1)]))) - (int16_t)g_64)));
            }
            else
            { /* block id: 349 */
                int32_t l_461 = (-10);
                struct S0 *l_467 = &g_180[1];
                float * const *l_470[10][7][3] = {{{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418},{(void*)0,&l_418,&l_418},{&l_418,(void*)0,&l_418},{(void*)0,&l_418,&l_418},{&l_418,&l_418,(void*)0}},{{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,(void*)0},{&l_418,&l_418,&l_418}},{{(void*)0,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418}},{{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418}},{{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,(void*)0},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418}},{{&l_418,&l_418,&l_418},{&l_418,&l_418,(void*)0},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418}},{{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,(void*)0},{&l_418,&l_418,(void*)0},{&l_418,&l_418,(void*)0},{(void*)0,&l_418,(void*)0},{&l_418,&l_418,(void*)0}},{{&l_418,&l_418,(void*)0},{&l_418,&l_418,(void*)0},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,(void*)0},{&l_418,&l_418,(void*)0}},{{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,(void*)0}},{{&l_418,(void*)0,(void*)0},{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{(void*)0,(void*)0,&l_418},{&l_418,&l_418,&l_418},{&l_418,(void*)0,&l_418},{(void*)0,(void*)0,&l_418}}};
                float * const **l_469 = &l_470[9][6][1];
                int i, j, k;
                if ((g_198[3].f6 == l_461))
                { /* block id: 350 */
                    uint16_t l_473 = 0x10BE;
                    if (p_35)
                    { /* block id: 351 */
                        (*l_430) = (*l_430);
                        g_462 = g_462;
                        (*l_418) = l_408;
                        return l_414;
                        /* statement id: 355 */
                        //assert (g_63 == dangling || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
                        //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
                    }
                    else
                    { /* block id: 356 */
                        struct S0 **l_468[4][7][7] = {{{&l_419,&l_413,(void*)0,&l_413,&g_197,&l_413,&l_413},{&g_197,&g_197,&l_467,(void*)0,&l_413,&g_197,&l_413},{(void*)0,&g_197,&g_197,(void*)0,&l_413,&l_413,&l_419},{&l_413,&l_467,&g_197,&l_413,&g_197,&l_413,&l_419},{&l_413,&g_197,&l_413,&g_197,&l_467,&l_413,&l_419},{&l_413,&l_413,(void*)0,&g_197,&g_197,(void*)0,&l_413},{&g_197,&l_413,(void*)0,&l_467,&g_197,&g_197,&l_413}},{{&l_413,&g_197,&l_413,(void*)0,&l_413,&l_419,&g_197},{&l_419,&l_467,&l_419,&l_467,&g_197,&l_419,&l_419},{&l_467,&g_197,&l_419,&g_197,&l_467,&l_419,&l_413},{&l_467,&g_197,(void*)0,&g_197,&l_419,&l_419,&g_197},{&g_197,&l_413,&g_197,&l_413,(void*)0,&g_197,&l_467},{&l_467,&g_197,&g_197,(void*)0,&l_467,(void*)0,&g_197},{&l_467,&l_467,&g_197,(void*)0,&l_413,&l_413,&l_419}},{{&l_419,&l_419,&g_197,&l_413,&l_467,&l_413,&g_197},{&l_413,(void*)0,(void*)0,&l_419,&l_413,&l_413,(void*)0},{&g_197,&l_467,&l_419,&l_419,&l_467,&g_197,(void*)0},{&l_413,&l_413,&l_419,(void*)0,(void*)0,&l_413,&g_197},{&l_413,&l_467,&l_413,&g_197,&l_419,&l_419,&l_419},{&l_413,&l_413,(void*)0,&l_419,&g_197,&g_197,&l_419},{&g_197,&l_467,&g_197,&l_419,&l_413,&l_413,&l_467}},{{&l_419,&l_419,&g_197,&l_413,&l_413,&l_419,&l_413},{(void*)0,&l_413,&l_413,&g_197,&l_413,&l_413,&l_467},{&g_197,&g_197,(void*)0,&l_467,(void*)0,&g_197,&g_197},{&g_197,&l_413,&l_413,&l_413,&g_197,&l_413,(void*)0},{(void*)0,&l_413,&g_197,&l_467,&l_419,&l_419,&l_413},{&l_419,&l_413,&l_413,(void*)0,&l_419,&l_419,&l_419},{&g_197,(void*)0,(void*)0,&g_197,&l_419,&l_467,&l_413}}};
                        int i, j, k;
                        if (l_408)
                            break;
                        (**g_151) = &l_414;
                        /* statement id: 358 */
                        assert (g_63 == &l_414);
                        l_419 = l_467;
                        /* statement id: 359 */
                        assert ((l_419 >= &g_180[0] && l_419 <= &g_180[3]));
                    }
                    /* facts after branching */
                    assert (g_63 == &l_414);
                    assert ((l_419 >= &g_180[0] && l_419 <= &g_180[3]));
                    (**g_152) = (*g_63);
                    if (((void*)0 == l_469))
                    { /* block id: 362 */
                        uint8_t l_481 = 254U;
                        (**l_482) = ((p_36 > (p_36 != l_432[6][7])) > (((float)(l_473 > 0xA.5BC2F7p+32) - (float)(-(float)((float)(((float)__builtin_clzl(((uint16_t)0xD971 + (uint16_t)((l_481 >= 0) != (l_482 == (void*)0)))) + (float)0xA.BC9B87p-82) == 0x4.3p+1) - (float)p_36))) == l_432[6][7]));
                        l_432[6][7] = p_35;
                    }
                    else
                    { /* block id: 365 */
                        struct S0 **l_484[2][3];
                        int i, j;
                        for (i = 0; i < 2; i = i + 1)
                        {
                            for (j = 0; j < 3; j = j + 1)
                                l_484[i][j] = &g_197;
                        }
                        g_197 = &g_180[2];
                        /* statement id: 366 */
                        assert ((g_197 >= &g_180[0] && g_197 <= &g_180[3]));
                    }
                }
                else
                { /* block id: 368 */
                    int16_t l_486 = (-3);
                    int32_t l_489 = 0xD9A7CB5F;
                    uint8_t l_503 = 0x99;
                    if ((l_485 || p_35))
                    { /* block id: 369 */
                        float **l_490[2][3];
                        int i, j;
                        for (i = 0; i < 2; i = i + 1)
                        {
                            for (j = 0; j < 3; j = j + 1)
                                l_490[i][j] = &l_483;
                        }
                        l_486 = (0xCB42 || g_345);
                        l_489 = (((p_36 > p_35) != ((float)p_36 - (float)(p_35 < 0xF.401061p-50))) > func_46(g_113[5][0], (((p_35 != ((void*)0 == &l_414)) < g_180[2].f8) & 0x88BCEA79), g_3[1]));
                        l_432[3][3] &= ((void*)0 == l_490[0][2]);
                    }
                    else
                    { /* block id: 373 */
                        (*l_483) = l_432[6][7];
                    }
                    for (l_486 = 1; (l_486 >= 0); l_486 -= 1)
                    { /* block id: 378 */
                        return l_408;
                        /* statement id: 379 */
                        //assert (g_63 == dangling || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
                        //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
                    }
                    if (((g_3[1] > l_486) <= 8U))
                    { /* block id: 381 */
                        int32_t *l_497 = (void*)0;
                        int i;
                        (*g_152) = l_497;
                        /* statement id: 382 */
                        assert (g_63 == 0);
                        if (p_36)
                            continue;
                        (**l_482) = (-0x4.Cp+1);
                    }
                    else
                    { /* block id: 385 */
                        return p_36;
                        /* statement id: 386 */
                        //assert (g_63 == dangling || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
                        //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
                    }
                    /* facts after branching */
                    assert (g_63 == 0);
                    if ((p_36 >= ((((int16_t)(l_461 | (-(int32_t)((int16_t)((void*)0 == &g_363) % (int16_t)0xF959))) - (int16_t)l_461) == l_503) != ((g_198[3].f6 >= (((p_36 >= p_35) == g_113[6][0]) >= l_408)) <= 0))))
                    { /* block id: 388 */
                        struct S0 ***l_505 = &g_363;
                        struct S0 ****l_504[8][10] = {{(void*)0,&l_505,(void*)0,&l_505,&l_505,(void*)0,&l_505,&l_505,&l_505,&l_505},{(void*)0,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,(void*)0},{&l_505,&l_505,(void*)0,&l_505,&l_505,&l_505,&l_505,&l_505,(void*)0,&l_505},{&l_505,(void*)0,&l_505,&l_505,&l_505,(void*)0,&l_505,&l_505,&l_505,(void*)0},{&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,(void*)0,&l_505,&l_505},{&l_505,(void*)0,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,(void*)0},{&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505}};
                        struct S0 ****l_506[1];
                        struct S0 ****l_507 = (void*)0;
                        struct S0 ****l_508[1][9] = {{&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505}};
                        struct S0 ****l_509[5];
                        struct S0 ****l_510 = &l_505;
                        int i, j;
                        for (i = 0; i < 1; i = i + 1)
                            l_506[i] = &l_505;
                        for (i = 0; i < 5; i = i + 1)
                            l_509[i] = &l_505;
                        if (l_432[6][3])
                            break;
                        (*l_510) = l_425;
                        l_461 |= ((p_36 == 65528U) != (~g_345));
                    }
                    else
                    { /* block id: 392 */
                        (**l_482) = (0x1.7p-1 > 0xA.4B58C6p-31);
                        if (p_36)
                            break;
                        return p_36;
                        /* statement id: 395 */
                        //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
                    }
                }
                /* facts after branching */
                assert (g_63 == 0 || g_63 == &l_414);
                l_420[1][4][0] = (void*)0;
                /* statement id: 398 */
                //assert (l_420[0][0][0] == 0 || l_420[0][0][0] == &g_64);
                l_461 = 8;
            }
            /* facts after branching */
            //assert (l_420[0][0][0] == 0 || l_420[0][0][0] == &g_64);
            if (p_35)
            { /* block id: 401 */
                const uint32_t l_516 = 0xCBE9C67E;
                float l_557[10] = {0x2.AE7E16p+0,0x2.AE7E16p+0,0x2.AE7E16p+0,0x2.AE7E16p+0,0x2.AE7E16p+0,0x2.AE7E16p+0,0x2.AE7E16p+0,0x2.AE7E16p+0,0x2.AE7E16p+0,0x2.AE7E16p+0};
                int32_t l_587 = (-1);
                int32_t ***l_603 = (void*)0;
                int i;
                if ((__builtin_ffsll(((uint16_t)((int16_t)0x88D5 + (int16_t)((l_516 & (&l_425 == g_517)) >= g_113[5][0])) >> (uint16_t)p_35)) <= 0xA752FC2C))
                { /* block id: 402 */
                    for (p_36 = 0; (p_36 <= 0); p_36 += 1)
                    { /* block id: 405 */
                        float l_518 = (-0x1.Dp+1);
                        int32_t l_519 = 0x06F166AD;
                        l_519 = p_36;
                        return l_519;
                        /* statement id: 407 */
                        //assert (g_63 == dangling || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
                        //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
                    }
                }
                else
                { /* block id: 409 */
                    uint32_t l_520 = 1U;
                    int32_t l_521 = 1;
                    l_521 = l_520;
                }
                if ((((uint16_t)(0x90E3 < __builtin_popcount(p_35)) - (uint16_t)l_516) & (~(p_35 || ((~((((int16_t)(p_36 == g_198[3].f8) >> (int16_t)0) <= ((((uint16_t)g_180[2].f0 >> (uint16_t)2) && p_35) | p_36)) >= l_530[3][6])) && 0xD461)))))
                { /* block id: 412 */
                    struct S0 **l_538 = &g_197;
                    for (g_114 = 0; (g_114 <= 0); g_114 += 1)
                    { /* block id: 415 */
                        uint32_t l_531 = 0xF752ACC5;
                        l_432[0][7] &= __builtin_popcountl((p_35 || p_36));
                        l_531 = p_36;
                        return l_516;
                        /* statement id: 418 */
                        //assert (g_63 == dangling || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
                        //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
                    }
                    l_414 = ((int16_t)p_35 + (int16_t)(p_36 & (((int16_t)(((int16_t)((void*)0 != l_538) + (int16_t)p_35) ^ (g_198[3].f5 > 0x33D2)) >> (int16_t)13) == 4294967294U)));
                }
                else
                { /* block id: 421 */
                    int32_t *l_539 = &g_114;
                    int32_t l_559 = 0x08394E19;
                    (*g_152) = l_539;
                    /* statement id: 422 */
                    assert (g_63 == &g_114);
                    if ((((3 != ((((uint32_t)func_88(l_539, (**g_151), ((((1U > ((!1) != ((p_35 & ((p_35 ^ ((((((func_88(func_55((((((float)(*l_539) + (float)((void*)0 != (*l_482))) > p_36) < l_516) > l_516), &l_432[6][7], (**g_151)), &l_414, g_198[3].f9, p_35) <= l_408) == l_432[7][0]) == g_180[2].f0) == g_180[2].f2) == 0) < g_180[2].f8)) == 65535U)) ^ 4294967289U))) | l_530[2][5]) ^ (-9)) | 0U), p_36) - (uint32_t)p_36) & l_530[3][6]) > 65535U)) || g_180[2].f6) || 0xE9C3EB5C))
                    { /* block id: 423 */
                        uint16_t l_560[9][3][2] = {{{65535U,0x296D},{65535U,6U},{6U,0x296D}},{{6U,6U},{65535U,0x296D},{65535U,6U}},{{6U,0x296D},{6U,6U},{65535U,0x296D}},{{65535U,6U},{6U,0x296D},{6U,6U}},{{65535U,0x296D},{65535U,6U},{6U,0x296D}},{{6U,6U},{65535U,0x296D},{65535U,6U}},{{6U,0x296D},{6U,6U},{65535U,0x296D}},{{65535U,6U},{6U,0x296D},{6U,6U}},{{65535U,0x296D},{65535U,6U},{6U,0x296D}}};
                        int i, j, k;
                        l_559 ^= ((0xA8B2 || g_345) || ((((uint16_t)((((g_119 < ((int16_t)(((uint32_t)((uint32_t)((uint32_t)((&g_463 == (void*)0) | ((g_180[2].f9 == p_36) >= (((uint16_t)(g_198[3].f8 >= (((((((0xB0CC & g_113[6][0]) == p_36) ^ 4294967286U) == 4294967295U) || p_35) > 0xBE89) >= 0x014DC0FC)) + (uint16_t)g_3[1]) != 5))) - (uint32_t)p_35) - (uint32_t)(***g_151)) % (uint32_t)g_180[2].f0) & 0U) + (int16_t)l_558)) >= g_64) > 0xE18FE0CA) || p_36) << (uint16_t)g_180[2].f2) == (*g_63)) < 1U));
                        l_560[0][0][0] = 0x0.Ep-1;
                        return l_561;
                        /* statement id: 426 */
                        //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
                    }
                    else
                    { /* block id: 427 */
                        float *l_571 = &g_128;
                        int32_t l_572 = 0x04CA549E;
                        l_572 |= (((int16_t)(((int32_t)((((((((int16_t)0x8D0E % (int16_t)g_113[5][0]) != ((((uint16_t)65535U - (uint16_t)(((**g_152) | g_198[3].f1) >= p_36)) <= ((void*)0 != l_570)) != ((((void*)0 == l_571) || g_3[1]) ^ g_198[3].f1))) & g_180[2].f2) < g_3[0]) ^ g_198[3].f8) == 9U) != (*l_539)) + (int32_t)p_36) == 0xB230) - (int16_t)0U) >= g_345);
                        if (l_572)
                            continue;
                        (***g_151) ^= p_35;
                        g_573 = &l_559;
                        /* statement id: 431 */
                        assert (g_573 == &l_559);
                    }
                    /* facts after branching */
                    assert (g_573 == &l_559);
                    (*g_63) |= ((int16_t)func_46(g_180[2].f3, g_198[3].f2, l_558) << (int16_t)g_198[3].f5);
                }
                if (p_35)
                { /* block id: 435 */
                    float *l_578 = &g_128;
                    struct S0 ***l_581 = &g_363;
                    int32_t l_584 = 0;
                    l_558 ^= 0xF71C7BBE;
                    l_432[6][7] |= ((((uint16_t)g_119 - (uint16_t)((p_35 | p_35) != ((l_578 != l_578) <= __builtin_ctz(((int16_t)(-1) >> (int16_t)8))))) | g_180[2].f6) == g_198[3].f2);
                    g_582 = l_581;
                    if (((p_36 && g_180[2].f5) >= ((void*)0 == g_353[0])))
                    { /* block id: 439 */
                        int32_t **l_583 = &g_63;
                        l_587 |= (g_180[2].f0 <= 0);
                        (*l_418) = ((void*)0 != l_583);
                        (**l_482) = (!l_516);
                    }
                    else
                    { /* block id: 443 */
                        struct S0 *l_590[9];
                        int32_t l_591[7] = {0,0xF054BA17,0xF054BA17,0,0xF054BA17,0xF054BA17,0};
                        int i;
                        for (i = 0; i < 9; i = i + 1)
                            l_590[i] = &g_180[2];
                        l_591[1] = ((l_584 > p_36) && g_198[3].f9);
                        if (l_584)
                            continue;
                        if (p_36)
                            break;
                        l_432[6][7] ^= p_35;
                    }
                }
                else
                { /* block id: 449 */
                    uint32_t l_596 = 0x97F4FB09;
                    uint32_t l_597 = 0x9B388B90;
                    struct S0 **l_605 = &l_413;
                    (*l_483) = ((p_36 != p_36) <= ((((float)((float)p_35 - (float)func_46(g_180[2].f3, g_113[0][0], func_46(((((void*)0 == l_418) || (func_46(p_36, l_596, l_558) & g_180[2].f9)) <= l_596), p_35, l_530[3][6]))) + (float)l_516) >= l_516) != 0x3.2E6565p+62));
                    l_604[8][1] |= (l_587 == g_119);
                    for (l_408 = 0; l_408 < 10; l_408 += 1)
                    {
                        l_557[l_408] = (-0x1.Ep+1);
                    }
                    for (l_597 = 0; (l_597 <= 0); l_597 += 1)
                    { /* block id: 455 */
                        float l_606 = (-0x10.Bp+1);
                        int32_t l_607 = 0x2053A33F;
                        (*l_425) = l_605;
                        /* statement id: 456 */
                        assert (g_363 == &l_413);
                        (*l_418) = (p_35 != (p_36 >= l_607));
                    }
                }
            }
            else
            { /* block id: 460 */
                l_558 = (0x72B43B19 && 0xB64287E6);
                if (l_432[5][7])
                    break;
            }
            l_432[0][7] = (((uint16_t)0x98C2 - (uint16_t)((int16_t)((uint16_t)((((void*)0 == &l_419) ^ (p_35 && ((((int16_t)((int16_t)((int32_t)0xDEDAF433 % (int32_t)g_114) % (int16_t)g_180[2].f1) + (int16_t)0xFB49) & l_604[6][2]) && l_561))) | g_345) % (uint16_t)0x097E) << (int16_t)p_35)) < g_180[2].f0);
        }
        /* facts after for loop */
        assert ((l_419 >= &g_198[0] && l_419 <= &g_198[3]) || (l_419 >= &g_180[0] && l_419 <= &g_180[3]));
        for (g_64 = 0; (g_64 >= 0); g_64 -= 1)
        { /* block id: 468 */
            struct S0 * const l_650 = &g_198[3];
            int32_t l_653 = 0x33F2E6C3;
            struct S0 *l_654 = &g_655;
            for (l_408 = 0; (l_408 <= 0); l_408 += 1)
            { /* block id: 471 */
                int32_t *l_652 = &l_414;
                int i, j;
                if (((g_113[(p_35 + 5)][g_64] & (p_35 & g_113[(p_35 + 5)][g_64])) != func_46(p_35, g_198[3].f6, l_621)))
                { /* block id: 472 */
                    (*l_483) = (0x4.238B15p-36 > (0x7.7p-1 >= p_35));
                }
                else
                { /* block id: 474 */
                    uint32_t l_633[1][2];
                    int i, j;
                    for (i = 0; i < 1; i = i + 1)
                    {
                        for (j = 0; j < 2; j = j + 1)
                            l_633[i][j] = 4294967289U;
                    }
                    for (p_36 = 0; (p_36 <= 2); p_36 += 1)
                    { /* block id: 477 */
                        const struct S0 ***l_627 = (void*)0;
                        const struct S0 ****l_626 = &l_627;
                        l_414 = (((uint32_t)g_113[(p_35 + 5)][g_64] + (uint32_t)(__builtin_clzl((l_624 == l_626)) != 4294967295U)) ^ 0x0A34);
                        if (l_621)
                            goto lbl_628;
                        //assert (g_63 == &l_414 || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || g_63 == dangling || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
                        l_432[6][7] ^= ((int16_t)(((int16_t)l_558 + (int16_t)p_35) || (-3)) << (int16_t)l_633[0][1]);
                    }
                    if (__builtin_bswap32(((g_113[(p_35 + 5)][g_64] & ((1U | ((int16_t)((uint16_t)((-(int16_t)(((func_46(((int16_t)((int16_t)(((~(((uint32_t)(g_198[3].f3 | g_198[3].f2) % (uint32_t)((uint16_t)(-(uint32_t)(__builtin_bswap64((g_113[(p_35 + 5)][g_64] != (-(int16_t)g_198[3].f5))) != func_46(((void*)0 == l_650), l_558, p_35))) >> (uint16_t)7)) || 6)) && g_113[5][0]) & 0U) << (int16_t)g_180[2].f8) >> (int16_t)5), g_198[3].f3, g_198[3].f8) >= p_36) < 0xB99EA2AA) && 0xE175)) == l_633[0][1]) - (uint16_t)0xFF11) << (int16_t)10)) != g_113[(p_35 + 5)][g_64])) && l_651)))
                    { /* block id: 482 */
                        (*g_152) = l_652;
                        /* statement id: 483 */
                        assert (g_63 == &l_414);
                        if (p_36)
                            continue;
                        if (l_653)
                            break;
                    }
                    else
                    { /* block id: 486 */
                        (**g_151) = &l_653;
                        /* statement id: 487 */
                        assert (g_63 == &l_653);
                    }
                    /* facts after branching */
                    assert (g_63 == &l_653 || g_63 == &l_414);
                    l_654 = (void*)0;
                    /* statement id: 489 */
                    assert (l_654 == 0);
                }
                if (l_621)
                    break;
                l_652 = &l_558;
                /* statement id: 492 */
                assert (l_652 == &l_558);
            }
            /* facts after for loop */
            //assert (g_63 == &l_653 || g_63 == &l_414 || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || g_63 == dangling || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
            assert (l_654 == 0 || l_654 == &g_655);
            for (g_655.f3 = 0; (g_655.f3 <= 12); g_655.f3 += 1)
            { /* block id: 496 */
                return l_653;
                /* statement id: 497 */
                //assert (g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || g_63 == dangling || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
                //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
            }
        }
    }
    return p_35;
    /* statement id: 501 */
    //assert (g_63 == dangling || g_63 == &g_114 || g_63 == 0 || g_63 == &g_64 || (g_63 >= &g_198[0].f1 && g_63 <= &g_198[3].f1));
    //assert (g_363 == dangling || g_363 == 0 || g_363 == &g_197);
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_3 g_64 g_114 g_119 g_113 g_151 g_152 g_180.f9 g_198.f1 g_180.f2 g_180.f6 g_198.f5 g_180.f8 g_180.f3 g_180.f1 g_198.f2 g_198.f8 g_198.f3 g_198.f9 g_180.f0 g_198.f0 g_345 g_180.f5
 * writes: g_64 g_113 g_114 g_119 g_128 g_63 g_197 g_198.f1 g_198.f5 g_198.f4 g_180.f1 g_151 g_363 g_345 g_180.f5
 */
inline static uint32_t  func_38(int32_t  p_39, uint32_t  p_40, uint32_t  p_41, uint16_t  p_42, int32_t  p_43)
{ /* block id: 40 */
    int16_t l_54[2];
    int32_t ***l_216 = (void*)0;
    int32_t l_251 = 0xE9A3B20B;
    struct S0 ** const l_295 = (void*)0;
    int32_t l_336 = 5;
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_54[i] = (-1);
    for (p_42 = 0; (p_42 <= 1); p_42 += 1)
    { /* block id: 43 */
        float l_69 = 0x5.Cp-1;
        int32_t *l_199 = (void*)0;
        (**g_151) = func_55(l_54[0], func_59(g_63, g_3[0], ((((uint16_t)p_42 >> (uint16_t)12) >= (((uint16_t)0x7E8F + (uint16_t)__builtin_bswap64(p_43)) != ((0x7EE8 ^ (0x2038 == p_40)) < l_54[0]))) == l_54[1])), l_199);
        /* statement id: 176 */
        assert ((g_197 >= &g_180[0] && g_197 <= &g_180[3]));
        if ((l_54[1] <= __builtin_clzl((l_216 != (void*)0))))
        { /* block id: 177 */
            int32_t *l_217 = &g_64;
            int32_t *l_220[7];
            int32_t l_222 = 0;
            int i;
            for (i = 0; i < 7; i = i + 1)
                l_220[i] = &g_198[3].f5;
            g_198[3].f5 ^= (((p_41 != (func_88(l_217, (**g_151), p_41, g_180[2].f6) < p_40)) || (g_180[2].f2 || __builtin_popcountl(((uint32_t)p_42 + (uint32_t)p_41)))) > p_40);
            for (p_40 = 0; (p_40 <= 1); p_40 += 1)
            { /* block id: 181 */
                (*g_63) |= (!g_180[2].f8);
            }
            (**g_152) ^= l_222;
        }
        else
        { /* block id: 185 */
            float *l_223 = &l_69;
            (*l_223) = p_41;
        }
    }
    /* facts after for loop */
    assert ((g_197 >= &g_180[0] && g_197 <= &g_180[3]) || (g_197 >= &g_198[0] && g_197 <= &g_198[3]));
    if (p_41)
    { /* block id: 189 */
        int32_t * const *l_224 = (void*)0;
        (**g_152) |= (l_224 != (void*)0);
        (***g_151) = p_39;
    }
    else
    { /* block id: 192 */
        int32_t l_229[10] = {(-5),0x095ABA82,(-5),0x095ABA82,(-5),0x095ABA82,(-5),0x095ABA82,(-5),0x095ABA82};
        int32_t l_233 = 0x4EDC10B8;
        int32_t l_249 = 6;
        int32_t **l_264 = (void*)0;
        uint32_t l_268 = 0x4CE6463C;
        int32_t l_313 = (-7);
        int16_t l_321 = 8;
        int32_t l_322[2];
        int32_t *l_323 = &l_233;
        float *l_351 = &g_198[3].f4;
        float **l_350 = &l_351;
        struct S0 **l_369 = &g_197;
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_322[i] = (-9);
        if ((**g_152))
        { /* block id: 193 */
            int16_t l_231 = 0x906A;
            int32_t *l_232[9][5] = {{&g_119,&g_119,(void*)0,(void*)0,(void*)0},{&g_119,&g_119,(void*)0,(void*)0,(void*)0},{&g_119,&g_119,(void*)0,(void*)0,(void*)0},{&g_119,&g_119,(void*)0,(void*)0,(void*)0},{&g_119,&g_119,(void*)0,(void*)0,(void*)0},{&g_119,&g_119,(void*)0,(void*)0,(void*)0},{&g_119,&g_119,(void*)0,(void*)0,(void*)0},{&g_119,&g_119,(void*)0,(void*)0,(void*)0},{&g_119,&g_119,(void*)0,(void*)0,(void*)0}};
            int i, j;
            for (g_64 = (-24); (g_64 >= (-19)); g_64 += 1)
            { /* block id: 196 */
                float *l_227 = (void*)0;
                float *l_228 = &g_198[3].f4;
                int32_t *l_230 = &g_180[2].f1;
                (*l_228) = (-0x5.5p+1);
                (**g_151) = l_227;
                /* statement id: 198 */
                assert (g_63 == 0);
                (*l_230) &= __builtin_parity(((g_180[2].f3 != (l_229[0] >= p_42)) != l_229[8]));
            }
            /* facts after for loop */
            assert (g_63 == 0 || g_63 == &g_64);
            g_180[2].f1 = l_231;
        }
        else
        { /* block id: 202 */
            int32_t l_250 = 0x6AFEBF34;
            int32_t * const *l_267[10][2] = {{&g_63,&g_63},{&g_63,&g_63},{&g_63,&g_63},{&g_63,&g_63},{&g_63,&g_63},{&g_63,&g_63},{&g_63,&g_63},{&g_63,&g_63},{&g_63,&g_63},{&g_63,&g_63}};
            int32_t * const **l_266[9][4] = {{&l_267[5][1],&l_267[5][1],&l_267[5][1],&l_267[5][1]},{&l_267[5][1],&l_267[5][1],(void*)0,&l_267[5][1]},{&l_267[5][1],&l_267[5][1],&l_267[5][1],&l_267[5][1]},{&l_267[5][1],&l_267[5][1],&l_267[5][1],&l_267[5][1]},{&l_267[5][1],&l_267[5][1],(void*)0,&l_267[5][1]},{&l_267[5][1],&l_267[5][1],&l_267[5][1],&l_267[5][1]},{&l_267[5][1],&l_267[5][1],&l_267[5][1],&l_267[5][1]},{&l_267[5][1],&l_267[5][1],(void*)0,&l_267[5][1]},{&l_267[5][1],&l_267[5][1],&l_267[5][1],&l_267[5][1]}};
            int32_t * const ***l_265[10] = {&l_266[2][0],&l_266[2][0],&l_266[2][0],&l_266[2][0],&l_266[2][0],&l_266[2][0],&l_266[2][0],&l_266[2][0],&l_266[2][0],&l_266[2][0]};
            int32_t *l_269 = &g_180[2].f1;
            uint8_t l_306 = 0x46;
            int i, j;
            l_233 = (**g_152);
lbl_274:
            l_251 = ((g_3[1] == g_198[3].f2) || ((int32_t)((int32_t)(((((int16_t)((int16_t)(__builtin_ctzll(((((int32_t)(((65534U == ((int16_t)((!((**g_152) ^ p_40)) < p_40) << (int16_t)12)) != (((int16_t)g_198[3].f8 + (int16_t)(((***g_151) <= p_39) == 0x3487E90F)) != 65534U)) < g_198[3].f3) % (int32_t)g_180[2].f1) == 0) > l_249)) < 4294967295U) >> (int16_t)p_41) >> (int16_t)p_43) >= 0xEA66983E) == (***g_151)) ^ l_250) - (int32_t)4294967290U) + (int32_t)(***g_151)));
            if (((uint16_t)(((func_70(g_198[3].f9, (((int16_t)(((int32_t)((uint16_t)((((uint16_t)l_249 >> (uint16_t)8) == (((int16_t)(l_250 != (g_180[2].f1 & 0x4285)) - (int16_t)((-1) >= ((*g_151) == l_264))) != (l_265[2] == (void*)0))) >= p_42) >> (uint16_t)l_268) % (int32_t)(*g_63)) || g_198[3].f2) << (int16_t)14) <= p_41), l_269, g_180[2].f2) ^ 0x27D7) == p_40) || g_3[1]) << (uint16_t)g_113[8][0]))
            { /* block id: 205 */
                int32_t ****l_270 = &g_151;
                (*l_270) = &g_152;
            }
            else
            { /* block id: 207 */
                const int16_t l_279 = 0x3E28;
                struct S0 * const l_304[2][8][6] = {{{(void*)0,&g_180[0],(void*)0,&g_198[0],(void*)0,(void*)0},{&g_198[2],&g_180[0],&g_198[3],&g_180[0],&g_180[0],(void*)0},{(void*)0,(void*)0,(void*)0,&g_198[3],&g_180[0],&g_180[2]},{&g_180[0],(void*)0,(void*)0,(void*)0,&g_198[3],(void*)0},{&g_180[0],&g_198[3],&g_180[2],&g_180[2],&g_198[3],&g_180[0]},{(void*)0,(void*)0,&g_198[3],&g_198[3],&g_180[1],(void*)0},{(void*)0,&g_198[3],&g_180[0],&g_180[0],&g_198[3],&g_198[0]},{&g_180[0],(void*)0,&g_198[0],&g_180[0],(void*)0,(void*)0}},{{(void*)0,&g_180[2],(void*)0,(void*)0,&g_198[3],&g_180[0]},{&g_198[2],&g_198[3],(void*)0,(void*)0,(void*)0,&g_198[3]},{&g_198[0],&g_180[0],(void*)0,(void*)0,&g_198[2],&g_180[0]},{&g_198[3],&g_180[2],&g_198[3],&g_198[2],(void*)0,&g_198[3]},{&g_198[3],&g_180[2],&g_198[3],&g_180[1],&g_198[2],(void*)0},{&g_198[3],&g_180[0],(void*)0,&g_198[3],(void*)0,(void*)0},{(void*)0,&g_198[3],(void*)0,&g_198[3],&g_198[3],(void*)0},{&g_180[2],&g_180[2],&g_180[1],&g_180[0],(void*)0,(void*)0}}};
                int i, j, k;
                if ((**g_152))
                { /* block id: 208 */
                    const int32_t l_273 = 2;
                    const struct S0 *l_283 = &g_180[2];
                    struct S0 **l_297 = (void*)0;
                    struct S0 ***l_296 = &l_297;
                    if (((int16_t)__builtin_popcount(p_40) >> (int16_t)l_273))
                    { /* block id: 209 */
                        float *l_284[1][4][2] = {{{(void*)0,(void*)0},{&g_198[3].f4,(void*)0},{(void*)0,&g_198[3].f4},{(void*)0,(void*)0}}};
                        int32_t l_285 = (-3);
                        int i, j, k;
                        (***g_151) = (-10);
                        if (p_39)
                            goto lbl_274;
                        (**g_152) = p_40;
                        l_285 = ((float)((float)(&g_151 != (void*)0) + (float)__builtin_popcount((l_279 == ((uint16_t)(-(int32_t)((l_283 == (void*)0) >= (&g_197 != (void*)0))) >> (uint16_t)((((-8) & (p_41 & 0xDE6F)) >= p_43) & g_180[2].f1))))) - (float)g_119);
                    }
                    else
                    { /* block id: 214 */
                        uint8_t l_294 = 8U;
                        (***g_151) = ((int16_t)((int16_t)(-3) << (int16_t)(((int32_t)((((((~(__builtin_ffsl(g_180[2].f0) ^ l_279)) <= __builtin_parityll(g_180[2].f1)) | l_273) <= (~p_39)) ^ p_39) || (**g_152)) - (int32_t)g_180[2].f3) > 1)) + (int16_t)l_294);
                    }
                    (*l_296) = l_295;
                    (***g_151) = p_42;
                    for (p_43 = 0; (p_43 != 18); p_43 += 3)
                    { /* block id: 221 */
                        const struct S0 **l_301 = &l_283;
                        const struct S0 ***l_300 = &l_301;
                        (*l_269) |= (((l_300 == (void*)0) || g_180[2].f3) > g_180[2].f8);
                    }
                }
                else
                { /* block id: 224 */
                    for (g_119 = 0; (g_119 < (-6)); g_119 -= 1)
                    { /* block id: 227 */
                        struct S0 **l_305 = &g_197;
                        (*l_305) = l_304[1][1][3];
                        /* statement id: 228 */
                        assert ((g_197 >= &g_198[0] && g_197 <= &g_198[3]) || (g_197 >= &g_180[0] && g_197 <= &g_180[3]) || g_197 == 0);
                        return g_180[2].f9;
                    }
                    (**g_151) = (void*)0;
                    /* statement id: 231 */
                    assert (g_63 == 0);
                    (*l_269) = (-1);
                    (**g_151) = (void*)0;
                }
                /* facts after branching */
                assert (g_63 == 0 || g_63 == &g_64);
                (*l_269) = (p_41 & (l_304[1][1][3] != l_304[1][1][3]));
                (*g_152) = (**g_151);
            }
            /* facts after branching */
            assert (g_63 == 0 || g_63 == &g_64);
            return l_306;
        }
        /* facts after branching */
        assert (g_63 == 0 || g_63 == &g_64);
        (*l_323) &= ((0xF79EB4F1 == ((int16_t)0 + (int16_t)(((int16_t)(((uint32_t)(l_313 >= ((uint32_t)__builtin_parity((-(uint16_t)(4294967295U || l_268))) - (uint32_t)__builtin_clzl(((int32_t)((uint16_t)g_3[1] << (uint16_t)10) + (int32_t)0x4B96D85E)))) % (uint32_t)l_322[0]) || 4294967295U) >> (int16_t)g_64) != p_42))) < l_54[0]);
        for (l_321 = (-10); (l_321 > (-11)); l_321 -= 5)
        { /* block id: 243 */
            uint8_t l_326 = 254U;
            int32_t l_347[7] = {4,4,4,4,4,4,4};
            float *l_360 = &g_128;
            int32_t l_361[7];
            int i;
            for (i = 0; i < 7; i = i + 1)
                l_361[i] = 0xDC04758E;
        }
        for (p_40 = 0; (p_40 <= 1); p_40 += 1)
        { /* block id: 275 */
            struct S0 **l_362 = (void*)0;
            int32_t l_383[3];
            int32_t * const *l_396[10];
            int i;
            for (i = 0; i < 3; i = i + 1)
                l_383[i] = (-4);
            for (i = 0; i < 10; i = i + 1)
                l_396[i] = &l_323;
            g_363 = l_362;
            /* statement id: 276 */
            assert (g_363 == 0);
            for (l_251 = 0; (l_251 <= 1); l_251 += 1)
            { /* block id: 279 */
                int32_t *l_367 = &l_336;
                int32_t l_397[5];
                int i;
                for (i = 0; i < 5; i = i + 1)
                    l_397[i] = 0x8D4A9802;
                if (((int16_t)l_54[p_40] >> (int16_t)3))
                { /* block id: 280 */
                    int32_t l_366[4][2] = {{0,0},{6,0},{0,6},{0,0}};
                    struct S0 ***l_368 = (void*)0;
                    struct S0 ***l_370 = &g_363;
                    int i, j;
                    l_336 &= l_366[2][1];
                    (*l_323) = ((*l_367) == p_40);
                    l_369 = (void*)0;
                    /* statement id: 283 */
                    assert (l_369 == 0);
                    (*l_370) = l_362;
                }
                else
                { /* block id: 285 */
                    uint8_t l_373 = 246U;
                    int32_t l_391 = (-4);
                    (**g_151) = (**g_151);
                    for (l_336 = 21; (l_336 > 24); l_336 += 1)
                    { /* block id: 289 */
                        if (p_41)
                            break;
                    }
                    if (l_373)
                    { /* block id: 292 */
                        (*l_323) &= ((int16_t)g_198[3].f0 % (int16_t)p_43);
                        (*l_323) &= ((uint16_t)(((uint16_t)(!(g_180[2].f6 == l_373)) + (uint16_t)(((uint16_t)(((*l_367) <= 65535U) > g_180[2].f0) >> (uint16_t)l_383[2]) <= p_42)) > g_198[3].f8) << (uint16_t)15);
                        l_391 |= ((((int16_t)g_119 << (int16_t)5) && __builtin_parityl((~(1 | (p_42 & g_119))))) == ((uint16_t)1U % (uint16_t)((uint32_t)g_198[3].f2 % (uint32_t)(-6))));
                    }
                    else
                    { /* block id: 296 */
                        (*l_367) |= ((int16_t)0x05EE + (int16_t)__builtin_popcountll(((uint32_t)p_39 + (uint32_t)(l_396[8] != (*g_151)))));
                    }
                }
                if ((*l_367))
                    continue;
                if (l_397[0])
                    continue;
            }
        }
        /* facts after for loop */
        assert (g_363 == 0 || g_363 == &g_197);
        assert (l_369 == &g_197 || l_369 == 0);
    }
    /* facts after branching */
    assert (g_63 == 0 || g_63 == &g_64);
    assert (g_363 == 0 || g_363 == &g_197);
    for (g_345 = (-18); (g_345 <= (-8)); g_345 += 2)
    { /* block id: 307 */
        int32_t *l_400 = &g_180[2].f5;
        if (p_41)
            break;
        (*l_400) |= g_119;
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_46(int32_t  p_47, int32_t  p_48, uint8_t  p_49)
{ /* block id: 38 */
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : g_198.f1 g_152 g_63 g_64 g_3 g_113 g_180.f2 g_151 g_114
 * writes: g_64 g_198.f1 g_114
 */
inline static int32_t * func_55(float  p_56, int32_t * p_57, int32_t * p_58)
{ /* block id: 166 */
    float *l_204 = &g_198[3].f4;
    const struct S0 *l_207 = (void*)0;
    int32_t l_208 = (-9);
    int32_t ****l_213 = (void*)0;
    int32_t *****l_212 = &l_213;
    struct S0 **l_214 = (void*)0;
    int32_t *l_215 = &g_198[3].f1;
    (**g_152) = ((uint16_t)g_198[3].f1 + (uint16_t)1U);
    for (g_64 = 0; (g_64 != (-18)); g_64 -= 6)
    { /* block id: 170 */
        uint8_t l_205 = 1U;
        struct S0 *l_206[3];
        int32_t *****l_211 = (void*)0;
        int i;
        for (i = 0; i < 3; i = i + 1)
            l_206[i] = (void*)0;
        g_198[3].f1 = ((l_204 != l_204) > func_46((l_205 || ((l_206[0] != l_207) != g_3[0])), func_46((l_208 || (((l_205 == ((uint16_t)(l_211 != l_212) << (uint16_t)6)) >= g_113[5][0]) == 4294967292U)), l_205, l_205), g_180[2].f2));
    }
    l_207 = &g_180[2];
    /* statement id: 173 */
    assert ((l_207 >= &g_180[0] && l_207 <= &g_180[3]));
    (*l_215) ^= (**g_152);
    return (**g_151);
    /* statement id: 175 */
    //assert (func_55_rv == &g_64 || func_55_rv == &g_114);
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_63 g_3 g_114 g_119 g_113 g_151 g_152 g_180.f9
 * writes: g_64 g_113 g_114 g_119 g_128 g_63 g_197
 */
static int32_t * func_59(int32_t * p_60, int32_t  p_61, uint16_t  p_62)
{ /* block id: 44 */
    uint16_t l_76[2];
    int32_t *l_87 = &g_64;
    int16_t l_139 = 0xD1CE;
    int32_t *l_193[5] = {&g_180[2].f5,&g_180[2].f5,&g_180[2].f5,&g_180[2].f5,&g_180[2].f5};
    int32_t l_194[7];
    struct S0 *l_196 = &g_180[2];
    struct S0 **l_195[8] = {&l_196,&l_196,&l_196,&l_196,&l_196,&l_196,&l_196,&l_196};
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_76[i] = 0U;
    for (i = 0; i < 7; i = i + 1)
        l_194[i] = 8;
    l_194[2] &= (p_62 >= func_70(__builtin_ffsl((((0xF277 > ((((-(int32_t)(l_76[0] != ((uint16_t)((int16_t)((int16_t)((uint32_t)((int16_t)(l_87 == l_87) << (int16_t)1) + (uint32_t)(&g_64 != (void*)0)) % (int16_t)(func_88(func_93(((int16_t)((*l_87) >= g_64) << (int16_t)g_64), &g_64, (*l_87)), p_60, l_139, g_3[1]) ^ 0xEBD28546)) % (int16_t)0x2D40) >> (uint16_t)g_3[0]))) || (*l_87)) == 0xB113) || 0x2C56C064)) && (*p_60)) < 0x9544)), g_3[1], g_63, g_3[1]));
    g_197 = &g_180[1];
    /* statement id: 164 */
    assert ((g_197 >= &g_180[0] && g_197 <= &g_180[3]));
    return (*g_152);
    /* statement id: 165 */
    //assert (func_59_rv == &g_64);
}


/* ------------------------------------------ */
/* 
 * reads : g_119 g_64 g_114 g_113 g_151 g_152 g_63 g_3 g_180.f9 g_180.f1
 * writes: g_119 g_114 g_64 g_63 g_180.f1
 */
static uint32_t  func_70(uint32_t  p_71, uint32_t  p_72, int32_t * p_73, uint8_t  p_74)
{ /* block id: 96 */
    float l_153 = 0x1.3p+1;
    int32_t l_171 = (-8);
    int32_t ***l_174 = (void*)0;
    uint32_t l_176 = 4294967295U;
    for (g_119 = 0; (g_119 >= 0); g_119 -= 1)
    { /* block id: 99 */
        int32_t **l_144 = &g_63;
        int32_t l_154[5][8][6] = {{{7,0xC3218605,(-1),0x8F1E77B9,0xC61BAF8C,(-9)},{(-9),0x5BE2A38A,0xC3218605,0xC3218605,0x5BE2A38A,(-9)},{0x8F1E77B9,0x3277048F,(-1),0x12D87D77,(-9),0x4BA4E592},{0x5BE2A38A,7,(-5),(-9),(-5),7},{0x5BE2A38A,0x4BA4E592,(-9),0x12D87D77,(-1),0x3277048F},{0x8F1E77B9,(-9),0x5BE2A38A,0xC3218605,0xC3218605,0x5BE2A38A},{(-9),(-9),0xC61BAF8C,0x8F1E77B9,(-1),0xC3218605},{7,0x4BA4E592,0x12D87D77,0xC61BAF8C,(-5),0xC61BAF8C}},{{0x12D87D77,7,0x12D87D77,0x3277048F,(-9),0xC3218605},{1,0x3277048F,0xC61BAF8C,(-3),0x5BE2A38A,0x5BE2A38A},{(-3),0x5BE2A38A,0x5BE2A38A,(-3),0xC61BAF8C,0x3277048F},{1,0xC3218605,(-9),0x3277048F,0x12D87D77,7},{0x12D87D77,0xC61BAF8C,(-5),0xC61BAF8C,0x12D87D77,0x4BA4E592},{7,0xC3218605,(-1),0x8F1E77B9,0xC61BAF8C,(-9)},{(-9),0x5BE2A38A,0xC3218605,0xC3218605,0x5BE2A38A,(-9)},{0x8F1E77B9,0x3277048F,(-1),0x12D87D77,(-9),0x4BA4E592}},{{0x5BE2A38A,7,(-5),0xC61BAF8C,1,0x8F1E77B9},{(-3),(-1),0xC61BAF8C,0xC3218605,(-5),0x4BA4E592},{0x3277048F,0xC61BAF8C,(-3),0x5BE2A38A,0x5BE2A38A,(-3)},{0xC61BAF8C,0xC61BAF8C,7,0x3277048F,(-5),0x5BE2A38A},{0x8F1E77B9,(-1),0xC3218605,7,1,7},{0xC3218605,0x8F1E77B9,0xC3218605,0x4BA4E592,0xC61BAF8C,0x5BE2A38A},{0x12D87D77,0x4BA4E592,7,(-9),(-3),(-3)},{(-9),(-3),(-3),(-9),7,0x4BA4E592}},{{0x12D87D77,0x5BE2A38A,0xC61BAF8C,0x4BA4E592,0xC3218605,0x8F1E77B9},{0xC3218605,7,1,7,0xC3218605,(-1)},{0x8F1E77B9,0x5BE2A38A,(-5),0x3277048F,7,0xC61BAF8C},{0xC61BAF8C,(-3),0x5BE2A38A,0x5BE2A38A,(-3),0xC61BAF8C},{0x3277048F,0x4BA4E592,(-5),0xC3218605,0xC61BAF8C,(-1)},{(-3),0x8F1E77B9,1,0xC61BAF8C,1,0x8F1E77B9},{(-3),(-1),0xC61BAF8C,0xC3218605,(-5),0x4BA4E592},{0x3277048F,0xC61BAF8C,(-3),0x5BE2A38A,0x5BE2A38A,(-3)}},{{0xC61BAF8C,0xC61BAF8C,7,0x3277048F,(-5),0x5BE2A38A},{0x8F1E77B9,(-1),0xC3218605,7,1,7},{0xC3218605,0x8F1E77B9,0xC3218605,0x4BA4E592,0xC61BAF8C,0x5BE2A38A},{0x12D87D77,0x4BA4E592,7,(-9),(-3),(-3)},{(-9),(-3),(-3),(-9),7,0x4BA4E592},{0x12D87D77,0x5BE2A38A,0xC61BAF8C,0x4BA4E592,0xC3218605,0x8F1E77B9},{0xC3218605,7,1,7,0xC3218605,(-1)},{0x8F1E77B9,0x5BE2A38A,(-5),0x3277048F,7,0xC61BAF8C}}};
        struct S0 *l_179 = &g_180[2];
        int i, j, k;
        if ((*p_73))
        { /* block id: 100 */
            float l_155 = 0x5.Bp-1;
            int32_t l_167 = 0x48B132FC;
            uint32_t l_175 = 1U;
            int32_t *l_177[3][4][8] = {{{&l_167,&l_167,&g_119,&l_167,&l_167,&g_119,&l_167,&l_167},{&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167},{&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167},{&l_167,&l_167,&g_119,&l_167,&l_167,&g_119,&l_167,&l_167}},{{&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167},{&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167},{&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167},{&g_119,&l_167,&g_119,&g_119,&l_167,&g_119,&g_119,&l_167}},{{&l_167,&g_119,&g_119,&l_167,&g_119,&g_119,&l_167,&g_119},{&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167,&l_167},{&g_119,&l_167,&g_119,&g_119,&l_167,&g_119,&g_119,&l_167},{&l_167,&g_119,&g_119,&l_167,&g_119,&g_119,&l_167,&g_119}}};
            uint32_t l_178 = 0x062718ED;
            int i, j, k;
            for (g_114 = 0; (g_114 >= 0); g_114 -= 1)
            { /* block id: 103 */
                float *l_156 = &l_155;
                int32_t l_159 = (-10);
                int i, j;
                (*l_156) = ((((((float)(func_46(((uint32_t)0x61D1304D + (uint32_t)((&p_73 != l_144) > ((int16_t)g_113[(g_114 + 1)][g_119] << (int16_t)1))), __builtin_ctzl(((int16_t)((int16_t)(&l_144 == g_151) + (int16_t)((*g_151) == (void*)0)) >> (int16_t)14)), p_71) == l_153) - (float)p_71) != l_154[1][1][2]) != (**l_144)) <= 0xC.30C7D5p+66) >= l_155);
                (*p_73) = ((int16_t)(**l_144) >> (int16_t)((__builtin_parityll((g_64 >= __builtin_bswap64(g_113[5][0]))) <= l_159) >= 6U));
                for (l_159 = 0; (l_159 <= 0); l_159 += 1)
                { /* block id: 108 */
                    int16_t l_166 = 0;
                    if ((*g_63))
                        break;
                    l_167 ^= (p_74 < ((*g_63) > ((***g_151) & (__builtin_ffs((*g_63)) != ((p_74 < p_72) | ((((int16_t)((uint16_t)__builtin_popcountl(((int32_t)g_113[(g_114 + 1)][g_119] + (int32_t)(&p_73 != (void*)0))) << (uint16_t)11) >> (int16_t)g_3[1]) > (**l_144)) <= l_166))))));
                    if ((p_73 == (void*)0))
                    { /* block id: 111 */
                        (**l_144) |= (p_73 != p_73);
                        (**l_144) = (-6);
                    }
                    else
                    { /* block id: 114 */
                        uint32_t l_168 = 0x26852E78;
                        (*l_156) = (&g_152 != &l_144);
                        return l_168;
                    }
                }
            }
            (**l_144) = (g_3[0] | ((uint16_t)l_171 % (uint16_t)(func_46(((int16_t)((*g_152) != (*l_144)) + (int16_t)(&g_152 == l_174)), (l_175 != (((*g_151) == (*g_151)) != p_74)), l_176) && l_167)));
            l_171 ^= (*p_73);
            l_171 ^= (func_46(((1 <= g_64) < (**g_152)), (**l_144), ((((*p_73) <= (**g_152)) > (0x8C2D907B > (**g_152))) > 9U)) > l_178);
        }
        else
        { /* block id: 123 */
            struct S0 **l_181 = &l_179;
            (*l_181) = l_179;
        }
        for (l_176 = 0; (l_176 <= 0); l_176 += 1)
        { /* block id: 128 */
            int32_t l_189 = 5;
            int16_t l_192[6][5][7] = {{{0x332A,(-6),0x332A,1,1,0x332A,(-6)},{0,0x5FB8,0x1409,0x6D99,8,0x3F3F,8},{0x332A,1,1,0x332A,(-6),0x332A,1},{0x9678,9,0,0x6D99,0,9,0x9678},{0x3D08,1,0x11B4,1,0x3D08,0x3D08,1}},{{(-1),0x5FB8,(-1),0x3F3F,0,5,8},{1,(-6),0x11B4,0x11B4,(-6),1,(-6)},{(-1),0x3F3F,0,5,8,5,0},{0x3D08,0x3D08,1,0x11B4,1,0x3D08,0x3D08},{0x9678,0x3F3F,0x1409,0x3F3F,0x9678,9,0}},{{0x332A,(-6),0x332A,1,1,0x332A,(-6)},{0,0x5FB8,0x1409,0x6D99,8,0x3F3F,8},{0x332A,1,1,0x332A,(-6),0x332A,1},{0x9678,9,0,0x6D99,0,9,0x9678},{0x3D08,1,0x11B4,1,0x3D08,0x3D08,1}},{{(-1),0x5FB8,(-1),0x3F3F,0,5,8},{1,(-6),0x11B4,0x11B4,(-6),1,(-6)},{(-1),0x3F3F,0,5,8,5,0},{0x3D08,0x3D08,1,0x11B4,1,0x3D08,0x3D08},{0x9678,0x3F3F,0x1409,0x3F3F,0x9678,9,0}},{{0x332A,(-6),0x332A,1,0x332A,0x11B4,0x3D08},{(-1),9,8,0x5FB8,0x9678,5,0x9678},{0x11B4,0x332A,0x332A,0x11B4,0x3D08,0x11B4,0x332A},{0,0x3F3F,(-1),0x5FB8,(-1),0x3F3F,0},{1,0x332A,(-6),0x332A,1,1,0x332A}},{{0x1409,9,0x1409,5,(-1),0x6D99,0x9678},{0x332A,0x3D08,(-6),(-6),0x3D08,0x332A,0x3D08},{0x1409,5,(-1),0x6D99,0x9678,0x6D99,(-1)},{1,1,0x332A,(-6),0x332A,1,1},{0,5,8,5,0,0x3F3F,(-1)}}};
            int i, j, k;
            for (p_72 = 0; (p_72 <= 0); p_72 += 1)
            { /* block id: 131 */
                const int32_t l_182[9][3][6] = {{{1,(-1),1,0xC3F753BD,(-9),1},{(-1),0x10644F25,0,0x860EB3D4,0xC3F753BD,0x8AF396E7},{(-9),0x2CB1EAEA,(-1),0x37B3BEAB,(-1),0}},{{1,1,(-1),0xC3F753BD,0x10644F25,0x8AF396E7},{0xE0E378A0,(-9),0,0x60D4552D,0x2CB1EAEA,1},{0x60D4552D,0x2CB1EAEA,1,1,1,1}},{{1,1,0,(-1),(-9),0x8AF396E7},{0xC3F753BD,0xE01BE6A3,(-1),0x860EB3D4,0x2CB1EAEA,0},{0x10644F25,0xC3F753BD,(-1),1,1,0x8AF396E7}},{{1,1,0,0xE0E378A0,0xE01BE6A3,1},{0xE0E378A0,0xE01BE6A3,1,(-9),0xC3F753BD,1},{0x10644F25,(-1),0,0x37B3BEAB,1,0x8AF396E7}},{{1,(-1),(-1),(-1),0xE01BE6A3,0},{(-1),(-9),(-1),(-9),(-1),0x8AF396E7},{0x60D4552D,0xC3F753BD,0,1,(-1),1}},{{1,(-1),1,0xC3F753BD,(-9),1},{(-1),0x10644F25,0,0x860EB3D4,0xC3F753BD,0x8AF396E7},{(-9),0x2CB1EAEA,(-1),0x37B3BEAB,(-1),0}},{{1,1,(-1),0xC3F753BD,0x10644F25,0x8AF396E7},{0xE0E378A0,(-9),0,0x60D4552D,0x2CB1EAEA,1},{0x60D4552D,0x2CB1EAEA,1,1,1,0x37B3BEAB}},{{0xB747BEB8,0xB747BEB8,1,(-10),0,1},{0x84AA91B6,0xF3CC005B,(-1),0,8,1},{1,0x84AA91B6,(-1),0xFC589675,0xB747BEB8,1}},{{0x3560D2B7,0xFC589675,1,0x33619917,0xF3CC005B,0x37B3BEAB},{0x33619917,0xF3CC005B,0x37B3BEAB,0,0x84AA91B6,0x37B3BEAB},{1,(-1),1,(-2),0xFC589675,1}}};
                uint16_t l_186 = 0x4E48;
                int i, j, k;
                if (__builtin_popcountll((l_182[3][1][1] >= ((uint16_t)__builtin_bswap32(l_182[5][0][0]) << (uint16_t)5))))
                { /* block id: 132 */
                    int32_t l_185 = 0xEDBEAE75;
                    (*l_144) = (**g_151);
                    (*p_73) ^= (l_185 && l_186);
                    return g_180[2].f9;
                }
                else
                { /* block id: 136 */
                    uint8_t l_187[5];
                    float *l_188 = (void*)0;
                    int i;
                    for (i = 0; i < 5; i = i + 1)
                        l_187[i] = 250U;
                    l_189 = l_187[3];
                    if ((***g_151))
                        break;
                    if ((*p_73))
                        break;
                }
                (**g_152) = (*p_73);
                for (p_71 = 0; (p_71 <= 0); p_71 += 1)
                { /* block id: 144 */
                    for (l_171 = 4; (l_171 >= 0); l_171 -= 1)
                    { /* block id: 147 */
                        int32_t ****l_191 = &l_174;
                        int32_t *****l_190 = &l_191;
                        (*l_190) = &g_151;
                        /* statement id: 148 */
                        assert (l_191 == &g_151);
                    }
                    if ((***g_151))
                        continue;
                }
            }
            l_192[1][2][1] = (p_74 != (__builtin_ctz(g_3[1]) > 0xFDE11B9B));
            for (l_189 = 0; (l_189 >= 0); l_189 -= 1)
            { /* block id: 156 */
                return g_180[2].f9;
            }
        }
    }
    (*p_73) = ((void*)0 != l_174);
    return g_119;
}


/* ------------------------------------------ */
/* 
 * reads : g_114 g_119 g_63
 * writes: g_64 g_114
 */
inline static uint32_t  func_88(int32_t * p_89, int32_t * p_90, int32_t  p_91, float  p_92)
{ /* block id: 92 */
    (*g_63) = (func_46(g_114, g_119, g_114) | ((void*)0 != &g_64));
    (*p_89) = 0x4DE62905;
    return g_119;
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_64 g_3 g_114 g_119 g_113
 * writes: g_64 g_113 g_114 g_119 g_128
 */
static int32_t * func_93(int32_t  p_94, int32_t * p_95, uint8_t  p_96)
{ /* block id: 45 */
    const float l_125 = 0xC.1B1975p+77;
    int32_t l_129 = 0x345427DA;
    float *l_130 = &g_128;
    int32_t *l_138 = &g_64;
lbl_120:
    (*g_63) &= ((uint16_t)((uint16_t)0x0FAC << (uint16_t)10) << (uint16_t)(&g_64 == (void*)0));
    for (p_96 = (-14); (p_96 <= 40); p_96 += 1)
    { /* block id: 49 */
        for (p_94 = 0; (p_94 <= (-30)); p_94 -= 1)
        { /* block id: 52 */
            int32_t **l_108 = &g_63;
            int32_t ***l_107 = &l_108;
            uint32_t l_126 = 0x7E171BA0;
            (*l_107) = &g_63;
            for (g_64 = 26; (g_64 <= 19); g_64 -= 6)
            { /* block id: 56 */
                int32_t l_117 = 0xC258348F;
                g_113[5][0] = (((float)g_64 - (float)g_3[1]) < (-0x4.2p-1));
                for (g_114 = 0; (g_114 <= (-10)); g_114 -= 1)
                { /* block id: 60 */
                    int32_t *l_118 = &g_119;
                    l_117 = __builtin_popcountll(p_96);
                    (*l_118) = (*g_63);
                    if ((p_94 <= 0xE089))
                    { /* block id: 63 */
                        if (p_94)
                            goto lbl_120;
                        if (g_114)
                            goto lbl_120;
                        g_119 ^= (-(int16_t)(((&p_95 != &g_63) & ((uint16_t)p_94 << (uint16_t)11)) >= 0x97EF0591));
                        if (l_117)
                            break;
                    }
                    else
                    { /* block id: 68 */
                        int32_t l_124 = 1;
                        float *l_127[3][3] = {{(void*)0,(void*)0,(void*)0},{&g_128,(void*)0,&g_128},{(void*)0,(void*)0,(void*)0}};
                        int i, j;
                        (*l_118) ^= l_124;
                        l_129 = (func_46((l_124 <= (0 & g_64)), (0U & 0x66DF6EF7), (**l_108)) >= (func_46((l_117 == (((((*l_118) != l_117) < (*g_63)) | 0xABC7) & l_126)), g_64, g_3[1]) <= 0x6.E9AC72p-92));
                    }
                }
            }
            for (g_114 = 0; (g_114 <= 0); g_114 += 1)
            { /* block id: 76 */
                int i, j;
                if (g_113[(g_114 + 3)][g_114])
                    break;
                if ((*g_63))
                    break;
                for (g_64 = 0; (g_64 >= 0); g_64 -= 1)
                { /* block id: 81 */
                    (*l_107) = (*l_107);
                    if (l_126)
                        goto lbl_120;
                }
            }
        }
        (*p_95) ^= l_129;
    }
    (*l_130) = 0x1.3p+1;
    (*p_95) ^= (l_129 || ((int32_t)(1 || func_46(l_129, ((uint16_t)((int16_t)l_129 + (int16_t)((!(p_94 ^ 0xD5E4)) < 65535U)) >> (uint16_t)6), p_94)) % (int32_t)0x12FBD8D1));
    return l_138;
    /* statement id: 91 */
    //assert (func_93_rv == &g_64);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    for (i = 0; i < 2; i = i + 1)
    {
        transparent_crc(g_3[i], "g_3[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_64, "g_64", print_hash_value);
    for (i = 0; i < 9; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
        {
            transparent_crc(g_113[i][j], "g_113[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_114, "g_114", print_hash_value);
    transparent_crc(g_119, "g_119", print_hash_value);
    transparent_crc_bytes (&g_128, sizeof(g_128), "g_128", print_hash_value);
    for (i = 0; i < 4; i = i + 1)
    {
        transparent_crc(g_180[i].f0, "g_180[i].f0", print_hash_value);
        transparent_crc(g_180[i].f1, "g_180[i].f1", print_hash_value);
        transparent_crc(g_180[i].f2, "g_180[i].f2", print_hash_value);
        transparent_crc(g_180[i].f3, "g_180[i].f3", print_hash_value);
        transparent_crc_bytes(&g_180[i].f4, sizeof(g_180[i].f4), "g_180[i].f4", print_hash_value);
        transparent_crc(g_180[i].f5, "g_180[i].f5", print_hash_value);
        transparent_crc(g_180[i].f6, "g_180[i].f6", print_hash_value);
        transparent_crc_bytes(&g_180[i].f7, sizeof(g_180[i].f7), "g_180[i].f7", print_hash_value);
        transparent_crc(g_180[i].f8, "g_180[i].f8", print_hash_value);
        transparent_crc(g_180[i].f9, "g_180[i].f9", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 4; i = i + 1)
    {
        transparent_crc(g_198[i].f0, "g_198[i].f0", print_hash_value);
        transparent_crc(g_198[i].f1, "g_198[i].f1", print_hash_value);
        transparent_crc(g_198[i].f2, "g_198[i].f2", print_hash_value);
        transparent_crc(g_198[i].f3, "g_198[i].f3", print_hash_value);
        transparent_crc_bytes(&g_198[i].f4, sizeof(g_198[i].f4), "g_198[i].f4", print_hash_value);
        transparent_crc(g_198[i].f5, "g_198[i].f5", print_hash_value);
        transparent_crc(g_198[i].f6, "g_198[i].f6", print_hash_value);
        transparent_crc_bytes(&g_198[i].f7, sizeof(g_198[i].f7), "g_198[i].f7", print_hash_value);
        transparent_crc(g_198[i].f8, "g_198[i].f8", print_hash_value);
        transparent_crc(g_198[i].f9, "g_198[i].f9", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_345, "g_345", print_hash_value);
    transparent_crc(g_602, "g_602", print_hash_value);
    transparent_crc(g_655.f0, "g_655.f0", print_hash_value);
    transparent_crc(g_655.f1, "g_655.f1", print_hash_value);
    transparent_crc(g_655.f2, "g_655.f2", print_hash_value);
    transparent_crc(g_655.f3, "g_655.f3", print_hash_value);
    transparent_crc_bytes (&g_655.f4, sizeof(g_655.f4), "g_655.f4", print_hash_value);
    transparent_crc(g_655.f5, "g_655.f5", print_hash_value);
    transparent_crc(g_655.f6, "g_655.f6", print_hash_value);
    transparent_crc_bytes (&g_655.f7, sizeof(g_655.f7), "g_655.f7", print_hash_value);
    transparent_crc(g_655.f8, "g_655.f8", print_hash_value);
    transparent_crc(g_655.f9, "g_655.f9", print_hash_value);
    transparent_crc(g_726, "g_726", print_hash_value);
    transparent_crc(g_727, "g_727", print_hash_value);
    transparent_crc(g_738, "g_738", print_hash_value);
    transparent_crc(g_893, "g_893", print_hash_value);
    transparent_crc(g_921.f0, "g_921.f0", print_hash_value);
    transparent_crc(g_921.f1, "g_921.f1", print_hash_value);
    transparent_crc(g_921.f2, "g_921.f2", print_hash_value);
    transparent_crc(g_921.f3, "g_921.f3", print_hash_value);
    transparent_crc_bytes (&g_921.f4, sizeof(g_921.f4), "g_921.f4", print_hash_value);
    transparent_crc(g_921.f5, "g_921.f5", print_hash_value);
    transparent_crc(g_921.f6, "g_921.f6", print_hash_value);
    transparent_crc_bytes (&g_921.f7, sizeof(g_921.f7), "g_921.f7", print_hash_value);
    transparent_crc(g_921.f8, "g_921.f8", print_hash_value);
    transparent_crc(g_921.f9, "g_921.f9", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 277
XXX total union variables: 0

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 278
   depth: 2, occurrence: 63
   depth: 3, occurrence: 9
   depth: 4, occurrence: 8
   depth: 5, occurrence: 5
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 4
   depth: 10, occurrence: 3
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 4
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 202

XXX times a variable address is taken: 373
XXX times a pointer is dereferenced on RHS: 142
breakdown:
   depth: 1, occurrence: 97
   depth: 2, occurrence: 38
   depth: 3, occurrence: 7
XXX times a pointer is dereferenced on LHS: 129
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 29
   depth: 3, occurrence: 7
XXX times a pointer is compared with null: 52
XXX times a pointer is compared with address of another variable: 17
XXX times a pointer is compared with another pointer: 24
XXX times a pointer is qualified to be dereferenced: 1172

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 591
   level: 2, occurrence: 298
   level: 3, occurrence: 133
   level: 4, occurrence: 32
   level: 5, occurrence: 29
XXX number of pointers point to pointers: 102
XXX number of pointers point to scalars: 80
XXX number of pointers point to structs: 20
XXX percent of pointers has null in alias set: 28.2
XXX average alias set size: 1.39

XXX times a non-volatile is read: 1260
XXX times a non-volatile is write: 451
XXX times a volatile is read: 35
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 887
XXX percentage of non-volatile access: 98

XXX forward jumps: 2
XXX backward jumps: 13

XXX stmts: 261
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 19
   depth: 2, occurrence: 29
   depth: 3, occurrence: 37
   depth: 4, occurrence: 63
   depth: 5, occurrence: 83

XXX percentage a fresh-made variable is used: 17.3
XXX percentage an existing variable is used: 82.7
********************* end of statistics **********************/

