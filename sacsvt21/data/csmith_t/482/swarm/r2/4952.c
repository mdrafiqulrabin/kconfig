/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      882214218
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int32_t  f0;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_9 = (-4L);
static int32_t *g_37 = (void*)0;
static const int32_t g_86 = 1L;
static int32_t g_88 = 0x78A82FB3L;
static int32_t g_153 = 1L;
static int32_t *g_152 = &g_153;
static union U0 g_161 = {0x2DDDAE5FL};
static uint32_t g_231 = 4294967289UL;
static int32_t g_285 = 0x1DFA8A07L;
static int32_t g_301 = (-1L);
static union U0 ***g_328 = (void*)0;
static int32_t **g_340 = &g_37;
static int32_t ***g_339 = &g_340;
static int32_t ****g_338 = &g_339;
static int32_t *g_363 = &g_153;
static union U0 *g_405 = &g_161;
static union U0 **g_404 = &g_405;
static int32_t g_410 = 0L;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_26(void);
inline static int32_t * func_28(const uint32_t  p_29, uint32_t  p_30, union U0  p_31);
inline static uint16_t  func_32(int32_t * p_33, int32_t * p_34, int32_t * p_35, uint32_t  p_36);
inline static int32_t * func_38(int32_t  p_39, int32_t  p_40, const int16_t  p_41, int32_t * p_42);
static int16_t  func_47(int32_t * p_48, const int32_t * p_49, int32_t * p_50, uint16_t  p_51);
inline static int32_t  func_71(int32_t  p_72);
static int32_t * func_92(int32_t * p_93, uint32_t  p_94, int32_t * p_95);
inline static int32_t * func_96(uint32_t  p_97);
static union U0  func_100(int32_t * p_101, uint16_t  p_102, int32_t * p_103, union U0  p_104);
static int32_t * func_105(const int32_t  p_106, int32_t * p_107, const int32_t  p_108, int32_t * p_109, int32_t * p_110);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_9 g_37 g_88 g_86 g_161 g_161.f1 g_152 g_153 g_231 g_161.f0 g_285 g_301 g_328 g_338 g_339 g_340 g_363 g_404 g_410 g_405
 * writes: g_88 g_9 g_153 g_152 g_37 g_161.f1 g_340 g_405
 */
static int32_t  func_26(void)
{ /* block id: 36 */
    uint32_t l_27 = 0x0D658EDFL;
    int32_t l_83 = 0x369E1D62L;
    int32_t l_262 = 1L;
    uint16_t l_293 = 0xEB30L;
    union U0 *l_315 = &g_161;
    union U0 **l_314 = &l_315;
    union U0 *l_344 = &g_161;
    int32_t l_345 = (-2L);
    uint16_t l_354 = 0xC2A6L;
    uint32_t l_364 = 0xFA5ECB41L;
    int32_t **l_365 = &g_37;
    union U0 **l_374 = &l_315;
    int32_t l_392 = 0x540B4691L;
    if (g_9)
    { /* block id: 37 */
        int32_t l_55 = 0xC2A41B87L;
        union U0 l_296 = {0xA1730DD1L};
        union U0 *l_304 = &l_296;
        union U0 **l_303 = &l_304;
        union U0 ***l_302 = &l_303;
        int32_t l_310 = 0x1A656AFCL;
        int32_t *l_317 = &g_88;
        int16_t l_343 = 0x8A62L;
        if (l_27)
        { /* block id: 38 */
            int16_t l_82 = (-1L);
            const uint32_t l_84 = 0x35F2012CL;
            const int32_t *l_85 = &g_86;
            int32_t *l_87 = &g_88;
            union U0 l_263 = {-1L};
            int32_t **l_292 = &l_87;
            union U0 ****l_305 = &l_302;
            (*l_292) = func_28((func_32(g_37, func_38(((int32_t)((int16_t)func_47(((((uint16_t)(((+(0x189D9E62L > l_55)) <= 6UL) , 0xC877L) << (uint16_t)((uint16_t)((((((uint16_t)((int32_t)((uint16_t)(((int32_t)((int32_t)((uint16_t)((((((((-(uint32_t)((g_9 , (((func_71(((uint16_t)65534UL - (uint16_t)(g_37 == (void*)0))) && 0xC5C2DA50L) , g_9) | l_55)) != 65535UL)) < l_82) && l_27) | g_9) <= l_82) , g_37) != (void*)0) , l_82) << (uint16_t)g_9) + (int32_t)0x1993E367L) - (int32_t)0xCE65120BL) , l_27) + (uint16_t)l_83) + (int32_t)l_82) << (uint16_t)g_9) < l_83) != l_55) | 0xC58AL) | g_9) + (uint16_t)g_9)) & l_84) , g_37), l_85, l_87, g_88) << (int16_t)l_83) % (int32_t)g_9), l_55, l_55, &g_88), g_37, g_161.f1) != (*l_85)), l_262, l_263);
            /* statement id: 136 */
            assert (l_87 == &g_153 || l_87 == &g_88);
            assert (g_152 == &g_88);
            l_262 = (((0x55A2B3F6L | g_153) > l_293) ^ ((func_32(&g_153, func_105((((((((int32_t)(((g_88 != l_83) == (((((l_296 , ((uint16_t)(g_9 , ((int32_t)(func_100(&g_88, g_231, &g_153, g_161) , (*g_152)) + (int32_t)4294967295UL)) >> (uint16_t)g_86)) , (*g_152)) & (-5L)) , g_88) | 0x390CL)) ^ 0xFEBDL) - (int32_t)l_296.f0) != g_161.f1) , (void*)0) == &g_152) || l_296.f0) && l_27), &g_88, (*g_152), &g_88, &g_88), &g_88, g_301) , (*g_152)) <= 4UL));
            (*l_305) = l_302;
        }
        else
        { /* block id: 139 */
            int32_t **l_306 = &g_37;
            const int16_t l_309 = 0x3CC0L;
            union U0 **l_313 = &l_304;
            union U0 ****l_318 = &l_302;
            const int32_t l_347 = 0x63148271L;
            (*l_306) = &g_153;
            /* statement id: 140 */
            assert (g_37 == &g_153);
            if ((func_47(&g_153, ((func_32((((int16_t)((-1L) >= (*g_152)) >> (int16_t)(l_293 >= (((g_285 ^ g_285) ^ (**l_306)) || l_309))) , &l_262), &l_262, &g_153, g_9) <= l_27) , &g_88), (*l_306), l_310) >= (**l_306)))
            { /* block id: 141 */
                int32_t l_320 = 6L;
                union U0 l_352 = {1L};
                int32_t *l_353 = &l_320;
                for (l_55 = (-4); (l_55 < (-6)); l_55 -= 7)
                { /* block id: 144 */
                    union U0 l_316 = {1L};
                    if ((**l_306))
                    { /* block id: 145 */
                        union U0 *****l_319 = &l_318;
                        l_313 = (void*)0;
                        /* statement id: 146 */
                        assert (l_313 == 0);
                        g_37 = func_105((*g_152), &g_153, ((void*)0 == l_314), ((l_316 , (l_27 <= ((*g_37) & (**l_306)))) , l_317), &g_88);
                        /* statement id: 147 */
                        assert (g_37 == &g_88);
                        (*l_319) = l_318;
                    }
                    else
                    { /* block id: 149 */
                        const uint32_t l_329 = 0xE255A649L;
                        (*g_152) = ((-1L) & (l_320 >= ((uint32_t)g_86 + (uint32_t)(((int32_t)(l_316.f0 < g_231) + (int32_t)(g_9 | (~(l_316 , (((int32_t)(((g_328 != (void*)0) & (*g_152)) ^ g_9) + (int32_t)4294967292UL) && 8L))))) != l_329))));
                        if ((*g_152))
                            break;
                        (*l_317) = (((int16_t)(**l_306) >> (int16_t)13) != ((int16_t)g_9 + (int16_t)((uint16_t)(((0x0866L < (((int16_t)((void*)0 != g_338) % (int16_t)((int16_t)(l_343 == ((4294967289UL && ((void*)0 == l_344)) | 4294967290UL)) >> (int16_t)l_345)) >= (***g_339))) < 0x66000788L) > g_285) % (uint16_t)l_320)));
                        (***g_338) = (***g_338);
                    }
                    if (((0x57FD0B38L || __builtin_popcount(l_345)) || g_285))
                    { /* block id: 155 */
                        (**g_340) = (***g_339);
                        (*g_152) = (g_301 , (**g_340));
                        (*g_37) = (g_285 > (((l_320 && g_301) == func_32(func_105((!(((func_32(l_317, (*g_340), func_28(l_347, (((uint16_t)l_320 + (uint16_t)(((uint32_t)((*l_317) , l_345) + (uint32_t)0xCB5D35E8L) , (**l_306))) != g_153), l_352), g_301) & g_285) & 0L) , l_352.f0)), (*l_306), (*g_37), (*g_340), (*g_340)), &l_320, l_353, l_354)) | 0x486CE315L));
                        (***g_338) = (***g_338);
                    }
                    else
                    { /* block id: 160 */
                        uint16_t l_355 = 65535UL;
                        (*l_306) = (*g_340);
                        if (l_355)
                            break;
                    }
                }
                /* facts after for loop */
                assert (g_37 == &g_153 || g_37 == &g_88);
                assert (l_313 == &l_304 || l_313 == 0);
                (*l_353) = ((__builtin_popcountl(g_88) & ((int32_t)((+g_153) <= ((uint16_t)g_86 - (uint16_t)g_88)) + (int32_t)(*l_317))) , (*l_353));
            }
            else
            { /* block id: 166 */
                (*l_306) = &l_262;
                /* statement id: 167 */
                assert (g_37 == &l_262);
                return (*g_152);
                /* statement id: 168 */
                //assert (g_37 == dangling);
            }
            /* facts after branching */
            assert (g_37 == &g_153 || g_37 == &g_88);
            assert (l_313 == &l_304 || l_313 == 0);
            (*g_152) = 0x30416393L;
        }
        /* facts after branching */
        assert (g_37 == &g_153 || g_37 == &g_88 || g_37 == 0);
        assert (g_152 == &g_153 || g_152 == &g_88);
        (**g_339) = l_317;
        /* statement id: 172 */
        assert (g_37 == &g_88);
        (*g_37) = l_345;
        for (g_161.f1 = (-5); (g_161.f1 < 30); g_161.f1 += 3)
        { /* block id: 176 */
            if ((**g_340))
                break;
        }
        /* facts after for loop */
            }
    else
    { /* block id: 179 */
        (**g_339) = g_363;
        /* statement id: 180 */
        assert (g_37 == &g_153);
        (***g_339) = l_364;
    }
    /* facts after branching */
    assert (g_37 == &g_153 || g_37 == &g_88);
    assert (g_152 == &g_153 || g_152 == &g_88);
        (*g_339) = l_365;
    if ((g_301 | (((&l_365 != (((uint32_t)((((g_161.f1 || (((int32_t)((uint16_t)g_88 >> (uint16_t)8) % (int32_t)__builtin_popcount((**l_365))) > (((l_374 != &l_315) || (g_161.f0 , (**l_365))) | 1L))) ^ 0x4421L) == (-1L)) , g_9) + (uint32_t)(**l_365)) , (void*)0)) >= g_86) != 0UL)))
    { /* block id: 184 */
        union U0 *l_385 = (void*)0;
        int32_t l_386 = (-6L);
        (**g_340) = ((uint16_t)__builtin_clzl(((uint32_t)(((uint32_t)g_153 - (uint32_t)(__builtin_parityl(g_9) & ((int16_t)((uint16_t)g_86 << (uint16_t)((void*)0 == l_385)) << (int16_t)15))) ^ (func_71(l_386) != (-(uint32_t)(l_386 , (**l_365))))) % (uint32_t)0xF5CB25AFL)) >> (uint16_t)5);
        if ((((+(+(((int32_t)0x94F28CE0L % (int32_t)func_71((((*g_340) == (***g_338)) > 0xBD36L))) ^ ((((l_392 <= g_301) , (**l_365)) < g_285) && l_386)))) != 65535UL) != g_231))
        { /* block id: 186 */
            const int16_t l_403 = 0L;
            union U0 *l_436 = &g_161;
            (***g_338) = (((func_71((((((void*)0 == (*g_338)) ^ 0L) >= (0xAF62C8C5L < ((int32_t)(l_386 & ((int16_t)((uint16_t)(((int16_t)((((((int32_t)func_32(func_28(((l_386 , 0x3237L) | (g_88 < 1L)), g_285, g_161), (**g_339), (**g_339), l_386) + (int32_t)l_403) != 0x04B4L) >= l_386) , 0x642D2665L) < (-5L)) % (int16_t)l_386) == l_386) << (uint16_t)4) << (int16_t)4)) + (int32_t)l_403))) == 0x4AB5L)) < (**l_365)) < (-1L)) , (void*)0);
            /* statement id: 187 */
            assert (g_37 == 0);
            if ((g_404 != (void*)0))
            { /* block id: 188 */
                int32_t l_414 = 0x9DE6CA52L;
                for (l_27 = 0; (l_27 >= 14); l_27 += 1)
                { /* block id: 191 */
                    const int32_t *l_411 = &g_161.f0;
                    const int32_t **l_412 = &l_411;
                    const uint32_t l_413 = 2UL;
                    (*g_152) = (g_9 != ((int16_t)((&g_328 != (void*)0) > ((g_410 != (*g_152)) | ((void*)0 != &g_405))) >> (int16_t)(g_161.f0 ^ l_386)));
                    (*l_412) = l_411;
                    (*g_152) = func_71(((l_413 >= l_414) , l_403));
                    if (l_386)
                        continue;
                }
                for (g_153 = 0; (g_153 < (-26)); g_153 -= 1)
                { /* block id: 199 */
                    (***g_338) = (***g_338);
                }
                (*g_404) = (*l_374);
            }
            else
            { /* block id: 203 */
                uint16_t l_435 = 0x8FABL;
                (*g_152) = ((uint32_t)g_88 + (uint32_t)((((uint16_t)((uint32_t)((int16_t)l_403 >> (int16_t)5) + (uint32_t)g_9) - (uint16_t)((int32_t)(*g_152) + (int32_t)((l_403 , (((int32_t)((void*)0 == &l_365) + (int32_t)((uint16_t)(((int16_t)((int16_t)l_262 - (int16_t)((**g_338) == (*g_339))) + (int16_t)7UL) ^ l_386) - (uint16_t)l_386)) != g_231)) , g_285))) >= l_386) , l_435));
                (*g_404) = (*g_404);
            }
            (*g_152) = 0x4B5D2482L;
            (*g_404) = l_436;
        }
        else
        { /* block id: 209 */
            (****g_338) = l_386;
            (***g_338) = func_28(g_86, l_386, (**l_314));
        }
        /* facts after branching */
        assert (g_37 == &g_153 || g_37 == &g_88 || g_37 == 0);
        (*g_340) = &l_386;
        /* statement id: 213 */
        assert (g_37 == &l_386);
        (**g_339) = (*g_340);
    }
    else
    { /* block id: 215 */
        (**l_365) = (*g_363);
        (****g_338) = 0x740C8EA8L;
        (*g_363) = 0xB4E194CDL;
        (*l_365) = (*g_340);
    }
    /* facts after branching */
    //assert (g_37 == &g_153 || g_37 == &g_88 || g_37 == dangling);
    return l_392;
}


/* ------------------------------------------ */
/* 
 * reads : g_86 g_153 g_161.f0 g_88 g_285
 * writes:
 */
inline static int32_t * func_28(const uint32_t  p_29, uint32_t  p_30, union U0  p_31)
{ /* block id: 125 */
    const int32_t *l_265 = &g_153;
    const int32_t **l_264 = &l_265;
    const int32_t ***l_267 = &l_264;
    const int32_t ****l_266 = &l_267;
    union U0 *l_290 = (void*)0;
    int32_t *l_291 = &g_88;
    (*l_264) = &g_86;
    /* statement id: 126 */
    assert (l_265 == &g_86);
    (*l_266) = &l_264;
    for (p_30 = 5; (p_30 != 32); p_30 += 1)
    { /* block id: 130 */
        (***l_266) = (((((***l_267) , (((uint16_t)(((!((uint16_t)p_29 % (uint16_t)g_153)) <= (**l_264)) | ((uint16_t)p_31.f0 << (uint16_t)15)) % (uint16_t)((int16_t)((int16_t)(g_161.f0 >= ((uint16_t)g_88 << (uint16_t)(((int16_t)g_285 % (int16_t)((((uint16_t)(((uint16_t)(p_31.f0 || p_30) << (uint16_t)7) || (**l_264)) % (uint16_t)0x6D0BL) > 0x629920BDL) || 0L)) ^ 4294967292UL))) + (int16_t)5L) >> (int16_t)12)) , (***l_267))) && g_88) , p_31.f1) , (void*)0);
        /* statement id: 131 */
        assert (l_265 == 0);
        return &g_153;
        /* statement id: 132 */
        //assert (func_28_rv == &g_153);
    }
    l_290 = &g_161;
    /* statement id: 134 */
    assert (l_290 == &g_161);
    return l_291;
    /* statement id: 135 */
    //assert (func_28_rv == &g_88);
}


/* ------------------------------------------ */
/* 
 * reads : g_231
 * writes:
 */
inline static uint16_t  func_32(int32_t * p_33, int32_t * p_34, int32_t * p_35, uint32_t  p_36)
{ /* block id: 122 */
    union U0 *l_260 = &g_161;
    union U0 **l_261 = &l_260;
    (*l_261) = l_260;
    return g_231;
}


/* ------------------------------------------ */
/* 
 * reads : g_88 g_86 g_9 g_161 g_161.f1 g_152 g_153 g_231 g_161.f0
 * writes: g_88 g_9 g_153 g_152
 */
inline static int32_t * func_38(int32_t  p_39, int32_t  p_40, const int16_t  p_41, int32_t * p_42)
{ /* block id: 46 */
    int32_t *l_221 = &g_88;
    uint16_t l_222 = 0xC335L;
    int32_t l_235 = 5L;
    const uint16_t l_236 = 9UL;
    int32_t l_245 = 0xCDD2221DL;
    union U0 l_250 = {1L};
    if ((*p_42))
    { /* block id: 47 */
        uint16_t l_91 = 0xB9CAL;
        int32_t **l_234 = &g_152;
        g_88 = l_91;
        (*l_234) = func_92(func_96(p_40), (((void*)0 != l_221) ^ (g_86 < l_222)), &g_88);
        /* statement id: 114 */
        assert (g_152 == &g_88);
    }
    else
    { /* block id: 115 */
        int32_t *l_237 = (void*)0;
        int32_t *l_238 = &g_153;
        int32_t **l_239 = &l_237;
        uint16_t l_244 = 0x78B1L;
        union U0 l_253 = {0x3A824C42L};
        (*l_239) = func_105((((((((((1UL >= g_88) , func_47(l_237, &g_153, l_237, g_88)) != p_41) , (-10L)) , 0UL) , g_88) ^ g_86) == (*g_152)) , (*l_221)), &g_153, (*l_221), l_238, l_237);
        /* statement id: 116 */
        assert (l_237 == &g_88);
        (*p_42) = ((int16_t)((uint32_t)l_244 + (uint32_t)(*l_237)) << (int16_t)(l_245 == (g_9 ^ (__builtin_bswap32((*l_221)) , ((uint16_t)p_41 << (uint16_t)((g_9 == ((uint16_t)(l_250 , 0xD754L) % (uint16_t)g_153)) , (**l_239)))))));
        g_152 = (*l_239);
        /* statement id: 118 */
        assert (g_152 == &g_88);
        (*l_238) = func_47(&p_39, &g_88, &l_235, g_9);
    }
    /* facts after branching */
    assert (g_152 == &g_88);
    return &g_153;
    /* statement id: 121 */
    //assert (func_38_rv == &g_153);
}


/* ------------------------------------------ */
/* 
 * reads : g_86
 * writes:
 */
static int16_t  func_47(int32_t * p_48, const int32_t * p_49, int32_t * p_50, uint16_t  p_51)
{ /* block id: 43 */
    uint32_t l_89 = 0x55298A7BL;
    int32_t l_90 = (-1L);
    l_90 = (0UL == l_89);
    return g_86;
}


/* ------------------------------------------ */
/* 
 * reads : g_9
 * writes:
 */
inline static int32_t  func_71(int32_t  p_72)
{ /* block id: 39 */
    uint16_t l_75 = 65528UL;
    int32_t l_81 = (-1L);
    p_72 = (l_75 ^ ((int16_t)(l_75 , g_9) >> (int16_t)15));
    l_81 = ((uint16_t)(!g_9) << (uint16_t)9);
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads : g_153 g_152 g_88 g_9 g_86 g_231 g_161.f0
 * writes: g_153 g_88 g_152
 */
static int32_t * func_92(int32_t * p_93, uint32_t  p_94, int32_t * p_95)
{ /* block id: 105 */
    int32_t l_226 = 0x2702D28AL;
    union U0 l_229 = {0xC477D8F5L};
    for (g_153 = (-11); (g_153 != 8); g_153 += 1)
    { /* block id: 108 */
        uint16_t l_225 = 0xE382L;
        int32_t l_232 = 0x9DFC485CL;
        int32_t **l_233 = &g_152;
        l_232 = (p_94 <= ((l_225 , (((l_226 > (func_71((*g_152)) == ((uint32_t)(l_229 , ((*p_95) == (((((~(*g_152)) == ((g_153 || g_86) , p_94)) , g_231) > g_153) == l_225))) + (uint32_t)4UL))) || g_161.f0) != l_225)) ^ p_94));
        (*p_93) = (*p_95);
        (*l_233) = &g_88;
        /* statement id: 111 */
        assert (g_152 == &g_88);
    }
    /* facts after for loop */
    assert (g_152 == &g_88 || g_152 == &g_153);
    return p_93;
    /* statement id: 113 */
    //assert (func_92_rv == &g_88);
}


/* ------------------------------------------ */
/* 
 * reads : g_88 g_86 g_9 g_161 g_161.f1 g_152 g_153
 * writes: g_9 g_153
 */
inline static int32_t * func_96(uint32_t  p_97)
{ /* block id: 49 */
    const int32_t *l_111 = &g_88;
    int32_t *l_112 = (void*)0;
    union U0 l_116 = {0x8E54706CL};
    (*g_152) = (((((((g_88 && g_88) < ((((uint16_t)(p_97 == ((func_100(func_105((l_111 == (p_97 , l_111)), l_112, ((int16_t)p_97 << (int16_t)g_86), l_112, l_112), g_9, &g_88, l_116) , 3UL) ^ g_161.f1)) << (uint16_t)p_97) , l_116) , (*l_111))) == (*g_152)) , (*l_111)) <= 3UL) & g_153) >= p_97);
    return &g_88;
    /* statement id: 104 */
    //assert (func_96_rv == &g_88);
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_161
 * writes: g_9
 */
static union U0  func_100(int32_t * p_101, uint16_t  p_102, int32_t * p_103, union U0  p_104)
{ /* block id: 52 */
    int32_t *l_121 = &g_88;
    int32_t *l_133 = &g_88;
    uint32_t l_150 = 0x700432F2L;
    uint16_t l_219 = 0x5193L;
    for (g_9 = (-16); (g_9 > 23); g_9 += 6)
    { /* block id: 55 */
        p_101 = &g_88;
    }
    for (g_9 = 0; (g_9 < (-26)); g_9 -= 5)
    { /* block id: 60 */
        int32_t **l_122 = &l_121;
        int16_t l_134 = (-1L);
        int32_t l_135 = 0x69A62DACL;
        int32_t l_182 = 0x4DF11EF4L;
        int32_t *l_220 = &g_153;
        (*l_122) = l_121;
    }
    return g_161;
    /* statement id: 102 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_105(const int32_t  p_106, int32_t * p_107, const int32_t  p_108, int32_t * p_109, int32_t * p_110)
{ /* block id: 50 */
    int32_t *l_115 = &g_88;
    return l_115;
    /* statement id: 51 */
    //assert (func_105_rv == &g_88);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_9, "g_9", print_hash_value);
    transparent_crc(g_86, "g_86", print_hash_value);
    transparent_crc(g_88, "g_88", print_hash_value);
    transparent_crc(g_153, "g_153", print_hash_value);
    transparent_crc(g_161.f0, "g_161.f0", print_hash_value);
    transparent_crc(g_161.f1, "g_161.f1", print_hash_value);
    transparent_crc(g_231, "g_231", print_hash_value);
    transparent_crc(g_285, "g_285", print_hash_value);
    transparent_crc(g_301, "g_301", print_hash_value);
    transparent_crc(g_410, "g_410", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 102
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 52
breakdown:
   depth: 1, occurrence: 120
   depth: 2, occurrence: 12
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 1
   depth: 37, occurrence: 1
   depth: 52, occurrence: 1

XXX total number of pointers: 70

XXX times a variable address is taken: 107
XXX times a pointer is dereferenced on RHS: 129
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 34
   depth: 3, occurrence: 9
XXX times a pointer is dereferenced on LHS: 61
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 8
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 251

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 186
   level: 2, occurrence: 61
   level: 3, occurrence: 29
   level: 4, occurrence: 4
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 36
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 15.7
XXX average alias set size: 1.39

XXX times a non-volatile is read: 668
XXX times a non-volatile is write: 175
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 95
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 27
   depth: 2, occurrence: 13
   depth: 3, occurrence: 9
   depth: 4, occurrence: 7
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
********************* end of statistics **********************/

