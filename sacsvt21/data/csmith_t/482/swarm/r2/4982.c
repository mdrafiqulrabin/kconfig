/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3355528438
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 9;
   int32_t  f1;
   int32_t  f2;
   const int32_t  f3;
   uint32_t  f4;
   float  f5;
   unsigned f6 : 29;
   int32_t  f7;
   uint32_t  f8;
   uint32_t  f9;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static struct S0 * func_2(struct S0 * p_3, float  p_4, struct S0 * p_5, int32_t  p_6);
static struct S0 * func_9(struct S0  p_10, float  p_11, struct S0 * p_12);
static struct S0  func_13(float  p_14, int16_t  p_15);
static int32_t  func_25(const int32_t * p_26, uint16_t  p_27, float  p_28);
static int32_t * func_29(int32_t * p_30, int32_t  p_31, const struct S0 * p_32);
static int32_t * func_33(int32_t * p_34, struct S0 * p_35, int32_t * p_36, uint16_t  p_37);
static int32_t * func_38(int32_t  p_39, const int16_t  p_40);
static int32_t  func_41(float  p_42, const int32_t  p_43, struct S0 * p_44);
static struct S0 * func_48(struct S0 * p_49, uint16_t  p_50, uint32_t  p_51, uint16_t  p_52, struct S0  p_53);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    struct S0 l_8 = {8,1,6,0x58A012E1,8U,-0x5.1p-1,10681,7,7U,1U};
    struct S0 *l_7 = &l_8;
    struct S0 **l_273 = &l_7;
    int32_t *l_274 = &l_8.f7;
    int32_t **l_275 = &l_274;
    float l_276 = 0x4.DC0E59p-46;
    (*l_273) = func_2(l_7, l_8.f2, func_9(func_13(l_8.f9, ((l_8.f0 < (1U == ((void*)0 == &l_8))) & (-10))), l_8.f4, &l_8), l_8.f4);
    (*l_275) = l_274;
    (*l_275) = func_38(((*l_274) && (*l_274)), (*l_274));
    for (l_8.f9 = 9; (l_8.f9 != 50); l_8.f9++)
    { /* block id: 113 */
        struct S0 **l_279 = &l_7;
        const struct S0 *l_282 = &l_8;
        const struct S0 **l_281 = &l_282;
        const struct S0 ***l_280 = &l_281;
        int32_t l_283 = 0x7334A1C8;
        (*l_280) = l_279;
        if (l_283)
            break;
    }
    return l_8.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_2(struct S0 * p_3, float  p_4, struct S0 * p_5, int32_t  p_6)
{ /* block id: 103 */
    uint16_t l_265 = 65526U;
    uint16_t *l_264 = &l_265;
    uint16_t **l_263 = &l_264;
    uint16_t ***l_262 = &l_263;
    int32_t l_267 = 0x5B980044;
    int32_t *l_266 = &l_267;
    int32_t **l_268 = (void*)0;
    int32_t **l_269 = &l_266;
    const int32_t *l_271 = &l_267;
    const int32_t **l_270 = &l_271;
    struct S0 *l_272 = (void*)0;
    (*l_262) = (void*)0;
    (*l_270) = ((*l_269) = l_266);
    return l_272;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_9(struct S0  p_10, float  p_11, struct S0 * p_12)
{ /* block id: 4 */
    uint16_t l_47 = 0x69E5;
    struct S0 l_55 = {-10,0xFE1A273D,-10,-2,6U,0x0.84C83Bp+91,11112,-1,4294967286U,4294967290U};
    struct S0 *l_54 = &l_55;
    int32_t *l_199 = &l_55.f7;
    int32_t l_229 = (-4);
    struct S0 *l_259 = &l_55;
    struct S0 *l_260 = &l_55;
    struct S0 *l_261 = (void*)0;
    for (p_10.f8 = (-18); (p_10.f8 > 44); p_10.f8 += 1)
    { /* block id: 7 */
        int16_t l_22 = 1;
        int32_t l_24 = 0;
        int32_t *l_23 = &l_24;
        struct S0 l_56 = {11,0xAE7BE98B,0,0,3U,0x1.9p-1,3520,0,0x6C484D54,0xCFB0F81A};
        int32_t **l_233 = &l_23;
        int32_t *l_257 = (void*)0;
        int32_t *l_258 = &l_56.f1;
        (*l_23) = l_22;
        (*l_258) = ((((*l_199) = func_25(((*l_233) = func_29(func_33(func_38((*l_23), (65535U && (func_41((*l_23), ((int16_t)((p_10.f1 >= l_47) ^ 1) * (int16_t)l_47), func_48(l_54, p_10.f2, p_10.f8, p_10.f6, l_56)) != 0x54CE7603))), &l_55, l_199, (*l_23)), l_229, &l_56)), p_10.f8, p_10.f4)) | p_10.f0) <= p_10.f7);
    }
    return l_261;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_13(float  p_14, int16_t  p_15)
{ /* block id: 1 */
    uint32_t l_16 = 0x9EC6EA3D;
    int32_t l_18 = (-6);
    int32_t *l_17 = &l_18;
    struct S0 l_19 = {-8,-1,0x1589AFCA,0x629342BB,0xE5DE2CAE,0xE.A4A2C6p+75,20534,0xF947F9F4,0xADF890BA,0xFC0266D9};
    (*l_17) = l_16;
    return l_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_25(const int32_t * p_26, uint16_t  p_27, float  p_28)
{ /* block id: 87 */
    int32_t l_235 = (-1);
    int32_t *l_234 = &l_235;
    uint32_t l_243 = 0U;
    uint32_t *l_242 = &l_243;
    uint32_t l_245 = 4294967295U;
    uint32_t *l_244 = &l_245;
    uint16_t *l_247 = (void*)0;
    uint16_t **l_246 = &l_247;
    const uint16_t *l_250 = (void*)0;
    const uint16_t **l_249 = &l_250;
    const uint16_t ***l_248 = &l_249;
    int32_t l_256 = 0x0238BE1A;
    (*l_234) = 1;
    (*l_234) = ((uint32_t)p_27 - (uint32_t)((uint16_t)(((*l_244) = ((*l_242) = ((uint16_t)(*l_234) * (uint16_t)p_27))) < (l_246 != ((*l_248) = &l_247))) + (uint16_t)(~(p_27 > p_27))));
    for (l_245 = 22; (l_245 <= 13); l_245 -= 9)
    { /* block id: 95 */
        float l_255 = 0x0.D2993Cp+76;
        float *l_254 = &l_255;
        (*l_254) = (*l_234);
    }
    return l_256;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_29(int32_t * p_30, int32_t  p_31, const struct S0 * p_32)
{ /* block id: 83 */
    int32_t l_232 = 0;
    int32_t *l_231 = &l_232;
    int32_t **l_230 = &l_231;
    (*l_230) = p_30;
    return p_30;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_33(int32_t * p_34, struct S0 * p_35, int32_t * p_36, uint16_t  p_37)
{ /* block id: 70 */
    int32_t *****l_200 = (void*)0;
    float *l_201 = (void*)0;
    int32_t l_202 = 0x2BBFE024;
    uint16_t *l_212 = (void*)0;
    uint16_t **l_211 = &l_212;
    uint16_t **l_216 = &l_212;
    const uint32_t l_221 = 1U;
    uint16_t *l_225 = (void*)0;
    uint16_t l_227 = 0x8413;
    uint16_t *l_226 = &l_227;
    int32_t *l_228 = (void*)0;
    l_200 = l_200;
    l_202 = p_37;
    for (p_37 = 14; (p_37 != 48); p_37++)
    { /* block id: 75 */
        uint16_t l_209 = 0x9626;
        uint16_t *l_208 = &l_209;
        uint16_t **l_207 = &l_208;
        uint16_t ***l_210 = &l_207;
        uint32_t l_218 = 0x7B1E6F47;
        uint32_t *l_217 = &l_218;
        int32_t l_222 = 0x5C4BC6AF;
        l_222 = (((*p_36) > ((uint16_t)(((*l_210) = l_207) != l_211) << (uint16_t)(-(int16_t)(((uint16_t)p_37 << (uint16_t)(((*l_217) = ((void*)0 != l_216)) > ((uint16_t)(&p_37 != (*l_211)) >> (uint16_t)3))) <= p_37)))) < l_221);
    }
    (*p_36) = ((uint16_t)0U * (uint16_t)((*l_226) = ((void*)0 == l_201)));
    return l_228;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_38(int32_t  p_39, const int16_t  p_40)
{ /* block id: 66 */
    int32_t l_192 = 0;
    const int32_t *l_191 = &l_192;
    int32_t **l_193 = (void*)0;
    int32_t *l_195 = &l_192;
    int32_t **l_194 = &l_195;
    int32_t *l_196 = &l_192;
    int32_t *l_197 = &l_192;
    int32_t *l_198 = (void*)0;
    (*l_194) = l_191;
    (*l_194) = &p_39;
    return l_198;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_41(float  p_42, const int32_t  p_43, struct S0 * p_44)
{ /* block id: 14 */
    int32_t l_87 = 1;
    int32_t *l_86 = &l_87;
    int32_t **l_85 = &l_86;
    const int32_t l_91 = 0x2DE0ECAC;
    const int32_t *l_90 = &l_91;
    const int32_t **l_89 = &l_90;
    const int32_t ***l_88 = &l_89;
    int16_t *l_100 = (void*)0;
    int16_t l_102 = (-1);
    int16_t *l_101 = &l_102;
    float l_120 = 0x0.Ap+1;
    struct S0 l_188 = {9,7,-1,-1,4294967295U,0x9.29225Cp+58,1582,1,4294967287U,8U};
    struct S0 *l_187 = &l_188;
    if (((int16_t)((uint32_t)0xDF1EF1A9 - (uint32_t)((((l_85 == ((*l_88) = &l_86)) != ((uint16_t)0x4C26 + (uint16_t)((uint16_t)(((int16_t)((int16_t)((*l_101) = ((void*)0 == &l_85)) >> (int16_t)((int32_t)((int16_t)((uint16_t)65534U >> (uint16_t)((uint16_t)(p_43 || ((uint16_t)(**l_85) >> (uint16_t)8)) << (uint16_t)11)) >> (int16_t)(**l_85)) + (int32_t)p_43)) % (int16_t)(**l_85)) <= p_43) << (uint16_t)(*l_90)))) && p_43) ^ 0xC59E)) >> (int16_t)(*l_86)))
    { /* block id: 17 */
        int32_t *l_113 = (void*)0;
        (*l_89) = l_113;
        (**l_88) = (**l_88);
    }
    else
    { /* block id: 20 */
        int32_t ***l_131 = &l_85;
        uint16_t l_140 = 0x36A2;
        uint16_t *l_139 = &l_140;
        int32_t l_141 = 0x89ECE453;
        float *l_142 = &l_120;
        (*l_89) = (**l_88);
        for (l_102 = 0; (l_102 <= (-7)); l_102--)
        { /* block id: 24 */
            float l_121 = 0xC.E2BE68p+62;
            int32_t l_124 = 0xA068B865;
            uint16_t l_126 = 8U;
            uint16_t *l_125 = &l_126;
            int32_t ***l_130 = &l_85;
            int32_t ****l_129 = &l_130;
            int32_t ****l_132 = (void*)0;
            int32_t ****l_133 = &l_131;
            uint16_t **l_134 = (void*)0;
            uint16_t **l_135 = (void*)0;
            uint16_t l_138 = 3U;
            uint16_t *l_137 = &l_138;
            uint16_t **l_136 = &l_137;
            l_141 = (((((int16_t)(((int32_t)(**l_89) - (int32_t)p_43) & ((*l_125) = ((uint16_t)l_124 * (uint16_t)l_124))) >> (int16_t)(((uint16_t)0xE0D9 >> (uint16_t)(((*l_129) = &l_85) != ((*l_133) = l_131))) < (((1U < (((*l_136) = l_101) == l_139)) <= p_43) ^ (***l_88)))) && (***l_88)) <= (**l_89)) >= p_43);
        }
        (*l_142) = p_42;
        for (l_102 = 0; (l_102 == 0); l_102 += 9)
        { /* block id: 34 */
            int32_t *l_147 = &l_87;
            int32_t l_180 = 0;
            for (l_141 = 0; (l_141 <= 2); l_141++)
            { /* block id: 37 */
                (**l_131) = l_147;
                (*l_147) = 0;
            }
            if ((**l_85))
                continue;
            for (l_87 = 21; (l_87 <= (-13)); l_87--)
            { /* block id: 44 */
                int32_t l_184 = 0x38B24C03;
                struct S0 l_186 = {-3,0x564559AE,5,1,4294967295U,0x7.9p+1,4266,0x9FF31343,1U,1U};
                const struct S0 *l_185 = &l_186;
                float *l_189 = &l_186.f5;
                float *l_190 = &l_188.f5;
                for (l_140 = 0; (l_140 <= 16); l_140 += 1)
                { /* block id: 47 */
                    uint32_t l_157 = 8U;
                    int16_t l_159 = (-1);
                    int16_t *l_158 = &l_159;
                    int16_t l_161 = 0x88DE;
                    int16_t *l_160 = &l_161;
                    uint16_t l_163 = 0x3C77;
                    uint16_t *l_162 = &l_163;
                    int16_t l_171 = (-1);
                    int16_t *l_170 = &l_171;
                    int16_t *l_172 = (void*)0;
                    int16_t l_174 = (-1);
                    int16_t *l_173 = &l_174;
                    int16_t l_176 = 0x99D2;
                    int16_t *l_175 = &l_176;
                    uint16_t *l_177 = (void*)0;
                    uint16_t l_179 = 3U;
                    uint16_t *l_178 = &l_179;
                    l_180 = (8U & ((*l_178) = ((uint16_t)((uint16_t)(~((*l_158) = l_157)) * (uint16_t)((*l_160) = (**l_85))) * (uint16_t)(((*l_162) = 0x1031) != ((*l_175) = ((*l_173) = ((uint16_t)(0x2924 == ((*l_147) >= (((((*l_147) < ((int32_t)p_43 % (int32_t)((int32_t)(((*l_170) = (p_43 <= 0xAC039BA7)) >= p_43) - (int32_t)p_43))) || 0x95C8) == p_43) > p_43))) + (uint16_t)0)))))));
                }
                (*l_190) = (p_43 != ((***l_131) >= (0x4.194B45p+2 == ((p_43 != 0x2.F6D29Bp+11) <= ((*l_189) = ((p_43 == (!(((*l_142) = ((float)l_184 - (float)(***l_131))) == ((l_185 = l_185) == l_187)))) != 0x0.C4115Ep-78))))));
                return p_43;
            }
        }
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_48(struct S0 * p_49, uint16_t  p_50, uint32_t  p_51, uint16_t  p_52, struct S0  p_53)
{ /* block id: 9 */
    const struct S0 *l_65 = (void*)0;
    uint32_t l_68 = 0x0CC90FA2;
    int32_t l_70 = 0xF0D7C7E6;
    int32_t *l_69 = &l_70;
    int32_t **l_71 = &l_69;
    struct S0 l_73 = {-3,0x03EC6B4E,0x2DD2E1BD,0xF38C1355,0x561D8FC8,-0x1.Dp-1,1585,0,0x4D3BE1F6,0x8D19747A};
    struct S0 *l_72 = &l_73;
    struct S0 *l_74 = &l_73;
    struct S0 *l_75 = &l_73;
    struct S0 *l_76 = &l_73;
    struct S0 *l_77 = &l_73;
    struct S0 *l_78 = &l_73;
    struct S0 *l_79 = &l_73;
    struct S0 *l_80 = (void*)0;
    (*l_69) = (p_53.f4 > ((int16_t)1 - (int16_t)((int16_t)(0x7A21E2C2 || p_53.f3) << (int16_t)(((uint32_t)(p_53.f9 >= ((uint16_t)(l_65 != &p_53) << (uint16_t)((uint32_t)0xBC0716CF - (uint32_t)l_68))) - (uint32_t)l_68) >= l_68))));
    (*l_71) = &l_70;
    (*l_71) = (*l_71);
    return l_80;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 54
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 17
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 19
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 4

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 10
   depth: 4, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 119

XXX times a variable address is taken: 92
XXX times a pointer is dereferenced on RHS: 28
breakdown:
   depth: 1, occurrence: 15
   depth: 2, occurrence: 9
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 50
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 216

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 93
   level: 2, occurrence: 16
   level: 3, occurrence: 6
XXX number of pointers point to pointers: 34
XXX number of pointers point to scalars: 57
XXX number of pointers point to structs: 28
XXX percent of pointers has null in alias set: 32.8
XXX average alias set size: 1.04

XXX times a non-volatile is read: 220
XXX times a non-volatile is write: 117
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 54
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 12
   depth: 2, occurrence: 4
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 11.7
XXX percentage an existing variable is used: 88.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

