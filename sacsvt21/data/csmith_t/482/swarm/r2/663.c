/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      972120194
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static float  func_2(int32_t  p_3, const float  p_4);
static uint16_t  func_16(const uint32_t  p_17);
static uint32_t  func_24(int32_t * p_25);
static const int16_t  func_40(int32_t * p_41, int32_t ** p_42);
static int32_t * func_46(uint16_t  p_47, int32_t ** p_48, const int32_t * p_49, const int32_t ** p_50, int16_t  p_51);
static int32_t ** func_53(int32_t * p_54, int32_t * p_55, int32_t  p_56, const int32_t  p_57);
static int32_t * func_58(uint32_t  p_59, int32_t * const * p_60);
static uint32_t  func_73(int32_t  p_74, int16_t  p_75, int32_t * p_76, int32_t * p_77);
static int32_t ** func_82(float  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_5 = 0UL;
    float l_320 = 0x8.4p+1;
    float *l_319 = &l_320;
    int32_t *l_322 = (void*)0;
    int32_t **l_321 = &l_322;
    uint16_t l_323 = 2UL;
    (*l_319) = func_2(l_5, l_5);
    l_323 ^= (((void*)0 == l_321) , l_5);
    return l_323;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_2(int32_t  p_3, const float  p_4)
{ /* block id: 1 */
    uint16_t l_8 = 65532UL;
    int32_t l_265 = 0xE84316CFL;
    int32_t *l_264 = &l_265;
    int32_t **l_263 = &l_264;
    int32_t ***l_262 = &l_263;
    int32_t ****l_261 = &l_262;
    int32_t l_277 = 1L;
    int32_t **l_313 = &l_264;
    for (p_3 = 0; (p_3 < (-13)); p_3 -= 3)
    { /* block id: 4 */
        int32_t l_27 = 0L;
        int32_t *l_26 = &l_27;
        int32_t ***l_273 = &l_263;
        uint32_t l_306 = 4294967293UL;
    }
    return p_3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_16(const uint32_t  p_17)
{ /* block id: 5 */
    int32_t l_19 = (-1L);
    int32_t *l_18 = &l_19;
    const int32_t *l_21 = &l_19;
    const int32_t **l_20 = &l_21;
    (*l_20) = l_18;
    return p_17;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_24(int32_t * p_25)
{ /* block id: 8 */
    int32_t l_28 = 0x4A5EA964L;
    int16_t l_33 = 0x364DL;
    int32_t *l_185 = &l_28;
    int32_t **l_184 = &l_185;
    uint32_t l_201 = 0xF1CC891DL;
    int32_t ***l_213 = &l_184;
    int32_t **l_214 = &l_185;
    uint32_t l_239 = 18446744073709551612UL;
    int32_t l_258 = 0L;
    for (l_28 = 0; (l_28 < (-1)); l_28 -= 2)
    { /* block id: 11 */
        const uint32_t l_34 = 0xEE1D4595L;
        int32_t *l_39 = (void*)0;
        int16_t l_162 = 5L;
        int32_t ***l_195 = &l_184;
        int32_t l_208 = (-1L);
        int32_t *l_207 = &l_208;
    }
    if ((((((int32_t)((int32_t)(*p_25) + (int32_t)((((*l_184) != p_25) || (*l_185)) | ((((*p_25) , l_213) != ((((((*l_185) , &p_25) != l_214) != 0xB.803394p+89) , 1L) , &l_184)) , 0xA01408C7L))) - (int32_t)(**l_184)) , (**l_214)) , p_25) == (void*)0))
    { /* block id: 61 */
        int32_t ***l_221 = &l_184;
        int16_t l_236 = 1L;
        int32_t l_238 = 0L;
        int32_t *l_237 = &l_238;
        (*l_237) &= ((***l_213) & (((uint16_t)((uint32_t)(((-(int16_t)(-5L)) == (+(((((l_221 != &l_214) <= (((***l_221) == (((int16_t)((uint16_t)((**l_184) , (((**l_214) == ((int32_t)((int16_t)((uint16_t)(((uint16_t)((int32_t)((0x6FD15697L & (**l_214)) != (*p_25)) / (int32_t)(***l_221)) - (uint16_t)(**l_184)) | (***l_221)) / (uint16_t)1UL) << (int16_t)6) - (int32_t)(*p_25))) != (**l_184))) << (uint16_t)(**l_214)) << (int16_t)(***l_213)) && 0L)) <= 0x8DC9L)) || (*l_185)) != (*p_25)) != (**l_214)))) || l_236) + (uint32_t)(***l_221)) - (uint16_t)(*l_185)) || (***l_221)));
        return l_239;
    }
    else
    { /* block id: 64 */
        uint16_t l_244 = 65533UL;
        int32_t ****l_255 = &l_213;
        int32_t l_257 = 4L;
        int32_t *l_256 = &l_257;
        (*l_256) |= ((((uint16_t)(((((uint16_t)(((((*l_213) == &p_25) <= l_244) ^ ((((int16_t)((int32_t)(*p_25) / (int32_t)(*p_25)) % (int16_t)l_244) != (((uint32_t)((uint16_t)((int32_t)(&l_213 == l_255) - (int32_t)((***l_213) && 0x714BL)) / (uint16_t)(****l_255)) % (uint32_t)(***l_213)) < 0UL)) < (***l_213))) > (****l_255)) * (uint16_t)(****l_255)) , 0x3B36L) | (****l_255)) , 0UL) >> (uint16_t)(***l_213)) <= 0x96BABB2BL) ^ (***l_213));
    }
    return l_258;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_40(int32_t * p_41, int32_t ** p_42)
{ /* block id: 13 */
    const uint16_t l_44 = 1UL;
    int32_t l_45 = 0xD14CA72CL;
    float l_52 = 0x1.3p-1;
    int16_t l_65 = 0x0988L;
    const float l_66 = 0x0.8p-1;
    int32_t * const *l_67 = (void*)0;
    const int32_t *l_154 = &l_45;
    int16_t l_155 = 0L;
    const uint32_t l_161 = 0xC423CDDDL;
    l_45 ^= l_44;
    l_154 = func_46((l_45 , 65535UL), func_53(&l_45, func_58((((int16_t)func_16(((((65528UL == ((l_45 , ((p_41 == &l_45) != l_45)) || ((int16_t)1L + (int16_t)l_45))) & (-1L)) , 0x410FL) == l_65)) << (int16_t)l_65) >= l_45), l_67), l_45, l_45), l_154, &l_154, l_155);
    /* statement id: 34 */
    assert (l_154 == 0);
    return l_161;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_46(uint16_t  p_47, int32_t ** p_48, const int32_t * p_49, const int32_t ** p_50, int16_t  p_51)
{ /* block id: 32 */
    int32_t l_157 = 0x50DB93F6L;
    int32_t *l_156 = &l_157;
    int32_t *l_158 = &l_157;
    int32_t *l_159 = &l_157;
    int32_t *l_160 = (void*)0;
    return l_160;
    /* statement id: 33 */
    //assert (func_46_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_53(int32_t * p_54, int32_t * p_55, int32_t  p_56, const int32_t  p_57)
{ /* block id: 17 */
    const int16_t l_69 = 0x456AL;
    int32_t l_70 = 0xCDE87198L;
    int32_t *l_72 = &l_70;
    int32_t **l_71 = &l_72;
    int32_t l_143 = (-4L);
    int32_t *l_142 = &l_143;
    int16_t l_150 = 1L;
    uint32_t l_151 = 0x570EA9D5L;
    int32_t **l_152 = &l_72;
    int32_t **l_153 = (void*)0;
    l_70 &= l_69;
    (*l_71) = &l_70;
    (*l_142) |= (func_16(func_73((**l_71), func_16((((int16_t)0x632CL * (int16_t)65530UL) >= (((&p_55 != (void*)0) != (&p_57 == (((int16_t)p_57 >> (int16_t)0) , func_58((**l_71), func_82(((**l_71) < (-0x4.5p+1))))))) & (*l_72)))), p_55, (*l_71))) < 0xB8E9996AL);
    l_151 &= (((*l_142) , ((void*)0 == &p_57)) < (((uint16_t)(((&p_54 != &p_55) , ((int32_t)((~(p_57 | ((+(((void*)0 == &l_142) ^ p_57)) || p_56))) != (*p_54)) % (int32_t)p_56)) > l_150) << (uint16_t)(*l_72)) && 1L));
    return l_153;
    /* statement id: 31 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_58(uint32_t  p_59, int32_t * const * p_60)
{ /* block id: 15 */
    int32_t *l_68 = (void*)0;
    return l_68;
    /* statement id: 16 */
    //assert (func_58_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_73(int32_t  p_74, int16_t  p_75, int32_t * p_76, int32_t * p_77)
{ /* block id: 26 */
    uint32_t l_123 = 4294967292UL;
    int32_t *l_140 = (void*)0;
    int32_t * const *l_139 = &l_140;
    int32_t **l_141 = &l_140;
    (*l_141) = func_58(((int16_t)((uint32_t)(((uint32_t)p_75 + (uint32_t)((int16_t)(!((uint16_t)l_123 % (uint16_t)(+((l_123 | 0xCC90L) & (((((int16_t)((int16_t)p_75 * (int16_t)((int16_t)((((uint16_t)((((uint16_t)((uint16_t)1UL << (uint16_t)12) >> (uint16_t)(p_74 , (((int16_t)((0xB44AL ^ p_74) < 0xF826083BL) - (int16_t)l_123) == (*p_77)))) != l_123) && 0x0164L) << (uint16_t)9) , l_123) < l_123) << (int16_t)p_75)) >> (int16_t)p_74) <= p_74) < p_74) || l_123))))) >> (int16_t)l_123)) || 0x8B0FL) / (uint32_t)0xFAF5C710L) % (int16_t)0x7073L), l_139);
    return p_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_82(float  p_83)
{ /* block id: 20 */
    float l_84 = (-0x8.Bp+1);
    int32_t l_85 = 0L;
    int32_t l_87 = 0x8D320CD5L;
    int32_t *l_86 = &l_87;
    int32_t *l_106 = &l_85;
    float l_109 = 0x1.Cp-1;
    int32_t **l_110 = &l_106;
    int32_t **l_111 = (void*)0;
    (*l_86) &= l_85;
    (*l_86) = ((*l_86) , ((uint32_t)((&l_86 == &l_86) < ((uint16_t)((*l_86) == ((uint16_t)(((((uint16_t)((((uint16_t)((uint16_t)(((int32_t)((*l_86) | (-1L)) + (int32_t)((uint32_t)(l_106 == &l_87) / (uint32_t)(((uint32_t)(((((((*l_106) != (*l_86)) , (*l_106)) , p_83) != 0x3.5AED0Ep-22) , (-1L)) & (*l_106)) % (uint32_t)5UL) , 0x86EA79F1L))) , 0x1C65L) << (uint16_t)(*l_86)) >> (uint16_t)(*l_86)) != (-10L)) | (*l_106)) << (uint16_t)(*l_106)) != (*l_86)) , (*l_86)) , (*l_86)) * (uint16_t)0UL)) << (uint16_t)(*l_106))) / (uint32_t)0x3094FC7AL));
    (*l_86) ^= (*l_106);
    (*l_86) = (((*l_86) > (1L & (*l_86))) ^ (*l_106));
    return l_111;
    /* statement id: 25 */
    //assert (func_82_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 66
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 2

XXX total number of pointers: 64

XXX times a variable address is taken: 66
XXX times a pointer is dereferenced on RHS: 101
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 20
   depth: 3, occurrence: 20
   depth: 4, occurrence: 6
XXX times a pointer is dereferenced on LHS: 26
breakdown:
   depth: 1, occurrence: 23
   depth: 2, occurrence: 0
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 252

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 120
   level: 2, occurrence: 44
   level: 3, occurrence: 41
   level: 4, occurrence: 12
XXX number of pointers point to pointers: 30
XXX number of pointers point to scalars: 34
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 39.1
XXX average alias set size: 1.06

XXX times a non-volatile is read: 460
XXX times a non-volatile is write: 72
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 30
XXX max block depth: 1
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 3

XXX percentage a fresh-made variable is used: 11.6
XXX percentage an existing variable is used: 88.4
********************* end of statistics **********************/

