/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3808935214
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
   float  f1;
   const uint32_t  f2;
   uint32_t  f3;
   uint16_t  f4;
   uint32_t  f5;
   int32_t  f6;
   int32_t  f7;
   int8_t  f8;
   uint16_t  f9;
};

union U1 {
   struct S0  f0;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_28(void);
static float  func_54(uint16_t  p_55, const struct S0  p_56, uint32_t  p_57, uint32_t  p_58);
static int16_t  func_65(uint16_t  p_66, int8_t  p_67, int32_t  p_68, uint16_t  p_69);
static int32_t  func_79(union U1  p_80, uint32_t  p_81, int32_t  p_82);
static union U1  func_83(const int32_t  p_84, int32_t  p_85, int16_t  p_86, uint32_t  p_87);
static int16_t  func_88(const float  p_89, float  p_90);
static float  func_93(int32_t  p_94, const uint16_t  p_95, int8_t  p_96, uint16_t  p_97, int32_t  p_98);
static uint16_t  func_106(int32_t  p_107, uint32_t  p_108);
static uint16_t  func_109(struct S0  p_110, uint16_t  p_111);
static uint32_t  func_115(const int8_t  p_116, const float  p_117, uint32_t  p_118);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_28(void)
{ /* block id: 36 */
    int8_t l_33 = (-6);
    int8_t l_38 = 1;
    int32_t l_41 = 0x4DE5A82A;
    int32_t l_435 = 1;
    const uint32_t l_454 = 4294967286U;
    l_38 = (((8U <= ((int32_t)((uint32_t)2U / (uint32_t)0x329EF4A0) + (int32_t)((l_33 > __builtin_bswap32((((uint32_t)((uint16_t)l_33 << (uint16_t)1) * (uint32_t)(l_33 & (0 && l_33))) != (0xABFF && l_33)))) ^ l_33))) == l_33) | l_33);
    l_41 = ((uint16_t)0x0907 + (uint16_t)l_38);
    for (l_33 = 0; (l_33 < (-26)); l_33 -= 1)
    { /* block id: 41 */
        uint32_t l_70 = 0x4B1F0599;
        const struct S0 l_414 = {0U,0x1.Bp-1,0x7E63882D,1U,0x10FE,0x88362FC7,0x66704019,0x7FF7380D,0x34,0x26F1};
        int32_t l_436 = 0x438B3E22;
        l_435 = ((float)((float)((float)0x6.A19AE8p-81 + (float)((((float)(((((float)func_54(((l_33 & ((int16_t)((uint16_t)(((int16_t)func_65(l_33, l_70, l_70, (l_70 >= __builtin_bswap64((((int16_t)(-2) >> (int16_t)(((int16_t)0 + (int16_t)0) && 0x3038)) != l_70)))) >> (int16_t)l_70) < l_70) - (uint16_t)l_41) >> (int16_t)l_70)) <= l_70), l_414, l_414.f6, l_38) - (float)l_414.f4) <= 0xC.428C04p+95) != 0x5.8p+1) >= 0x0.7p-1) / (float)l_414.f2) >= 0x1.4p+1) <= 0xC.B7650Cp-81)) + (float)0x1.6p+1) + (float)0x7.DC7412p-30);
        l_436 |= l_38;
    }
    l_435 = ((uint32_t)((int16_t)((int32_t)func_115((~((uint32_t)0x95968A78 / (uint32_t)((((int16_t)(((l_33 >= ((uint32_t)((int16_t)((1U > ((int32_t)l_38 - (int32_t)__builtin_ia32_crc32qi(l_38, (0x7B4945F9 | 0x31C4C9FA)))) == (__builtin_bswap32(((l_38 != l_41) <= l_435)) > 7U)) >> (int16_t)l_38) + (uint32_t)l_454)) || l_33) <= l_38) << (int16_t)l_435) | l_454) && l_33))), l_38, l_33) + (int32_t)l_41) << (int16_t)l_454) + (uint32_t)l_33);
    return l_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_54(uint16_t  p_55, const struct S0  p_56, uint32_t  p_57, uint32_t  p_58)
{ /* block id: 159 */
    int32_t l_417 = 0x86C2678D;
    int16_t l_426 = (-8);
    int16_t l_432 = 0xC374;
    l_417 = ((float)(l_417 <= ((float)0x3.8p-1 + (float)0x0.F46E8Ap+28)) / (float)((float)((float)p_56.f5 / (float)(p_55 == p_58)) - (float)((((float)((l_417 >= (p_56.f9 == 0x1.Cp+1)) > 0xC.F57F94p+92) + (float)0x0.Cp-1) > l_417) != l_417)));
    l_426 = l_417;
    l_417 = ((uint16_t)(-(int32_t)(0x1072 & ((uint16_t)__builtin_ia32_crc32qi(l_432, ((int32_t)(p_56.f3 & l_426) % (int32_t)(p_58 ^ p_56.f8))) - (uint16_t)p_56.f8))) % (uint16_t)0x3E3E);
    return p_56.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_65(uint16_t  p_66, int8_t  p_67, int32_t  p_68, uint16_t  p_69)
{ /* block id: 42 */
    int16_t l_99 = 4;
    float l_100 = 0xA.5EA0D0p-57;
    int8_t l_243 = 0x67;
    int32_t l_261 = 1;
    int32_t l_342 = (-7);
    int32_t l_344 = 0x53795DC2;
    int32_t l_345 = 0xF7F71887;
    int32_t l_346 = 0xFFCEB0BC;
    int32_t l_349 = 0xA31FFB44;
    int32_t l_351 = 0;
    int32_t l_352 = 0;
    int32_t l_353 = 1;
    int32_t l_354 = 0;
    int32_t l_355 = 0x314A802A;
    int32_t l_357 = 8;
    int32_t l_358 = (-9);
    int32_t l_359 = (-4);
    int32_t l_362 = (-1);
    int32_t l_363 = 8;
    int32_t l_364 = 0xCDE4736B;
    int32_t l_365 = 0xB3BA48C5;
    int32_t l_366 = 0x454B698C;
    int32_t l_367 = 0x8337A895;
    int32_t l_368 = 6;
    int32_t l_369 = 0x5D34177D;
    int32_t l_370 = 0x627B09AB;
    int32_t l_372 = (-1);
    int32_t l_378 = 1;
    int32_t l_380 = 0;
    int32_t l_381 = 0x41B2535B;
    int32_t l_382 = 0xDBC2BB81;
    int32_t l_384 = 0x66BB1736;
    int32_t l_386 = (-10);
    int32_t l_388 = (-1);
    int32_t l_390 = 1;
    int32_t l_392 = 0;
    int32_t l_393 = 0xEAAE944D;
    if ((((4294967295U < ((uint16_t)((int32_t)func_79(func_83(((func_88(((float)func_93(l_99, l_99, p_69, l_99, ((0x084F7CB2 != ((int16_t)__builtin_bswap32(l_99) % (int16_t)8U)) && l_99)) + (float)(-0x1.4p+1)), l_99) == p_67) <= l_99), l_99, p_68, l_99), p_68, p_68) % (int32_t)p_69) - (uint16_t)p_67)) && p_68) == l_243))
    { /* block id: 115 */
        const uint32_t l_248 = 0xCEF47AD6;
        int32_t l_287 = 0;
        union U1 l_302 = {{0U,-0x4.Cp+1,4294967289U,0xA4215E30,1U,4294967295U,1,0x85AF8ADF,0x63,0x1895}};
        int32_t l_343 = (-6);
        float l_347 = 0x8.4B4B9Bp+31;
        int32_t l_348 = 1;
        int32_t l_350 = 0x4648A997;
        int32_t l_356 = 0x6EA5D3A2;
        int32_t l_360 = 0;
        int32_t l_361 = 0x273A6DB6;
        int32_t l_371 = 0x7B11ED50;
        int32_t l_373 = 0x491A405F;
        int32_t l_374 = (-8);
        int32_t l_375 = 5;
        int32_t l_376 = 0x26C21DDF;
        int32_t l_377 = (-10);
        int32_t l_379 = (-1);
        int32_t l_383 = 0;
        int32_t l_385 = (-1);
        int32_t l_387 = 9;
        int32_t l_389 = 0;
        int32_t l_391 = (-3);
        int32_t l_394 = (-10);
        uint16_t l_395 = 65532U;
        for (p_68 = 0; (p_68 != (-11)); --p_68)
        { /* block id: 118 */
            int16_t l_250 = 0xC4A1;
            int32_t l_266 = 0x4544C11F;
            int16_t l_339 = 1;
            for (p_69 = 0; (p_69 <= 46); p_69 += 1)
            { /* block id: 121 */
                uint32_t l_249 = 4294967288U;
                int32_t l_283 = 0x18198974;
                if (l_248)
                { /* block id: 122 */
                    const int8_t l_255 = (-5);
                    int32_t l_282 = 0xDE750D66;
                    l_249 ^= p_68;
                    if (((func_106(l_248, l_250) == ((((uint32_t)l_248 - (uint32_t)l_248) < l_255) || 0U)) == ((uint32_t)(3 >= (((uint16_t)4U + (uint16_t)0xB7D5) | l_255)) / (uint32_t)p_69)))
                    { /* block id: 124 */
                        l_261 &= ((-(int16_t)0xC006) <= p_66);
                        l_266 = ((uint32_t)__builtin_ctz(((uint16_t)p_69 << (uint16_t)6)) % (uint32_t)0x76B29E6F);
                    }
                    else
                    { /* block id: 127 */
                        return p_66;
                    }
                    l_282 |= (((int32_t)(((int32_t)(1 | 0xEA65) + (int32_t)(((int32_t)((int16_t)((uint32_t)((int16_t)0xF06D % (int16_t)l_249) + (uint32_t)p_67) % (int16_t)l_255) - (int32_t)(+(l_248 != (0xDF4B ^ ((uint16_t)((65526U >= 1) == 0x9C3CA289) >> (uint16_t)l_248))))) | l_255)) | 7U) % (int32_t)1U) ^ p_69);
                }
                else
                { /* block id: 131 */
                    int32_t l_286 = (-1);
                    int32_t l_315 = 0x95644861;
                    l_283 &= l_248;
                    if ((0xA383889F >= p_67))
                    { /* block id: 133 */
                        l_287 = ((uint16_t)l_286 << (uint16_t)(__builtin_ffs(p_67) & l_248));
                    }
                    else
                    { /* block id: 135 */
                        l_286 &= (((int32_t)(-1) + (int32_t)((((uint32_t)l_266 - (uint32_t)((uint32_t)p_67 - (uint32_t)l_99)) & (0xD101BBB7 != ((((((uint16_t)((((0 || 0x9C2CA9A2) & p_68) >= ((l_266 <= 0xC4637558) ^ 0x7D2F)) | 0x48D4) + (uint16_t)0U) | 0xF7B5) | l_266) ^ 0) >= 1U))) <= p_69)) || l_99);
                        if (l_266)
                            continue;
                        l_283 = ((uint32_t)(__builtin_ctz((p_67 >= (__builtin_ffsll(l_99) && l_266))) != l_261) - (uint32_t)((uint16_t)((l_243 > 0x247F) < (((int16_t)func_79(l_302, p_69, p_69) % (int16_t)p_69) <= 0x3627BD82)) << (uint16_t)3));
                        l_315 &= ((int32_t)((int16_t)l_302.f0.f3 + (int16_t)l_261) - (int32_t)((int32_t)(p_67 <= ((uint16_t)0U - (uint16_t)((((p_66 || l_286) && ((int32_t)((int16_t)(__builtin_ctzl(l_99) ^ (p_68 & (-1))) - (int16_t)1) % (int32_t)l_249)) >= p_66) || l_302.f0.f8))) + (int32_t)l_286));
                    }
                }
                l_287 &= ((int32_t)(((((int32_t)l_243 - (int32_t)(((uint32_t)((int16_t)l_266 >> (int16_t)4) - (uint32_t)(((int32_t)((uint16_t)l_250 / (uint16_t)__builtin_ctzl(l_249)) - (int32_t)(l_99 & p_69)) <= (!((-8) | (65530U | 0x8963))))) != p_66)) < 0xD3BD) & l_250) & 0U) + (int32_t)4);
            }
            l_261 &= ((uint32_t)((uint16_t)p_68 >> (uint16_t)(((p_66 > (0x811FDEBC != (l_266 || ((l_302.f0.f7 > (l_250 && ((((int32_t)((uint16_t)((uint16_t)__builtin_popcountl(((p_67 || l_302.f0.f3) > ((((__builtin_ctzl(p_67) && l_302.f0.f8) & p_67) && l_248) <= 1))) << (uint16_t)11) >> (uint16_t)l_339) / (int32_t)4294967295U) != l_339) <= p_66))) < 0x6A0C)))) < p_67) != 0xF1F2)) / (uint32_t)l_266);
            l_261 = ((float)l_339 / (float)l_261);
            if (p_67)
                break;
        }
        --l_395;
    }
    else
    { /* block id: 149 */
        uint32_t l_408 = 0x43E4FF47;
        int32_t l_413 = (-2);
        p_68 = __builtin_clz((p_68 ^ (p_69 ^ ((int32_t)((((1U & p_67) | 0xB7F8BF72) ^ p_67) != ((int32_t)func_115((((int32_t)((int16_t)((int32_t)((l_408 < l_344) != ((int16_t)l_408 + (int16_t)l_364)) / (int32_t)0x74F58ABC) / (int16_t)l_366) / (int32_t)0xF530F209) || 0x82CB), l_408, p_68) - (int32_t)p_67)) + (int32_t)l_408))));
        for (l_99 = (-26); (l_99 >= (-17)); l_99 += 1)
        { /* block id: 153 */
            l_413 = p_69;
        }
        l_413 = p_67;
    }
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_79(union U1  p_80, uint32_t  p_81, int32_t  p_82)
{ /* block id: 111 */
    int16_t l_237 = 0x175C;
    const float l_240 = (-0x10.5p+1);
    int32_t l_241 = 0x5FDFF747;
    int32_t l_242 = 0x6ED50CF4;
    l_237 = 0x1.0p+1;
    l_242 |= (__builtin_parityll(((uint16_t)(l_237 && __builtin_bswap64(__builtin_popcount(l_237))) >> (uint16_t)0)) >= l_241);
    return p_80.f0.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_83(const int32_t  p_84, int32_t  p_85, int16_t  p_86, uint32_t  p_87)
{ /* block id: 108 */
    int8_t l_235 = 0;
    union U1 l_236 = {{65530U,0x1.Cp-1,0x17A9C682,7U,0x4340,0x74B80A73,-1,-7,-1,0x2EDF}};
    l_235 = p_85;
    return l_236;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_88(const float  p_89, float  p_90)
{ /* block id: 103 */
    uint16_t l_214 = 1U;
    int32_t l_221 = (-1);
    l_221 &= ((int16_t)l_214 % (int16_t)((4 < (l_214 > (1U != ((uint32_t)l_214 + (uint32_t)l_214)))) ^ ((uint32_t)((int16_t)__builtin_ctzl(l_214) >> (int16_t)l_214) % (uint32_t)0xA27BBEFF)));
    l_221 = (((uint16_t)((((uint16_t)func_106((4294967295U & (l_221 <= l_221)), l_221) << (uint16_t)13) & (~(func_106((((int16_t)((uint16_t)((((int16_t)(l_221 || __builtin_popcountll(l_221)) << (int16_t)15) || (l_214 < l_221)) < l_214) >> (uint16_t)3) + (int16_t)l_214) || 0x95D41F0D), l_214) && l_214))) && l_221) << (uint16_t)11) & 1U);
    p_90 = 0xE.E0601Fp-34;
    return l_221;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_93(int32_t  p_94, const uint16_t  p_95, int8_t  p_96, uint16_t  p_97, int32_t  p_98)
{ /* block id: 43 */
    float l_123 = 0x9.270AEEp-56;
    int32_t l_124 = 0xBF48DF11;
    int32_t l_211 = (-2);
    for (p_94 = 28; (p_94 == (-9)); p_94 -= 1)
    { /* block id: 46 */
        uint32_t l_105 = 4294967293U;
        struct S0 l_112 = {5U,0x8.C2C51Cp+61,0U,5U,65527U,0x59FE4D3D,1,-9,2,65535U};
        uint32_t l_125 = 0xCC05FD73;
        uint32_t l_150 = 0x08E2B083;
        int32_t l_184 = 0xB2B2917D;
        if (((l_105 && p_96) > (func_106((func_109(l_112, ((uint32_t)func_115((0U ^ ((int16_t)((0U & ((0U | ((int16_t)p_94 << (int16_t)(l_105 == l_124))) != p_94)) | 0xF7AD) + (int16_t)l_125)), p_98, p_96) + (uint32_t)l_112.f6)) <= 0x8CE9), l_150) | 0x654D)))
        { /* block id: 71 */
            uint32_t l_175 = 0x92F5982E;
            int32_t l_180 = 0x2EDBCE3F;
            struct S0 l_181 = {65535U,0x4.611AB6p-86,1U,0x113F68E7,65530U,0x4C8FCCF9,4,0xE2F553DE,0x8F,2U};
            l_124 = ((((((uint16_t)((p_96 && func_106(l_124, (p_97 | (l_175 == ((uint16_t)l_175 / (uint16_t)((int16_t)l_124 % (int16_t)(__builtin_ctzl(p_95) | l_175))))))) != p_96) >> (uint16_t)p_96) == p_98) ^ l_124) & l_175) && 0U);
            l_180 = 0xA740B190;
            l_184 = (func_109(l_181, (0x6135 != ((0x6412 ^ ((int32_t)0x79DCF4DC + (int32_t)func_106(l_124, p_95))) != l_112.f0))) >= 65526U);
        }
        else
        { /* block id: 75 */
            float l_189 = (-0x1.Dp+1);
            int32_t l_190 = 1;
            float l_191 = 0xE.3B3DE1p+66;
            int32_t l_192 = (-1);
            l_184 = p_94;
            l_184 = p_98;
            l_192 &= (((uint16_t)p_96 % (uint16_t)((p_95 | ((uint16_t)__builtin_popcountl(l_190) >> (uint16_t)p_97)) | p_96)) && (0x361D >= (l_112.f9 == (((l_124 & l_124) && (-1)) <= l_112.f3))));
        }
        if (l_112.f9)
            break;
        l_184 = (l_124 > p_94);
        l_184 &= (func_109(l_112, p_96) >= (((uint16_t)((int16_t)(p_95 <= ((p_98 && (+(((int32_t)func_109(l_112, l_112.f4) - (int32_t)l_124) | 0x1201))) && l_150)) << (int16_t)l_124) - (uint16_t)p_97) && l_124));
    }
    if (l_124)
    { /* block id: 84 */
        uint32_t l_200 = 4294967295U;
        int32_t l_205 = 0x185A6AE0;
        l_200 = 0xA.E99574p-29;
        for (p_94 = 0; (p_94 == 14); p_94 += 1)
        { /* block id: 88 */
            if (l_200)
                break;
            for (p_97 = 0; (p_97 == 59); p_97 += 3)
            { /* block id: 92 */
                l_205 = l_124;
                if (l_200)
                    break;
            }
        }
    }
    else
    { /* block id: 97 */
        uint32_t l_206 = 8U;
        l_124 = l_206;
        l_124 = l_206;
    }
    l_211 = ((func_115((p_94 | p_95), p_97, p_96) > (((((float)((float)(l_124 >= ((p_95 >= (l_124 < p_96)) != p_97)) / (float)p_96) / (float)0xF.F29C22p-89) == 0x6.5p+1) < p_95) <= 0x8.E06F24p+25)) != 0x0.908D26p+88);
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_106(int32_t  p_107, uint32_t  p_108)
{ /* block id: 66 */
    uint32_t l_151 = 4294967288U;
    int32_t l_166 = 0xA04A83BE;
    struct S0 l_169 = {1U,0x7.FC39F9p+20,0U,0xDFE233B6,0x2EDB,8U,0x52264B8E,-7,1,0x5703};
    --l_151;
    l_166 = ((uint16_t)p_108 - (uint16_t)((func_115(((uint16_t)func_115(p_108, (((float)p_107 - (float)((float)(l_151 != __builtin_popcount(l_151)) - (float)(((((float)p_108 + (float)((float)l_151 / (float)__builtin_clz(__builtin_ctzl((0 >= l_151))))) <= l_151) == l_151) > p_107))) <= l_151), l_151) >> (uint16_t)7), l_151, l_151) <= (-4)) && p_108));
    l_166 = (((float)l_166 - (float)0x1.Bp+1) >= func_109(l_169, (-(int32_t)p_107)));
    return l_166;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_109(struct S0  p_110, uint16_t  p_111)
{ /* block id: 56 */
    int32_t l_141 = 0xADB25B5F;
    uint32_t l_149 = 0U;
    l_141 ^= (-4);
    for (p_111 = (-10); (p_111 != 15); p_111 += 5)
    { /* block id: 60 */
        l_141 = p_110.f2;
        return l_141;
    }
    l_141 = ((((float)(+(p_110.f3 >= p_110.f4)) + (float)(p_110.f9 <= ((((float)p_110.f5 + (float)func_115(l_141, l_141, p_110.f5)) != (p_110.f4 < 0xE.7570BAp+38)) == l_141))) > l_149) == 0xF.B69D60p-33);
    return p_110.f8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_115(const int8_t  p_116, const float  p_117, uint32_t  p_118)
{ /* block id: 47 */
    uint32_t l_126 = 4294967291U;
    int32_t l_127 = (-7);
    if (l_126)
    { /* block id: 48 */
        l_127 = p_116;
    }
    else
    { /* block id: 50 */
        uint16_t l_132 = 8U;
        int32_t l_139 = 2;
        l_139 = ((float)((float)p_116 / (float)((l_132 == ((float)p_116 / (float)(((float)((l_132 == (l_132 == ((float)p_116 / (float)l_126))) >= p_116) / (float)p_116) > l_132))) <= p_118)) - (float)p_116);
        l_139 |= (!p_116);
        return p_118;
    }
    return l_127;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 122
   depth: 1, occurrence: 4
XXX total union variables: 2

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 13
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 4
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 348
XXX times a non-volatile is write: 60
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 85
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 21
   depth: 2, occurrence: 13
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 27.7
XXX percentage an existing variable is used: 72.3
********************* end of statistics **********************/

