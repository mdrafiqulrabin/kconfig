/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1596874080
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_26(void);
static int32_t * func_27(int32_t  p_28, uint16_t  p_29, int32_t * p_30, int32_t * p_31, int32_t  p_32);
inline static int32_t * func_35(uint32_t  p_36, uint32_t  p_37);
inline static float  func_54(int32_t ** p_55, int32_t  p_56);
static int32_t  func_58(uint16_t  p_59, uint16_t  p_60, int32_t * p_61);
inline static uint16_t  func_62(int32_t * p_63);
static int32_t * func_67(int32_t  p_68);
inline static uint16_t  func_78(uint32_t  p_79);
inline static int32_t * func_86(float  p_87, int16_t  p_88);
static int32_t *** func_89(int32_t *** p_90, int16_t  p_91, int16_t  p_92, int32_t  p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_26(void)
{ /* block id: 36 */
    int32_t l_34 = (-1L);
    int32_t *l_33 = &l_34;
    int32_t **l_51 = &l_33;
    int32_t ***l_277 = &l_51;
    int32_t ****l_276 = &l_277;
    int32_t l_278 = 0x4C872E6DL;
    int16_t l_309 = 0x8072L;
    int16_t l_326 = 0xC29DL;
    int32_t l_335 = 0L;
    float l_336 = 0x0.Fp-1;
    uint16_t l_337 = 65531UL;
    int32_t l_340 = 0L;
    uint32_t l_341 = 0x5F0AE923L;
    float l_342 = 0x6.175456p-54;
    int32_t *l_343 = &l_34;
    float l_344 = 0x6.0C2D7Fp+66;
    int16_t l_345 = (-1L);
    (*l_51) = func_27(((void*)0 == l_33), (*l_33), &l_34, func_35(((void*)0 == &l_34), (((int16_t)(((*l_33) < 65535UL) > (((*l_33) && (*l_33)) == 0x814BL)) + (int16_t)(*l_33)) > 0xF58AL)), (*l_33));
    for (l_34 = (-22); (l_34 == (-24)); l_34 -= 1)
    { /* block id: 46 */
        int32_t **l_57 = &l_33;
        int32_t l_254 = 8L;
        float *l_271 = (void*)0;
        float l_273 = 0xE.042488p+9;
        float *l_272 = &l_273;
        (*l_272) = func_54(l_57, func_58(func_62((*l_51)), l_34, func_35((l_34 <= ((0x9C3933B6L || ((int16_t)l_254 << (int16_t)l_254)) & (((int16_t)l_34 >> (int16_t)6) <= 0x3501AD26L))), l_254)));
        if (l_254)
            continue;
        if (l_34)
            break;
    }
    if (((uint16_t)((void*)0 == l_276) + (uint16_t)(l_33 == l_33)))
    { /* block id: 161 */
        int32_t l_280 = 4L;
        uint32_t l_310 = 6UL;
        int32_t ***l_313 = (void*)0;
        int32_t l_319 = (-1L);
        int32_t l_324 = 0x4CCEA3E2L;
        if (l_278)
        { /* block id: 162 */
            int32_t l_279 = 0L;
            l_280 = l_279;
            return l_280;
        }
        else
        { /* block id: 165 */
            int32_t l_288 = (-2L);
            uint16_t l_291 = 0x7A06L;
            int32_t ***l_306 = &l_51;
            int32_t ***l_307 = &l_51;
            for (l_34 = 13; (l_34 != 17); l_34 += 1)
            { /* block id: 168 */
                int32_t **l_283 = &l_33;
                float l_285 = 0xF.103CEEp-21;
                float *l_284 = &l_285;
                int32_t l_290 = (-9L);
                int16_t l_297 = (-6L);
                (*l_284) = (l_283 == (void*)0);
                for (l_278 = (-9); (l_278 < (-27)); l_278 -= 1)
                { /* block id: 172 */
                    int32_t *l_289 = &l_280;
                    l_280 = (l_288 ^ l_288);
                    (**l_277) = l_289;
                }
                (**l_277) = func_35(__builtin_bswap64(l_290), l_291);
                for (l_278 = (-1); (l_278 != (-11)); l_278 -= 1)
                { /* block id: 179 */
                    int16_t l_296 = (-1L);
                    l_288 = l_280;
                    (*l_283) = &l_288;
                    (*l_276) = func_89((*l_276), ((l_280 || l_291) && ((*l_33) >= 0x175EL)), l_280, ((uint16_t)l_296 + (uint16_t)((1L != __builtin_popcountll(((((void*)0 != &l_280) > l_288) >= l_296))) != l_297)));
                }
            }
            for (l_278 = 0; (l_278 > 6); l_278 += 4)
            { /* block id: 187 */
                uint32_t l_308 = 0UL;
                if (l_291)
                { /* block id: 188 */
                    int16_t l_301 = 0x5BF8L;
                    int32_t *l_318 = &l_280;
                    l_288 = l_288;
                    if (((!l_301) < ((int32_t)(((uint16_t)((((l_306 == l_307) >= l_301) > (((((((func_62(&l_280) && (l_280 >= 1UL)) > l_280) || 0x97FBL) > l_308) && l_309) || 0xE3E2L) > l_301)) < l_280) >> (uint16_t)8) | 0xAFFF069DL) + (int32_t)l_301)))
                    { /* block id: 190 */
                        uint32_t l_315 = 0x22DDEA78L;
                        uint32_t l_316 = 4294967295UL;
                        (***l_276) = func_86(l_310, ((int16_t)((void*)0 == l_313) - (int16_t)__builtin_ia32_crc32qi((!l_315), l_316)));
                        if (l_301)
                            continue;
                    }
                    else
                    { /* block id: 193 */
                        int16_t l_317 = 0xC520L;
                        return l_317;
                    }
                    (**l_277) = l_318;
                }
                else
                { /* block id: 197 */
                    if (l_308)
                        break;
                }
                if (l_310)
                    break;
            }
            (***l_276) = (**l_277);
        }
        if (l_319)
        { /* block id: 204 */
            int32_t *l_320 = &l_280;
            int32_t ***l_321 = &l_51;
            (***l_276) = l_320;
            (***l_276) = func_27(l_319, ((l_321 != (void*)0) & (((int16_t)(***l_321) << (int16_t)0) >= (**l_51))), (**l_277), &l_280, (*l_320));
            l_324 = (((((*l_321) != (**l_276)) != (l_324 >= l_319)) && (!l_280)) & (*l_320));
        }
        else
        { /* block id: 208 */
            return l_326;
        }
        (**l_277) = func_67(((uint16_t)l_310 >> (uint16_t)0));
    }
    else
    { /* block id: 212 */
        int32_t *l_329 = (void*)0;
        int32_t *l_330 = &l_34;
        (*l_330) = func_62((*l_51));
    }
    (*l_343) = ((l_326 < (__builtin_ctzl(((uint16_t)l_278 % (uint16_t)l_326)) > ((((uint16_t)((l_335 & l_335) ^ l_335) << (uint16_t)l_337) && ((((uint16_t)((void*)0 != (*l_51)) >> (uint16_t)10) < l_278) >= 65533UL)) != l_340))) > l_341);
    return l_345;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_27(int32_t  p_28, uint16_t  p_29, int32_t * p_30, int32_t * p_31, int32_t  p_32)
{ /* block id: 39 */
    int32_t l_44 = 1L;
    float l_46 = (-0x1.Fp-1);
    float *l_45 = &l_46;
    int32_t *l_47 = &l_44;
    int32_t *l_48 = &l_44;
    int32_t *l_49 = &l_44;
    int32_t *l_50 = (void*)0;
    (*p_30) = l_44;
    (*l_45) = (&p_32 == (void*)0);
    return l_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_35(uint32_t  p_36, uint32_t  p_37)
{ /* block id: 37 */
    int32_t l_41 = 1L;
    int32_t *l_40 = &l_41;
    int32_t *l_42 = &l_41;
    int32_t *l_43 = (void*)0;
    return l_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_54(int32_t ** p_55, int32_t  p_56)
{ /* block id: 154 */
    int32_t *l_270 = (void*)0;
    (*p_55) = l_270;
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_58(uint16_t  p_59, uint16_t  p_60, int32_t * p_61)
{ /* block id: 143 */
    int16_t l_257 = 4L;
    int32_t l_263 = 0xCAB9C88EL;
    int32_t *l_262 = &l_263;
    (*l_262) = (l_257 & ((int16_t)(((uint16_t)p_59 << (uint16_t)14) < l_257) % (int16_t)p_59));
    (*l_262) = 7L;
    for (p_60 = (-1); (p_60 < 11); p_60 += 1)
    { /* block id: 148 */
        uint16_t l_268 = 0x40C4L;
        int32_t **l_269 = &l_262;
    }
    (*l_262) = __builtin_bswap32((*l_262));
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_62(int32_t * p_63)
{ /* block id: 47 */
    int16_t l_64 = 0x2177L;
    float l_66 = (-0x6.3p+1);
    float *l_65 = &l_66;
    int32_t l_250 = 0xF7FA5D5BL;
    int32_t *l_249 = &l_250;
    int32_t **l_248 = &l_249;
    int16_t l_251 = 0xFD3FL;
    (*l_248) = l_65;
    (*l_65) = 0xD.9EC65Fp-88;
    return l_251;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_67(int32_t  p_68)
{ /* block id: 48 */
    float l_73 = (-0x5.2p-1);
    int32_t l_74 = 0L;
    int32_t ***l_229 = (void*)0;
    int32_t *l_230 = &l_74;
    float *l_231 = &l_73;
    float *l_232 = &l_73;
    float *l_233 = &l_73;
    int32_t **l_234 = &l_230;
    int32_t *l_235 = &l_74;
    int32_t *l_236 = &l_74;
    int32_t *l_237 = &l_74;
    int32_t *l_238 = &l_74;
    int32_t *l_239 = &l_74;
    int32_t *l_240 = &l_74;
    int32_t *l_241 = &l_74;
    int32_t *l_242 = &l_74;
    int32_t *l_243 = &l_74;
    int32_t *l_244 = &l_74;
    int32_t *l_245 = &l_74;
    int32_t *l_246 = &l_74;
    int32_t *l_247 = (void*)0;
    (*l_230) = ((int16_t)((int16_t)p_68 << (int16_t)l_74) << (int16_t)(((-(uint16_t)l_74) >= ((uint16_t)((func_78(l_74) != p_68) || p_68) % (uint16_t)(__builtin_ctzll(((void*)0 != l_229)) | p_68))) == p_68));
    (*l_231) = 0x7.C97AD9p+80;
    (*l_234) = &p_68;
    return l_247;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_78(uint32_t  p_79)
{ /* block id: 49 */
    uint32_t l_80 = 0x9E0795B1L;
    int32_t l_83 = 6L;
    int32_t *l_82 = &l_83;
    int32_t **l_81 = &l_82;
    float l_85 = (-0x3.4p+1);
    float *l_84 = &l_85;
    (*l_81) = func_35(p_79, l_80);
    (*l_84) = 0x0.5p-1;
    (*l_81) = (*l_81);
    (*l_81) = func_86(((*l_81) != (*l_81)), p_79);
    return p_79;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_86(float  p_87, int16_t  p_88)
{ /* block id: 53 */
    int32_t **l_95 = (void*)0;
    int32_t ***l_94 = &l_95;
    int32_t l_98 = 5L;
    int32_t ****l_223 = &l_94;
    int32_t *l_225 = &l_98;
    int32_t **l_224 = &l_225;
    int32_t *l_226 = &l_98;
    int32_t *l_227 = &l_98;
    int32_t *l_228 = (void*)0;
    (*l_223) = func_89(l_94, (((p_88 != ((2UL <= ((int16_t)p_88 + (int16_t)l_98)) | ((uint32_t)(__builtin_popcountll((p_88 || p_88)) <= ((((p_88 > 65535UL) != p_88) >= p_88) >= 0x9387L)) % (uint32_t)p_88))) >= p_88) == 0x2EF76CAFL), l_98, p_88);
    (*l_224) = func_35(p_88, l_98);
    return l_228;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_89(int32_t *** p_90, int16_t  p_91, int16_t  p_92, int32_t  p_93)
{ /* block id: 54 */
    uint32_t l_122 = 6UL;
    float *l_169 = (void*)0;
    for (p_93 = 0; (p_93 <= 14); p_93 += 1)
    { /* block id: 57 */
        uint32_t l_121 = 4294967295UL;
        int32_t l_154 = 0x936FBAC3L;
        int32_t *l_153 = &l_154;
        int32_t **l_166 = &l_153;
        int32_t ***l_165 = &l_166;
        int32_t l_170 = 0xFF8A6063L;
        if ((p_92 < p_91))
        { /* block id: 58 */
            float l_124 = (-0x1.Bp+1);
            for (p_92 = 0; (p_92 <= 18); p_92 += 3)
            { /* block id: 61 */
                uint32_t l_114 = 18446744073709551612UL;
                uint32_t l_123 = 1UL;
                int32_t l_125 = 0xFC3DD168L;
                int32_t *l_131 = &l_125;
                int32_t **l_130 = &l_131;
                l_125 = ((p_92 & ((0xB79BA4D2L ^ (((uint16_t)p_93 - (uint16_t)1L) < ((int16_t)((uint32_t)((uint32_t)(!l_114) % (uint32_t)(0x501E45A2L | p_93)) + (uint32_t)((int32_t)(((int16_t)((p_92 || ((uint16_t)(l_121 == l_121) % (uint16_t)0xA5FBL)) <= l_122) >> (int16_t)1) <= 1L) - (int32_t)l_123)) % (int16_t)l_122))) > 0xF334L)) && l_122);
                for (p_91 = (-7); (p_91 < 6); p_91 += 7)
                { /* block id: 65 */
                    float l_132 = 0xA.A799ADp+22;
                    int32_t l_133 = 0L;
                    for (l_122 = 0; (l_122 != 9); l_122 += 1)
                    { /* block id: 68 */
                        float *l_134 = (void*)0;
                        int32_t l_135 = 0x65FAFB16L;
                        l_135 = (((((0x2.8E951Fp-91 < p_91) <= (__builtin_popcountll(p_93) >= p_92)) >= ((void*)0 == l_130)) > ((l_122 != l_132) > l_133)) == 0x1.Fp+1);
                    }
                }
            }
        }
        else
        { /* block id: 73 */
            int16_t l_142 = (-1L);
            int32_t l_152 = (-1L);
            int32_t *l_151 = &l_152;
            int32_t **l_164 = &l_153;
            int32_t ***l_163 = &l_164;
            float l_168 = 0x2.DAB535p+26;
            float *l_167 = &l_168;
            if (((int16_t)((((uint32_t)((uint32_t)0x61F34F69L % (uint32_t)l_142) - (uint32_t)((uint16_t)((uint16_t)l_142 << (uint16_t)1) >> (uint16_t)14)) ^ ((uint32_t)(l_122 | p_92) - (uint32_t)(l_142 >= 0xA44AL))) | 0L) + (int16_t)(0x3366FBB5L != p_93)))
            { /* block id: 74 */
                int32_t l_150 = 0xF9727A2CL;
                int32_t *l_149 = &l_150;
                (*l_149) = 4L;
                l_151 = l_151;
                l_151 = l_153;
                (**l_166) = (__builtin_parityll((*l_149)) | ((((int16_t)(((((uint16_t)((uint16_t)((int16_t)(__builtin_parity(__builtin_popcount(p_92)) && (4294967289UL <= (((l_163 == l_165) <= (l_167 == l_169)) <= (*l_149)))) >> (int16_t)p_91) + (uint16_t)(*l_151)) + (uint16_t)(*l_149)) & 0x8E2AL) > (*l_149)) <= 6L) << (int16_t)13) < (*l_153)) & l_170));
            }
            else
            { /* block id: 79 */
                int32_t *l_171 = &l_152;
                (*l_164) = l_171;
            }
            for (l_142 = 0; (l_142 >= 2); l_142 += 1)
            { /* block id: 84 */
                int32_t l_175 = 0L;
            }
            (**l_165) = (**l_163);
            (*l_153) = p_93;
        }
    }
    for (p_91 = 18; (p_91 > (-3)); p_91 -= 1)
    { /* block id: 103 */
        int32_t l_184 = 0xCCF6E19BL;
        int32_t *l_183 = &l_184;
        (*l_183) = 4L;
        if ((*l_183))
        { /* block id: 105 */
            int32_t **l_187 = &l_183;
            int32_t l_190 = (-1L);
            if (l_122)
                break;
            if ((((int16_t)((void*)0 != l_187) << (int16_t)6) && (0xB6B4L <= ((*l_183) | p_91))))
            { /* block id: 107 */
                float l_203 = 0x1.Bp+1;
                int32_t l_208 = 0x60B61569L;
                for (p_92 = 0; (p_92 >= 23); p_92 += 1)
                { /* block id: 110 */
                    float *l_191 = (void*)0;
                    float l_193 = 0x4.Cp-1;
                    float *l_192 = &l_193;
                    int32_t l_198 = 0xCDC420A7L;
                    (*l_192) = l_190;
                    (*l_183) = ((((p_93 <= (p_91 || (((uint32_t)(((((((uint16_t)l_198 << (uint16_t)14) != (**l_187)) <= (__builtin_clzll(l_122) & __builtin_ffs(((int16_t)((int16_t)(l_198 < l_122) << (int16_t)5) << (int16_t)p_91)))) != 65528UL) == (**l_187)) >= 0xFF555B32L) + (uint32_t)p_92) & (**l_187)))) == 0xA804L) != l_122) <= 1UL);
                    for (l_198 = (-28); (l_198 > (-29)); l_198 -= 1)
                    { /* block id: 115 */
                        return p_90;
                    }
                    (*l_192) = ((*l_183) < ((float)(l_208 < ((float)(p_91 > (!l_208)) + (float)p_92)) - (float)0x7.1E4365p+7));
                }
                (*l_187) = l_169;
            }
            else
            { /* block id: 121 */
                return p_90;
            }
        }
        else
        { /* block id: 124 */
            uint32_t l_216 = 4294967295UL;
            float l_222 = 0x0.7p-1;
            float *l_221 = &l_222;
            (*l_221) = ((((float)l_122 + (float)((float)l_216 + (float)p_91)) >= ((float)l_216 + (float)(((*l_183) <= ((float)l_216 - (float)l_122)) != l_122))) == (-0x7.9p+1));
            (*l_221) = (l_183 != (void*)0);
        }
        if (l_122)
            break;
    }
    return p_90;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 111
XXX total union variables: 0

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 21
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2

XXX total number of pointers: 89

XXX times a variable address is taken: 77
XXX times a pointer is dereferenced on RHS: 46
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 49
breakdown:
   depth: 1, occurrence: 38
   depth: 2, occurrence: 7
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 465

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 103
   level: 2, occurrence: 68
   level: 3, occurrence: 46
   level: 4, occurrence: 18
XXX number of pointers point to pointers: 27
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 28.1
XXX average alias set size: 1.18

XXX times a non-volatile is read: 372
XXX times a non-volatile is write: 137
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 98
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 11
   depth: 2, occurrence: 18
   depth: 3, occurrence: 16
   depth: 4, occurrence: 14
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 10.9
XXX percentage an existing variable is used: 89.1
********************* end of statistics **********************/

