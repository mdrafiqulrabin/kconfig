/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      649018288
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const signed f0 : 6;
   signed f1 : 3;
   const unsigned f2 : 25;
   signed f3 : 1;
   unsigned f4 : 12;
   const unsigned f5 : 19;
   unsigned f6 : 5;
   unsigned f7 : 6;
   const signed f8 : 18;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_27(void);
inline static int16_t  func_34(float  p_35, const uint16_t  p_36);
static uint16_t  func_45(int32_t  p_46, int32_t  p_47, int16_t  p_48);
inline static int32_t * func_49(const uint32_t  p_50, const struct S0  p_51, const int32_t * p_52, uint16_t  p_53, uint32_t  p_54);
static int32_t  func_64(const int32_t * p_65, int32_t  p_66);
static float  func_75(uint32_t  p_76, uint16_t  p_77);
inline static float  func_85(int32_t * p_86);
inline static uint32_t  func_91(uint32_t  p_92);
inline static uint32_t  func_103(struct S0  p_104, float  p_105, int32_t * p_106, int32_t * p_107, int32_t * p_108);
static struct S0  func_109(int32_t  p_110, uint32_t  p_111, int16_t  p_112);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_27(void)
{ /* block id: 36 */
    float l_28 = 0xA.7B722Bp-5;
    int32_t l_29 = (-1);
    int32_t l_718 = (-1);
    int16_t l_729 = 6;
    struct S0 l_735 = {-0,-0,200,0,41,705,2,6,-154};
    struct S0 *l_734 = &l_735;
    struct S0 **l_736 = &l_734;
    if (__builtin_popcountl(l_29))
    { /* block id: 37 */
        uint32_t l_40 = 1U;
        float *l_721 = (void*)0;
        float *l_722 = (void*)0;
        int32_t l_723 = 0x1E10E040;
        struct S0 l_724 = {3,1,5050,-0,6,542,0,0,-476};
        uint32_t l_725 = 0xE6B64325;
        float l_726 = (-0x1.Cp+1);
        int32_t *l_730 = (void*)0;
        int32_t *l_731 = (void*)0;
        int32_t *l_732 = &l_723;
        for (l_29 = 0; (l_29 <= (-17)); --l_29)
        { /* block id: 40 */
            float l_39 = 0x0.Ap-1;
            int32_t l_42 = 1;
            int32_t l_709 = 1;
            int32_t *l_714 = (void*)0;
            l_42 = ((int16_t)func_34(((float)(l_39 <= (l_40 < l_40)) - (float)(!l_42)), (((uint16_t)func_45((1U ^ l_42), l_42, l_42) - (uint16_t)l_709) & 0x404E)) << (int16_t)l_40);
        }
        l_723 = ((float)__builtin_ia32_crc32qi(l_40, (-(uint16_t)(0xC97F < l_29))) - (float)((l_718 >= l_718) <= ((float)(-0x9.Bp-1) + (float)l_718)));
        (*l_732) = (func_103(l_724, l_725, func_49(l_29, func_109((func_103(func_109(func_45(l_29, l_29, (l_724.f8 || 0x1701C035)), ((uint16_t)((l_29 == 4294967295U) || l_718) << (uint16_t)12), l_724.f8), l_724.f6, &l_718, &l_29, &l_723) || 0xD98CBB09), l_29, l_718), &l_718, l_725, l_729), &l_29, &l_723) != l_718);
    }
    else
    { /* block id: 566 */
        uint16_t l_733 = 65535U;
        return l_733;
    }
    (*l_736) = l_734;
    return l_735.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_34(float  p_35, const uint16_t  p_36)
{ /* block id: 559 */
    const int16_t l_712 = 3;
    float l_713 = (-0x9.Fp+1);
    l_713 = ((float)l_712 + (float)p_35);
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(int32_t  p_46, int32_t  p_47, int16_t  p_48)
{ /* block id: 41 */
    const int32_t l_55 = 0xFEC1E183;
    const int32_t l_68 = 1;
    const int32_t *l_67 = &l_68;
    int32_t **l_708 = (void*)0;
    if (p_47)
    { /* block id: 42 */
        return p_46;
    }
    else
    { /* block id: 44 */
        const struct S0 l_56 = {-7,-1,2254,0,49,533,1,7,-161};
        const int32_t *l_57 = (void*)0;
        const int32_t **l_707 = &l_67;
        (*l_707) = func_49(l_55, l_56, l_57, ((int16_t)((void*)0 == l_57) - (int16_t)(((&p_46 == (void*)0) >= ((int16_t)((((int32_t)func_64(l_67, (p_48 == p_46)) - (int32_t)p_46) == l_56.f2) >= (*l_67)) >> (int16_t)p_46)) < (*l_67))), p_46);
        /* statement id: 555 */
        assert (l_67 == 0);
    }
    /* facts after branching */
    assert (l_67 == 0);
    l_67 = &p_46;
    /* statement id: 557 */
    assert (l_67 == &p_46);
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_49(const uint32_t  p_50, const struct S0  p_51, const int32_t * p_52, uint16_t  p_53, uint32_t  p_54)
{ /* block id: 532 */
    int32_t *l_687 = (void*)0;
    uint32_t l_688 = 0x1F77DABD;
    struct S0 *l_699 = (void*)0;
    float l_703 = 0xC.B0F128p+80;
    p_52 = l_687;
    /* statement id: 533 */
    assert (p_52 == 0);
    if (l_688)
    { /* block id: 534 */
        uint16_t l_689 = 0U;
        int32_t l_691 = 6;
        int32_t *l_690 = &l_691;
        int32_t **l_692 = &l_690;
        float l_696 = 0x7.6DF990p+93;
        float *l_695 = &l_696;
        (*l_690) = l_689;
        if (l_688)
            goto lbl_693;
lbl_693:
        (*l_692) = &l_691;
        (*l_695) = (-(float)l_688);
        (*l_695) = ((**l_692) <= 0x8.91BA2Bp+82);
    }
    else
    { /* block id: 540 */
        int32_t l_702 = (-6);
        int32_t *l_701 = &l_702;
        for (p_53 = (-26); (p_53 >= 42); p_53 += 9)
        { /* block id: 543 */
            struct S0 **l_700 = &l_699;
            (*l_700) = l_699;
        }
        l_701 = l_687;
        /* statement id: 546 */
        assert (l_701 == 0);
        l_703 = l_688;
    }
    for (p_53 = 6; (p_53 < 8); p_53 += 3)
    { /* block id: 551 */
        int32_t l_706 = 0xD1BE7D6B;
        l_706 = p_51.f3;
    }
    return l_687;
    /* statement id: 554 */
    //assert (func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_64(const int32_t * p_65, int32_t  p_66)
{ /* block id: 45 */
    int32_t l_72 = 0x104E0BBE;
    int32_t *l_71 = &l_72;
    uint32_t l_684 = 0xC8F2F155;
    float l_686 = 0x1.Bp-1;
    float *l_685 = &l_686;
    (*l_685) = (0xC.EA44E0p+11 > ((((float)(l_71 == &l_72) - (float)p_66) == ((((*l_71) > (*l_71)) != ((*l_71) >= ((float)((*l_71) >= ((func_75((0xF696 || p_66), (*l_71)) < (-0x1.Cp-1)) >= 0x8.6p-1)) + (float)0x5.9B2D59p-33))) <= p_66)) >= l_684));
    return (*p_65);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_75(uint32_t  p_76, uint16_t  p_77)
{ /* block id: 46 */
    int32_t l_81 = 2;
    struct S0 l_675 = {3,-1,5232,0,27,144,1,2,423};
    struct S0 *l_674 = &l_675;
    const float l_679 = 0xF.E08858p+8;
    const float *l_678 = &l_679;
    const float **l_677 = &l_678;
    float l_683 = 0x0.Cp-1;
    float *l_682 = &l_683;
    for (p_77 = 11; (p_77 != 38); p_77 += 9)
    { /* block id: 49 */
        uint32_t l_82 = 0U;
        float *l_669 = (void*)0;
        float l_671 = 0x2.1E9FD6p-46;
        float *l_670 = &l_671;
        l_81 = (-(float)(l_81 == (((0x7.35ED35p-39 <= (p_76 >= (-0x1.3p+1))) <= l_82) >= ((float)l_82 - (float)func_85(&l_81)))));
        (*l_670) = l_82;
    }
    for (p_77 = (-16); (p_77 <= 52); p_77 += 6)
    { /* block id: 524 */
        struct S0 *l_676 = (void*)0;
        l_676 = l_674;
        /* statement id: 525 */
        assert (l_676 == &l_675);
    }
    (*l_682) = (__builtin_popcountl((p_76 >= (((void*)0 != l_677) && ((int16_t)p_76 % (int16_t)p_76)))) <= p_77);
    l_675.f1 = (p_76 | 65535U);
    return l_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_85(int32_t * p_86)
{ /* block id: 50 */
    float l_89 = (-0x1.2p-1);
    int32_t l_98 = (-1);
    int32_t l_252 = 3;
    int32_t *l_251 = &l_252;
    struct S0 l_285 = {7,0,4824,-0,10,689,2,1,-347};
    struct S0 *l_284 = &l_285;
    int32_t **l_300 = (void*)0;
    int32_t ***l_299 = &l_300;
    float l_397 = (-0x1.Bp+1);
    uint32_t l_399 = 0xC7C98F07;
    float l_440 = 0x1.Dp+1;
    int32_t ***l_512 = (void*)0;
    float *l_544 = &l_89;
    float * const *l_543 = &l_544;
    float * const **l_542 = &l_543;
    float * const ***l_541 = &l_542;
    int32_t l_593 = (-1);
    int32_t l_594 = 0xCA8E30B5;
    if ((*p_86))
    { /* block id: 51 */
        uint32_t l_90 = 1U;
        int32_t *l_242 = &l_98;
        uint32_t l_245 = 0xAD5EC58B;
        int32_t ** const *l_249 = (void*)0;
        int32_t ** const **l_248 = &l_249;
        const int32_t *l_265 = &l_252;
        const int32_t * const *l_264 = &l_265;
        const int32_t * const ** const l_263 = &l_264;
        struct S0 l_283 = {2,0,2123,0,15,613,4,2,178};
        struct S0 *l_282 = &l_283;
        uint16_t l_288 = 0xC960;
        uint32_t l_303 = 0xF4312185;
        int32_t *l_315 = &l_98;
        int32_t l_339 = 0xF890D4C2;
        uint32_t l_348 = 0xBE8F8155;
        float *l_350 = &l_89;
        float **l_349 = &l_350;
        float ***l_383 = &l_349;
        float ****l_382 = &l_383;
        int16_t l_386 = (-7);
        int32_t **l_387 = (void*)0;
        if (((uint16_t)l_90 + (uint16_t)(func_91(((uint32_t)l_90 - (uint32_t)l_90)) < ((~((l_98 & ((int16_t)(7U >= (-(int32_t)(~(l_90 >= (func_103(func_109(l_90, l_90, l_90), l_90, p_86, &l_98, p_86) | 0xD84902EF))))) << (int16_t)l_90)) < l_98)) || l_90))))
        { /* block id: 154 */
            uint16_t l_257 = 65530U;
            int32_t l_258 = 0x4F3E2910;
            int32_t **l_271 = &l_242;
            int32_t ***l_270 = &l_271;
            int32_t ****l_269 = &l_270;
            int32_t *****l_304 = &l_269;
            struct S0 l_316 = {-5,1,3626,-0,33,426,3,2,-147};
            uint32_t l_318 = 1U;
            if (l_90)
            { /* block id: 155 */
                int32_t *l_226 = (void*)0;
                int32_t *l_227 = &l_98;
                (*l_227) = 0;
                return l_98;
            }
            else
            { /* block id: 158 */
                struct S0 *l_228 = (void*)0;
                int32_t l_241 = 0x044EFE06;
                int32_t ** const **l_250 = &l_249;
                l_228 = l_228;
                for (l_98 = (-5); (l_98 == 14); l_98 += 1)
                { /* block id: 162 */
                    struct S0 *l_236 = (void*)0;
                    for (l_90 = 14; (l_90 == 41); l_90 += 9)
                    { /* block id: 165 */
                        float *l_233 = &l_89;
                        int32_t *l_235 = &l_98;
                        int32_t **l_234 = &l_235;
                        (*l_233) = (-0x2.Fp-1);
                        (*l_234) = p_86;
                        /* statement id: 167 */
                        //assert (l_235 == &l_81);
                    }
                    if (((l_236 == l_236) && 0x43946F77))
                    { /* block id: 169 */
                        int32_t *l_238 = &l_98;
                        int32_t **l_237 = &l_238;
                        float *l_239 = &l_89;
                        (*l_237) = p_86;
                        /* statement id: 170 */
                        //assert (l_238 == &l_81);
                        (*l_239) = (*l_238);
                        if ((*p_86))
                            break;
                        (*l_237) = p_86;
                    }
                    else
                    { /* block id: 174 */
                        struct S0 l_240 = {4,-1,320,0,45,268,4,7,349};
                        int32_t *l_243 = (void*)0;
                        int32_t *l_244 = (void*)0;
                        int32_t *l_246 = &l_241;
                        int32_t **l_247 = &l_246;
                        l_245 = func_103(l_240, (l_241 == (p_86 != p_86)), p_86, p_86, l_242);
                        (*l_246) = ((*p_86) == l_241);
                        (*l_247) = l_244;
                        /* statement id: 177 */
                        assert (l_246 == 0);
                        (*l_247) = l_242;
                        /* statement id: 178 */
                        assert (l_246 == &l_98);
                    }
                    l_250 = l_248;
                    l_251 = p_86;
                    /* statement id: 181 */
                    //assert (l_251 == &l_81);
                }
                /* facts after for loop */
                //assert (l_251 == &l_81 || l_251 == &l_252);
                for (l_90 = 0; (l_90 >= 23); l_90++)
                { /* block id: 185 */
                    for (l_98 = 13; (l_98 > (-12)); l_98 -= 2)
                    { /* block id: 188 */
                        return l_257;
                    }
                }
            }
            /* facts after branching */
            //assert (l_251 == &l_81 || l_251 == &l_252);
            l_258 = 0x0.Cp+1;
            if (__builtin_popcount(((uint16_t)65529U >> (uint16_t)4)))
            { /* block id: 194 */
                float *l_261 = &l_89;
                int32_t **l_262 = (void*)0;
                (*l_261) = ((void*)0 != &l_251);
                l_242 = p_86;
                /* statement id: 196 */
                //assert (l_242 == &l_81);
                return (*l_242);
            }
            else
            { /* block id: 198 */
                uint32_t l_266 = 1U;
                int32_t l_272 = 1;
                int32_t *l_273 = &l_258;
                const int32_t **** const l_276 = (void*)0;
                struct S0 l_296 = {-5,0,5108,-0,31,657,3,1,32};
                l_266 = (((void*)0 != l_263) <= 0x0.Cp-1);
                if (((uint16_t)(((-1) > ((void*)0 != l_269)) != (__builtin_clzll((*l_251)) <= ((**l_271) & ((**l_264) && 0xA1A6AEE2)))) << (uint16_t)((((***l_263) >= 0xD1BF06AC) || 1U) && 1U)))
                { /* block id: 200 */
                    l_272 = ((void*)0 == &l_249);
                    (*l_271) = (void*)0;
                    /* statement id: 202 */
                    assert (l_242 == 0);
                }
                else
                { /* block id: 203 */
                    l_273 = p_86;
                    /* statement id: 204 */
                    //assert (l_273 == &l_81);
                    for (l_98 = (-16); (l_98 < (-16)); l_98 += 1)
                    { /* block id: 207 */
                        int32_t *l_277 = &l_252;
                        float *l_286 = (void*)0;
                        float *l_287 = &l_89;
                        (*l_277) = (&l_249 == l_276);
                        (*l_287) = ((float)(*l_277) - (float)(((float)(l_282 != l_284) + (float)(*l_265)) >= ((void*)0 == &l_285)));
                    }
                    if (l_288)
                    { /* block id: 211 */
                        int32_t l_297 = 0xDD1E5A38;
                        float *l_298 = &l_89;
                        (*l_298) = (((float)(**l_264) + (float)((float)(__builtin_parityll((****l_269)) != (**l_271)) + (float)(**l_264))) <= (((float)(-(float)func_103(l_296, (**l_271), p_86, p_86, p_86)) - (float)l_297) < 0xD.BB388Ep-11));
                        (**l_271) = (0x1F9259F1 & ((*l_269) != l_299));
                    }
                    else
                    { /* block id: 214 */
                        uint16_t l_301 = 0x184D;
                        float *l_302 = &l_89;
                        (*l_302) = (l_301 == 0x8.9BA08Dp-56);
                        (*l_302) = l_301;
                    }
                    (***l_270) = ((void*)0 != (*l_248));
                }
                /* facts after branching */
                assert (l_242 == &l_98 || l_242 == 0);
                //assert (l_273 == &l_81 || l_273 == &l_258);
                l_98 = 0xBCA7656A;
                if (l_303)
                { /* block id: 221 */
                    uint32_t l_305 = 0x562396B6;
                    struct S0 *l_308 = &l_285;
                    l_304 = &l_269;
                    l_296.f1 = l_305;
lbl_311:
                    for (l_305 = 0; (l_305 < 51); ++l_305)
                    { /* block id: 226 */
                        struct S0 **l_309 = &l_284;
                        int32_t l_310 = 0x442EEB04;
                        (*l_309) = l_308;
                        l_310 = (-1);
                        if (l_296.f8)
                            goto lbl_311;
                        (*l_271) = p_86;
                        /* statement id: 229 */
                        //assert (l_242 == &l_81);
                    }
                    return l_305;
                }
                else
                { /* block id: 233 */
                    int32_t *l_312 = &l_272;
                    struct S0 *l_313 = &l_283;
                    struct S0 **l_314 = &l_284;
                    p_86 = l_312;
                    /* statement id: 234 */
                    assert (p_86 == &l_272);
                    (*l_314) = l_313;
                    /* statement id: 235 */
                    assert (l_284 == &l_283);
                    (*l_315) = func_103((**l_314), (*l_312), l_312, p_86, l_315);
                    (**l_270) = p_86;
                    /* statement id: 237 */
                    assert (l_242 == &l_272);
                }
                /* facts after branching */
                assert (p_86 == &l_272);
                assert (l_242 == &l_272);
                assert (l_284 == &l_283);
            }
            /* facts after branching */
            //assert (p_86 == dangling);
            //assert (l_242 == dangling);
            assert (l_284 == &l_283);
            if ((**l_264))
            { /* block id: 240 */
                int32_t *l_317 = &l_258;
                (*l_317) = ((func_103(l_316, (**l_264), l_317, l_317, l_317) || ((*l_265) > l_318)) ^ ((uint32_t)(&l_282 != (void*)0) % (uint32_t)(*l_317)));
                (**l_270) = &l_98;
                /* statement id: 242 */
                assert (l_242 == &l_98);
            }
            else
            { /* block id: 243 */
                uint16_t l_323 = 0x23D8;
                int32_t **l_324 = &l_242;
                int32_t l_325 = (-4);
                for (l_90 = 9; (l_90 >= 26); l_90++)
                { /* block id: 246 */
                    l_323 = ((-1) | (*l_315));
                }
                (*l_324) = (**l_263);
                /* statement id: 249 */
                assert (l_242 == &l_252);
                return l_325;
            }
            /* facts after branching */
            assert (l_242 == &l_98);
        }
        else
        { /* block id: 252 */
            int16_t l_328 = (-1);
            struct S0 l_338 = {-3,-1,5301,-0,61,182,0,4,505};
            int32_t l_365 = 3;
            int32_t *l_381 = &l_98;
        }
        /* facts after branching */
        //assert (p_86 == &l_81 || p_86 == dangling);
        //assert (l_251 == &l_81 || l_251 == &l_252);
        assert (l_284 == &l_285 || l_284 == &l_283);
        (*l_382) = &l_349;
        if ((*l_251))
        { /* block id: 288 */
            uint32_t l_384 = 0xBB0ED486;
            l_384 = 0x196AC040;
        }
        else
        { /* block id: 290 */
            int32_t *l_385 = &l_252;
            l_385 = &l_252;
            l_386 = (***l_263);
        }
        l_265 = (*l_264);
    }
    else
    { /* block id: 295 */
        int32_t l_388 = 9;
        struct S0 l_391 = {4,-0,3125,-0,43,80,0,4,33};
        float **l_432 = (void*)0;
        float ***l_431 = &l_432;
        int32_t ****l_438 = &l_299;
        int32_t ***** const l_437 = &l_438;
        int32_t *****l_439 = (void*)0;
        const int32_t *l_445 = (void*)0;
        const int32_t **l_444 = &l_445;
        const int32_t ***l_443 = &l_444;
        const int32_t ****l_442 = &l_443;
        const int32_t *****l_441 = &l_442;
        int16_t l_492 = 0xA36D;
        int32_t l_520 = 0;
        float l_553 = 0x0.Cp+1;
        if (__builtin_bswap64(l_388))
        { /* block id: 296 */
            int16_t l_392 = 0x933D;
            int32_t *l_393 = &l_98;
            float *l_394 = &l_89;
            const int32_t *****l_436 = (void*)0;
            uint16_t l_495 = 65528U;
            int32_t * const l_497 = (void*)0;
            float ****l_503 = &l_431;
            const int32_t *l_506 = &l_252;
            (*l_394) = ((float)(0xB.9143F4p+55 > (func_103(l_391, l_392, l_393, p_86, p_86) < (*l_393))) - (float)(l_388 >= (-0x1.7p+1)));
            if (((int32_t)(-1) - (int32_t)(l_391.f3 <= (*l_251))))
            { /* block id: 298 */
                int32_t **l_398 = &l_393;
                struct S0 **l_400 = (void*)0;
                struct S0 **l_401 = &l_284;
                float ***l_420 = (void*)0;
                float ****l_419 = &l_420;
                float *****l_418 = &l_419;
                (*l_398) = p_86;
                /* statement id: 299 */
                //assert (l_393 == &l_81);
                (*l_394) = l_399;
                (*l_401) = &l_285;
                if ((**l_398))
                { /* block id: 302 */
                    float l_410 = (-0x10.Ap+1);
                    int32_t l_411 = 0;
                    struct S0 l_413 = {-6,0,4121,-0,61,616,4,5,-306};
                    (*l_398) = p_86;
                    (*l_394) = ((void*)0 == (*l_401));
                    (*l_251) = ((-1) & ((((int16_t)(((((uint16_t)l_391.f7 << (uint16_t)((uint32_t)(**l_398) + (uint32_t)((uint16_t)((((**l_398) || l_391.f0) == l_411) | l_391.f5) >> (uint16_t)3))) & (-(int32_t)(*p_86))) | func_103(l_413, (**l_398), p_86, p_86, p_86)) > 0xC1116C56) + (int16_t)(**l_398)) >= l_413.f5) == 8U));
                    (*l_394) = ((((l_413.f1 >= l_391.f2) > (l_391.f8 != l_391.f3)) <= l_413.f2) < (*l_393));
                }
                else
                { /* block id: 307 */
                    float **l_417 = &l_394;
                    float ***l_416 = &l_417;
                    float ****l_415 = &l_416;
                    float *****l_414 = &l_415;
                    l_418 = l_414;
                    /* statement id: 308 */
                    assert (l_418 == &l_415);
                }
                /* facts after branching */
                //assert (l_418 == dangling || l_418 == &l_419);
            }
            else
            { /* block id: 310 */
                int16_t l_421 = 0xD22A;
                int32_t *l_478 = &l_252;
                int32_t l_489 = 0x138F6F16;
                int32_t ***l_491 = &l_300;
                if (func_91(l_421))
                { /* block id: 311 */
                    int32_t **l_422 = &l_251;
                    float *** const l_433 = &l_432;
                    (*l_422) = l_393;
                    /* statement id: 312 */
                    assert (l_251 == &l_98);
                    if ((!__builtin_ffsl(l_391.f0)))
                    { /* block id: 313 */
                        uint32_t l_428 = 1U;
                        (*l_393) = ((*p_86) ^ ((((int16_t)l_391.f2 >> (int16_t)((int16_t)l_428 >> (int16_t)(func_91(((int32_t)0x1A81AF41 - (int32_t)((l_431 != l_433) == ((((int32_t)((**l_422) || 4U) - (int32_t)(l_436 == l_437)) ^ l_428) || (**l_422))))) || l_428))) ^ l_428) != 0x6380));
                    }
                    else
                    { /* block id: 315 */
                        int32_t l_452 = 0xCB0F604B;
                        l_439 = &l_438;
                        /* statement id: 316 */
                        assert (l_439 == &l_438);
                        (*l_251) = ((**l_422) && ((*p_86) != (*p_86)));
                        l_441 = l_436;
                        /* statement id: 318 */
                        assert (l_441 == 0);
                        (*l_393) = (+(((uint16_t)((**l_422) && (-4)) << (uint16_t)1) | ((~l_421) >= (((((uint32_t)l_452 + (uint32_t)((**l_422) || (~l_421))) | (**l_422)) && l_421) >= 0x0BD4))));
                    }
                    /* facts after branching */
                    assert (l_439 == &l_438 || l_439 == 0);
                    assert (l_441 == 0 || l_441 == &l_442);
                }
                else
                { /* block id: 321 */
                    int32_t l_471 = 0xC092EF31;
                    struct S0 l_477 = {1,-0,1646,0,46,214,1,4,399};
                    (*l_393) = ((uint16_t)(((uint16_t)(!((((uint32_t)((int32_t)((uint16_t)__builtin_clzl((((uint16_t)65531U - (uint16_t)((uint32_t)((int32_t)__builtin_ia32_crc32qi(l_471, l_471) + (int32_t)(*p_86)) - (uint32_t)(&l_284 != (void*)0))) && l_421)) << (uint16_t)l_421) % (int32_t)l_421) + (uint32_t)0x7E0959EE) < (*p_86)) | 0x718A48E0)) >> (uint16_t)13) ^ (*l_393)) - (uint16_t)l_421);
                    for (l_471 = 22; (l_471 > (-17)); l_471 -= 6)
                    { /* block id: 325 */
                        int32_t *l_474 = &l_252;
                        l_474 = l_474;
                        (*l_394) = (func_91((((int16_t)func_103(l_477, (*l_393), l_478, p_86, p_86) % (int16_t)((int16_t)(*l_393) - (int16_t)((*l_474) | l_477.f4))) <= 0x7936)) > l_477.f2);
                        return l_477.f0;
                    }
                }
                /* facts after branching */
                assert (l_251 == &l_252 || l_251 == &l_98);
                assert (l_439 == &l_438 || l_439 == 0);
                assert (l_441 == 0 || l_441 == &l_442);
                if (func_103(l_391, (*l_478), p_86, p_86, l_478))
                { /* block id: 331 */
                    const struct S0 *l_483 = (void*)0;
                    int32_t *l_486 = (void*)0;
                    int32_t l_496 = 9;
                    if (((uint32_t)0U - (uint32_t)(*p_86)))
                    { /* block id: 332 */
                        struct S0 **l_484 = &l_284;
                        int32_t *l_485 = &l_98;
                        (*l_484) = l_483;
                        /* statement id: 333 */
                        assert (l_284 == 0);
                        (*l_444) = l_485;
                        /* statement id: 334 */
                        assert (l_445 == &l_98);
                        (***l_442) = p_86;
                        /* statement id: 335 */
                        //assert (l_445 == &l_81);
                        (*l_444) = l_486;
                        /* statement id: 336 */
                        assert (l_445 == 0);
                    }
                    else
                    { /* block id: 337 */
                        int32_t ***l_490 = &l_300;
                        int32_t **l_498 = &l_251;
                        (*l_478) = func_91(((l_489 & (l_490 != l_491)) != (((l_492 != (*l_393)) || (*l_393)) >= ((int32_t)((((-2) < (*l_393)) < l_495) & l_496) + (int32_t)0U))));
                        (*l_393) = (*p_86);
                        (*l_498) = l_497;
                        /* statement id: 340 */
                        assert (l_251 == 0);
                        l_486 = &l_496;
                        /* statement id: 341 */
                        assert (l_486 == &l_496);
                    }
                    /* facts after branching */
                    assert (l_251 == 0 || l_251 == &l_252 || l_251 == &l_98);
                    assert (l_284 == &l_285 || l_284 == 0);
                    assert (l_486 == &l_496 || l_486 == 0);
                }
                else
                { /* block id: 343 */
                    int16_t l_504 = 0x3057;
                    int32_t *l_505 = &l_98;
                    (*l_251) = (~((uint16_t)(*l_478) + (uint16_t)(-(uint32_t)((l_503 != (void*)0) == l_504))));
                    (**l_443) = l_505;
                    /* statement id: 345 */
                    assert (l_445 == &l_98);
                }
                /* facts after branching */
                assert (l_251 == 0 || l_251 == &l_252 || l_251 == &l_98);
                assert (l_284 == &l_285 || l_284 == 0);
                assert (l_445 == &l_98 || l_445 == 0);
            }
            /* facts after branching */
            assert (l_251 == 0 || l_251 == &l_252 || l_251 == &l_98);
            assert (l_284 == &l_285 || l_284 == 0);
            //assert (l_393 == &l_98 || l_393 == &l_81);
            assert (l_439 == &l_438 || l_439 == 0);
            assert (l_445 == &l_98 || l_445 == 0);
            assert (l_441 == 0 || l_441 == &l_442);
            l_506 = (*l_444);
            /* statement id: 348 */
            assert (l_506 == &l_98 || l_506 == 0);
            l_391.f3 = 0;
        }
        else
        { /* block id: 350 */
            int32_t * const *l_508 = &l_251;
            int32_t * const **l_507 = &l_508;
            int32_t *l_509 = &l_98;
            const float *** const *l_545 = (void*)0;
            uint32_t l_572 = 0x88E1740D;
            uint16_t l_582 = 65535U;
            if ((l_507 == (void*)0))
            { /* block id: 351 */
                uint32_t l_514 = 0U;
                int32_t *l_516 = &l_252;
                if (func_103((*l_284), (***l_507), p_86, p_86, l_509))
                { /* block id: 352 */
                    float l_515 = 0xC.8723A0p-66;
                    int32_t l_518 = (-6);
                    for (l_492 = 0; (l_492 > (-10)); l_492--)
                    { /* block id: 355 */
                        int16_t l_513 = (-1);
                        (*l_438) = l_512;
                        /* statement id: 356 */
                        assert (l_299 == 0);
                        (***l_507) = l_513;
                        return l_514;
                    }
                    if (l_399)
                        goto lbl_517;
lbl_517:
                    (***l_507) = func_103((*l_284), l_515, l_516, p_86, l_516);
                    (*l_509) = (((*l_299) != &p_86) & l_518);
                }
                else
                { /* block id: 363 */
                    const int32_t **l_519 = &l_445;
                    float *l_521 = &l_440;
                    (*l_519) = (**l_507);
                    /* statement id: 364 */
                    assert (l_445 == &l_252);
                    (*l_521) = l_520;
                }
                /* facts after branching */
                assert (l_445 == &l_252 || l_445 == 0);
                for (l_514 = 0; (l_514 != 45); ++l_514)
                { /* block id: 369 */
                    uint16_t l_524 = 0x0EF6;
                    return l_524;
                }
            }
            else
            { /* block id: 372 */
                int16_t l_533 = 0x24CA;
                int16_t l_540 = 0x6688;
                for (l_520 = (-5); (l_520 > (-23)); l_520 -= 7)
                { /* block id: 375 */
                    int32_t l_527 = 2;
                    if (l_527)
                    { /* block id: 376 */
                        uint32_t l_528 = 0xE28E9320;
                        return l_528;
                    }
                    else
                    { /* block id: 378 */
                        float l_534 = 0x7.FDB46Ap+40;
                        int32_t l_539 = 0xB87A49A5;
                        (**l_508) = ((int16_t)((int16_t)l_533 - (int16_t)(**l_508)) << (int16_t)((int32_t)(!(__builtin_clz(((((((-(uint16_t)0x8845) >= (l_539 != (func_91(l_540) == (l_541 == l_545)))) != l_540) & l_540) ^ l_539) <= (*l_251))) > l_539)) % (int32_t)(*p_86)));
                        (**l_443) = (*l_444);
                    }
                    if (__builtin_bswap32((*l_251)))
                    { /* block id: 382 */
                        int32_t **l_546 = &l_251;
                        (*l_546) = (*l_508);
                    }
                    else
                    { /* block id: 384 */
                        return l_527;
                    }
                    if ((*p_86))
                        continue;
                }
            }
            /* facts after branching */
            assert (l_445 == &l_252 || l_445 == 0);
            if ((*p_86))
            { /* block id: 390 */
                float l_547 = (-0x1.2p+1);
                return l_547;
            }
            else
            { /* block id: 392 */
                uint16_t l_550 = 0x521F;
                int32_t l_552 = 0x92EC177A;
                for (l_388 = 0; (l_388 != (-12)); l_388 -= 3)
                { /* block id: 395 */
                    uint32_t l_551 = 4294967295U;
                    l_550 = (**l_508);
                    l_552 = (l_551 | (*p_86));
                }
            }
            if ((*p_86))
            { /* block id: 400 */
                uint32_t l_558 = 0x3288B0B0;
                int32_t *l_585 = &l_98;
                int32_t *l_586 = (void*)0;
lbl_556:
                (***l_507) = (-1);
                if (__builtin_popcountl(((*l_507) == (void*)0)))
                { /* block id: 402 */
                    int32_t l_554 = 1;
                    float **** const *l_557 = (void*)0;
                    (***l_507) = (*l_509);
                    if (l_554)
                    { /* block id: 404 */
                        int32_t *l_555 = (void*)0;
                        l_555 = p_86;
                        /* statement id: 405 */
                        //assert (l_555 == &l_81);
                        if (l_391.f0)
                            goto lbl_556;
                        (**l_543) = ((((l_557 == (void*)0) != (l_558 < l_558)) <= (!0x0.Ap-1)) <= ((float)l_558 - (float)((float)((0x6.90BF16p+55 > (*l_555)) != (((float)(((*l_555) > 0x7.1242CAp+82) == (*l_555)) + (float)(*l_555)) == (*l_251))) - (float)l_558)));
                    }
                    else
                    { /* block id: 408 */
                        struct S0 **l_566 = &l_284;
                        float ****l_567 = (void*)0;
                        float ****l_568 = (void*)0;
                        float ****l_569 = &l_431;
                        (*l_566) = &l_285;
                        (*l_569) = &l_432;
                        (****l_541) = l_558;
                        (*l_251) = (0x4100DE2B & l_554);
                    }
                }
                else
                { /* block id: 414 */
                    for (l_520 = 0; (l_520 <= (-29)); --l_520)
                    { /* block id: 417 */
                        return l_572;
                    }
                    (*l_509) = (+(((0xA6DE3D14 || (-1)) ^ l_558) && 4294967295U));
                }
                if (((((-6) || (((0x886C669D < l_558) || (((uint32_t)((int16_t)(((uint16_t)((*l_541) == (void*)0) << (uint16_t)l_558) >= (***l_507)) << (int16_t)13) % (uint32_t)(*p_86)) != 2)) != (*l_509))) || 0xB96DCF82) == l_558))
                { /* block id: 422 */
                    for (l_399 = 0; (l_399 != 34); l_399 += 1)
                    { /* block id: 425 */
                        (*l_444) = p_86;
                        /* statement id: 426 */
                        //assert (l_445 == &l_81);
                    }
                    /* facts after for loop */
                    //assert (l_445 == &l_81 || l_445 == &l_252 || l_445 == 0);
lbl_588:
                    p_86 = p_86;
                }
                else
                { /* block id: 429 */
                    uint16_t l_583 = 65526U;
                    int32_t *l_584 = (void*)0;
                    if ((l_582 >= l_583))
                    { /* block id: 430 */
                        return l_583;
                    }
                    else
                    { /* block id: 432 */
                        (*l_444) = l_584;
                        /* statement id: 433 */
                        assert (l_445 == 0);
                    }
                    /* facts after branching */
                    assert (l_445 == 0);
                    if ((0xE51F && (l_558 < (*l_251))))
                    { /* block id: 435 */
                        (*l_585) = (l_585 == (void*)0);
                        (***l_542) = 0x0.4p+1;
                        (**l_443) = p_86;
                        /* statement id: 438 */
                        //assert (l_445 == &l_81);
                        (***l_442) = p_86;
                    }
                    else
                    { /* block id: 440 */
                        float **l_587 = &l_544;
                        (*l_509) = (*p_86);
                        (*l_444) = l_586;
                        (*l_509) = (l_587 != (void*)0);
                        if (l_252)
                            goto lbl_588;
                    }
                    /* facts after branching */
                    //assert (l_445 == 0 || l_445 == &l_81);
                }
                /* facts after branching */
                //assert (l_445 == &l_81 || l_445 == &l_252 || l_445 == 0);
            }
            else
            { /* block id: 447 */
                float l_589 = 0xD.A51B17p-22;
                int32_t l_590 = 0xCB5F3D00;
                (****l_441) = p_86;
                /* statement id: 448 */
                //assert (l_445 == &l_81);
                (***l_507) = ((0x5DA5AEA2 ^ (**l_508)) == l_590);
            }
            /* facts after branching */
            //assert (l_445 == &l_81 || l_445 == &l_252 || l_445 == 0);
        }
        /* facts after branching */
        assert (l_251 == 0 || l_251 == &l_252 || l_251 == &l_98);
        assert (l_284 == &l_285 || l_284 == 0);
        assert (l_439 == &l_438 || l_439 == 0);
        //assert (l_445 == &l_81 || l_445 == &l_252 || l_445 == 0 || l_445 == &l_98);
        assert (l_441 == 0 || l_441 == &l_442);
        (****l_541) = ((((((l_285.f4 > (0x0.Bp-1 < 0x9.17FAE1p+24)) != l_285.f2) < l_285.f0) == ((0x0.1p-1 == (((float)l_285.f0 + (float)((l_285.f5 >= (0x5.34E4AAp-70 != 0xB.C252D4p-28)) < 0x8.B74EBBp+20)) >= 0x1.B71CA1p-3)) != 0x2.F462ABp+93)) < l_593) >= l_285.f1);
        return l_594;
    }
    /* facts after branching */
    //assert (p_86 == &l_81 || p_86 == dangling);
    //assert (l_251 == &l_81 || l_251 == &l_252);
    //assert (l_284 == &l_285 || l_284 == dangling);
    if ((*l_251))
    { /* block id: 455 */
        uint32_t l_595 = 4294967295U;
        int32_t l_596 = 0x7C87E3B5;
        int32_t **l_597 = &l_251;
        int32_t *l_598 = (void*)0;
        l_596 = l_595;
        (*l_597) = &l_98;
        /* statement id: 457 */
        assert (l_251 == &l_98);
        (*l_597) = l_598;
        /* statement id: 458 */
        assert (l_251 == 0);
    }
    else
    { /* block id: 459 */
        float l_601 = (-0x7.1p-1);
        int32_t l_603 = 0x035FF378;
        struct S0 l_617 = {-0,0,2135,0,55,66,4,3,-454};
        int32_t *l_625 = &l_603;
        int32_t **l_657 = &l_251;
        struct S0 **l_667 = (void*)0;
        struct S0 **l_668 = &l_284;
        for (l_98 = 2; (l_98 < (-8)); l_98--)
        { /* block id: 462 */
            uint32_t l_602 = 2U;
            int32_t *l_613 = &l_593;
            float l_651 = 0x1.Ap+1;
            l_603 = l_602;
            for (l_602 = (-29); (l_602 >= 54); ++l_602)
            { /* block id: 466 */
                int32_t *l_606 = &l_252;
                int32_t ***l_624 = &l_300;
                float l_652 = 0x0.2p-1;
                float **l_653 = &l_544;
                (*l_606) = ((void*)0 == &l_603);
                for (l_399 = (-19); (l_399 <= 43); l_399++)
                { /* block id: 470 */
                    struct S0 l_611 = {0,-0,4838,0,45,162,3,3,-475};
                    int32_t *l_614 = &l_98;
                    const float * const *l_650 = (void*)0;
                    const float * const **l_649 = &l_650;
                    const float * const *** const l_648 = &l_649;
                    for (l_593 = (-2); (l_593 > (-1)); l_593 += 9)
                    { /* block id: 473 */
                        uint32_t l_612 = 0x45CD436B;
                        l_603 = ((2 & func_103(l_611, ((__builtin_ctz((l_603 > l_612)) <= l_611.f6) == l_611.f3), l_613, l_606, l_614)) <= 0xE980309A);
                    }
                    if (((uint16_t)((*l_614) ^ (func_103(l_617, (0x1.9p+1 < ((float)(!((float)((!(((&l_300 == l_624) <= (*l_614)) < 0x6.E999B7p+33)) <= func_91((*l_613))) - (float)(-0x1.6p+1))) - (float)(*l_251))), l_625, l_614, l_614) == (*l_613))) + (uint16_t)65527U))
                    { /* block id: 476 */
                        (****l_541) = ((*l_613) == (*l_625));
                    }
                    else
                    { /* block id: 478 */
                        int32_t *l_626 = &l_603;
                        l_626 = l_614;
                        /* statement id: 479 */
                        assert (l_626 == &l_98);
                        l_613 = &l_603;
                        /* statement id: 480 */
                        assert (l_613 == &l_603);
                    }
                    for (l_603 = 0; (l_603 < 2); l_603 += 6)
                    { /* block id: 484 */
                        int32_t **l_629 = &l_613;
                        l_613 = l_613;
                        (*l_629) = &l_603;
                        /* statement id: 486 */
                        assert (l_613 == &l_603);
                    }
                    if ((((__builtin_parityl((((*l_625) > ((int16_t)((((*l_613) ^ ((uint16_t)(*l_613) >> (uint16_t)((((((int16_t)((int16_t)(((int32_t)(*l_251) % (int32_t)(((((int32_t)((uint16_t)(*l_625) >> (uint16_t)7) - (int32_t)(((int16_t)(*l_625) >> (int16_t)6) != ((uint32_t)((void*)0 != l_648) + (uint32_t)(*l_625)))) != (*l_614)) | (*l_614)) ^ (*l_614))) || 0x575A922C) - (int16_t)(-1)) % (int16_t)(*l_251)) ^ (*l_614)) ^ (*l_625)) || (*l_614)) | 1))) != 1U) != (*l_625)) + (int16_t)0x3258)) != 0xE825)) == (*l_606)) | (*l_613)) & (*l_606)))
                    { /* block id: 488 */
                        (*l_542) = l_653;
                    }
                    else
                    { /* block id: 490 */
                        l_611.f1 = __builtin_parity(((0x1438 == 0x552C) && ((*l_625) > ((*l_614) >= (*l_614)))));
                    }
                }
                for (l_603 = 6; (l_603 >= 12); l_603 += 2)
                { /* block id: 496 */
                    int32_t **l_656 = &l_613;
                    (****l_541) = 0xD.81E990p+60;
                    (*l_656) = l_613;
                }
            }
            /* facts after for loop */
            assert (l_613 == &l_603 || l_613 == &l_593);
        }
        (*l_657) = &l_603;
        /* statement id: 502 */
        assert (l_251 == &l_603);
        for (l_593 = 0; (l_593 == (-21)); l_593--)
        { /* block id: 505 */
            (*l_251) = (~((*l_251) ^ 0xA54153A9));
            for (l_98 = (-21); (l_98 > 16); ++l_98)
            { /* block id: 509 */
                const float *l_666 = &l_397;
                const float **l_665 = &l_666;
                const float ***l_664 = &l_665;
                const float ****l_663 = &l_664;
                (*l_625) = ((void*)0 != l_663);
                (*l_657) = (*l_657);
            }
            (**l_543) = ((void*)0 == &l_284);
            if ((*l_251))
                break;
        }
        (*l_668) = &l_285;
        /* statement id: 516 */
        assert (l_284 == &l_285);
    }
    /* facts after branching */
    //assert (l_251 == dangling || l_251 == 0);
    return l_285.f8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_91(uint32_t  p_92)
{ /* block id: 52 */
    uint32_t l_95 = 0x68679DD5;
    int32_t l_96 = 0x801C16B3;
    l_96 = l_95;
    return l_96;
}


/* ------------------------------------------ */
/* 
 * reads : l_81
 * writes:
 */
inline static uint32_t  func_103(struct S0  p_104, float  p_105, int32_t * p_106, int32_t * p_107, int32_t * p_108)
{ /* block id: 62 */
    int32_t l_118 = 9;
    int32_t *l_117 = &l_118;
    int32_t **l_116 = &l_117;
    int32_t ***l_119 = &l_116;
    int32_t l_123 = (-8);
    uint32_t l_136 = 0x59BB015C;
lbl_186:
    (*l_119) = l_116;
    if ((*p_108))
    { /* block id: 64 */
        uint32_t l_124 = 0x29A6A910;
        int32_t ** const *l_131 = &l_116;
        uint16_t l_148 = 65535U;
        int32_t ** const **l_191 = &l_131;
        int32_t ** const ***l_190 = &l_191;
        if (func_91(((p_104.f0 >= ((int16_t)((~(p_104.f3 >= l_123)) | (((***l_119) != l_124) >= l_124)) % (int16_t)((int16_t)((uint16_t)((uint32_t)func_91(p_104.f6) + (uint32_t)((l_131 != (void*)0) >= 0x5DC6)) << (uint16_t)6) << (int16_t)p_104.f0))) != (***l_131))))
        { /* block id: 65 */
            uint32_t l_137 = 0xCEF6A3D7;
            float l_176 = 0x2.Cp-1;
            const float *l_175 = &l_176;
            if (((uint16_t)((((uint16_t)((**l_116) && l_136) + (uint16_t)((p_104.f4 || ((*l_119) == (void*)0)) != l_137)) & ((int16_t)(1U == (***l_131)) + (int16_t)0x62F1)) > p_104.f0) + (uint16_t)p_104.f4))
            { /* block id: 66 */
                return p_104.f5;
            }
            else
            { /* block id: 68 */
                int16_t l_144 = 2;
                int32_t *l_145 = &l_123;
                int32_t *l_164 = &l_118;
                uint32_t l_170 = 4294967294U;
                float *l_177 = &l_176;
                if ((0xED51 > (p_104.f8 | ((int16_t)((int32_t)l_137 - (int32_t)(l_144 >= 0x3B42)) - (int16_t)(&p_106 != &p_107)))))
                { /* block id: 69 */
                    (**l_131) = l_145;
                    /* statement id: 70 */
                    assert (l_117 == &l_123);
                    for (l_123 = 0; (l_123 < (-15)); l_123 -= 3)
                    { /* block id: 73 */
                        const int16_t l_150 = 8;
                        float l_152 = 0x9.1p-1;
                        float *l_151 = &l_152;
                        (**l_119) = p_106;
                        /* statement id: 74 */
                        //assert (l_117 == &l_81 || l_117 == &l_272 || l_117 == &l_258 || l_117 == &l_98 || l_117 == &l_252 || l_117 == &l_593 || l_117 == &l_603 || l_117 == &l_718 || l_117 == 0);
                        l_148 = (-9);
                        (*l_151) = (((void*)0 != &p_107) != (l_137 >= (-(float)l_150)));
                    }
                    /* facts after for loop */
                    //assert (l_117 == &l_81 || l_117 == &l_123 || l_117 == &l_272 || l_117 == &l_258 || l_117 == &l_98 || l_117 == &l_252 || l_117 == &l_593 || l_117 == &l_603 || l_117 == &l_718 || l_117 == 0);
                }
                else
                { /* block id: 78 */
                    int32_t *l_160 = (void*)0;
                    for (l_124 = 29; (l_124 == 59); l_124++)
                    { /* block id: 81 */
                        float l_156 = 0xB.E7324Bp+31;
                        float *l_155 = &l_156;
                        int32_t ****l_159 = &l_119;
                        int32_t *****l_158 = &l_159;
                        (*l_155) = (*l_145);
                    }
                    (*l_116) = p_107;
                    /* statement id: 87 */
                    //assert (l_117 == &l_98 || l_117 == &l_81 || l_117 == &l_272 || l_117 == &l_258 || l_117 == &l_252 || l_117 == &l_29);
                }
                /* facts after branching */
                //assert (l_117 == &l_98 || l_117 == &l_81 || l_117 == &l_123 || l_117 == &l_272 || l_117 == &l_258 || l_117 == &l_252 || l_117 == &l_593 || l_117 == &l_603 || l_117 == &l_29 || l_117 == &l_718 || l_117 == 0);
                for (l_148 = 16; (l_148 >= 21); l_148++)
                { /* block id: 91 */
                    int32_t l_163 = 1;
                    int32_t *l_165 = &l_123;
                    if ((p_104.f1 <= l_163))
                    { /* block id: 92 */
                        return p_104.f4;
                    }
                    else
                    { /* block id: 94 */
                        l_165 = l_164;
                        /* statement id: 95 */
                        assert (l_165 == &l_118);
                    }
                    /* facts after branching */
                    assert (l_165 == &l_118);
                    (*l_116) = l_145;
                    /* statement id: 97 */
                    assert (l_117 == &l_123);
                    p_105 = ((((float)((p_104.f1 > ((float)p_104.f0 - (float)l_170)) <= (((*l_165) < (p_104.f4 == (*l_165))) >= ((0x6.8p-1 != p_104.f5) <= (((float)((*l_165) != 0xD.B569DAp+8) + (float)p_104.f3) == p_104.f0)))) + (float)p_104.f8) >= (*l_164)) >= p_104.f4);
                }
                (*l_177) = ((float)(&p_108 != (void*)0) + (float)(l_175 != (void*)0));
            }
            /* facts after branching */
            //assert (l_117 == &l_98 || l_117 == &l_81 || l_117 == &l_123 || l_117 == &l_272 || l_117 == &l_258 || l_117 == &l_252 || l_117 == &l_593 || l_117 == &l_603 || l_117 == &l_29 || l_117 == &l_718 || l_117 == 0);
            for (l_148 = 0; (l_148 <= 26); ++l_148)
            { /* block id: 104 */
                int32_t *l_180 = (void*)0;
                (*l_116) = l_180;
                /* statement id: 105 */
                assert (l_117 == 0);
            }
            l_123 = ((void*)0 == (**l_119));
        }
        else
        { /* block id: 108 */
            float l_213 = 0xE.FFFD43p-51;
            int32_t l_214 = 0;
            for (l_136 = 0; (l_136 > 41); l_136 += 8)
            { /* block id: 111 */
                int16_t l_194 = 0x895D;
                int32_t l_195 = 0x5FEEA2D5;
                for (l_124 = 7; (l_124 > 25); l_124 += 4)
                { /* block id: 114 */
                    int32_t ***l_185 = &l_116;
                    l_119 = l_185;
                    if (p_104.f1)
                        goto lbl_186;
                }
                for (l_124 = 23; (l_124 >= 52); l_124 += 4)
                { /* block id: 120 */
                    int32_t l_202 = 1;
                    int32_t l_212 = 0;
                }
                (****l_190) = &l_195;
                /* statement id: 132 */
                assert (l_117 == &l_195);
                return p_104.f3;
            }
            return l_214;
        }
        /* facts after branching */
        //assert (l_117 == 0 || l_117 == &l_98 || l_117 == &l_81 || l_117 == &l_123 || l_117 == &l_272 || l_117 == &l_258 || l_117 == &l_252 || l_117 == &l_593 || l_117 == &l_603 || l_117 == &l_29 || l_117 == &l_718);
        (****l_190) = (****l_190);
        return p_104.f2;
    }
    else
    { /* block id: 139 */
        (*l_116) = (**l_119);
    }
    if ((!(((int16_t)(l_117 == l_117) + (int16_t)((((p_104.f7 >= ((int16_t)(l_117 == l_117) >> (int16_t)13)) < 0x4805) != ((uint16_t)((int16_t)(*l_117) + (int16_t)p_104.f7) >> (uint16_t)13)) >= (*l_117))) > 1U)))
    { /* block id: 142 */
        uint32_t l_224 = 0x79E9FF3C;
        if ((*p_107))
        { /* block id: 143 */
            return l_224;
        }
        else
        { /* block id: 145 */
            int16_t l_225 = 8;
            p_108 = p_108;
            return l_225;
        }
    }
    else
    { /* block id: 149 */
        (**l_116) = (*l_117);
        (*l_116) = (void*)0;
        /* statement id: 151 */
        assert (l_117 == 0);
    }
    /* facts after branching */
    assert (l_117 == 0);
    return p_104.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_109(int32_t  p_110, uint32_t  p_111, int16_t  p_112)
{ /* block id: 55 */
    struct S0 l_115 = {4,1,3769,-0,42,60,2,0,41};
    for (p_110 = (-27); (p_110 <= (-14)); p_110 += 1)
    { /* block id: 58 */
        return l_115;
    }
    return l_115;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 214
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 4
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 11
XXX full-bitfields structs in the program: 12
breakdown:
   indirect level: 0, occurrence: 12
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 22
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 68

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 348
   depth: 2, occurrence: 65
   depth: 3, occurrence: 10
   depth: 4, occurrence: 4
   depth: 6, occurrence: 7
   depth: 7, occurrence: 2
   depth: 8, occurrence: 3
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 5
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 196

XXX times a variable address is taken: 186
XXX times a pointer is dereferenced on RHS: 175
breakdown:
   depth: 1, occurrence: 130
   depth: 2, occurrence: 34
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 134
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 15
   depth: 3, occurrence: 9
   depth: 4, occurrence: 7
XXX times a pointer is compared with null: 35
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 929

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 667
   level: 2, occurrence: 218
   level: 3, occurrence: 147
   level: 4, occurrence: 107
   level: 5, occurrence: 20
XXX number of pointers point to pointers: 99
XXX number of pointers point to scalars: 86
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 29.1
XXX average alias set size: 1.36

XXX times a non-volatile is read: 931
XXX times a non-volatile is write: 418
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 4

XXX stmts: 292
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 40
   depth: 2, occurrence: 30
   depth: 3, occurrence: 47
   depth: 4, occurrence: 67
   depth: 5, occurrence: 78

XXX percentage a fresh-made variable is used: 19.5
XXX percentage an existing variable is used: 80.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

