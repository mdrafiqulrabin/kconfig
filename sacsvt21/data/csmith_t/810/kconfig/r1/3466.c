/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1756278904
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const uint16_t  func_34(void);
static uint64_t  func_35(float  p_36, uint16_t  p_37, int32_t  p_38);
static const float  func_41(int32_t  p_42, uint32_t  p_43, uint8_t  p_44, uint32_t  p_45, int32_t  p_46);
static int16_t  func_50(uint32_t  p_51, uint64_t  p_52, uint64_t  p_53, uint32_t  p_54);
static int32_t  func_58(uint32_t  p_59, float  p_60, const uint8_t  p_61);
static float  func_62(uint64_t  p_63);
inline static uint64_t  func_75(const uint8_t  p_76, float * p_77, float  p_78);
inline static int32_t * func_82(int32_t * p_83, int32_t  p_84);
static int32_t * func_85(int32_t * p_86, int32_t  p_87);
static float  func_100(int16_t  p_101, float  p_102, float * const  p_103, int32_t  p_104, int32_t * p_105);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_34(void)
{ /* block id: 36 */
    uint32_t l_47 = 0x5AC3D6C1L;
    float l_510 = (-0x4.Bp+1);
    float * const l_509 = &l_510;
    float *l_511 = &l_510;
    int32_t l_512 = 0x3290B5A5L;
    uint64_t l_517 = 4UL;
    uint32_t l_520 = 0x3E70D122L;
    int32_t *****l_543 = (void*)0;
    float *l_545 = &l_510;
    float l_546 = 0x1.Ep-1;
    int32_t *l_567 = &l_512;
    int32_t **l_566 = &l_567;
    float * const **l_576 = (void*)0;
    int32_t l_581 = 0x01509AACL;
    int32_t *l_604 = (void*)0;
    int32_t *l_621 = &l_512;
    uint32_t l_635 = 0x79D94295L;
    const uint64_t l_636 = 18446744073709551610UL;
    if ((func_35(((float)((func_41(l_47, l_47, ((uint32_t)((func_50((l_47 && (+((((int16_t)((func_58(l_47, func_62(l_47), l_47) == ((int16_t)(~(-(uint64_t)__builtin_ctzll(((l_509 == l_511) | l_47)))) >> (int16_t)12)) & l_47) + (int16_t)0x9AA0L) && 0x8539D021F345487BLL) >= 0x2EDAL))), l_512, l_512, l_512) || 65534UL) > l_517) % (uint32_t)0x949F32C2L), l_47, l_517) != l_520) > l_47) / (float)l_512), l_520, l_512) != l_517))
    { /* block id: 360 */
        int32_t l_535 = 1L;
        int32_t *l_542 = &l_512;
        int32_t **l_541 = &l_542;
        int32_t ***l_540 = &l_541;
        int32_t ****l_539 = &l_540;
        int32_t *****l_538 = &l_539;
        float l_544 = 0x4.2EB9DFp-62;
        float **l_548 = (void*)0;
        float ***l_547 = &l_548;
        (*****l_538) = ((((uint16_t)l_535 / (uint16_t)__builtin_clz((((int16_t)((((l_538 != l_543) > l_520) < l_520) == ((void*)0 == l_545)) >> (int16_t)(****l_539)) & func_50(l_517, (***l_540), l_517, (****l_539))))) <= 18446744073709551610UL) & 0xC2285C87L);
        (*l_547) = &l_511;
        /* statement id: 362 */
        assert (l_548 == &l_511);
    }
    else
    { /* block id: 363 */
        int32_t *l_549 = &l_512;
        int32_t **l_550 = (void*)0;
        int32_t **l_551 = &l_549;
        (*l_551) = l_549;
        (*l_511) = (((float)((float)(((float)(0x5.B7990Bp+60 < 0x8.Bp-1) / (float)(((0x2.8BF080p-72 >= l_520) == (((float)(((float)((0xF.211B9Bp+23 <= (((0x3.9p-1 < ((float)((float)(**l_551) + (float)((*l_551) == &l_512)) / (float)l_47)) == (-0x4.Ep-1)) <= (**l_551))) >= 0x1.1p-1) / (float)(-0x10.8p+1)) != (-0x7.Ap-1)) / (float)(-0x1.Fp-1)) <= (-0x8.3p-1))) != (-0x9.3p-1))) != 0xF.A03617p+27) - (float)0x1.4p+1) - (float)0x4.A0429Ap-1) <= (*l_549));
    }
    (*l_566) = &l_512;
    if ((((int16_t)(**l_566) - (int16_t)(((((uint16_t)(*l_567) >> (uint16_t)(**l_566)) < (*l_567)) < func_35((**l_566), (**l_566), (*l_567))) || ((((uint16_t)((void*)0 != l_576) << (uint16_t)(*l_567)) == 0x28F38741L) <= 0xD294866EL))) < 4294967289UL))
    { /* block id: 368 */
        int64_t l_577 = 0xB6C1680EE69BF1A7LL;
        const float *l_580 = &l_510;
        const float ** const l_579 = &l_580;
        int32_t *l_582 = &l_512;
        l_582 = func_82((*l_566), (((((void*)0 != &l_509) < ((l_577 != (0xA5A67771L ^ (-4L))) && ((+(l_579 != &l_509)) <= (**l_566)))) > (*l_567)) && l_581));
        /* statement id: 369 */
        assert (l_582 == 0);
    }
    else
    { /* block id: 370 */
        int32_t ***l_585 = &l_566;
        int32_t ****l_584 = &l_585;
        int32_t *****l_583 = &l_584;
        float l_608 = 0x4.1F49E8p+88;
        float l_630 = 0xC.0D0315p+73;
        int32_t l_634 = (-1L);
        l_583 = (void*)0;
        /* statement id: 371 */
        assert (l_583 == 0);
        for (l_581 = 26; (l_581 > 11); l_581--)
        { /* block id: 374 */
            uint8_t l_598 = 0xD6L;
            int32_t l_599 = 0x6FBF9409L;
            int32_t *****l_609 = &l_584;
        }
    }
    return l_636;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_35(float  p_36, uint16_t  p_37, int32_t  p_38)
{ /* block id: 356 */
    uint64_t l_523 = 0x3E4CD29A4E533699LL;
    int32_t l_532 = 8L;
    int32_t *l_531 = &l_532;
    int32_t **l_530 = &l_531;
    int32_t ***l_529 = &l_530;
    int32_t ****l_528 = &l_529;
    (****l_528) = ((int16_t)func_50(p_37, l_523, ((int16_t)(((int64_t)p_38 - (int64_t)((void*)0 != l_528)) || ((*l_531) && p_37)) << (int16_t)(**l_530)), (**l_530)) % (int16_t)p_37);
    (**l_529) = func_85((*l_530), (****l_528));
    /* statement id: 358 */
    assert (l_531 == 0);
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_41(int32_t  p_42, uint32_t  p_43, uint8_t  p_44, uint32_t  p_45, int32_t  p_46)
{ /* block id: 352 */
    int32_t l_519 = 0xDD7D93E5L;
    int32_t *l_518 = &l_519;
    l_518 = l_518;
    (*l_518) = __builtin_popcountll((*l_518));
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_50(uint32_t  p_51, uint64_t  p_52, uint64_t  p_53, uint32_t  p_54)
{ /* block id: 349 */
    int32_t *l_513 = (void*)0;
    int32_t l_514 = 0x0322A895L;
    int32_t **l_516 = &l_513;
    int32_t ***l_515 = &l_516;
    (*l_516) = func_85(func_85(l_513, l_514), ((void*)0 == l_515));
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_58(uint32_t  p_59, float  p_60, const uint8_t  p_61)
{ /* block id: 113 */
    int32_t l_189 = 0xA75DB762L;
    int32_t *l_188 = &l_189;
    int32_t **l_187 = &l_188;
    uint32_t l_242 = 0UL;
    float l_262 = 0x1.5p+1;
    int32_t * const *l_275 = &l_188;
    int32_t * const **l_274 = &l_275;
    int32_t * const *** const l_273 = &l_274;
    uint32_t l_324 = 1UL;
    int32_t *l_336 = &l_189;
    uint32_t l_357 = 1UL;
    uint64_t l_369 = 0x2E57F3D4169CB32DLL;
    int32_t *l_413 = &l_189;
    uint16_t l_428 = 0x9CD4L;
    int32_t l_440 = (-1L);
    int32_t ** const *l_445 = &l_187;
    int32_t ** const **l_444 = &l_445;
    uint32_t l_504 = 0x03D7F307L;
    if (((int16_t)(l_187 == &l_188) >> (int16_t)11))
    { /* block id: 114 */
        int32_t *l_190 = &l_189;
        int16_t l_199 = 0xFE8AL;
        (*l_187) = func_85(func_85(l_190, ((*l_188) > ((void*)0 != l_190))), (*l_190));
        /* statement id: 115 */
        assert (l_188 == 0);
        if (l_189)
            goto lbl_202;
lbl_202:
        for (l_189 = 0; (l_189 >= 8); ++l_189)
        { /* block id: 118 */
            float l_198 = 0x0.Ap+1;
            float *l_197 = &l_198;
            int32_t l_201 = 0x9C725F56L;
            int32_t *l_200 = &l_201;
            (*l_200) = (((func_75(((int64_t)(((int32_t)0L / (int32_t)p_59) > p_59) % (int64_t)__builtin_ia32_crc32qi((p_59 > (*l_190)), p_61)), l_197, l_199) || p_59) | p_61) < p_59);
        }
        (*l_187) = (*l_187);
        for (l_199 = 0; (l_199 < (-10)); l_199 -= 1)
        { /* block id: 125 */
            int32_t ***l_211 = &l_187;
            const float l_241 = 0x8.F7BBE7p-86;
            int32_t l_250 = 5L;
            float *l_271 = &l_262;
            if (p_59)
            { /* block id: 126 */
                float *l_212 = (void*)0;
                float l_214 = 0x0.Ep-1;
                float *l_213 = &l_214;
                int32_t l_217 = 0L;
                for (p_59 = 29; (p_59 == 43); p_59 += 1)
                { /* block id: 129 */
                    const int32_t *l_210 = &l_189;
                    const int32_t ** const l_209 = &l_210;
                    const int32_t ** const *l_208 = &l_209;
                    const int32_t ** const **l_207 = &l_208;
                    (*l_207) = &l_187;
                    /* statement id: 130 */
                    assert (l_208 == &l_187);
                    return p_61;
                }
                (*l_213) = ((void*)0 == l_211);
                (*l_190) = (((((*l_190) ^ 18446744073709551612UL) > (*l_190)) & ((int16_t)(-1L) >> (int16_t)11)) | (l_217 ^ ((int32_t)(*l_190) + (int32_t)p_59)));
            }
            else
            { /* block id: 135 */
                uint16_t l_222 = 0x17B6L;
                int32_t *l_245 = &l_189;
                uint8_t l_259 = 0x39L;
                if (p_59)
                { /* block id: 136 */
                    (**l_211) = (void*)0;
                }
                else
                { /* block id: 138 */
                    l_222 = ((uint64_t)0x6188C7F9DB91B04CLL + (uint64_t)((**l_211) != (void*)0));
                    if (p_59)
                        continue;
                    (*l_190) = (0x28CD2B34E314DBE9LL != 18446744073709551615UL);
                    (*l_190) = 0xC14CCD6CL;
                }
                if (((((((uint32_t)((uint16_t)(p_61 == ((*l_190) || ((int32_t)(-1L) % (int32_t)p_59))) << (uint16_t)((uint64_t)((int16_t)(((uint32_t)((int16_t)((uint16_t)(((p_61 >= l_242) | p_61) | p_59) + (uint16_t)(*l_190)) << (int16_t)l_242) / (uint32_t)0xEAE63DA6L) <= (-1L)) >> (int16_t)l_222) / (uint64_t)0xC8820D8B5B86692ALL)) % (uint32_t)(*l_190)) == 0xC57C8980EC63AA86LL) && 0L) <= p_61) || l_222))
                { /* block id: 144 */
                    float l_244 = (-0x1.Fp+1);
                    float *l_243 = &l_244;
                    if (l_222)
                        break;
                    (*l_243) = (__builtin_clzll(l_222) < p_60);
                    l_190 = l_245;
                }
                else
                { /* block id: 148 */
                    float * const l_263 = &l_262;
                    int32_t l_268 = 1L;
                    (*l_263) = func_100((((int16_t)(*l_245) >> (int16_t)2) & 1L), ((float)func_100((*l_190), (l_250 < 0xD.BCA6F5p-69), func_85(l_190, ((int32_t)((uint16_t)((int16_t)((uint32_t)l_259 + (uint32_t)(0x0A6EEA41B15C3DA0LL < ((uint16_t)1UL - (uint16_t)p_59))) << (int16_t)2) % (uint16_t)p_61) % (int32_t)p_59)), p_61, l_245) + (float)p_59), l_263, (*l_245), l_245);
                    (*l_190) = p_61;
                    (*l_190) = (p_59 != ((((int16_t)0L % (int16_t)1L) | ((0x1BE63813A0B3C3F1LL <= ((int32_t)(-2L) - (int32_t)__builtin_ctzll(l_268))) || ((int16_t)func_75(p_59, l_271, l_268) << (int16_t)p_59))) < p_61));
                }
            }
            if (p_61)
            { /* block id: 154 */
                (*l_271) = p_59;
            }
            else
            { /* block id: 156 */
                uint8_t l_272 = 0x90L;
                (*l_187) = l_190;
                /* statement id: 157 */
                assert (l_188 == &l_189);
                return l_272;
            }
            return p_59;
        }
    }
    else
    { /* block id: 162 */
        uint16_t l_280 = 0x9534L;
        int32_t *l_297 = (void*)0;
        int32_t ***l_321 = (void*)0;
        int32_t ****l_320 = &l_321;
        uint32_t l_370 = 0UL;
        int64_t l_393 = (-4L);
    }
    /* facts after branching */
    assert (l_188 == &l_189 || l_188 == 0);
    (***l_444) = (*l_187);
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_62(uint64_t  p_63)
{ /* block id: 37 */
    float *l_66 = (void*)0;
    float l_68 = 0x0.Bp+1;
    float *l_67 = &l_68;
    float *l_71 = &l_68;
    int32_t l_72 = (-6L);
    float *l_79 = &l_68;
    float *l_80 = &l_68;
    int32_t *l_162 = &l_72;
    int32_t **l_184 = &l_162;
    (*l_67) = ((float)0x4.1477A1p+88 / (float)p_63);
    if (((((uint32_t)(p_63 & (l_71 == (void*)0)) - (uint32_t)l_72) < (l_72 > ((uint64_t)0xFB49A5C1B09C821FLL % (uint64_t)func_75(l_72, l_79, ((((void*)0 != l_80) >= p_63) > 0x5.9p-1))))) ^ l_72))
    { /* block id: 65 */
        uint16_t l_149 = 0xB907L;
        int32_t *l_151 = &l_72;
        int32_t **l_150 = &l_151;
        for (l_72 = 0; (l_72 < (-6)); l_72 -= 1)
        { /* block id: 68 */
            int32_t ***l_152 = &l_150;
            const int32_t l_154 = 1L;
            const int32_t *l_153 = &l_154;
            if (l_149)
                break;
            (*l_152) = l_150;
            l_153 = (void*)0;
            /* statement id: 71 */
            assert (l_153 == 0);
        }
        l_72 = (**l_150);
        for (p_63 = 0; (p_63 > 9); p_63++)
        { /* block id: 76 */
            if (l_72)
                break;
            for (l_149 = 0; (l_149 != 44); ++l_149)
            { /* block id: 80 */
                uint64_t l_159 = 1UL;
                (*l_150) = func_82(&l_72, l_159);
                /* statement id: 81 */
                assert (l_151 == 0);
            }
        }
        /* facts after for loop */
        assert (l_151 == 0 || l_151 == &l_72);
    }
    else
    { /* block id: 84 */
        int32_t *l_161 = (void*)0;
        int32_t **l_160 = &l_161;
        (*l_160) = (void*)0;
        l_162 = (*l_160);
        /* statement id: 86 */
        assert (l_162 == 0);
        (*l_160) = func_82(&l_72, p_63);
        for (l_72 = 0; (l_72 != (-26)); --l_72)
        { /* block id: 90 */
            uint64_t l_169 = 0x52B1B1FA0A7086DELL;
            for (p_63 = (-15); (p_63 < 47); ++p_63)
            { /* block id: 93 */
                int32_t l_171 = 0x7D2F2FD2L;
                int32_t *l_172 = (void*)0;
                int32_t *l_173 = &l_171;
                (*l_173) = ((uint16_t)((l_169 | __builtin_popcountl((0L ^ (-(int64_t)l_169)))) == (p_63 && l_171)) >> (uint16_t)0);
                for (l_169 = 0; (l_169 >= 56); l_169 += 7)
                { /* block id: 97 */
                    uint16_t l_179 = 0xDB6AL;
                    for (l_171 = 0; (l_171 <= (-7)); l_171 -= 6)
                    { /* block id: 100 */
                        int32_t *l_178 = &l_72;
                        int32_t l_183 = 0xEC77404BL;
                        int32_t *l_182 = &l_183;
                        (*l_160) = func_85(l_178, p_63);
                        /* statement id: 101 */
                        assert (l_161 == 0);
                        l_179 = (*l_178);
                        (*l_182) = ((int32_t)l_169 - (int32_t)0x52C19797L);
                    }
                }
                if (p_63)
                    continue;
            }
            (*l_160) = &l_72;
            /* statement id: 108 */
            assert (l_161 == &l_72);
        }
        /* facts after for loop */
        assert (l_161 == &l_72 || l_161 == 0);
    }
    /* facts after branching */
    assert (l_162 == 0 || l_162 == &l_72);
    (*l_184) = &l_72;
    /* statement id: 111 */
    assert (l_162 == &l_72);
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_75(const uint8_t  p_76, float * p_77, float  p_78)
{ /* block id: 39 */
    int16_t l_81 = 0x7D5BL;
    int32_t l_89 = 9L;
    int32_t *l_88 = &l_89;
    int16_t l_90 = 0L;
    if (l_81)
    { /* block id: 40 */
        int32_t **l_137 = &l_88;
        (*l_137) = func_82(func_85(l_88, l_90), p_76);
        /* statement id: 60 */
        assert (l_88 == 0);
    }
    else
    { /* block id: 61 */
        int16_t l_142 = (-9L);
        (*p_77) = (((((float)((float)l_142 / (float)(l_142 >= 0x1.1p+1)) - (float)((0x5.F5E99Ap-4 <= l_142) == (((void*)0 == &l_89) > ((((float)(*l_88) + (float)(((((float)(((*p_77) < (*l_88)) >= 0x1.5p-1) / (float)(*p_77)) <= 0x0.7p-1) > (*p_77)) <= (*l_88))) < 0x4.Ep+1) != l_142)))) <= l_142) >= 0x6.1p+1) != (*p_77));
    }
    /* facts after branching */
    assert (l_88 == &l_89 || l_88 == 0);
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_82(int32_t * p_83, int32_t  p_84)
{ /* block id: 45 */
    int32_t l_108 = 0x97A847E0L;
    int32_t l_129 = 1L;
    int32_t *l_128 = &l_129;
    int32_t *l_135 = &l_129;
    if ((p_84 || ((int64_t)0x4264A3A207B8A5F0LL % (int64_t)0x206CBC8CA929EFCFLL)))
    { /* block id: 46 */
        uint64_t l_115 = 18446744073709551606UL;
        int32_t l_123 = 0x88186F27L;
        int32_t *l_122 = &l_123;
        float l_126 = 0x1.1p+1;
        float *l_125 = &l_126;
        int32_t *l_130 = &l_129;
        int32_t *l_132 = (void*)0;
        (*l_122) = func_100(((0x3ADAL <= ((uint64_t)0xB579AB67338D581CLL - (uint64_t)l_108)) >= __builtin_parityll((((__builtin_clzll(p_84) < ((((int16_t)l_108 / (int16_t)((int64_t)l_115 - (int64_t)l_115)) == ((uint32_t)((int16_t)((int16_t)(0xC3517D3E8228F8F0LL | 0L) << (int16_t)l_108) >> (int16_t)p_84) - (uint32_t)l_115)) == l_115)) <= 0xFBA4BDACL) & l_115))), l_108, p_83, p_84, l_122);
        (*l_125) = l_108;
        if ((*l_122))
        { /* block id: 52 */
            int32_t *l_127 = &l_123;
            int32_t *l_131 = (void*)0;
            return l_131;
            /* statement id: 53 */
            //assert (func_82_rv == 0);
        }
        else
        { /* block id: 54 */
            return l_132;
            /* statement id: 55 */
            //assert (func_82_rv == 0);
        }
    }
    else
    { /* block id: 57 */
        int32_t *l_133 = &l_129;
        int32_t *l_134 = &l_129;
        int32_t *l_136 = (void*)0;
        return l_136;
        /* statement id: 58 */
        //assert (func_82_rv == 0);
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_85(int32_t * p_86, int32_t  p_87)
{ /* block id: 41 */
    int32_t l_93 = 0L;
    int32_t *l_92 = &l_93;
    int32_t **l_91 = &l_92;
    float *l_94 = (void*)0;
    float l_96 = (-0x1.4p-1);
    float *l_95 = &l_96;
    int32_t *l_97 = (void*)0;
    (*l_91) = &p_87;
    /* statement id: 42 */
    assert (l_92 == &p_87);
    (*l_95) = p_87;
    return l_97;
    /* statement id: 44 */
    //assert (func_85_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_100(int16_t  p_101, float  p_102, float * const  p_103, int32_t  p_104, int32_t * p_105)
{ /* block id: 47 */
    uint32_t l_124 = 0xF5A29150L;
    p_105 = &p_104;
    /* statement id: 48 */
    assert (p_105 == &p_104);
    return l_124;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 173
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 16
   depth: 3, occurrence: 8
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 140

XXX times a variable address is taken: 135
XXX times a pointer is dereferenced on RHS: 91
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 18
   depth: 3, occurrence: 5
   depth: 4, occurrence: 11
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 92
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 6
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 515

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 308
   level: 2, occurrence: 80
   level: 3, occurrence: 59
   level: 4, occurrence: 49
   level: 5, occurrence: 9
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 78
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 31.4
XXX average alias set size: 1.27

XXX times a non-volatile is read: 738
XXX times a non-volatile is write: 273
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 2

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 25
   depth: 2, occurrence: 13
   depth: 3, occurrence: 12
   depth: 4, occurrence: 14
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 18.3
XXX percentage an existing variable is used: 81.7
********************* end of statistics **********************/

