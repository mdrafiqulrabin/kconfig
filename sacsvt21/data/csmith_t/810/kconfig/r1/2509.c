/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      1689918032
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const signed f0 : 22;
   unsigned f1 : 19;
   unsigned f2 : 9;
   signed f3 : 17;
   signed f4 : 28;
   signed f5 : 3;
   unsigned f6 : 21;
   const unsigned f7 : 22;
   signed f8 : 2;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_6 = 0xF8F576C5;
static const int32_t *g_10[4] = {(void*)0,(void*)0,(void*)0,(void*)0};
static int32_t g_34 = 0x7DA828C0;
static int32_t g_35 = 0xC2391700;
static uint32_t g_97 = 2U;
static struct S0 g_192[9] = {{-1339,440,15,-106,9288,-0,324,1157,0},{-1339,440,15,-106,9288,-0,324,1157,0},{-1339,440,15,-106,9288,-0,324,1157,0},{-1339,440,15,-106,9288,-0,324,1157,0},{-1339,440,15,-106,9288,-0,324,1157,0},{-1339,440,15,-106,9288,-0,324,1157,0},{-1339,440,15,-106,9288,-0,324,1157,0},{-1339,440,15,-106,9288,-0,324,1157,0},{-1339,440,15,-106,9288,-0,324,1157,0}};
static struct S0 *g_191 = &g_192[2];
static uint32_t g_241 = 0U;
static const struct S0 g_265 = {-188,484,1,44,14140,0,1288,820,0};
static const struct S0 *g_264 = &g_265;
static int32_t *g_314 = &g_6;
static int32_t **g_313 = &g_314;
static int32_t ***g_312 = &g_313;
static int32_t *** const *g_400 = &g_312;
static int32_t *** const **g_399 = &g_400;
static struct S0 **g_480 = &g_191;
static struct S0 ***g_479 = &g_480;
static int32_t *** const *g_512 = &g_312;
static uint32_t g_622 = 0x8C05A2A0;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_1(void);
inline static int32_t  func_12(const struct S0  p_13, uint32_t  p_14, uint32_t  p_15);
static const struct S0  func_16(uint8_t  p_17, int32_t * p_18, int8_t  p_19);
inline static uint8_t  func_20(uint32_t  p_21);
static int8_t  func_27(uint32_t  p_28, int32_t * p_29, int32_t  p_30, const uint32_t  p_31);
static int32_t * func_38(const uint32_t  p_39, int32_t  p_40, int32_t * p_41, uint32_t  p_42);
static int32_t * const  func_50(int32_t * p_51, int32_t * p_52, uint32_t  p_53, int32_t * p_54);
static int32_t * func_56(struct S0  p_57, uint32_t  p_58, int32_t * p_59, int32_t * p_60, int32_t  p_61);
static struct S0  func_62(int8_t  p_63, const int32_t * p_64);
static int32_t * func_70(int32_t * p_71, uint32_t  p_72, int8_t  p_73, uint8_t  p_74);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_34 g_35 g_97 g_265.f2 g_399 g_400 g_312 g_313 g_314 g_479 g_480 g_265.f8 g_192.f0 g_512 g_241 g_192.f8 g_265.f3 g_265.f6 g_191 g_192.f5 g_192.f1 g_265.f7 g_265.f5 g_192.f7 g_622 g_192.f2 g_192.f4 g_192.f6 g_265.f1 g_265.f0 g_265.f4 g_192.f3 g_192 g_10
 * writes: g_6 g_10 g_34 g_191 g_314 g_241 g_35 g_480 g_192.f8 g_264 g_97 g_312 g_313 g_399 g_512 g_622 g_192.f4
 */
inline static int32_t  func_1(void)
{ /* block id: 0 */
    int8_t l_4 = (-10);
    int32_t *l_5 = &g_6;
    int32_t l_32[9][6][2] = {{{0x8D1D9D65,0x0D296407},{(-7),1},{(-7),0x0D296407},{0x8D1D9D65,0x734895C4},{0x0D296407,9},{(-1),0xC19CD890}},{{0,0xE96F77D9},{0xE96F77D9,0x8D1D9D65},{1,0x8D1D9D65},{0xE96F77D9,0xE96F77D9},{0,0xC19CD890},{(-1),9}},{{0x0D296407,0x734895C4},{0x8D1D9D65,0x0D296407},{(-7),1},{(-7),0x0D296407},{0x8D1D9D65,0x771B7056},{0,0x8D1D9D65}},{{(-7),0x734895C4},{0xC19CD890,1},{1,1},{0xE96F77D9,1},{1,1},{0xC19CD890,0x734895C4}},{{(-7),0x8D1D9D65},{0,0x771B7056},{1,0},{9,0x0D296407},{9,0},{1,0x771B7056}},{{0,0x8D1D9D65},{(-7),0x734895C4},{0xC19CD890,1},{1,1},{0xE96F77D9,1},{1,1}},{{0xC19CD890,0x734895C4},{(-7),0x8D1D9D65},{0,0x771B7056},{1,0},{9,0x0D296407},{9,0}},{{1,0x771B7056},{0,0x8D1D9D65},{(-7),0x734895C4},{0xC19CD890,1},{1,1},{0xE96F77D9,1}},{{1,1},{0xC19CD890,0x734895C4},{(-7),0x8D1D9D65},{0,0x771B7056},{1,0},{9,0x0D296407}}};
    int32_t *l_538 = &l_32[2][2][0];
    uint32_t l_545 = 4294967290U;
    int32_t *** const l_572 = &g_313;
    int32_t l_619[1][8];
    struct S0 *l_640 = &g_192[2];
    int8_t l_694 = (-10);
    int8_t l_717[6][3][5] = {{{5,5,0x25,(-4),(-1)},{0xA8,0x81,0x81,0xA8,1},{0xB3,(-4),0xDD,0xDD,(-4)}},{{1,0x81,1,0xDD,0xDD},{0xD2,5,0xD2,0xDD,0x25},{0,0xA8,0xDD,0xA8,0}},{{0xD2,0xB3,5,(-4),5},{1,1,0xDD,0,0xBF},{0xB3,0xD2,0xD2,0xB3,5}},{{0xA8,0,1,1,0},{5,0xD2,0xDD,0x25,0x25},{0x81,1,0x81,1,0xDD}},{{(-4),0xB3,0x25,0xB3,(-4)},{0x81,0xA8,1,0,1},{5,5,0x25,(-4),(-1)}},{{0xA8,0x81,0x81,0xA8,1},{0xB3,(-4),0xDD,0xDD,(-4)},{1,0x81,1,0xDD,0xDD}}};
    int32_t ***l_737 = &g_313;
    struct S0 *** const l_745 = &g_480;
    uint16_t l_750 = 0U;
    uint32_t l_777 = 0x515E45E4;
    const int32_t **l_779 = &g_10[3];
    int i, j, k;
    for (i = 0; i < 1; i = i + 1)
    {
        for (j = 0; j < 8; j = j + 1)
            l_619[i][j] = 0xB8718228;
    }
lbl_677:
    (*l_5) = (safe_add_func_int32_t_s_s(0x26FF23B1, l_4));
lbl_675:
    if (((*l_5) | 1))
    { /* block id: 2 */
        int32_t *l_7 = (void*)0;
        (*l_5) = (l_7 == &g_6);
    }
    else
    { /* block id: 4 */
        uint16_t l_11 = 0x68F9;
        if (g_6)
        { /* block id: 5 */
            for (g_6 = 0; (g_6 >= (-23)); g_6 = safe_sub_func_uint8_t_u_u(g_6, 9))
            { /* block id: 8 */
                g_10[3] = (void*)0;
            }
        }
        else
        { /* block id: 11 */
            return l_11;
        }
    }
    if (func_12(func_16(func_20(((safe_sub_func_int8_t_s_s(((safe_add_func_uint32_t_u_u((((*l_5) > g_6) & (*l_5)), (~(*l_5)))) & ((0 | (((func_27((*l_5), &g_6, l_32[2][2][1], g_6) >= g_6) == g_35) != g_6)) ^ g_6)), (*l_5))) && (*l_5))), l_538, g_265.f8), l_545, g_192[2].f0))
    { /* block id: 318 */
        const uint8_t l_571 = 0xD6;
        int32_t **l_697[1][1];
        struct S0 *l_711 = (void*)0;
        uint16_t l_716 = 2U;
        int32_t ****l_735[6] = {&g_312,&g_312,&g_312,&g_312,&g_312,&g_312};
        int32_t *****l_734 = &l_735[0];
        struct S0 *l_763 = &g_192[2];
        const int32_t ***l_780 = (void*)0;
        const int32_t ***l_781 = (void*)0;
        const int32_t ***l_782 = (void*)0;
        const int32_t ***l_783 = &l_779;
        int i, j;
        for (i = 0; i < 1; i = i + 1)
        {
            for (j = 0; j < 1; j = j + 1)
                l_697[i][j] = &g_314;
        }
        if ((****g_400))
        { /* block id: 319 */
            int8_t l_574 = 0xFE;
            int32_t ** const *l_587 = &g_313;
            int32_t ** const ** const l_586 = &l_587;
            int32_t l_621 = (-1);
            uint32_t l_660 = 6U;
            int32_t *** const **l_698 = &g_400;
lbl_685:
            (**g_479) = (**g_479);
            if (((safe_sub_func_int8_t_s_s(l_571, (-1))) | ((void*)0 != l_572)))
            { /* block id: 321 */
                int32_t *l_575 = &l_32[2][2][1];
                struct S0 ****l_634 = (void*)0;
                struct S0 ***l_661 = (void*)0;
                if ((*g_314))
                { /* block id: 322 */
                    int32_t *l_588 = &g_34;
                    struct S0 ****l_633 = &g_479;
                    if ((~l_574))
                    { /* block id: 323 */
                        int32_t l_604 = 9;
                        (****g_399) = (*g_313);
                        (****g_512) = (((g_265.f8 < (safe_sub_func_int8_t_s_s((g_35 < ((*g_399) == (void*)0)), ((safe_mod_func_uint16_t_u_u(((safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(((*g_480) != (**g_479)), 12)), g_192[2].f5)), (!(((*l_588) || (safe_sub_func_uint32_t_u_u((g_192[2].f1 > 1U), 0x19834FE6))) < (**g_313))))), (*l_5))) > l_604), 0xC4C0)) >= (***l_572))))) == g_265.f7) ^ g_192[2].f1);
                        if (l_574)
                            goto lbl_668;
                        (*g_313) = (***g_400);
                    }
                    else
                    { /* block id: 327 */
                        (*g_313) = (***g_512);
                        return (*l_588);
                    }
                    (**g_479) = (**g_479);
                    if (((*l_575) & (*l_588)))
                    { /* block id: 332 */
                        uint32_t l_620 = 0x300A49A9;
                        (*l_588) = (0xCDAC53CA <= ((void*)0 != &l_575));
                        (****g_512) = (*l_588);
                        (*l_538) = (((void*)0 == &l_586) > (g_265.f5 > (1U < (((safe_add_func_uint8_t_u_u((!(0x82 > (((((safe_lshift_func_uint8_t_u_s(((((safe_rshift_func_int16_t_s_u(g_265.f2, g_192[2].f8)) == (safe_sub_func_uint32_t_u_u((!(safe_lshift_func_uint16_t_u_s(1U, 13))), l_619[0][4]))) ^ l_620) || g_6), g_192[2].f7)) == l_621) == g_622) & (*l_575)) <= g_192[2].f2))), 0xBB)) & 4) ^ (-4)))));
                    }
                    else
                    { /* block id: 336 */
                        int32_t * const ***l_623 = (void*)0;
                        (**g_313) = 0;
                        (**g_312) = l_575;
                        /* statement id: 338 */
                        assert ((g_314 >= &l_32[0][0][0] && g_314 <= &l_32[8][5][1]));
                        (***l_572) = ((((*g_512) != (void*)0) ^ ((void*)0 != l_623)) > (safe_mod_func_uint16_t_u_u(((safe_mod_func_uint8_t_u_u(((((safe_lshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_u((-1), 4)), 6)) != (~(l_633 == l_634))) ^ ((((g_192[2].f2 != ((((safe_mod_func_uint16_t_u_u((safe_unary_minus_func_uint32_t_u((safe_sub_func_uint32_t_u_u((l_640 == (*g_480)), g_265.f6)))), 4)) || 9U) <= (***l_587)) >= 65530U)) || 0x47D66627) & g_265.f6) ^ l_571)) < g_265.f3), g_192[2].f1)) & g_192[2].f1), g_265.f2)));
                        (*****g_399) = (safe_rshift_func_int16_t_s_u(((((*g_479) != (void*)0) <= (*l_5)) == (l_571 | (safe_lshift_func_int16_t_s_u(((**l_586) != (*g_312)), g_192[2].f4)))), (safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_s(3U, g_622)), 10))));
                    }
                    /* facts after branching */
                    assert ((g_314 >= &l_32[0][0][0] && g_314 <= &l_32[8][5][1]) || g_314 == &g_6);
                }
                else
                { /* block id: 342 */
                    uint32_t l_659 = 5U;
                    for (l_4 = 3; (l_4 >= 0); l_4 -= 1)
                    { /* block id: 345 */
                        const int32_t l_649[1] = {0x308098ED};
                        int i;
                        (*g_480) = (*g_480);
                        (*****g_399) = l_649[0];
                        g_10[l_4] = (***g_512);
                        (*****g_399) = (((void*)0 == (*g_399)) && (g_192[2].f6 || (safe_mod_func_int32_t_s_s((***g_312), ((g_97 == ((g_265.f1 && (safe_sub_func_uint8_t_u_u(g_192[2].f2, (((safe_sub_func_uint16_t_u_u(g_192[2].f5, ((~(safe_rshift_func_int8_t_s_u(0x25, l_659))) || g_265.f0))) == (****g_400)) <= l_660)))) >= 0x91)) | (***l_572))))));
                    }
                    (*****g_399) = (((***l_587) & 0x68) == (0xC1 && 0xE0));
                    for (g_241 = 0; (g_241 <= 0); g_241 += 1)
                    { /* block id: 354 */
                        (***l_587) = (***g_312);
                    }
                }
                /* facts after branching */
                assert ((g_314 >= &l_32[0][0][0] && g_314 <= &l_32[8][5][1]) || g_314 == &g_6);
lbl_668:
                (****l_586) = (((((**g_399) != (void*)0) ^ (l_661 == (void*)0)) || (safe_mod_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u(g_265.f4, l_571)) < (safe_sub_func_uint16_t_u_u((1U <= (g_192[2].f2 ^ (*l_575))), (***l_572)))), 0x59DD))) || 65532U);
                for (g_34 = (-7); (g_34 > 0); g_34 = safe_add_func_uint8_t_u_u(g_34, 6))
                { /* block id: 362 */
                    if (g_265.f0)
                        goto lbl_668;
                    (***l_587) = 0;
                }
                return (*l_5);
                /* statement id: 366 */
                //assert (g_314 == dangling || g_314 == &g_6);
            }
            else
            { /* block id: 367 */
                const uint16_t l_676 = 0xFB45;
                int32_t *l_686 = &l_619[0][7];
                for (g_241 = 0; (g_241 < 29); g_241 = safe_add_func_int32_t_s_s(g_241, 2))
                { /* block id: 370 */
                    const int32_t **l_681[8];
                    const int32_t ***l_680[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                    const int32_t ****l_679 = &l_680[9];
                    const int32_t *****l_678[10] = {&l_679,&l_679,&l_679,&l_679,&l_679,&l_679,&l_679,&l_679,&l_679,&l_679};
                    const int32_t *l_684[5][6][2] = {{{&l_619[0][1],(void*)0},{(void*)0,(void*)0},{(void*)0,&l_32[2][2][1]},{(void*)0,&l_619[0][5]},{&l_32[3][4][1],&g_6},{&g_6,(void*)0}},{{&l_32[2][2][1],(void*)0},{&g_6,&g_6},{&l_32[3][4][1],&l_619[0][5]},{(void*)0,&l_32[2][2][1]},{(void*)0,(void*)0},{(void*)0,(void*)0}},{{&l_619[0][1],&l_32[2][2][1]},{&l_619[0][1],(void*)0},{(void*)0,(void*)0},{(void*)0,&l_32[2][2][1]},{(void*)0,&l_619[0][5]},{&l_32[3][4][1],&g_6}},{{&g_6,(void*)0},{&l_32[2][2][1],(void*)0},{&g_6,&g_6},{&l_32[3][4][1],&l_619[0][5]},{(void*)0,&l_32[2][2][1]},{(void*)0,(void*)0}},{{(void*)0,(void*)0},{&l_619[0][1],&l_32[2][2][1]},{&l_619[0][1],(void*)0},{(void*)0,(void*)0},{(void*)0,&l_32[2][2][1]},{(void*)0,&l_619[0][5]}}};
                    int i, j, k;
                    for (i = 0; i < 8; i = i + 1)
                        l_681[i] = &g_10[0];
                    for (l_660 = 0; (l_660 > 35); l_660 = safe_add_func_int16_t_s_s(l_660, 2))
                    { /* block id: 373 */
                        if (g_35)
                            goto lbl_675;
                        if (l_676)
                            break;
                        if (g_265.f0)
                            goto lbl_677;
                    }
                    (**g_313) = (l_678[2] == (void*)0);
                    for (g_35 = 28; (g_35 == 1); g_35--)
                    { /* block id: 381 */
                        (***g_400) = (****g_399);
                        (****g_512) = ((void*)0 == l_684[0][5][1]);
                        if (l_545)
                            goto lbl_685;
                    }
                    (*g_479) = (*g_479);
                }
                (***l_586) = l_686;
                /* statement id: 388 */
                assert ((g_314 >= &l_619[0][0] && g_314 <= &l_619[0][7]));
            }
            /* facts after branching */
            assert ((g_314 >= &l_619[0][0] && g_314 <= &l_619[0][7]));
            l_538 = func_38((safe_sub_func_int16_t_s_s(((g_192[2].f3 <= (safe_unary_minus_func_int32_t_s((***g_312)))) & ((0x56EFE57B || (0x19 >= (safe_rshift_func_uint16_t_u_u(g_192[2].f3, g_265.f7)))) && (safe_lshift_func_uint8_t_u_u(((l_694 & (safe_rshift_func_uint16_t_u_s((l_697[0][0] != l_697[0][0]), 15))) & g_6), (****l_586))))), g_192[2].f0)), (****l_586), (***l_586), (****l_586));
            /* statement id: 390 */
            //assert (g_10[0] == dangling || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0);
            //assert ((g_191 >= &g_192[0] && g_191 <= &g_192[8]) || g_191 == dangling);
            assert ((g_264 >= &g_192[0] && g_264 <= &g_192[8]) || g_264 == 0);
            //assert (g_314 == dangling || g_314 == &g_6 || g_314 == &g_34);
            //assert (g_480 == 0 || g_480 == &g_191 || g_480 == dangling);
            //assert (g_512 == &g_312 || g_512 == 0 || g_512 == dangling);
            assert (l_538 == 0);
            l_698 = &g_400;
        }
        else
        { /* block id: 392 */
            uint8_t l_709 = 0U;
            int32_t *l_710 = &l_619[0][4];
            uint8_t l_760 = 1U;
            uint32_t l_762 = 0x4BCC2AE2;
            int8_t l_776 = 0;
            int32_t l_778 = 0x6F10CAE1;
            for (g_622 = (-14); (g_622 == 57); ++g_622)
            { /* block id: 395 */
                int32_t l_701 = 0xD8CE2368;
                int32_t *l_702 = &l_32[2][2][1];
            }
            if (((((g_622 & (-1)) <= g_265.f8) <= (safe_sub_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((safe_add_func_uint8_t_u_u(((*l_710) & g_192[2].f2), ((void*)0 != l_734))), (*l_710))), (g_265.f5 == g_192[2].f1)))) == 0xD21A7548))
            { /* block id: 401 */
                if (g_265.f7)
                    goto lbl_675;
                (****g_400) = (0x27346146 < (safe_unary_minus_func_uint8_t_u(0U)));
                (*l_5) = (*****g_399);
                (*g_314) = (**g_313);
            }
            else
            { /* block id: 406 */
                int32_t l_738 = 0x229E0906;
                const int32_t ****l_742 = (void*)0;
                const int32_t ***** const l_741 = &l_742;
                for (g_35 = 0; (g_35 <= 0); g_35 += 1)
                { /* block id: 409 */
                    l_737 = (*g_512);
                    return l_738;
                }
                for (l_709 = 0; (l_709 <= 3); l_709 += 1)
                { /* block id: 415 */
                    int32_t l_752[3];
                    int i;
                    for (i = 0; i < 3; i = i + 1)
                        l_752[i] = (-10);
                }
                (*****l_734) = (-3);
            }
            for (g_34 = 3; (g_34 >= 0); g_34 -= 1)
            { /* block id: 445 */
                const int32_t **l_753 = &g_10[2];
                int32_t *** const l_766 = &l_697[0][0];
                struct S0 **** const l_767 = &g_479;
                int i;
                (*l_753) = g_10[g_34];
                (**l_737) = (void*)0;
                /* statement id: 447 */
                assert (g_314 == 0);
                for (g_6 = 0; (g_6 > 25); g_6 = safe_add_func_uint16_t_u_u(g_6, 5))
                { /* block id: 450 */
                    const uint8_t l_761 = 249U;
                    int32_t l_775 = 0x8CB38074;
                    if ((0xAECC > (((void*)0 != (*g_479)) <= ((0x4C ^ ((((+(~((0xDE2D > ((((safe_unary_minus_func_uint8_t_u((1U <= (+(((l_760 == g_265.f0) || (g_192[2].f7 >= l_761)) < g_192[2].f1))))) || l_762) >= g_192[2].f8) <= 0x15B5A567)) && 0x96))) > g_265.f4) > l_761) || (*l_538))) == g_265.f5))))
                    { /* block id: 451 */
                        g_192[2].f4 = (*l_710);
                        (*g_313) = (****g_399);
                        (*g_480) = l_763;
                    }
                    else
                    { /* block id: 455 */
                        l_777 = ((((safe_add_func_int32_t_s_s(((l_766 != (void*)0) ^ ((void*)0 == l_767)), (safe_add_func_int16_t_s_s(((((safe_unary_minus_func_int16_t_s((((&g_480 == (void*)0) == ((*l_710) < ((safe_mod_func_int8_t_s_s((safe_sub_func_int16_t_s_s(0x15CF, l_775)), 246U)) < l_776))) >= 0x20))) >= g_265.f4) || g_192[2].f7) | 0xD12D), g_622)))) != (*l_5)) >= 0xA5AA14BD) != g_192[2].f2);
                        (***g_512) = (***g_400);
                        (**l_737) = (***g_400);
                    }
                }
            }
            /* facts after for loop */
            assert (g_314 == 0 || g_314 == &g_6);
            l_778 = (*l_710);
        }
        /* facts after branching */
        //assert (g_10[0] == dangling || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0);
        //assert ((g_191 >= &g_192[0] && g_191 <= &g_192[8]) || g_191 == dangling);
        assert (g_264 == &g_265 || (g_264 >= &g_192[0] && g_264 <= &g_192[8]) || g_264 == 0);
        //assert (g_314 == 0 || g_314 == &g_6 || g_314 == dangling || g_314 == &g_34);
        //assert (g_480 == 0 || g_480 == &g_191 || g_480 == dangling);
        //assert (g_512 == &g_312 || g_512 == 0 || g_512 == dangling);
        assert ((l_538 >= &l_32[0][0][0] && l_538 <= &l_32[8][5][1]) || l_538 == 0);
        (*l_783) = l_779;
    }
    else
    { /* block id: 465 */
        uint8_t l_784 = 255U;
        (**g_313) = l_784;
    }
    /* facts after branching */
    //assert (g_10[0] == dangling || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0);
    //assert ((g_191 >= &g_192[0] && g_191 <= &g_192[8]) || g_191 == dangling);
    assert (g_264 == &g_265 || (g_264 >= &g_192[0] && g_264 <= &g_192[8]) || g_264 == 0);
    //assert (g_314 == 0 || g_314 == &g_6 || g_314 == dangling || g_314 == &g_34);
    //assert (g_480 == 0 || g_480 == &g_191 || g_480 == dangling);
    //assert (g_512 == &g_312 || g_512 == 0 || g_512 == dangling);
    assert ((l_538 >= &l_32[0][0][0] && l_538 <= &l_32[8][5][1]) || l_538 == 0);
    return (*l_5);
}


/* ------------------------------------------ */
/* 
 * reads : g_512 g_312 g_313 g_241 g_6 g_192.f8 g_265.f3 g_314 g_265.f6 g_34 g_97 g_399 g_400
 * writes: g_314 g_6 g_10
 */
inline static int32_t  func_12(const struct S0  p_13, uint32_t  p_14, uint32_t  p_15)
{ /* block id: 313 */
    int32_t *l_546 = &g_6;
    struct S0 **l_555 = &g_191;
    uint32_t l_562 = 4294967295U;
    int32_t **** const l_566 = (void*)0;
    int32_t **** const *l_565 = &l_566;
    (***g_512) = l_546;
    (**g_313) = (safe_lshift_func_uint8_t_u_u((g_241 <= (safe_lshift_func_int16_t_s_s((7 > (safe_sub_func_uint32_t_u_u((safe_rshift_func_uint8_t_u_u((l_555 != (void*)0), (((*l_546) < ((safe_rshift_func_uint8_t_u_s((safe_add_func_uint32_t_u_u(g_192[2].f8, g_265.f3)), (safe_add_func_int32_t_s_s((((*l_546) && (*l_546)) | (*l_546)), (-1))))) > (*l_546))) > p_15))), 4))), 4))), 4));
    (****g_399) = func_70(l_546, p_13.f0, l_562, ((g_265.f6 >= (p_13.f3 <= (-1))) & (safe_sub_func_uint32_t_u_u(p_13.f1, (l_565 != (void*)0)))));
    return p_13.f5;
}


/* ------------------------------------------ */
/* 
 * reads : g_314 g_6 g_400 g_312 g_313
 * writes: g_6
 */
static const struct S0  func_16(uint8_t  p_17, int32_t * p_18, int8_t  p_19)
{ /* block id: 302 */
    uint32_t l_539[5][8][6] = {{{0U,4294967295U,0x9DEA8204,4294967287U,0x9E703182,0U},{3U,4294967290U,0x8588B505,3U,0x6751E6E5,0xB56DFF16},{0U,0x9E703182,3U,0x18C1D69E,3U,0x87112506},{4294967295U,4294967295U,4294967290U,0xA02C455B,1U,1U},{0U,4294967295U,4294967295U,0U,3U,0x78853474},{4294967287U,0U,3U,0x0AFEA872,4294967291U,0xA02C455B},{0xE849F56F,0x45D62980,0xE0EFC14E,0x0C9CC59A,4294967291U,4294967295U},{0U,0U,0x9DEA8204,0x87112506,3U,0x2CDD0DE0}},{{0x271E9C70,4294967295U,0xB56DFF16,3U,1U,0x3F57EACD},{0x9DEA8204,4294967295U,0x881E825A,0x97242DD8,3U,0x45D62980},{4294967290U,0x9E703182,0x19B97B3A,4294967295U,0x6751E6E5,1U},{0U,4294967290U,0U,0xA93D07BB,0x9E703182,4294967291U},{4294967287U,4294967295U,0x6751E6E5,4294967295U,4294967287U,4294967295U},{0xA93D07BB,0x45D62980,0xA02C455B,0xE0EFC14E,0x18C1D69E,0x0AFEA872},{1U,0U,0x9DEA8204,0x45D62980,4294967295U,0x0AFEA872},{0x97C912F7,0U,0xA02C455B,3U,0x881E825A,4294967295U}},{{4294967295U,0x9DEA8204,0x6751E6E5,0x78853474,3U,4294967291U},{0U,0x97C912F7,0U,0x3F57EACD,0x5D82A794,1U},{4294967295U,0U,0x19B97B3A,0U,0U,0x45D62980},{4294967287U,0x2CDD0DE0,0x881E825A,0xE849F56F,0x78853474,0x3F57EACD},{0x2CDD0DE0,0x45D62980,0xB56DFF16,0xB56DFF16,0x45D62980,0x2CDD0DE0},{0x19B97B3A,0x0AFEA872,0x9DEA8204,0xB56DFF16,0x02085444,1U},{0x305E0515,0x87112506,0x5D82A794,3U,0x9E703182,0x6751E6E5},{0x305E0515,3U,3U,0xB56DFF16,0U,0x8588B505}},{{0x78853474,0x02085444,0x97242DD8,1U,3U,0U},{4294967290U,0x78853474,4294967287U,0U,4294967288U,0xE0EFC14E},{4294967295U,0U,0x9DEA8204,4294967295U,0xE0EFC14E,1U},{1U,0xA02C455B,0x881E825A,7U,0x3F57EACD,0x19B97B3A},{0x45D62980,0U,0U,0x8588B505,0U,0U},{4294967293U,0x18C1D69E,3U,3U,0x9DEA8204,0x881E825A},{4294967288U,4294967295U,0x9E703182,0xA02C455B,0U,0x3F57EACD},{0x18C1D69E,4294967295U,0x45D62980,0x5D82A794,0x9DEA8204,0U}},{{0U,0x18C1D69E,4294967291U,1U,0U,4294967295U},{4294967295U,0U,0x97C912F7,0U,0x3F57EACD,0x5D82A794},{4294967295U,0xA02C455B,7U,3U,0xE0EFC14E,0U},{4294967287U,0U,0U,0x3F57EACD,4294967288U,4294967295U},{0U,0x78853474,3U,3U,3U,3U},{0x02085444,0x02085444,0U,0xE0EFC14E,0U,0x0C9CC59A},{0x87112506,3U,0x18C1D69E,3U,0x9E703182,0U},{0U,0x87112506,0x18C1D69E,0U,0x02085444,0x0C9CC59A}}};
    int32_t ***l_540 = &g_313;
    uint32_t l_541[9][9][2] = {{{0xE825FBA1,0x53A977D7},{0x1C4B697E,4294967287U},{0x5D57140D,0x1C4B697E},{1U,0xFACB373A},{1U,0x1C4B697E},{0x5D57140D,4294967287U},{0x1C4B697E,0x53A977D7},{0xE825FBA1,0U},{0x9C54849C,4294967289U}},{{4294967289U,0x1C4B697E},{4294967295U,4294967295U},{0U,8U},{0x5D57140D,4294967294U},{0x9C54849C,1U},{0xFACB373A,0U},{4294967293U,4294967287U},{4294967294U,8U},{4294967295U,4294967295U}},{{1U,0x9C54849C},{4294967289U,4294967294U},{4294967293U,0x53A977D7},{4294967295U,0x53A977D7},{4294967293U,4294967294U},{4294967289U,0x9C54849C},{1U,4294967295U},{4294967295U,8U},{4294967294U,4294967287U}},{{4294967293U,0U},{0xFACB373A,1U},{0x9C54849C,4294967294U},{0x5D57140D,8U},{0U,4294967295U},{4294967295U,0x1C4B697E},{4294967289U,4294967289U},{0x9C54849C,0U},{0xE825FBA1,0x53A977D7}},{{0x1C4B697E,4294967287U},{0x5D57140D,0x1C4B697E},{1U,0xFACB373A},{1U,0x1C4B697E},{0xEA2A0F3C,0xC282ABA0},{0xE825FBA1,0x9C54849C},{0x2F056A97,4294967293U},{4294967295U,1U},{1U,0xE825FBA1}},{{4294967290U,0xF31D2603},{4294967293U,0xFACB373A},{0xEA2A0F3C,0x5B947408},{4294967295U,0x1C4B697E},{1U,4294967293U},{4294967294U,0xC282ABA0},{0x5B947408,0xFACB373A},{4294967290U,7U},{0x1C4B697E,4294967295U}},{{1U,0x5B947408},{4294967294U,0x9C54849C},{7U,0x9C54849C},{4294967294U,0x5B947408},{1U,4294967295U},{0x1C4B697E,7U},{4294967290U,0xFACB373A},{0x5B947408,0xC282ABA0},{4294967294U,4294967293U}},{{1U,0x1C4B697E},{4294967295U,0x5B947408},{0xEA2A0F3C,0xFACB373A},{4294967293U,0xF31D2603},{4294967290U,0xE825FBA1},{1U,1U},{4294967295U,4294967293U},{0x2F056A97,0x9C54849C},{0xE825FBA1,0xC282ABA0}},{{0xEA2A0F3C,0xE825FBA1},{0x1C4B697E,1U},{0x1C4B697E,0xE825FBA1},{0xEA2A0F3C,0xC282ABA0},{0xE825FBA1,0x9C54849C},{0x2F056A97,4294967293U},{4294967295U,1U},{1U,0xE825FBA1},{4294967290U,0xF31D2603}}};
    const struct S0 l_544[7] = {{1250,648,2,214,-15844,1,1125,1277,0},{1250,648,2,214,-15844,1,1125,1277,0},{1250,648,2,214,-15844,1,1125,1277,0},{1250,648,2,214,-15844,1,1125,1277,0},{1250,648,2,214,-15844,1,1125,1277,0},{1250,648,2,214,-15844,1,1125,1277,0},{1250,648,2,214,-15844,1,1125,1277,0}};
    int i, j, k;
    if ((*g_314))
    { /* block id: 303 */
        (****g_400) = (l_539[4][7][3] > (((void*)0 == l_540) & l_541[5][6][1]));
    }
    else
    { /* block id: 305 */
        for (p_19 = (-10); (p_19 <= (-30)); p_19--)
        { /* block id: 308 */
            (***l_540) = (-1);
        }
    }
    return l_544[1];
}


/* ------------------------------------------ */
/* 
 * reads : g_97 g_265.f2 g_399 g_400 g_312 g_313 g_314 g_479 g_480
 * writes: g_6 g_191
 */
inline static uint8_t  func_20(uint32_t  p_21)
{ /* block id: 18 */
    int8_t l_43 = 0x5C;
    int32_t *l_46 = &g_6;
    int32_t l_49 = 1;
    uint32_t l_535 = 0x58B4C528;
    struct S0 *l_536 = &g_192[0];
    int32_t l_537 = 1;
    (*****g_399) = ((safe_add_func_int32_t_s_s((p_21 != (g_97 ^ 0x5771)), g_265.f2)) ^ l_535);
    (**g_479) = l_536;
    return l_537;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_34
 * writes: g_34
 */
static int8_t  func_27(uint32_t  p_28, int32_t * p_29, int32_t  p_30, const uint32_t  p_31)
{ /* block id: 15 */
    int32_t *l_33 = &g_34;
    (*l_33) = (*p_29);
    return (*l_33);
}


/* ------------------------------------------ */
/* 
 * reads : g_35 g_34 g_6 g_97 g_241 g_192.f0 g_192.f4 g_192.f8 g_192.f6 g_192.f1 g_192.f3 g_265.f1 g_192.f7 g_265.f5 g_265.f8 g_265.f6 g_265.f0 g_265.f3 g_265.f7 g_312 g_313 g_314 g_192.f5 g_399 g_400 g_192.f2 g_265.f2 g_265.f4 g_479 g_192
 * writes: g_34 g_35 g_6 g_10 g_192.f8 g_264 g_241 g_97 g_191 g_312 g_314 g_313 g_399 g_480 g_512
 */
static int32_t * func_38(const uint32_t  p_39, int32_t  p_40, int32_t * p_41, uint32_t  p_42)
{ /* block id: 19 */
    int32_t l_55 = 0xD5E57097;
    int32_t *l_340 = &l_55;
    int32_t **l_532 = &g_314;
    struct S0 *l_533[5][10] = {{&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0,&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0},{&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0,&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0},{&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0,&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0},{&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0,&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0},{&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0,&g_192[2],&g_192[8],&g_192[8],&g_192[2],(void*)0}};
    int32_t *l_534 = (void*)0;
    int i, j;
    (*l_532) = func_50(&g_6, &g_6, func_27(l_55, func_56(func_62(func_27(g_35, &l_55, ((&g_6 == &l_55) && g_35), (l_55 != p_40)), &g_6), g_6, &l_55, &g_6, p_39), l_55, l_55), l_340);
    /* statement id: 296 */
    //assert (g_10[0] == &l_55 || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0 || g_10[0] == dangling);
    assert (g_314 == &l_55 || g_314 == &g_34 || g_314 == &g_6);
    g_264 = l_533[3][9];
    /* statement id: 297 */
    assert ((g_264 >= &g_192[0] && g_264 <= &g_192[8]) || g_264 == 0);
    return l_534;
    /* statement id: 298 */
    //assert (g_10[0] == dangling || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0);
    //assert (g_314 == dangling || g_314 == &g_34 || g_314 == &g_6);
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_312 g_313 g_265.f3 g_192.f0 g_265.f1 g_34 g_97 g_6 g_35 g_192.f1 g_265.f7 g_265.f0 g_192.f5 g_399 g_400 g_314 g_192.f2 g_241 g_265.f2 g_265.f5 g_265.f8 g_192.f8 g_192.f7 g_265.f4 g_265.f6 g_479 g_192.f3 g_192.f4 g_192
 * writes: g_6 g_313 g_35 g_10 g_399 g_314 g_480 g_34 g_241 g_97 g_512 g_192.f8 g_264 g_191 g_312
 */
static int32_t * const  func_50(int32_t * p_51, int32_t * p_52, uint32_t  p_53, int32_t * p_54)
{ /* block id: 196 */
    const int32_t **l_346 = &g_10[3];
    const int32_t ***l_345 = &l_346;
    const uint32_t l_347 = 0x38B602A2;
    int8_t l_376 = (-1);
    struct S0 l_413[8][5] = {{{-1018,718,2,342,10060,-1,166,293,1},{-1018,718,2,342,10060,-1,166,293,1},{-957,181,11,-331,13822,-1,1359,1946,-0},{551,268,5,269,2010,0,49,807,0},{1716,702,14,151,-10769,0,337,390,-0}},{{966,528,15,-201,7040,0,1124,375,-1},{-1016,435,10,-187,7741,-0,1345,738,0},{-1358,133,13,170,15798,0,812,1285,-1},{-1358,133,13,170,15798,0,812,1285,-1},{-1016,435,10,-187,7741,-0,1345,738,0}},{{1716,702,14,151,-10769,0,337,390,-0},{-1855,627,7,-223,-4431,-1,992,950,0},{1071,213,8,-95,4043,-1,941,31,1},{1716,702,14,151,-10769,0,337,390,-0},{-1961,100,5,-156,1386,-0,1300,1521,-1}},{{514,230,19,-302,5302,1,754,195,-0},{-1016,435,10,-187,7741,-0,1345,738,0},{1226,582,13,-143,1997,1,897,1029,-0},{-1016,435,10,-187,7741,-0,1345,738,0},{514,230,19,-302,5302,1,754,195,-0}},{{1071,213,8,-95,4043,-1,941,31,1},{-1018,718,2,342,10060,-1,166,293,1},{-1855,627,7,-223,-4431,-1,992,950,0},{-1961,100,5,-156,1386,-0,1300,1521,-1},{-1018,718,2,342,10060,-1,166,293,1}},{{514,230,19,-302,5302,1,754,195,-0},{1678,330,7,-209,1782,1,150,1019,1},{1678,330,7,-209,1782,1,150,1019,1},{514,230,19,-302,5302,1,754,195,-0},{-1358,133,13,170,15798,0,812,1285,-1}},{{1716,702,14,151,-10769,0,337,390,-0},{551,268,5,269,2010,0,49,807,0},{-957,181,11,-331,13822,-1,1359,1946,-0},{-1018,718,2,342,10060,-1,166,293,1},{-1018,718,2,342,10060,-1,166,293,1}},{{966,528,15,-201,7040,0,1124,375,-1},{514,230,19,-302,5302,1,754,195,-0},{966,528,15,-201,7040,0,1124,375,-1},{-1358,133,13,170,15798,0,812,1285,-1},{514,230,19,-302,5302,1,754,195,-0}}};
    uint32_t l_444[1][9] = {{0x2BECF8EA,1U,0x2BECF8EA,1U,0x2BECF8EA,1U,0x2BECF8EA,1U,0x2BECF8EA}};
    int32_t l_446 = 0xFE190DD1;
    uint8_t l_447 = 0x97;
    const struct S0 ***l_458 = (void*)0;
    const struct S0 *** const *l_457 = &l_458;
    const uint8_t l_483[7] = {0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2};
    int16_t l_499 = 0xA8F1;
    int32_t l_521 = 0xB01A7F6B;
    int32_t ****l_525 = &g_312;
    int32_t *****l_524 = &l_525;
    const int8_t l_531 = 0x3F;
    int i, j;
    (*p_51) = ((safe_add_func_uint8_t_u_u((&g_6 == (void*)0), 0x2B)) >= ((safe_sub_func_int8_t_s_s((l_345 == &g_313), p_53)) || 0x0966FC5E));
    (*g_312) = (*g_312);
    if (l_347)
    { /* block id: 199 */
lbl_514:
        for (g_35 = 0; g_35 < 4; g_35 += 1)
        {
            g_10[g_35] = (void*)0;
        }
    }
    else
    { /* block id: 201 */
        struct S0 *l_350 = &g_192[0];
        int32_t l_353 = 0;
        int32_t **l_387[3][3] = {{&g_314,&g_314,&g_314},{&g_314,&g_314,&g_314},{&g_314,&g_314,&g_314}};
        int i, j;
        (*p_52) = ((safe_mod_func_uint16_t_u_u((((((l_350 == &g_192[5]) >= ((((safe_mod_func_int32_t_s_s(((l_353 == (safe_sub_func_uint8_t_u_u((5 == 8), (safe_mod_func_int32_t_s_s((((*p_54) == (safe_lshift_func_int16_t_s_u((&g_313 == &l_346), 2))) != g_265.f3), g_192[2].f0))))) ^ p_53), l_353)) || 0x04) && p_53) || 255U)) ^ g_265.f1) != p_53) == 0x2A79), g_34)) <= p_53);
        if ((((safe_sub_func_int16_t_s_s(l_353, (((!(safe_add_func_int16_t_s_s((!(g_97 ^ (((((safe_lshift_func_uint16_t_u_u((safe_add_func_uint8_t_u_u(p_53, g_6)), 3)) <= ((((0x8C017859 ^ (((void*)0 == &g_265) != (safe_lshift_func_uint8_t_u_u(((251U <= (safe_add_func_int32_t_s_s((*p_51), 0xC920B3F1))) || (*p_51)), g_35)))) <= 0xEEB15368) >= 1U) != g_192[2].f1)) || 0x77C2) != l_353) == 0x9F))), l_376))) & g_265.f7) >= p_53))) || p_53) > 1))
        { /* block id: 203 */
            uint8_t l_388 = 253U;
            int32_t * const l_401 = &g_34;
            int32_t ***l_450 = &l_387[1][1];
            const struct S0 * const *l_456 = &g_264;
            const struct S0 * const **l_455 = &l_456;
            const struct S0 * const ***l_454 = &l_455;
            if (((safe_mod_func_uint16_t_u_u((p_53 <= (safe_sub_func_int32_t_s_s((((*p_52) && (((safe_add_func_int8_t_s_s((safe_rshift_func_int8_t_s_u(((safe_mod_func_uint32_t_u_u(0x4D7976DD, (255U | 1))) > ((-10) <= (l_387[1][0] != (*g_312)))), 5)), g_97)) ^ g_265.f0) <= 1U)) ^ 3), (-9)))), l_388)) && (*p_54)))
            { /* block id: 204 */
                uint8_t l_394 = 0x47;
                int32_t ****l_424 = &g_312;
                if (((safe_lshift_func_uint16_t_u_u((!((safe_sub_func_uint16_t_u_u(g_192[2].f5, (g_34 | ((p_53 || (l_394 == (((p_53 <= (((safe_rshift_func_uint8_t_u_u(g_35, 7)) == (safe_rshift_func_int8_t_s_u(0x61, (l_394 <= p_53)))) <= p_53)) != l_388) < p_53))) >= p_53)))) < 0x77)), p_53)) && (-5)))
                { /* block id: 205 */
                    (*l_345) = (void*)0;
                    /* statement id: 206 */
                    assert (l_346 == 0);
                    g_399 = g_399;
                    return l_401;
                    /* statement id: 208 */
                    //assert (func_50_rv == &g_34);
                }
                else
                { /* block id: 209 */
                    struct S0 **l_403 = &l_350;
                    struct S0 ***l_402 = &l_403;
                    int32_t *l_414[3];
                    int32_t ****l_423 = &g_312;
                    int32_t * const **l_428 = (void*)0;
                    int i;
                    for (i = 0; i < 3; i = i + 1)
                        l_414[i] = (void*)0;
                    if ((*l_401))
                    { /* block id: 210 */
                        struct S0 ****l_404 = (void*)0;
                        struct S0 ****l_405 = &l_402;
                        int16_t l_406[2];
                        int i;
                        for (i = 0; i < 2; i = i + 1)
                            l_406[i] = 0;
                        (*l_405) = l_402;
                        (*p_52) = (*p_54);
                        (*p_52) = l_406[0];
                        (*p_51) = ((l_394 >= 0x3C83) && l_406[0]);
                    }
                    else
                    { /* block id: 215 */
                        uint16_t l_408[3];
                        int i;
                        for (i = 0; i < 3; i = i + 1)
                            l_408[i] = 0U;
                        (*g_313) = p_54;
                        /* statement id: 216 */
                        //assert (g_314 == &l_55);
                        (*****g_399) = (((!l_408[1]) & (((l_394 != 0xA5EB) < g_265.f1) <= 248U)) & (p_53 ^ l_408[2]));
                        (*p_51) = ((((0x4DA1 == ((p_53 != ((safe_lshift_func_int8_t_s_u((*l_401), (((**g_399) != (void*)0) || ((*l_401) && 0x1211)))) ^ p_53)) | (safe_lshift_func_uint16_t_u_u(g_265.f1, 14)))) < 0xE9320118) > 0xE15A) | g_192[2].f2);
                        if (g_265.f1)
                            goto lbl_425;
                    }
                    /* facts after branching */
                    //assert (g_314 == &l_55 || g_314 == dangling || g_314 == &g_6 || (g_314 >= &l_619[0][0] && g_314 <= &l_619[0][7]) || g_314 == &g_34);
lbl_425:
                    if ((*p_54))
                    { /* block id: 220 */
                        const int32_t ***l_422 = (void*)0;
                        (***g_400) = p_54;
                        /* statement id: 221 */
                        //assert (g_314 == &l_55);
                        (***g_312) = (((g_265.f3 == (*l_401)) & ((safe_lshift_func_uint8_t_u_u((safe_add_func_uint8_t_u_u(((safe_mod_func_uint32_t_u_u(g_34, (+((****g_399) == (void*)0)))) | (l_422 != (**g_399))), ((l_423 != l_424) <= (*g_314)))), 0)) | p_53)) >= (*l_401));
                    }
                    else
                    { /* block id: 223 */
                        return p_51;
                        /* statement id: 224 */
                        //assert (func_50_rv == &g_6);
                    }
                    /* facts after branching */
                    //assert (g_314 == &l_55);
                    (*p_54) = (safe_rshift_func_uint16_t_u_u(((l_428 == (*l_423)) <= (~(safe_sub_func_int8_t_s_s((0x58 || (safe_lshift_func_uint8_t_u_s(g_241, (safe_lshift_func_int8_t_s_s((safe_rshift_func_uint16_t_u_s((0x90BF1668 | (safe_sub_func_uint32_t_u_u(g_241, ((((safe_add_func_int8_t_s_s(((safe_add_func_uint32_t_u_u((l_444[0][2] <= ((+(g_265.f2 >= (-4))) == (-6))), l_446)) & p_53), 0x86)) && 0x9801) <= g_265.f5) == g_265.f0)))), 0)), p_53))))), (*l_401))))), l_447));
                }
                /* facts after branching */
                //assert (g_314 == &l_55);
                if ((safe_sub_func_int8_t_s_s(((*l_401) && ((&l_346 == l_450) | (((((g_6 >= ((~(p_53 == (**g_313))) & ((safe_add_func_uint16_t_u_u((l_454 != l_457), 0x7E0C)) == p_53))) && (**g_313)) != (****l_424)) & g_265.f8) <= (*l_401)))), g_6)))
                { /* block id: 229 */
                    uint32_t l_467 = 0xE55A4685;
                    int32_t l_472 = 0x530713DA;
                    for (l_353 = 0; (l_353 == 12); l_353 = safe_add_func_int32_t_s_s(l_353, 6))
                    { /* block id: 232 */
                        l_472 = ((p_53 > (safe_lshift_func_uint8_t_u_s(0x62, (safe_sub_func_int16_t_s_s(((safe_mod_func_int16_t_s_s((l_467 > 1U), ((safe_rshift_func_int16_t_s_u((p_51 == (***g_400)), g_192[2].f8)) && (((safe_rshift_func_int8_t_s_s(p_53, 6)) || (g_192[2].f7 >= g_265.f4)) && (*p_52))))) > 9U), p_53))))) < 0);
                        (*l_346) = (*g_313);
                        (*g_313) = func_70((****g_399), ((g_265.f6 == p_53) <= (((void*)0 == (*g_400)) | 0)), p_53, (safe_add_func_int16_t_s_s(0x2AF4, (g_241 < 0x2C5EDC73))));
                        if (l_447)
                            goto lbl_475;
                        if ((*p_54))
                            break;
                    }
                    /* facts after for loop */
                    //assert (g_10[0] == &l_55 || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0 || g_10[0] == dangling);
lbl_475:
                    (*g_314) = (****l_424);
                    (***g_399) = (*g_312);
                }
                else
                { /* block id: 241 */
                    struct S0 ***l_481 = &g_480;
                    for (l_446 = (-3); (l_446 <= 19); l_446 = safe_add_func_uint16_t_u_u(l_446, 1))
                    { /* block id: 244 */
                        int32_t *l_478 = &g_34;
                        if ((*p_54))
                            break;
                        (*l_346) = l_478;
                        (*p_54) = (****g_400);
                    }
                    if ((g_479 == l_481))
                    { /* block id: 249 */
                        return p_52;
                        /* statement id: 250 */
                        //assert (func_50_rv == &g_6);
                    }
                    else
                    { /* block id: 251 */
                        return (*g_313);
                        /* statement id: 252 */
                        //assert (func_50_rv == &l_55);
                    }
                }
                /* facts after branching */
                //assert (g_10[0] == &l_55 || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0 || g_10[0] == dangling);
            }
            else
            { /* block id: 255 */
                struct S0 **l_482[6][9][4] = {{{&l_350,&l_350,&g_191,&g_191},{&l_350,&l_350,&l_350,&g_191},{&l_350,&l_350,&l_350,&g_191},{&g_191,&g_191,&l_350,(void*)0},{(void*)0,&g_191,&l_350,&g_191},{&g_191,&l_350,&g_191,&g_191},{&g_191,&g_191,&l_350,&l_350},{&l_350,&l_350,&l_350,&g_191},{&g_191,&l_350,&g_191,&l_350}},{{&l_350,&g_191,&l_350,&g_191},{(void*)0,&g_191,(void*)0,&l_350},{(void*)0,&g_191,&g_191,&l_350},{&g_191,(void*)0,&g_191,&g_191},{&l_350,&l_350,&g_191,&l_350},{&g_191,&l_350,&g_191,&l_350},{(void*)0,&l_350,(void*)0,&g_191},{(void*)0,&g_191,&l_350,&g_191},{&l_350,&g_191,&g_191,&l_350}},{{&g_191,&l_350,&l_350,&g_191},{&l_350,(void*)0,&l_350,&l_350},{&g_191,&g_191,&g_191,&l_350},{&g_191,&g_191,&l_350,&l_350},{(void*)0,&l_350,&l_350,&l_350},{&g_191,&l_350,&l_350,&g_191},{&l_350,&g_191,&l_350,&l_350},{&l_350,&l_350,&g_191,(void*)0},{&l_350,&l_350,&l_350,&g_191}},{{&g_191,&g_191,&g_191,&l_350},{&l_350,&l_350,&l_350,&l_350},{&g_191,&l_350,&l_350,&g_191},{&l_350,&l_350,&g_191,&l_350},{&l_350,&l_350,&l_350,&l_350},{&l_350,&g_191,&l_350,&l_350},{&l_350,&l_350,&g_191,&l_350},{&l_350,&l_350,&g_191,&g_191},{&g_191,&l_350,&g_191,&l_350}},{{&l_350,&l_350,&l_350,&l_350},{&l_350,&g_191,&g_191,&g_191},{(void*)0,&l_350,&l_350,(void*)0},{&g_191,&l_350,&l_350,&l_350},{&l_350,&g_191,&l_350,&g_191},{&g_191,&l_350,&l_350,&l_350},{&l_350,&l_350,&l_350,&l_350},{&l_350,&g_191,(void*)0,&l_350},{&l_350,&g_191,&g_191,&g_191}},{{&g_191,&l_350,&l_350,&l_350},{&l_350,&l_350,&l_350,&l_350},{&g_191,&l_350,&g_191,&g_191},{&l_350,&g_191,(void*)0,&g_191},{&l_350,&g_191,&l_350,&l_350},{&g_191,&l_350,&g_191,&l_350},{&l_350,&l_350,&g_191,&l_350},{&l_350,&l_350,&g_191,&g_191},{&g_191,&l_350,&l_350,&g_191}}};
                int i, j, k;
                (*g_479) = l_482[3][5][2];
                /* statement id: 256 */
                assert (g_480 == 0 || g_480 == &g_191 || g_480 == &l_350);
                (*l_401) = (*p_54);
            }
            /* facts after branching */
            //assert (g_10[0] == &l_55 || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0 || g_10[0] == dangling);
            //assert (g_314 == dangling || g_314 == &g_6 || g_314 == &l_55 || (g_314 >= &l_619[0][0] && g_314 <= &l_619[0][7]) || g_314 == &g_34);
            //assert (g_480 == 0 || g_480 == &g_191 || g_480 == &l_350 || g_480 == dangling);
        }
        else
        { /* block id: 259 */
            int16_t l_510 = 0xE77C;
            struct S0 *l_513 = &l_413[0][0];
            for (g_6 = 0; (g_6 <= 3); g_6 += 1)
            { /* block id: 262 */
                uint16_t l_509 = 0xD73A;
                for (g_241 = 0; (g_241 <= 3); g_241 += 1)
                { /* block id: 265 */
                    for (g_97 = 0; (g_97 <= 3); g_97 += 1)
                    { /* block id: 268 */
                        int i;
                        if (l_483[0])
                            break;
                    }
                }
                for (l_446 = 17; (l_446 >= 16); l_446 = safe_sub_func_uint16_t_u_u(l_446, 3))
                { /* block id: 274 */
                    int32_t ***l_500 = &l_387[1][0];
                    if ((((safe_add_func_uint32_t_u_u(((((safe_lshift_func_uint16_t_u_s((safe_lshift_func_uint16_t_u_u((safe_rshift_func_int8_t_s_s(p_53, 5)), 5)), 3)) && (+(safe_add_func_uint8_t_u_u((l_499 & (l_500 != (void*)0)), (safe_lshift_func_uint16_t_u_u(g_192[2].f3, 14)))))) || 0xD8A2) && (g_192[2].f3 <= (safe_lshift_func_int16_t_s_s((safe_mod_func_int8_t_s_s(p_53, (safe_add_func_int16_t_s_s(((p_54 != (void*)0) && 9U), p_53)))), 0)))), l_509)) == g_192[2].f7) & l_510))
                    { /* block id: 275 */
                        int32_t *** const *l_511[5][6] = {{(void*)0,(void*)0,&l_500,&l_500,(void*)0,(void*)0},{(void*)0,&l_500,&l_500,(void*)0,(void*)0,&l_500},{(void*)0,(void*)0,&l_500,&l_500,(void*)0,(void*)0},{(void*)0,&l_500,&l_500,(void*)0,(void*)0,&l_500},{(void*)0,(void*)0,&l_500,&l_500,(void*)0,(void*)0}};
                        int i, j;
                        g_512 = l_511[1][2];
                        /* statement id: 276 */
                        assert (g_512 == &g_312 || g_512 == 0 || g_512 == &l_500);
                        (*p_54) = (g_192[2].f4 > (l_513 == (void*)0));
                        if ((*p_52))
                            continue;
                        //assert (g_512 == &g_312 || g_512 == 0 || g_512 == dangling);
                        (***g_400) = p_52;
                        /* statement id: 279 */
                        assert (g_314 == &g_6);
                    }
                    else
                    { /* block id: 280 */
                        (*p_54) = (*p_52);
                    }
                    /* facts after branching */
                    //assert (g_512 == &g_312 || g_512 == 0 || g_512 == dangling || g_512 == &l_500);
                    if (l_509)
                        continue;
                    //assert (g_512 == &g_312 || g_512 == 0 || g_512 == dangling);
                    for (g_97 = 0; (g_97 <= 2); g_97 += 1)
                    { /* block id: 286 */
                        if (g_265.f7)
                            goto lbl_514;
                        //assert (g_512 == &g_312 || g_512 == 0 || g_512 == dangling);
                    }
                }
            }
        }
        /* facts after branching */
        //assert (g_10[0] == &l_55 || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0 || g_10[0] == dangling);
        //assert (g_314 == dangling || g_314 == &g_6 || g_314 == &l_55 || (g_314 >= &l_619[0][0] && g_314 <= &l_619[0][7]) || g_314 == &g_34);
        //assert (g_480 == 0 || g_480 == &g_191 || g_480 == &l_350 || g_480 == dangling);
        (*g_313) = func_56((*l_350), (safe_rshift_func_uint16_t_u_u(((safe_mod_func_uint8_t_u_u((g_192[2].f2 & ((safe_mod_func_int32_t_s_s((g_192[2].f0 ^ l_521), (safe_lshift_func_uint8_t_u_s(g_35, 0)))) > (((l_524 == &g_400) > (safe_rshift_func_uint8_t_u_s((safe_sub_func_int32_t_s_s((g_265.f3 ^ (+p_53)), 4294967291U)), g_192[2].f2))) != 9))), p_53)) < l_531), p_53)), p_51, p_54, g_192[2].f1);
        /* statement id: 292 */
        //assert (g_314 == &g_34 || g_314 == &l_55);
    }
    /* facts after branching */
    //assert (g_10[0] == &l_55 || g_10[0] == &g_34 || g_10[0] == &g_6 || g_10[0] == 0 || g_10[0] == dangling);
    //assert (g_314 == &g_34 || g_314 == &l_55 || g_314 == dangling || g_314 == &g_6 || (g_314 >= &l_619[0][0] && g_314 <= &l_619[0][7]));
    (**l_345) = p_51;
    return p_52;
    /* statement id: 295 */
    //assert (func_50_rv == &g_6);
}


/* ------------------------------------------ */
/* 
 * reads : g_35 g_34 g_6 g_97 g_241 g_192.f0 g_192.f4 g_192.f8 g_192.f6 g_192.f1 g_192.f3 g_265.f1 g_192.f7 g_265.f5 g_265.f8 g_265.f6 g_265.f0 g_265.f3 g_265.f7 g_312 g_313 g_314 l_55
 * writes: g_6 g_10 g_34 g_35 g_192.f8 g_264 g_241 g_97 g_191 g_312 g_314 l_55
 */
static int32_t * func_56(struct S0  p_57, uint32_t  p_58, int32_t * p_59, int32_t * p_60, int32_t  p_61)
{ /* block id: 27 */
    uint32_t l_69 = 0x8EB2A14D;
    int32_t l_80 = (-1);
    const int32_t * const l_81 = &g_34;
    int32_t *l_111 = (void*)0;
    const struct S0 *l_262 = (void*)0;
    int32_t ***l_322 = &g_313;
    if (l_69)
    { /* block id: 28 */
        const int32_t l_75 = 0x94120B1A;
        int32_t *l_104 = &g_34;
        int32_t **l_103 = &l_104;
        (*l_103) = func_70(p_60, ((((void*)0 != p_60) && 1) ^ l_75), (0x3F132C5A == (((safe_lshift_func_uint8_t_u_u((((l_80 < (0x7A17 >= ((void*)0 != l_81))) ^ l_75) & 0xFC), g_35)) >= g_34) >= l_75)), l_75);
        /* statement id: 36 */
        //assert (l_104 == &g_6 || l_104 == &l_55);
        (*l_103) = func_70(&g_34, ((p_60 == p_60) && g_35), ((safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_u(((*l_103) != (*l_103)), 0)), 0)) ^ ((*l_81) > (((((((0xB5E4 & (*l_104)) ^ g_34) & 0x21BE) && (*l_81)) | g_97) <= p_57.f8) ^ p_57.f8))), (*l_81));
        /* statement id: 37 */
        assert (l_104 == &g_34);
    }
    else
    { /* block id: 38 */
        int32_t *l_109 = &g_6;
        int32_t **l_110[1][8][7] = {{{&l_109,(void*)0,&l_109,(void*)0,&l_109,&l_109,&l_109},{&l_109,&l_109,(void*)0,(void*)0,&l_109,(void*)0,&l_109},{&l_109,&l_109,&l_109,&l_109,(void*)0,(void*)0,&l_109},{&l_109,(void*)0,&l_109,&l_109,&l_109,&l_109,&l_109},{&l_109,&l_109,&l_109,(void*)0,&l_109,(void*)0,&l_109},{(void*)0,&l_109,&l_109,&l_109,(void*)0,&l_109,&l_109},{&l_109,&l_109,(void*)0,(void*)0,&l_109,(void*)0,&l_109},{&l_109,(void*)0,&l_109,&l_109,&l_109,&l_109,(void*)0}}};
        const int32_t l_216 = 0xBA30310D;
        int32_t l_219 = (-1);
        int i, j, k;
        l_111 = func_70(l_109, g_34, p_58, ((*l_81) & ((*l_109) >= 0x6A3BB2BE)));
        /* statement id: 39 */
        assert (l_111 == &g_6);
        for (p_61 = 0; (p_61 <= (-28)); --p_61)
        { /* block id: 42 */
            int8_t l_114[8][10][3] = {{{(-2),0,(-2)},{0,6,0},{0x40,(-1),0x3C},{0x77,0,0xD4},{0xD3,(-5),(-5)},{0x77,9,(-4)},{0x40,0x40,0},{0,0xB6,(-4)},{(-2),0,0x40},{0x55,0xE4,(-5)}},{{(-1),(-2),0x40},{0x5E,(-4),(-4)},{3,0xD3,0},{0,0,(-4)},{0xA4,7,(-5)},{(-4),0x55,0xD4},{0,7,0x3C},{0,0,0},{7,0xD3,(-2)},{0xB6,(-4),0x77}},{{0x3C,(-2),0x01},{6,0xE4,(-1)},{(-2),0x40,0xD3},{(-4),(-4),0xE4},{(-1),(-1),0x01},{0x42,0xB6,(-4)},{0,0,0x3C},{6,0x42,(-4)},{3,0x01,0x01},{(-1),0x5E,0xE4}},{{(-5),(-5),0xD3},{0,(-4),0},{0xD3,0,0},{9,(-4),0},{0,(-5),0},{(-4),0x5E,0x42},{(-1),0x01,(-2)},{0,0x42,(-5)},{0xA4,0,7},{0,0xB6,6}},{{(-1),(-1),(-5)},{(-4),(-4),0xD4},{0,0x40,(-1)},{9,0x55,0x77},{0xD3,0,(-1)},{0,0xD4,0xD4},{(-5),0xA4,(-5)},{(-1),0xE4,6},{3,(-1),7},{6,9,(-5)}},{{0,(-1),(-2)},{0x42,0xE4,0x42},{(-1),0xA4,0},{(-4),0xD4,0},{(-2),0,0},{0x5E,0x55,0},{(-2),0x40,0xD3},{(-4),(-4),0xE4},{(-1),(-1),0x01},{0x42,0xB6,(-4)}},{{0,0,0x3C},{6,0x42,(-4)},{3,0x01,0x01},{(-1),0x5E,0xE4},{(-5),(-5),0xD3},{0,(-4),0},{0xD3,0,0},{9,(-4),0},{0,(-5),0},{(-4),0x5E,0x42}},{{(-1),0x01,(-2)},{0,0x42,(-5)},{0xA4,0,7},{0,0xB6,6},{(-1),(-1),(-5)},{(-4),(-4),0xD4},{0,0x40,(-1)},{9,0x55,0x77},{0xD3,0,(-1)},{0,0xD4,0xD4}}};
            int i, j, k;
            if (l_114[0][5][2])
                break;
        }
        for (g_35 = 0; (g_35 < 15); g_35 = safe_add_func_uint16_t_u_u(g_35, 3))
        { /* block id: 47 */
            uint16_t l_147[5];
            int32_t *l_185[4][7][9] = {{{&g_34,&g_6,&g_6,&g_34,&g_34,&g_6,&g_34,&g_34,&g_6},{&g_6,&g_6,&g_34,&g_34,&g_6,&g_6,&g_34,&g_34,&g_34},{&g_34,&g_34,&g_6,&g_34,&g_6,&g_34,&g_6,(void*)0,(void*)0},{(void*)0,(void*)0,&g_34,&g_34,&g_34,(void*)0,(void*)0,(void*)0,&g_34},{&g_6,&g_6,&g_6,&g_34,&g_6,&g_6,&g_34,(void*)0,&g_6},{&g_34,&g_34,&g_34,(void*)0,&g_6,(void*)0,&g_34,(void*)0,&g_34},{&g_6,(void*)0,&g_6,(void*)0,&g_34,&g_6,&g_6,(void*)0,&g_34}},{{&g_34,&g_6,(void*)0,&g_6,&g_6,&g_6,(void*)0,(void*)0,&g_6},{&g_6,&g_34,&g_34,&g_6,&g_6,&g_6,&g_34,(void*)0,&g_6},{&g_34,(void*)0,&g_6,&g_6,&g_34,&g_34,&g_34,(void*)0,(void*)0},{(void*)0,&g_6,&g_34,&g_34,&g_6,&g_6,&g_6,(void*)0,&g_34},{&g_34,&g_34,&g_6,&g_34,&g_6,&g_34,&g_6,(void*)0,(void*)0},{(void*)0,(void*)0,&g_34,&g_34,&g_34,(void*)0,(void*)0,(void*)0,&g_34},{&g_6,&g_6,&g_6,&g_34,&g_6,&g_6,&g_34,(void*)0,&g_6}},{{&g_34,&g_34,&g_34,(void*)0,&g_6,(void*)0,&g_34,(void*)0,&g_34},{&g_6,(void*)0,&g_6,(void*)0,&g_34,&g_6,&g_6,(void*)0,&g_34},{&g_34,&g_6,(void*)0,&g_6,&g_6,&g_6,(void*)0,(void*)0,&g_6},{&g_6,&g_34,&g_34,&g_6,&g_6,&g_6,&g_34,(void*)0,&g_6},{&g_34,(void*)0,&g_6,&g_6,&g_34,&g_34,&g_34,(void*)0,(void*)0},{(void*)0,&g_6,&g_34,&g_34,&g_6,&g_6,&g_6,(void*)0,&g_34},{&g_34,&g_34,&g_6,&g_34,&g_6,&g_34,&g_6,(void*)0,(void*)0}},{{(void*)0,(void*)0,&g_34,&g_34,&g_34,(void*)0,(void*)0,(void*)0,&g_34},{&g_6,&g_6,&g_6,&g_34,&g_6,&g_6,&g_34,(void*)0,&g_6},{&g_34,&g_34,&g_6,&g_34,(void*)0,&g_6,&g_34,&g_34,&g_6},{(void*)0,&g_34,(void*)0,&g_6,&g_6,&g_34,(void*)0,&g_34,&g_34},{(void*)0,&g_34,(void*)0,&g_6,&g_6,&g_6,&g_6,&g_34,(void*)0},{&g_6,&g_34,&g_34,(void*)0,(void*)0,&g_34,&g_6,&g_34,&g_34},{&g_34,&g_34,&g_6,&g_34,&g_6,&g_34,&g_34,&g_34,(void*)0}}};
            int8_t l_190 = 0x89;
            uint8_t l_212 = 1U;
            const int32_t **l_213 = &g_10[3];
            const struct S0 *l_235 = &g_192[2];
            const struct S0 **l_234 = &l_235;
            int i, j, k;
            for (i = 0; i < 5; i = i + 1)
                l_147[i] = 0U;
        }
    }
    /* facts after branching */
    assert (l_111 == &g_6 || l_111 == 0);
    for (g_35 = (-23); (g_35 >= 9); ++g_35)
    { /* block id: 100 */
        for (p_61 = 0; (p_61 <= 3); p_61 += 1)
        { /* block id: 103 */
            struct S0 **l_244 = &g_191;
            int32_t l_245[10] = {0,0,0,0,0,0,0,0,0,0};
            int i;
            (*p_60) = ((l_244 == &g_191) != g_241);
            if (l_245[5])
                break;
        }
        if ((*p_59))
            break;
        (*p_60) = 0x590F9319;
    }
    for (g_34 = 13; (g_34 != 6); g_34--)
    { /* block id: 112 */
        struct S0 * const *l_260[2][1];
        int32_t l_266 = 0xF3735969;
        int32_t l_283[7][6][6] = {{{1,0x8AD69F50,(-4),(-4),0x8AD69F50,1},{0x1C5CEDB8,(-1),(-8),0x60C5AEF0,1,1},{0x8AD69F50,0x87561C71,0,1,0,0x87561C71},{0x8AD69F50,1,1,0x60C5AEF0,(-8),(-1)},{0x1C5CEDB8,1,0x8AD69F50,(-4),(-4),0x8AD69F50},{1,1,4,0x1C5CEDB8,(-8),(-4)}},{{0x87561C71,1,0x60C5AEF0,4,0,4},{0x60C5AEF0,0x87561C71,0x60C5AEF0,(-1),1,(-4)},{0x0102855B,(-1),4,0xDA7767F0,0x8AD69F50,0x8AD69F50},{0xDA7767F0,0x8AD69F50,0x8AD69F50,0xDA7767F0,4,(-1)},{0x0102855B,(-4),1,(-1),0x60C5AEF0,0x87561C71},{0x60C5AEF0,4,0,4,0x60C5AEF0,1}},{{0x87561C71,(-4),(-8),0x1C5CEDB8,4,1},{1,0x8AD69F50,(-4),(-4),0x8AD69F50,1},{0x1C5CEDB8,(-1),(-8),0x60C5AEF0,1,1},{0x8AD69F50,0x87561C71,0,1,0,0x87561C71},{0x8AD69F50,1,1,0x60C5AEF0,(-8),(-1)},{0x1C5CEDB8,1,0x8AD69F50,(-4),(-4),0x8AD69F50}},{{1,1,4,0x1C5CEDB8,(-8),(-4)},{0x87561C71,1,0x60C5AEF0,4,0,4},{0x60C5AEF0,0x87561C71,0x60C5AEF0,(-1),1,(-4)},{0x0102855B,(-1),4,0xDA7767F0,0x8AD69F50,0x8AD69F50},{0xDA7767F0,0x8AD69F50,0x8AD69F50,0xDA7767F0,0x87561C71,1},{0x60C5AEF0,0x8AD69F50,4,1,(-4),0x1C5CEDB8}},{{(-4),0x87561C71,0x0102855B,0x87561C71,(-4),(-8)},{0x1C5CEDB8,0x8AD69F50,0,(-1),0x87561C71,4},{4,0xDA7767F0,0x8AD69F50,0x8AD69F50,0xDA7767F0,4},{(-1),1,0,(-4),4,(-8)},{0xDA7767F0,0x1C5CEDB8,0x0102855B,4,0x0102855B,0x1C5CEDB8},{0xDA7767F0,(-8),4,(-4),0,1}},{{(-1),4,0xDA7767F0,0x8AD69F50,0x8AD69F50,0xDA7767F0},{4,4,0x87561C71,(-1),0,0x8AD69F50},{0x1C5CEDB8,(-8),(-4),0x87561C71,0x0102855B,0x87561C71},{(-4),0x1C5CEDB8,(-4),1,4,0x8AD69F50},{0x60C5AEF0,1,0x87561C71,1,0xDA7767F0,0xDA7767F0},{1,0xDA7767F0,0xDA7767F0,1,0x87561C71,1}},{{0x60C5AEF0,0x8AD69F50,4,1,(-4),0x1C5CEDB8},{(-4),0x87561C71,0x0102855B,0x87561C71,(-4),(-8)},{0x1C5CEDB8,0x8AD69F50,0,(-1),0x87561C71,4},{4,0xDA7767F0,0x8AD69F50,0x8AD69F50,0xDA7767F0,4},{(-1),1,0,(-4),4,(-8)},{0xDA7767F0,0x1C5CEDB8,0x0102855B,4,0x0102855B,0x1C5CEDB8}}};
        int i, j, k;
        for (i = 0; i < 2; i = i + 1)
        {
            for (j = 0; j < 1; j = j + 1)
                l_260[i][j] = &g_191;
        }
        if ((safe_sub_func_int16_t_s_s((&g_34 == (void*)0), (p_57.f3 && p_57.f0))))
        { /* block id: 113 */
            int32_t *l_250 = &g_34;
            if ((*p_59))
            { /* block id: 114 */
                int32_t **l_251 = &l_250;
                (*l_251) = l_250;
                (*p_60) = (-1);
            }
            else
            { /* block id: 117 */
                int32_t **l_261 = &l_250;
                g_192[2].f8 = (!(safe_add_func_uint16_t_u_u((((0x69 == 0x38) | (p_57.f7 != g_192[2].f0)) && ((safe_mod_func_uint8_t_u_u(((void*)0 == &p_57), ((safe_unary_minus_func_uint16_t_u((((((safe_add_func_uint16_t_u_u(g_192[2].f4, (g_192[2].f8 ^ (l_260[1][0] != (void*)0)))) && 0x43) == 0x8D) | g_34) == 0x55))) & g_192[2].f6))) & (-1))), g_192[2].f1)));
                if ((*p_59))
                    continue;
                (*l_261) = &g_6;
                /* statement id: 120 */
                assert (l_250 == &g_6);
                for (p_61 = 0; (p_61 <= 3); p_61 += 1)
                { /* block id: 123 */
                    const struct S0 **l_263[9] = {&l_262,&l_262,&l_262,&l_262,&l_262,&l_262,&l_262,&l_262,&l_262};
                    int i;
                    if ((*l_250))
                        break;
                    g_264 = l_262;
                    /* statement id: 125 */
                    assert (g_264 == 0);
                }
            }
            /* facts after branching */
            assert (l_250 == &g_6 || l_250 == &g_34);
            if ((*p_60))
                continue;
        }
        else
        { /* block id: 129 */
            (*p_60) = l_266;
            (*p_60) = (*p_59);
        }
        for (l_266 = 0; (l_266 <= 0); l_266 += 1)
        { /* block id: 135 */
            uint32_t l_284 = 4294967292U;
            const struct S0 **l_294[5];
            int i;
            for (i = 0; i < 5; i = i + 1)
                l_294[i] = &l_262;
            for (g_241 = 0; (g_241 <= 3); g_241 += 1)
            { /* block id: 138 */
                uint32_t l_297 = 4294967286U;
                int i;
                (*p_60) = l_266;
                for (g_97 = 0; (g_97 <= 0); g_97 += 1)
                { /* block id: 142 */
                    uint8_t l_282 = 0U;
                    if ((252U & 0x32))
                    { /* block id: 143 */
                        int i;
                        g_10[g_241] = (void*)0;
                        (*p_60) = (*p_59);
                    }
                    else
                    { /* block id: 146 */
                        int8_t l_287[1][1][8] = {{{0x60,0x36,0x60,0x60,0x36,0x60,0x60,0x36}}};
                        int i, j, k;
                        (*p_60) = ((safe_sub_func_uint8_t_u_u(((void*)0 == &p_59), (safe_lshift_func_uint16_t_u_u(p_61, (((void*)0 != &p_59) < (1U & 0x4400)))))) <= p_61);
                        (*p_60) = (((!(((((&g_6 != (void*)0) & ((2 && ((((((safe_lshift_func_uint16_t_u_s((g_192[2].f3 && (((g_35 ^ (safe_mod_func_int16_t_s_s(0xC1BE, ((safe_mod_func_int16_t_s_s((safe_add_func_int8_t_s_s((safe_add_func_uint16_t_u_u(0x0644, 0x4FD7)), g_265.f1)), p_58)) & 1U)))) | 7) <= 0xDB)), l_266)) == g_192[2].f7) | g_192[2].f4) || 0U) >= g_265.f5) & l_282)) == 0x58)) || l_283[5][4][1]) || g_265.f8) >= g_34)) >= l_284) < p_57.f8);
                        (*p_60) = (g_35 || (((safe_add_func_uint8_t_u_u((p_57.f5 >= ((void*)0 != p_60)), 0U)) >= g_265.f6) > (p_60 == p_59)));
                        (*p_60) = (((l_287[0][0][3] && (safe_sub_func_int16_t_s_s((safe_lshift_func_uint8_t_u_u((l_287[0][0][0] >= (p_57.f5 & (safe_lshift_func_uint16_t_u_u(65535U, 3)))), 3)), (g_265.f0 >= ((g_265.f0 | (l_260[g_97][l_266] == l_294[3])) | (safe_mod_func_uint32_t_u_u(0x63D65F5B, g_265.f3))))))) < l_297) != 4294967295U);
                    }
                }
                (*p_60) = (((safe_mod_func_uint32_t_u_u((((safe_sub_func_int16_t_s_s(((void*)0 != l_260[1][0]), g_192[2].f1)) | (l_266 ^ ((&g_192[4] != (void*)0) < ((((safe_lshift_func_uint8_t_u_u((((&g_265 != (void*)0) < (safe_add_func_int32_t_s_s((safe_lshift_func_uint8_t_u_s((p_57.f5 && l_283[3][3][4]), 3)), p_57.f1))) | g_265.f7), g_192[2].f7)) < l_283[5][4][1]) || p_57.f4) & 6)))) != p_61), (*p_60))) ^ 1U) >= p_57.f4);
            }
        }
        if (((&g_34 != &l_266) || (((void*)0 != &g_10[2]) | ((void*)0 != l_262))))
        { /* block id: 156 */
            struct S0 **l_308 = &g_191;
            int32_t l_311 = 4;
            (*l_308) = &p_57;
            /* statement id: 157 */
            assert (g_191 == &p_57);
            for (l_80 = 0; (l_80 <= 4); l_80 = safe_add_func_uint16_t_u_u(l_80, 1))
            { /* block id: 160 */
                if ((*p_59))
                    break;
                l_311 = (-5);
            }
            if ((*p_59))
                break;
        }
        else
        { /* block id: 165 */
            int32_t ****l_315 = &g_312;
            (*l_315) = g_312;
            (**g_312) = &l_266;
            /* statement id: 167 */
            assert (g_314 == &l_266);
            for (p_58 = (-25); (p_58 != 60); ++p_58)
            { /* block id: 170 */
                (***l_315) = (***l_315);
                for (g_241 = 0; (g_241 <= 5); g_241 += 1)
                { /* block id: 174 */
                    int i, j, k;
                    (*p_60) = (safe_rshift_func_int16_t_s_s((l_283[(g_241 + 1)][g_241][g_241] & (4294967295U != g_241)), ((safe_rshift_func_uint16_t_u_u(l_283[5][4][1], ((&p_60 != (*g_312)) & (((l_322 == (void*)0) > ((safe_rshift_func_int16_t_s_u((p_57.f3 != l_283[6][3][3]), 7)) < p_57.f7)) >= l_283[3][4][0])))) ^ g_34)));
                    for (l_266 = 3; (l_266 >= 0); l_266 -= 1)
                    { /* block id: 178 */
                        return p_60;
                        /* statement id: 179 */
                        //assert ((g_191 >= &g_192[0] && g_191 <= &g_192[8]) || g_191 == dangling);
                        //assert (g_314 == dangling);
                        //assert (func_56_rv == &g_6 || func_56_rv == &l_55);
                    }
                    if ((*p_59))
                    { /* block id: 181 */
                        (*l_315) = (*l_315);
                        (*p_60) = (*p_60);
                    }
                    else
                    { /* block id: 184 */
                        (**g_313) = (safe_lshift_func_uint8_t_u_s(p_57.f4, 0));
                    }
                }
            }
        }
        /* facts after branching */
        //assert (g_314 == &l_266 || g_314 == dangling || g_314 == &g_6 || g_314 == &l_55 || (g_314 >= &l_619[0][0] && g_314 <= &l_619[0][7]) || g_314 == &g_34);
    }
    /* facts after for loop */
    //assert ((g_191 >= &g_192[0] && g_191 <= &g_192[8]) || g_191 == &p_57 || g_191 == dangling);
    if ((safe_mod_func_uint8_t_u_u((((safe_lshift_func_uint8_t_u_s(((p_60 == (void*)0) | (((g_192[2].f3 ^ (((0x371D >= (safe_add_func_int32_t_s_s((((safe_add_func_uint32_t_u_u(((g_265.f3 > (*l_81)) == (((safe_lshift_func_uint8_t_u_u(1U, 6)) != ((safe_mod_func_uint16_t_u_u((p_57.f2 != (g_265.f7 > g_192[2].f3)), 0x9FC1)) != 0U)) == 0x0C)), (*p_60))) & (*l_81)) && p_57.f2), g_241))) && 3U) & 0x90)) ^ p_57.f2) ^ p_57.f2)), 6)) | g_192[2].f1) && 6U), 0xE4)))
    { /* block id: 191 */
        return p_60;
        /* statement id: 192 */
        //assert ((g_191 >= &g_192[0] && g_191 <= &g_192[8]) || g_191 == dangling);
        //assert (func_56_rv == &g_6 || func_56_rv == &l_55);
    }
    else
    { /* block id: 193 */
        int32_t *l_339 = &g_34;
        return l_339;
        /* statement id: 194 */
        //assert ((g_191 >= &g_192[0] && g_191 <= &g_192[8]) || g_191 == dangling);
        //assert (func_56_rv == &g_34);
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_35
 * writes: g_35
 */
static struct S0  func_62(int8_t  p_63, const int32_t * p_64)
{ /* block id: 20 */
    struct S0 l_68 = {1713,294,7,261,5828,-0,1248,1886,-0};
    for (g_35 = 28; (g_35 <= 24); --g_35)
    { /* block id: 23 */
        struct S0 l_67 = {1835,400,18,125,13782,0,1414,676,-0};
        return l_67;
    }
    return l_68;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_34 g_97 l_55
 * writes: g_6 g_10 g_34 l_55
 */
static int32_t * func_70(int32_t * p_71, uint32_t  p_72, int8_t  p_73, uint8_t  p_74)
{ /* block id: 29 */
    uint32_t l_95 = 0x32418DFC;
    uint8_t l_96 = 0x9A;
    int32_t *l_102[7] = {&g_34,&g_34,&g_34,&g_34,&g_34,&g_34,&g_34};
    int32_t **l_101[9] = {&l_102[6],&l_102[6],&l_102[6],&l_102[6],&l_102[6],&l_102[6],&l_102[6],&l_102[6],&l_102[6]};
    int i;
    (*p_71) = (((1 <= (+(0x310918DD >= (safe_sub_func_int32_t_s_s(((p_73 > (0x02B52C7F && (safe_rshift_func_uint8_t_u_s(((((safe_mod_func_uint16_t_u_u((+p_74), ((safe_unary_minus_func_int16_t_s(((void*)0 != &g_34))) || p_73))) > (((safe_mod_func_int32_t_s_s((safe_lshift_func_int8_t_s_u(0xC7, 0)), (*p_71))) > g_34) | 9)) > l_95) ^ p_73), l_95)))) || l_95), l_96))))) ^ g_97) ^ g_34);
    if (p_73)
        goto lbl_100;
lbl_100:
    (*p_71) = (!(l_96 >= (~((void*)0 != &g_6))));
    (*p_71) = l_96;
    g_10[3] = p_71;
    return p_71;
    /* statement id: 35 */
    //assert (func_70_rv == &g_6 || func_70_rv == &g_34 || func_70_rv == &l_55 || (func_70_rv >= &l_32[0][0][0] && func_70_rv <= &l_32[8][5][1]));
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_34, "g_34", print_hash_value);
    transparent_crc(g_35, "g_35", print_hash_value);
    transparent_crc(g_97, "g_97", print_hash_value);
    for (i = 0; i < 9; i = i + 1)
    {
        transparent_crc(g_192[i].f0, "g_192[i].f0", print_hash_value);
        transparent_crc(g_192[i].f1, "g_192[i].f1", print_hash_value);
        transparent_crc(g_192[i].f2, "g_192[i].f2", print_hash_value);
        transparent_crc(g_192[i].f3, "g_192[i].f3", print_hash_value);
        transparent_crc(g_192[i].f4, "g_192[i].f4", print_hash_value);
        transparent_crc(g_192[i].f5, "g_192[i].f5", print_hash_value);
        transparent_crc(g_192[i].f6, "g_192[i].f6", print_hash_value);
        transparent_crc(g_192[i].f7, "g_192[i].f7", print_hash_value);
        transparent_crc(g_192[i].f8, "g_192[i].f8", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_241, "g_241", print_hash_value);
    transparent_crc(g_265.f0, "g_265.f0", print_hash_value);
    transparent_crc(g_265.f1, "g_265.f1", print_hash_value);
    transparent_crc(g_265.f2, "g_265.f2", print_hash_value);
    transparent_crc(g_265.f3, "g_265.f3", print_hash_value);
    transparent_crc(g_265.f4, "g_265.f4", print_hash_value);
    transparent_crc(g_265.f5, "g_265.f5", print_hash_value);
    transparent_crc(g_265.f6, "g_265.f6", print_hash_value);
    transparent_crc(g_265.f7, "g_265.f7", print_hash_value);
    transparent_crc(g_265.f8, "g_265.f8", print_hash_value);
    transparent_crc(g_622, "g_622", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 162
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 30
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 10
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 5
XXX full-bitfields structs in the program: 4
breakdown:
   indirect level: 0, occurrence: 4
XXX times a bitfields struct's address is taken: 23
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 172

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 252
   depth: 2, occurrence: 44
   depth: 3, occurrence: 5
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 4
   depth: 19, occurrence: 4
   depth: 20, occurrence: 5
   depth: 21, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 130

XXX times a variable address is taken: 336
XXX times a pointer is dereferenced on RHS: 196
breakdown:
   depth: 1, occurrence: 144
   depth: 2, occurrence: 14
   depth: 3, occurrence: 23
   depth: 4, occurrence: 14
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 124
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 16
   depth: 3, occurrence: 13
   depth: 4, occurrence: 11
   depth: 5, occurrence: 7
XXX times a pointer is compared with null: 57
XXX times a pointer is compared with address of another variable: 21
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 771

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1227
   level: 2, occurrence: 99
   level: 3, occurrence: 114
   level: 4, occurrence: 51
   level: 5, occurrence: 20
XXX number of pointers point to pointers: 79
XXX number of pointers point to scalars: 40
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 31.5
XXX average alias set size: 1.51

XXX times a non-volatile is read: 1119
XXX times a non-volatile is write: 418
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 4
XXX backward jumps: 8

XXX stmts: 227
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 25
   depth: 2, occurrence: 27
   depth: 3, occurrence: 36
   depth: 4, occurrence: 36
   depth: 5, occurrence: 68

XXX percentage a fresh-made variable is used: 15.9
XXX percentage an existing variable is used: 84.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

