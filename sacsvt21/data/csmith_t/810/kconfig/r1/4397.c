/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      2374939448
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 10;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_6 = 1L;
static volatile struct S0 g_31 = {27};/* VOLATILE GLOBAL g_31 */
static int32_t g_41[2][4] = {{0x66AC3A60L,0x66AC3A60L,0x66AC3A60L,0x66AC3A60L},{0x66AC3A60L,0x66AC3A60L,0x66AC3A60L,0x66AC3A60L}};
static int32_t *g_98 = &g_41[1][1];
static volatile int32_t g_107 = 1L;/* VOLATILE GLOBAL g_107 */
static int32_t g_108 = (-4L);
static volatile struct S0 * volatile g_117[7] = {&g_31,&g_31,&g_31,&g_31,&g_31,&g_31,&g_31};
static float g_120[7] = {0x1.Bp+1,0x1.Bp+1,0x1.Bp+1,0x1.Bp+1,0x1.Bp+1,0x1.Bp+1,0x1.Bp+1};
static float * volatile g_119 = &g_120[3];/* VOLATILE GLOBAL g_119 */
static volatile int32_t *g_127 = (void*)0;
static struct S0 g_148 = {30};
static struct S0 ** const  volatile g_149 = (void*)0;/* VOLATILE GLOBAL g_149 */
static float * const  volatile g_155 = &g_120[3];/* VOLATILE GLOBAL g_155 */
static float * volatile g_192 = &g_120[5];/* VOLATILE GLOBAL g_192 */
static volatile int32_t * volatile *g_270 = &g_127;
static volatile int32_t * volatile **g_269 = &g_270;
static float * volatile g_275 = &g_120[6];/* VOLATILE GLOBAL g_275 */
static const uint32_t g_314 = 18446744073709551607UL;
static struct S0 ** const  volatile *g_324[1][4][4] = {{{&g_149,&g_149,&g_149,&g_149},{&g_149,&g_149,&g_149,&g_149},{&g_149,&g_149,&g_149,&g_149},{&g_149,&g_149,&g_149,&g_149}}};
static struct S0 ** const  volatile ** volatile g_323 = &g_324[0][0][3];/* VOLATILE GLOBAL g_323 */
static const int32_t **g_338 = (void*)0;
static const int32_t *** volatile g_340 = &g_338;/* VOLATILE GLOBAL g_340 */
static uint8_t g_379 = 4UL;
static float g_431[5][6] = {{0xD.B7DE32p-23,(-0x6.1p+1),(-0x6.1p+1),0xD.B7DE32p-23,(-0x6.1p+1),(-0x6.1p+1)},{0xD.B7DE32p-23,(-0x6.1p+1),0xE.A58404p+92,(-0x6.1p+1),0xE.A58404p+92,0xE.A58404p+92},{(-0x6.1p+1),0xE.A58404p+92,0xE.A58404p+92,(-0x6.1p+1),0xE.A58404p+92,0xE.A58404p+92},{(-0x6.1p+1),0xE.A58404p+92,0xE.A58404p+92,(-0x6.1p+1),0xE.A58404p+92,0xE.A58404p+92},{(-0x6.1p+1),0xE.A58404p+92,0xE.A58404p+92,(-0x6.1p+1),0xE.A58404p+92,0xE.A58404p+92}};
static uint32_t g_433[5][6][8] = {{{1UL,18446744073709551607UL,0UL,0UL,0x9F4B684BL,0xF345487BL,18446744073709551615UL,0x10FAFC31L},{0x8959AB81L,0x79582722L,0x47B51DFCL,1UL,0x9F4B684BL,0x343486B5L,0x343486B5L,0x9F4B684BL},{1UL,0x9237EF3FL,0x9237EF3FL,1UL,0xAB7D97D9L,0x9D22A20EL,0x5FABA868L,0x10FAFC31L},{0x4DAA3092L,1UL,0x9237EF3FL,0UL,0x302B2448L,18446744073709551615UL,0x343486B5L,18446744073709551615UL},{18446744073709551615UL,1UL,0x47B51DFCL,0x8959AB81L,0x25B9E783L,0x9D22A20EL,18446744073709551615UL,0xAB7D97D9L},{18446744073709551615UL,0x9237EF3FL,0UL,0x2B89AA06L,0x302B2448L,0x343486B5L,0xD5479BA9L,0xAB7D97D9L}},{{0x4DAA3092L,0x79582722L,1UL,0x8959AB81L,0xAB7D97D9L,0xF345487BL,0xD5479BA9L,18446744073709551615UL},{1UL,18446744073709551607UL,0UL,0UL,0x9F4B684BL,0xF345487BL,18446744073709551615UL,0x10FAFC31L},{0x8959AB81L,0x79582722L,0x47B51DFCL,1UL,0x9F4B684BL,0x343486B5L,0x343486B5L,0x9F4B684BL},{1UL,0x9237EF3FL,0x9237EF3FL,1UL,0xAB7D97D9L,0x9D22A20EL,0x5FABA868L,0x10FAFC31L},{0x4DAA3092L,1UL,0x9237EF3FL,0UL,0x302B2448L,18446744073709551615UL,0x343486B5L,18446744073709551615UL},{18446744073709551615UL,1UL,0x47B51DFCL,0x8959AB81L,0x25B9E783L,0x9D22A20EL,18446744073709551615UL,0xAB7D97D9L}},{{18446744073709551615UL,0x9237EF3FL,0UL,0x2B89AA06L,0x302B2448L,0x343486B5L,0xD5479BA9L,0xAB7D97D9L},{0x4DAA3092L,0x79582722L,1UL,0x8959AB81L,0xAB7D97D9L,0xF345487BL,0xD5479BA9L,18446744073709551615UL},{1UL,18446744073709551607UL,0UL,0UL,0x9F4B684BL,0xF345487BL,18446744073709551615UL,0x10FAFC31L},{0x8959AB81L,0x79582722L,0x47B51DFCL,1UL,0x9F4B684BL,0x343486B5L,0x343486B5L,0x9F4B684BL},{1UL,0x9237EF3FL,0x9237EF3FL,1UL,0xAB7D97D9L,0x9D22A20EL,0x5FABA868L,0x10FAFC31L},{0x4DAA3092L,1UL,0x9237EF3FL,0UL,0x302B2448L,18446744073709551615UL,0x343486B5L,18446744073709551615UL}},{{18446744073709551615UL,1UL,0x47B51DFCL,0x8959AB81L,0x25B9E783L,0x9D22A20EL,18446744073709551615UL,0xAB7D97D9L},{18446744073709551615UL,0x9237EF3FL,0UL,0x2B89AA06L,0x302B2448L,0x343486B5L,0xD5479BA9L,0xAB7D97D9L},{0x4DAA3092L,0x79582722L,1UL,0x8959AB81L,0xAB7D97D9L,0xF345487BL,0xD5479BA9L,18446744073709551615UL},{1UL,0UL,0x47B51DFCL,0x2B89AA06L,0xD2563290L,0xD5479BA9L,0x5FABA868L,18446744073709551615UL},{0UL,0x9237EF3FL,1UL,0x4DAA3092L,0xD2563290L,18446744073709551615UL,18446744073709551615UL,0xD2563290L},{0x4DAA3092L,18446744073709551607UL,18446744073709551607UL,0x4DAA3092L,0x25B9E783L,0x343486B5L,18446744073709551615UL,18446744073709551615UL}},{{0x8959AB81L,1UL,18446744073709551607UL,0x2B89AA06L,0xAB7D97D9L,0x5FABA868L,18446744073709551615UL,0x9F4B684BL},{7UL,1UL,1UL,0UL,0x10FAFC31L,0x343486B5L,0x5FABA868L,0x25B9E783L},{7UL,18446744073709551607UL,0x47B51DFCL,18446744073709551615UL,0xAB7D97D9L,18446744073709551615UL,0x9D22A20EL,0x25B9E783L},{0x8959AB81L,0x9237EF3FL,1UL,0UL,0x25B9E783L,0xD5479BA9L,0x9D22A20EL,0x9F4B684BL},{0x4DAA3092L,0UL,0x47B51DFCL,0x2B89AA06L,0xD2563290L,0xD5479BA9L,0x5FABA868L,18446744073709551615UL},{0UL,0x9237EF3FL,1UL,0x4DAA3092L,0xD2563290L,18446744073709551615UL,18446744073709551615UL,0xD2563290L}}};
static float ** volatile * volatile *g_480[7] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static const float *g_568[10][3] = {{&g_431[4][2],&g_120[3],&g_120[3]},{&g_120[4],&g_120[3],&g_431[0][0]},{&g_120[2],&g_431[4][2],&g_431[0][0]},{&g_120[4],&g_120[4],&g_431[0][0]},{&g_431[4][2],&g_120[2],&g_431[0][0]},{&g_120[3],&g_120[4],&g_120[3]},{&g_120[3],&g_431[4][2],&g_120[4]},{&g_431[4][2],&g_120[3],&g_120[3]},{&g_120[4],&g_120[3],&g_431[0][0]},{&g_120[2],&g_431[4][2],&g_431[0][0]}};
static const float **g_567 = &g_568[6][0];
static const float ** const *g_566[8] = {&g_567,&g_567,&g_567,&g_567,&g_567,&g_567,&g_567,&g_567};
static const float ** const ** volatile g_565 = &g_566[6];/* VOLATILE GLOBAL g_565 */
static int32_t * volatile g_712 = &g_41[0][3];/* VOLATILE GLOBAL g_712 */
static int32_t ** volatile g_714 = &g_98;/* VOLATILE GLOBAL g_714 */
static struct S0 * volatile g_731 = &g_148;/* VOLATILE GLOBAL g_731 */
static int32_t ** volatile g_770 = (void*)0;/* VOLATILE GLOBAL g_770 */
static float * volatile g_771 = &g_431[3][2];/* VOLATILE GLOBAL g_771 */
static volatile int8_t g_865 = (-1L);/* VOLATILE GLOBAL g_865 */
static struct S0 *g_881 = (void*)0;
static struct S0 ** volatile g_880 = &g_881;/* VOLATILE GLOBAL g_880 */
static int32_t * volatile g_882[2] = {&g_41[1][1],&g_41[1][1]};
static int32_t * volatile g_883[9] = {&g_41[0][3],&g_41[0][3],&g_41[0][3],&g_41[0][3],&g_41[0][3],&g_41[0][3],&g_41[0][3],&g_41[0][3],&g_41[0][3]};
static int32_t g_884 = 9L;
static const int32_t *g_886 = &g_41[0][3];
static const int32_t ** volatile g_885 = &g_886;/* VOLATILE GLOBAL g_885 */
static int32_t ** volatile g_910[6] = {&g_98,&g_98,&g_98,&g_98,&g_98,&g_98};
static volatile int32_t * volatile g_928 = &g_107;/* VOLATILE GLOBAL g_928 */
static int32_t ** volatile g_949 = &g_98;/* VOLATILE GLOBAL g_949 */
static float **g_963 = (void*)0;
static float *** volatile g_962 = &g_963;/* VOLATILE GLOBAL g_962 */
static int32_t ** volatile *g_1085 = &g_949;
static int32_t ** volatile ** volatile g_1084 = &g_1085;/* VOLATILE GLOBAL g_1084 */
static const struct S0 **g_1090 = (void*)0;
static const struct S0 *** volatile g_1089 = &g_1090;/* VOLATILE GLOBAL g_1089 */
static float * volatile g_1095 = &g_120[6];/* VOLATILE GLOBAL g_1095 */
static const struct S0 g_1120 = {30};
static volatile struct S0 g_1134 = {30};/* VOLATILE GLOBAL g_1134 */
static int32_t * volatile g_1176[2] = {&g_41[1][0],&g_41[1][0]};
static int32_t * volatile g_1184[1][4] = {{&g_884,&g_884,&g_884,&g_884}};
static int32_t ** volatile g_1216 = &g_98;/* VOLATILE GLOBAL g_1216 */
static int32_t ** volatile g_1220[4] = {(void*)0,(void*)0,(void*)0,(void*)0};


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_30(void);
inline static uint32_t  func_32(int32_t  p_33, float  p_34, int16_t  p_35);
static float  func_37(uint32_t  p_38);
static float  func_42(int8_t  p_43, int16_t  p_44);
inline static int16_t  func_47(int32_t ** p_48, int32_t ** p_49, uint32_t  p_50, const int32_t * p_51);
static int32_t ** func_52(int16_t  p_53, int64_t  p_54);
inline static int64_t  func_60(uint8_t  p_61, int32_t ** p_62);
static int16_t  func_68(int32_t  p_69);
static const int32_t ** func_76(float  p_77);
inline static float  func_78(float  p_79);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_148
 * writes:
 */
inline static struct S0  func_30(void)
{ /* block id: 36 */
    uint32_t l_36 = 0x96A53086L;
    const struct S0 *l_1088[6] = {&g_148,&g_148,&g_148,&g_148,&g_148,&g_148};
    const struct S0 **l_1087 = &l_1088[5];
    struct S0 l_1093 = {22};
    float *l_1102 = &g_431[0][0];
    uint64_t l_1157 = 0x3537A9ED0813DA9DLL;
    float ***l_1218 = (void*)0;
    float ****l_1217[4][10] = {{&l_1218,(void*)0,(void*)0,&l_1218,(void*)0,(void*)0,&l_1218,(void*)0,(void*)0,&l_1218},{(void*)0,&l_1218,(void*)0,(void*)0,&l_1218,(void*)0,(void*)0,&l_1218,(void*)0,(void*)0},{&l_1218,&l_1218,(void*)0,&l_1218,&l_1218,(void*)0,&l_1218,&l_1218,(void*)0,&l_1218},{&l_1218,(void*)0,(void*)0,&l_1218,(void*)0,(void*)0,&l_1218,(void*)0,(void*)0,&l_1218}};
    int i, j;
    return (**l_1087);
}


/* ------------------------------------------ */
/* 
 * reads : g_314 g_148.f0 g_31.f0 g_41 g_323 g_324 g_771 g_714 g_712 g_379
 * writes: g_108 g_431 g_98 g_41
 */
inline static uint32_t  func_32(int32_t  p_33, float  p_34, int16_t  p_35)
{ /* block id: 672 */
    uint8_t l_820[4] = {1UL,1UL,1UL,1UL};
    struct S0 l_854[5] = {{10},{10},{10},{10},{10}};
    struct S0 *l_869 = &l_854[1];
    struct S0 **l_868 = &l_869;
    struct S0 ***l_867 = &l_868;
    struct S0 ****l_866[7][1] = {{&l_867},{(void*)0},{&l_867},{(void*)0},{&l_867},{(void*)0},{&l_867}};
    float *l_875 = &g_431[2][4];
    float **l_874 = &l_875;
    int32_t l_907 = 0xD938C0D3L;
    float l_951 = (-0x3.4p+1);
    int32_t *l_954 = &g_41[0][3];
    float ****l_972 = (void*)0;
    float *****l_971 = &l_972;
    uint32_t l_982 = 0x77158734L;
    uint8_t l_1021 = 255UL;
    float ***l_1053 = &l_874;
    uint64_t l_1066 = 0UL;
    int i, j;
    for (g_108 = 0; (g_108 <= 7); g_108 += 1)
    { /* block id: 675 */
        uint32_t l_852 = 5UL;
        int32_t l_861 = 0x64C60B88L;
        struct S0 l_871 = {15};
        int32_t *l_927 = &g_884;
        volatile int32_t * volatile l_959 = &g_107;/* VOLATILE GLOBAL l_959 */
        int32_t *l_979[2][7][7] = {{{&l_907,(void*)0,&l_861,(void*)0,(void*)0,(void*)0,&l_861},{&g_108,(void*)0,(void*)0,&g_884,&l_861,&g_884,&l_861},{(void*)0,(void*)0,&g_41[1][3],&g_41[0][3],(void*)0,(void*)0,&g_41[0][3]},{(void*)0,&g_41[0][3],(void*)0,&g_41[0][3],&l_861,&l_861,&g_41[0][3]},{&g_41[0][3],(void*)0,&g_41[0][3],&g_884,&g_108,&g_41[0][3],&g_884},{&g_884,&l_861,&l_861,(void*)0,&g_884,&l_861,(void*)0},{&l_861,(void*)0,(void*)0,&l_907,(void*)0,(void*)0,&l_861}},{{&l_861,&l_861,&g_41[0][3],&l_861,(void*)0,&g_884,(void*)0},{&g_884,&g_108,(void*)0,(void*)0,&g_41[0][3],(void*)0,&g_108},{&g_41[0][3],&g_884,&g_41[0][3],&g_41[1][3],(void*)0,&g_41[0][3],(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,&l_907,&l_861},{(void*)0,(void*)0,&l_861,&g_41[0][3],&g_41[0][3],&g_108,&l_861},{&g_108,&g_41[0][3],&g_41[0][3],&l_861,(void*)0,(void*)0,&l_861},{&l_907,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}}};
        int i, j, k;
        if ((safe_lshift_func_uint16_t_u_u((0UL <= 0xD2AAL), ((__builtin_ctzll((safe_sub_func_uint8_t_u_u(((g_314 , p_35) | p_33), p_33))) >= (safe_add_func_int16_t_s_s(g_148.f0, l_820[0]))) ^ 0x6BFF4D91L))))
        { /* block id: 676 */
            struct S0 *l_830[7][10] = {{(void*)0,&g_148,&g_148,&g_148,(void*)0,&g_148,&g_148,&g_148,&g_148,&g_148},{(void*)0,&g_148,&g_148,(void*)0,&g_148,&g_148,&g_148,&g_148,&g_148,&g_148},{&g_148,&g_148,&g_148,&g_148,&g_148,&g_148,&g_148,&g_148,&g_148,&g_148},{&g_148,&g_148,&g_148,(void*)0,(void*)0,(void*)0,&g_148,&g_148,&g_148,&g_148},{&g_148,&g_148,(void*)0,&g_148,&g_148,(void*)0,&g_148,(void*)0,&g_148,(void*)0},{&g_148,&g_148,(void*)0,(void*)0,&g_148,&g_148,(void*)0,&g_148,&g_148,(void*)0},{&g_148,&g_148,&g_148,&g_148,&g_148,&g_148,(void*)0,&g_148,(void*)0,&g_148}};
            struct S0 **l_829 = &l_830[2][3];
            struct S0 ***l_828 = &l_829;
            struct S0 *** const * const l_827 = &l_828;
            struct S0 *** const * const * const l_826 = &l_827;
            const int32_t l_833[5] = {2L,2L,2L,2L,2L};
            float **l_839 = (void*)0;
            float ***l_838 = &l_839;
            float ****l_837 = &l_838;
            float *****l_836 = &l_837;
            int32_t **l_850 = (void*)0;
            int32_t *** const l_849[3][6] = {{&l_850,(void*)0,(void*)0,(void*)0,(void*)0,&l_850},{&l_850,&l_850,(void*)0,&l_850,&l_850,&l_850},{(void*)0,&l_850,&l_850,(void*)0,(void*)0,(void*)0}};
            int32_t *l_856[1];
            uint32_t l_858 = 1UL;
            int i, j;
            for (i = 0; i < 1; i++)
                l_856[i] = &g_108;
            for (p_33 = 1; (p_33 <= 7); p_33 += 1)
            { /* block id: 679 */
                uint64_t l_840 = 0x748979BF36417F50LL;
                struct S0 l_855 = {18};
                int32_t l_857 = 1L;
                if (((~func_68(((safe_mul_func_int16_t_s_s((((void*)0 != &g_340) >= g_31.f0), ((__builtin_bswap64((((safe_div_func_uint32_t_u_u(((void*)0 != l_826), (safe_mul_func_uint16_t_u_u(g_41[0][2], l_833[0])))) == (-1L)) == __builtin_clzll((safe_sub_func_int32_t_s_s((l_836 != &g_480[5]), 0xE338C87EL))))) && l_833[1]) > 65528UL))) , p_35))) >= l_840))
                { /* block id: 680 */
                    int32_t l_843[8][5] = {{1L,(-2L),0x2CBAEEDBL,0x6AE9E3DEL,(-2L)},{0x3D4E6823L,0xBF51782FL,0xBF51782FL,0x3D4E6823L,1L},{(-7L),6L,0x19CB3A10L,(-2L),(-2L)},{0L,0x3D4E6823L,0L,1L,0x3D4E6823L},{(-2L),0x2CBAEEDBL,0x6AE9E3DEL,(-2L),0x6AE9E3DEL},{0x33D6B8D8L,0x33D6B8D8L,(-4L),0x3D4E6823L,0xB0C46922L},{1L,(-7L),0x6AE9E3DEL,0x6AE9E3DEL,(-7L)},{0xB0C46922L,0xBF51782FL,0L,0xB0C46922L,1L}};
                    int32_t *** const l_851 = &l_850;
                    int32_t l_853 = 0xF8E5A8FDL;
                    int i, j;
                    (*g_771) = (safe_add_func_float_f_f(l_843[4][3], (+(((((safe_sub_func_float_f_f(((safe_mul_func_float_f_f(l_833[0], ((l_849[0][1] == l_851) , ((void*)0 != (**l_826))))) < (((p_35 != ((void*)0 == (*g_323))) != 0L) , l_852)), 0x4.F01C8Dp-2)) == 0x6.4p+1) <= p_33) <= l_820[0]) <= l_853))));
                    l_855 = l_854[1];
                }
                else
                { /* block id: 683 */
                    (*g_714) = l_856[0];
                    /* statement id: 684 */
                    assert (g_98 == &g_108);
                    if (l_840)
                        continue;
                    l_857 = 0x01F6A1F2L;
                }
                return l_858;
            }
            if ((*g_712))
                break;
        }
        else
        { /* block id: 691 */
            if (p_35)
                break;
            if (__builtin_ffsl(g_379))
            { /* block id: 693 */
                int32_t *l_859 = (void*)0;
                l_859 = &p_33;
                /* statement id: 694 */
                assert (l_859 == &p_33);
            }
            else
            { /* block id: 695 */
                int32_t *l_860 = &g_41[1][3];
                (*l_860) = l_820[1];
                if (p_35)
                    continue;
                if (p_35)
                    break;
                l_861 = l_820[2];
            }
        }
    }
    /* facts after for loop */
    //assert (g_98 == &g_108 || g_98 == dangling || (g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_41 g_31 g_148 g_108 g_98 g_269 g_275 g_270 g_155 g_107 g_314 g_192 g_120 g_127 g_323 g_338 g_340 g_379 g_433 g_480 g_119 g_712 g_771
 * writes: g_6 g_98 g_148 g_108 g_41 g_120 g_127 g_270 g_324 g_338 g_379 g_107 g_566 g_431
 */
static float  func_37(uint32_t  p_38)
{ /* block id: 37 */
    int32_t *l_40 = &g_41[0][3];
    int32_t **l_39 = &l_40;
    int32_t l_55 = 0x6BB64548L;
    int64_t l_65 = 0L;
    struct S0 l_775[9][2] = {{{24},{24}},{{19},{24}},{{24},{19}},{{24},{24}},{{19},{24}},{{24},{19}},{{24},{24}},{{19},{24}},{{24},{19}}};
    int i, j;
    (*l_39) = (void*)0;
    /* statement id: 38 */
    assert (l_40 == 0);
    (*g_771) = func_42((safe_mod_func_uint8_t_u_u(__builtin_clz((p_38 & 0L)), 0x7BL)), func_47(func_52(((l_55 & (((((p_38 , p_38) >= (safe_div_func_int64_t_s_s(2L, ((safe_mod_func_uint32_t_u_u((func_60(((safe_lshift_func_uint16_t_u_s(g_6, g_6)) , l_65), &l_40) & p_38), 0x259CD487L)) ^ g_314)))) == 0L) < g_314) , g_41[0][3])) , g_41[0][3]), p_38), &l_40, p_38, (*l_39)));
    /* statement id: 630 */
    //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]) || l_40 == 0 || l_40 == dangling || l_40 == &g_108);
    //assert (g_98 == dangling || (g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
    if (p_38)
    { /* block id: 631 */
        int32_t *l_772 = &g_41[0][3];
        struct S0 l_804 = {6};
        int32_t l_811 = 0x3859B3E6L;
        (*l_39) = l_772;
        /* statement id: 632 */
        assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
        for (l_65 = (-3); (l_65 >= 1); l_65++)
        { /* block id: 635 */
            struct S0 *l_776 = &l_775[2][0];
            int32_t l_781 = 0L;
            (*l_776) = l_775[2][0];
            if (((((*l_772) == g_41[0][3]) , (safe_add_func_uint16_t_u_u((safe_mul_func_uint8_t_u_u(((p_38 < l_781) || func_68((g_108 , (**l_39)))), p_38)), 65535UL))) | g_108))
            { /* block id: 637 */
                return p_38;
            }
            else
            { /* block id: 639 */
                int32_t *l_792 = &l_781;
                float *l_803[5][1][8] = {{{&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2]}},{{&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2]}},{{&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2]}},{{&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2]}},{{&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2],&g_120[3],&g_431[4][2]}}};
                float * const *l_802 = &l_803[3][0][7];
                float * const **l_801 = &l_802;
                int16_t l_810 = 0xAEB8L;
                int i, j, k;
                for (p_38 = (-23); (p_38 > 9); p_38 = safe_add_func_int32_t_s_s(p_38, 8))
                { /* block id: 642 */
                    (**l_39) = (safe_sub_func_uint8_t_u_u(0xE2L, p_38));
                    for (g_6 = 0; (g_6 < 25); g_6++)
                    { /* block id: 646 */
                        (*l_39) = l_792;
                        /* statement id: 647 */
                        assert (l_40 == &l_781);
                    }
                }
                /* facts after for loop */
                assert (l_40 == &l_781 || (l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
                for (g_379 = 0; (g_379 > 18); g_379++)
                { /* block id: 652 */
                    int16_t l_812 = 0L;
                    for (p_38 = 0; (p_38 <= 4); p_38 += 1)
                    { /* block id: 655 */
                        l_792 = l_792;
                        (**l_39) = ((**l_39) != 0xD3A7L);
                    }
                    l_812 = (((safe_add_func_uint16_t_u_u(p_38, ((*l_772) < ((safe_lshift_func_uint8_t_u_u((247UL < ((void*)0 != l_801)), (((l_804 , (~(-1L))) == (safe_lshift_func_int8_t_s_s((-6L), (safe_sub_func_uint64_t_u_u(g_433[1][4][4], l_810))))) == (*l_792)))) > 1L)))) , l_811) , (**l_39));
                    (*l_39) = (*l_39);
                }
                (*l_776) = l_804;
                (*l_801) = (void*)0;
                /* statement id: 663 */
                assert (l_802 == 0);
            }
            /* facts after branching */
            assert (l_40 == &l_781 || (l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
            return (*l_772);
        }
        (**g_269) = (void*)0;
    }
    else
    { /* block id: 668 */
        int32_t *l_813 = (void*)0;
        (*l_39) = l_813;
        /* statement id: 669 */
        assert (l_40 == 0);
    }
    /* facts after branching */
    assert (l_40 == 0 || (l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads : g_270 g_127 g_379 g_712 g_192 g_120
 * writes: g_127 g_379 g_41
 */
static float  func_42(int8_t  p_43, int16_t  p_44)
{ /* block id: 588 */
    int32_t *l_713[1];
    struct S0 l_715 = {5};
    float *l_727 = &g_120[3];
    float **l_726 = &l_727;
    int16_t l_751 = 0x44D0L;
    int64_t l_766 = 2L;
    int i;
    for (i = 0; i < 1; i++)
        l_713[i] = &g_41[0][1];
    (*g_270) = (*g_270);
    for (g_379 = 0; (g_379 == 16); g_379 = safe_add_func_int8_t_s_s(g_379, 1))
    { /* block id: 592 */
        struct S0 l_716 = {4};
        int32_t l_717 = 1L;
        struct S0 * const l_761 = (void*)0;
        struct S0 * const *l_760 = &l_761;
        (*g_712) = p_44;
    }
    return (*g_192);
}


/* ------------------------------------------ */
/* 
 * reads : g_379 g_108 g_31.f0 g_6 g_98 g_107 g_41 g_270 g_127 g_269 g_31 g_148 g_275 g_155 g_314 g_192 g_120 g_323 g_338 g_340 g_433 g_480 g_119
 * writes: g_6 g_41 g_379 g_120 g_98 g_127 g_108 g_148 g_270 g_324 g_338 g_107 g_566
 */
inline static int16_t  func_47(int32_t ** p_48, int32_t ** p_49, uint32_t  p_50, const int32_t * p_51)
{ /* block id: 233 */
    const uint8_t l_380 = 1UL;
    float *l_387 = &g_120[3];
    float **l_386 = &l_387;
    int16_t l_420 = 0xA815L;
    int8_t l_432[6][4][6] = {{{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L},{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L}},{{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L},{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L}},{{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L},{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L}},{{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L},{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L}},{{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L},{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L}},{{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L},{0x6FL,0L,0x6FL,0L,0x6FL,0L},{0xBDL,0L,0xBDL,0L,0xBDL,0L}}};
    float *l_458 = &g_431[0][0];
    int32_t l_459 = 0x1F4C52F5L;
    struct S0 *l_504 = (void*)0;
    struct S0 **l_518 = &l_504;
    struct S0 ***l_517 = &l_518;
    struct S0 ****l_516 = &l_517;
    struct S0 *****l_515 = &l_516;
    struct S0 l_585[9] = {{3},{24},{24},{3},{24},{24},{3},{24},{24}};
    int32_t l_648 = 0x9BBF7A33L;
    struct S0 l_662 = {3};
    volatile int32_t * volatile l_697 = &g_107;/* VOLATILE GLOBAL l_697 */
    uint8_t l_709 = 0x8FL;
    int i, j, k;
    if ((!((g_379 > (g_108 , (p_50 | l_380))) , l_380)))
    { /* block id: 234 */
        int8_t l_390 = (-9L);
        struct S0 l_406[4][5][2] = {{{{1},{23}},{{1},{1}},{{0},{23}},{{0},{1}},{{1},{23}}},{{{1},{1}},{{0},{23}},{{0},{1}},{{1},{23}},{{1},{1}}},{{{0},{23}},{{0},{1}},{{1},{23}},{{1},{1}},{{0},{23}}},{{{0},{1}},{{1},{23}},{{1},{1}},{{0},{23}},{{0},{1}}}};
        const float * const l_430 = &g_431[0][0];
        uint32_t l_435 = 0x01C377F9L;
        uint64_t l_438 = 0UL;
        uint16_t l_440 = 0x6A68L;
        struct S0 *l_452 = &l_406[2][0][0];
        struct S0 * const *l_451[5][5][5] = {{{&l_452,(void*)0,&l_452,&l_452,(void*)0},{&l_452,&l_452,&l_452,&l_452,&l_452},{(void*)0,(void*)0,&l_452,(void*)0,(void*)0},{&l_452,&l_452,&l_452,&l_452,&l_452},{(void*)0,&l_452,&l_452,(void*)0,&l_452}},{{&l_452,&l_452,(void*)0,&l_452,&l_452},{&l_452,(void*)0,&l_452,&l_452,(void*)0},{&l_452,&l_452,&l_452,&l_452,&l_452},{(void*)0,(void*)0,&l_452,(void*)0,(void*)0},{&l_452,&l_452,&l_452,&l_452,&l_452}},{{(void*)0,&l_452,&l_452,(void*)0,&l_452},{&l_452,&l_452,(void*)0,&l_452,&l_452},{&l_452,(void*)0,&l_452,&l_452,(void*)0},{&l_452,&l_452,&l_452,&l_452,&l_452},{(void*)0,(void*)0,&l_452,(void*)0,(void*)0}},{{&l_452,&l_452,(void*)0,(void*)0,&l_452},{&l_452,&l_452,&l_452,&l_452,&l_452},{&l_452,&l_452,&l_452,&l_452,&l_452},{&l_452,&l_452,&l_452,&l_452,&l_452},{&l_452,(void*)0,(void*)0,&l_452,(void*)0}},{{&l_452,&l_452,(void*)0,&l_452,&l_452},{(void*)0,&l_452,(void*)0,(void*)0,&l_452},{&l_452,&l_452,&l_452,&l_452,&l_452},{&l_452,&l_452,&l_452,&l_452,&l_452},{&l_452,&l_452,&l_452,&l_452,&l_452}}};
        struct S0 * const **l_450 = &l_451[3][4][4];
        struct S0 * const ***l_449 = &l_450;
        uint32_t l_456 = 1UL;
        int32_t l_457 = (-7L);
        int32_t **l_479 = (void*)0;
        int32_t ***l_478 = &l_479;
        float ** volatile * volatile *l_481 = (void*)0;
        int i, j, k;
lbl_439:
        for (g_6 = 0; (g_6 <= (-22)); g_6 = safe_sub_func_int16_t_s_s(g_6, 7))
        { /* block id: 237 */
            uint16_t l_393 = 0xBA04L;
            (**p_48) = (~(safe_mul_func_int16_t_s_s(((0xA6L < ((1L <= (func_68(((void*)0 != l_386)) < (safe_lshift_func_uint16_t_u_s(l_390, g_31.f0)))) ^ (l_390 , ((safe_mod_func_int64_t_s_s(0x75B379C0B1A54CAFLL, l_393)) && g_6)))) , g_6), (-8L))));
            for (l_390 = 6; (l_390 >= 0); l_390 -= 1)
            { /* block id: 241 */
                int32_t *l_396 = (void*)0;
                if ((g_107 , 0x9D009C60L))
                { /* block id: 242 */
                    uint8_t l_394[6];
                    int i;
                    for (i = 0; i < 6; i++)
                        l_394[i] = 255UL;
                    for (g_379 = 0; (g_379 <= 6); g_379 += 1)
                    { /* block id: 245 */
                        (**p_48) = l_394[4];
                        (*p_49) = (*p_48);
                        /* statement id: 247 */
                        //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
                        if (l_394[4])
                            continue;
                    }
                    if (p_50)
                        goto lbl_419;
                    return p_50;
                }
                else
                { /* block id: 251 */
                    int32_t *l_395 = &g_108;
                    l_395 = (*p_48);
                    /* statement id: 252 */
                    assert ((l_395 >= &g_41[0][0] && l_395 <= &g_41[1][3]));
                }
                (*p_49) = l_396;
                /* statement id: 254 */
                //assert (l_40 == 0);
                for (l_393 = 0; (l_393 <= 6); l_393 += 1)
                { /* block id: 257 */
                    int i;
                    g_120[l_393] = func_68(__builtin_popcountll(g_108));
                }
                return g_6;
            }
            if ((**p_48))
                continue;
        }
        for (l_390 = 24; (l_390 <= 11); --l_390)
        { /* block id: 266 */
            (*p_48) = (*p_48);
            for (p_50 = 0; (p_50 >= 51); p_50++)
            { /* block id: 270 */
                int32_t *l_401 = &g_41[0][3];
                (**g_269) = (*g_270);
                (*p_49) = l_401;
                /* statement id: 272 */
                //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
            }
            for (p_50 = 0; (p_50 > 3); p_50++)
            { /* block id: 276 */
                int8_t l_408 = 0xA8L;
                for (g_108 = (-22); (g_108 >= (-15)); g_108 = safe_add_func_int16_t_s_s(g_108, 4))
                { /* block id: 279 */
                    struct S0 *l_407 = &l_406[2][2][0];
                    (*l_407) = l_406[2][0][0];
                    (*l_407) = l_406[2][0][0];
                    return l_408;
                }
            }
        }
        if ((safe_mod_func_uint16_t_u_u((safe_unary_minus_func_int32_t_s(((safe_add_func_int16_t_s_s(((l_406[2][0][0] , (safe_sub_func_int16_t_s_s(l_380, ((l_406[2][0][0] , 4294967295UL) && ((((safe_add_func_uint16_t_u_u(((void*)0 == &l_387), (p_50 <= ((~(func_60(g_6, &g_98) , 1L)) <= 0x53F47ECDL)))) | 0xFA34L) , l_406[2][0][0].f0) < p_50))))) , g_148.f0), l_390)) ^ g_314))), g_379)))
        { /* block id: 286 */
            if (__builtin_clz((p_51 != p_51)))
            { /* block id: 287 */
lbl_419:
                (*p_49) = (*p_48);
                /* statement id: 288 */
                //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
                for (g_6 = 0; (g_6 <= 6); g_6 += 1)
                { /* block id: 292 */
                    return l_420;
                }
                for (g_379 = 0; (g_379 <= 39); g_379++)
                { /* block id: 297 */
                    struct S0 **l_455[1];
                    struct S0 ***l_454 = &l_455[0];
                    struct S0 ****l_453 = &l_454;
                    int i;
                    for (i = 0; i < 1; i++)
                        l_455[i] = &l_452;
                    if ((((!func_60(l_380, p_49)) | ((p_50 <= (safe_lshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_u(func_68(g_314), (safe_mul_func_uint16_t_u_u((p_51 == l_430), 1L)))), l_432[0][1][3]))) != g_379)) && g_107))
                    { /* block id: 298 */
                        struct S0 l_434[2] = {{13},{13}};
                        int i;
                        (**p_49) = ((func_60(g_433[0][4][7], (l_434[1] , &g_98)) , (0x627ED3F3E70D1222LL == l_435)) && ((((safe_mul_func_int8_t_s_s(func_68(l_438), 0x82L)) || 5L) , g_41[1][3]) | p_50));
                        if (l_380)
                            goto lbl_439;
                    }
                    else
                    { /* block id: 301 */
                        return l_440;
                    }
                    (**p_48) = 0L;
                    l_457 = (safe_add_func_float_f_f(0x0.AFE82Cp+68, (safe_add_func_float_f_f((safe_div_func_float_f_f(0x8.8p-1, (p_50 , (safe_mul_func_float_f_f((*g_155), (l_449 != l_453)))))), l_456))));
                }
                l_459 = (l_458 != (void*)0);
            }
            else
            { /* block id: 308 */
                int32_t *l_462 = &g_108;
                int32_t ** const l_477[9][4][2] = {{{&g_98,&g_98},{&l_462,&l_462},{&g_98,&g_98},{&g_98,&l_462}},{{(void*)0,&l_462},{&l_462,(void*)0},{&g_98,&l_462},{&g_98,(void*)0}},{{&l_462,&l_462},{(void*)0,&l_462},{&g_98,&g_98},{&g_98,&l_462}},{{&l_462,&g_98},{&g_98,&g_98},{&g_98,&g_98},{&l_462,&g_98}},{{&g_98,&g_98},{&l_462,(void*)0},{&l_462,&l_462},{&g_98,&g_98}},{{&g_98,&g_98},{&l_462,&g_98},{&g_98,&g_98},{&g_98,&l_462}},{{&l_462,(void*)0},{&l_462,&g_98},{&g_98,&g_98},{&l_462,&g_98}},{{&g_98,&g_98},{&g_98,&g_98},{&l_462,&l_462},{&g_98,&g_98}},{{&g_98,&l_462},{(void*)0,&l_462},{&l_462,(void*)0},{&g_98,&l_462}}};
                int32_t ** const *l_476 = &l_477[8][3][0];
                int32_t ** const **l_475 = &l_476;
                int i, j, k;
                for (l_440 = 0; (l_440 <= 30); l_440 = safe_add_func_int64_t_s_s(l_440, 2))
                { /* block id: 311 */
                    (*p_49) = l_462;
                    /* statement id: 312 */
                    //assert (l_40 == &g_108);
                    (*l_387) = (-0x9.Bp-1);
                }
                /* facts after for loop */
                //assert (l_40 == &g_108 || (l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]) || l_40 == 0);
                if (l_390)
                { /* block id: 315 */
                    (**p_48) = (0xDF43732FL >= ((safe_add_func_int32_t_s_s((((((p_50 , (safe_add_func_uint8_t_u_u((safe_rshift_func_int16_t_s_u((p_50 , (safe_div_func_int8_t_s_s(((safe_mul_func_int16_t_s_s((safe_mod_func_int8_t_s_s(g_108, __builtin_popcountl((*l_462)))), (g_41[1][3] > (l_475 != (void*)0)))) != (*g_98)), 1L))), l_420)), p_50))) > g_31.f0) , &g_338) != l_478) != p_50), (**p_48))) > 0x597037C3L));
                    if ((*g_98))
                    { /* block id: 317 */
                        struct S0 l_482 = {21};
                        l_481 = g_480[5];
                        (*l_452) = l_482;
                        return l_482.f0;
                    }
                    else
                    { /* block id: 321 */
                        (*l_462) = (**p_48);
                        (*l_449) = (void*)0;
                        /* statement id: 323 */
                        assert (l_450 == 0);
                    }
                    /* facts after branching */
                    assert (l_450 == 0);
                    (**l_386) = (-0x1.1p+1);
                }
                else
                { /* block id: 326 */
                    (*g_270) = (*g_270);
                }
                /* facts after branching */
                assert ((l_450 >= &l_451[0][0][0] && l_450 <= &l_451[4][4][4]) || l_450 == 0);
            }
            /* facts after branching */
            //assert (l_40 == &g_108 || (l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]) || l_40 == 0);
            assert ((l_450 >= &l_451[0][0][0] && l_450 <= &l_451[4][4][4]) || l_450 == 0);
        }
        else
        { /* block id: 330 */
            struct S0 *l_483[2][3][1];
            int32_t *l_495 = &l_459;
            int i, j, k;
            for (i = 0; i < 2; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    for (k = 0; k < 1; k++)
                        l_483[i][j][k] = (void*)0;
                }
            }
lbl_497:
            l_483[0][0][0] = l_483[0][0][0];
            for (g_108 = 0; (g_108 < 28); g_108 = safe_add_func_int16_t_s_s(g_108, 8))
            { /* block id: 334 */
                struct S0 **l_494 = &l_452;
                int32_t l_496 = 0x0F2815A3L;
                for (l_438 = (-9); (l_438 > 57); l_438 = safe_add_func_int32_t_s_s(l_438, 5))
                { /* block id: 337 */
                    for (l_459 = 0; (l_459 < (-16)); --l_459)
                    { /* block id: 340 */
                        uint32_t l_490 = 0x16B153C2L;
                        return l_490;
                        /* statement id: 341 */
                        //assert (g_98 == dangling || (g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
                        //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]) || l_40 == 0 || l_40 == dangling);
                    }
                }
                for (l_456 = (-4); (l_456 <= 41); l_456 = safe_add_func_int8_t_s_s(l_456, 9))
                { /* block id: 346 */
                    struct S0 **l_493 = (void*)0;
                    if ((l_493 == l_494))
                    { /* block id: 347 */
                        (*p_49) = l_495;
                        /* statement id: 348 */
                        //assert (l_40 == &l_459);
                    }
                    else
                    { /* block id: 349 */
                        l_496 = l_456;
                    }
                    if (g_148.f0)
                        goto lbl_497;
                }
                (*p_49) = &l_496;
                /* statement id: 354 */
                //assert (l_40 == &l_496);
                (*p_48) = l_495;
                /* statement id: 355 */
                assert (g_98 == &l_459);
            }
            (*g_98) = l_432[0][1][3];
        }
        /* facts after branching */
        assert (g_98 == &l_459 || (g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
        //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]) || l_40 == 0 || l_40 == &l_459 || l_40 == dangling || l_40 == &g_108);
        assert ((l_450 >= &l_451[0][0][0] && l_450 <= &l_451[4][4][4]) || l_450 == 0);
        for (l_459 = 0; (l_459 <= 8); l_459++)
        { /* block id: 361 */
            for (l_456 = 0; (l_456 <= 49); l_456 = safe_add_func_uint64_t_u_u(l_456, 4))
            { /* block id: 364 */
                return g_107;
                /* statement id: 365 */
                //assert (g_98 == dangling || (g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
                //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]) || l_40 == 0 || l_40 == dangling || l_40 == &g_108);
            }
        }
    }
    else
    { /* block id: 368 */
        struct S0 *l_502[5][8] = {{&g_148,&g_148,&g_148,(void*)0,&g_148,&g_148,(void*)0,&g_148},{&g_148,(void*)0,&g_148,(void*)0,&g_148,&g_148,&g_148,&g_148},{&g_148,&g_148,&g_148,&g_148,&g_148,&g_148,&g_148,(void*)0},{&g_148,(void*)0,&g_148,&g_148,(void*)0,&g_148,&g_148,(void*)0},{&g_148,&g_148,&g_148,&g_148,(void*)0,(void*)0,(void*)0,&g_148}};
        const int32_t l_529 = 0L;
        struct S0 l_584 = {10};
        uint8_t l_588 = 0UL;
        float ****l_636 = (void*)0;
        int i, j;
lbl_649:
        if ((**p_48))
        { /* block id: 369 */
            struct S0 **l_503[10][9][1] = {{{&l_502[3][3]},{&l_502[3][4]},{&l_502[2][5]},{&l_502[3][4]},{&l_502[3][4]},{&l_502[3][4]},{&l_502[4][2]},{&l_502[2][5]},{&l_502[4][2]}},{{&l_502[3][4]},{&l_502[3][4]},{&l_502[3][4]},{&l_502[2][5]},{&l_502[3][4]},{&l_502[3][3]},{&l_502[3][4]},{&l_502[3][4]},{&l_502[4][3]}},{{&l_502[4][2]},{(void*)0},{&l_502[3][3]},{&l_502[3][4]},{&l_502[3][4]},{&l_502[3][4]},{&l_502[3][3]},{(void*)0},{&l_502[4][2]}},{{(void*)0},{(void*)0},{&l_502[0][6]},{&l_502[0][1]},{&l_502[3][4]},{&l_502[3][4]},{&l_502[2][5]},{&l_502[2][1]},{&l_502[0][6]}},{{&l_502[3][4]},{&l_502[3][0]},{&l_502[3][4]},{&l_502[0][6]},{&l_502[2][1]},{&l_502[2][5]},{&l_502[3][4]},{&l_502[3][4]},{&l_502[0][1]}},{{&l_502[0][6]},{(void*)0},{(void*)0},{&l_502[3][4]},{&l_502[3][4]},{&l_502[0][1]},{&l_502[2][5]},{&l_502[4][1]},{&l_502[2][5]}},{{&l_502[0][1]},{&l_502[3][4]},{&l_502[3][4]},{(void*)0},{(void*)0},{&l_502[0][6]},{&l_502[0][1]},{&l_502[3][4]},{&l_502[3][4]}},{{&l_502[2][5]},{&l_502[2][1]},{&l_502[0][6]},{&l_502[3][4]},{&l_502[3][0]},{&l_502[3][4]},{&l_502[0][6]},{&l_502[2][1]},{&l_502[2][5]}},{{&l_502[3][4]},{&l_502[3][4]},{&l_502[0][1]},{&l_502[0][6]},{(void*)0},{(void*)0},{&l_502[3][4]},{&l_502[3][4]},{&l_502[0][1]}},{{&l_502[2][5]},{&l_502[4][1]},{&l_502[2][5]},{&l_502[0][1]},{&l_502[3][4]},{&l_502[3][4]},{(void*)0},{(void*)0},{&l_502[0][6]}}};
            int i, j, k;
            (*p_48) = (*p_48);
            (**g_269) = (*g_270);
            l_504 = l_502[3][4];
            /* statement id: 372 */
            assert (l_504 == 0 || l_504 == &g_148);
        }
        else
        { /* block id: 373 */
            struct S0 l_525 = {0};
            int32_t *l_544 = &g_41[0][3];
            const float * const *l_596[5][6][8] = {{{&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0},{&g_568[4][0],&g_568[6][0],&g_568[6][0],&g_568[6][0],&g_568[4][0],&g_568[0][1],&g_568[4][0],&g_568[6][0]},{&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0]},{&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0},{&g_568[4][0],&g_568[6][0],&g_568[6][0],&g_568[6][0],&g_568[4][0],&g_568[0][1],&g_568[4][0],&g_568[6][0]},{&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0]}},{{&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0},{&g_568[4][0],&g_568[6][0],&g_568[6][0],&g_568[6][0],&g_568[4][0],&g_568[0][1],&g_568[4][0],&g_568[6][0]},{&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0]},{&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0},{&g_568[4][0],&g_568[6][0],&g_568[6][0],&g_568[6][0],&g_568[4][0],&g_568[0][1],&g_568[4][0],&g_568[6][0]},{&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0]}},{{&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0},{&g_568[4][0],&g_568[6][0],&g_568[6][0],&g_568[6][0],&g_568[4][0],&g_568[0][1],&g_568[4][0],&g_568[6][0]},{&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0]},{&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0,&g_568[4][0],(void*)0},{&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0},{&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0}},{{&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1]},{&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0},{&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0},{&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1]},{&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0},{&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0}},{{&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1]},{&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0},{&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0},{&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1]},{&g_568[6][0],(void*)0,&g_568[4][0],(void*)0,&g_568[6][0],&g_568[6][0],&g_568[6][0],(void*)0},{&g_568[6][0],(void*)0,&g_568[6][0],&g_568[0][1],&g_568[6][0],&g_568[0][1],&g_568[6][0],(void*)0}}};
            const float * const **l_595[5][9] = {{&l_596[2][3][5],(void*)0,&l_596[2][2][0],(void*)0,&l_596[1][3][4],&l_596[2][2][0],&l_596[2][2][0],&l_596[2][2][0],&l_596[1][3][4]},{&l_596[2][3][5],&l_596[1][3][4],&l_596[1][3][4],&l_596[2][3][5],(void*)0,&l_596[2][2][0],(void*)0,&l_596[1][3][4],&l_596[2][2][0]},{&l_596[3][2][1],&l_596[1][3][4],&l_596[2][2][0],(void*)0,&l_596[2][2][0],&l_596[2][2][0],(void*)0,&l_596[2][2][0],&l_596[1][3][4]},{(void*)0,(void*)0,&l_596[2][2][0],&l_596[2][2][0],(void*)0,&l_596[1][3][4],&l_596[2][2][0],&l_596[2][2][0],&l_596[2][2][0]},{&l_596[3][2][1],&l_596[2][2][0],&l_596[1][3][4],&l_596[2][2][0],&l_596[1][3][4],&l_596[2][2][0],&l_596[3][2][1],&l_596[1][3][4],&l_596[2][2][0]}};
            int64_t l_610[1];
            int i, j, k;
            for (i = 0; i < 1; i++)
                l_610[i] = 0x18C88A2468CED126LL;
            (*p_49) = (g_31.f0 , ((safe_mul_func_uint8_t_u_u((safe_mul_func_uint16_t_u_u(g_379, (g_41[1][3] && 0x5EA1L))), 6L)) , (void*)0));
            /* statement id: 374 */
            //assert (l_40 == 0);
            if (((safe_mul_func_float_f_f((safe_div_func_float_f_f((((safe_lshift_func_int8_t_s_u(__builtin_bswap32(p_50), 3)) , l_515) != &l_516), (safe_sub_func_float_f_f(p_50, (safe_add_func_float_f_f(((safe_mul_func_float_f_f((l_525 , (__builtin_parityl(((+g_107) && ((g_433[0][4][7] <= (safe_mod_func_int16_t_s_s(p_50, p_50))) , l_432[0][1][3]))) , p_50)), l_420)) > l_525.f0), p_50)))))), (-0x5.6p+1))) , l_529))
            { /* block id: 375 */
                struct S0 l_532[10] = {{1},{4},{1},{20},{20},{1},{4},{1},{20},{20}};
                struct S0 *****l_534 = (void*)0;
                int i;
                for (p_50 = 0; (p_50 <= 34); p_50 = safe_add_func_uint16_t_u_u(p_50, 8))
                { /* block id: 378 */
                    struct S0 l_533 = {15};
                    l_533 = (p_50 , l_532[8]);
                }
                (*p_49) = (*p_49);
                for (l_459 = 1; (l_459 <= 6); l_459 += 1)
                { /* block id: 384 */
                    uint64_t l_542[4];
                    int i;
                    for (i = 0; i < 4; i++)
                        l_542[i] = 1UL;
                    (*g_98) = 0xC67319C4L;
                    for (g_6 = 0; (g_6 <= 4); g_6 += 1)
                    { /* block id: 388 */
                        int64_t l_543 = 0xB7B1F47291F4E67ALL;
                        l_534 = (void*)0;
                        (*p_48) = (*p_48);
                        (*p_48) = ((~(((safe_mod_func_int32_t_s_s((**p_48), (safe_rshift_func_int8_t_s_s(((safe_rshift_func_int8_t_s_s((g_31.f0 <= ((p_50 <= 0x4BL) , 0L)), (func_68((*g_98)) >= ((l_542[3] <= l_532[8].f0) || g_41[1][2])))) != 0x8B23L), 5)))) | l_543) && 0xBC974CA1F2D75E25LL)) , l_544);
                    }
                }
                (*p_49) = (void*)0;
            }
            else
            { /* block id: 395 */
                const struct S0 l_547[9] = {{12},{12},{12},{12},{12},{12},{12},{12},{12}};
                int i;
lbl_589:
                for (l_459 = 0; (l_459 <= (-15)); l_459 = safe_sub_func_int16_t_s_s(l_459, 5))
                { /* block id: 398 */
                    struct S0 l_548 = {15};
                    l_548 = l_547[3];
                }
                for (g_6 = 0; (g_6 <= (-16)); g_6 = safe_sub_func_int64_t_s_s(g_6, 6))
                { /* block id: 403 */
                    for (p_50 = (-29); (p_50 != 40); p_50 = safe_add_func_uint8_t_u_u(p_50, 3))
                    { /* block id: 406 */
                        return g_433[0][2][4];
                    }
                    return p_50;
                }
                for (l_459 = 25; (l_459 == (-14)); l_459 = safe_sub_func_int32_t_s_s(l_459, 6))
                { /* block id: 413 */
                    for (g_6 = 0; (g_6 < 11); g_6 = safe_add_func_int8_t_s_s(g_6, 7))
                    { /* block id: 416 */
                        (**l_386) = (*g_119);
                        return l_459;
                    }
                }
                for (g_108 = 0; (g_108 > (-23)); g_108 = safe_sub_func_uint64_t_u_u(g_108, 8))
                { /* block id: 432 */
                    for (g_379 = 3; (g_379 >= 18); ++g_379)
                    { /* block id: 435 */
                        uint8_t l_583[3][7] = {{1UL,0x52L,8UL,254UL,254UL,8UL,0x52L},{1UL,0x52L,8UL,254UL,254UL,8UL,0x52L},{1UL,255UL,254UL,1UL,1UL,254UL,255UL}};
                        int i, j;
                        (**p_48) = ((void*)0 == &p_49);
                        if ((*g_98))
                            break;
                        (**l_386) = ((0x0.Fp-1 == 0xC.CAB270p-97) != (((0xE2L > (safe_mod_func_uint8_t_u_u((g_6 , p_50), g_31.f0))) & (&g_270 == ((safe_mul_func_int16_t_s_s(((safe_add_func_uint64_t_u_u(((safe_sub_func_int16_t_s_s(((safe_div_func_uint8_t_u_u((p_50 , (func_68(l_432[0][1][3]) <= p_50)), 251UL)) <= p_50), (-10L))) , 0x3076A0DB767BAFDCLL), l_583[2][4])) <= 0x03CC5A4AL), p_50)) , (void*)0))) , 0x0.76F351p-83));
                        l_585[6] = l_584;
                    }
                    for (g_107 = 0; g_107 < 8; g_107 += 1)
                    {
                        g_566[g_107] = (void*)0;
                    }
                    for (p_50 = 10; (p_50 >= 2); p_50 = safe_sub_func_uint8_t_u_u(p_50, 2))
                    { /* block id: 444 */
                        (**g_269) = (**g_269);
                        if (l_588)
                            continue;
                        if (l_525.f0)
                            goto lbl_589;
                    }
                }
            }
            (*l_544) = (**p_48);
            for (g_6 = 0; (g_6 <= (-12)); g_6 = safe_sub_func_int8_t_s_s(g_6, 2))
            { /* block id: 454 */
                uint16_t l_599[9][6] = {{0UL,0x5152L,0UL,0UL,0x5152L,0UL},{0UL,0x5152L,0UL,0UL,0x5152L,0UL},{0UL,0x5152L,0UL,0UL,0x5152L,0UL},{0UL,0x5152L,0UL,0UL,0x5152L,0UL},{0UL,0x5152L,0UL,0UL,0x5152L,0UL},{0UL,0x5152L,0UL,0UL,0x5152L,0UL},{0UL,0x5152L,0UL,0UL,0x5152L,0UL},{0UL,0x5152L,0UL,0UL,0x5152L,0UL},{0UL,0x5152L,0UL,0UL,0x5152L,0UL}};
                const struct S0 l_609 = {30};
                int i, j;
                if ((g_108 == 0x81L))
                { /* block id: 455 */
                    int32_t l_592 = 1L;
                    (*l_544) = 0xE94A7693L;
                    (*p_49) = (*p_48);
                    /* statement id: 457 */
                    //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
                    (*l_387) = l_592;
                }
                else
                { /* block id: 459 */
                    (*p_49) = (*p_49);
                }
            }
            /* facts after for loop */
            //assert (l_40 == 0 || (l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]));
        }
        /* facts after branching */
        assert (l_504 == &l_584 || l_504 == 0 || l_504 == &g_148);
        (***l_516) = &l_584;
        /* statement id: 491 */
        assert (l_504 == &l_584);
        for (l_420 = 0; (l_420 != (-15)); l_420 = safe_sub_func_uint32_t_u_u(l_420, 5))
        { /* block id: 494 */
            (***l_515) = (*l_517);
            for (g_379 = 9; (g_379 != 30); ++g_379)
            { /* block id: 498 */
                for (g_108 = 24; (g_108 > 1); g_108 = safe_sub_func_int16_t_s_s(g_108, 6))
                { /* block id: 501 */
                    uint32_t l_621 = 0x0363A8CAL;
                    float * const *l_639[9] = {&l_458,&l_387,&l_458,&l_458,&l_387,&l_458,&l_458,&l_387,&l_458};
                    float * const **l_638[2][3] = {{&l_639[5],&l_639[5],&l_639[5]},{(void*)0,(void*)0,(void*)0}};
                    float * const *** const l_637 = &l_638[1][2];
                    uint32_t l_646[4] = {0x694AB104L,0x694AB104L,0x694AB104L,0x694AB104L};
                    uint32_t l_647 = 0xABCC978BL;
                    int i, j;
                    for (g_6 = 2; (g_6 <= 0); --g_6)
                    { /* block id: 504 */
                        int16_t l_620 = (-1L);
                        (**p_48) = (g_433[0][4][7] , l_588);
                        if (l_620)
                            continue;
                        if (l_584.f0)
                            continue;
                        (**p_48) = __builtin_clzl(l_621);
                    }
                    (*g_98) = func_68((safe_lshift_func_uint8_t_u_s(p_50, p_50)));
                    for (p_50 = 20; (p_50 > 56); p_50 = safe_add_func_uint64_t_u_u(p_50, 7))
                    { /* block id: 513 */
                        if (l_588)
                            break;
                        (*p_48) = (*p_48);
                        return g_433[1][4][0];
                    }
                    (**p_48) = ((safe_lshift_func_uint16_t_u_s(((safe_lshift_func_int16_t_s_u(((safe_mul_func_uint16_t_u_u(0xAC89L, g_433[3][2][3])) <= (safe_mul_func_int16_t_s_s(((***l_515) != (void*)0), ((((safe_mul_func_int8_t_s_s((l_636 != l_637), (0x39A1L | (safe_div_func_uint64_t_u_u(((safe_mod_func_int8_t_s_s(((l_621 & (((safe_lshift_func_int8_t_s_s((-6L), 5)) <= 65533UL) & l_621)) < 0UL), g_6)) , l_646[2]), 0x58AD98EB32115BC5LL))))) , (void*)0) != (void*)0) & l_647)))), 9)) , 6UL), l_529)) , 0x24D2B475L);
                }
            }
            for (g_108 = 3; (g_108 >= 0); g_108 -= 1)
            { /* block id: 523 */
                for (g_6 = 2; (g_6 >= 0); g_6 -= 1)
                { /* block id: 526 */
                    return l_648;
                }
            }
            for (g_6 = 0; (g_6 <= 6); g_6 += 1)
            { /* block id: 532 */
                if (l_529)
                    goto lbl_649;
            }
        }
    }
    /* facts after branching */
    assert (g_98 == &l_459 || (g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
    //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]) || l_40 == 0 || l_40 == &l_459 || l_40 == dangling || l_40 == &g_108);
    //assert (l_504 == dangling || l_504 == 0);
    for (l_420 = 0; (l_420 != 10); l_420 = safe_add_func_uint64_t_u_u(l_420, 2))
    { /* block id: 539 */
        int16_t l_654 = 0x4065L;
        uint32_t l_661[8];
        struct S0 * const l_676 = &l_585[5];
        int32_t l_695 = 1L;
        int i;
        for (i = 0; i < 8; i++)
            l_661[i] = 0xC4F1C860L;
        if (func_60(l_380, &g_98))
        { /* block id: 540 */
            int32_t *l_655 = &g_108;
            int32_t l_660 = 0x2769CC52L;
            struct S0 l_663 = {3};
            (**g_269) = (**g_269);
            l_663 = ((safe_mod_func_int16_t_s_s(g_6, __builtin_clzl(g_107))) , (((l_654 , l_655) != (*p_48)) , (((*l_655) , (g_41[1][2] , ((safe_rshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u(__builtin_ctzll(g_108), l_660)), l_661[1])) && p_50))) , l_662)));
        }
        else
        { /* block id: 543 */
            struct S0 ** const l_671 = &l_504;
            int32_t * const *l_692 = &g_98;
            int32_t * const **l_691 = &l_692;
            struct S0 *l_701 = &l_585[6];
            for (l_648 = 1; (l_648 <= (-26)); l_648 = safe_sub_func_uint8_t_u_u(l_648, 1))
            { /* block id: 546 */
                int32_t l_693 = 0L;
                struct S0 l_698 = {17};
                for (l_459 = 0; (l_459 <= 2); l_459 += 1)
                { /* block id: 549 */
                    int64_t l_694 = 0x64C412ACFF27723CLL;
                    int32_t *l_696 = &g_41[0][3];
                    for (p_50 = 0; (p_50 <= 2); p_50 += 1)
                    { /* block id: 552 */
                        float ***l_668 = &l_386;
                        float **** const l_667 = &l_668;
                        float **** const *l_666 = &l_667;
                        l_666 = (void*)0;
                        /* statement id: 553 */
                        assert (l_666 == 0);
                        g_41[0][3] = (((safe_mod_func_int16_t_s_s((((l_671 == (void*)0) != ((safe_mul_func_int16_t_s_s(((safe_sub_func_uint8_t_u_u(((void*)0 != l_676), (safe_sub_func_int16_t_s_s(((65533UL != (((safe_mul_func_uint16_t_u_u(((*l_676) , (safe_mul_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u((((safe_rshift_func_uint16_t_u_s(((safe_lshift_func_int16_t_s_s((safe_sub_func_int16_t_s_s(((void*)0 != l_691), 0L)), 8)) | (-1L)), 2)) >= (***l_691)) != l_693), 5)), (**l_692)))), p_50)) , 0x90L) && 0x8AL)) , g_107), p_50)))) == l_661[1]), 0x2EBEL)) , 0xF686FE12L)) | g_379), p_50)) , l_694) , 0xC72C2554L);
                        l_695 = (*g_98);
                    }
                    for (g_108 = 0; (g_108 <= 2); g_108 += 1)
                    { /* block id: 559 */
                        if ((*g_98))
                            break;
                    }
                    (*l_696) = l_661[1];
                }
            }
        }
        if (l_709)
            break;
    }
    return (*l_697);
    /* statement id: 587 */
    //assert (g_98 == dangling || (g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
    //assert ((l_40 >= &g_41[0][0] && l_40 <= &g_41[1][3]) || l_40 == 0 || l_40 == dangling || l_40 == &g_108);
}


/* ------------------------------------------ */
/* 
 * reads : g_148 g_98
 * writes: g_98
 */
static int32_t ** func_52(int16_t  p_53, int64_t  p_54)
{ /* block id: 227 */
    int32_t * const l_371 = &g_41[0][3];
    int32_t **l_372 = &g_98;
    const struct S0 *l_375 = &g_148;
    const struct S0 **l_374 = &l_375;
    const struct S0 ***l_373 = &l_374;
    const struct S0 ****l_376 = &l_373;
    struct S0 l_377 = {4};
    (*l_372) = l_371;
    /* statement id: 228 */
    assert ((g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
    (*l_376) = l_373;
    l_377 = (***l_373);
    (*l_372) = (*l_372);
    return l_372;
    /* statement id: 232 */
    //assert (func_52_rv == &g_98);
}


/* ------------------------------------------ */
/* 
 * reads : g_41 g_31 g_6 g_148 g_108 g_98 g_269 g_275 g_270 g_155 g_107 g_314 g_192 g_120 g_127 g_323 g_338 g_340
 * writes: g_6 g_98 g_148 g_108 g_41 g_120 g_127 g_270 g_324 g_338
 */
inline static int64_t  func_60(uint8_t  p_61, int32_t ** p_62)
{ /* block id: 39 */
    const int32_t l_91 = (-2L);
    struct S0 *l_343 = &g_148;
    uint16_t l_368 = 0xDF1AL;
    if (((((p_61 && func_68(g_41[0][0])) < 0UL) ^ (safe_sub_func_uint8_t_u_u((safe_rshift_func_uint8_t_u_u(0xD5L, (safe_rshift_func_uint16_t_u_u(0xFE2CL, 15)))), g_41[1][1]))) ^ __builtin_popcountl(p_61)))
    { /* block id: 42 */
        const int32_t l_86 = 0L;
        const int32_t ***l_339 = (void*)0;
        (*g_340) = func_76((func_78(((safe_div_func_uint16_t_u_u(((__builtin_ia32_crc32qi(((func_68((safe_mul_func_uint8_t_u_u((safe_rshift_func_int8_t_s_u(((((p_61 , ((g_31 , (-2L)) >= g_41[0][3])) <= l_86) | (safe_sub_func_uint32_t_u_u((safe_lshift_func_int8_t_s_s(g_41[0][3], l_91)), (safe_sub_func_int64_t_s_s(l_91, l_91))))) > 0x79A83ADAL), 0)), p_61))) , 9L) , l_91), p_61) , 18446744073709551615UL) == g_41[0][3]), l_91)) , g_6)) != 0x1.571537p+38));
    }
    else
    { /* block id: 197 */
        (**g_269) = (void*)0;
        (*g_270) = (void*)0;
    }
    for (g_108 = (-11); (g_108 < (-7)); g_108 = safe_add_func_uint32_t_u_u(g_108, 9))
    { /* block id: 203 */
        struct S0 *l_344 = &g_148;
        float *l_356 = &g_120[3];
        const int32_t l_357 = 8L;
        struct S0 **l_367 = &l_344;
        struct S0 ***l_366[9][4] = {{&l_367,&l_367,&l_367,&l_367},{&l_367,&l_367,(void*)0,&l_367},{&l_367,&l_367,&l_367,&l_367},{&l_367,&l_367,&l_367,&l_367},{&l_367,&l_367,&l_367,(void*)0},{&l_367,&l_367,(void*)0,(void*)0},{&l_367,&l_367,&l_367,&l_367},{&l_367,&l_367,&l_367,&l_367},{&l_367,&l_367,(void*)0,&l_367}};
        struct S0 ****l_365 = &l_366[5][0];
        struct S0 *****l_364 = &l_365;
        int i, j;
        for (g_6 = 1; (g_6 >= 0); g_6 -= 1)
        { /* block id: 206 */
            int i, j;
            g_41[g_6][(g_6 + 2)] = (-1L);
        }
        if ((l_343 != l_344))
        { /* block id: 209 */
            (*g_270) = (*g_270);
            for (g_6 = 2; (g_6 <= (-17)); g_6 = safe_sub_func_uint64_t_u_u(g_6, 4))
            { /* block id: 213 */
                if (l_91)
                    break;
            }
        }
        else
        { /* block id: 216 */
            float *l_347 = &g_120[3];
            (*l_347) = __builtin_ffsl((l_91 , 0x074FC59CL));
        }
        (*g_98) = (safe_div_func_int32_t_s_s((safe_add_func_int64_t_s_s(1L, (-1L))), ((safe_div_func_int64_t_s_s(func_68((((safe_div_func_uint16_t_u_u(((((l_356 != l_356) & l_357) ^ g_41[1][1]) ^ p_61), (safe_mod_func_int16_t_s_s((0x9DL <= (((safe_rshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_u((((l_364 == &l_365) , 0x764A5F26L) || l_91), g_314)), l_91)) > l_91) <= p_61)), 0xA5EFL)))) & p_61) , l_368)), 1L)) | 0x10L)));
        for (l_368 = 0; (l_368 != 39); l_368 = safe_add_func_uint32_t_u_u(l_368, 3))
        { /* block id: 222 */
            if (l_357)
                break;
        }
    }
    return l_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_68(int32_t  p_69)
{ /* block id: 40 */
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_323 g_338
 * writes: g_6 g_324 g_108
 */
static const int32_t ** func_76(float  p_77)
{ /* block id: 181 */
    int32_t *l_329 = (void*)0;
    struct S0 l_333 = {14};
    const int32_t *l_337 = (void*)0;
    const int32_t **l_336 = &l_337;
    for (g_6 = 21; (g_6 != 5); --g_6)
    { /* block id: 184 */
        struct S0 * const l_330 = (void*)0;
        struct S0 ** const  volatile **l_335 = (void*)0;
        struct S0 ** const  volatile ***l_334 = &l_335;
        (*g_323) = &g_149;
        for (g_108 = 0; (g_108 > 29); ++g_108)
        { /* block id: 188 */
            int32_t *l_327 = &g_108;
            int32_t **l_328 = (void*)0;
            struct S0 *l_332 = &g_148;
            struct S0 **l_331 = &l_332;
            l_329 = l_327;
            /* statement id: 189 */
            assert (l_329 == &g_108);
            (*l_331) = l_330;
            /* statement id: 190 */
            assert (l_332 == 0);
            l_333 = l_333;
        }
        (*l_334) = &g_324[0][0][3];
        /* statement id: 193 */
        assert ((l_335 >= &g_324[0][0][0] && l_335 <= &g_324[0][3][3]));
    }
    /* facts after for loop */
    assert (l_329 == &g_108 || l_329 == 0);
    return g_338;
    /* statement id: 195 */
    //assert (func_76_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_41 g_148 g_108 g_98 g_269 g_275 g_31.f0 g_270 g_155 g_107 g_314 g_192 g_120 g_127 l_459
 * writes: g_6 g_98 g_148 g_108 g_41 g_120 g_127 g_270 l_459
 */
inline static float  func_78(float  p_79)
{ /* block id: 43 */
    int32_t *l_94 = &g_41[0][3];
    uint64_t l_116 = 18446744073709551615UL;
    uint64_t l_132[6];
    struct S0 *l_147 = &g_148;
    float l_153 = (-0x3.7p+1);
    uint64_t l_229[5][5][6] = {{{0x6404DC0F1C83726DLL,18446744073709551614UL,18446744073709551611UL,1UL,0UL,18446744073709551613UL},{0x32E19209CF466BE1LL,0x2D9D8ABC683ED5A7LL,0xBD08AE5EAE226BEBLL,18446744073709551615UL,0UL,1UL},{18446744073709551610UL,18446744073709551613UL,0xD09D3C4D2ADB4F27LL,1UL,8UL,0x7FA829B7C7E5BD8FLL},{0xC23F78381580886FLL,0x219E0C19E0181DA6LL,18446744073709551615UL,0x219E0C19E0181DA6LL,0xC23F78381580886FLL,18446744073709551615UL},{0x5CE0736A644C7829LL,18446744073709551615UL,0x6404DC0F1C83726DLL,1UL,9UL,18446744073709551615UL}},{{1UL,0x02FA1FB7984CDCF2LL,0UL,18446744073709551615UL,0UL,18446744073709551615UL},{18446744073709551615UL,18446744073709551610UL,0x6404DC0F1C83726DLL,18446744073709551611UL,0xF5AE1CCF118B289ELL,18446744073709551615UL},{0UL,18446744073709551615UL,18446744073709551615UL,0xA44F27AFECD87168LL,0x2D9D8ABC683ED5A7LL,0x7FA829B7C7E5BD8FLL},{0xC1215010C314D703LL,18446744073709551614UL,0xD09D3C4D2ADB4F27LL,0x38C59D00192FCFE0LL,18446744073709551615UL,1UL},{1UL,0xC23F78381580886FLL,0xBD08AE5EAE226BEBLL,18446744073709551609UL,0x5CE0736A644C7829LL,18446744073709551613UL}},{{0x38C59D00192FCFE0LL,0x28DD6C4D081FCDCBLL,18446744073709551611UL,0x32E19209CF466BE1LL,0x5955131B15F34AE0LL,0UL},{1UL,5UL,0xF5AE1CCF118B289ELL,0x02FA1FB7984CDCF2LL,0UL,9UL},{5UL,5UL,18446744073709551614UL,18446744073709551614UL,0UL,0UL},{18446744073709551611UL,0x7FA829B7C7E5BD8FLL,0x7FA829B7C7E5BD8FLL,18446744073709551611UL,18446744073709551615UL,0xC1215010C314D703LL},{8UL,0UL,18446744073709551615UL,0UL,0UL,0xC23F78381580886FLL}},{{0UL,18446744073709551615UL,9UL,0x02FA1FB7984CDCF2LL,0UL,0xB306596C44C6D56ELL},{0x85A425B5E633137ALL,0UL,0xF5AE1CCF118B289ELL,0x3C1EEC739D5C1E08LL,18446744073709551615UL,0x2D9D8ABC683ED5A7LL},{18446744073709551615UL,0x7FA829B7C7E5BD8FLL,0UL,0x6D91DA8F8FD024E1LL,0UL,1UL},{0xA44F27AFECD87168LL,0x5955131B15F34AE0LL,18446744073709551611UL,0x5CE0736A644C7829LL,0xD09D3C4D2ADB4F27LL,0x32E19209CF466BE1LL},{0UL,18446744073709551614UL,18446744073709551613UL,18446744073709551609UL,5UL,0x43ED317036850D54LL}},{{0x3C1EEC739D5C1E08LL,0UL,18446744073709551615UL,0UL,0x219E0C19E0181DA6LL,5UL},{9UL,0x32E19209CF466BE1LL,0x5CE0736A644C7829LL,18446744073709551610UL,0x43ED317036850D54LL,0x02FA1FB7984CDCF2LL},{0x6D91DA8F8FD024E1LL,0x3C1EEC739D5C1E08LL,0x219E0C19E0181DA6LL,5UL,0x5CE0736A644C7829LL,5UL},{0UL,0x43ED317036850D54LL,0UL,18446744073709551607UL,5UL,0x5CE0736A644C7829LL},{0UL,0UL,0UL,0x32E19209CF466BE1LL,0UL,18446744073709551615UL}}};
    volatile int32_t * volatile **l_272 = &g_270;
    int i, j, k;
    for (i = 0; i < 6; i++)
        l_132[i] = 0x4503A7054D2AC322LL;
lbl_250:
    for (g_6 = 1; (g_6 >= 0); g_6 -= 1)
    { /* block id: 46 */
        float l_95 = (-0x1.3p+1);
        int32_t l_103 = 0L;
        int32_t **l_106 = &g_98;
        float l_115 = 0x5.57609Ep+15;
        struct S0 l_128 = {22};
        float **l_210 = (void*)0;
        uint8_t l_237[7][1];
        int i, j;
        for (i = 0; i < 7; i++)
        {
            for (j = 0; j < 1; j++)
                l_237[i][j] = 1UL;
        }
        if (((((((void*)0 == l_94) > 0x9B4DB59FB14BE569LL) ^ g_6) , 0x934CEB0392260F14LL) == g_41[0][3]))
        { /* block id: 47 */
            int32_t *l_96 = &g_41[0][3];
            int32_t **l_97[2];
            int i;
            for (i = 0; i < 2; i++)
                l_97[i] = &l_96;
            g_98 = l_96;
            /* statement id: 48 */
            assert ((g_98 >= &g_41[0][0] && g_98 <= &g_41[1][3]));
        }
        else
        { /* block id: 49 */
            const int32_t *l_100 = &g_41[0][3];
            const int32_t **l_99 = &l_100;
            (*l_99) = (void*)0;
            /* statement id: 50 */
            assert (l_100 == 0);
        }
        if (g_6)
            goto lbl_250;
    }
    (*l_147) = (*l_147);
    for (g_6 = 0; (g_6 > (-2)); g_6 = safe_sub_func_int16_t_s_s(g_6, 5))
    { /* block id: 138 */
        uint8_t l_263 = 0x12L;
        int32_t l_291[9] = {(-5L),7L,(-5L),7L,(-5L),7L,(-5L),7L,(-5L)};
        int32_t **l_318 = &l_94;
        int32_t ***l_317 = &l_318;
        int i;
        for (g_108 = 0; (g_108 != 6); ++g_108)
        { /* block id: 141 */
            volatile int32_t * volatile ***l_271[6] = {&g_269,&g_269,&g_269,&g_269,&g_269,&g_269};
            uint16_t l_304 = 0x2AFEL;
            int64_t l_313 = 0L;
            int i;
            for (l_116 = (-16); (l_116 < 2); ++l_116)
            { /* block id: 144 */
                float *l_258 = &l_153;
                float **l_257 = &l_258;
                const int32_t l_268 = 0x63680A18L;
                (*g_98) = (l_257 == (void*)0);
                (*l_94) = ((safe_div_func_int16_t_s_s(((safe_sub_func_int64_t_s_s(g_148.f0, (l_263 | (__builtin_popcountll((safe_lshift_func_uint16_t_u_s(((safe_rshift_func_uint8_t_u_u(l_263, 1)) == l_268), (l_268 & 0x4153CC6216E46704LL)))) <= 0x32DDE119L)))) , ((g_148.f0 , (void*)0) != (void*)0)), 65535UL)) , (-7L));
            }
            l_272 = g_269;
            for (l_263 = 18; (l_263 >= 51); ++l_263)
            { /* block id: 151 */
                int32_t ***l_276 = (void*)0;
                int32_t l_315 = 0L;
                (*g_275) = p_79;
                (*g_98) = ((l_276 == &g_270) , (safe_unary_minus_func_int32_t_s(((0x8F7548C9L != (*g_98)) , (*l_94)))));
                if ((safe_lshift_func_uint8_t_u_u(((g_41[0][3] > (1L ^ (safe_rshift_func_int8_t_s_s((safe_unary_minus_func_int8_t_s(g_148.f0)), 3)))) || (0x2FL || (safe_sub_func_uint64_t_u_u((*l_94), l_263)))), (0x53A13BA321D59750LL || (g_6 < __builtin_ia32_crc32qi((safe_add_func_int64_t_s_s(g_31.f0, g_41[0][3])), g_148.f0))))))
                { /* block id: 154 */
                    int16_t l_287 = 0x57F3L;
                    const int32_t *l_292 = &g_41[1][3];
                    if (l_287)
                    { /* block id: 155 */
                        float *l_288[10] = {&g_120[4],&g_120[4],&g_120[4],&g_120[4],&g_120[4],&g_120[4],&g_120[4],&g_120[4],&g_120[4],&g_120[4]};
                        int i;
                        (**g_269) = (void*)0;
                        (*g_155) = 0x5.Ep-1;
                    }
                    else
                    { /* block id: 158 */
                        float l_289 = 0xD.DF69DBp-34;
                        int32_t l_290 = 0xEC65E067L;
                        const int32_t **l_293 = &l_292;
                        l_291[0] = l_290;
                        (*g_98) = (*g_98);
                        (*l_293) = l_292;
                        (*g_98) = 0x489F91F7L;
                    }
                    if ((safe_lshift_func_uint8_t_u_u(((safe_sub_func_uint32_t_u_u((safe_mul_func_uint8_t_u_u(((((((*l_292) , (safe_sub_func_int32_t_s_s((*l_292), 0UL))) != ((l_291[0] & (safe_sub_func_uint16_t_u_u((((l_304 <= ((safe_sub_func_int32_t_s_s(((((__builtin_ffsll((0x49D4L | (((*l_292) >= ((safe_rshift_func_int8_t_s_u((((safe_lshift_func_uint8_t_u_u(((((safe_mul_func_int16_t_s_s((((void*)0 != &g_117[3]) >= 0xD8L), g_6)) , 9L) || l_313) , g_107), g_108)) , 18446744073709551608UL) || g_31.f0), g_6)) & g_108)) == g_314))) , (void*)0) != &g_270) > g_148.f0) && (*l_94)), (-5L))) || 0x2F73DE9391A50DC0LL)) , g_107) <= l_263), 1L))) , 0x0F1069EAL)) < l_313) <= l_315) && 0x1B2EE99A6343D952LL), 0x80L)), 4294967286UL)) , g_41[1][3]), 0)))
                    { /* block id: 164 */
                        return (*g_192);
                    }
                    else
                    { /* block id: 166 */
                        const int64_t l_316 = 0x8D0A81A918C5570CLL;
                        (*g_270) = (*g_270);
                        (*g_269) = (*g_269);
                        if (l_316)
                            break;
                    }
                    p_79 = p_79;
                }
                else
                { /* block id: 172 */
                    int32_t ****l_319 = &l_276;
                    (*l_319) = l_317;
                    /* statement id: 173 */
                    assert (l_276 == &l_318);
                    (*g_98) = (~0L);
                }
                /* facts after branching */
                assert (l_276 == &l_318 || l_276 == 0);
            }
        }
        return p_79;
    }
    return (*l_94);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_31.f0, "g_31.f0", print_hash_value);
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 4; j++)
        {
            transparent_crc(g_41[i][j], "g_41[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_107, "g_107", print_hash_value);
    transparent_crc(g_108, "g_108", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        transparent_crc_bytes(&g_120[i], sizeof(g_120[i]), "g_120[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_148.f0, "g_148.f0", print_hash_value);
    transparent_crc(g_314, "g_314", print_hash_value);
    transparent_crc(g_379, "g_379", print_hash_value);
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc_bytes(&g_431[i][j], sizeof(g_431[i][j]), "g_431[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 6; j++)
        {
            for (k = 0; k < 8; k++)
            {
                transparent_crc(g_433[i][j][k], "g_433[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_865, "g_865", print_hash_value);
    transparent_crc(g_884, "g_884", print_hash_value);
    transparent_crc(g_1120.f0, "g_1120.f0", print_hash_value);
    transparent_crc(g_1134.f0, "g_1134.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 278
   depth: 1, occurrence: 55
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 89
breakdown:
   indirect level: 0, occurrence: 55
   indirect level: 1, occurrence: 15
   indirect level: 2, occurrence: 10
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 55
breakdown:
   indirect level: 0, occurrence: 55
XXX times a bitfields struct's address is taken: 94
XXX times a bitfields struct on LHS: 19
XXX times a bitfields struct on RHS: 65
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 58

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 277
   depth: 2, occurrence: 74
   depth: 3, occurrence: 5
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 10, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 274

XXX times a variable address is taken: 579
XXX times a pointer is dereferenced on RHS: 162
breakdown:
   depth: 1, occurrence: 117
   depth: 2, occurrence: 38
   depth: 3, occurrence: 7
XXX times a pointer is dereferenced on LHS: 212
breakdown:
   depth: 1, occurrence: 163
   depth: 2, occurrence: 42
   depth: 3, occurrence: 7
XXX times a pointer is compared with null: 35
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 1534

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 686
   level: 2, occurrence: 260
   level: 3, occurrence: 95
   level: 4, occurrence: 12
   level: 5, occurrence: 11
XXX number of pointers point to pointers: 159
XXX number of pointers point to scalars: 83
XXX number of pointers point to structs: 32
XXX percent of pointers has null in alias set: 29.2
XXX average alias set size: 1.44

XXX times a non-volatile is read: 1292
XXX times a non-volatile is write: 623
XXX times a volatile is read: 93
XXX    times read thru a pointer: 20
XXX times a volatile is write: 58
XXX    times written thru a pointer: 28
XXX times a volatile is available for access: 759
XXX percentage of non-volatile access: 92.7

XXX forward jumps: 2
XXX backward jumps: 9

XXX stmts: 260
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 29
   depth: 2, occurrence: 45
   depth: 3, occurrence: 49
   depth: 4, occurrence: 58
   depth: 5, occurrence: 51

XXX percentage a fresh-made variable is used: 22.5
XXX percentage an existing variable is used: 77.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

