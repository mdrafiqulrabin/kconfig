/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3340615624
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
};
#pragma pack(pop)

struct S1 {
   int32_t  f0;
   struct S0  f1;
   int32_t  f2;
   int32_t  f3;
   struct S0  f4;
   signed f5 : 17;
   uint32_t  f6;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_7 = 0U;
static uint32_t g_29 = 0x73A4C924;
static int32_t g_33 = 0xB2E809B4;
static struct S1 g_61 = {1,{0x0AA07078},0x3FCEEEC8,0,{0xE7900082},289,5U};
static uint16_t g_82 = 0U;


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_32(void);
static int32_t  func_34(uint32_t  p_35, struct S1  p_36, struct S0  p_37, uint32_t  p_38, uint16_t  p_39);
static int32_t  func_40(int32_t  p_41);
static struct S1  func_43(uint16_t  p_44, struct S1  p_45, int32_t  p_46, int16_t  p_47);
static struct S1  func_48(int16_t  p_49);
static struct S1  func_50(struct S1  p_51);
static struct S1  func_52(int32_t  p_53, struct S1  p_54, struct S0  p_55);
static uint32_t  func_56(struct S1  p_57, int32_t  p_58, uint32_t  p_59, uint32_t  p_60);
static int32_t  func_65(struct S0  p_66, uint32_t  p_67);
static struct S0  func_68(uint32_t  p_69, uint32_t  p_70);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_61 g_7 g_29 g_82 g_33
 * writes: g_33 g_82 g_61
 */
static struct S1  func_32(void)
{ /* block id: 36 */
    uint32_t l_42 = 0xF63EEDA7;
    struct S1 l_199 = {0x493D40E6,{0x5772B18E},0xE2E21426,0x232ECD07,{1U},-69,4294967287U};
    g_33 = 0x5537C57F;
    l_199.f5 = __builtin_ffsl(func_34((func_40(l_42) && ((-(uint32_t)l_42) > l_42)), l_199, l_199.f1, g_7, l_199.f0));
    g_61.f4 = g_61.f4;
    return g_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_34(uint32_t  p_35, struct S1  p_36, struct S0  p_37, uint32_t  p_38, uint16_t  p_39)
{ /* block id: 103 */
    int32_t l_200 = 0xE9AB393D;
    return l_200;
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_7 g_29 g_82 g_33
 * writes: g_82 g_61
 */
static int32_t  func_40(int32_t  p_41)
{ /* block id: 38 */
    struct S1 l_197 = {-7,{0x4F4B611B},0xE515C3C2,-1,{4294967286U},91,0x816EC6A9};
    l_197 = func_43(p_41, func_48(p_41), __builtin_ia32_crc32qi(p_41, (-(uint16_t)1U)), p_41);
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads : g_61.f6 g_29 g_82
 * writes:
 */
static struct S1  func_43(uint16_t  p_44, struct S1  p_45, int32_t  p_46, int16_t  p_47)
{ /* block id: 98 */
    uint32_t l_194 = 1U;
    struct S0 l_195 = {0x3CAE3F3A};
    struct S1 l_196 = {0xA747682D,{1U},0,0x9D7BC268,{4294967295U},-149,0x72973F10};
    l_195 = func_68(((((((((int32_t)((int32_t)p_45.f2 - (int32_t)p_45.f5) + (int32_t)(g_61.f6 & ((((uint32_t)((((0x52E1 >= 1U) > (g_29 < (0 && ((uint16_t)((int16_t)(~p_45.f2) + (int16_t)0xA178) >> (uint16_t)3)))) & 4294967293U) ^ 0x4CE2010D) % (uint32_t)l_194) != 0x150234E0) > l_194))) > 3U) && g_82) == l_194) && (-1)) != l_194) == p_45.f3), g_29);
    return l_196;
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_7 g_29 g_82 g_33
 * writes: g_82 g_61
 */
static struct S1  func_48(int16_t  p_49)
{ /* block id: 39 */
    int32_t l_62 = 5;
    int32_t l_78 = 1;
    struct S1 l_83 = {0x12DD267A,{0U},-2,0x6D3FBECF,{4294967290U},-258,1U};
    l_83 = func_50(func_52((__builtin_ia32_crc32qi(p_49, p_49) & ((((func_56(g_61, g_61.f0, l_62, ((uint16_t)(((func_65(func_68(((int16_t)(((((uint16_t)((uint16_t)((l_62 & (-(uint16_t)l_62)) > __builtin_popcount((g_61.f0 == 0x9D3D8B2F))) % (uint16_t)l_78) % (uint16_t)l_78) ^ 1U) <= g_29) >= p_49) >> (int16_t)3), p_49), p_49) & 4294967286U) <= l_62) && p_49) >> (uint16_t)2)) != 0x3BBBF133) == 65535U) ^ p_49) >= l_62)), l_83, g_61.f4));
    l_83.f5 = p_49;
    return g_61;
}


/* ------------------------------------------ */
/* 
 * reads : g_61.f3 g_82 g_7 g_61.f5 g_61.f1.f0 g_61.f0 g_61 g_29 g_33
 * writes: g_61.f2 g_61 g_82
 */
static struct S1  func_50(struct S1  p_51)
{ /* block id: 51 */
    uint32_t l_94 = 0x60D347FA;
    struct S0 l_115 = {4294967294U};
    int32_t l_121 = (-10);
    struct S1 l_179 = {-3,{0x60B7E2CB},9,1,{0U},-357,4294967295U};
    g_61.f2 = (__builtin_parityl(g_61.f3) < __builtin_clz(((int16_t)(!(g_82 | ((((l_94 != 0x1A91DCBA) || ((uint16_t)(((uint16_t)g_7 << (uint16_t)3) == ((((int16_t)(1U & g_61.f5) - (int16_t)(l_94 ^ g_7)) | 0U) ^ 4294967295U)) >> (uint16_t)l_94)) && l_94) && 2U))) - (int16_t)l_94)));
    if (((-7) & ((uint32_t)p_51.f0 - (uint32_t)((-(int32_t)(p_51.f0 | ((p_51.f6 < (g_7 == ((uint32_t)(p_51.f2 >= p_51.f2) % (uint32_t)p_51.f4.f0))) != (((int16_t)__builtin_ctz(p_51.f1.f0) << (int16_t)l_94) == g_61.f1.f0)))) == 65529U))))
    { /* block id: 53 */
        uint32_t l_114 = 4294967294U;
        struct S1 l_116 = {-4,{4294967290U},0xC2F6D8A0,0,{0x337CDB55},-212,0U};
        l_116 = func_52((0x85A9 || ((int16_t)((int32_t)g_61.f3 % (int32_t)l_114) << (int16_t)func_65(l_115, g_61.f0))), p_51, func_68(((-9) && g_61.f1.f0), l_94));
        l_121 = ((int16_t)((uint16_t)(l_116.f6 | g_29) % (uint16_t)g_61.f4.f0) >> (int16_t)14);
    }
    else
    { /* block id: 56 */
        int32_t l_124 = 1;
        for (p_51.f2 = 9; (p_51.f2 == (-23)); p_51.f2 -= 1)
        { /* block id: 59 */
            struct S1 l_127 = {3,{0x706A3B5E},0xD512F4EC,4,{4U},-235,0xE982BA97};
            int16_t l_170 = 7;
            if (l_124)
            { /* block id: 60 */
                l_127 = func_52((0x6C8C != ((int16_t)l_124 >> (int16_t)7)), g_61, p_51.f4);
            }
            else
            { /* block id: 62 */
                p_51.f3 = 0xC1E51B7A;
                if (g_61.f3)
                    continue;
            }
            for (g_61.f2 = (-1); (g_61.f2 >= 27); g_61.f2 += 1)
            { /* block id: 68 */
                uint32_t l_141 = 0x91441489;
                int32_t l_158 = 0xD8EA33B3;
                for (g_61.f3 = 0; (g_61.f3 >= 2); g_61.f3 += 1)
                { /* block id: 71 */
                    int32_t l_155 = 0;
                    if ((l_121 <= ((!(((int32_t)l_121 + (int32_t)(g_7 >= 65527U)) <= ((int16_t)(g_33 != ((uint16_t)(((65535U & ((int16_t)((g_33 > g_61.f1.f0) < ((65531U <= (-10)) || 0xEF20)) << (int16_t)p_51.f3)) | g_61.f5) ^ 0) << (uint16_t)l_141)) + (int16_t)0x9DDC))) ^ g_61.f6)))
                    { /* block id: 72 */
                        int32_t l_142 = (-2);
                        l_124 = (0x532626EB & (l_142 > p_51.f0));
                        l_158 = ((l_94 <= p_51.f6) && (((((uint16_t)((uint16_t)((int16_t)(((int16_t)__builtin_ffsll(p_51.f2) << (int16_t)6) > (((uint16_t)(-(uint32_t)((!l_155) | ((int32_t)g_61.f4.f0 - (int32_t)(g_61.f3 & ((p_51.f0 != (func_56(p_51, p_51.f5, g_7, p_51.f5) & l_127.f5)) || 0x82E662C9))))) >> (uint16_t)9) <= p_51.f0)) + (int16_t)p_51.f2) - (uint16_t)0x45A4) >> (uint16_t)10) ^ l_142) || 0x9A68D69D) <= p_51.f1.f0));
                    }
                    else
                    { /* block id: 75 */
                        p_51.f5 = p_51.f3;
                        p_51.f1 = func_68(__builtin_ctzll(((int32_t)(p_51.f3 ^ ((int16_t)(((uint16_t)g_61.f0 - (uint16_t)p_51.f5) < ((uint32_t)((-3) & ((func_56(l_127, __builtin_clzll(l_155), g_7, p_51.f0) <= g_29) ^ l_121)) % (uint32_t)3)) % (int16_t)g_61.f5)) % (int32_t)g_61.f4.f0)), p_51.f6);
                    }
                }
                for (p_51.f3 = (-1); (p_51.f3 <= 20); p_51.f3 += 7)
                { /* block id: 82 */
                    if (p_51.f5)
                        break;
                    g_61.f3 = (g_61.f4.f0 & (-(uint32_t)func_56(p_51, (func_65(func_68((l_170 <= g_29), (!(-(uint32_t)((int16_t)g_61.f4.f0 >> (int16_t)3)))), g_33) && (((int16_t)(5 > 0x706A) + (int16_t)g_61.f3) == 0xD60D)), p_51.f5, p_51.f6)));
                }
            }
            for (l_127.f3 = 0; (l_127.f3 == 17); l_127.f3 += 1)
            { /* block id: 89 */
                l_124 = 5;
            }
        }
    }
    return l_179;
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_82
 * writes: g_61 g_82
 */
static struct S1  func_52(int32_t  p_53, struct S1  p_54, struct S0  p_55)
{ /* block id: 47 */
    int16_t l_86 = 0xA743;
    int32_t l_89 = 0x431F4830;
    struct S1 l_90 = {0xC0CBF820,{0xC77F51BC},-2,0xF0CD8B2F,{4294967295U},121,5U};
    g_61 = g_61;
    l_89 = ((((int16_t)((l_86 >= p_54.f6) != 0x79296E56) << (int16_t)6) < ((uint16_t)0xFE4D << (uint16_t)(g_61.f6 <= (__builtin_ia32_crc32qi(p_54.f1.f0, p_54.f1.f0) ^ (__builtin_bswap64(func_56(g_61, g_82, p_54.f4.f0, p_54.f4.f0)) == 1U))))) < 1U);
    return l_90;
}


/* ------------------------------------------ */
/* 
 * reads : g_61.f6
 * writes: g_82
 */
static uint32_t  func_56(struct S1  p_57, int32_t  p_58, uint32_t  p_59, uint32_t  p_60)
{ /* block id: 44 */
    g_82 = (p_57.f0 & ((uint16_t)g_61.f6 >> (uint16_t)13));
    return p_57.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_65(struct S0  p_66, uint32_t  p_67)
{ /* block id: 42 */
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_68(uint32_t  p_69, uint32_t  p_70)
{ /* block id: 40 */
    struct S0 l_79 = {9U};
    return l_79;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_32();
    transparent_crc(g_7, "g_7", print_hash_value);
    transparent_crc(g_29, "g_29", print_hash_value);
    transparent_crc(g_33, "g_33", print_hash_value);
    transparent_crc(g_61.f0, "g_61.f0", print_hash_value);
    transparent_crc(g_61.f1.f0, "g_61.f1.f0", print_hash_value);
    transparent_crc(g_61.f2, "g_61.f2", print_hash_value);
    transparent_crc(g_61.f3, "g_61.f3", print_hash_value);
    transparent_crc(g_61.f4.f0, "g_61.f4.f0", print_hash_value);
    transparent_crc(g_61.f5, "g_61.f5", print_hash_value);
    transparent_crc(g_61.f6, "g_61.f6", print_hash_value);
    transparent_crc(g_82, "g_82", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 3
   depth: 2, occurrence: 9
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 9
breakdown:
   indirect level: 0, occurrence: 9
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 10

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 176
XXX times a non-volatile is write: 26
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 41
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 3
   depth: 2, occurrence: 3
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 21.6
XXX percentage an existing variable is used: 78.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

