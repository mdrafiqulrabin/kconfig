/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2476811824
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_31(void);
static int32_t * func_32(int32_t  p_33, int32_t  p_34);
static int32_t  func_39(int32_t * p_40, int16_t  p_41);
static int32_t * func_42(uint32_t  p_43, int32_t * p_44, uint16_t  p_45, int32_t * p_46);
inline static uint16_t  func_49(int32_t  p_50, int16_t  p_51, float  p_52);
static int32_t  func_61(int32_t * p_62, int32_t  p_63, int32_t * p_64, uint32_t  p_65, int32_t * p_66);
inline static int32_t ** func_71(int32_t * p_72, int32_t * p_73, uint16_t  p_74, int32_t * p_75, int32_t ** p_76);
inline static int32_t * func_77(int32_t * p_78, uint32_t  p_79, int32_t * p_80, int32_t * p_81, int32_t  p_82);
inline static uint16_t  func_83(int32_t * p_84, int32_t * p_85, int32_t  p_86, int32_t  p_87, int32_t * p_88);
static int32_t * func_89(int32_t * p_90, int32_t  p_91, int32_t * p_92, int32_t ** p_93, uint32_t  p_94);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_31(void)
{ /* block id: 36 */
    int32_t l_36 = 0xA5F27A41L;
    int32_t *l_35 = &l_36;
    int32_t **l_320 = &l_35;
    uint16_t l_321 = 0x85C9L;
    (*l_320) = func_32(((((l_35 == &l_36) | ((*l_35) >= (*l_35))) <= ((int16_t)(((func_39(&l_36, (*l_35)) != (!(!func_83(&l_36, &l_36, (*l_35), (*l_35), &l_36)))) && 8UL) <= (*l_35)) - (int16_t)(*l_35))) < (*l_35)), (*l_35));
    return l_321;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_32(int32_t  p_33, int32_t  p_34)
{ /* block id: 168 */
    uint16_t l_255 = 0xE84DL;
    int32_t *l_260 = (void*)0;
    int32_t **l_259 = &l_260;
    int32_t ***l_258 = &l_259;
    int32_t l_275 = 0x20AEDE11L;
    int32_t *l_274 = &l_275;
    int32_t *l_318 = &l_275;
    int32_t *l_319 = (void*)0;
    l_255 = p_34;
    if (l_255)
    { /* block id: 170 */
        uint32_t l_261 = 1UL;
        float l_267 = 0x0.0p-1;
        float *l_266 = &l_267;
        int32_t *l_276 = &l_275;
        int32_t *l_278 = &l_275;
        int32_t *l_280 = &l_275;
        int32_t *l_281 = (void*)0;
        (*l_266) = ((p_33 <= ((((__builtin_bswap32(p_34) <= 0x0.1p+1) < __builtin_ia32_crc32qi(((uint16_t)((void*)0 != l_258) + (uint16_t)(l_261 < ((int16_t)((uint32_t)__builtin_clzl(l_261) - (uint32_t)p_34) >> (int16_t)p_33))), l_261)) >= p_34) >= l_261)) > 0x6.5p-1);
        for (p_33 = 2; (p_33 > 0); p_33 -= 1)
        { /* block id: 174 */
            int32_t *l_270 = (void*)0;
            int32_t l_272 = 2L;
            int32_t *l_271 = &l_272;
            int32_t *l_273 = &l_272;
            int32_t *l_277 = &l_275;
            int32_t *l_279 = &l_275;
            (*l_271) = (p_33 != 0L);
            return l_281;
        }
    }
    else
    { /* block id: 178 */
        int32_t *l_296 = &l_275;
        int16_t l_297 = 1L;
        int16_t l_309 = 0xFED9L;
        (*l_259) = (void*)0;
        (*l_274) = (p_33 >= 3UL);
        for (p_33 = (-19); (p_33 > 27); p_33 += 1)
        { /* block id: 183 */
            float *l_289 = (void*)0;
            float **l_288 = &l_289;
            float ***l_287 = &l_288;
            int32_t l_295 = (-1L);
            (**l_258) = &p_33;
            for (p_34 = 0; (p_34 == 4); p_34 += 1)
            { /* block id: 187 */
                int32_t *l_286 = (void*)0;
                uint16_t l_310 = 1UL;
                (**l_258) = l_286;
                l_287 = (void*)0;
                for (l_255 = 2; (l_255 >= 45); l_255 += 7)
                { /* block id: 192 */
                    uint32_t l_294 = 1UL;
                    int32_t l_298 = 0x4BA52184L;
                    (**l_258) = func_77((*l_259), ((int32_t)(__builtin_popcountll(p_34) | l_294) % (int32_t)l_295), l_286, l_296, ((func_49(__builtin_popcountll(l_297), l_295, l_294) <= p_33) && 8UL));
                    l_298 = l_294;
                    if ((*l_296))
                        continue;
                }
                for (l_297 = 0; (l_297 > (-4)); l_297 -= 1)
                { /* block id: 199 */
                    int16_t l_303 = (-7L);
                    float *l_311 = (void*)0;
                    float l_313 = 0x3.B83D35p+30;
                    float *l_312 = &l_313;
                    if (((int32_t)(0x0FD85092L == ((l_303 <= ((0x43121853L && (((*l_296) && p_33) != 1L)) >= ((int16_t)0L - (int16_t)0L))) > 0UL)) + (int32_t)0xF298B996L))
                    { /* block id: 200 */
                        float ***l_306 = &l_288;
                        int32_t l_307 = 0xD0C9CB34L;
                        l_307 = (l_306 != (void*)0);
                        if (p_34)
                            continue;
                        if (p_33)
                            continue;
                    }
                    else
                    { /* block id: 204 */
                        int32_t **l_308 = &l_286;
                        (*l_308) = &p_34;
                        if (l_303)
                            break;
                    }
                    (*l_312) = l_310;
                    if (l_295)
                    { /* block id: 209 */
                        int32_t *l_314 = &l_275;
                        l_314 = (void*)0;
                    }
                    else
                    { /* block id: 211 */
                        int32_t *l_315 = &l_275;
                        (**l_258) = l_315;
                        (*l_274) = (((int16_t)(((void*)0 == l_315) ^ (*l_315)) >> (int16_t)12) && p_34);
                        (*l_312) = (-0x6.Ep+1);
                        (*l_260) = ((l_296 == (void*)0) > l_303);
                    }
                }
            }
        }
    }
    return l_319;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_39(int32_t * p_40, int16_t  p_41)
{ /* block id: 37 */
    uint32_t l_57 = 5UL;
    int32_t l_70 = 0xDC630DE2L;
    int32_t *l_69 = &l_70;
    int32_t l_221 = 0xB14FC1BAL;
    int32_t **l_252 = &l_69;
    (*l_252) = func_42(((uint16_t)func_49(((((uint16_t)((*p_40) > (-1L)) % (uint16_t)(((uint16_t)0x3BE4L + (uint16_t)(__builtin_popcountll(l_57) <= (!(((int32_t)l_57 + (int32_t)((l_57 | func_61(p_40, ((int16_t)(l_69 == (void*)0) << (int16_t)1), &l_70, p_41, p_40)) == l_57)) || (*l_69))))) || 4294967286UL)) && (*l_69)) != 5L), p_41, l_221) >> (uint16_t)p_41), p_40, l_221, &l_221);
    return (*p_40);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_42(uint32_t  p_43, int32_t * p_44, uint16_t  p_45, int32_t * p_46)
{ /* block id: 164 */
    int32_t l_251 = 0x70BE373BL;
    int32_t *l_250 = &l_251;
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_49(int32_t  p_50, int16_t  p_51, float  p_52)
{ /* block id: 153 */
    uint32_t l_222 = 0x107391EFL;
    int32_t l_224 = 0L;
    int32_t *l_223 = &l_224;
    (*l_223) = l_222;
    for (p_50 = 0; (p_50 > 1); p_50 += 1)
    { /* block id: 157 */
        float l_231 = 0x2.Fp-1;
        int32_t l_237 = (-1L);
        uint32_t l_242 = 0xA056DCA7L;
        int32_t **l_243 = &l_223;
        float *l_248 = (void*)0;
        float *l_249 = &l_231;
        (*l_223) = ((1L != ((uint32_t)((uint16_t)p_51 >> (uint16_t)(*l_223)) + (uint32_t)(*l_223))) != (((-(int32_t)0x5C0E4766L) | ((int16_t)((uint16_t)p_51 % (uint16_t)6L) >> (int16_t)l_237)) || (*l_223)));
        (*l_243) = func_89(&l_237, ((uint32_t)0UL - (uint32_t)((uint32_t)(*l_223) % (uint32_t)l_242)), &l_237, l_243, (**l_243));
        (*l_249) = ((float)(func_83((*l_243), (*l_243), ((int32_t)(p_51 < func_83(&l_224, &l_224, p_50, (*l_223), &p_50)) % (int32_t)4294967295UL), (**l_243), (*l_243)) != (-0x7.Bp+1)) - (float)0x0.6p-1);
        (*l_249) = (0x7.5p+1 == 0x0.0p+1);
    }
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads : l_36
 * writes:
 */
static int32_t  func_61(int32_t * p_62, int32_t  p_63, int32_t * p_64, uint32_t  p_65, int32_t * p_66)
{ /* block id: 38 */
    int32_t l_95 = 0L;
    int32_t *l_96 = (void*)0;
    float l_148 = 0x1.1p+1;
    int32_t ***l_218 = (void*)0;
    int32_t **l_220 = &l_96;
    int32_t ***l_219 = &l_220;
    (*l_219) = func_71(func_77(p_66, (func_83(p_66, func_89(p_64, l_95, l_96, &l_96, l_95), ((((int16_t)p_65 - (int16_t)p_65) >= 4294967295UL) & 0x0C92L), l_95, p_66) < l_95), p_64, l_96, p_65), p_62, p_65, l_96, &l_96);
    return (*p_62);
}


/* ------------------------------------------ */
/* 
 * reads : l_36
 * writes:
 */
inline static int32_t ** func_71(int32_t * p_72, int32_t * p_73, uint16_t  p_74, int32_t * p_75, int32_t ** p_76)
{ /* block id: 96 */
    int32_t l_162 = 1L;
    int32_t *l_161 = &l_162;
    int32_t **l_184 = &l_161;
    int32_t **l_188 = (void*)0;
    int32_t **l_201 = &l_161;
    int32_t **l_202 = (void*)0;
    int32_t *l_211 = (void*)0;
    int32_t *l_212 = &l_162;
    int32_t **l_213 = &l_211;
    int32_t **l_214 = &l_211;
    int32_t **l_215 = &l_161;
    int32_t **l_216 = &l_211;
    int32_t **l_217 = (void*)0;
    l_161 = l_161;
    if ((*l_161))
    { /* block id: 98 */
        (*l_161) = ((uint16_t)(p_74 != (-5L)) << (uint16_t)((*p_73) | (*p_73)));
    }
    else
    { /* block id: 100 */
        int16_t l_165 = 0xAF9CL;
        int16_t l_167 = 0L;
        int32_t *l_195 = &l_162;
        if (l_165)
        { /* block id: 101 */
            int32_t *l_166 = &l_162;
            (*p_76) = (*p_76);
            (*p_76) = l_166;
        }
        else
        { /* block id: 104 */
            int16_t l_171 = 0x2609L;
            int32_t **l_187 = &l_161;
            if ((((l_167 | (__builtin_clzll((p_74 | (*l_161))) || (__builtin_bswap32((!(p_74 < (((uint32_t)(((&p_76 != &p_76) < (*l_161)) > __builtin_popcountl((*l_161))) + (uint32_t)p_74) <= 0xE5B6L)))) || p_74))) || l_171) >= l_167))
            { /* block id: 105 */
                int16_t l_179 = 0xF3C5L;
                float l_181 = 0x8.8p+1;
                float *l_180 = &l_181;
                for (l_165 = 0; (l_165 >= (-21)); l_165 -= 1)
                { /* block id: 108 */
                    int32_t l_174 = 4L;
                    (*l_161) = ((__builtin_ia32_crc32qi(l_171, l_174) >= (p_74 != (*l_161))) > __builtin_ctzll(((int16_t)p_74 + (int16_t)(l_174 < ((uint16_t)(l_179 > (__builtin_popcountl(p_74) == l_174)) << (uint16_t)7)))));
                }
                (*l_180) = l_171;
            }
            else
            { /* block id: 112 */
                int32_t **l_186 = &l_161;
                float l_194 = 0x8.5C2003p+33;
                float *l_193 = &l_194;
                (*l_161) = l_171;
                for (p_74 = 0; (p_74 <= 10); p_74 += 1)
                { /* block id: 116 */
                    int32_t **l_185 = &l_161;
                    return l_188;
                }
                (**l_187) = (0xC.DEF21Ep+93 != (__builtin_popcountl(p_74) <= (p_74 >= ((**l_187) != ((float)p_74 + (float)((float)(p_74 > p_74) - (float)0xD.22DCD2p+64))))));
                (*l_193) = (-0x9.0p+1);
            }
            l_195 = (*p_76);
            for (l_162 = 0; (l_162 < (-18)); l_162 -= 1)
            { /* block id: 125 */
                if ((**l_187))
                    break;
                for (l_165 = 0; (l_165 < 28); l_165 += 3)
                { /* block id: 129 */
                    int32_t **l_200 = &l_161;
                    return l_202;
                }
            }
            (**l_201) = ((!65535UL) & (p_74 > 65526UL));
        }
        (*p_76) = (*l_201);
    }
    if ((*p_73))
    { /* block id: 137 */
        int32_t **l_204 = &l_161;
        int32_t **l_205 = (void*)0;
        return l_205;
    }
    else
    { /* block id: 139 */
        uint16_t l_208 = 65535UL;
        for (p_74 = 0; (p_74 >= 47); p_74 += 8)
        { /* block id: 142 */
            float l_210 = 0x0.4p+1;
            float *l_209 = &l_210;
            (*l_209) = (__builtin_ia32_crc32qi(l_208, l_208) >= (**l_201));
            (*l_209) = ((*p_76) == (void*)0);
            (*l_209) = l_208;
        }
        (*l_184) = (*p_76);
    }
    (*l_212) = (*p_73);
    return l_217;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_77(int32_t * p_78, uint32_t  p_79, int32_t * p_80, int32_t * p_81, int32_t  p_82)
{ /* block id: 85 */
    int32_t l_155 = (-6L);
    int32_t *l_154 = &l_155;
    int32_t *l_156 = &l_155;
    int32_t *l_160 = &l_155;
    if (func_83(l_154, l_156, __builtin_ctz((*l_156)), (*l_156), p_80))
    { /* block id: 86 */
        for (l_155 = 17; (l_155 <= 13); l_155 -= 1)
        { /* block id: 89 */
            return p_80;
        }
    }
    else
    { /* block id: 92 */
        int32_t *l_159 = &l_155;
        return p_81;
    }
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_83(int32_t * p_84, int32_t * p_85, int32_t  p_86, int32_t  p_87, int32_t * p_88)
{ /* block id: 81 */
    int32_t *l_149 = (void*)0;
    int32_t **l_150 = &l_149;
    int32_t **l_151 = (void*)0;
    (*l_150) = l_149;
    (*l_150) = (*l_150);
    return p_86;
}


/* ------------------------------------------ */
/* 
 * reads : l_70
 * writes: l_70
 */
static int32_t * func_89(int32_t * p_90, int32_t  p_91, int32_t * p_92, int32_t ** p_93, uint32_t  p_94)
{ /* block id: 39 */
    int32_t l_100 = 1L;
    int32_t *l_99 = &l_100;
    int32_t **l_98 = &l_99;
    int32_t ***l_97 = &l_98;
    int32_t *l_112 = &l_100;
    float l_144 = 0xD.9FCC30p+60;
    float *l_143 = &l_144;
    float **l_142 = &l_143;
    (*l_97) = &p_92;
    for (p_91 = 21; (p_91 > (-14)); p_91 -= 6)
    { /* block id: 43 */
        if ((*l_99))
            break;
    }
    for (p_94 = 0; (p_94 != 5); p_94 += 1)
    { /* block id: 48 */
        int32_t l_109 = 0xB9AA6B35L;
        (*l_99) = ((int16_t)((uint16_t)__builtin_popcount((*l_99)) >> (uint16_t)0) - (int16_t)65535UL);
        if (l_109)
            continue;
        (*p_90) = (*p_90);
        for (l_109 = 28; (l_109 != (-8)); l_109 -= 1)
        { /* block id: 54 */
            uint32_t l_113 = 0xA7CF5EE2L;
            int32_t *l_140 = &l_100;
            (**l_97) = l_112;
            if (((l_109 & l_113) > l_113))
            { /* block id: 56 */
                float l_120 = 0xD.06D3C1p-30;
                float *l_119 = &l_120;
                (*l_119) = ((&p_93 != (void*)0) > ((((float)__builtin_popcountll((l_109 && ((void*)0 != &p_93))) + (float)(-(float)0x4.62DE1Bp-45)) < ((float)(p_94 < (p_91 < p_94)) - (float)0x0.Bp+1)) > p_91));
            }
            else
            { /* block id: 58 */
                uint32_t l_123 = 0x864CC439L;
                int32_t **l_141 = &l_140;
                float ***l_145 = &l_142;
                (*l_99) = l_109;
                for (l_113 = 0; (l_113 > 4); l_113 += 1)
                { /* block id: 62 */
                    float l_125 = 0x0.2p+1;
                    float *l_124 = &l_125;
                    (*l_124) = (l_123 == p_91);
                }
                (*l_145) = l_142;
            }
        }
    }
    return (*p_93);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 91
XXX total union variables: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 111
   depth: 2, occurrence: 22
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 19, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 97

XXX times a variable address is taken: 86
XXX times a pointer is dereferenced on RHS: 63
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 52
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 274

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 173
   level: 2, occurrence: 37
   level: 3, occurrence: 8
XXX number of pointers point to pointers: 33
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 35.1
XXX average alias set size: 1.34

XXX times a non-volatile is read: 352
XXX times a non-volatile is write: 137
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 101
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 22
   depth: 2, occurrence: 16
   depth: 3, occurrence: 16
   depth: 4, occurrence: 10
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 11.7
XXX percentage an existing variable is used: 88.3
********************* end of statistics **********************/

