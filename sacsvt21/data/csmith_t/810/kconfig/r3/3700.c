/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --safe-math --packed-struct --paranoid --no-pointers --structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      189140368
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   volatile int32_t  f0;
   volatile int16_t  f1;
   uint16_t  f2;
   volatile uint16_t  f3;
   int32_t  f4;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_25[6] = {(-1),1,(-1),(-1),1,(-1)};
static volatile uint32_t g_31 = 0xA7209C39;/* VOLATILE GLOBAL g_31 */
static float g_32 = 0x3.C4DF8Ep-30;
static float g_35 = (-0x9.5p+1);
static int32_t g_37 = 0x835A7AB5;
static int32_t g_51 = 1;
static uint16_t g_52[9] = {0xC19C,0xC19C,0xC19C,0xC19C,0xC19C,0xC19C,0xC19C,0xC19C,0xC19C};
static int32_t g_55[3] = {1,1,1};
static int16_t g_61 = 0x14D8;
static struct S0 g_62[6][6][1] = {{{{-5,-5,0xA4EE,0xB4BC,0x7302220C}},{{7,1,65526U,0xC677,0xCB2DC507}},{{0x408375F0,0xA7CF,1U,0xCBD0,0}},{{7,1,65526U,0xC677,0xCB2DC507}},{{-5,-5,0xA4EE,0xB4BC,0x7302220C}},{{-1,-1,0U,0x3AC4,0x406CCCE4}}},{{{-1,-1,0U,0x3AC4,0x406CCCE4}},{{-5,-5,0xA4EE,0xB4BC,0x7302220C}},{{7,1,65526U,0xC677,0xCB2DC507}},{{0x408375F0,0xA7CF,1U,0xCBD0,0}},{{7,1,65526U,0xC677,0xCB2DC507}},{{-5,-5,0xA4EE,0xB4BC,0x7302220C}}},{{{-1,-1,0U,0x3AC4,0x406CCCE4}},{{-1,-1,0U,0x3AC4,0x406CCCE4}},{{-5,-5,0xA4EE,0xB4BC,0x7302220C}},{{7,1,65526U,0xC677,0xCB2DC507}},{{0x408375F0,0xA7CF,1U,0xCBD0,0}},{{7,1,65526U,0xC677,0xCB2DC507}}},{{{-5,-5,0xA4EE,0xB4BC,0x7302220C}},{{-1,-1,0U,0x3AC4,0x406CCCE4}},{{-1,-1,0U,0x3AC4,0x406CCCE4}},{{-5,-5,0xA4EE,0xB4BC,0x7302220C}},{{7,1,65526U,0xC677,0xCB2DC507}},{{0x408375F0,0xA7CF,1U,0xCBD0,0}}},{{{7,1,65526U,0xC677,0xCB2DC507}},{{-5,-5,0xA4EE,0xB4BC,0x7302220C}},{{-1,-1,0U,0x3AC4,0x406CCCE4}},{{-1,-1,0U,0x3AC4,0x406CCCE4}},{{0x408375F0,0xA7CF,1U,0xCBD0,0}},{{-5,-5,0xA4EE,0xB4BC,0x7302220C}}},{{{0x715B7D07,-4,65532U,0xE7EB,0}},{{-5,-5,0xA4EE,0xB4BC,0x7302220C}},{{0x408375F0,0xA7CF,1U,0xCBD0,0}},{{1,0x92BB,0x6079,0U,0x9DD5AE90}},{{1,0x92BB,0x6079,0U,0x9DD5AE90}},{{0x408375F0,0xA7CF,1U,0xCBD0,0}}}};


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
inline static struct S0  func_38(int16_t  p_39, int32_t  p_40, int32_t  p_41, int32_t  p_42);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_31 g_37 g_25 g_55 g_62
 * writes: g_31 g_37 g_51 g_52 g_55 g_61 g_62
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_33[7] = {(-3),(-3),(-3),(-3),(-3),(-3),(-3)};
    int32_t l_34 = 0xB9628EAF;
    int32_t l_36 = 0xD258D033;
    float l_56 = (-0x1.1p+1);
    int32_t l_57 = 0x47399D01;
    int i;
    g_31 ^= 0xF18C9A01;
    l_33[2] = (-9);
    g_37 = (l_36 &= ((l_33[4] < g_31) > l_34));
    g_62[5][5][0] = func_38((safe_div_func_int32_t_s_s((safe_mod_func_uint32_t_u_u(__builtin_ffsl(g_37), (safe_rshift_func_int16_t_s_u((g_52[4] = (g_51 = ((l_36 = 3U) ^ ((safe_lshift_func_int16_t_s_s(0x8D1D, 13)) > 0xFE96)))), (g_25[1] <= 0xA7DA828C))))), (safe_add_func_uint32_t_u_u(__builtin_parityll(__builtin_clzl((g_55[0] &= (l_33[1] ^ 8U)))), g_37)))), l_57, g_37, l_33[4]);
    return g_55[2];
}


/* ------------------------------------------ */
/* 
 * reads : g_62
 * writes: g_61
 */
inline static struct S0  func_38(int16_t  p_39, int32_t  p_40, int32_t  p_41, int32_t  p_42)
{ /* block id: 45 */
    uint32_t l_60[2][5][8] = {{{0x45F0A862,0xE5AB8BF5,0x674B172A,3U,0xC2878486,0U,0U,0xC2878486},{0x45F0A862,0x283564F6,0x283564F6,0x45F0A862,0U,3U,0x104E0BBE,0x06D673C0},{0x38CF49CF,1U,3U,0x6F6EC374,0x283564F6,0x290900DD,0x06D673C0,0x290900DD},{0U,1U,0x104E0BBE,1U,0U,3U,0x45F0A862,1U},{3U,0x283564F6,0U,0U,0x449BABE4,0U,1U,1U}},{{0x06D673C0,0xE5AB8BF5,0U,0U,0xE5AB8BF5,0x06D673C0,0x45F0A862,0x449BABE4},{0x449BABE4,0x290900DD,0x104E0BBE,1U,1U,0U,0x06D673C0,3U},{0x104E0BBE,0x38CF49CF,3U,1U,3U,0x38CF49CF,0x104E0BBE,0x449BABE4},{0xE5AB8BF5,3U,0x283564F6,0U,0U,0x449BABE4,0U,1U},{1U,0x6F6EC374,0x674B172A,0U,0U,0x674B172A,0x6F6EC374,1U}}};
    int i, j, k;
    for (p_39 = 0; (p_39 >= 9); p_39 = safe_add_func_int32_t_s_s(p_39, 5))
    { /* block id: 48 */
        g_61 = (p_42 &= (l_60[1][3][7] | 65535U));
    }
    return g_62[1][4][0];
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    for (i = 0; i < 6; i++)
    {
        transparent_crc(g_25[i], "g_25[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_31, "g_31", print_hash_value);
    transparent_crc_bytes (&g_32, sizeof(g_32), "g_32", print_hash_value);
    transparent_crc_bytes (&g_35, sizeof(g_35), "g_35", print_hash_value);
    transparent_crc(g_37, "g_37", print_hash_value);
    transparent_crc(g_51, "g_51", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        transparent_crc(g_52[i], "g_52[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 3; i++)
    {
        transparent_crc(g_55[i], "g_55[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_61, "g_61", print_hash_value);
    for (i = 0; i < 6; i++)
    {
        for (j = 0; j < 6; j++)
        {
            for (k = 0; k < 1; k++)
            {
                transparent_crc(g_62[i][j][k].f0, "g_62[i][j][k].f0", print_hash_value);
                transparent_crc(g_62[i][j][k].f1, "g_62[i][j][k].f1", print_hash_value);
                transparent_crc(g_62[i][j][k].f2, "g_62[i][j][k].f2", print_hash_value);
                transparent_crc(g_62[i][j][k].f3, "g_62[i][j][k].f3", print_hash_value);
                transparent_crc(g_62[i][j][k].f4, "g_62[i][j][k].f4", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 9
   depth: 2, occurrence: 1
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 21, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 31
XXX times a non-volatile is write: 11
XXX times a volatile is read: 1
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 11
XXX percentage of non-volatile access: 95.5

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 8
XXX max block depth: 1
breakdown:
   depth: 0, occurrence: 7
   depth: 1, occurrence: 1

XXX percentage a fresh-made variable is used: 53.2
XXX percentage an existing variable is used: 46.8
********************* end of statistics **********************/

