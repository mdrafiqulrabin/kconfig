/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1713200056
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_32(void);
static const uint64_t  func_39(int32_t * p_40);
static int32_t * func_43(int32_t ** p_44, int32_t  p_45, int32_t ** p_46, uint16_t  p_47, int32_t * p_48);
inline static int32_t ** func_49(uint8_t  p_50, int16_t  p_51, const uint32_t  p_52, uint8_t  p_53, const int32_t * const * p_54);
inline static int16_t  func_61(uint32_t  p_62, const uint32_t  p_63, float  p_64, int32_t ** p_65, int64_t  p_66);
inline static uint32_t  func_67(int32_t  p_68, const int32_t  p_69, uint16_t  p_70, int32_t  p_71);
inline static float ** func_83(int32_t  p_84);
static uint64_t  func_87(int32_t * p_88, int32_t  p_89, uint8_t  p_90, const int32_t  p_91);
inline static float  func_95(uint32_t  p_96, uint16_t  p_97);
inline static int32_t * const  func_100(int16_t  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_32(void)
{ /* block id: 36 */
    int32_t l_35 = 0xF9C77509L;
    int32_t l_323 = 0xCC735A51L;
    int32_t *l_322 = &l_323;
    const float ***l_336 = (void*)0;
    const float ****l_335 = &l_336;
    const float *****l_334 = &l_335;
    int32_t **l_363 = &l_322;
    int32_t l_389 = 0x70C8BC80L;
    if (__builtin_clz(((int64_t)l_35 % (int64_t)l_35)))
    { /* block id: 37 */
        int32_t l_37 = 0x6C1DFE93L;
        int32_t *l_36 = &l_37;
        int32_t **l_38 = &l_36;
        (*l_38) = l_36;
        return l_35;
    }
    else
    { /* block id: 40 */
        int32_t l_42 = 0x466AC3A6L;
        int32_t *l_41 = &l_42;
        float l_328 = 0x1.3p-1;
        float * const l_327 = &l_328;
        if (__builtin_clzll((func_39(l_41) & (*l_41))))
        { /* block id: 172 */
            int32_t *l_324 = &l_323;
            int32_t **l_329 = &l_324;
            uint32_t l_360 = 0x39479D91L;
lbl_361:
            l_324 = l_322;
            /* statement id: 173 */
            assert (l_324 == &l_323);
            (*l_329) = func_100(((int16_t)(*l_324) << (int16_t)(((((void*)0 != l_327) < (*l_322)) ^ (*l_322)) >= (0x95C0E044L & (*l_41)))));
            /* statement id: 174 */
            assert (l_324 == 0);
            if ((((int16_t)(*l_322) << (int16_t)((uint16_t)((void*)0 == l_334) << (uint16_t)2)) >= (l_322 == (void*)0)))
            { /* block id: 175 */
                int32_t l_339 = 0xEBB8F754L;
                float *l_348 = &l_328;
                float ** const l_347 = &l_348;
                const uint16_t l_358 = 65535UL;
                if (((*l_322) || ((int16_t)__builtin_parityl(l_339) + (int16_t)l_339)))
                { /* block id: 176 */
                    int32_t l_344 = 0xDCF8AAB9L;
                    uint16_t l_351 = 0x16EFL;
                    (*l_327) = ((((float)((float)(l_344 > __builtin_ffs((l_339 <= ((uint16_t)((void*)0 == l_347) - (uint16_t)l_344)))) + (float)0x5.83735Ap+79) + (float)(*l_322)) < (*l_322)) < 0xB.AABC08p-68);
                    for (l_344 = 0; (l_344 > 1); l_344++)
                    { /* block id: 180 */
                        return l_351;
                    }
                }
                else
                { /* block id: 183 */
                    float l_356 = 0x0.7EC65Ep+77;
                    int32_t l_357 = 0x14738234L;
                    int32_t **l_359 = &l_324;
                    (*l_327) = ((((float)(l_358 <= 0x4.DDF7B9p+85) + (float)0x7.E1E5C5p-84) <= 0x9.DE6AF5p-45) >= 0x1.0p+1);
                }
                (*l_41) = (-1L);
                (*l_41) = l_339;
            }
            else
            { /* block id: 188 */
                if (l_35)
                    goto lbl_361;
            }
            (*l_329) = &l_323;
            /* statement id: 191 */
            assert (l_324 == &l_323);
        }
        else
        { /* block id: 192 */
            const int32_t *l_362 = (void*)0;
            (*l_322) = (l_362 != (void*)0);
        }
        (*l_322) = (65529UL < (*l_41));
    }
    (*l_322) = (*l_322);
    (*l_363) = &l_323;
    for (l_323 = 0; (l_323 >= (-9)); l_323 -= 3)
    { /* block id: 201 */
        int64_t l_371 = 0x0B62747BD279F683LL;
        const float ** const **l_379 = (void*)0;
        const float ** const ***l_378 = &l_379;
        uint8_t l_384 = 249UL;
        int32_t l_386 = 1L;
        int32_t *l_385 = &l_386;
        float l_388 = 0x1.3p-1;
        float *l_387 = &l_388;
        (*l_385) = func_67(__builtin_parityll(((int16_t)(-(int64_t)((int32_t)l_371 - (int32_t)((uint16_t)l_371 >> (uint16_t)0))) << (int16_t)((uint32_t)l_371 - (uint32_t)((**l_363) == ((uint16_t)((void*)0 != l_378) / (uint16_t)(**l_363)))))), ((uint64_t)(((int16_t)0L / (int16_t)(-10L)) || l_371) + (uint64_t)l_384), l_371, l_371);
        if ((*l_385))
            break;
        (*l_387) = (**l_363);
    }
    return l_389;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint64_t  func_39(int32_t * p_40)
{ /* block id: 41 */
    uint32_t l_72 = 0UL;
    int32_t l_74 = 0x53A21B78L;
    int32_t *l_73 = &l_74;
    int16_t l_277 = 1L;
    const int32_t * const l_279 = (void*)0;
    const int32_t * const *l_278 = &l_279;
    int32_t l_306 = (-1L);
    int32_t *l_305 = &l_306;
    int32_t **l_304 = &l_305;
    const uint8_t l_321 = 0UL;
    p_40 = func_43(func_49(((((int64_t)((uint16_t)(7L >= (((int16_t)func_61(func_67(l_72, l_72, (l_73 != &l_74), (*l_73)), (*l_73), (*l_73), &l_73, (*l_73)) << (int16_t)l_72) ^ l_72)) >> (uint16_t)l_72) - (int64_t)l_72) && 1L) != l_277), l_277, l_277, l_277, l_278), l_72, l_304, (*l_305), p_40);
    /* statement id: 170 */
    assert (p_40 == &l_306);
    return l_321;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_43(int32_t ** p_44, int32_t  p_45, int32_t ** p_46, uint16_t  p_47, int32_t * p_48)
{ /* block id: 165 */
    int32_t l_308 = 0x3D723124L;
    int32_t * const l_307 = &l_308;
    int32_t **l_309 = (void*)0;
    int32_t **l_310 = (void*)0;
    int32_t *l_312 = &l_308;
    int32_t **l_311 = &l_312;
    float l_319 = 0x0.6p+1;
    float *l_318 = &l_319;
    float **l_317 = &l_318;
    int32_t **l_320 = &l_312;
    (*l_311) = l_307;
    (*l_307) = ((int16_t)((uint16_t)(l_317 == &l_318) - (uint16_t)p_47) >> (int16_t)13);
    (*l_320) = func_100(p_45);
    /* statement id: 168 */
    assert (l_312 == 0);
    return (*p_46);
    /* statement id: 169 */
    //assert (func_43_rv == &l_306);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_49(uint8_t  p_50, int16_t  p_51, const uint32_t  p_52, uint8_t  p_53, const int32_t * const * p_54)
{ /* block id: 155 */
    float l_280 = 0x0.6p-1;
    int32_t l_281 = 0x983243EDL;
    float ** const *l_282 = (void*)0;
    float *l_286 = &l_280;
    float **l_285 = &l_286;
    float ***l_284 = &l_285;
    float ****l_283 = &l_284;
    int32_t *l_290 = &l_281;
    int32_t **l_289 = &l_290;
    int32_t **l_291 = &l_290;
    int32_t **l_292 = &l_290;
    int32_t **l_293 = &l_290;
    int32_t **l_294 = &l_290;
    int32_t **l_295 = &l_290;
    int32_t **l_296 = &l_290;
    int32_t **l_297 = &l_290;
    int32_t **l_298 = &l_290;
    int32_t **l_299 = &l_290;
    int32_t **l_300 = &l_290;
    int32_t **l_301 = &l_290;
    int32_t **l_302 = &l_290;
    int32_t **l_303 = (void*)0;
    l_281 = l_280;
    (*l_283) = l_282;
    /* statement id: 157 */
    assert (l_284 == 0);
    for (l_281 = 0; (l_281 <= (-2)); l_281--)
    { /* block id: 160 */
        if (l_281)
            break;
    }
    (**l_285) = l_281;
    return l_303;
    /* statement id: 164 */
    //assert (func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_61(uint32_t  p_62, const uint32_t  p_63, float  p_64, int32_t ** p_65, int64_t  p_66)
{ /* block id: 101 */
    int32_t *l_165 = (void*)0;
    int32_t l_166 = (-1L);
    uint16_t l_167 = 0xCB97L;
    const int32_t l_185 = (-1L);
    const float l_186 = 0xB.97979Dp-5;
    float l_188 = 0x8.53E36Ep-55;
    float *l_187 = &l_188;
    float **l_236 = &l_187;
    float ***l_235 = &l_236;
    float ****l_234 = &l_235;
    int32_t l_276 = 0x24882324L;
    (**p_65) = (0x2BC5L && (((((int64_t)func_87((*p_65), __builtin_bswap64(p_63), ((uint32_t)((int16_t)(0xB907L >= ((l_165 == l_165) == func_87((*p_65), p_66, l_166, l_166))) - (int16_t)4L) + (uint32_t)p_63), p_66) / (int64_t)l_167) <= p_62) == p_62) && l_167));
lbl_191:
    (*l_187) = (((float)func_95(l_166, ((uint64_t)p_62 - (uint64_t)((p_66 || (((((uint64_t)(65532UL > 65535UL) - (uint64_t)((((uint32_t)(((uint64_t)((uint16_t)(p_62 < p_63) >> (uint16_t)((int64_t)((__builtin_popcount(((uint16_t)(!0L) >> (uint16_t)6)) < l_167) > 0x0B25D924L) - (int64_t)p_62)) + (uint64_t)l_185) != p_62) + (uint32_t)p_62) && p_62) <= p_62)) != p_66) > (**p_65)) && p_63)) & p_66))) + (float)p_66) == 0x6.7CBFDDp+15);
    for (l_167 = 0; (l_167 != 8); l_167 += 8)
    { /* block id: 106 */
        int32_t l_195 = 0xE7FF6F2DL;
        if (p_66)
            goto lbl_191;
        (*l_187) = (p_63 != (__builtin_popcountll((~((int16_t)((((**p_65) ^ (-5L)) >= (__builtin_clzll(l_195) >= (p_66 & (func_87(&l_195, p_63, (0xA4DFBEF9L >= 4294967292UL), l_195) == p_66)))) < p_66) / (int16_t)l_195))) < p_66));
        (*l_187) = ((float)l_185 + (float)(+((((float)(p_64 > ((float)(0x0.6p+1 <= (p_66 < (((p_64 != l_195) > ((!(p_62 == ((((((void*)0 != &l_185) == p_66) > p_62) > l_195) <= (-0x1.4p+1)))) < 0x4.B1FDE0p-0)) <= (-0x1.Bp+1)))) + (float)(-0x1.6p+1))) + (float)l_195) == 0x1.0p+1) > p_63)));
    }
    for (p_66 = 0; (p_66 > 1); ++p_66)
    { /* block id: 113 */
        uint8_t l_206 = 0x34L;
        int32_t **l_232 = &l_165;
        float *****l_239 = &l_234;
        uint8_t l_272 = 252UL;
        if ((l_206 <= (l_206 >= ((uint16_t)65529UL + (uint16_t)((uint32_t)l_206 - (uint32_t)(!l_206))))))
        { /* block id: 114 */
            uint32_t l_240 = 4294967293UL;
            float **l_261 = &l_187;
            int32_t **l_262 = (void*)0;
            const int32_t *l_263 = &l_166;
            for (l_166 = 0; (l_166 == 18); l_166 += 4)
            { /* block id: 117 */
                float l_223 = 0x6.D57942p-2;
                int32_t l_226 = 0xC0632B81L;
                uint32_t l_233 = 0UL;
                int32_t l_258 = 0x23137507L;
                for (l_167 = 0; (l_167 != 34); l_167++)
                { /* block id: 120 */
                    for (l_206 = 22; (l_206 > 26); ++l_206)
                    { /* block id: 123 */
                        int32_t **l_218 = &l_165;
                        (*l_218) = func_100(p_66);
                        /* statement id: 124 */
                        assert (l_165 == 0);
                    }
                }
                (*p_65) = (*p_65);
                if (((int16_t)0x9247L + (int16_t)(__builtin_ffs(((uint32_t)(l_206 == ((uint64_t)l_206 / (uint64_t)p_62)) % (uint32_t)l_226)) & ((-(int64_t)((int16_t)__builtin_ia32_crc32qi(p_62, ((int32_t)l_206 / (int32_t)((l_232 != (void*)0) && l_233))) - (int16_t)p_66)) > 0xD885D17DL))))
                { /* block id: 128 */
                    float *****l_237 = &l_234;
                    int32_t l_238 = 0x61988898L;
                    (*l_237) = l_234;
                    (**p_65) = (l_206 && l_238);
                }
                else
                { /* block id: 131 */
                    l_239 = &l_234;
                }
                if (l_240)
                { /* block id: 134 */
                    (*l_232) = (*p_65);
                    /* statement id: 135 */
                    //assert (l_165 == &l_74);
                }
                else
                { /* block id: 136 */
                    int32_t **l_257 = &l_165;
                    (*l_232) = &l_226;
                    /* statement id: 137 */
                    assert (l_165 == &l_226);
                    if (((func_67((*l_165), __builtin_bswap32((l_233 ^ (((int16_t)(-8L) << (int16_t)((((int16_t)p_63 - (int16_t)((~p_63) < (-1L))) && ((int32_t)(0xF264C02D86D1A421LL < 0xF78E13ECE3592EE3LL) / (int32_t)((int64_t)(-(uint64_t)l_226) + (int64_t)p_63))) | (**l_232))) == l_233))), l_240, p_63) == 1UL) && (-8L)))
                    { /* block id: 138 */
                        uint32_t l_259 = 0x62AC07F3L;
                        int32_t **l_260 = &l_165;
                        (*l_260) = func_100(((uint16_t)(((uint16_t)((0x6B0DL < (l_257 != p_65)) > (0xB3BD2D33L | ((void*)0 == &l_165))) >> (uint16_t)((**p_65) | (p_63 < 0xDF83237CEF4F5830LL))) <= l_258) / (uint16_t)l_259));
                        /* statement id: 139 */
                        assert (l_165 == 0);
                        (**p_65) = (l_261 != (***l_239));
                    }
                    else
                    { /* block id: 141 */
                        if ((**l_232))
                            break;
                        //assert (l_165 == dangling);
                    }
                    /* facts after branching */
                    assert (l_165 == &l_226 || l_165 == 0);
                }
                /* facts after branching */
                //assert (l_165 == &l_226 || l_165 == 0 || l_165 == &l_74);
            }
            l_263 = &l_185;
            /* statement id: 146 */
            assert (l_263 == &l_185);
        }
        else
        { /* block id: 147 */
            int32_t **l_273 = (void*)0;
            int32_t **l_274 = (void*)0;
            int32_t **l_275 = &l_165;
            (*****l_239) = (((((float)((-0x6.2p+1) != p_64) / (float)0x5.F5F8C2p+97) != (__builtin_ctz(((uint32_t)__builtin_popcountll(((uint64_t)p_66 + (uint64_t)18446744073709551615UL)) / (uint32_t)p_66)) < (((float)(p_64 <= p_63) + (float)p_63) == 0x8.8p-1))) >= l_272) <= p_63);
            (*l_275) = func_100(p_66);
            /* statement id: 149 */
            assert (l_165 == 0);
            (*l_232) = (*p_65);
            /* statement id: 150 */
            //assert (l_165 == &l_74);
            (*p_65) = (*p_65);
        }
    }
    /* facts after for loop */
    //assert (l_165 == dangling || l_165 == 0 || l_165 == &l_74);
    return l_276;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_67(int32_t  p_68, const int32_t  p_69, uint16_t  p_70, int32_t  p_71)
{ /* block id: 42 */
    int32_t l_93 = 1L;
    int32_t *l_92 = &l_93;
    float l_156 = (-0x1.Ep+1);
    float *l_155 = &l_156;
    float **l_154 = &l_155;
    float *** const l_153 = &l_154;
    float *** const *l_152 = &l_153;
    int32_t **l_157 = &l_92;
    for (p_68 = 21; (p_68 > (-24)); p_68 -= 5)
    { /* block id: 45 */
        int32_t l_80 = 0x15BFEB1EL;
        int32_t *l_79 = &l_80;
        float l_82 = (-0x1.Cp-1);
        float *l_81 = &l_82;
        float l_94 = (-0x4.7p+1);
        float **l_151 = &l_81;
        float ***l_150 = &l_151;
        (*l_81) = ((float)p_68 / (float)((void*)0 == l_79));
        if (p_68)
            goto lbl_158;
        (*l_150) = func_83(((uint32_t)__builtin_ctzll(func_87(l_92, p_71, p_69, (*l_79))) / (uint32_t)0xFEF28ED3L));
        /* statement id: 94 */
        assert (l_151 == 0);
    }
    l_152 = l_152;
lbl_158:
    (*l_157) = func_100((*l_92));
    /* statement id: 97 */
    assert (l_92 == 0);
    (*l_157) = (void*)0;
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float ** func_83(int32_t  p_84)
{ /* block id: 55 */
    int32_t **l_107 = (void*)0;
    int32_t l_110 = 1L;
    int32_t *l_109 = &l_110;
    int32_t **l_108 = &l_109;
    int32_t *l_115 = (void*)0;
    float **l_135 = (void*)0;
    int32_t *l_147 = &l_110;
    (*l_108) = &p_84;
    /* statement id: 56 */
    assert (l_109 == &p_84);
    for (p_84 = 0; (p_84 < (-4)); p_84 -= 5)
    { /* block id: 59 */
        uint64_t l_113 = 18446744073709551608UL;
        int32_t *l_114 = &l_110;
        l_113 = p_84;
        (*l_114) = (__builtin_clz((&p_84 != (void*)0)) | p_84);
        l_115 = &p_84;
        /* statement id: 62 */
        assert (l_115 == &p_84);
        if ((*l_114))
        { /* block id: 63 */
            uint8_t l_126 = 1UL;
            float l_134 = (-0x1.8p-1);
            float *l_133 = &l_134;
            float **l_132 = &l_133;
            for (l_113 = 29; (l_113 >= 46); l_113 += 1)
            { /* block id: 66 */
                int32_t l_138 = (-1L);
                uint8_t l_142 = 7UL;
                if (p_84)
                { /* block id: 67 */
                    const int32_t *l_118 = (void*)0;
                    int32_t **l_119 = &l_115;
                    int32_t l_120 = 1L;
                    int32_t **l_128 = &l_115;
                    float l_131 = 0x0.Fp+1;
                    float *l_130 = &l_131;
                    float **l_129 = &l_130;
                    (*l_119) = l_118;
                    /* statement id: 68 */
                    assert (l_115 == 0);
                    (*l_128) = func_100((l_120 | ((int32_t)((!((int32_t)p_84 - (int32_t)l_126)) >= p_84) / (int32_t)((!(**l_108)) ^ p_84))));
                    if ((*l_109))
                    { /* block id: 70 */
                        (*l_114) = (*l_109);
                        return l_135;
                        /* statement id: 72 */
                        //assert (func_83_rv == 0);
                    }
                    else
                    { /* block id: 73 */
                        uint64_t l_136 = 0x2E2EE0BD24A17051LL;
                        l_136 = p_84;
                        return l_135;
                        /* statement id: 75 */
                        //assert (func_83_rv == 0);
                    }
                }
                else
                { /* block id: 77 */
                    uint64_t l_137 = 0x84E3EED797CFCBFALL;
                    int32_t **l_139 = &l_109;
                    l_137 = p_84;
                    (**l_132) = ((0xE.0087D4p+64 <= l_138) < ((((void*)0 == &p_84) < ((void*)0 != l_139)) > (((float)((*l_115) >= ((l_142 > (((float)((__builtin_popcountll(l_126) > 0x0.Bp-1) < (**l_139)) - (float)(*l_114)) == 0x1.Ap+1)) <= (**l_139))) / (float)l_126) < l_138)));
                }
                (*l_108) = &p_84;
            }
        }
        else
        { /* block id: 83 */
            float l_146 = 0x0.7p+1;
            float *l_145 = &l_146;
            (*l_145) = p_84;
        }
    }
    /* facts after for loop */
    assert (l_115 == &p_84 || l_115 == 0);
    (*l_108) = l_147;
    /* statement id: 87 */
    assert (l_109 == &l_110);
    for (l_110 = 0; (l_110 <= (-17)); --l_110)
    { /* block id: 90 */
        if (p_84)
            break;
    }
    return l_135;
    /* statement id: 93 */
    //assert (func_83_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_87(int32_t * p_88, int32_t  p_89, uint8_t  p_90, const int32_t  p_91)
{ /* block id: 47 */
    int32_t l_99 = 0L;
    int32_t *l_98 = &l_99;
    float l_105 = 0x1.2p+1;
    float *l_104 = &l_105;
    int16_t l_106 = 1L;
    (*l_104) = func_95(((void*)0 == l_98), (*l_98));
    return l_106;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_95(uint32_t  p_96, uint16_t  p_97)
{ /* block id: 48 */
    int32_t *l_103 = (void*)0;
    l_103 = func_100(p_97);
    return p_96;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_100(int16_t  p_101)
{ /* block id: 49 */
    int32_t * const l_102 = (void*)0;
    return l_102;
    /* statement id: 50 */
    //assert (func_100_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 102
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 116
   depth: 2, occurrence: 21
   depth: 3, occurrence: 2
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 109

XXX times a variable address is taken: 97
XXX times a pointer is dereferenced on RHS: 48
breakdown:
   depth: 1, occurrence: 36
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 48
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 5
   depth: 3, occurrence: 0
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 247

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 98
   level: 2, occurrence: 30
   level: 3, occurrence: 3
   level: 4, occurrence: 1
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 69
XXX number of pointers point to scalars: 40
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.8
XXX average alias set size: 1.13

XXX times a non-volatile is read: 366
XXX times a non-volatile is write: 128
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 103
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 20
   depth: 2, occurrence: 13
   depth: 3, occurrence: 10
   depth: 4, occurrence: 15
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 14.7
XXX percentage an existing variable is used: 85.3
********************* end of statistics **********************/

