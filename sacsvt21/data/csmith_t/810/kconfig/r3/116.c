/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3187357884
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_28(void);
inline static int16_t  func_36(int64_t  p_37, uint8_t  p_38, int16_t  p_39);
inline static uint64_t  func_42(uint16_t  p_43, uint32_t  p_44, int16_t  p_45, int64_t  p_46, int32_t  p_47);
static int16_t  func_50(float  p_51, uint16_t  p_52, int16_t  p_53, const uint32_t  p_54, const uint32_t  p_55);
inline static uint64_t  func_56(const int16_t  p_57, uint16_t  p_58, float  p_59);
inline static const int32_t * const  func_61(uint64_t  p_62, uint32_t  p_63, int32_t * p_64, int64_t  p_65, uint32_t  p_66);
static int32_t * func_81(uint32_t  p_82, int32_t * p_83, float  p_84, int32_t  p_85, float * p_86);
inline static int16_t  func_87(int32_t * p_88, int32_t * p_89, int16_t  p_90);
inline static int32_t * func_96(uint8_t  p_97);
static uint8_t  func_98(int32_t * p_99, const uint32_t  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_28(void)
{ /* block id: 36 */
    uint8_t l_29 = 0x65L;
    const uint32_t l_60 = 0xEC3E1B8DL;
    uint32_t l_200 = 1UL;
    int32_t l_244 = 0x6D3B482FL;
    float l_266 = 0x5.991E07p-90;
    float *l_265 = &l_266;
    int64_t l_288 = (-1L);
    int32_t *l_313 = &l_244;
    int32_t ** const l_312 = &l_313;
    float *l_323 = (void*)0;
    uint32_t l_335 = 0x7E966681L;
    uint16_t l_338 = 0x7EC6L;
    l_200 = ((l_29 || (~(((uint16_t)l_29 - (uint16_t)((!((uint32_t)(l_29 && func_36((((uint16_t)(func_42(((int16_t)func_50(((l_29 < l_29) == l_29), (__builtin_bswap32(l_29) < func_56(l_60, l_60, l_29)), l_60, l_29, l_29) >> (int16_t)6), l_60, l_60, l_29, l_29) >= l_60) >> (uint16_t)l_60) | l_60), l_60, l_60)) / (uint32_t)0xEEFF2A67L)) & l_29)) & 0x5947L))) >= (-4L));
    if (l_60)
    { /* block id: 96 */
        float l_204 = (-0x1.6p-1);
        float *l_203 = &l_204;
        const int32_t l_214 = 0L;
        float l_226 = 0x1.9p+1;
        uint8_t l_297 = 255UL;
        float *l_320 = &l_266;
        float *l_324 = &l_266;
        (*l_203) = ((float)(-0x10.Dp+1) + (float)l_29);
        (*l_203) = (l_29 < (0x6.CDC562p-68 == ((-(float)(((float)(((float)((float)((float)(l_214 > ((float)l_29 - (float)((float)(l_214 < ((float)l_60 / (float)(((float)l_200 + (float)(((float)l_29 / (float)(+l_226)) <= l_214)) >= 0x0.Dp+1))) + (float)l_200))) + (float)0x6.EB6654p+90) - (float)l_214) + (float)l_200) >= l_214) / (float)0x7.EA3A5Bp-63) == 0xB.8BB2A2p+48)) <= l_214)));
        if (l_29)
        { /* block id: 99 */
            int16_t l_229 = 0xA24AL;
            int32_t l_250 = (-1L);
            float *l_267 = &l_266;
            uint32_t l_298 = 0xF4A9CFADL;
lbl_232:
            (*l_203) = (-0x7.5p+1);
            if (((uint16_t)(l_229 && l_214) >> (uint16_t)13))
            { /* block id: 101 */
                uint16_t l_235 = 0UL;
                int16_t l_238 = 1L;
                int32_t *l_241 = (void*)0;
                int64_t l_246 = (-3L);
                for (l_229 = 2; (l_229 > 26); l_229 += 7)
                { /* block id: 104 */
                    if (l_60)
                        goto lbl_232;
                    if (l_229)
                        break;
                    (*l_203) = l_214;
                }
                if ((l_214 == ((l_229 > ((__builtin_clzll(((int16_t)(l_235 | l_29) - (int16_t)((int64_t)l_235 % (int64_t)l_229))) | (l_229 >= __builtin_bswap32(l_238))) ^ l_214)) & 1L)))
                { /* block id: 109 */
                    int32_t *l_239 = (void*)0;
                    int32_t **l_240 = &l_239;
                    (*l_240) = l_239;
                    (*l_203) = __builtin_parityl(l_229);
                }
                else
                { /* block id: 112 */
                    int32_t **l_242 = &l_241;
                    int32_t * const *l_243 = &l_241;
                    (*l_242) = l_241;
                    l_244 = (l_242 != l_243);
                    (*l_203) = func_42(((-(uint16_t)(l_246 >= l_229)) && l_29), l_229, l_214, ((uint16_t)(9L < l_229) >> (uint16_t)(+(0xDCADL <= 7UL))), l_214);
                }
                l_250 = (0xD.A6DD21p-14 != 0x7.E21D3Dp-93);
            }
            else
            { /* block id: 118 */
                int32_t *l_252 = &l_250;
                int32_t **l_251 = &l_252;
                uint64_t l_261 = 0xD50EB43A0534DAAFLL;
                uint32_t l_262 = 0x79A84713L;
                uint16_t l_287 = 1UL;
                int32_t *l_289 = &l_244;
                int32_t **l_290 = &l_289;
                (*l_251) = &l_244;
                /* statement id: 119 */
                assert (l_252 == &l_244);
                (**l_251) = ((0xCF2A4E10F472F1F1LL == func_42(l_214, ((*l_252) <= ((int16_t)((int16_t)((int16_t)(((*l_252) || (((uint16_t)(l_261 == (**l_251)) >> (uint16_t)14) && (l_262 > (func_98(func_81(l_214, func_96(((uint32_t)l_200 + (uint32_t)0x3FAFD5E7L)), l_214, l_214, l_265), (*l_252)) & l_244)))) || (-3L)) - (int16_t)0x6352L) >> (int16_t)9) >> (int16_t)(*l_252))), l_250, (**l_251), l_250)) >= 4UL);
                (*l_252) = 0xFDEEFCC7L;
                (*l_290) = func_61(((((void*)0 == l_267) >= ((uint64_t)(((int64_t)((l_229 || ((int32_t)(0L != ((((uint16_t)0UL - (uint16_t)l_250) | l_250) == ((uint16_t)((uint16_t)((((0x7763L & ((uint32_t)(+((int16_t)((int64_t)l_60 + (int64_t)l_250) >> (int16_t)l_250)) / (uint32_t)l_214)) == l_214) >= (*l_252)) | l_214) >> (uint16_t)l_287) >> (uint16_t)l_250))) / (int32_t)l_250)) > (-2L)) % (int64_t)l_200) | l_244) % (uint64_t)0xAF0DCE50D722C878LL)) && l_214), l_288, l_289, l_288, (*l_289));
            }
            (*l_265) = __builtin_parityl((((0xEB97D692D81DAF6DLL < 0UL) > (((int16_t)l_229 >> (int16_t)3) || ((int16_t)((l_200 > (((l_288 != l_214) == l_288) | ((uint16_t)(l_29 >= (l_297 | l_214)) - (uint16_t)2L))) | l_60) >> (int16_t)l_250))) | l_298));
            l_244 = l_229;
        }
        else
        { /* block id: 126 */
            const float l_304 = 0x7.FDFA38p+43;
            const int64_t l_305 = 0xBA37C6CF8349BCD8LL;
            int32_t *l_306 = &l_244;
            for (l_200 = 0; (l_200 < 9); l_200 += 9)
            { /* block id: 129 */
                uint16_t l_301 = 65533UL;
                l_301 = l_60;
            }
            (*l_306) = ((uint32_t)l_214 / (uint32_t)l_214);
            (*l_265) = ((float)(*l_306) + (float)((__builtin_ctzll(((*l_306) == ((+((uint16_t)((void*)0 == l_312) << (uint16_t)11)) && ((**l_312) < (*l_306))))) <= l_214) <= l_297));
            (*l_320) = ((*l_313) != (((0x3.F3D8B4p+48 > (((float)((float)0x4.FFBB3Fp-18 - (float)(**l_312)) + (float)((float)((l_320 == (void*)0) != func_87(l_320, l_203, ((int16_t)(l_323 != l_324) % (int16_t)(*l_306)))) / (float)0x8.47D68Fp-92)) <= (*l_313))) > (*l_306)) >= 0x7.58CCBBp+70));
        }
        (*l_313) = ((int16_t)(*l_313) << (int16_t)11);
    }
    else
    { /* block id: 137 */
        const int32_t l_329 = (-2L);
        float *l_334 = &l_266;
        (*l_313) = (((float)((((l_329 == ((float)(((-0x1.6p-1) != (l_329 != ((*l_313) != 0x1.6p+1))) == (*l_313)) - (float)(*l_313))) != l_329) < 0xE.4B3009p-50) > l_329) - (float)l_335) > 0x3.DE8AA6p+30);
    }
    (*l_313) = ((uint64_t)(*l_313) / (uint64_t)(*l_313));
    return l_338;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_36(int64_t  p_37, uint8_t  p_38, int16_t  p_39)
{ /* block id: 75 */
    int32_t l_139 = (-10L);
    uint32_t l_142 = 2UL;
    int32_t l_155 = 0xAF0D9658L;
    int32_t *l_154 = &l_155;
    if ((l_139 == p_38))
    { /* block id: 76 */
        int32_t l_149 = (-1L);
        int32_t *l_148 = &l_149;
        int32_t **l_147 = &l_148;
        int32_t *l_153 = (void*)0;
        (*l_148) = ((uint32_t)(l_142 && (0x7A5C46AFL && (((int16_t)((uint16_t)(__builtin_ffsll(p_39) | (((l_147 != &l_148) != (((int16_t)((+(**l_147)) | 0x325CL) >> (int16_t)func_87(l_153, l_154, p_37)) < 0xA4DCL)) == p_38)) + (uint16_t)p_38) - (int16_t)(*l_154)) > p_39))) + (uint32_t)p_39);
    }
    else
    { /* block id: 78 */
        int32_t **l_156 = &l_154;
lbl_189:
        (*l_156) = &l_155;
        if ((((uint16_t)((*l_154) >= p_37) + (uint16_t)func_87((*l_156), &l_155, ((((int16_t)((*l_154) == ((**l_156) > ((*l_156) != (void*)0))) - (int16_t)((**l_156) > (**l_156))) != (**l_156)) >= p_37))) | 65535UL))
        { /* block id: 80 */
            float *l_165 = (void*)0;
            float l_171 = 0x4.3A4BFFp+23;
            float *l_170 = &l_171;
            (*l_170) = ((float)((float)0x0.0DFAB6p-55 + (float)((((void*)0 != l_165) < ((float)((**l_156) < ((float)0x1.Cp+1 - (float)0xB.051342p-31)) - (float)(-0x5.7p+1))) > ((p_39 != 0x3.6C5452p-13) != 0x0.2EBD03p-83))) / (float)0x5.A0E5F2p-59);
        }
        else
        { /* block id: 82 */
            int32_t l_179 = 0xD96F57F4L;
            if (((void*)0 != l_156))
            { /* block id: 83 */
                int32_t * const l_172 = &l_155;
                float l_178 = 0xF.1E2AC5p+84;
                float *l_177 = &l_178;
                (*l_156) = l_172;
                (*l_177) = (((p_38 >= ((float)((float)(*l_172) / (float)0xD.9A4CFDp-68) + (float)p_39)) == p_39) != p_37);
            }
            else
            { /* block id: 86 */
                int32_t l_186 = 0x3B0D5B00L;
                (*l_154) = (l_179 & (((int16_t)(p_37 <= (*l_154)) >> (int16_t)p_39) <= (((p_39 == l_186) >= ((((uint32_t)(__builtin_ia32_crc32qi(l_179, (**l_156)) <= (**l_156)) / (uint32_t)(*l_154)) ^ 1L) <= 0UL)) | 0L)));
                if (p_38)
                    goto lbl_189;
            }
        }
        (*l_156) = &l_155;
        (*l_154) = ((int16_t)((int32_t)((**l_156) != (*l_154)) / (int32_t)((*l_154) & (**l_156))) / (int16_t)((int16_t)func_56((**l_156), (*l_154), p_39) + (int16_t)((uint16_t)((uint64_t)__builtin_ctzll(((*l_154) == (*l_154))) / (uint64_t)0xF68FA652D37032A6LL) >> (uint16_t)9)));
    }
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_42(uint16_t  p_43, uint32_t  p_44, int16_t  p_45, int64_t  p_46, int32_t  p_47)
{ /* block id: 63 */
    int64_t l_129 = 0x037C870D1841160CLL;
    int32_t l_131 = 1L;
    int32_t *l_130 = &l_131;
    int32_t **l_132 = (void*)0;
    int32_t **l_133 = &l_130;
    int64_t l_137 = 0L;
    int32_t *l_138 = &l_131;
    (*l_133) = func_81(l_129, l_130, (*l_130), (*l_130), l_130);
    if (func_87((*l_133), (*l_133), p_43))
    { /* block id: 65 */
        int32_t *l_134 = (void*)0;
        (*l_133) = func_96((**l_133));
        /* statement id: 66 */
        assert (l_130 == 0);
        (*l_133) = l_134;
        (*l_133) = (*l_133);
    }
    else
    { /* block id: 69 */
        (**l_133) = 0x1A75D104L;
        (*l_130) = (**l_133);
    }
    /* facts after branching */
    assert (l_130 == &l_131 || l_130 == 0);
    (*l_138) = (func_98(&p_47, p_43) && 0x9D4FL);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_50(float  p_51, uint16_t  p_52, int16_t  p_53, const uint32_t  p_54, const uint32_t  p_55)
{ /* block id: 56 */
    for (p_53 = 0; (p_53 <= 25); p_53++)
    { /* block id: 59 */
        uint16_t l_128 = 65535UL;
        l_128 = p_53;
    }
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_56(const int16_t  p_57, uint16_t  p_58, float  p_59)
{ /* block id: 37 */
    int32_t l_69 = 4L;
    const int32_t *l_123 = (void*)0;
    const int32_t **l_124 = &l_123;
    float l_125 = (-0x5.Fp+1);
    l_123 = func_61(((uint16_t)l_69 << (uint16_t)4), __builtin_ctzll(((int32_t)(&l_69 == &l_69) + (int32_t)0xAB6AC39BL)), &l_69, p_58, p_58);
    /* statement id: 53 */
    assert (l_123 == &l_69);
    (*l_124) = &l_69;
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * const  func_61(uint64_t  p_62, uint32_t  p_63, int32_t * p_64, int64_t  p_65, uint32_t  p_66)
{ /* block id: 38 */
    uint16_t l_76 = 0x862EL;
    int32_t l_78 = (-1L);
    int32_t *l_77 = &l_78;
    float l_80 = 0x8.53E8AFp+58;
    float *l_79 = &l_80;
    int32_t **l_121 = (void*)0;
    int32_t *l_122 = &l_78;
    (*l_79) = ((float)((float)((p_65 >= ((p_64 == p_64) != ((l_76 > l_76) == l_76))) == ((void*)0 != l_77)) - (float)(&l_78 == (void*)0)) / (float)(*l_77));
    l_122 = func_81((func_87(p_64, p_64, ((int64_t)1L / (int64_t)p_62)) > 0x6C8EL), &l_78, ((float)((void*)0 != &l_78) + (float)p_63), (*l_77), p_64);
    /* statement id: 51 */
    //assert (l_122 == &l_69 || l_122 == &l_244);
    return p_64;
    /* statement id: 52 */
    //assert (func_61_rv == &l_69 || func_61_rv == &l_244);
}


/* ------------------------------------------ */
/* 
 * reads : l_69 l_244
 * writes:
 */
static int32_t * func_81(uint32_t  p_82, int32_t * p_83, float  p_84, int32_t  p_85, float * p_86)
{ /* block id: 42 */
    float l_102 = 0x1.C34287p-58;
    float *l_101 = &l_102;
    int32_t **l_117 = (void*)0;
    int32_t l_120 = 0xFEF66F2FL;
    int32_t *l_119 = &l_120;
    int32_t **l_118 = &l_119;
    (*l_118) = func_96(func_98(p_86, ((l_101 == (void*)0) & p_85)));
    /* statement id: 49 */
    assert (l_119 == 0);
    return p_86;
    /* statement id: 50 */
    //assert (func_81_rv == &l_69 || func_81_rv == &l_131 || func_81_rv == &l_266 || func_81_rv == &l_244);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_87(int32_t * p_88, int32_t * p_89, int16_t  p_90)
{ /* block id: 40 */
    uint32_t l_93 = 0x637EAC69L;
    return l_93;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_96(uint8_t  p_97)
{ /* block id: 46 */
    const int16_t l_111 = 0xC61BL;
    float l_115 = 0x0.95BD66p+70;
    float *l_114 = &l_115;
    int32_t *l_116 = (void*)0;
    (*l_114) = ((float)p_97 / (float)(((float)l_111 / (float)((float)(l_111 >= p_97) + (float)p_97)) == (-0x1.Cp-1)));
    return l_116;
    /* statement id: 48 */
    //assert (func_96_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_69 l_131 l_266 l_244
 * writes:
 */
static uint8_t  func_98(int32_t * p_99, const uint32_t  p_100)
{ /* block id: 43 */
    int32_t **l_103 = (void*)0;
    int32_t l_106 = 0x08C9934BL;
    int32_t *l_105 = &l_106;
    int32_t **l_104 = &l_105;
    (*l_104) = p_99;
    /* statement id: 44 */
    //assert (l_105 == &l_69 || l_105 == &l_131 || l_105 == &p_47 || l_105 == &l_266 || l_105 == &l_244);
    return (*l_105);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 66
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 6, occurrence: 4
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 28, occurrence: 2
   depth: 32, occurrence: 1

XXX total number of pointers: 55

XXX times a variable address is taken: 53
XXX times a pointer is dereferenced on RHS: 57
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 17
XXX times a pointer is dereferenced on LHS: 39
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 131

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 96
   level: 2, occurrence: 25
XXX number of pointers point to pointers: 16
XXX number of pointers point to scalars: 39
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.3
XXX average alias set size: 1.38

XXX times a non-volatile is read: 374
XXX times a non-volatile is write: 91
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 71
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 16
   depth: 2, occurrence: 10
   depth: 3, occurrence: 12
   depth: 4, occurrence: 8

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
********************* end of statistics **********************/

