/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2136939560
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int64_t  f0;
   int64_t  f1;
   uint32_t  f2;
   uint8_t  f3;
   signed f4 : 17;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_31(void);
static float  func_38(uint64_t  p_39, const uint8_t  p_40);
inline static uint16_t  func_45(int64_t  p_46);
inline static uint64_t  func_48(int16_t  p_49, int32_t  p_50, uint8_t  p_51, uint32_t  p_52);
static int32_t  func_53(uint32_t  p_54, int32_t  p_55);
static uint16_t  func_59(uint32_t  p_60, const uint32_t  p_61, uint8_t  p_62, uint32_t  p_63);
static int16_t  func_74(uint8_t  p_75, uint8_t  p_76);
static uint16_t  func_85(const uint8_t  p_86);
static int32_t * func_90(const int32_t * p_91, uint32_t  p_92, int16_t  p_93);
inline static const int32_t * func_94(uint16_t  p_95, int32_t  p_96);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = (-3L);
    float l_679 = 0x2.341FC4p-8;
    float *l_678 = &l_679;
    float **l_677 = &l_678;
    uint32_t l_699 = 0x4E1E5A44L;
    int32_t l_707 = 0xDB47E454L;
    int32_t * const ***l_708 = (void*)0;
    uint64_t l_725 = 0xD7D39FCB48F1871BLL;
    const union U0 ***l_730 = (void*)0;
    int32_t * const l_754 = &l_707;
    union U0 l_797 = {1L};
    union U0 * const l_796 = &l_797;
    union U0 *l_799 = &l_797;
    union U0 **l_798 = &l_799;
    uint32_t l_840 = 1UL;
lbl_814:
    for (l_32 = (-15); (l_32 <= 6); l_32 += 1)
    { /* block id: 39 */
        uint32_t l_35 = 0x924B5411L;
        int32_t l_676 = 0L;
        int32_t *l_675 = &l_676;
        float ***l_715 = &l_677;
        float ****l_714 = &l_715;
        float *****l_713 = &l_714;
        union U0 l_729 = {-1L};
        union U0 *l_728 = &l_729;
        union U0 **l_727 = &l_728;
        union U0 ***l_726 = &l_727;
        int32_t l_744 = 2L;
        int32_t ***l_747 = (void*)0;
        if (l_35)
            break;
        for (l_35 = 0; (l_35 >= 60); l_35 += 1)
        { /* block id: 43 */
            int16_t l_47 = 5L;
            int16_t l_70 = 0x3395L;
            int32_t l_674 = (-7L);
            float ***l_680 = (void*)0;
            float ***l_681 = &l_677;
            l_674 = ((func_38((l_32 > (((uint16_t)(((uint16_t)(func_45((((l_47 | __builtin_clzll((func_48((func_53((((uint16_t)0UL >> (uint16_t)(-(uint64_t)(l_32 >= ((3UL > func_59(((uint16_t)((uint32_t)(((uint16_t)((l_32 == l_70) == ((l_70 < (0xB9D3L || l_32)) && 0UL)) / (uint16_t)l_47) == l_32) / (uint32_t)0xEF5D3CC1L) % (uint16_t)0xFF6AL), l_35, l_32, l_35)) ^ l_47)))) & l_32), l_70) <= 0x43605614L), l_32, l_32, l_32) && l_32))) <= l_35) ^ l_47)) > 0L) >> (uint16_t)l_32) ^ 0UL) / (uint16_t)l_47) | l_70)), l_35) == l_32) != 0x0.0p-1);
            l_675 = func_90(&l_674, (l_35 < (0UL >= 0xB476EC48L)), l_674);
            /* statement id: 376 */
            assert (l_675 == 0);
            (*l_681) = l_677;
        }
        /* facts after for loop */
        assert (l_675 == 0 || l_675 == &l_676);
        if (l_32)
        { /* block id: 379 */
            return l_32;
        }
        else
        { /* block id: 381 */
            float ***l_682 = &l_677;
            int32_t l_689 = 0L;
            int32_t *l_700 = &l_676;
            (*l_682) = &l_678;
            (*l_700) = (((uint64_t)(((int16_t)((uint32_t)(l_689 == (((int16_t)l_32 % (int16_t)(+l_689)) != ((l_32 & ((int16_t)0xD67AL + (int16_t)((l_35 < l_676) > func_48(l_689, (((int64_t)l_689 % (int64_t)l_32) != l_32), l_35, l_32)))) <= l_32))) + (uint32_t)l_689) / (int16_t)l_689) ^ l_699) / (uint64_t)4UL) || l_699);
        }
        if ((l_699 < 0x92CAL))
        { /* block id: 385 */
            uint32_t l_704 = 0x3347DF2BL;
            float *****l_716 = &l_714;
            const float l_724 = 0x0.Ep+1;
            int32_t **l_746 = &l_675;
            int32_t ***l_745 = &l_746;
            int32_t l_762 = 0x3D630D45L;
            if ((l_32 & l_699))
            { /* block id: 386 */
                uint8_t l_703 = 0x9BL;
                const int32_t *l_705 = (void*)0;
                union U0 l_721 = {0xA0A6571AFBA164C1LL};
                union U0 *l_720 = &l_721;
                union U0 **l_719 = &l_720;
                const uint32_t l_750 = 0x181A7AE0L;
                int32_t l_751 = 0x18380382L;
                uint8_t l_752 = 8UL;
                if ((((uint64_t)l_703 % (uint64_t)func_74(l_699, l_703)) || l_704))
                { /* block id: 387 */
                    int32_t *l_706 = &l_676;
                    int32_t *****l_709 = (void*)0;
                    l_706 = func_90(l_705, l_704, ((func_45(l_704) && 65533UL) < l_704));
                    /* statement id: 388 */
                    assert (l_706 == 0);
                    l_707 = l_32;
                    l_708 = l_708;
                }
                else
                { /* block id: 391 */
                    int32_t l_712 = (-1L);
                    for (l_703 = 14; (l_703 == 10); l_703--)
                    { /* block id: 394 */
                        return l_712;
                    }
                    l_716 = l_713;
                }
                if (((l_704 > 0x6B0DL) <= ((int16_t)((0x0068B44D2C27210BLL && ((void*)0 == l_719)) ^ ((int16_t)0x22DBL - (int16_t)l_725)) / (int16_t)(func_74((l_726 == l_730), l_704) | l_704))))
                { /* block id: 399 */
                    return l_704;
                }
                else
                { /* block id: 401 */
                    const uint8_t l_735 = 0x65L;
                    float *****l_738 = &l_714;
                    if (((uint16_t)(__builtin_ctzll(__builtin_ia32_crc32qi(l_725, (1L <= ((((((uint16_t)func_53(__builtin_clzl(((l_704 >= (l_735 ^ ((int16_t)((l_704 && l_735) != l_729.f1) << (int16_t)(l_738 == l_738)))) >= l_35)), l_704) + (uint16_t)0xCAA1L) | l_735) & l_735) > 0L) || l_729.f3)))) | l_704) << (uint16_t)l_735))
                    { /* block id: 402 */
                        uint64_t l_743 = 18446744073709551614UL;
                        int32_t *l_748 = (void*)0;
                        int32_t *l_749 = &l_676;
                        int32_t **l_753 = &l_749;
                        (*l_749) = ((int64_t)(((uint16_t)l_743 >> (uint16_t)((l_735 == 0x750C409CL) <= l_744)) <= (l_745 != l_747)) - (int64_t)l_743);
                        (*l_753) = func_94(l_721.f3, func_59(l_735, l_750, l_751, l_752));
                        /* statement id: 404 */
                        assert (l_749 == 0);
                        (*****l_738) = l_35;
                    }
                    else
                    { /* block id: 406 */
                        int32_t **l_755 = &l_675;
                        (*l_755) = l_754;
                        /* statement id: 407 */
                        assert (l_675 == &l_707);
                        return l_735;
                    }
                }
            }
            else
            { /* block id: 411 */
                const int32_t *l_758 = &l_676;
                int32_t l_767 = 0x296F36FBL;
                union U0 ****l_769 = &l_726;
                union U0 *****l_768 = &l_769;
                uint16_t l_793 = 0x4D1BL;
                for (l_725 = 0; (l_725 >= 40); l_725 += 6)
                { /* block id: 414 */
                    int32_t l_759 = 0x1E1C9720L;
                    uint64_t l_781 = 18446744073709551606UL;
                    (**l_745) = func_90(l_758, l_759, (*l_758));
                    /* statement id: 415 */
                    assert (l_675 == 0);
                    (**l_745) = &l_707;
                    /* statement id: 416 */
                    assert (l_675 == &l_707);
                    if ((***l_745))
                    { /* block id: 417 */
                        (*l_754) = (((func_48(l_759, (*l_758), l_759, __builtin_ctzll(l_759)) == ((***l_745) || ((int16_t)((***l_745) && l_762) >> (int16_t)10))) >= (*l_675)) == l_759);
                        (**l_745) = func_90((*l_746), l_759, (*l_675));
                        /* statement id: 419 */
                        assert (l_675 == 0);
                        (*l_754) = 0x1B1A6EA4L;
                    }
                    else
                    { /* block id: 421 */
                        int32_t l_778 = 0x042D62B9L;
                        float l_782 = 0x1.4p+1;
                        (*l_754) = ((uint32_t)(((int16_t)__builtin_parityll((l_767 & func_45((((void*)0 == l_768) | ((uint32_t)((uint16_t)((uint64_t)(4294967294UL && (*l_754)) + (uint64_t)0xFC564CF22E3A02C0LL) >> (uint16_t)((uint64_t)(func_45(l_778) | ((int16_t)((l_781 <= l_778) | l_759) % (int16_t)(*l_758))) / (uint64_t)(*l_758))) + (uint32_t)l_778))))) / (int16_t)(**l_746)) || 0x24CA425AL) - (uint32_t)(**l_746));
                        (*l_746) = &l_767;
                        /* statement id: 423 */
                        assert (l_675 == &l_767);
                        if (l_778)
                            continue;
                        (***l_745) = ((uint16_t)((((uint16_t)(((*l_675) < (*l_758)) || ((int16_t)l_781 / (int16_t)__builtin_bswap64((*l_758)))) + (uint16_t)((void*)0 == l_708)) < l_781) ^ ((uint16_t)((int32_t)func_74(l_781, (***l_745)) % (int32_t)(-1L)) - (uint16_t)l_793)) << (uint16_t)11);
                    }
                    /* facts after branching */
                    assert (l_675 == &l_767 || l_675 == 0);
                    if ((*l_758))
                        break;
                }
                /* facts after for loop */
                assert (l_675 == &l_767 || l_675 == 0 || l_675 == &l_676);
            }
            /* facts after branching */
            //assert (l_675 == dangling || l_675 == 0 || l_675 == &l_676);
        }
        else
        { /* block id: 430 */
            union U0 ****l_794 = &l_726;
            union U0 *****l_795 = (void*)0;
            l_794 = l_794;
        }
        /* facts after branching */
        //assert (l_675 == dangling || l_675 == 0 || l_675 == &l_676);
    }
    (*l_798) = l_796;
    if ((-(int32_t)(*l_754)))
    { /* block id: 435 */
        int32_t l_804 = 0x3441F030L;
        int32_t **l_833 = (void*)0;
        int32_t *l_837 = (void*)0;
        int32_t **l_836 = &l_837;
        for (l_797.f1 = 0; (l_797.f1 != (-4)); --l_797.f1)
        { /* block id: 438 */
            const int64_t l_803 = 8L;
            uint64_t l_813 = 0x36C8588156A841D5LL;
            const float ****l_825 = (void*)0;
            const float *****l_824 = &l_825;
            (*l_754) = l_803;
            if ((l_804 == l_803))
            { /* block id: 440 */
                int32_t l_805 = 9L;
                int32_t l_806 = 0x3C57D527L;
                l_806 = l_805;
                if (l_804)
                { /* block id: 442 */
                    for (l_804 = 0; (l_804 >= (-28)); l_804--)
                    { /* block id: 445 */
                        int32_t *l_809 = &l_806;
                        int32_t **l_810 = &l_809;
                        (*l_810) = l_809;
                    }
                }
                else
                { /* block id: 448 */
                    int32_t *l_812 = &l_32;
                    int32_t **l_811 = &l_812;
                    (*l_754) = l_803;
                    (*l_811) = (void*)0;
                    /* statement id: 450 */
                    assert (l_812 == 0);
                    return l_813;
                }
                if (l_806)
                    continue;
                if (l_699)
                    goto lbl_814;
            }
            else
            { /* block id: 455 */
                uint64_t l_815 = 0x59EE3DA583C436A6LL;
                int32_t *l_832 = &l_32;
                int32_t **l_831 = &l_832;
                const union U0 ****l_834 = &l_730;
                union U0 *****l_835 = (void*)0;
                (**l_677) = (func_38(l_815, (((int16_t)l_804 % (int16_t)func_74((*l_754), l_803)) == (((uint64_t)((uint32_t)(l_815 && ((int16_t)(0x11AFE144L == ((void*)0 != l_824)) << (int16_t)0)) % (uint32_t)l_815) % (uint64_t)l_815) >= l_813))) >= (-0x3.5p+1));
                (*l_678) = ((float)((*l_754) > l_804) + (float)(-(float)(((float)l_803 + (float)0x9.BA643Ep-38) >= l_813)));
                (*l_832) = (l_831 != l_833);
                l_834 = l_834;
            }
        }
        /* facts after for loop */
                (*l_836) = func_94(l_804, l_804);
        (*l_678) = ((float)__builtin_bswap64((0x6C1A8EC0L != l_804)) + (float)(l_840 >= (*l_754)));
        return l_804;
    }
    else
    { /* block id: 465 */
        int32_t *l_843 = &l_707;
        float l_845 = (-0x8.3p-1);
        uint64_t l_846 = 0x73EFF802DCEDD759LL;
        for (l_707 = 0; (l_707 <= 18); l_707 += 4)
        { /* block id: 468 */
            int32_t **l_844 = &l_843;
            (*l_844) = l_843;
        }
        return l_846;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_38(uint64_t  p_39, const uint8_t  p_40)
{ /* block id: 371 */
    uint16_t l_666 = 65526UL;
    float l_671 = 0x6.Fp+1;
    int32_t l_672 = (-2L);
    int32_t *l_673 = &l_672;
    l_672 = ((((int32_t)(func_45(l_666) < p_40) % (int32_t)(((((((int64_t)(~(l_666 & p_39)) + (int64_t)p_40) == 1UL) >= l_666) | func_53((((-(int32_t)l_666) != p_39) >= 0xB4017B7A4F7B63D2LL), l_666)) && p_40) && 0x84396A70DAF5C121LL)) == (-1L)) & l_666);
    l_673 = &l_672;
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_45(int64_t  p_46)
{ /* block id: 362 */
    float l_656 = 0xB.C5E04Dp+28;
    float *l_655 = &l_656;
    int32_t l_657 = 0xD121491CL;
    int32_t *l_658 = &l_657;
    (*l_658) = ((l_655 != (void*)0) | l_657);
    for (p_46 = 0; (p_46 < 2); p_46 += 2)
    { /* block id: 366 */
        int32_t * const l_663 = (void*)0;
        if (p_46)
            break;
        (*l_658) = ((uint32_t)((void*)0 != l_663) + (uint32_t)(-1L));
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_48(int16_t  p_49, int32_t  p_50, uint8_t  p_51, uint32_t  p_52)
{ /* block id: 359 */
    float *l_651 = (void*)0;
    float l_653 = 0x4.A0F8B6p-43;
    float *l_652 = &l_653;
    int32_t l_654 = 0x824B5A77L;
    (*l_652) = (-0x4.2p-1);
    return l_654;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_53(uint32_t  p_54, int32_t  p_55)
{ /* block id: 335 */
    int32_t **l_611 = (void*)0;
    int32_t l_614 = 0x76D0839FL;
    int32_t *l_613 = &l_614;
    int32_t **l_612 = &l_613;
    union U0 ***l_646 = (void*)0;
    union U0 ****l_645 = &l_646;
lbl_625:
    (*l_612) = &p_55;
    /* statement id: 336 */
    assert (l_613 == &p_55);
    if ((p_54 == (-1L)))
    { /* block id: 337 */
        const union U0 *l_615 = (void*)0;
        int32_t l_616 = 0xFC131C93L;
        float l_618 = (-0x4.9p+1);
        float *l_617 = &l_618;
        l_615 = l_615;
        (*l_617) = __builtin_parityl((l_616 > p_54));
        (*l_617) = ((float)(p_55 == 0x5.582A12p-53) - (float)((-0x7.Cp+1) != func_59(l_616, l_616, (p_54 != ((func_59(p_55, (*l_613), (((int16_t)((uint32_t)(**l_612) + (uint32_t)p_54) >> (int16_t)6) != p_54), p_54) == p_54) > p_54)), (**l_612))));
    }
    else
    { /* block id: 341 */
        float l_629 = 0x0.Cp+1;
        float *l_628 = &l_629;
        int32_t l_634 = (-1L);
        if (p_54)
            goto lbl_625;
        l_634 = ((int16_t)((l_628 == l_613) >= ((int16_t)p_55 + (int16_t)(((int64_t)l_634 - (int64_t)l_634) < l_634))) << (int16_t)7);
        if (((int32_t)((int32_t)((*l_613) ^ (p_54 <= (l_634 < 0x61A7614259A3E50DLL))) + (int32_t)p_54) % (int32_t)(l_634 && ((((uint64_t)(l_634 >= (l_634 || ((int16_t)(&l_611 == (void*)0) << (int16_t)1))) + (uint64_t)p_55) >= 1UL) >= 0x8DCAB2CDL))))
        { /* block id: 344 */
            int32_t *l_643 = &l_614;
            l_643 = &p_55;
            /* statement id: 345 */
            assert (l_643 == &p_55);
        }
        else
        { /* block id: 346 */
            uint8_t l_644 = 0x16L;
            (*l_612) = func_90(func_94(l_644, (l_634 & (l_645 == &l_646))), (**l_612), (0UL ^ (p_54 | func_59(l_634, p_55, l_634, p_54))));
            /* statement id: 347 */
            assert (l_613 == 0);
            for (l_644 = 0; (l_644 < 53); l_644++)
            { /* block id: 350 */
                uint8_t l_649 = 0xEEL;
                int32_t *l_650 = (void*)0;
                l_649 = p_54;
                (*l_628) = p_54;
                (*l_612) = l_650;
            }
            return p_54;
        }
    }
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_59(uint32_t  p_60, const uint32_t  p_61, uint8_t  p_62, uint32_t  p_63)
{ /* block id: 44 */
    int32_t l_73 = 2L;
    int32_t l_80 = 0x8101BC64L;
    union U0 ** const *l_341 = (void*)0;
    if ((((int16_t)l_73 >> (int16_t)(l_73 && func_74((((int16_t)(!l_80) + (int16_t)(((uint32_t)(((uint16_t)func_85(l_80) >> (uint16_t)3) & 1UL) + (uint32_t)l_73) <= ((int32_t)(l_341 != (void*)0) % (int32_t)l_73))) ^ l_73), l_80))) != 0L))
    { /* block id: 319 */
        int32_t *l_581 = &l_80;
        int32_t **l_582 = &l_581;
        int32_t * const *l_590 = &l_581;
        int32_t * const **l_589 = &l_590;
        int32_t * const ***l_588 = &l_589;
        uint16_t l_603 = 0x6CC4L;
lbl_585:
        (*l_582) = l_581;
        (*l_581) = __builtin_popcount(p_61);
        for (p_62 = (-23); (p_62 == 11); p_62 += 4)
        { /* block id: 324 */
            int32_t l_604 = (-1L);
            float l_606 = (-0x5.Cp-1);
            float *l_605 = &l_606;
            if (l_80)
                goto lbl_585;
            l_80 = ((int16_t)func_74((((((void*)0 == l_588) != ((int32_t)(__builtin_ctzll(((uint32_t)((int16_t)func_85(l_73) << (int16_t)1) % (uint32_t)((uint16_t)((((p_60 ^ p_62) > ((int64_t)(func_74(((**l_582) != 0xB10184A4C1BB2893LL), ((uint16_t)(0xD600L && l_603) / (uint16_t)p_63)) < l_604) - (int64_t)p_61)) <= 0xDD34L) != l_604) << (uint16_t)l_604))) < (****l_588)) / (int32_t)4294967294UL)) < p_61) && l_80), (****l_588)) / (int16_t)l_80);
            (*l_605) = l_604;
        }
        return l_80;
    }
    else
    { /* block id: 330 */
        union U0 l_608 = {0L};
        union U0 *l_607 = &l_608;
        union U0 **l_609 = &l_607;
        int32_t *l_610 = &l_80;
        (*l_609) = l_607;
        (*l_610) = 0xFE4AA0D4L;
        return p_62;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_74(uint8_t  p_75, uint8_t  p_76)
{ /* block id: 195 */
    float l_344 = 0xC.3307FDp+34;
    uint64_t l_355 = 1UL;
    union U0 **l_365 = (void*)0;
    int32_t * const *l_412 = (void*)0;
    int32_t * const **l_411 = &l_412;
    int32_t * const ***l_410 = &l_411;
    float *l_545 = &l_344;
    float **l_544 = &l_545;
    float ***l_543 = &l_544;
    float ****l_542 = &l_543;
    float *****l_541 = &l_542;
    union U0 * const ** const l_567 = (void*)0;
    union U0 * const ** const *l_566 = &l_567;
    union U0 * const ** const **l_565 = &l_566;
    for (p_75 = (-13); (p_75 >= 43); p_75 += 7)
    { /* block id: 198 */
        uint8_t l_349 = 0xECL;
        int32_t l_415 = 0xF3B268BFL;
        int32_t *l_414 = &l_415;
        union U0 ***l_459 = &l_365;
        union U0 ****l_458 = &l_459;
        float *l_478 = &l_344;
        float **l_477 = &l_478;
        float ***l_476 = &l_477;
        float ****l_475 = &l_476;
        const int32_t * const *** const l_503 = (void*)0;
        const int32_t * const *** const *l_502 = &l_503;
        float *****l_507 = &l_475;
        if (p_76)
            break;
        if (p_76)
        { /* block id: 200 */
            const float l_350 = 0x9.7CED49p+56;
            int32_t l_356 = 2L;
            const int32_t *l_409 = &l_356;
            const int32_t **l_408 = &l_409;
            const int32_t ***l_407 = &l_408;
            const int32_t ****l_406 = &l_407;
            union U0 ** const *l_446 = &l_365;
            union U0 ** const **l_445 = &l_446;
            union U0 ** const ***l_447 = &l_445;
            if (p_76)
                break;
            for (p_76 = (-25); (p_76 < 2); p_76 += 8)
            { /* block id: 204 */
                int32_t l_354 = 0x81A09870L;
                float *l_389 = &l_344;
                int32_t l_433 = 0L;
                int32_t **l_442 = (void*)0;
                int32_t ***l_441 = &l_442;
            }
            (*l_447) = l_445;
        }
        else
        { /* block id: 243 */
            uint8_t l_457 = 0x85L;
            int32_t *l_460 = &l_415;
            union U0 l_464 = {0x0D821A32C9F228F1LL};
            union U0 *l_463 = &l_464;
            float l_504 = (-0x9.5p+1);
            uint16_t l_506 = 0x0840L;
            float *****l_512 = &l_475;
            for (l_415 = 0; (l_415 < (-20)); l_415 -= 8)
            { /* block id: 246 */
                int32_t l_456 = 0x210DF2F0L;
                int32_t l_465 = 0xCE634954L;
                int32_t * const *l_515 = &l_460;
            }
        }
        for (l_415 = 0; (l_415 <= 15); l_415 += 5)
        { /* block id: 295 */
            int32_t l_523 = 0x3AD8DB43L;
            const int32_t *l_524 = (void*)0;
            union U0 l_557 = {0x0C5B31C882E834E3LL};
            union U0 *l_556 = &l_557;
            uint64_t l_579 = 0x53D4998C55F51B6DLL;
            l_524 = func_94(__builtin_popcountll(l_523), p_76);
        }
    }
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_85(const uint8_t  p_86)
{ /* block id: 45 */
    int32_t l_87 = 3L;
    int32_t l_333 = 0xCD189FC5L;
    float l_338 = 0x1.Bp-1;
    float *l_337 = &l_338;
    for (l_87 = (-11); (l_87 < 10); l_87 += 1)
    { /* block id: 48 */
        uint32_t l_97 = 0x421A0E57L;
        int16_t l_115 = (-1L);
        int32_t *l_310 = &l_87;
        int32_t **l_309 = &l_310;
        (*l_309) = func_90(func_94(p_86, l_97), p_86, l_115);
        /* statement id: 174 */
        assert (l_310 == 0);
    }
    for (l_87 = (-23); (l_87 != (-3)); ++l_87)
    { /* block id: 178 */
        union U0 **l_314 = (void*)0;
        union U0 ***l_313 = &l_314;
        union U0 ****l_315 = &l_313;
        int32_t *l_316 = &l_87;
        int32_t l_317 = 0xD14D15A4L;
        (*l_315) = l_313;
        l_316 = l_316;
        for (l_317 = 1; (l_317 != (-1)); l_317 -= 2)
        { /* block id: 183 */
            const uint32_t l_328 = 0xD75CF964L;
            uint32_t l_330 = 4UL;
            if (((uint16_t)65531UL % (uint16_t)((int16_t)p_86 << (int16_t)13)))
            { /* block id: 184 */
                const uint16_t l_329 = 1UL;
                int32_t l_332 = (-1L);
                int32_t *l_331 = &l_332;
                (*l_331) = (((uint16_t)1UL << (uint16_t)15) >= ((((int16_t)0xA128L - (int16_t)l_328) | ((l_329 < l_330) == (p_86 >= p_86))) | p_86));
                (*l_331) = p_86;
            }
            else
            { /* block id: 187 */
                int32_t **l_334 = &l_316;
                l_333 = (-2L);
                (*l_334) = &l_87;
            }
        }
    }
    (*l_337) = ((float)p_86 / (float)l_87);
    return p_86;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_90(const int32_t * p_91, uint32_t  p_92, int16_t  p_93)
{ /* block id: 52 */
    int32_t l_117 = 0x0E38899AL;
    int32_t *l_116 = &l_117;
    int32_t **l_179 = &l_116;
    int32_t *** const l_178 = &l_179;
    int32_t *** const *l_177 = &l_178;
    uint8_t l_197 = 7UL;
    float l_224 = 0x5.5E4FF7p+0;
    float ****l_241 = (void*)0;
    int64_t l_243 = 8L;
    float *l_290 = &l_224;
    float **l_289 = &l_290;
    int32_t *l_303 = &l_117;
    int32_t *l_304 = &l_117;
    int32_t *l_305 = &l_117;
    int32_t *l_306 = &l_117;
    int32_t *l_307 = &l_117;
    int32_t *l_308 = (void*)0;
    if ((p_91 == l_116))
    { /* block id: 53 */
        int16_t l_132 = (-3L);
        int32_t *l_140 = &l_117;
        int32_t *l_151 = &l_117;
        int32_t *l_152 = &l_117;
        const int32_t *l_172 = &l_117;
        int32_t l_216 = 0x0864EB22L;
        int32_t ***l_221 = &l_179;
        int32_t ****l_220 = &l_221;
        if ((~(p_93 != (*l_116))))
        { /* block id: 54 */
            int32_t **l_119 = &l_116;
            int32_t l_130 = (-1L);
            const float l_145 = (-0x1.0p+1);
            int32_t *l_153 = (void*)0;
            int32_t ***l_181 = &l_179;
            int32_t ****l_180 = &l_181;
            (*l_119) = p_91;
            /* statement id: 55 */
            //assert (l_116 == 0 || l_116 == &l_415 || l_116 == &l_674 || l_116 == &l_676 || l_116 == &l_707);
            for (p_92 = (-30); (p_92 <= 49); ++p_92)
            { /* block id: 58 */
                int32_t l_131 = 0x15133AA3L;
                union U0 l_187 = {5L};
                const union U0 *l_186 = &l_187;
                float **l_195 = (void*)0;
                float ***l_194 = &l_195;
                int32_t **l_206 = &l_116;
                for (l_117 = 1; (l_117 == (-26)); --l_117)
                { /* block id: 61 */
                    int32_t ***l_124 = &l_119;
                    int32_t ** const **l_125 = (void*)0;
                    const int32_t *l_129 = &l_117;
                    const int32_t **l_128 = &l_129;
                    const int32_t ***l_127 = &l_128;
                    const int32_t ****l_126 = &l_127;
                    int32_t *l_133 = &l_131;
                    (*l_126) = l_124;
                    /* statement id: 62 */
                    assert (l_127 == &l_119);
                    if (l_130)
                        continue;
                    if (l_131)
                        break;
                    (*l_133) = ((-6L) || l_132);
                }
                if ((l_131 >= 0L))
                { /* block id: 67 */
                    int32_t **l_139 = &l_116;
                    for (l_130 = 24; (l_130 >= 19); l_130--)
                    { /* block id: 70 */
                        (*l_119) = (void*)0;
                        /* statement id: 71 */
                        assert (l_116 == 0);
                    }
                    l_131 = (((p_93 >= __builtin_popcount(p_93)) <= l_131) && ((0UL ^ ((int16_t)(!(l_132 >= l_132)) >> (int16_t)11)) == (&p_91 == l_139)));
                    (*l_139) = (void*)0;
                    /* statement id: 74 */
                    assert (l_116 == 0);
                    if (__builtin_ffsl(p_92))
                    { /* block id: 75 */
                        uint32_t l_141 = 0UL;
                        p_91 = l_140;
                        /* statement id: 76 */
                        assert (p_91 == &l_117);
                        p_91 = &l_117;
                        (*l_140) = (l_141 >= (*l_140));
                        (*l_119) = (void*)0;
                    }
                    else
                    { /* block id: 80 */
                        if (l_117)
                            break;
                        (*l_140) = 0xD9536661L;
                    }
                }
                else
                { /* block id: 84 */
                    int32_t l_146 = 0xFA911A91L;
                    int32_t *l_150 = &l_131;
                    for (p_93 = 0; (p_93 < 23); ++p_93)
                    { /* block id: 87 */
                        int32_t **l_144 = &l_116;
                        (*l_144) = p_91;
                        /* statement id: 88 */
                        //assert (l_116 == 0 || l_116 == &l_117 || l_116 == &l_415 || l_116 == &l_674 || l_116 == &l_676 || l_116 == &l_707);
                        if ((*l_140))
                            continue;
                        l_131 = p_92;
                    }
                    if (p_92)
                    { /* block id: 92 */
                        (*l_119) = &l_117;
                        /* statement id: 93 */
                        assert (l_116 == &l_117);
                        if (p_93)
                            continue;
                        (**l_119) = l_146;
                    }
                    else
                    { /* block id: 96 */
                        int32_t **l_147 = (void*)0;
                        int32_t **l_148 = &l_116;
                        int32_t *l_149 = &l_131;
                        (*l_148) = p_91;
                        /* statement id: 97 */
                        //assert (l_116 == 0 || l_116 == &l_117 || l_116 == &l_415 || l_116 == &l_674 || l_116 == &l_676 || l_116 == &l_707);
                        return l_153;
                        /* statement id: 98 */
                        //assert (func_90_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_116 == &l_117);
                    for (l_131 = 0; (l_131 < 21); l_131++)
                    { /* block id: 102 */
                        uint32_t l_156 = 4294967295UL;
                        float l_158 = 0x1.Fp-1;
                        float *l_157 = &l_158;
                        float **l_160 = &l_157;
                        float ***l_159 = &l_160;
                        (*l_119) = l_150;
                        /* statement id: 103 */
                        assert (l_116 == &l_131);
                        p_91 = p_91;
                        (*l_157) = l_156;
                        (*l_159) = &l_157;
                    }
                    /* facts after for loop */
                    assert (l_116 == &l_131 || l_116 == &l_117);
                }
                /* facts after branching */
                assert (l_116 == &l_131 || l_116 == &l_117 || l_116 == 0);
                (*l_151) = (-(int64_t)(((int16_t)l_131 >> (int16_t)10) || (*l_151)));
                for (l_130 = 0; (l_130 < 20); l_130 += 9)
                { /* block id: 112 */
                    int32_t l_171 = (-9L);
                    int32_t l_217 = 9L;
                    float l_219 = 0x0.9p-1;
                    float *l_218 = &l_219;
                }
            }
            /* facts after for loop */
            //assert (p_91 == 0 || p_91 == &l_117 || p_91 == &l_415 || p_91 == &l_674 || p_91 == &l_676 || p_91 == &l_707);
            //assert (l_116 == dangling || l_116 == &l_117 || l_116 == 0 || l_116 == &l_415 || l_116 == &l_674 || l_116 == &l_676 || l_116 == &l_707);
            (*l_140) = (l_220 == &l_178);
            (*l_152) = __builtin_bswap32(((int16_t)p_92 % (int16_t)p_93));
        }
        else
        { /* block id: 143 */
            p_91 = func_94(p_92, (p_92 == 0L));
            /* statement id: 144 */
            assert (p_91 == 0);
        }
        /* facts after branching */
        //assert (p_91 == 0 || p_91 == &l_117 || p_91 == &l_415 || p_91 == &l_674 || p_91 == &l_676 || p_91 == &l_707);
        //assert (l_116 == dangling || l_116 == &l_117 || l_116 == 0 || l_116 == &l_415 || l_116 == &l_674 || l_116 == &l_676 || l_116 == &l_707);
    }
    else
    { /* block id: 146 */
        union U0 ***l_236 = (void*)0;
        int32_t l_242 = (-3L);
        if (((uint32_t)((((uint16_t)(-(int64_t)((uint16_t)((int16_t)((void*)0 == l_236) + (int16_t)p_93) >> (uint16_t)(0x5A5BBF8F4250F726LL || ((int16_t)(((uint64_t)((void*)0 != l_241) - (uint64_t)l_242) ^ (****l_177)) >> (int16_t)10)))) + (uint16_t)(__builtin_clzl((*l_116)) == l_242)) > l_243) >= (*l_116)) / (uint32_t)l_242))
        { /* block id: 147 */
            const int32_t *l_244 = &l_242;
            int32_t **l_245 = &l_116;
            (*l_245) = l_244;
            /* statement id: 148 */
            assert (l_116 == &l_242);
            (**l_245) = (0xA.CB4D10p+64 != ((float)(((float)(**l_245) / (float)(((float)(((float)(((float)p_92 / (float)((l_242 < ((float)(**l_245) / (float)p_93)) <= p_92)) != (((float)(**l_245) / (float)(((float)(*l_244) - (float)p_93) <= p_93)) >= (-0x1.1p+1))) / (float)p_92) != (**l_245)) + (float)0x5.2p-1) < 0x0.0p+1)) == p_93) + (float)0x0.7p-1));
        }
        else
        { /* block id: 150 */
            int32_t l_276 = 0x0800E734L;
            int16_t l_277 = (-5L);
            for (p_92 = (-5); (p_92 >= 9); ++p_92)
            { /* block id: 153 */
                float *l_266 = &l_224;
                float ** const l_265 = &l_266;
                float ** const * const l_264 = &l_265;
                float * const *l_269 = &l_266;
                float * const **l_268 = &l_269;
                float * const ***l_267 = &l_268;
                (*l_267) = l_264;
                /* statement id: 154 */
                assert (l_268 == &l_265);
                (****l_177) = ((p_93 > p_92) || l_242);
            }
            (***l_178) = ((uint32_t)(**l_179) / (uint32_t)(p_92 & ((int16_t)p_92 >> (int16_t)(((int64_t)(l_276 >= l_277) % (int64_t)((uint64_t)0UL + (uint64_t)1L)) || 1L))));
        }
        /* facts after branching */
        assert (l_116 == &l_117 || l_116 == &l_242);
    }
    /* facts after branching */
    //assert (p_91 == 0 || p_91 == &l_117 || p_91 == &l_415 || p_91 == &l_674 || p_91 == &l_676 || p_91 == &l_707);
    //assert (l_116 == dangling || l_116 == &l_117 || l_116 == 0 || l_116 == &l_415 || l_116 == &l_674 || l_116 == &l_676 || l_116 == &l_707);
    if ((p_92 || (+((int64_t)((int32_t)p_92 % (int32_t)((int32_t)(p_92 | (((void*)0 != l_289) <= ((p_93 || p_93) < p_92))) / (int32_t)(p_93 ^ p_92))) % (int64_t)p_93))))
    { /* block id: 160 */
        int32_t l_291 = (-4L);
        (*l_290) = l_291;
    }
    else
    { /* block id: 162 */
        int32_t **l_292 = &l_116;
        union U0 l_295 = {6L};
        union U0 *l_294 = &l_295;
        union U0 **l_293 = &l_294;
        union U0 ***l_296 = &l_293;
        int32_t *l_297 = (void*)0;
        int32_t *l_298 = &l_117;
lbl_302:
        (*l_292) = p_91;
        /* statement id: 163 */
        //assert (l_116 == 0 || l_116 == &l_117 || l_116 == &l_415 || l_116 == &l_674 || l_116 == &l_676 || l_116 == &l_707);
        (*l_296) = l_293;
        (*l_298) = p_93;
        for (l_197 = (-12); (l_197 < 59); l_197 += 1)
        { /* block id: 168 */
            int64_t l_301 = 4L;
            (*l_298) = l_301;
            if (l_197)
                goto lbl_302;
        }
    }
    return l_308;
    /* statement id: 173 */
    //assert (func_90_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_94(uint16_t  p_95, int32_t  p_96)
{ /* block id: 49 */
    uint32_t l_105 = 0x6DE1F29AL;
    int32_t l_111 = 0x24235991L;
    int32_t * const l_110 = &l_111;
    float l_113 = (-0x1.Bp+1);
    float *l_112 = &l_113;
    const int32_t *l_114 = (void*)0;
    (*l_112) = __builtin_clzl((+((uint16_t)((int16_t)(p_96 == ((p_96 && ((int16_t)(__builtin_ia32_crc32qi(p_96, l_105) <= ((uint64_t)((int16_t)(p_95 | 0x9F5B60AA07078C3FLL) >> (int16_t)14) + (uint64_t)(0x00082338L == ((void*)0 != l_110)))) << (int16_t)5)) ^ (*l_110))) >> (int16_t)p_96) >> (uint16_t)p_95)));
    return l_114;
    /* statement id: 51 */
    //assert (func_94_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 210
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 27
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 6
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 15
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 0

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 203
   depth: 2, occurrence: 39
   depth: 3, occurrence: 8
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 246

XXX times a variable address is taken: 218
XXX times a pointer is dereferenced on RHS: 69
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 112
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 10
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 544

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 591
   level: 2, occurrence: 145
   level: 3, occurrence: 44
   level: 4, occurrence: 39
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 150
XXX number of pointers point to scalars: 82
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26
XXX average alias set size: 1.14

XXX times a non-volatile is read: 833
XXX times a non-volatile is write: 322
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 183
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 39
   depth: 2, occurrence: 35
   depth: 3, occurrence: 24
   depth: 4, occurrence: 26
   depth: 5, occurrence: 33

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

