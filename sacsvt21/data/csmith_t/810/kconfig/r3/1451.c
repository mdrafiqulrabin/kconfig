/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3417290008
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const signed f0 : 26;
};

union U1 {
   uint16_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_29(void);
inline static const float  func_30(union U1  p_31, int32_t  p_32, const struct S0  p_33, uint32_t  p_34);
inline static union U1  func_35(uint32_t  p_36, int16_t  p_37, int16_t  p_38, int32_t  p_39);
static int16_t  func_43(uint32_t  p_44, int32_t  p_45, float  p_46);
inline static uint32_t  func_62(uint32_t  p_63, uint16_t  p_64, uint32_t  p_65, float  p_66);
inline static uint32_t  func_67(struct S0  p_68, uint32_t  p_69, int32_t  p_70, int32_t  p_71);
inline static union U1 * func_74(union U1 * p_75, union U1 * p_76, uint16_t  p_77, int32_t  p_78);
static union U1 * func_79(union U1 * p_80);
inline static union U1 * func_81(const union U1 * p_82, uint32_t  p_83, union U1 * p_84, uint16_t  p_85);
inline static uint16_t  func_88(uint32_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_29(void)
{ /* block id: 36 */
    int32_t l_40 = 1;
    float l_47 = 0x3.BBD188p+28;
    float l_48 = 0x9.00CE3Dp+55;
    uint32_t l_881 = 0x29A8898D;
    struct S0 **l_884 = (void*)0;
    struct S0 ***l_883 = &l_884;
    struct S0 ****l_882 = &l_883;
    const struct S0 l_891 = {-2659};
    float *l_900 = &l_48;
    (*l_900) = (0x4.EBFB2Cp+67 >= func_30(func_35((l_40 <= ((int16_t)func_43(l_40, l_40, l_40) % (int16_t)((int16_t)(-6) % (int16_t)((+((uint16_t)l_881 + (uint16_t)(l_882 != &l_883))) | 0xCC39)))), l_40, l_881, l_40), l_40, l_891, l_40));
    return l_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const float  func_30(union U1  p_31, int32_t  p_32, const struct S0  p_33, uint32_t  p_34)
{ /* block id: 499 */
    const int32_t l_896 = 0x6C288B1A;
    const int32_t *l_895 = &l_896;
    float l_898 = (-0x1.9p+1);
    float *l_897 = &l_898;
    const int32_t l_899 = 1;
    for (p_31.f0 = (-17); (p_31.f0 >= 46); p_31.f0 += 2)
    { /* block id: 502 */
        int32_t l_894 = (-4);
        if (l_894)
            break;
    }
    l_895 = l_895;
    (*l_897) = __builtin_ctz(p_34);
    return l_899;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_35(uint32_t  p_36, int16_t  p_37, int16_t  p_38, int32_t  p_39)
{ /* block id: 496 */
    float ** const l_885 = (void*)0;
    float l_889 = 0xA.941B74p-43;
    float *l_888 = &l_889;
    float **l_887 = &l_888;
    float ***l_886 = &l_887;
    union U1 l_890 = {0xE9E1};
    (*l_886) = l_885;
    /* statement id: 497 */
    assert (l_887 == 0);
    return l_890;
    /* statement id: 498 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_43(uint32_t  p_44, int32_t  p_45, float  p_46)
{ /* block id: 37 */
    uint16_t l_73 = 0x460D;
    int32_t l_751 = 5;
    int32_t *l_750 = &l_751;
    int32_t *****l_756 = (void*)0;
    float l_767 = 0xC.6DC4F1p+42;
    const float l_768 = 0xF.4C4FE3p+39;
    int32_t l_772 = 0x6E5A8125;
    struct S0 l_775 = {7758};
    struct S0 *l_774 = &l_775;
    union U1 l_804 = {0x680D};
    union U1 *l_803 = &l_804;
    union U1 **l_802 = &l_803;
    union U1 ***l_801 = &l_802;
    union U1 ****l_800 = &l_801;
    struct S0 **l_848 = (void*)0;
    struct S0 ***l_847 = &l_848;
    const int32_t *l_875 = &l_751;
    const int32_t **l_874 = &l_875;
    for (p_44 = (-4); (p_44 >= 36); p_44++)
    { /* block id: 40 */
        struct S0 l_72 = {5070};
        int32_t l_745 = 0xCF949963;
        int32_t *l_746 = (void*)0;
        int32_t *l_747 = (void*)0;
        int32_t l_749 = 0xC5E60CE4;
        int32_t *l_748 = &l_749;
        (*l_748) = (-(int32_t)((((((int16_t)p_44 << (int16_t)((((int16_t)((((65531U ^ (((((int16_t)(((int16_t)(0x1CD4 != ((uint32_t)func_62(func_67(l_72, p_45, l_72.f0, l_73), l_73, p_44, p_44) % (uint32_t)l_73)) << (int16_t)13) > 0U) % (int16_t)65534U) || l_73) > 0xFF442B08) & l_745)) != p_45) && p_45) > 4294967286U) << (int16_t)l_745) >= p_45) != l_73)) < 0x5347CB55) <= p_44) ^ 0x1042) > 0x1DE2));
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_62(uint32_t  p_63, uint16_t  p_64, uint32_t  p_65, float  p_66)
{ /* block id: 346 */
    int16_t l_596 = 0;
    float l_597 = 0x0.Bp-1;
    union U1 l_639 = {65528U};
    union U1 *l_638 = &l_639;
    union U1 **l_637 = &l_638;
    union U1 ***l_636 = &l_637;
    union U1 ****l_635 = &l_636;
    struct S0 l_685 = {4813};
    struct S0 *l_684 = &l_685;
    struct S0 ** const l_683 = &l_684;
    int32_t l_699 = 0xCE69AB97;
    int32_t *l_698 = &l_699;
    int32_t **l_703 = &l_698;
    int32_t ***l_702 = &l_703;
    for (p_63 = 0; (p_63 < 29); p_63 += 2)
    { /* block id: 349 */
        float l_595 = 0x1.847112p-21;
        int32_t l_598 = 0xEEDD2B8B;
        const int32_t *l_602 = &l_598;
        const int32_t **l_601 = &l_602;
        const int32_t ***l_600 = &l_601;
        struct S0 l_609 = {7262};
        union U1 ***l_669 = &l_637;
        float l_704 = 0x1.Ep-1;
        uint32_t l_730 = 0x26F0A6F7;
        uint16_t l_742 = 0x1B85;
        if ((__builtin_parity(l_596) < ((l_598 | l_598) | (((!(l_596 != ((void*)0 != l_600))) ^ __builtin_ctz(l_596)) ^ 0x6FBF9409))))
        { /* block id: 350 */
            const int32_t *l_603 = &l_598;
            const float *l_616 = &l_595;
            const float **l_615 = &l_616;
            l_603 = (*l_601);
            l_598 = 0xCA1A1E9A;
            if (p_65)
            { /* block id: 353 */
                if ((*l_602))
                    break;
            }
            else
            { /* block id: 355 */
                const uint16_t l_612 = 65533U;
                union U1 l_621 = {0U};
                union U1 *l_620 = &l_621;
                int32_t * const l_624 = &l_598;
                for (p_65 = 9; (p_65 > 38); p_65 += 1)
                { /* block id: 358 */
                    struct S0 l_608 = {-6191};
                    union U1 *l_622 = (void*)0;
                    int32_t *l_626 = (void*)0;
                    int32_t **l_625 = &l_626;
                    if (((int16_t)func_67(l_608, (func_67(l_609, (((((int32_t)p_64 + (int32_t)(*l_603)) < l_612) ^ (((int16_t)(((0x35AA < 9) || p_64) || (l_615 != (void*)0)) << (int16_t)14) && l_608.f0)) == p_63), l_608.f0, p_65) <= (*l_603)), p_65, (*l_602)) << (int16_t)l_608.f0))
                    { /* block id: 359 */
                        union U1 l_619 = {7U};
                        union U1 *l_618 = &l_619;
                        union U1 **l_617 = &l_618;
                        (*l_617) = (void*)0;
                        /* statement id: 360 */
                        assert (l_618 == 0);
                        if (p_65)
                            continue;
                    }
                    else
                    { /* block id: 362 */
                        union U1 **l_623 = &l_620;
                        (*l_623) = func_81(func_79(l_620), l_596, l_622, ((void*)0 == (*l_615)));
                        /* statement id: 363 */
                        assert (l_620 == 0);
                    }
                    (*l_625) = l_624;
                    /* statement id: 365 */
                    assert (l_626 == &l_598);
                }
                /* facts after for loop */
                assert (l_620 == 0 || l_620 == &l_621);
            }
        }
        else
        { /* block id: 368 */
            struct S0 *l_659 = &l_609;
            struct S0 **l_658 = &l_659;
            struct S0 ***l_657 = &l_658;
            if (((l_596 > __builtin_ctz(p_64)) > p_65))
            { /* block id: 369 */
                int32_t *l_629 = (void*)0;
                if (((*l_602) & (((int16_t)p_63 >> (int16_t)11) | 0xFC8C08B6)))
                { /* block id: 370 */
                    (**l_600) = l_629;
                    /* statement id: 371 */
                    assert (l_602 == 0);
                    return p_64;
                }
                else
                { /* block id: 373 */
                    float *l_630 = (void*)0;
                    float *l_631 = &l_597;
                    (*l_631) = l_596;
                }
            }
            else
            { /* block id: 376 */
                float l_645 = 0xC.B1F418p+68;
                float *l_650 = &l_597;
                float **l_649 = &l_650;
                float ***l_648 = &l_649;
                for (l_596 = 0; (l_596 > (-10)); l_596 -= 9)
                { /* block id: 379 */
                    union U1 ****l_634 = (void*)0;
                    struct S0 * const *l_662 = &l_659;
                    struct S0 * const **l_661 = &l_662;
                    struct S0 * const ***l_660 = &l_661;
                    l_635 = l_634;
                    /* statement id: 380 */
                    assert (l_635 == 0);
                    for (p_64 = 0; (p_64 < 25); p_64 += 6)
                    { /* block id: 383 */
                        (**l_649) = ((l_596 <= (((float)((!p_65) >= l_596) + (float)l_645) == (((float)((void*)0 == l_648) + (float)__builtin_bswap32(((int16_t)(l_639.f0 || ((uint16_t)((uint32_t)(((*l_602) != (-1)) ^ p_65) + (uint32_t)0xCF6CDC54) >> (uint16_t)0)) >> (int16_t)13))) > (-0x1.9p-1)))) < 0x1.5p-1);
                    }
                    (*l_660) = l_657;
                    /* statement id: 386 */
                    assert (l_661 == &l_658);
                    for (p_65 = 0; (p_65 <= 37); p_65 += 7)
                    { /* block id: 389 */
                        int32_t *l_665 = &l_639.f1;
                        int32_t *l_666 = &l_598;
                        (*l_665) = p_65;
                        /* statement id: 390 */
                                                (*l_666) = (*l_665);
                    }
                }
                /* facts after for loop */
                assert (l_635 == 0 || l_635 == &l_636);
                return p_64;
            }
        }
    }
    (*l_698) = ((uint16_t)0U >> (uint16_t)4);
    (*l_703) = (*l_703);
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_67(struct S0  p_68, uint32_t  p_69, int32_t  p_70, int32_t  p_71)
{ /* block id: 41 */
    const union U1 l_87 = {0U};
    const union U1 *l_86 = &l_87;
    int32_t l_92 = 1;
    union U1 l_190 = {65535U};
    union U1 *l_189 = &l_190;
    union U1 **l_545 = &l_189;
    int32_t *l_553 = &l_92;
    int32_t **l_552 = &l_553;
    int32_t ***l_551 = &l_552;
    struct S0 *l_586 = (void*)0;
    struct S0 **l_585 = &l_586;
    float l_589 = 0xB.C5E591p+19;
    float *l_588 = &l_589;
    float ** const l_587 = &l_588;
    uint16_t l_592 = 65535U;
lbl_572:
    (*l_545) = func_74(func_79(func_81(l_86, (((0x207B8A5F <= 0x6206CBC8) >= p_70) != func_88(((uint16_t)(((&l_87 == (void*)0) & ((l_92 != (((int16_t)(p_71 || (l_87.f0 > 0x4C2E)) >> (int16_t)l_92) != l_92)) >= p_71)) ^ p_70) >> (uint16_t)p_71))), l_189, l_92)), &l_190, l_190.f0, p_71);
    for (l_190.f0 = 24; (l_190.f0 >= 45); l_190.f0 += 6)
    { /* block id: 316 */
        int32_t l_548 = 0x0B5BDC0A;
        int32_t l_549 = 0x66749B94;
        l_549 = l_548;
        if (p_69)
        { /* block id: 318 */
            const uint32_t l_550 = 0x2F114DF0;
            l_549 = (p_71 < l_550);
        }
        else
        { /* block id: 320 */
            uint32_t l_583 = 4294967295U;
            (***l_551) = (((l_551 != &l_552) <= (((int16_t)0xFAA4 + (int16_t)((uint32_t)(-(uint16_t)p_68.f0) - (uint32_t)((uint16_t)l_549 << (uint16_t)7))) <= (***l_551))) > ((p_68.f0 | (((uint16_t)((uint32_t)(l_549 & (((uint16_t)p_68.f0 % (uint16_t)p_70) < l_548)) % (uint32_t)p_70) >> (uint16_t)11) ^ 1U)) != (*l_553)));
            if (((l_548 & (!1U)) & 6))
            { /* block id: 322 */
                uint32_t l_579 = 0x92735655;
                int32_t l_580 = 0;
                int32_t *** const *l_581 = (void*)0;
                for (l_92 = (-4); (l_92 > (-6)); l_92 -= 3)
                { /* block id: 325 */
                    int32_t l_582 = 0x878A801E;
                    int32_t l_584 = 0x02348A51;
                    for (p_69 = (-30); (p_69 == 25); p_69++)
                    { /* block id: 328 */
                        if ((**l_552))
                            break;
                        (*l_552) = (**l_551);
                        if (l_190.f0)
                            goto lbl_572;
                        l_583 = (0x6751C904 >= ((((((int16_t)1 - (int16_t)(p_70 <= (((int32_t)((int32_t)l_579 + (int32_t)(l_580 >= (***l_551))) + (int32_t)((l_581 != (void*)0) & ((*l_553) != 1))) != l_582))) <= (**l_552)) >= 4294967295U) & l_549) < p_68.f0));
                    }
                    if (l_584)
                        break;
                    return p_68.f0;
                }
                return l_548;
            }
            else
            { /* block id: 338 */
                (**l_552) = (l_548 <= p_70);
            }
        }
        (*l_552) = (*l_552);
    }
    (*l_553) = func_88((((void*)0 == l_585) < (((l_587 == &l_588) == ((int16_t)0xC8FE >> (int16_t)l_592)) ^ (**l_552))));
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1 * func_74(union U1 * p_75, union U1 * p_76, uint16_t  p_77, int32_t  p_78)
{ /* block id: 283 */
    int16_t l_470 = (-1);
    int32_t l_471 = 0xFDA9F7B7;
    int32_t l_481 = 1;
    int32_t *l_480 = &l_481;
    int32_t **l_479 = &l_480;
    int32_t ** const *l_478 = &l_479;
    int32_t ** const **l_477 = &l_478;
    int32_t ** const ***l_476 = &l_477;
    union U1 l_520 = {1U};
    union U1 *l_519 = &l_520;
    uint32_t l_523 = 0xA3940CC9;
    if (((uint16_t)(((0xCB063B3B > l_470) == (l_471 | (8 == ((uint16_t)((int16_t)func_88((l_476 != (void*)0)) << (int16_t)(((((((int16_t)(*****l_476) + (int16_t)p_78) | p_77) > (**l_479)) >= (*l_480)) && (****l_477)) | (-2))) >> (uint16_t)(**l_479))))) == (***l_478)) % (uint16_t)0x86B5))
    { /* block id: 284 */
        float l_497 = 0x1.C09184p-61;
        float * const l_496 = &l_497;
        float * const *l_495 = &l_496;
        union U1 l_502 = {0xE985};
        union U1 *l_501 = &l_502;
        int32_t l_512 = 0x71B7427D;
        for (l_470 = (-3); (l_470 <= 26); ++l_470)
        { /* block id: 287 */
            uint32_t l_492 = 0x6D403725;
            int32_t ***l_494 = &l_479;
            int32_t ****l_493 = &l_494;
            union U1 *l_503 = &l_502;
            union U1 **l_507 = &l_501;
            union U1 ** const *l_506 = &l_507;
            float *l_510 = (void*)0;
            (****l_477) = ((uint32_t)(0xD4B7 > ((int32_t)((uint16_t)((****l_477) || 0x6E40) << (uint16_t)(0x5479 < l_492)) - (int32_t)(l_493 != (*l_476)))) - (uint32_t)(l_495 != (void*)0));
            if (((((**l_479) >= p_78) || (p_77 || (-(uint32_t)((0xF074DAA3 != (**l_479)) | (((((uint16_t)(l_501 != l_503) << (uint16_t)7) != (p_77 != p_78)) == p_77) < p_77))))) != p_77))
            { /* block id: 289 */
                return p_75;
                /* statement id: 290 */
                //assert (func_74_rv == &l_190);
            }
            else
            { /* block id: 291 */
                int32_t *l_511 = &l_481;
                (**l_495) = (((float)((void*)0 == l_506) + (float)((((float)0x9.642853p+48 - (float)((****l_477) == (l_510 == l_480))) == (**l_479)) >= (0xA.471A9Ap+9 >= __builtin_ctzll((***l_494))))) >= (***l_494));
                (**l_478) = (**l_494);
                (***l_477) = l_511;
                (*l_480) = __builtin_parity((p_78 <= l_502.f0));
            }
        }
        (*l_496) = (l_512 < (((float)l_512 - (float)0xA.7AADFBp-5) != ((p_78 < p_77) <= ((float)(****l_477) + (float)(((****l_477) >= (p_78 >= ((****l_477) == p_77))) != (-0x1.9p+1))))));
        for (l_512 = 0; (l_512 < 17); l_512 += 8)
        { /* block id: 301 */
            (**l_478) = (****l_476);
            return p_76;
            /* statement id: 303 */
            //assert (func_74_rv == &l_190);
        }
    }
    else
    { /* block id: 305 */
        const float l_526 = 0x0.Cp+1;
        int32_t l_527 = 0xE5B9472A;
        int32_t ***l_541 = &l_479;
        union U1 **l_542 = (void*)0;
        union U1 **l_543 = &l_519;
        (****l_477) = ((uint16_t)(((*****l_476) ^ (((l_523 ^ (((int32_t)l_527 % (int32_t)((uint16_t)p_77 + (uint16_t)(func_88(p_78) < (~((uint16_t)(__builtin_clzl(((0x580E && (__builtin_ffs(((int32_t)(p_78 && ((uint32_t)((uint16_t)((int16_t)(l_541 != l_541) + (int16_t)0x3657) << (uint16_t)3) % (uint32_t)(*l_480))) - (int32_t)(*l_480))) == 0xA946E749)) ^ (*l_480))) >= p_78) >> (uint16_t)4))))) ^ 65535U)) < p_77) == p_78)) || (***l_541)) >> (uint16_t)p_77);
        if (l_527)
            goto lbl_544;
        (***l_478) = func_88((1 || p_78));
lbl_544:
        (*l_543) = &l_520;
        (**l_541) = (**l_541);
    }
    return p_76;
    /* statement id: 312 */
    //assert (func_74_rv == &l_190);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1 * func_79(union U1 * p_80)
{ /* block id: 140 */
    int32_t l_204 = 0x2C60FB40;
    union U1 ***l_232 = (void*)0;
    int32_t l_242 = (-1);
    int32_t *l_241 = &l_242;
    uint16_t l_281 = 8U;
    int32_t **l_341 = &l_241;
    int32_t ***l_340 = &l_341;
    uint16_t l_391 = 65535U;
    int32_t * const ***l_398 = (void*)0;
    int32_t * const ****l_397 = &l_398;
    struct S0 ***l_421 = (void*)0;
    struct S0 l_426 = {8150};
    struct S0 *l_425 = &l_426;
    struct S0 **l_424 = &l_425;
    const int32_t *l_456 = &l_242;
    float l_465 = 0x2.939953p-52;
    float *l_464 = &l_465;
    float **l_463 = &l_464;
    float ***l_462 = &l_463;
    for (l_204 = 19; (l_204 <= (-11)); l_204--)
    { /* block id: 143 */
        int32_t **l_207 = (void*)0;
        int32_t **l_208 = (void*)0;
        int32_t *l_210 = &l_204;
        int32_t **l_209 = &l_210;
        int32_t l_211 = (-1);
        int32_t ***l_229 = &l_207;
        int32_t ****l_228 = &l_229;
        struct S0 l_259 = {-7094};
        struct S0 *l_258 = &l_259;
        struct S0 **l_257 = &l_258;
        struct S0 ***l_256 = &l_257;
        uint16_t l_280 = 0x9D97;
        union U1 l_286 = {65529U};
        union U1 *l_285 = &l_286;
        union U1 **l_284 = &l_285;
        union U1 ***l_283 = &l_284;
        int32_t *l_289 = &l_286.f1;
        (*l_209) = &l_204;
        for (l_211 = (-5); (l_211 == 28); l_211++)
        { /* block id: 147 */
            int16_t l_216 = 0x1977;
            int32_t *l_251 = (void*)0;
            union U1 ***l_282 = (void*)0;
            int32_t l_304 = 0;
            struct S0 *l_318 = (void*)0;
            int32_t *l_327 = &l_204;
        }
    }
    if ((l_241 == (void*)0))
    { /* block id: 203 */
        float l_364 = 0x0.2C63C9p+14;
        float *l_363 = &l_364;
        const int32_t l_366 = 0x4C57F72F;
        uint32_t l_367 = 0x53CF452A;
        const int32_t *l_396 = &l_366;
        const int32_t **l_395 = &l_396;
        const int32_t ***l_394 = &l_395;
        const int32_t *** const *l_393 = &l_394;
        const int32_t *** const **l_392 = &l_393;
        struct S0 ***l_409 = (void*)0;
        const uint16_t l_430 = 0U;
lbl_399:
        for (l_204 = 24; (l_204 != (-24)); l_204 -= 1)
        { /* block id: 206 */
            uint16_t l_334 = 0x140D;
            int32_t * const **l_339 = (void*)0;
            int32_t l_342 = 0xD4169CB3;
            struct S0 l_354 = {1313};
            struct S0 *l_353 = &l_354;
            struct S0 **l_352 = &l_353;
            union U1 ***l_379 = (void*)0;
            union U1 l_383 = {1U};
            union U1 *l_382 = &l_383;
            union U1 **l_381 = &l_382;
            union U1 ***l_380 = &l_381;
        }
        if (((void*)0 != &l_366))
        { /* block id: 240 */
            float l_386 = (-0x8.2p-1);
            int32_t l_387 = 0x11FD18A2;
            if (((uint16_t)1U >> (uint16_t)(**l_341)))
            { /* block id: 241 */
                struct S0 l_389 = {3291};
                struct S0 *l_388 = &l_389;
                int32_t l_390 = 0x037B79DA;
                (*l_241) = l_387;
                l_388 = l_388;
                l_390 = (*l_241);
                (*l_363) = (__builtin_ffsll(l_391) <= (l_389.f0 == __builtin_ffsll((l_392 == l_397))));
            }
            else
            { /* block id: 246 */
                if (l_387)
                    goto lbl_399;
                (*l_241) = __builtin_bswap32((((uint16_t)(**l_341) << (uint16_t)0) && (!0x8E46)));
            }
        }
        else
        { /* block id: 250 */
            int32_t l_411 = 0x994A519D;
            float **l_414 = &l_363;
            struct S0 **l_427 = &l_425;
            int32_t l_445 = (-7);
            if (func_88((((int32_t)(*****l_392) + (int32_t)0xCA4D006B) == (((uint32_t)__builtin_clzl((*l_396)) - (uint32_t)((((uint16_t)((void*)0 != l_409) << (uint16_t)((!(*****l_392)) == (0x4FC5 <= l_411))) >= 65526U) != l_411)) >= (**l_395)))))
            { /* block id: 251 */
                int32_t ****l_412 = &l_340;
                int32_t *****l_413 = &l_412;
                float * const *l_416 = (void*)0;
                float * const **l_415 = &l_416;
                struct S0 l_420 = {7694};
                struct S0 *l_419 = &l_420;
                struct S0 **l_418 = &l_419;
                struct S0 ***l_417 = &l_418;
                (*l_413) = l_412;
                (*l_415) = l_414;
                /* statement id: 253 */
                assert (l_416 == &l_363);
                (**l_341) = func_88(((l_417 == l_421) < ((***l_340) & ((int32_t)l_411 - (int32_t)((*****l_392) <= (1U != ((4294967291U >= (l_424 != l_427)) & (*l_396))))))));
                (***l_340) = ((void*)0 == (*l_417));
            }
            else
            { /* block id: 256 */
                const uint32_t l_431 = 0x9A409E23;
                int32_t *l_442 = &l_242;
                float l_455 = 0x2.FE5F78p-45;
                (**l_340) = (**l_340);
                if (((uint16_t)((l_430 != l_431) & ((**l_341) == ((((int16_t)(-1) % (int16_t)((int32_t)((***l_394) && (****l_393)) - (int32_t)l_431)) != ((((uint16_t)func_88((((l_241 != l_241) | l_431) < (**l_395))) << (uint16_t)l_411) | (-1)) ^ (**l_395))) != (**l_341)))) << (uint16_t)14))
                { /* block id: 258 */
                    for (l_367 = 0; (l_367 != 45); l_367 += 5)
                    { /* block id: 261 */
                        (*l_341) = l_442;
                    }
                }
                else
                { /* block id: 264 */
                    const float l_443 = (-0x1.Cp-1);
                    int32_t l_444 = 0xAA079075;
                    l_444 = (l_443 >= 0x0.9p-1);
                    if ((((func_88((((2 && (0x4CAF > l_444)) | (((void*)0 == &p_80) == __builtin_clzll((***l_394)))) > (*l_442))) < 1) && (**l_341)) == l_445))
                    { /* block id: 266 */
                        float l_451 = 0xD.D9B5BCp+45;
                        int32_t l_452 = (-1);
                        (**l_414) = ((float)(((void*)0 != &l_398) > ((float)((((-(float)0x3.9p+1) == ((*l_394) == (void*)0)) < l_451) == (*l_442)) + (float)l_444)) - (float)((l_452 == 0xA.548FFBp-56) >= 0x3.BE3FEFp+32));
                        l_442 = l_442;
                        (*l_241) = ((__builtin_clz((((0xCBAA != 65535U) < (((&l_444 != &l_445) | ((**l_341) <= (l_445 < 0xF93242E5))) == __builtin_popcountll(l_411))) < 3)) | l_452) ^ 0U);
                        l_456 = (**l_394);
                        /* statement id: 270 */
                        assert (l_456 == &l_366);
                    }
                    else
                    { /* block id: 271 */
                        (**l_394) = &l_444;
                        /* statement id: 272 */
                        assert (l_396 == &l_444);
                        (*l_427) = (*l_427);
                    }
                    /* facts after branching */
                    assert (l_396 == &l_444 || l_396 == &l_366);
                    assert (l_456 == &l_242 || l_456 == &l_366);
                }
                /* facts after branching */
                //assert (l_396 == dangling || l_396 == &l_366);
                assert (l_456 == &l_242 || l_456 == &l_366);
            }
            /* facts after branching */
            //assert (l_396 == dangling || l_396 == &l_366);
            assert (l_456 == &l_242 || l_456 == &l_366);
        }
        /* facts after branching */
        //assert (l_396 == dangling || l_396 == &l_366);
        assert (l_456 == &l_242 || l_456 == &l_366);
    }
    else
    { /* block id: 278 */
        uint16_t l_461 = 0U;
        union U1 l_467 = {65531U};
        union U1 *l_466 = &l_467;
        (*l_464) = __builtin_ffs(((int16_t)((**l_341) != ((((-5) || ((int32_t)(l_461 && (((0xB627779F & ((void*)0 != l_462)) != ((l_461 == (**l_341)) < l_461)) >= 0x58383D20)) - (int32_t)l_461)) >= 0xA815386C) < l_461)) - (int16_t)(*l_241)));
        return p_80;
        /* statement id: 280 */
        //assert (func_79_rv == &l_190 || func_79_rv == &l_621 || func_79_rv == 0);
    }
    /* facts after branching */
    //assert (l_456 == &l_242 || l_456 == dangling);
    return p_80;
    /* statement id: 282 */
    //assert (func_79_rv == &l_190 || func_79_rv == &l_621 || func_79_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1 * func_81(const union U1 * p_82, uint32_t  p_83, union U1 * p_84, uint16_t  p_85)
{ /* block id: 128 */
    int32_t **l_193 = (void*)0;
    int32_t ***l_192 = &l_193;
    int32_t ****l_191 = &l_192;
    if (p_85)
    { /* block id: 129 */
        int32_t *** const *l_195 = &l_192;
        int32_t *** const **l_194 = &l_195;
        int32_t *l_196 = (void*)0;
        int32_t *l_197 = (void*)0;
        int32_t *l_198 = (void*)0;
        int32_t *l_199 = (void*)0;
        int32_t l_201 = 0xC38B9561;
        int32_t *l_200 = &l_201;
        (*l_194) = l_191;
        (*l_200) = p_85;
    }
    else
    { /* block id: 132 */
        for (p_83 = 25; (p_83 != 26); ++p_83)
        { /* block id: 135 */
            if (p_83)
                break;
        }
    }
    return p_84;
    /* statement id: 139 */
    //assert (func_81_rv == &l_190 || func_81_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_88(uint32_t  p_89)
{ /* block id: 42 */
    int32_t l_95 = 0x4CEB0392;
    union U1 l_102 = {0xF610};
    union U1 *l_101 = &l_102;
    union U1 **l_100 = &l_101;
    int32_t *l_115 = &l_102.f1;
    int32_t l_134 = (-10);
    float l_188 = 0x0.1p-1;
    float *l_187 = &l_188;
    if ((l_95 || l_95))
    { /* block id: 43 */
        union U1 l_98 = {4U};
        union U1 *l_97 = &l_98;
        union U1 **l_96 = &l_97;
        union U1 ***l_99 = (void*)0;
        int32_t l_104 = 1;
        int32_t *l_103 = &l_104;
        int32_t **l_105 = &l_103;
        l_100 = l_96;
        /* statement id: 44 */
        assert (l_100 == &l_97);
        (*l_105) = l_103;
        (*l_100) = (void*)0;
        /* statement id: 46 */
        assert (l_97 == 0);
        (**l_105) = (p_89 | (p_89 >= __builtin_popcountl(p_89)));
    }
    else
    { /* block id: 48 */
        union U1 *l_119 = &l_102;
        struct S0 l_121 = {-3475};
        struct S0 *l_120 = &l_121;
        union U1 *l_152 = &l_102;
        int16_t l_153 = 0;
        int32_t **l_172 = &l_115;
        int32_t *l_186 = &l_102.f1;
        for (p_89 = (-24); (p_89 > 11); p_89 += 5)
        { /* block id: 51 */
            int32_t *l_108 = &l_102.f1;
            union U1 *l_109 = &l_102;
            (*l_108) = 0;
            /* statement id: 52 */
                        (*l_100) = l_109;
        }
        for (p_89 = 0; (p_89 != 5); p_89 += 5)
        { /* block id: 57 */
            int32_t *l_114 = &l_102.f1;
            int32_t **l_116 = &l_114;
            struct S0 *l_132 = (void*)0;
            float l_143 = 0x7.C11101p-77;
            float *l_142 = &l_143;
            (*l_114) = ((uint16_t)0x0D3B << (uint16_t)2);
            /* statement id: 58 */
                        (*l_116) = l_115;
            for (l_102.f1 = (-15); (l_102.f1 > (-9)); l_102.f1 += 7)
            { /* block id: 62 */
                const struct S0 **l_122 = (void*)0;
                struct S0 **l_133 = &l_120;
                (*l_100) = l_119;
                l_120 = l_120;
                for (l_95 = 0; (l_95 >= 5); l_95 += 7)
                { /* block id: 67 */
                    int32_t l_125 = 0;
                    for (l_125 = 0; (l_125 > 21); l_125++)
                    { /* block id: 70 */
                        float *l_128 = (void*)0;
                        float *l_129 = (void*)0;
                        float l_131 = (-0x6.9p-1);
                        float *l_130 = &l_131;
                        if (p_89)
                            break;
                        (*l_130) = 0x0.Fp+1;
                        (*l_100) = (*l_100);
                    }
                }
                (*l_133) = l_132;
                /* statement id: 76 */
                assert (l_120 == 0);
            }
            (*l_142) = (l_134 == ((__builtin_ctzl(p_89) > 0x6.9E5B73p+64) < (+((p_89 == (l_121.f0 != (((float)__builtin_ffsl(((((int16_t)((0x76A7 <= ((*l_115) < ((uint16_t)p_89 << (uint16_t)3))) == 1U) + (int16_t)(-1)) | 0x8E4F) > 1U)) + (float)p_89) < p_89))) > (*l_115)))));
        }
        /* facts after for loop */
        assert (l_120 == 0 || l_120 == &l_121);
        if ((((int32_t)((uint16_t)(0x2B86 == ((-(int32_t)((((~((uint16_t)p_89 << (uint16_t)4)) != (l_152 == l_119)) && (l_121.f0 && (l_153 < ((((((uint16_t)0U + (uint16_t)l_153) <= l_153) | l_153) <= 0x355696F0) & l_121.f0)))) && p_89)) ^ l_121.f0)) % (uint16_t)p_89) % (int32_t)0x321B6B7D) & l_95))
        { /* block id: 80 */
            for (l_134 = 0; (l_134 == (-5)); l_134 -= 9)
            { /* block id: 83 */
                return p_89;
            }
        }
        else
        { /* block id: 86 */
            int32_t **l_167 = &l_115;
            union U1 * const l_170 = (void*)0;
            int32_t l_175 = 0x7022D3B1;
            if (__builtin_popcount(p_89))
            { /* block id: 87 */
                float l_159 = 0x9.F0B25Dp-59;
                float *l_158 = &l_159;
                struct S0 * const *l_160 = &l_120;
                struct S0 **l_162 = &l_120;
                struct S0 ***l_161 = &l_162;
                (*l_158) = p_89;
                (*l_161) = l_160;
                if (l_121.f0)
                { /* block id: 90 */
                    return l_121.f0;
                }
                else
                { /* block id: 92 */
                    uint16_t l_163 = 65531U;
                    int32_t *l_171 = &l_102.f1;
                    if ((p_89 & p_89))
                    { /* block id: 93 */
                        (*l_115) = l_163;
                        /* statement id: 94 */
                                                (*l_158) = ((float)(+((l_167 == (void*)0) != p_89)) - (float)l_121.f0);
                    }
                    else
                    { /* block id: 96 */
                        int32_t l_169 = 2;
                        int32_t *l_168 = &l_169;
                        (*l_158) = 0x0.2p+1;
                        (*l_167) = l_168;
                        /* statement id: 98 */
                        assert (l_115 == &l_169);
                    }
                    /* facts after branching */
                    //assert (l_115 == dangling || l_115 == &l_102.f1);
                    (*l_171) = (l_152 == l_170);
                    /* statement id: 100 */
                                        (*l_171) = (p_89 >= p_89);
                }
                /* facts after branching */
                                //assert (l_115 == dangling || l_115 == &l_102.f1);
            }
            else
            { /* block id: 103 */
                uint16_t l_182 = 65535U;
                if ((&l_115 == l_172))
                { /* block id: 104 */
                    const uint16_t l_178 = 65535U;
                    float l_181 = 0x6.71F1E8p-74;
                    for (l_134 = 0; (l_134 <= (-8)); l_134 -= 2)
                    { /* block id: 107 */
                        float l_177 = 0xC.FD3A0Bp-97;
                        float *l_176 = &l_177;
                        (*l_176) = ((-0x1.Bp+1) <= l_175);
                        (**l_172) = (-1);
                        /* statement id: 109 */
                                            }
                    (**l_172) = (l_178 ^ p_89);
                    /* statement id: 111 */
                                        for (l_102.f1 = (-8); (l_102.f1 == (-21)); l_102.f1 -= 2)
                    { /* block id: 114 */
                        int32_t ***l_184 = &l_172;
                        int32_t ****l_183 = &l_184;
                        l_182 = l_181;
                        (*l_183) = &l_172;
                    }
                }
                else
                { /* block id: 118 */
                    (*l_115) = p_89;
                    /* statement id: 119 */
                                        return p_89;
                }
                /* facts after branching */
                            }
            /* facts after branching */
                        //assert (l_115 == dangling || l_115 == &l_102.f1);
        }
        /* facts after branching */
        //assert (l_115 == dangling || l_115 == &l_102.f1);
        (*l_186) = (~((&l_119 != (void*)0) || (p_89 && (l_152 != (void*)0))));
        /* statement id: 124 */
            }
    /* facts after branching */
    //assert (l_100 == &l_101 || l_100 == dangling);
    //assert (l_115 == dangling || l_115 == &l_102.f1);
    (*l_187) = (-0x2.Ap+1);
    return p_89;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 216
   depth: 1, occurrence: 5
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 9
   indirect level: 3, occurrence: 8
   indirect level: 4, occurrence: 1
XXX full-bitfields structs in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 14
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 18

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 181
   depth: 2, occurrence: 43
   depth: 3, occurrence: 3
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 4
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 270

XXX times a variable address is taken: 240
XXX times a pointer is dereferenced on RHS: 155
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 42
   depth: 3, occurrence: 18
   depth: 4, occurrence: 8
   depth: 5, occurrence: 5
XXX times a pointer is dereferenced on LHS: 135
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 20
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 38
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 22
XXX times a pointer is qualified to be dereferenced: 478

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 364
   level: 2, occurrence: 162
   level: 3, occurrence: 86
   level: 4, occurrence: 31
   level: 5, occurrence: 21
XXX number of pointers point to pointers: 143
XXX number of pointers point to scalars: 81
XXX number of pointers point to structs: 16
XXX percent of pointers has null in alias set: 24.8
XXX average alias set size: 1.19

XXX times a non-volatile is read: 1091
XXX times a non-volatile is write: 379
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 7

XXX stmts: 168
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 31
   depth: 2, occurrence: 22
   depth: 3, occurrence: 34
   depth: 4, occurrence: 25
   depth: 5, occurrence: 28

XXX percentage a fresh-made variable is used: 25.5
XXX percentage an existing variable is used: 74.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

