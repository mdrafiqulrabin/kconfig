/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      865593568
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 30;
   unsigned f1 : 27;
   signed f2 : 17;
};
#pragma pack(pop)

union U1 {
   uint32_t  f0;
   uint16_t  f1;
   const uint32_t  f2;
   const uint32_t  f3;
};

union U2 {
   uint32_t  f0;
   uint32_t  f1;
};

union U3 {
   const uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
inline static const uint16_t  func_13(int32_t  p_14, int8_t  p_15, union U3  p_16, uint32_t  p_17, uint16_t  p_18);
static int32_t  func_27(uint8_t  p_28, int32_t  p_29, int16_t  p_30);
static int32_t  func_37(union U2 ** p_38, int32_t  p_39);
inline static union U2 ** func_40(uint8_t  p_41, uint8_t  p_42, struct S0  p_43, uint16_t  p_44);
static struct S0  func_45(const union U2 * const * p_46, union U2 * const * p_47, union U2 * p_48);
inline static const union U2 ** func_49(uint32_t  p_50, int8_t  p_51, int32_t  p_52, union U2  p_53);
static union U2  func_55(int32_t  p_56, union U2 * p_57, const uint32_t  p_58, union U2 * p_59);
inline static uint8_t  func_73(union U2 * p_74);
inline static int8_t  func_80(uint16_t  p_81, uint32_t  p_82, union U2 * p_83, uint32_t  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0xDED68044;
    int16_t l_5 = 0x58E1;
    uint16_t l_6 = 65535U;
    union U2 **l_299 = (void*)0;
    union U3 l_301 = {6U};
lbl_415:
    for (l_2 = (-17); (l_2 <= 15); ++l_2)
    { /* block id: 3 */
        return l_2;
    }
    l_2 = l_2;
    if (l_2)
        goto lbl_7;
lbl_7:
    l_6 = (0x3358 | l_5);
    for (l_5 = (-6); (l_5 == 18); l_5 = safe_add_func_int32_t_s_s(l_5, 9))
    { /* block id: 11 */
        int32_t l_31 = (-5);
        int16_t l_300 = 0xFD01;
        union U1 l_417 = {4294967293U};
        union U1 *l_416 = &l_417;
        int32_t *l_422 = &l_2;
        if ((~(safe_div_func_uint32_t_u_u(((func_13((safe_add_func_int16_t_s_s((safe_mod_func_uint8_t_u_u((safe_add_func_int16_t_s_s((((safe_sub_func_int32_t_s_s(func_27(l_31, l_31, l_2), l_31)) < (!((l_31 > (safe_mod_func_uint32_t_u_u(l_31, ((safe_mod_func_uint32_t_u_u(((l_31 > ((void*)0 != l_299)) != l_2), 4294967288U)) && l_5)))) || l_31))) >= l_5), l_300)), 1U)), l_5)), l_300, l_301, l_301.f0, l_300) == 0x5A89) ^ 248U), l_300))))
        { /* block id: 162 */
            int32_t *l_412 = &l_31;
            for (l_300 = 29; (l_300 < 22); l_300 = safe_sub_func_uint8_t_u_u(l_300, 5))
            { /* block id: 165 */
                const int32_t *l_414 = &l_2;
                const int32_t **l_413 = &l_414;
                (*l_413) = l_412;
                /* statement id: 166 */
                assert (l_414 == &l_31);
            }
        }
        else
        { /* block id: 168 */
            union U1 **l_418 = &l_416;
            if (l_5)
                goto lbl_415;
            (*l_418) = l_416;
        }
        for (l_300 = (-10); (l_300 > (-29)); l_300--)
        { /* block id: 174 */
            int32_t *l_421 = &l_2;
            (*l_421) = l_6;
            l_422 = l_421;
        }
    }
    return l_301.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_13(int32_t  p_14, int8_t  p_15, union U3  p_16, uint32_t  p_17, uint16_t  p_18)
{ /* block id: 105 */
    union U2 l_307 = {0x5CD96861};
    union U2 *l_306 = &l_307;
    union U2 **l_305 = &l_306;
    union U2 ***l_304 = &l_305;
    struct S0 l_314 = {-7562,4848,24};
    struct S0 *l_313 = &l_314;
    struct S0 **l_312 = &l_313;
    int32_t l_319 = 0;
    int32_t *l_318 = &l_319;
    union U3 l_322 = {7U};
    union U3 *l_321 = &l_322;
    uint32_t l_340 = 3U;
    union U1 *l_353 = (void*)0;
    union U1 **l_352 = &l_353;
    uint16_t l_377 = 65526U;
    int32_t l_386 = (-8);
    struct S0 * const *l_407 = &l_313;
    struct S0 * const **l_406 = &l_407;
    struct S0 * const ***l_405 = &l_406;
    struct S0 * const ****l_404 = &l_405;
    int32_t l_408 = 0xA7871D96;
    int8_t l_409 = 0;
    if ((safe_div_func_int8_t_s_s((l_304 != &l_305), (safe_div_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(l_307.f1, (l_312 == &l_313))), (safe_sub_func_uint32_t_u_u(l_307.f1, 0)))))))
    { /* block id: 106 */
        const int8_t l_317 = (-9);
        return l_317;
    }
    else
    { /* block id: 108 */
        int32_t *l_320 = &l_319;
        union U3 **l_323 = &l_321;
        int32_t l_379 = 0xC5604E1A;
        const struct S0 *l_380 = &l_314;
        l_320 = l_318;
        if (l_307.f1)
            goto lbl_324;
lbl_324:
        (*l_323) = l_321;
        for (l_319 = (-17); (l_319 > 15); l_319 = safe_add_func_int32_t_s_s(l_319, 2))
        { /* block id: 114 */
            int32_t **l_332 = &l_320;
            int32_t ***l_331 = &l_332;
            int32_t ****l_330 = &l_331;
            uint16_t l_378 = 0x5290;
            struct S0 **l_381 = &l_313;
            for (p_15 = 25; (p_15 > (-26)); p_15 = safe_sub_func_uint16_t_u_u(p_15, 1))
            { /* block id: 117 */
                uint32_t l_333 = 1U;
                int32_t **** const l_334 = &l_331;
                int32_t *****l_335 = &l_330;
                union U2 ****l_337 = (void*)0;
                union U2 *****l_336 = &l_337;
                l_333 = (safe_unary_minus_func_int16_t_s((0xD029318B & (l_330 == &l_331))));
                (*l_335) = l_334;
                (*l_336) = &l_304;
                /* statement id: 120 */
                assert (l_337 == &l_304);
            }
            for (p_14 = 0; (p_14 < (-1)); p_14--)
            { /* block id: 124 */
                int32_t *l_341 = (void*)0;
                int32_t l_343 = 0x342FEDE2;
                int32_t *l_342 = &l_343;
                union U2 ****l_344 = (void*)0;
                if ((***l_331))
                    break;
                (*l_342) = l_340;
                (*l_332) = &l_319;
                if (((void*)0 == l_344))
                { /* block id: 128 */
                    int32_t l_350 = (-1);
                    if ((safe_add_func_uint32_t_u_u((safe_add_func_uint8_t_u_u(0x2F, p_15)), (safe_unary_minus_func_int32_t_s(1)))))
                    { /* block id: 129 */
                        (*l_342) = l_350;
                        if (p_14)
                            continue;
                        if (p_17)
                            continue;
                    }
                    else
                    { /* block id: 133 */
                        struct S0 l_351 = {-1448,6002,304};
                        union U1 ***l_354 = &l_352;
                        struct S0 ****l_355 = (void*)0;
                        struct S0 ***l_357 = (void*)0;
                        struct S0 ****l_356 = &l_357;
                        (**l_312) = l_351;
                        (*l_354) = l_352;
                        (*l_356) = &l_312;
                        /* statement id: 136 */
                        assert (l_357 == &l_312);
                        (***l_330) = (void*)0;
                        /* statement id: 137 */
                        assert (l_320 == 0);
                    }
                    /* facts after branching */
                    assert (l_320 == 0 || l_320 == &l_319);
                    return l_350;
                }
                else
                { /* block id: 140 */
                    const uint8_t l_360 = 0x93;
                    for (l_307.f0 = 0; (l_307.f0 < 13); l_307.f0 = safe_add_func_int32_t_s_s(l_307.f0, 1))
                    { /* block id: 143 */
                        return l_360;
                    }
                }
            }
            l_379 = (7U == ((safe_lshift_func_uint16_t_u_u((*l_320), ((((**l_332) | (4294967295U >= (safe_add_func_uint16_t_u_u((**l_332), (safe_lshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((****l_330), ((safe_mod_func_int16_t_s_s((safe_mod_func_int8_t_s_s((4U & (safe_div_func_uint32_t_u_u(((safe_lshift_func_int8_t_s_u(((*l_312) == (void*)0), 1)) || l_377), p_18))), l_378)), 0xAE39)) == p_16.f0))), 5)))))) < 0xF2) == p_14))) || p_16.f0));
            (*l_381) = l_380;
        }
        if ((((&l_353 != &l_353) == 0) ^ ((safe_rshift_func_uint8_t_u_s(l_386, 7)) >= (*l_318))))
        { /* block id: 151 */
            int32_t *l_387 = &l_379;
            const int32_t *l_389 = &l_319;
            const int32_t **l_388 = &l_389;
            (*l_388) = l_387;
            /* statement id: 152 */
            assert (l_389 == &l_379);
            (*l_388) = &l_379;
            (*l_320) = p_18;
        }
        else
        { /* block id: 155 */
            const int32_t *l_393 = &l_319;
            const int32_t **l_392 = &l_393;
            const int32_t ***l_391 = &l_392;
            const int32_t ****l_390 = &l_391;
            (*l_318) = ((l_390 != (void*)0) || (*l_318));
        }
    }
    (*l_318) = (((void*)0 != &l_322) || ((1U == 1U) || ((safe_add_func_uint32_t_u_u((1U ^ ((~(!0xE20B)) != ((((0xD151 > (((safe_div_func_int16_t_s_s((safe_mod_func_int16_t_s_s(((l_404 != &l_405) > (*l_318)), p_14)), 0xE056)) == (*l_318)) != l_408)) < p_18) >= (*l_318)) < l_409))), (*l_318))) && p_18)));
    (**l_304) = (void*)0;
    /* statement id: 160 */
    assert (l_306 == 0);
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_27(uint8_t  p_28, int32_t  p_29, int16_t  p_30)
{ /* block id: 12 */
    union U2 l_34 = {0x4D996497};
    union U2 *l_33 = &l_34;
    union U2 **l_32 = &l_33;
    int32_t ***l_272 = (void*)0;
    int32_t l_290 = 5;
    int32_t *l_291 = &l_290;
    struct S0 l_292 = {-1706,6478,215};
    struct S0 *l_293 = &l_292;
    (*l_32) = (void*)0;
    /* statement id: 13 */
    assert (l_33 == 0);
    if ((safe_lshift_func_uint8_t_u_s(((*l_32) != (*l_32)), 6)))
    { /* block id: 14 */
        uint8_t l_54 = 253U;
        union U2 *l_60 = (void*)0;
        int8_t l_273 = 0xD2;
        if (func_37(func_40(l_34.f1, l_34.f0, func_45(func_49(p_28, l_54, l_34.f0, func_55(l_34.f1, l_60, (safe_rshift_func_int16_t_s_u((safe_rshift_func_uint8_t_u_s((p_29 ^ (0x85 < p_30)), 3)), 15)), (*l_32))), &l_60, l_60), l_34.f0), l_54))
        { /* block id: 92 */
            return l_54;
        }
        else
        { /* block id: 94 */
            int32_t l_258 = (-8);
            int32_t *l_257 = &l_258;
            int32_t **l_256 = &l_257;
            union U2 **l_269 = &l_33;
            (*l_256) = &p_29;
            /* statement id: 95 */
            assert (l_257 == &p_29);
            (*l_257) = (safe_sub_func_int8_t_s_s((((safe_add_func_int16_t_s_s(p_28, (safe_mod_func_uint32_t_u_u(((l_54 > ((safe_lshift_func_int8_t_s_u(((((&p_29 == (*l_256)) > l_54) <= ((p_30 < (&l_33 == l_269)) & (safe_rshift_func_uint16_t_u_s((l_272 != (void*)0), (**l_256))))) | p_29), l_54)) != p_29)) | p_28), l_54)))) <= l_54) ^ p_28), (**l_256)));
            return l_273;
        }
    }
    else
    { /* block id: 99 */
        int32_t ****l_275 = &l_272;
        int32_t *****l_274 = &l_275;
        (*l_274) = (void*)0;
        /* statement id: 100 */
        assert (l_275 == 0);
    }
    (*l_291) = (safe_lshift_func_uint16_t_u_s(5U, (((safe_add_func_uint32_t_u_u(0x880BC6D3, 4294967292U)) == (safe_mod_func_int16_t_s_s((safe_div_func_int8_t_s_s(l_34.f1, p_28)), (safe_div_func_uint32_t_u_u((((l_34.f0 != ((((safe_rshift_func_uint8_t_u_u((0x89C927E8 > l_34.f0), 1)) <= ((safe_rshift_func_uint16_t_u_u((p_29 || l_290), p_29)) <= p_29)) >= l_290) || p_29)) || 65535U) > 0x41E9), 1U))))) <= 1U)));
    (*l_293) = l_292;
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_37(union U2 ** p_38, int32_t  p_39)
{ /* block id: 72 */
    const struct S0 l_221 = {-5002,3122,-126};
    int8_t l_239 = 0x96;
    union U2 l_241 = {4294967293U};
    union U2 *l_240 = &l_241;
    uint8_t l_245 = 1U;
    struct S0 l_247 = {-19992,4744,-83};
    struct S0 *l_246 = &l_247;
    int32_t *l_252 = (void*)0;
    int32_t l_254 = 0x8CC6768E;
    int32_t *l_253 = &l_254;
    for (p_39 = 22; (p_39 == (-22)); p_39 = safe_sub_func_int32_t_s_s(p_39, 9))
    { /* block id: 75 */
        struct S0 l_220 = {10643,11465,142};
        struct S0 *l_219 = &l_220;
        struct S0 **l_218 = &l_219;
        struct S0 ***l_217 = &l_218;
        struct S0 ****l_216 = &l_217;
        struct S0 *****l_215 = &l_216;
        union U1 l_229 = {7U};
        union U1 *l_228 = &l_229;
        union U1 **l_230 = &l_228;
        if ((l_215 != &l_216))
        { /* block id: 76 */
            const int16_t l_222 = 0xBAE7;
            int32_t *l_223 = (void*)0;
            int32_t l_225 = 0x624557DD;
            int32_t *l_224 = &l_225;
            int32_t **l_226 = &l_223;
            (*l_219) = l_221;
            (*l_224) = (l_220.f0 >= l_222);
            if (l_220.f2)
                continue;
            (*l_226) = &p_39;
            /* statement id: 80 */
            assert (l_223 == &p_39);
        }
        else
        { /* block id: 81 */
            struct S0 **l_227 = &l_219;
            (***l_215) = l_227;
        }
        (****l_216) = (***l_217);
        if (l_220.f2)
            continue;
        (*l_230) = l_228;
    }
lbl_255:
    (*l_246) = func_45(func_49(((safe_lshift_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_s(((safe_div_func_uint8_t_u_u(((l_239 || (((void*)0 == l_240) != (~(l_221.f2 & ((0xF4 & (((safe_div_func_uint32_t_u_u((((void*)0 != &p_38) | (65527U < 0U)), (-1))) > 0x08) != l_239)) < l_221.f2))))) ^ (-1)), l_245)) < l_241.f1), 8)) & l_221.f0), l_221.f0)) > p_39), l_221.f1, l_221.f1, (*l_240)), &l_240, &l_241);
    (*l_253) = (safe_rshift_func_uint8_t_u_s((65535U | (safe_lshift_func_int16_t_s_u(0x9271, 3))), p_39));
    if (p_39)
        goto lbl_255;
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 ** func_40(uint8_t  p_41, uint8_t  p_42, struct S0  p_43, uint16_t  p_44)
{ /* block id: 66 */
    uint8_t l_181 = 0U;
    struct S0 l_184 = {19328,67,-256};
    struct S0 *l_183 = &l_184;
    struct S0 **l_182 = &l_183;
    const struct S0 *l_189 = &l_184;
    const struct S0 **l_188 = &l_189;
    const struct S0 *** const l_187 = &l_188;
    const struct S0 *** const *l_186 = &l_187;
    const struct S0 *** const **l_185 = &l_186;
    union U2 l_190 = {4294967295U};
    union U2 *l_193 = (void*)0;
    union U2 **l_192 = &l_193;
    union U2 ***l_191 = &l_192;
    int32_t l_207 = 0x6B5F6A14;
    int32_t *l_206 = &l_207;
    int16_t l_208 = 0xE1C9;
    int32_t **l_209 = &l_206;
    int32_t ***l_210 = &l_209;
    union U2 **l_211 = &l_193;
    union U2 **l_212 = (void*)0;
    (*l_191) = func_49(((l_181 <= (p_44 == p_41)) >= (l_182 != (void*)0)), (l_185 != (void*)0), l_184.f0, l_190);
    /* statement id: 67 */
    assert (l_192 == 0);
    (*l_206) = ((safe_lshift_func_int8_t_s_s((((safe_lshift_func_int8_t_s_s(l_181, 5)) & (((-1) & (&l_186 != (void*)0)) ^ ((p_43.f2 > (safe_lshift_func_int16_t_s_s(((safe_add_func_int16_t_s_s(((safe_lshift_func_uint8_t_u_u(l_190.f1, ((safe_lshift_func_int16_t_s_u(((0xC2E6 || (l_206 != (void*)0)) ^ (*l_206)), p_44)) && 0x4627))) < p_41), (*l_206))) || p_43.f1), l_208))) > (-10)))) | p_43.f1), 5)) & (*l_206));
    (*l_209) = &l_207;
    (*l_210) = &l_206;
    return l_212;
    /* statement id: 71 */
    //assert (func_40_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_45(const union U2 * const * p_46, union U2 * const * p_47, union U2 * p_48)
{ /* block id: 51 */
    struct S0 l_149 = {-26677,8311,152};
    struct S0 *l_148 = &l_149;
    struct S0 **l_147 = &l_148;
    struct S0 ***l_146 = &l_147;
    int32_t **l_151 = (void*)0;
    int32_t l_153 = 3;
    int32_t *l_152 = &l_153;
    struct S0 l_178 = {29813,10901,-106};
    (*l_152) = ((safe_rshift_func_int16_t_s_u((((0x65 & (l_146 == &l_147)) == (((((safe_unary_minus_func_uint16_t_u(((void*)0 == (*l_146)))) | ((l_151 != l_151) >= ((l_149.f0 > (2 != l_149.f1)) <= 0x366F))) < l_149.f0) | l_149.f2) <= l_149.f1)) ^ l_149.f0), 8)) || 0);
    for (l_153 = 6; (l_153 >= (-8)); l_153 = safe_sub_func_uint32_t_u_u(l_153, 3))
    { /* block id: 55 */
        int32_t l_156 = (-10);
        int32_t **l_159 = &l_152;
        struct S0 l_162 = {4339,2609,157};
        for (l_156 = 0; (l_156 != 0); l_156 = safe_add_func_uint8_t_u_u(l_156, 6))
        { /* block id: 58 */
            int32_t l_161 = 0xE60EB54A;
            int32_t *l_160 = &l_161;
            struct S0 l_163 = {31558,6284,122};
            (*l_160) = ((void*)0 == l_159);
            l_163 = l_162;
        }
        (*l_159) = (*l_159);
    }
    (*l_152) = ((safe_add_func_int16_t_s_s((&l_152 != (void*)0), (0xE32C ^ (!(!(((safe_lshift_func_int16_t_s_s(((1 >= (safe_sub_func_int32_t_s_s(0x352CA7B4, 0xCE2574B0))) & (*l_152)), 8)) > (safe_mod_func_int16_t_s_s((safe_add_func_int16_t_s_s(0xFDA2, ((safe_add_func_int8_t_s_s((*l_152), (*l_152))) <= (*l_152)))), (*l_152)))) > (*l_152))))))) >= (*l_152));
    return l_178;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const union U2 ** func_49(uint32_t  p_50, int8_t  p_51, int32_t  p_52, union U2  p_53)
{ /* block id: 40 */
    struct S0 ****l_130 = (void*)0;
    int32_t l_136 = 4;
    int32_t *l_139 = &l_136;
    union U2 l_142 = {0xE5BAC905};
    const union U2 *l_141 = &l_142;
    const union U2 **l_140 = &l_141;
    const union U2 **l_143 = (void*)0;
    for (p_52 = 13; (p_52 <= (-27)); p_52 = safe_sub_func_uint8_t_u_u(p_52, 1))
    { /* block id: 43 */
        struct S0 *****l_131 = &l_130;
        int32_t l_133 = 0x9B2FD4BB;
        int32_t *l_132 = &l_133;
        (*l_131) = l_130;
        (*l_132) = 0x2835E52A;
        l_132 = (void*)0;
        /* statement id: 46 */
        assert (l_132 == 0);
    }
    (*l_139) = ((p_51 >= (safe_lshift_func_int8_t_s_u(l_136, (8U < (l_136 && (safe_add_func_int8_t_s_s(((void*)0 == &l_136), ((((p_52 >= l_136) || (((5U | l_136) == p_53.f0) ^ 0x33)) || l_136) | p_51)))))))) & p_50);
    (*l_139) = (*l_139);
    return l_143;
    /* statement id: 50 */
    //assert (func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_55(int32_t  p_56, union U2 * p_57, const uint32_t  p_58, union U2 * p_59)
{ /* block id: 15 */
    int16_t l_67 = 1;
    const union U2 *l_68 = (void*)0;
    union U2 l_76 = {0U};
    union U2 *l_75 = &l_76;
    struct S0 l_96 = {-20694,6940,61};
    struct S0 l_121 = {10853,8819,359};
    struct S0 *l_124 = &l_121;
    struct S0 **l_123 = &l_124;
    union U2 l_127 = {0xE45A2DC9};
    if ((p_58 || ((l_67 == ((l_68 != (void*)0) >= l_67)) == ((safe_add_func_int16_t_s_s((safe_add_func_uint8_t_u_u(func_73(l_75), (&l_75 != &p_57))), p_58)) == l_76.f1))))
    { /* block id: 18 */
        union U2 * const l_87 = &l_76;
        union U2 *l_88 = &l_76;
        int32_t l_95 = 1;
        int32_t *l_94 = &l_95;
        struct S0 *l_97 = &l_96;
        (*l_94) = (safe_rshift_func_int8_t_s_s(p_58, func_80(((safe_lshift_func_int8_t_s_s(0xA1, 1)) > p_58), (((void*)0 != l_87) < p_56), l_88, (0xC5 && ((&p_57 == &p_57) < (-6))))));
        (*l_97) = l_96;
        (*l_94) = (safe_div_func_uint8_t_u_u(((l_96.f0 != (((safe_sub_func_int8_t_s_s((safe_unary_minus_func_uint16_t_u((safe_rshift_func_uint16_t_u_u((*l_94), 13)))), ((p_58 & ((safe_lshift_func_uint16_t_u_s((safe_sub_func_int8_t_s_s(((-6) <= (~(safe_rshift_func_uint16_t_u_u(((((safe_sub_func_uint32_t_u_u(p_56, ((~0x17) != (((safe_add_func_int8_t_s_s((-1), ((-3) != ((((safe_div_func_uint32_t_u_u(((*l_94) && 5), p_58)) <= 0x9F947EB5) || p_58) == 0x0D33)))) && (*l_94)) != p_58)))) < 0x2EF76CAF) > p_56) == 0xA2), p_56)))), p_56)), 2)) || p_56)) ^ 0x0D))) && l_96.f0) >= l_96.f1)) | l_96.f0), 0xEB));
        for (l_76.f0 = 0; (l_76.f0 == 1); l_76.f0 = safe_add_func_int16_t_s_s(l_76.f0, 1))
        { /* block id: 29 */
            int32_t **l_122 = &l_94;
            struct S0 ***l_125 = &l_123;
            (*l_97) = l_121;
            (*l_122) = (void*)0;
            /* statement id: 31 */
            assert (l_94 == 0);
            if (p_58)
                continue;
            (*l_125) = l_123;
        }
        /* facts after for loop */
        assert (l_94 == 0 || l_94 == &l_95);
    }
    else
    { /* block id: 35 */
        union U2 l_126 = {4294967291U};
        (**l_123) = (*l_124);
        return l_126;
        /* statement id: 37 */
            }
    return l_127;
    /* statement id: 39 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_73(union U2 * p_74)
{ /* block id: 16 */
    uint16_t l_77 = 5U;
    return l_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_80(uint16_t  p_81, uint32_t  p_82, union U2 * p_83, uint32_t  p_84)
{ /* block id: 19 */
    struct S0 l_90 = {-26242,5720,-189};
    struct S0 *l_89 = &l_90;
    struct S0 **l_91 = &l_89;
    int32_t l_93 = 0;
    int32_t *l_92 = &l_93;
    (*l_91) = l_89;
    l_91 = &l_89;
    (*l_92) = 1;
    return p_84;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 71
   depth: 1, occurrence: 8
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 8
breakdown:
   indirect level: 0, occurrence: 8
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 13
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 23

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 137
   depth: 2, occurrence: 18
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 4
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 123

XXX times a variable address is taken: 128
XXX times a pointer is dereferenced on RHS: 37
breakdown:
   depth: 1, occurrence: 30
   depth: 2, occurrence: 4
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 55
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 3
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 174

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 101
   level: 2, occurrence: 10
   level: 3, occurrence: 8
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 70
XXX number of pointers point to scalars: 24
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 25.2
XXX average alias set size: 1.07

XXX times a non-volatile is read: 357
XXX times a non-volatile is write: 142
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 2

XXX stmts: 113
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 40
   depth: 1, occurrence: 26
   depth: 2, occurrence: 28
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

