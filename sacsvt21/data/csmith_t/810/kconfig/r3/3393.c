/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      2858472424
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   int32_t  f1;
   uint8_t  f2;
   int32_t  f3;
   uint32_t  f4;
   int32_t  f5;
   uint16_t  f6;
   int32_t  f7;
   signed f8 : 21;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int32_t  f0;
   signed f1 : 8;
   int32_t  f2;
   uint32_t  f3;
   uint8_t  f4;
   struct S0  f5;
   int32_t  f6;
   uint8_t  f7;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t  func_9(uint8_t  p_10, uint32_t  p_11);
static uint16_t  func_14(struct S0  p_15, uint32_t  p_16, uint8_t  p_17);
static int32_t  func_21(uint16_t  p_22);
static uint32_t  func_40(uint8_t  p_41, uint8_t  p_42, int32_t  p_43, struct S1  p_44, uint32_t  p_45);
static uint16_t  func_50(struct S0  p_51, struct S0  p_52);
static struct S0  func_54(int32_t  p_55);
static int32_t  func_58(uint16_t  p_59, int16_t  p_60, struct S0  p_61);
static int16_t  func_68(uint32_t  p_69, int16_t  p_70, uint8_t  p_71, int32_t  p_72, uint32_t  p_73);
static struct S0  func_77(uint32_t  p_78, uint8_t  p_79, int32_t  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 5;
    int32_t l_5 = 0xB779C63C;
    struct S0 l_18 = {0x09B4AF7B,6,2U,0x374FD522,4294967295U,1,0x0B08,-1,-5};
    for (l_2 = 0; (l_2 == 5); l_2 += 7)
    { /* block id: 3 */
        uint16_t l_8 = 0xAB22;
        struct S0 l_436 = {4U,-6,0U,-6,4294967291U,6,1U,0,-700};
        l_5 = 0xEC17E5C2;
        if (((uint32_t)((-1) != (l_8 || func_9(((int16_t)((func_14(l_18, (((uint16_t)(l_8 >= ((func_21(l_18.f3) < ((((int16_t)(-(uint16_t)(((uint32_t)(65529U < ((65529U ^ (-(int16_t)(l_18.f2 || l_18.f1))) <= (-1))) % (uint32_t)1) > l_8)) << (int16_t)4) < 6U) <= l_18.f1)) == l_18.f8)) >> (uint16_t)l_18.f4) | l_5), l_18.f2) < l_8) < l_2) << (int16_t)3), l_8))) % (uint32_t)4294967286U))
        { /* block id: 127 */
            uint32_t l_431 = 1U;
            l_5 = ((int16_t)(((int16_t)((l_18.f4 != ((uint16_t)4U - (uint16_t)((uint32_t)l_18.f4 + (uint32_t)l_431))) || (((l_18.f1 ^ ((int16_t)(l_8 > (0x7BB5EA8D ^ ((((l_431 != (((uint32_t)(l_18.f0 || l_2) + (uint32_t)l_8) == l_18.f2)) | l_8) <= 6) <= l_431))) % (int16_t)0x2932)) > l_8) && l_2)) << (int16_t)l_18.f0) <= l_18.f5) << (int16_t)7);
        }
        else
        { /* block id: 129 */
            struct S0 l_437 = {0x40659CFA,0xF7164121,252U,0xFEEB476E,2U,0x428103AB,0U,-1,1410};
            l_437 = l_436;
            l_18.f8 = (5U & 0xD498);
            for (l_436.f0 = 25; (l_436.f0 >= 7); l_436.f0 -= 1)
            { /* block id: 134 */
                return l_436.f5;
            }
        }
        for (l_436.f7 = 0; (l_436.f7 >= 10); l_436.f7 += 1)
        { /* block id: 140 */
            return l_436.f3;
        }
    }
    l_18.f3 = (l_18.f7 > ((((int16_t)(l_18.f5 < (1U > l_18.f2)) << (int16_t)13) & ((uint32_t)((int16_t)3 >> (int16_t)9) + (uint32_t)l_2)) == ((uint16_t)l_5 >> (uint16_t)11)));
    return l_18.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_9(uint8_t  p_10, uint32_t  p_11)
{ /* block id: 119 */
    struct S1 l_398 = {1,1,0xE26671C1,0x499AFB89,248U,{0xE2595FBE,0x7C3F1183,0x35,0x8239F17E,4294967286U,7,0x93AB,0x8C037808,-954},-8,0x88};
    uint32_t l_422 = 1U;
    for (p_10 = (-21); (p_10 < 6); p_10 += 9)
    { /* block id: 122 */
        struct S1 l_399 = {0x67B2A463,-15,0x5097E263,5U,0x8D,{0xCDB755E3,1,0x63,9,0x8BE9F7AA,0,0x7CF2,0x8528CA12,-236},0xC99B3F84,0xE9};
        l_399 = l_398;
        l_399.f6 = (((uint16_t)((((((!(0x3E62D634 || l_398.f5.f3)) || (((int32_t)0 - (int32_t)(((l_399.f7 == (((uint16_t)((int32_t)((((uint16_t)(((int16_t)(((l_398.f4 != ((int16_t)p_11 << (int16_t)2)) && p_11) ^ ((p_10 ^ (!((int16_t)(((uint16_t)((uint16_t)p_10 >> (uint16_t)l_398.f1) << (uint16_t)11) && 0xB354) % (int16_t)l_399.f5.f5))) >= 0x9D22448B)) << (int16_t)4) || l_422) % (uint16_t)p_11) | p_11) > 0x824B) - (int32_t)p_11) % (uint16_t)p_11) <= p_10)) & p_10) >= 2U)) && l_398.f1)) < 0x4076DD90) >= l_398.f3) > l_399.f6) != 0xE59FCD12) << (uint16_t)4) != l_399.f4);
    }
    return l_398.f5.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_14(struct S0  p_15, uint32_t  p_16, uint8_t  p_17)
{ /* block id: 12 */
    uint16_t l_36 = 0x3F55;
    struct S0 l_53 = {0xE52E9AD7,0,0x03,0x50090E7A,1U,1,0x8A60,0x10F657D2,-1058};
    struct S1 l_367 = {0x7B8A3ACC,-0,0xDF5171D4,0x1D0AFAAC,0x8B,{0x7904C0D5,0x4E740CD5,0x97,-6,1U,0x90DBE4FE,0x0A83,-10,1015},0xD30AE7E3,0x0E};
    l_367.f5.f8 = (((int32_t)(-(int32_t)(l_36 <= 0xDE89C674)) + (int32_t)((p_15.f4 >= ((((uint16_t)((!((func_40(func_21((((int16_t)(((uint16_t)(func_21(func_50(l_53, func_54((4U < (l_53.f1 > func_21(p_15.f8)))))) >= p_15.f4) % (uint16_t)l_53.f2) ^ p_15.f4) << (int16_t)p_15.f1) > 4294967295U)), l_53.f1, l_53.f7, l_367, p_15.f2) > l_367.f0) < l_367.f7)) ^ l_367.f4) << (uint16_t)p_15.f1) & (-1)) < 0x69E6)) & 0x7CCA)) >= l_367.f5.f6);
    p_15.f3 = p_15.f0;
    l_53.f8 = p_15.f5;
    return l_367.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_21(uint16_t  p_22)
{ /* block id: 5 */
    int16_t l_26 = 0;
    for (p_22 = 0; (p_22 <= 38); p_22 += 1)
    { /* block id: 8 */
        int16_t l_25 = 1;
        return l_25;
    }
    return l_26;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_40(uint8_t  p_41, uint8_t  p_42, int32_t  p_43, struct S1  p_44, uint32_t  p_45)
{ /* block id: 103 */
    uint32_t l_383 = 0x327F81C1;
    uint8_t l_393 = 6U;
    struct S1 l_395 = {0xBD2B96D3,1,1,0xABAA7D1F,0x43,{0x4784EC2A,0x033338E9,6U,8,0xB10184A4,0x1BB28938,65535U,0xC4DA7D5E,-1203},0x517D6003,0xFC};
    for (p_44.f5.f2 = 29; (p_44.f5.f2 > 8); p_44.f5.f2 -= 1)
    { /* block id: 106 */
        uint32_t l_379 = 9U;
        uint32_t l_392 = 0x1E2E06FD;
        p_44.f1 = ((((((!(p_44.f5.f6 <= ((uint32_t)((int16_t)(((((uint32_t)0xCA0DB158 + (uint32_t)(p_44.f2 & (((uint16_t)((65527U > l_379) && ((!p_44.f7) <= (((((((uint32_t)l_383 - (uint32_t)l_383) < l_379) | p_44.f5.f2) != p_44.f2) | 0x0FE5F93F) != l_379))) << (uint16_t)13) || p_44.f5.f2))) == l_379) >= 3U) > p_44.f7) << (int16_t)l_383) - (uint32_t)(-1)))) > l_383) >= l_383) >= l_383) || p_44.f1) > l_383);
        if (((uint16_t)(((uint32_t)((uint32_t)(((((0xEDF3 | ((uint32_t)l_392 % (uint32_t)l_392)) ^ (3U & p_43)) && ((1 ^ l_393) < (~5))) != l_393) != p_44.f1) % (uint32_t)l_393) + (uint32_t)p_44.f4) ^ l_383) >> (uint16_t)12))
        { /* block id: 108 */
            return p_44.f4;
        }
        else
        { /* block id: 110 */
            l_395 = p_44;
        }
    }
    return l_395.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_50(struct S0  p_51, struct S0  p_52)
{ /* block id: 85 */
    uint32_t l_324 = 4294967295U;
    int32_t l_335 = 0xDE9F1D2E;
    if (((uint16_t)(((int16_t)l_324 >> (int16_t)4) < (0xCFFE | (l_324 <= (((p_51.f8 != ((0xCA6D & p_51.f7) >= l_324)) != ((uint32_t)p_51.f4 - (uint32_t)0U)) && p_52.f7)))) % (uint16_t)p_52.f5))
    { /* block id: 86 */
        int32_t l_338 = (-1);
        l_335 = ((uint16_t)(l_324 > ((uint16_t)((((p_51.f2 | 0x677EC04D) > p_52.f8) || (!l_324)) > (!l_335)) << (uint16_t)13)) << (uint16_t)p_52.f6);
        p_52.f8 = (((uint16_t)p_51.f1 - (uint16_t)l_338) & (-(uint32_t)p_51.f3));
    }
    else
    { /* block id: 89 */
        struct S0 l_340 = {0xEE653A38,0xAB490EE6,0xED,0xF625D81B,1U,0xAA1B3EB4,0x33E5,1,545};
        p_52.f1 = p_52.f4;
        p_52 = l_340;
        if (p_52.f5)
        { /* block id: 92 */
            p_51 = func_54(l_340.f7);
        }
        else
        { /* block id: 94 */
            uint32_t l_348 = 0xB439EF4D;
            if (((~(l_340.f3 != (((int32_t)(((int32_t)5 - (int32_t)((uint32_t)4294967295U % (uint32_t)p_51.f5)) != p_51.f8) - (int32_t)l_348) >= (l_335 ^ (-(int32_t)(l_348 != (0x96E82DC9 <= l_348))))))) > l_340.f3))
            { /* block id: 95 */
                p_52 = p_52;
            }
            else
            { /* block id: 97 */
                int32_t l_352 = 5;
                l_340.f8 = (p_51.f1 < ((int16_t)(l_352 >= (((int16_t)((uint16_t)l_340.f2 + (uint16_t)(((int16_t)((!((-3) < 0U)) >= (((uint16_t)0U << (uint16_t)((uint16_t)1U >> (uint16_t)l_352)) ^ ((uint32_t)(!((l_352 > p_52.f8) ^ 1U)) - (uint32_t)0U))) - (int16_t)p_51.f7) < p_52.f4)) % (int16_t)l_340.f4) && p_52.f6)) - (int16_t)l_335));
            }
        }
    }
    return p_52.f8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_54(int32_t  p_55)
{ /* block id: 13 */
    int32_t l_62 = 0x6D0914BD;
    struct S0 l_150 = {1U,0x0FA72BBA,0U,-3,1U,0,0xDDF6,0x144B6F7A,-854};
    for (p_55 = 0; (p_55 == (-20)); p_55 -= 6)
    { /* block id: 16 */
        uint16_t l_67 = 0xC78E;
        l_150.f8 = func_58(l_62, ((int32_t)0xBA474122 % (int32_t)(((uint16_t)l_67 >> (uint16_t)0) | (func_68(l_67, ((int32_t)(!0xBFF9) - (int32_t)func_21((p_55 > func_21(l_67)))), p_55, p_55, p_55) != l_67))), l_150);
    }
    return l_150;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_58(uint16_t  p_59, int16_t  p_60, struct S0  p_61)
{ /* block id: 27 */
    struct S1 l_151 = {0x4B4CCDFE,2,0x1259A4FA,0U,255U,{4294967290U,9,0x17,0x1CC2B1C8,0xE662C939,0x4B5287A9,0x704C,0x75E38545,546},4,0x75};
    int16_t l_165 = 0x7DC5;
    int16_t l_166 = 8;
    uint32_t l_213 = 0U;
    int32_t l_226 = (-1);
    l_151 = l_151;
    p_61.f3 = ((int16_t)((((int16_t)(!0x5287BB0C) >> (int16_t)7) | p_61.f1) < (l_151.f4 | 0)) - (int16_t)((((0xA032 == (((uint32_t)((int16_t)(p_61.f0 == l_151.f5.f0) + (int16_t)(((((0x802A && (((uint16_t)((uint16_t)l_151.f5.f6 >> (uint16_t)l_151.f5.f0) - (uint16_t)0x1BCC) || l_151.f7)) ^ 0U) ^ p_61.f6) >= (-1)) >= l_165)) + (uint32_t)p_61.f8) < p_61.f3)) < l_151.f1) ^ p_61.f7) || l_151.f5.f6));
    if (l_166)
    { /* block id: 30 */
        uint16_t l_170 = 0xCB65;
        uint32_t l_199 = 0U;
        struct S0 l_222 = {0U,0x1B637EA3,248U,0x8290AFDD,0U,-7,0x4903,0xFC9DB44E,-666};
        if (l_166)
        { /* block id: 31 */
            int32_t l_169 = 0;
            l_169 = ((uint32_t)p_61.f3 % (uint32_t)l_151.f5.f1);
            return l_170;
        }
        else
        { /* block id: 34 */
            uint8_t l_180 = 246U;
            int32_t l_200 = 6;
            uint8_t l_260 = 1U;
            struct S0 l_269 = {1U,5,4U,0x34EFDB94,2U,0,65535U,0,-225};
            l_200 = ((int16_t)((int16_t)l_151.f5.f4 - (int16_t)(((int16_t)((((int32_t)((65535U & ((!(-1)) & ((l_180 != l_170) & ((((uint16_t)(p_61.f7 && (p_61.f4 <= (((((uint16_t)((((uint16_t)((int16_t)(p_61.f1 < (((((int32_t)(((!(((uint32_t)((((int16_t)(((~((((uint32_t)((0U != 0) != l_180) - (uint32_t)0x891A7476) ^ p_61.f8) >= p_61.f0)) || l_180) >= l_180) - (int16_t)0U) && 0x47A68E1F) || l_199) - (uint32_t)4294967295U) || l_180)) ^ p_61.f4) || l_180) + (int32_t)1U) || 8) > 0U) & p_59)) + (int16_t)l_199) % (uint16_t)65535U) | 0x8F816EC6) != p_60) >> (uint16_t)15) <= 0xE8D20A93) > l_151.f5.f6) && l_151.f3))) << (uint16_t)l_180) & 0x73F1) | l_180)))) != 0xC9BE) % (int32_t)l_151.f4) & p_61.f1) && p_59) << (int16_t)p_61.f6) == p_61.f0)) + (int16_t)l_180);
            l_151.f5.f1 = ((((uint16_t)((uint16_t)(((p_61.f8 >= p_59) > ((uint16_t)0x6DD7 >> (uint16_t)9)) == ((l_151.f4 > (l_170 == (((int16_t)l_151.f5.f8 << (int16_t)((l_170 < ((int32_t)0x372E6339 - (int32_t)(((((uint16_t)p_61.f4 + (uint16_t)p_61.f5) <= l_200) > l_151.f3) < p_61.f1))) > p_61.f0)) || p_61.f8))) <= l_213)) - (uint16_t)0x38E5) % (uint16_t)l_151.f3) <= 0U) <= p_61.f4);
            l_151.f5 = p_61;
            for (p_61.f5 = 0; (p_61.f5 < 12); p_61.f5 += 1)
            { /* block id: 40 */
                int16_t l_218 = 0;
                int32_t l_221 = 9;
                uint16_t l_261 = 0xDF7F;
                uint8_t l_266 = 0U;
                for (p_61.f7 = 0; (p_61.f7 != 24); p_61.f7 += 1)
                { /* block id: 43 */
                    int16_t l_223 = 0xD9B3;
                    if (l_218)
                    { /* block id: 44 */
                        p_61.f1 = 1;
                        l_221 = ((int16_t)p_61.f1 << (int16_t)1);
                        l_222 = p_61;
                    }
                    else
                    { /* block id: 48 */
                        l_223 = 0x29B9E970;
                    }
                }
                l_222.f8 = ((uint16_t)((l_180 & l_226) & (p_61.f6 || (((1U > l_200) == p_61.f3) == ((uint16_t)(l_200 > p_61.f3) >> (uint16_t)(((uint16_t)(p_61.f3 >= 0x6BC57D95) - (uint16_t)0x2231) ^ 0xC1FECEB4))))) + (uint16_t)0x7CED);
                if ((((int16_t)((uint16_t)((int16_t)l_151.f5.f4 % (int16_t)(-(uint16_t)(((l_151.f5.f0 || ((p_61.f1 < ((int16_t)p_59 + (int16_t)(9 > 0xC9E143BA))) ^ ((int32_t)((int32_t)l_151.f6 + (int32_t)(((uint16_t)((int16_t)((~((((int16_t)p_61.f1 << (int16_t)15) > p_61.f7) || 1U)) != 1U) - (int16_t)0U) + (uint16_t)0xE9A5) < l_213)) % (int32_t)p_61.f0))) ^ l_221) ^ 1))) - (uint16_t)0xC121) >> (int16_t)l_221) >= 1))
                { /* block id: 53 */
                    uint16_t l_253 = 1U;
                    l_200 = ((p_61.f8 == ((int32_t)(((l_253 && 6U) < (0xC657 <= (9 & ((int16_t)(65535U & l_253) % (int16_t)(-7))))) & (l_180 == p_61.f3)) - (int32_t)l_253)) || 0U);
                }
                else
                { /* block id: 55 */
                    p_61.f1 = ((((uint16_t)(((uint16_t)l_151.f1 << (uint16_t)(l_260 ^ ((p_61.f4 && (l_180 & (l_261 >= 1))) && (((int32_t)((uint16_t)(l_266 | (3U & ((uint16_t)65533U << (uint16_t)15))) - (uint16_t)p_61.f8) + (int32_t)p_61.f8) | p_61.f7)))) < 0xA596) << (uint16_t)9) < l_151.f7) > 0);
                    l_269 = func_77(l_200, p_61.f1, l_222.f5);
                    return p_61.f0;
                }
            }
        }
    }
    else
    { /* block id: 62 */
        uint16_t l_278 = 0xEFD4;
        uint16_t l_280 = 0x0878;
        int32_t l_283 = 0xB76E90CC;
        struct S1 l_301 = {0x58A4408C,-1,0x4B7888E8,4294967295U,0xA6,{0x1430380A,1,0x1A,0x46ECEDAA,0U,0,0x6020,8,942},1,9U};
        if (((uint32_t)(((int16_t)((p_61.f3 <= l_151.f2) < ((((int16_t)p_61.f3 << (int16_t)13) != ((l_151.f5.f2 || ((((uint16_t)p_61.f4 << (uint16_t)13) < 0x53EA47AB) <= (0x2A8F >= (l_278 & (((((!l_278) | p_61.f0) | 0U) <= l_213) == p_61.f2))))) && l_278)) != 0xD117)) << (int16_t)l_278) > l_278) - (uint32_t)l_280))
        { /* block id: 63 */
            uint32_t l_286 = 0U;
            int32_t l_300 = 0;
            struct S1 l_302 = {0xC816ABCE,10,0xACCCAD14,0xC0F2A8A3,0x8C,{0x2AD4DA4A,-6,0x1B,0,0x6CB6D5B2,-8,0x323B,0x560E697D,694},-4,1U};
            for (p_61.f7 = 0; (p_61.f7 > (-24)); p_61.f7 -= 8)
            { /* block id: 66 */
                uint16_t l_299 = 1U;
                l_283 = l_226;
                l_300 = ((0x1AC8A185 && (p_61.f2 ^ ((uint16_t)p_59 << (uint16_t)(l_286 <= ((((uint16_t)((((((int16_t)((int16_t)((int16_t)(((uint16_t)l_151.f5.f4 % (uint16_t)(p_61.f8 || (((int32_t)l_151.f0 - (int32_t)(p_59 == 0xBF8CB437)) >= l_299))) > l_299) % (int16_t)p_61.f5) - (int16_t)0U) << (int16_t)8) ^ p_59) >= p_61.f5) < 7) > 0x1A8EAB97) << (uint16_t)3) > 0xF85E) < p_61.f0))))) | l_299);
                l_151.f6 = l_299;
                if (p_61.f4)
                    break;
            }
            l_302 = l_301;
            p_61.f8 = (((uint16_t)((l_151.f5.f4 > ((l_302.f5.f1 ^ (((uint32_t)((int32_t)((((int16_t)0xE358 - (int16_t)l_301.f5.f1) ^ ((((1 > (((int16_t)(!(65527U > ((int16_t)0x6911 >> (int16_t)((int16_t)((((l_302.f5.f4 && ((uint32_t)(0x93A6662E || p_61.f1) % (uint32_t)l_300)) <= p_61.f2) >= 0x885F) < l_151.f5.f5) >> (int16_t)l_301.f5.f7)))) << (int16_t)6) & p_61.f4)) > l_301.f3) ^ 4294967286U) == l_301.f0)) <= p_61.f0) + (int32_t)4294967295U) % (uint32_t)l_302.f5.f5) < p_59)) ^ 9)) == l_213) % (uint16_t)p_61.f8) || 0xC077);
        }
        else
        { /* block id: 74 */
            l_151.f1 = (0 && l_151.f6);
            return l_151.f5.f0;
        }
        l_301.f6 = p_61.f4;
        p_61 = l_301.f5;
    }
    return p_61.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_68(uint32_t  p_69, int16_t  p_70, uint8_t  p_71, int32_t  p_72, uint32_t  p_73)
{ /* block id: 17 */
    uint16_t l_88 = 65535U;
    struct S0 l_126 = {4294967292U,0xA506553B,255U,0xF12706A3,1U,-9,0x2F4E,0xBCE0EE98,-249};
    l_126 = func_77((p_69 & (p_71 == ((int16_t)((uint16_t)((int16_t)((((((1 ^ 0x3E67) || ((!p_72) || p_71)) > l_88) & p_71) < (((~0x2F8D) > p_70) || 0xB93D7553)) && l_88) - (int16_t)p_71) << (uint16_t)p_72) << (int16_t)3))), p_71, l_88);
    l_126.f8 = (((((((0xA01D1870 <= (p_73 || l_126.f8)) == ((uint16_t)((uint16_t)(65535U || (((((int16_t)((~((int32_t)p_72 - (int32_t)4)) ^ p_72) % (int16_t)p_72) >= ((uint32_t)p_72 % (uint32_t)p_69)) == 0xC90A92FA) && p_71)) + (uint16_t)0x4148) >> (uint16_t)9)) > l_126.f7) && p_72) != p_70) == l_88) || 0U);
    l_126.f1 = ((((((((int32_t)0xE25250D9 - (int32_t)p_72) < p_72) & (l_126.f6 <= 7U)) && l_126.f8) >= l_126.f6) && ((((uint32_t)((uint16_t)((uint16_t)((uint16_t)((((uint32_t)p_72 - (uint32_t)(p_71 < l_126.f7)) <= p_70) == p_71) >> (uint16_t)10) >> (uint16_t)l_126.f2) >> (uint16_t)p_69) + (uint32_t)4294967295U) != l_126.f6) >= l_88)) ^ l_126.f6);
    return l_126.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_77(uint32_t  p_78, uint8_t  p_79, int32_t  p_80)
{ /* block id: 18 */
    uint16_t l_90 = 0xE529;
    int32_t l_101 = (-8);
    struct S0 l_125 = {1U,-2,0xB9,-8,0x1E9D581D,0x2E7BD33C,0U,0x799C40DF,51};
    p_80 = l_90;
    l_101 = ((int32_t)(((int16_t)((uint16_t)l_90 << (uint16_t)8) << (int16_t)2) >= (((((int16_t)((4294967291U | (p_79 != ((int16_t)((l_90 & p_79) && l_90) << (int16_t)14))) == (0x1AC0D59B ^ p_80)) << (int16_t)l_90) | 4294967295U) == p_79) && p_80)) + (int32_t)l_90);
    l_101 = (-(int16_t)(((!((uint16_t)((uint16_t)(-(uint32_t)p_79) - (uint16_t)((uint32_t)0x8BBDFDC5 + (uint32_t)(((uint16_t)((uint32_t)((l_101 > (p_80 >= ((int16_t)(((((((int32_t)0x6F77E7A5 % (int32_t)((0x32FAA63A | ((int16_t)(((((int16_t)((uint16_t)p_80 % (uint16_t)(p_78 ^ p_79)) + (int16_t)p_79) || (-1)) > 0x602C2F6D) >= 0xC824337C) - (int16_t)p_79)) ^ l_90)) < l_90) && l_90) || l_90) | p_78) != 9U) - (int16_t)l_90))) > 0x49FF72C9) - (uint32_t)p_78) + (uint16_t)(-4)) && p_80))) << (uint16_t)1)) > p_79) | l_90));
    return l_125;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 43
   depth: 1, occurrence: 10
   depth: 2, occurrence: 7
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 17
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 13
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 11
XXX times a single bitfield on RHS: 26

XXX max expression depth: 45
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 2
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 30, occurrence: 1
   depth: 32, occurrence: 1
   depth: 45, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 410
XXX times a non-volatile is write: 58
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 86
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 18
   depth: 2, occurrence: 20
   depth: 3, occurrence: 10
   depth: 4, occurrence: 5
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 13.4
XXX percentage an existing variable is used: 86.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

