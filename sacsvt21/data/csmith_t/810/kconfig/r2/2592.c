/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3227630744
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 26;
   signed f1 : 7;
   signed f2 : 13;
};
#pragma pack(pop)

struct S1 {
   int32_t  f0;
   unsigned f1 : 7;
   signed f2 : 16;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_27(void);
inline static int32_t  func_29(struct S0  p_30, uint32_t  p_31, int16_t  p_32, uint32_t  p_33);
static struct S0  func_34(uint32_t  p_35);
inline static uint16_t  func_39(int16_t  p_40, int8_t  p_41);
inline static int8_t  func_42(uint32_t  p_43);
inline static int32_t  func_49(uint32_t  p_50, int32_t  p_51, int8_t  p_52, int32_t  p_53);
inline static int32_t  func_54(int16_t  p_55);
static struct S1  func_60(int16_t  p_61, int16_t  p_62, struct S0  p_63, uint16_t  p_64, struct S0  p_65);
inline static struct S1  func_66(uint32_t  p_67, struct S0  p_68, uint16_t  p_69, uint32_t  p_70, int8_t  p_71);
static int16_t  func_75(uint32_t  p_76, uint16_t  p_77, int16_t  p_78, struct S1  p_79, uint16_t  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_27(void)
{ /* block id: 36 */
    int32_t l_28 = (-6);
    struct S0 l_479 = {-7966,9,48};
    uint16_t l_480 = 0xDE46;
    struct S1 l_485 = {0x6FBF9409,9,216};
    struct S0 l_517 = {-422,8,38};
    uint16_t l_638 = 65535U;
    uint16_t l_641 = 65535U;
    int8_t l_694 = 1;
    uint16_t l_700 = 65535U;
    if (l_28)
    { /* block id: 37 */
        int16_t l_44 = 7;
        struct S1 l_476 = {-7,8,-74};
        struct S0 l_477 = {3518,-3,-69};
        struct S1 l_481 = {0x681DB775,2,10};
        struct S1 l_486 = {-1,4,81};
        int32_t l_510 = 1;
        uint16_t l_520 = 0xD279;
        if (func_29(func_34(((uint16_t)(((((!(func_39((l_28 <= l_28), func_42(l_44)) || (((int16_t)l_44 % (int16_t)(((-(int16_t)l_44) , l_44) | l_28)) > l_44))) && l_28) < l_28) , l_28) , l_28) - (uint16_t)0x7F9D)), l_28, l_28, l_28))
        { /* block id: 243 */
            int32_t l_473 = 8;
            struct S0 l_478 = {-6558,-6,1};
            struct S1 l_482 = {0xA631D278,1,218};
            struct S0 l_522 = {2095,-10,-29};
            uint16_t l_557 = 1U;
            l_479 = func_34(__builtin_ia32_crc32qi((((int16_t)((l_473 = 0x1359E93B) || 0xBF1A73D9) * (int16_t)l_28) , (l_479.f1 = ((int16_t)(l_476 , ((((((func_60(l_473, l_473, func_34(func_29((l_476.f1 , l_477), l_473, l_28, l_28)), l_473, l_478) , l_479) , l_479.f2) & 0xB50E) != l_473) == l_480) , 0xA4E1)) + (int16_t)l_473))), l_479.f0));
            l_482 = l_481;
            for (l_473 = 3; (l_473 > 28); l_473 += 1)
            { /* block id: 250 */
                uint16_t l_491 = 7U;
                int32_t l_511 = (-9);
                uint32_t l_514 = 0xECDB3315;
                struct S0 l_523 = {5413,3,20};
                l_486 = l_485;
                if (((uint32_t)((uint16_t)2U >> (uint16_t)9) + (uint32_t)l_491))
                { /* block id: 252 */
                    uint32_t l_518 = 0xC96F6771;
                    int32_t l_519 = 0x4CCCD61F;
                    int32_t l_521 = 1;
                    struct S0 l_556 = {2384,-0,5};
                    l_478.f1 = 0xEAC1FFC7;
                    for (l_491 = 0; (l_491 <= 25); l_491 += 8)
                    { /* block id: 256 */
                        int16_t l_499 = 0x09CA;
                        struct S0 l_524 = {5931,-0,-1};
                        l_481 = func_60((((uint16_t)((int16_t)((((__builtin_parity((-(int16_t)0x6BA7)) >= l_499) > ((l_486.f0 < (((func_42(((uint32_t)((((int32_t)((int32_t)(l_519 = (l_477.f0 = (((uint16_t)((int16_t)(l_511 |= l_510) << (int16_t)13) - (uint16_t)((((uint16_t)l_514 >> (uint16_t)4) && (l_478.f1 = (((int32_t)(l_482.f2 = func_29(l_517, l_478.f2, (l_485.f0 |= 0x3BEA), l_518)) + (int32_t)l_473) && l_476.f0))) < 1U)) > 0xA6AC))) % (int32_t)l_518) - (int32_t)0xD10D603B) >= l_518) || l_499) - (uint32_t)l_518)) | (-1)) < l_520) | l_520)) < l_518)) ^ (-10)) , l_521) * (int16_t)l_486.f0) >> (uint16_t)1) < 0xC6BBCF57), l_477.f2, l_522, l_477.f2, l_523);
                        l_482 = func_66(l_521, l_524, (((uint16_t)l_524.f0 >> (uint16_t)((int16_t)l_511 >> (int16_t)0)) > (l_511 >= (l_482.f0 & func_49((func_34((((l_473 , func_34(l_518)) , 9U) > l_486.f2)) , l_518), l_28, l_524.f1, l_491)))), l_517.f0, l_518);
                        l_523.f2 = l_521;
                    }
                    if (l_521)
                    { /* block id: 267 */
                        int8_t l_531 = 1;
                        l_481.f2 = ((int16_t)((func_34((__builtin_ia32_crc32qi(l_511, (l_481.f0 |= __builtin_parityl((l_522.f1 |= l_531)))) ^ ((l_482.f0 = (l_518 == l_521)) <= (l_519 = l_486.f1)))) , ((uint16_t)l_521 % (uint16_t)0xE25D)) , l_517.f1) % (int16_t)l_521);
                        l_519 = l_482.f1;
                    }
                    else
                    { /* block id: 274 */
                        int8_t l_535 = (-10);
                        struct S0 l_550 = {-1438,-8,1};
                        l_485.f2 = (~0x50AB);
                        if (l_519)
                            break;
                        l_482.f2 = ((l_522.f2 , ((l_523.f2 != (l_479.f2 ^= (l_523.f1 = (0 & 0x608B)))) != (l_535 > (((uint16_t)((int32_t)((((uint16_t)((int32_t)l_480 + (int32_t)l_535) >> (uint16_t)__builtin_clzll(((uint16_t)l_519 * (uint16_t)((uint32_t)func_29(l_517, l_480, l_482.f2, l_476.f2) % (uint32_t)4294967288U)))) , 0x9993) , 0) + (int32_t)l_476.f0) >> (uint16_t)4) , 0x322CEEC3)))) , 0x537A5CB8);
                        l_479.f2 = (l_535 <= ((int16_t)(-6) * (int16_t)(l_522.f1 == func_29(l_550, l_517.f2, (l_557 ^= ((~(((int16_t)((uint32_t)(func_39((l_523.f2 , (0U != func_29((l_556 = l_550), l_550.f0, l_514, l_478.f1))), l_518) , l_550.f0) + (uint32_t)l_522.f0) * (int16_t)1) || l_517.f1)) || l_523.f1)), l_518))));
                    }
                }
                else
                { /* block id: 284 */
                    uint16_t l_565 = 0xDD2C;
                    int32_t l_572 = 0xC4EECA38;
                    int16_t l_573 = (-6);
                    l_478.f0 = (((int32_t)(func_42(l_486.f1) , ((l_482.f2 = (65531U || (0x2047 ^ l_485.f2))) < __builtin_clz(((((uint16_t)((((((!((uint32_t)(func_34((l_565 = l_482.f0)) , ((int16_t)((int16_t)((l_572 = ((uint16_t)65535U * (uint16_t)func_54(l_476.f1))) , l_486.f2) << (int16_t)13) - (int16_t)l_491)) + (uint32_t)0x126D2577)) , 0x41B4) | l_523.f1) <= l_517.f2) >= (-1)) && l_573) >> (uint16_t)4) , l_478.f2) || l_573)))) + (int32_t)1U) <= 0x4826449B);
                }
            }
            l_478.f0 = (((uint16_t)(((int16_t)(l_522.f1 = l_517.f0) * (int16_t)((2 <= (l_522.f0 > l_477.f1)) | l_28)) , (((uint32_t)(l_482.f0 = (l_517.f1 || ((int16_t)(l_486.f0 = ((int16_t)((uint16_t)(!__builtin_ia32_crc32qi(l_478.f0, l_520)) + (uint16_t)65532U) >> (int16_t)13)) << (int16_t)l_486.f2))) % (uint32_t)l_28) != l_482.f2)) - (uint16_t)0x3945) == l_28);
        }
        else
        { /* block id: 295 */
            struct S1 l_592 = {0x0C7446ED,3,-114};
            struct S0 l_643 = {-276,5,-61};
            for (l_28 = (-25); (l_28 == (-21)); l_28 += 6)
            { /* block id: 298 */
                int32_t l_601 = (-10);
                struct S0 l_606 = {-4512,8,10};
                for (l_476.f0 = 0; (l_476.f0 <= (-8)); l_476.f0 -= 1)
                { /* block id: 301 */
                    int16_t l_594 = 0;
                    int32_t l_613 = 0x2C69E44E;
                    if ((l_477.f2 = 0xEF31B355))
                    { /* block id: 303 */
                        struct S1 l_591 = {-5,1,-38};
                        l_592 = l_591;
                    }
                    else
                    { /* block id: 305 */
                        struct S0 l_593 = {5467,-9,69};
                        l_477 = l_593;
                    }
                    l_476.f2 &= l_594;
                    l_476.f2 ^= l_485.f1;
                    if (((int32_t)((int16_t)(((l_520 , (l_592.f2 | 0x7ABCC978)) <= ((uint32_t)(l_601 | (l_485.f2 >= ((((int16_t)(l_592.f0 = (-7)) * (int16_t)((uint16_t)func_29(l_606, (-(uint32_t)0xC95DFDBF), ((((int16_t)(-1) >> (int16_t)l_606.f2) || l_594) <= 4294967295U), l_594) << (uint16_t)l_606.f0)) , 0x40659B9E) | l_594))) % (uint32_t)l_476.f0)) < 0x5C051AD2) + (int16_t)l_592.f1) - (int32_t)l_520))
                    { /* block id: 311 */
                        int16_t l_612 = 0xC992;
                        l_613 = ((int32_t)l_594 - (int32_t)l_612);
                        l_481.f0 = ((uint32_t)((l_517.f0 = l_613) | 4294967291U) - (uint32_t)((int16_t)(l_485.f2 = l_606.f1) >> (int16_t)l_517.f1));
                    }
                    else
                    { /* block id: 316 */
                        l_486 = l_592;
                        l_479.f0 &= l_592.f2;
                    }
                }
                if ((l_481.f0 &= ((uint32_t)((((uint32_t)((uint16_t)0xB4D9 >> (uint16_t)l_477.f2) + (uint32_t)((l_479.f1 = func_42(l_601)) >= ((int16_t)(((~l_606.f2) != ((l_485 , (l_606.f1 &= l_486.f1)) || __builtin_popcountl(((l_606.f1 = func_29(l_477, ((((int16_t)l_476.f1 >> (int16_t)l_606.f0) && l_606.f0) , 0x4C8077C0), l_477.f2, l_592.f2)) , 0x4CF0D9C3)))) && l_485.f0) * (int16_t)l_517.f1))) == l_485.f2) , l_477.f1) % (uint32_t)l_517.f1)))
                { /* block id: 325 */
                    int32_t l_639 = 0x25AFC368;
                    int32_t l_640 = 5;
                    uint16_t l_642 = 0U;
                    for (l_520 = (-20); (l_520 < 46); l_520 += 1)
                    { /* block id: 328 */
                        uint32_t l_644 = 0x6D89FAE1;
                        int32_t l_645 = (-3);
                        l_645 = (func_66((l_592.f2 | ((4294967288U | (((uint16_t)(l_606.f0 = 0x0903) - (uint16_t)(l_44 & ((l_606.f2 && 0xCF42E50F) & (func_54(((-(uint32_t)func_49(((l_485 , ((65535U > (((int16_t)(l_485.f2 = ((l_639 = func_54(((uint32_t)l_638 + (uint32_t)l_517.f2))) <= 4294967295U)) * (int16_t)l_640) && 0x9D96)) ^ l_641)) >= l_642), l_485.f1, l_486.f1, l_517.f2)) > (-1))) > l_517.f0)))) > 4294967286U)) , l_479.f1)), l_643, l_606.f1, l_644, l_606.f2) , l_517.f0);
                    }
                    for (l_44 = 0; (l_44 >= (-5)); l_44 -= 1)
                    { /* block id: 336 */
                        l_643.f2 |= (l_517.f0 = l_486.f0);
                    }
                    for (l_638 = (-12); (l_638 <= 34); l_638 += 1)
                    { /* block id: 342 */
                        return l_517.f2;
                    }
                }
                else
                { /* block id: 345 */
                    int16_t l_650 = 0xF05D;
                    l_650 |= (l_606.f1 = l_486.f0);
                }
                if (l_486.f1)
                    break;
                l_486.f2 = 0xBF658F8E;
            }
        }
    }
    else
    { /* block id: 353 */
        struct S0 l_651 = {-2122,-1,-30};
        int16_t l_660 = 1;
        struct S1 l_676 = {0x86060A22,9,180};
        l_660 = ((l_651 , ((l_485.f2 ^ l_485.f2) | 0xF2B1)) == ((int16_t)((l_485.f1 && (~l_651.f1)) > ((((l_638 ^ (((uint16_t)((((!l_651.f2) == (__builtin_clzll((l_479.f1 = ((((int32_t)(-1) - (int32_t)l_28) | 7) & l_651.f0))) , l_651.f2)) == l_651.f1) , l_641) - (uint16_t)0x4296) > 2U)) <= 0) ^ 0) ^ l_485.f1)) * (int16_t)l_638));
        for (l_660 = 4; (l_660 == 10); l_660 += 7)
        { /* block id: 358 */
            uint16_t l_667 = 0x8E94;
            struct S0 l_677 = {-5214,5,-9};
            if (((l_651.f0 ^= ((uint16_t)(l_517.f2 != ((uint32_t)__builtin_popcountl((l_479.f1 ^= func_42(l_667))) - (uint32_t)((int16_t)((((int16_t)(0U || (0xCE26 && (l_651.f1 | ((uint32_t)((int16_t)l_667 >> (int16_t)2) + (uint32_t)func_75(l_660, l_517.f0, l_667, l_676, l_479.f0))))) + (int16_t)1) && 1U) < 1) * (int16_t)0x69A0))) >> (uint16_t)l_667)) == l_517.f0))
            { /* block id: 361 */
                int16_t l_679 = (-10);
                int32_t l_685 = 0xFC5964F4;
                l_677 = func_34(l_480);
                l_676.f2 ^= (!((l_651.f0 = l_679) == (l_676.f1 , (((!(0xFCF771E9 | l_651.f1)) > (l_651.f1 <= ((int16_t)l_667 * (int16_t)(l_679 >= l_485.f0)))) || ((uint16_t)l_679 * (uint16_t)1)))));
                l_685 = (l_651.f1 = l_679);
                for (l_485.f0 = 0; (l_485.f0 > (-22)); l_485.f0 -= 7)
                { /* block id: 369 */
                    int8_t l_692 = 0x83;
                    int32_t l_693 = 0xCEDA2C19;
                    l_692 = ((l_517.f0 ^= __builtin_clz((((l_677.f1 = l_685) <= (l_677.f2 = ((int16_t)((int16_t)l_679 << (int16_t)8) >> (int16_t)6))) | l_676.f2))) == func_42(l_676.f2));
                    l_693 = l_651.f0;
                    if (l_660)
                        break;
                    l_677.f2 |= 0xAC08895D;
                }
            }
            else
            { /* block id: 378 */
                int16_t l_695 = 1;
                l_517.f0 = ((__builtin_ctz(l_694) ^ ((l_695 != ((((l_676.f0 < (l_677.f1 <= l_517.f2)) > l_677.f1) , ((int16_t)((((l_677.f1 != (0 < l_676.f2)) | l_676.f1) != 65535U) == (-1)) << (int16_t)l_695)) || l_676.f2)) <= l_651.f0)) , l_676.f0);
            }
        }
        l_651.f1 = ((uint16_t)__builtin_parity(l_660) + (uint16_t)l_700);
    }
    return l_517.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_29(struct S0  p_30, uint32_t  p_31, int16_t  p_32, uint32_t  p_33)
{ /* block id: 224 */
    struct S1 l_432 = {-1,10,-195};
    int32_t l_433 = (-4);
    int16_t l_445 = 0;
    l_432 = l_432;
    p_30.f1 = (l_432.f0 = (l_433 |= (l_432.f2 < l_432.f0)));
    for (p_33 = 18; (p_33 > 24); p_33 += 1)
    { /* block id: 231 */
        uint16_t l_442 = 0xE014;
        uint32_t l_450 = 8U;
        int32_t l_459 = 0x41B23E04;
        int32_t l_460 = 0xDE78D617;
        struct S0 l_461 = {6680,-0,-56};
        p_30.f1 = ((__builtin_popcountll(((int16_t)(((int16_t)(l_460 ^= (l_433 = ((int16_t)(__builtin_parityl((l_432.f2 = (((__builtin_popcountll((l_442 > (p_31 , ((int16_t)((func_54((0 ^ __builtin_ffsl(l_442))) , l_445) <= (p_32 &= ((int16_t)((int16_t)l_450 >> (int16_t)((int16_t)(((l_459 = ((uint16_t)(((uint16_t)((uint16_t)(0U | p_30.f2) % (uint16_t)0x736A) >> (uint16_t)l_450) && 0x5BDC) % (uint16_t)p_33)) & l_442) > 1) << (int16_t)4)) + (int16_t)65535U))) >> (int16_t)0)))) <= l_445) ^ 0x580D3211) | (-7)))) , 0xD953) + (int16_t)8U))) - (int16_t)0xAA45) , p_30.f1) % (int16_t)5)) >= l_432.f0) != p_30.f2);
        l_432.f0 |= (l_461 , (0U && (((uint16_t)(0x7A90DA04 | ((l_433 = __builtin_ctzll((func_54(l_461.f1) , ((uint16_t)(l_461.f2 = ((-(int32_t)((int16_t)((((l_461.f1 | 0x12B6D85F) != (__builtin_ia32_crc32qi(((uint16_t)((p_31 == l_442) <= 0x3FC86E06) << (uint16_t)p_30.f2), p_30.f0) & l_460)) >= 0xF38741EE) || l_445) >> (int16_t)14)) != p_31)) << (uint16_t)l_432.f2)))) > l_460)) * (uint16_t)0U) > l_459)));
    }
    return l_433;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_34(uint32_t  p_35)
{ /* block id: 215 */
    int32_t l_426 = 0x21E987AC;
    struct S0 l_431 = {-311,0,-87};
    l_426 = p_35;
    for (p_35 = (-30); (p_35 == 18); p_35 += 1)
    { /* block id: 219 */
        uint16_t l_429 = 0xD710;
        l_429 = l_426;
        l_426 = ((~p_35) | p_35);
    }
    return l_431;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_39(int16_t  p_40, int8_t  p_41)
{ /* block id: 102 */
    struct S0 l_204 = {7240,-1,-34};
    int32_t l_215 = (-7);
    int32_t l_216 = 0x1CCF118B;
    struct S1 l_217 = {0x21E8A32C,4,-177};
    int16_t l_264 = (-5);
    struct S0 l_413 = {-4344,7,57};
    l_217 = func_66(p_41, l_204, p_40, (l_204.f1 <= ((int16_t)(l_216 = (((int32_t)func_49(l_204.f2, l_204.f0, ((uint16_t)1U * (uint16_t)(((int16_t)l_204.f1 + (int16_t)(l_215 = ((~(~l_204.f1)) & l_204.f2))) , l_204.f0)), l_204.f1) - (int32_t)l_204.f2) > 0xB601)) << (int16_t)8)), l_204.f2);
    for (p_40 = 0; (p_40 != (-7)); p_40 -= 1)
    { /* block id: 108 */
        int32_t l_238 = (-1);
        int32_t l_239 = 1;
        int32_t l_250 = 1;
        int32_t l_251 = 2;
        int32_t l_252 = 3;
        struct S1 l_253 = {0xDA4D15D3,3,-192};
        int32_t l_254 = 0x4AFDE6B9;
        uint32_t l_255 = 0xDBBE093A;
        uint32_t l_290 = 4294967293U;
        struct S0 l_302 = {6455,-1,-89};
        uint32_t l_303 = 0x783CCC9B;
        for (l_216 = 0; (l_216 == 9); l_216 += 7)
        { /* block id: 111 */
            uint32_t l_228 = 0xCDCBAFF7;
            int32_t l_237 = (-1);
            l_238 = (l_237 = ((int16_t)(((uint16_t)((int16_t)l_228 >> (int16_t)13) % (uint16_t)((int32_t)l_204.f1 - (int32_t)((((uint32_t)p_40 + (uint32_t)0x57AF3478) && func_54(((int16_t)(-1) >> (int16_t)3))) | p_41))) & l_204.f2) + (int16_t)(((uint16_t)((((__builtin_ctz(l_228) , l_228) >= l_217.f1) == 0x36BD) , l_228) - (uint16_t)p_40) | p_41)));
            l_204.f2 = l_238;
            l_239 ^= p_41;
        }
        l_254 &= ((((int32_t)(((p_40 >= l_217.f0) ^ (((int16_t)(l_217.f1 || func_75(((l_238 , ((l_216 > (((l_252 &= (((int16_t)(l_251 |= ((uint16_t)(l_204.f1 = ((l_239 = l_239) && l_217.f1)) << (uint16_t)(l_250 = ((int16_t)p_40 * (int16_t)(p_41 >= p_41))))) << (int16_t)p_41) & l_217.f1)) >= p_41) != p_40)) | p_41)) , l_251), p_41, p_41, l_253, l_253.f2)) * (int16_t)p_41) , 0x2683)) || 0) % (int32_t)p_41) < l_238) || 6U);
        l_250 = l_255;
        if (((uint16_t)(1U & ((((uint16_t)(((uint16_t)p_40 % (uint16_t)l_215) && 0xB6CC735A) >> (uint16_t)(((uint16_t)p_41 + (uint16_t)l_264) < ((int16_t)(p_40 | 4294967295U) >> (int16_t)(7U >= p_40)))) >= l_251) < l_215)) + (uint16_t)l_252))
        { /* block id: 124 */
            int8_t l_267 = (-1);
            l_267 |= p_40;
        }
        else
        { /* block id: 126 */
            int32_t l_268 = 0xDEA13161;
            int32_t l_269 = 0xDBA93513;
            struct S0 l_274 = {-5262,0,60};
            int32_t l_279 = (-1);
            int32_t l_280 = (-7);
            int8_t l_291 = (-1);
            uint32_t l_314 = 0x52B09809;
            uint32_t l_321 = 4294967290U;
            uint32_t l_389 = 4U;
            int8_t l_418 = 0x5A;
            l_269 = __builtin_popcountl((l_268 ^= p_40));
            for (l_269 = 0; (l_269 >= (-29)); l_269 -= 7)
            { /* block id: 131 */
                uint32_t l_283 = 1U;
                int32_t l_301 = 0x79F683CE;
                l_280 ^= (l_253.f0 = ((int16_t)((l_274 , ((uint32_t)p_41 % (uint32_t)__builtin_clzll(l_217.f2))) <= (l_238 <= (((l_204.f0 = ((((uint16_t)(l_279 &= func_54(l_255)) >> (uint16_t)func_75(((4294967288U < 0xF93D7C05) ^ 0x9281), l_215, p_41, l_253, p_41)) | 0x978F) < p_41)) | p_40) <= 0x9720))) * (int16_t)0x16EF));
                l_280 = ((int32_t)l_283 + (int32_t)((int16_t)((l_279 ^= (func_66(((l_254 = l_283) , ((uint16_t)__builtin_parity((((l_283 || (l_301 = (((((int16_t)(l_290 && (0xB942 != (0xC576 | (((l_291 > ((uint16_t)(((uint16_t)(l_268 < ((!((int16_t)((uint16_t)5U % (uint16_t)l_283) * (int16_t)p_41)) == l_291)) * (uint16_t)0xCF51) & l_283) + (uint16_t)65535U)) || l_217.f2) < l_255)))) * (int16_t)0x49D4) >= p_40) | p_40) != (-1)))) && p_41) == p_41)) - (uint16_t)9)), l_302, p_40, l_303, l_302.f2) , 0x3CF4)) ^ 65526U) >> (int16_t)13));
            }
            if (p_40)
            { /* block id: 141 */
                return p_41;
            }
            else
            { /* block id: 143 */
                int32_t l_304 = (-7);
                int32_t l_318 = 0;
                int32_t l_319 = 0xAD9700F0;
                uint32_t l_374 = 0x0D79999D;
                struct S1 l_401 = {0x4B0FBFB2,10,57};
                l_304 = l_217.f0;
                if (((p_40 && l_215) == ((int32_t)(((int16_t)(l_319 &= (((p_41 && (((int16_t)(-7) * (int16_t)l_304) != (!l_314))) ^ (0 & ((uint32_t)(l_264 != ((l_318 = ((~(((l_304 >= p_40) & p_41) && 0U)) & 0xB66C)) && l_303)) % (uint32_t)l_253.f1))) != p_41)) - (int16_t)p_41) | p_40) + (int32_t)4294967295U)))
                { /* block id: 147 */
                    uint16_t l_326 = 65535U;
                    struct S0 l_339 = {-4937,-1,-4};
                    l_274.f1 &= (-(int32_t)(__builtin_popcountll(l_321) ^ (l_215 = ((uint16_t)((uint16_t)l_318 % (uint16_t)__builtin_ffsl(l_326)) + (uint16_t)p_40))));
                    for (l_254 = 0; (l_254 != (-19)); l_254 -= 1)
                    { /* block id: 152 */
                        uint32_t l_335 = 4294967291U;
                        int16_t l_349 = 0x86E1;
                        l_274 = ((((int32_t)l_274.f1 + (int32_t)(l_269 = ((l_302 , func_42((l_280 = ((uint16_t)((uint32_t)l_335 - (uint32_t)l_304) << (uint16_t)l_326)))) >= p_41))) | (((int16_t)((!(p_40 == (l_319 = 0x644D))) , 0x8AC4) * (int16_t)l_274.f1) , l_253.f2)) , l_339);
                        l_204.f0 = (((uint16_t)(l_239 = ((uint16_t)((((func_42(((((((p_40 & l_291) < l_326) , ((int16_t)(l_318 <= ((((((~2U) == (((int16_t)0x64A5 << (int16_t)2) | 9U)) == ((65533U | (l_339.f1 = 0x33CE)) < l_255)) && p_41) >= l_253.f2) & l_291)) >> (int16_t)5)) , 0x46D31012) ^ p_40) == p_41)) >= 0x649A409E) && p_40) == 0) != p_40) - (uint16_t)p_40)) * (uint16_t)65528U) && l_349);
                        if (p_40)
                            break;
                    }
                    l_204.f2 = (((uint16_t)(((int16_t)6 % (int16_t)((uint16_t)__builtin_ctzl(p_40) >> (uint16_t)((uint16_t)(((uint16_t)0xC56E >> (uint16_t)6) > ((uint16_t)0x80A3 << (uint16_t)(__builtin_clzll(l_319) && (l_318 ^ (((l_319 >= l_314) , p_41) || 3))))) * (uint16_t)0xD779))) | p_40) + (uint16_t)l_339.f2) <= l_280);
                }
                else
                { /* block id: 163 */
                    int32_t l_373 = 0xF69760B0;
                    if ((((l_304 = (((l_290 , ((uint16_t)(~((uint16_t)p_40 << (uint16_t)4)) + (uint16_t)((((int16_t)l_204.f0 >> (int16_t)10) , (p_40 & (-1))) > func_49((((((uint32_t)(l_302.f0 &= 0x4B34C819) + (uint32_t)(l_269 , p_40)) , ((uint16_t)(l_373 & p_40) << (uint16_t)l_374)) != p_41) , 1U), l_238, l_318, l_274.f1)))) , 0x0D55) ^ l_373)) , p_40) && p_40))
                    { /* block id: 166 */
                        l_373 = (p_40 >= p_41);
                    }
                    else
                    { /* block id: 168 */
                        return p_41;
                    }
                    if ((((-1) >= l_253.f0) ^ 1U))
                    { /* block id: 171 */
                        return p_41;
                    }
                    else
                    { /* block id: 173 */
                        return l_373;
                    }
                }
                if ((((uint16_t)((int16_t)((int32_t)(l_318 = ((l_215 = (l_253.f0 < l_280)) <= ((uint32_t)0x899B7062 % (uint32_t)p_41))) % (int32_t)(l_204.f1 = p_40)) * (int16_t)(~0x3242E564)) >> (uint16_t)0) > 0x80C8))
                { /* block id: 180 */
                    uint16_t l_388 = 0xE1FC;
                    int32_t l_403 = 0x05FA5C55;
                    struct S1 l_405 = {-1,5,4};
                    int32_t l_412 = 0;
                    if (((l_274.f2 |= (2 <= ((int16_t)((uint16_t)(p_41 | (l_388 == l_389)) - (uint16_t)((((l_274.f1 |= (l_280 = ((l_217.f2 = l_318) , (p_40 , ((0 ^ ((uint32_t)p_41 - (uint32_t)(((p_40 , 0xD2AF201F) ^ p_41) & 0x1166EDB2))) != l_204.f1))))) , p_40) | p_40) || 0x9532293B)) >> (int16_t)3))) ^ p_41))
                    { /* block id: 185 */
                        int16_t l_402 = 4;
                        l_403 = ((l_254 || (__builtin_popcount(l_314) == (p_40 > ((int32_t)l_238 + (int32_t)((l_215 ^= ((uint32_t)((-(int32_t)((((int16_t)__builtin_clzl(((l_253.f2 ^= func_75(l_252, ((uint16_t)(((((0x04EA | (p_41 & (l_318 <= 0x019D))) & p_41) != p_40) && p_40) && l_217.f1) << (uint16_t)p_41), l_318, l_401, l_253.f0)) ^ l_319)) * (int16_t)p_41) , p_40) < 0xFFCB)) == l_374) - (uint32_t)l_217.f1)) || l_402))))) < p_40);
                    }
                    else
                    { /* block id: 189 */
                        int32_t l_404 = 0x8D4D5479;
                        l_404 = p_41;
                        l_204.f2 = ((p_40 <= l_204.f0) < l_269);
                        if (l_404)
                            continue;
                    }
                    l_405 = l_253;
                    l_274.f0 = __builtin_ctz(((int16_t)((uint32_t)((int16_t)l_412 - (int16_t)(p_40 , (__builtin_bswap32(l_268) > l_401.f1))) + (uint32_t)(__builtin_parityll(p_41) , (l_204.f1 , (((((l_253.f0 |= ((l_413 = (l_204 = l_274)) , l_405.f1)) & 0) < p_40) | p_40) && 0x4D9D)))) * (int16_t)l_405.f1));
                    return l_318;
                }
                else
                { /* block id: 200 */
                    if (p_41)
                    { /* block id: 201 */
                        uint32_t l_414 = 0x6559237E;
                        l_253.f0 |= l_414;
                        return p_40;
                    }
                    else
                    { /* block id: 204 */
                        int16_t l_421 = 8;
                        int32_t l_422 = 0x034A355E;
                        l_274.f0 |= (((uint16_t)((l_422 = (!(l_418 >= ((uint16_t)((p_40 >= (l_239 = 0xAC0322A8)) | l_421) >> (uint16_t)1)))) != 0x0F64) >> (uint16_t)15) <= p_40);
                        return l_279;
                    }
                }
            }
        }
    }
    return l_413.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_42(uint32_t  p_43)
{ /* block id: 38 */
    uint32_t l_47 = 4294967295U;
    int32_t l_203 = 1;
    for (p_43 = 0; (p_43 != 28); p_43 += 7)
    { /* block id: 41 */
        struct S1 l_48 = {6,6,201};
        int32_t l_202 = (-1);
        if (l_47)
            break;
        if ((((l_48 , func_49(p_43, func_54(l_47), p_43, l_47)) != l_48.f0) & ((uint16_t)0x0853 << (uint16_t)9)))
        { /* block id: 93 */
            l_202 ^= l_47;
            return p_43;
        }
        else
        { /* block id: 96 */
            return l_47;
        }
    }
    l_203 &= (l_47 <= func_54(p_43));
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_49(uint32_t  p_50, int32_t  p_51, int8_t  p_52, int32_t  p_53)
{ /* block id: 88 */
    int32_t l_190 = 7;
    struct S0 l_191 = {-6858,9,8};
    int16_t l_192 = 0x2FDF;
    struct S1 l_193 = {-10,0,80};
    int32_t l_195 = 0;
    l_190 = (!((p_51 == ((int32_t)((l_191.f0 = func_75(((int32_t)(~(((((p_52 & ((int32_t)p_51 % (int32_t)0x77FDBCA6)) , (p_50 & ((func_75(l_190, l_190, p_52, func_66(l_190, l_191, p_50, l_192, p_51), l_191.f1) & l_191.f1) > 0xED5062BB))) , l_192) != 65535U) < 0)) - (int32_t)l_191.f1), l_192, p_53, l_193, p_51)) , (-1)) + (int32_t)1)) & l_193.f0));
    l_191.f1 &= (!((((p_52 | l_193.f0) , l_195) < 0x2D88AC7E) <= (((((int32_t)((l_190 <= p_53) <= ((int32_t)l_193.f2 + (int32_t)func_54(l_191.f2))) + (int32_t)0xFB6A07BB) | l_191.f0) < p_52) > p_50)));
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_54(int16_t  p_55)
{ /* block id: 43 */
    uint32_t l_72 = 4294967295U;
    int32_t l_85 = 0xB4954824;
    int32_t l_92 = 0x88DFEF28;
    int16_t l_93 = 0x81CA;
    struct S1 l_94 = {1,4,-244};
    struct S0 l_96 = {5962,-4,-88};
    int32_t l_175 = 0;
    l_175 &= (((((int16_t)((int16_t)((l_94 = func_60((func_66((l_72 >= ((int16_t)l_72 + (int16_t)func_75(((uint32_t)(((uint16_t)(p_55 | (l_85 = l_72)) >> (uint16_t)15) & ((uint32_t)(((uint32_t)(l_92 = p_55) - (uint32_t)l_72) ^ (__builtin_ctzll(p_55) == (p_55 >= 0x3ADA))) % (uint32_t)p_55)) % (uint32_t)l_93), l_93, p_55, l_94, p_55))), l_96, p_55, l_93, l_96.f1) , p_55), l_96.f1, l_96, l_96.f2, l_96)) , 0xFDAC) << (int16_t)8) % (int16_t)0xD8B5) > 1) && 3) && p_55);
    for (l_92 = 0; (l_92 == (-22)); l_92 -= 1)
    { /* block id: 84 */
        uint16_t l_178 = 1U;
        int32_t l_179 = 4;
        l_179 = l_178;
    }
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_60(int16_t  p_61, int16_t  p_62, struct S0  p_63, uint16_t  p_64, struct S0  p_65)
{ /* block id: 74 */
    uint32_t l_165 = 9U;
    int8_t l_166 = 1;
    struct S1 l_167 = {-1,2,232};
    int32_t l_174 = 0xDB83A45D;
    l_174 ^= ((((int16_t)(((uint16_t)(((l_165 <= l_165) | ((((l_165 < (l_166 = p_65.f0)) , (l_167 , 0x314DBE92)) , ((p_64 >= func_75((l_166 < ((uint16_t)((uint16_t)func_75(((__builtin_clz((((((uint32_t)(p_63.f1 | l_167.f2) + (uint32_t)l_167.f0) ^ 0x79F5) ^ p_64) , 0xC1DB4CFA)) || p_62) > 0x35A271B2), p_65.f2, l_167.f0, l_167, p_62) - (uint16_t)l_167.f2) + (uint16_t)p_64)), l_165, l_166, l_167, p_63.f1)) != 1)) < (-6))) == l_167.f0) * (uint16_t)l_167.f0) != l_167.f0) << (int16_t)8) < p_62) , p_65.f1);
    p_65.f0 = (l_167.f0 = l_167.f0);
    return l_167;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_66(uint32_t  p_67, struct S0  p_68, uint16_t  p_69, uint32_t  p_70, int8_t  p_71)
{ /* block id: 48 */
    int32_t l_97 = 0x384C7B93;
    struct S1 l_98 = {0x75AC3517,9,83};
    struct S0 l_99 = {-2858,-7,29};
    int8_t l_118 = 8;
    uint32_t l_146 = 0x206065F2;
    l_97 ^= p_68.f0;
    if ((l_98 , ((((l_99 = p_68) , p_69) > (l_97 = p_67)) || (l_97 & (0xA291 <= l_97)))))
    { /* block id: 52 */
        int32_t l_107 = 1;
        int32_t l_108 = (-1);
        int32_t l_115 = 0x758A71D4;
        l_99.f1 = (p_68.f1 ^= (!(((l_97 &= ((int32_t)((((l_115 = ((4U < p_71) & ((p_68.f2 == (((int16_t)p_69 >> (int16_t)9) & l_107)) ^ (((l_108 = p_69) , p_68.f2) && (l_107 , (((uint16_t)((uint16_t)((int16_t)l_107 * (int16_t)l_99.f0) << (uint16_t)10) * (uint16_t)1) <= 0xE4E4C4DC)))))) & 0x8699) ^ 0x3379BBDC) != 1) % (int32_t)0x4F5E99A5)) >= 0xB73647B8) && 0)));
    }
    else
    { /* block id: 58 */
        int32_t l_143 = (-1);
        int8_t l_144 = 0x21;
        struct S1 l_145 = {0xFDD64987,1,46};
        int8_t l_158 = 0;
        l_97 = ((func_75(p_70, ((int32_t)((l_118 < ((((-(int32_t)(65526U < l_118)) != ((int16_t)0x2FCB * (int16_t)((uint16_t)((uint32_t)((l_143 = ((((uint16_t)(((uint16_t)((uint16_t)((int16_t)__builtin_popcount((((func_75(((uint16_t)(-(uint32_t)((int16_t)((((uint32_t)p_68.f0 % (uint32_t)((p_68.f2 &= ((int16_t)l_99.f1 % (int16_t)__builtin_ia32_crc32qi((0x6DA17685 ^ (((func_75(l_98.f0, l_99.f1, l_97, l_98, l_97) < 1U) | p_71) > p_69)), l_143))) | 9)) , l_143) >= (-1)) * (int16_t)0x6421)) - (uint16_t)l_143), p_71, p_68.f1, l_98, l_143) <= l_143) | p_69) | l_143)) << (int16_t)p_69) >> (uint16_t)l_143) << (uint16_t)12) , 5U) - (uint16_t)p_67) & p_69) > l_143)) > l_144) - (uint32_t)1) + (uint16_t)l_99.f0))) || p_68.f0) , 0xFF72)) ^ l_144) + (int32_t)l_144), l_99.f0, l_145, p_67) != p_68.f0) , l_146);
        for (l_146 = 4; (l_146 <= 55); l_146 += 1)
        { /* block id: 64 */
            int32_t l_159 = (-1);
            int32_t l_160 = 0xAD1E1EA8;
            l_97 = ((((uint32_t)((((uint16_t)(l_98.f2 = (l_145 , (p_70 | (p_71 > ((int16_t)(l_145 , (l_145.f2 = l_98.f1)) + (int16_t)(p_69 = ((((~__builtin_parityll((l_160 = ((uint16_t)((p_70 & (func_75(l_158, l_159, ((p_68.f1 ^ 1U) , p_71), l_98, l_97) && p_68.f1)) , l_159) >> (uint16_t)10)))) <= p_68.f0) || l_99.f0) > l_159))))))) >> (uint16_t)2) > l_98.f1) == l_159) - (uint32_t)l_99.f2) , l_159) >= 0xB1FDE04A);
        }
        l_145 = l_98;
    }
    return l_98;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_75(uint32_t  p_76, uint16_t  p_77, int16_t  p_78, struct S1  p_79, uint16_t  p_80)
{ /* block id: 46 */
    int8_t l_95 = 0xB1;
    return l_95;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 125
   depth: 1, occurrence: 43
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 43
breakdown:
   indirect level: 0, occurrence: 43
XXX full-bitfields structs in the program: 24
breakdown:
   indirect level: 0, occurrence: 24
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 19
XXX times a bitfields struct on RHS: 57
XXX times a single bitfield on LHS: 72
XXX times a single bitfield on RHS: 184

XXX max expression depth: 55
breakdown:
   depth: 1, occurrence: 138
   depth: 2, occurrence: 27
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 13, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 2
   depth: 23, occurrence: 5
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 28, occurrence: 3
   depth: 30, occurrence: 1
   depth: 31, occurrence: 2
   depth: 32, occurrence: 1
   depth: 34, occurrence: 1
   depth: 36, occurrence: 1
   depth: 37, occurrence: 1
   depth: 38, occurrence: 2
   depth: 43, occurrence: 1
   depth: 55, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 735
XXX times a non-volatile is write: 205
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 140
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 19
   depth: 2, occurrence: 17
   depth: 3, occurrence: 17
   depth: 4, occurrence: 26
   depth: 5, occurrence: 33

XXX percentage a fresh-made variable is used: 18.4
XXX percentage an existing variable is used: 81.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

