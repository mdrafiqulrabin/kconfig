/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1179931968
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int64_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
static struct S0 * func_2(int16_t  p_3, struct S0 * p_4);
static struct S0 * func_7(float  p_8);
inline static float  func_9(const struct S0 * p_10);
static struct S0 * func_11(struct S0 * p_12, struct S0 * p_13, int64_t  p_14, const int16_t  p_15);
static struct S0 * func_16(int16_t  p_17, const int32_t  p_18, int64_t  p_19, struct S0 * p_20);
inline static int32_t  func_26(int16_t  p_27);
static int8_t  func_30(struct S0 * p_31, struct S0 * p_32);
static int32_t * func_65(const struct S0 ** p_66, uint32_t  p_67, int32_t ** p_68, struct S0 ** p_69);
static const struct S0 ** func_70(int32_t  p_71, struct S0 ** p_72, uint32_t  p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    struct S0 l_6 = {0L};
    struct S0 *l_5 = &l_6;
    struct S0 **l_1732[1][2];
    struct S0 *l_1733 = (void*)0;
    int32_t l_1734 = 1L;
    const struct S0 *l_1737 = (void*)0;
    const struct S0 **l_1736[2];
    int32_t *l_1739 = &l_1734;
    int32_t **l_1738 = &l_1739;
    int i, j;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 2; j++)
            l_1732[i][j] = (void*)0;
    }
    for (i = 0; i < 2; i++)
        l_1736[i] = &l_1737;
    l_1733 = func_2(((void*)0 != l_5), func_7((((void*)0 != &l_6) <= func_9(func_11(func_16(l_6.f0, l_6.f0, (l_6.f0 <= ((l_6.f0 && (l_6.f0 < 1UL)) | l_6.f0)), &l_6), &l_6, l_6.f0, l_6.f0)))));
    l_1732[0][0] = &l_1733;
    /* statement id: 945 */
    //assert (l_1732[0][0] == &l_1733 || l_1732[0][0] == 0);
    if (l_6.f0)
        goto lbl_1735;
lbl_1735:
    l_1734 = l_6.f0;
    (*l_1738) = func_65(l_1736[0], l_1734, l_1738, &l_1733);
    /* statement id: 948 */
    assert (l_1739 == 0);
    return l_1734;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_2(int16_t  p_3, struct S0 * p_4)
{ /* block id: 722 */
    struct S0 l_1342 = {9L};
    struct S0 *l_1341[10][2][2] = {{{(void*)0,&l_1342},{&l_1342,(void*)0}},{{&l_1342,(void*)0},{&l_1342,(void*)0}},{{&l_1342,&l_1342},{(void*)0,&l_1342}},{{&l_1342,&l_1342},{&l_1342,&l_1342}},{{&l_1342,&l_1342},{&l_1342,&l_1342}},{{&l_1342,&l_1342},{(void*)0,&l_1342}},{{&l_1342,(void*)0},{&l_1342,(void*)0}},{{&l_1342,(void*)0},{&l_1342,&l_1342}},{{(void*)0,&l_1342},{&l_1342,&l_1342}},{{&l_1342,&l_1342},{&l_1342,&l_1342}}};
    struct S0 **l_1340 = &l_1341[1][1][1];
    struct S0 ***l_1339[1];
    struct S0 ****l_1338 = &l_1339[0];
    int32_t l_1358 = 8L;
    int32_t *l_1357 = &l_1358;
    int32_t **l_1356[1][2];
    int32_t ***l_1355 = &l_1356[0][0];
    int32_t ****l_1354 = &l_1355;
    int32_t *****l_1353 = &l_1354;
    int16_t l_1408 = 0x3B43L;
    const uint32_t l_1526 = 4294967295UL;
    uint16_t l_1531[2];
    int32_t *l_1588[7][8] = {{&l_1358,&l_1358,(void*)0,&l_1358,&l_1358,(void*)0,&l_1358,&l_1358},{&l_1358,&l_1358,&l_1358,&l_1358,&l_1358,(void*)0,&l_1358,&l_1358},{&l_1358,&l_1358,&l_1358,&l_1358,&l_1358,&l_1358,&l_1358,&l_1358},{&l_1358,(void*)0,&l_1358,&l_1358,&l_1358,&l_1358,&l_1358,(void*)0},{&l_1358,&l_1358,(void*)0,&l_1358,&l_1358,&l_1358,&l_1358,&l_1358},{&l_1358,&l_1358,&l_1358,&l_1358,&l_1358,(void*)0,&l_1358,&l_1358},{&l_1358,&l_1358,(void*)0,&l_1358,(void*)0,&l_1358,&l_1358,&l_1358}};
    float l_1612 = 0xA.1F2A78p-73;
    float *l_1611[8] = {&l_1612,(void*)0,&l_1612,&l_1612,(void*)0,&l_1612,&l_1612,(void*)0};
    float **l_1610[3];
    float ***l_1609 = &l_1610[2];
    float *** const *l_1608 = &l_1609;
    float *** const **l_1607[1][8] = {{&l_1608,&l_1608,&l_1608,&l_1608,&l_1608,&l_1608,&l_1608,&l_1608}};
    int32_t *l_1645 = &l_1358;
    int32_t **l_1648 = &l_1645;
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_1339[i] = &l_1340;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 2; j++)
            l_1356[i][j] = &l_1357;
    }
    for (i = 0; i < 2; i++)
        l_1531[i] = 0UL;
    for (i = 0; i < 3; i++)
        l_1610[i] = &l_1611[0];
    return p_4;
    /* statement id: 943 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_7(float  p_8)
{ /* block id: 719 */
    int32_t l_1299[8] = {0x1F0B1C71L,0x1F0B1C71L,0x1F0B1C71L,0x1F0B1C71L,0x1F0B1C71L,0x1F0B1C71L,0x1F0B1C71L,0x1F0B1C71L};
    float l_1310 = 0x3.D8907Bp-52;
    float *l_1309 = &l_1310;
    float **l_1308 = &l_1309;
    int32_t *l_1324 = &l_1299[6];
    struct S0 l_1326 = {0x224C8F1525CEC73DLL};
    struct S0 *l_1325 = &l_1326;
    struct S0 *l_1327 = &l_1326;
    struct S0 *l_1328[8] = {&l_1326,&l_1326,&l_1326,&l_1326,&l_1326,&l_1326,&l_1326,&l_1326};
    struct S0 *l_1329[7][4] = {{(void*)0,&l_1326,&l_1326,(void*)0},{&l_1326,(void*)0,&l_1326,&l_1326},{(void*)0,(void*)0,&l_1326,(void*)0},{(void*)0,&l_1326,&l_1326,(void*)0},{&l_1326,(void*)0,&l_1326,&l_1326},{(void*)0,(void*)0,&l_1326,(void*)0},{(void*)0,&l_1326,&l_1326,(void*)0}};
    struct S0 *l_1330 = &l_1326;
    struct S0 *l_1331 = (void*)0;
    int i, j;
    (*l_1324) = ((l_1299[6] != l_1299[6]) & ((6L && (((((safe_sub_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s((l_1299[4] < (safe_rshift_func_int16_t_s_u(((safe_div_func_uint8_t_u_u((((l_1308 == &l_1309) < (safe_add_func_int64_t_s_s(((7L || (safe_add_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((0xA9AF98D576077F2CLL > (((safe_add_func_int64_t_s_s(((safe_lshift_func_int16_t_s_s((~((safe_mod_func_uint8_t_u_u(l_1299[3], l_1299[3])) && l_1299[6])), 8)) >= l_1299[5]), 0L)) || l_1299[6]) == l_1299[2])), 12)), l_1299[6]))) > l_1299[5]), l_1299[6]))) == (-3L)), 0x92L)) || (-1L)), 8))), 0)), l_1299[1])) & l_1299[1]) && l_1299[6]) != l_1299[3]) != l_1299[6])) != l_1299[4]));
    return l_1331;
    /* statement id: 721 */
    //assert (func_7_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_9(const struct S0 * p_10)
{ /* block id: 691 */
    float l_1280[4][10][6] = {{{(-0x7.3p+1),0x4.FB2F7Ep+64,0x4.3p+1,(-0x8.8p-1),0x0.2p-1,(-0x8.Bp+1)},{0x0.2p-1,0x4.FB2F7Ep+64,0x1.C94BB5p-32,0x4.3p+1,0x1.7p-1,(-0x1.6p-1)},{0x2.0EBE36p+96,(-0x5.2p-1),0x0.48CC68p-32,0x0.48CC68p-32,(-0x5.2p-1),0x2.0EBE36p+96},{0x2.BFAC49p-37,(-0x7.3p+1),(-0x8.8p-1),(-0x1.6p-1),0x0.48CC68p-32,0x9.01774Ap+42},{0x0.9p+1,0x4.3p+1,0x8.577112p-28,0x2.F1DA4Ep+20,0x1.4p+1,0x1.C94BB5p-32},{0x0.9p+1,0x1.C94BB5p-32,0x2.F1DA4Ep+20,(-0x1.6p-1),0x4.FB2F7Ep+64,0x1.4p+1},{0x2.BFAC49p-37,0x0.48CC68p-32,0x0.2p-1,0x0.48CC68p-32,0x2.BFAC49p-37,0x8.577112p-28},{0x2.0EBE36p+96,(-0x8.8p-1),(-0x8.Bp+1),0x4.3p+1,0x1.1p+1,(-0x7.5p-1)},{0x0.2p-1,0x8.577112p-28,0x6.721D72p-94,(-0x8.8p-1),0x1.7F2523p+46,(-0x7.5p-1)},{(-0x7.3p+1),0x2.F1DA4Ep+20,(-0x8.Bp+1),0x9.01774Ap+42,0x8.577112p-28,0x8.577112p-28}},{{0x1.7F2523p+46,0x0.2p-1,0x0.2p-1,0x1.7F2523p+46,(-0x7.3p+1),0x1.4p+1},{0x9.01774Ap+42,(-0x8.Bp+1),0x2.F1DA4Ep+20,(-0x7.3p+1),(-0x1.6p-1),0x1.C94BB5p-32},{(-0x8.8p-1),0x6.721D72p-94,0x8.577112p-28,0x0.2p-1,(-0x1.6p-1),0x9.01774Ap+42},{0x4.3p+1,(-0x8.Bp+1),(-0x8.8p-1),0x0.48CC68p-32,0x0.2p-1,0x0.48CC68p-32},{0x1.7p-1,0x2.C6B258p-59,0x1.7p-1,0x2.F1DA4Ep+20,(-0x5.2p-1),(-0x8.8p-1)},{(-0x8.8p-1),(-0x8.Bp+1),0x4.3p+1,0x1.1p+1,(-0x7.5p-1),0x8.577112p-28},{(-0x8.Bp+1),(-0x5.2p-1),(-0x1.6p-1),0x1.1p+1,0x1.7F2523p+46,0x2.F1DA4Ep+20},{(-0x8.8p-1),0x2.BFAC49p-37,0x0.2p-1,0x2.F1DA4Ep+20,0x2.F1DA4Ep+20,0x0.2p-1},{0x1.7p-1,0x1.7p-1,0x6.721D72p-94,0x0.48CC68p-32,0x2.0EBE36p+96,(-0x8.Bp+1)},{(-0x1.6p-1),0x4.3p+1,0x2.0EBE36p+96,0x2.C6B258p-59,(-0x7.3p+1),0x6.721D72p-94}},{{0x2.BFAC49p-37,(-0x1.6p-1),0x2.0EBE36p+96,0x0.2p-1,0x1.7p-1,(-0x8.Bp+1)},{0x1.C94BB5p-32,0x0.2p-1,0x6.721D72p-94,(-0x7.5p-1),0x6.721D72p-94,0x0.2p-1},{(-0x7.5p-1),0x6.721D72p-94,0x0.2p-1,0x1.C94BB5p-32,0x1.4p+1,0x2.F1DA4Ep+20},{0x0.2p-1,0x2.0EBE36p+96,(-0x1.6p-1),0x2.BFAC49p-37,0x2.C6B258p-59,0x8.577112p-28},{0x2.C6B258p-59,0x2.0EBE36p+96,0x4.3p+1,(-0x1.6p-1),0x1.4p+1,(-0x8.8p-1)},{0x0.48CC68p-32,0x6.721D72p-94,0x1.7p-1,0x1.7p-1,0x6.721D72p-94,0x0.48CC68p-32},{0x2.F1DA4Ep+20,0x0.2p-1,0x2.BFAC49p-37,(-0x8.8p-1),0x1.7p-1,0x1.C94BB5p-32},{0x1.1p+1,(-0x1.6p-1),(-0x5.2p-1),(-0x8.Bp+1),(-0x7.3p+1),0x4.3p+1},{0x1.1p+1,0x4.3p+1,(-0x8.Bp+1),(-0x8.8p-1),0x2.0EBE36p+96,(-0x7.3p+1)},{0x2.F1DA4Ep+20,0x1.7p-1,0x2.C6B258p-59,0x1.7p-1,0x2.F1DA4Ep+20,(-0x5.2p-1)}},{{0x0.48CC68p-32,0x2.BFAC49p-37,0x8.577112p-28,(-0x1.6p-1),0x1.7F2523p+46,0x4.FB2F7Ep+64},{0x2.C6B258p-59,(-0x5.2p-1),0x0.9p+1,0x2.BFAC49p-37,(-0x7.5p-1),0x4.FB2F7Ep+64},{0x0.2p-1,(-0x8.Bp+1),0x8.577112p-28,0x1.C94BB5p-32,(-0x5.2p-1),(-0x5.2p-1)},{(-0x7.5p-1),0x2.C6B258p-59,0x2.C6B258p-59,(-0x7.5p-1),0x0.2p-1,(-0x7.3p+1)},{0x1.C94BB5p-32,0x8.577112p-28,(-0x8.Bp+1),0x0.2p-1,(-0x8.8p-1),0x4.3p+1},{0x2.BFAC49p-37,0x0.9p+1,(-0x5.2p-1),0x2.C6B258p-59,(-0x8.8p-1),0x1.C94BB5p-32},{(-0x1.6p-1),0x8.577112p-28,0x2.BFAC49p-37,0x0.48CC68p-32,0x0.2p-1,0x0.48CC68p-32},{0x1.7p-1,0x2.C6B258p-59,0x1.7p-1,0x2.F1DA4Ep+20,(-0x5.2p-1),(-0x8.8p-1)},{(-0x8.8p-1),(-0x8.Bp+1),0x4.3p+1,0x1.1p+1,(-0x7.5p-1),0x8.577112p-28},{(-0x8.Bp+1),(-0x5.2p-1),(-0x1.6p-1),0x1.1p+1,0x1.7F2523p+46,0x2.F1DA4Ep+20}}};
    int32_t l_1281 = 1L;
    float *l_1286[10][6] = {{&l_1280[1][3][4],&l_1280[1][5][3],&l_1280[3][7][2],(void*)0,&l_1280[3][7][2],&l_1280[1][5][3]},{&l_1280[3][7][2],&l_1280[1][3][4],&l_1280[3][8][0],&l_1280[1][6][0],&l_1280[1][6][0],&l_1280[3][8][0]},{&l_1280[3][7][2],&l_1280[3][7][2],&l_1280[1][6][0],(void*)0,(void*)0,(void*)0},{&l_1280[1][3][4],&l_1280[3][7][2],&l_1280[1][3][4],&l_1280[3][8][0],&l_1280[1][6][0],&l_1280[1][6][0]},{&l_1280[1][5][3],&l_1280[1][3][4],&l_1280[1][3][4],&l_1280[1][5][3],&l_1280[3][7][2],(void*)0},{(void*)0,&l_1280[1][3][4],&l_1280[3][7][2],&l_1280[1][3][4],&l_1280[3][8][0],&l_1280[1][6][0]},{&l_1280[1][3][4],&l_1280[3][8][0],&l_1280[1][6][0],&l_1280[1][6][0],&l_1280[3][8][0],&l_1280[1][3][4]},{(void*)0,&l_1280[1][3][4],(void*)0,&l_1280[3][8][0],(void*)0,&l_1280[1][3][4]},{(void*)0,(void*)0,&l_1280[1][6][0],&l_1280[3][7][2],&l_1280[3][7][2],&l_1280[1][6][0]},{(void*)0,(void*)0,&l_1280[3][7][2],&l_1280[3][8][0],&l_1280[1][5][3],&l_1280[3][8][0]}};
    float **l_1285 = &l_1286[2][0];
    float ***l_1284 = &l_1285;
    struct S0 *l_1292 = (void*)0;
    const struct S0 *l_1296 = (void*)0;
    const struct S0 **l_1295 = &l_1296;
    int32_t *l_1298 = &l_1281;
    int32_t **l_1297 = &l_1298;
    int i, j, k;
    for (l_1281 = 3; (l_1281 >= 0); l_1281 -= 1)
    { /* block id: 694 */
        int32_t *l_1282 = &l_1281;
        int32_t l_1283 = 1L;
        float ***l_1287 = (void*)0;
        struct S0 l_1294 = {0xDBA55A1D84D87C18LL};
        struct S0 *l_1293 = &l_1294;
        l_1282 = l_1282;
        for (l_1283 = 0; (l_1283 <= 3); l_1283 += 1)
        { /* block id: 698 */
            uint32_t l_1288 = 1UL;
            int32_t l_1290[6] = {(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)};
            int32_t *l_1289 = &l_1290[2];
            int i;
            l_1288 = (l_1284 != l_1287);
            for (l_1288 = 0; (l_1288 <= 3); l_1288 += 1)
            { /* block id: 702 */
                int32_t l_1291 = 1L;
                l_1289 = &l_1283;
                /* statement id: 703 */
                assert (l_1289 == &l_1283);
                for (l_1291 = 3; (l_1291 >= 0); l_1291 -= 1)
                { /* block id: 706 */
                    l_1293 = l_1292;
                    /* statement id: 707 */
                    assert (l_1293 == 0);
                }
            }
            /* facts after for loop */
            assert (l_1289 == &l_1283 || (l_1289 >= &l_1290[0] && l_1289 <= &l_1290[5]));
        }
        /* facts after for loop */
        assert (l_1293 == 0 || l_1293 == &l_1294);
    }
    for (l_1281 = 0; (l_1281 <= 3); l_1281 += 1)
    { /* block id: 714 */
        return l_1281;
    }
    (*l_1297) = func_65(l_1295, l_1281, l_1297, &l_1292);
    /* statement id: 717 */
    assert (l_1298 == 0);
    return l_1281;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_11(struct S0 * p_12, struct S0 * p_13, int64_t  p_14, const int16_t  p_15)
{ /* block id: 4 */
    int32_t l_33 = (-3L);
    const int16_t l_34 = 1L;
    struct S0 *l_35 = (void*)0;
    int32_t *l_39 = &l_33;
    int32_t **l_38 = &l_39;
    float l_914 = 0xD.4B97F7p+31;
    float *l_913 = &l_914;
    float **l_912 = &l_913;
    struct S0 **l_920[1][9];
    struct S0 ***l_919 = &l_920[0][0];
    struct S0 ****l_918 = &l_919;
    struct S0 l_926 = {0x6C004309EB66B1FALL};
    const struct S0 *l_925 = &l_926;
    const struct S0 **l_924[7][2];
    int32_t l_971 = 5L;
    int32_t **l_993 = &l_39;
    int32_t *** const l_1127 = &l_993;
    int32_t *** const *l_1126[6][7][2] = {{{&l_1127,&l_1127},{(void*)0,&l_1127},{(void*)0,&l_1127},{&l_1127,&l_1127},{&l_1127,&l_1127},{(void*)0,&l_1127},{&l_1127,(void*)0}},{{(void*)0,&l_1127},{(void*)0,&l_1127},{&l_1127,&l_1127},{(void*)0,&l_1127},{(void*)0,(void*)0},{&l_1127,&l_1127},{(void*)0,&l_1127}},{{&l_1127,&l_1127},{&l_1127,&l_1127},{(void*)0,&l_1127},{(void*)0,&l_1127},{&l_1127,&l_1127},{&l_1127,&l_1127},{(void*)0,&l_1127}},{{&l_1127,(void*)0},{(void*)0,&l_1127},{(void*)0,&l_1127},{&l_1127,&l_1127},{(void*)0,&l_1127},{(void*)0,(void*)0},{&l_1127,&l_1127}},{{(void*)0,&l_1127},{&l_1127,&l_1127},{&l_1127,&l_1127},{(void*)0,&l_1127},{(void*)0,&l_1127},{&l_1127,&l_1127},{&l_1127,&l_1127}},{{(void*)0,&l_1127},{&l_1127,(void*)0},{(void*)0,&l_1127},{(void*)0,&l_1127},{&l_1127,&l_1127},{(void*)0,&l_1127},{(void*)0,(void*)0}}};
    struct S0 **l_1137 = &l_35;
    int16_t l_1221 = 0x476EL;
    int32_t ***l_1276[7][6][6] = {{{&l_38,&l_993,&l_993,&l_993,&l_993,&l_38},{&l_993,&l_993,(void*)0,&l_38,&l_38,&l_38},{&l_993,&l_993,&l_38,(void*)0,&l_38,&l_38},{&l_993,&l_38,(void*)0,&l_38,&l_993,(void*)0},{&l_993,&l_38,&l_38,&l_993,&l_993,&l_38},{&l_38,&l_993,&l_38,&l_993,&l_993,&l_38}},{{&l_38,&l_38,(void*)0,(void*)0,&l_993,&l_38},{&l_993,&l_38,&l_993,&l_993,&l_38,(void*)0},{&l_38,&l_993,&l_993,&l_993,&l_38,&l_38},{(void*)0,&l_993,(void*)0,&l_38,&l_993,&l_38},{&l_38,&l_993,&l_38,(void*)0,&l_38,&l_38},{&l_38,&l_38,&l_38,&l_38,(void*)0,(void*)0}},{{(void*)0,&l_38,(void*)0,&l_993,&l_38,&l_38},{&l_38,&l_993,&l_38,&l_993,&l_38,&l_38},{&l_993,&l_38,(void*)0,(void*)0,(void*)0,&l_38},{&l_38,&l_38,&l_993,&l_993,&l_38,(void*)0},{&l_38,&l_993,&l_993,&l_993,&l_993,&l_38},{&l_993,&l_993,(void*)0,&l_38,&l_38,&l_38}},{{&l_993,&l_993,&l_38,(void*)0,&l_38,&l_38},{&l_993,&l_38,(void*)0,&l_38,&l_993,(void*)0},{&l_993,&l_38,&l_38,&l_993,&l_993,&l_38},{&l_38,&l_993,&l_38,&l_993,&l_993,&l_38},{&l_38,&l_38,(void*)0,(void*)0,&l_993,&l_38},{&l_993,&l_38,&l_993,&l_993,&l_38,(void*)0}},{{&l_38,&l_993,&l_993,&l_993,&l_38,&l_38},{(void*)0,&l_993,(void*)0,&l_38,&l_993,&l_38},{&l_38,&l_993,&l_38,(void*)0,&l_38,&l_38},{&l_38,&l_38,&l_38,&l_38,(void*)0,(void*)0},{(void*)0,&l_38,(void*)0,&l_993,&l_38,&l_38},{&l_38,&l_993,&l_38,&l_993,&l_38,&l_38}},{{&l_993,&l_38,(void*)0,(void*)0,(void*)0,&l_38},{&l_38,&l_38,&l_993,&l_993,&l_38,(void*)0},{&l_38,&l_993,&l_993,&l_993,&l_993,&l_38},{&l_993,&l_993,(void*)0,&l_38,&l_38,&l_38},{&l_993,&l_993,&l_38,(void*)0,&l_38,&l_38},{&l_993,&l_38,(void*)0,&l_38,&l_993,(void*)0}},{{&l_993,&l_38,&l_38,&l_993,&l_993,&l_38},{&l_38,&l_993,&l_38,&l_993,&l_993,&l_38},{&l_38,&l_38,(void*)0,(void*)0,&l_993,&l_38},{&l_993,&l_38,&l_993,&l_993,&l_38,(void*)0},{&l_38,&l_993,&l_993,&l_993,&l_38,&l_38},{(void*)0,&l_993,(void*)0,&l_38,&l_993,&l_38}}};
    uint16_t l_1278 = 0xD230L;
    int32_t l_1279 = 0xFF6E61CFL;
    int i, j, k;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 9; j++)
            l_920[i][j] = &l_35;
    }
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 2; j++)
            l_924[i][j] = &l_925;
    }
    (*l_39) = func_26((safe_div_func_int16_t_s_s((func_30(func_16(l_33, l_34, p_15, l_35), func_16(l_33, l_33, (safe_lshift_func_int16_t_s_u(((l_38 != &l_39) & 2UL), (*l_39))), p_13)) < (*l_39)), 0xCC82L)));
    if ((safe_rshift_func_uint8_t_u_u(p_14, 6)))
    { /* block id: 466 */
        int32_t *l_819[6][1] = {{(void*)0},{(void*)0},{(void*)0},{(void*)0},{(void*)0},{(void*)0}};
        int32_t ***l_845 = &l_38;
        int32_t ****l_844[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
        struct S0 ** const l_860 = &l_35;
        const struct S0 l_909 = {-10L};
        const struct S0 *l_908[8] = {&l_909,&l_909,&l_909,&l_909,&l_909,&l_909,&l_909,&l_909};
        const struct S0 **l_907 = &l_908[7];
        struct S0 **l_921 = (void*)0;
        int i, j;
        if ((p_14 || ((void*)0 != l_819[3][0])))
        { /* block id: 467 */
            uint8_t l_820 = 0x03L;
            int32_t **l_838 = &l_819[1][0];
            struct S0 ***l_840 = (void*)0;
            struct S0 ****l_839 = &l_840;
            int32_t *** const *l_846 = &l_845;
lbl_863:
            l_820 = p_14;
            for (l_820 = 28; (l_820 > 11); l_820--)
            { /* block id: 471 */
                int32_t *l_830 = &l_33;
                for (p_14 = 0; (p_14 == 28); p_14 = safe_add_func_uint32_t_u_u(p_14, 5))
                { /* block id: 474 */
                    struct S0 **l_829 = &l_35;
                    int32_t **l_831[2];
                    const int32_t *l_835[3];
                    const int32_t **l_834 = &l_835[2];
                    const int32_t ***l_833[8][5][5] = {{{&l_834,(void*)0,&l_834,(void*)0,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,(void*)0,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834}},{{&l_834,(void*)0,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,(void*)0},{&l_834,&l_834,&l_834,(void*)0,(void*)0},{&l_834,(void*)0,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834}},{{&l_834,(void*)0,&l_834,&l_834,(void*)0},{&l_834,&l_834,&l_834,&l_834,(void*)0},{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,(void*)0,&l_834,(void*)0,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834}},{{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,(void*)0,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,(void*)0,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,(void*)0}},{{&l_834,&l_834,&l_834,(void*)0,(void*)0},{&l_834,(void*)0,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,(void*)0,&l_834,&l_834,(void*)0},{&l_834,&l_834,&l_834,&l_834,(void*)0}},{{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,(void*)0,&l_834,(void*)0,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,(void*)0,&l_834,&l_834,&l_834}},{{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,(void*)0,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,(void*)0},{&l_834,&l_834,&l_834,(void*)0,(void*)0},{&l_834,(void*)0,&l_834,&l_834,&l_834}},{{&l_834,&l_834,&l_834,&l_834,(void*)0},{&l_834,&l_834,&l_834,&l_834,&l_834},{(void*)0,&l_834,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834},{&l_834,&l_834,&l_834,&l_834,&l_834}}};
                    const int32_t ****l_832 = &l_833[7][2][2];
                    int i, j, k;
                    for (i = 0; i < 2; i++)
                        l_831[i] = &l_819[3][0];
                    for (i = 0; i < 3; i++)
                        l_835[i] = &l_33;
                    for (l_33 = 0; (l_33 >= 0); l_33 -= 1)
                    { /* block id: 477 */
                        const struct S0 *l_826 = (void*)0;
                        const struct S0 **l_825 = &l_826;
                        int i, j;
                        (*l_38) = l_830;
                    }
                    (*l_38) = l_830;
                    for (l_33 = 1; (l_33 >= 0); l_33 -= 1)
                    { /* block id: 483 */
                        int i;
                        if (l_820)
                            break;
                        return p_13;
                        /* statement id: 485 */
                        //assert (func_11_rv == &l_6 || func_11_rv == 0);
                    }
                    (*l_832) = (void*)0;
                }
                if (((safe_add_func_uint8_t_u_u((p_14 < (l_838 != (void*)0)), ((void*)0 == l_839))) || (!(safe_div_func_uint32_t_u_u((l_844[6] == l_846), (safe_add_func_uint16_t_u_u(p_14, (safe_lshift_func_uint16_t_u_u((safe_mod_func_int64_t_s_s(((**l_38) ^ (****l_846)), 5L)), 12)))))))))
                { /* block id: 489 */
                    for (p_14 = 0; (p_14 >= 0); p_14 -= 1)
                    { /* block id: 492 */
                        float l_862 = 0xE.E0D551p+77;
                        float *l_861 = &l_862;
                        int i, j;
                        (*l_830) = ((&l_38 == (void*)0) && (1UL <= (safe_lshift_func_int16_t_s_s(((safe_unary_minus_func_int8_t_s(0xA5L)) >= (-7L)), (safe_mod_func_uint64_t_u_u(0x28AA16818E195D10LL, (safe_div_func_int64_t_s_s((-1L), 0x7019FCFA535F60F5LL))))))));
                        (*l_861) = (l_860 != &p_12);
                        (*l_838) = l_819[p_14][p_14];
                        if ((****l_846))
                            continue;
                    }
                }
                else
                { /* block id: 498 */
                    (***l_846) = (***l_846);
                    (*l_838) = (***l_846);
                }
            }
            if (p_15)
                goto lbl_863;
        }
        else
        { /* block id: 504 */
            float l_874 = (-0x1.Fp+1);
            float *l_873 = &l_874;
            float **l_878 = &l_873;
            int32_t l_881 = 0x8F9AA5D3L;
            struct S0 **l_903 = (void*)0;
            int32_t ***l_904[3];
            const struct S0 ** const *l_917[6][7] = {{&l_907,&l_907,&l_907,&l_907,&l_907,&l_907,&l_907},{&l_907,&l_907,&l_907,&l_907,&l_907,&l_907,&l_907},{&l_907,&l_907,&l_907,&l_907,&l_907,&l_907,&l_907},{&l_907,&l_907,&l_907,&l_907,&l_907,&l_907,&l_907},{&l_907,&l_907,&l_907,&l_907,&l_907,&l_907,&l_907},{&l_907,&l_907,&l_907,&l_907,&l_907,&l_907,&l_907}};
            const struct S0 ** const **l_916 = &l_917[3][1];
            int i, j;
            for (i = 0; i < 3; i++)
                l_904[i] = &l_38;
            for (l_33 = (-14); (l_33 == (-20)); l_33--)
            { /* block id: 507 */
                const uint32_t l_870 = 0x1F9AAC44L;
                (*l_873) = (((((-(((&l_38 == (void*)0) == ((-((safe_sub_func_float_f_f(l_870, p_15)) > (-p_15))) > ((+((l_819[3][0] != l_873) < ((+0x9.78AA31p-95) < (safe_add_func_float_f_f(0x4.4p-1, 0x5.D59460p+84))))) <= (***l_845)))) < p_14)) >= l_870) <= (**l_38)) > (**l_38)) < 0x7.5880BFp-24);
                l_878 = &l_873;
                return p_13;
                /* statement id: 510 */
                //assert (func_11_rv == &l_6 || func_11_rv == 0);
            }
            (***l_845) = (*l_39);
            for (p_14 = 0; (p_14 == (-18)); p_14 = safe_sub_func_uint64_t_u_u(p_14, 9))
            { /* block id: 515 */
                int8_t l_885 = 0x5BL;
                if (p_14)
                    break;
                if (p_14)
                    continue;
                (***l_845) = (4UL ^ (l_881 != (((*l_39) >= (safe_div_func_uint32_t_u_u(((!(((-1L) <= l_885) || (((l_881 == 0UL) <= p_14) ^ (safe_sub_func_int8_t_s_s((safe_div_func_uint64_t_u_u((**l_38), (-4L))), (***l_845)))))) && p_14), l_881))) ^ 1L)));
            }
            if ((255UL | (safe_sub_func_uint64_t_u_u((safe_lshift_func_uint8_t_u_u((((p_14 | ((safe_sub_func_int8_t_s_s((safe_mod_func_uint16_t_u_u((safe_div_func_int16_t_s_s(l_881, ((**l_38) || (*l_39)))), 0x4773L)), l_881)) <= (*l_39))) < (safe_unary_minus_func_int32_t_s(p_14))) || (***l_845)), l_881)), p_15))))
            { /* block id: 520 */
                uint64_t l_905 = 0x93036E1EACD4D707LL;
                int32_t **l_906[10][5][3] = {{{&l_39,(void*)0,&l_819[3][0]},{&l_39,&l_819[3][0],(void*)0},{&l_819[5][0],&l_819[3][0],&l_819[3][0]},{&l_39,&l_819[3][0],&l_819[3][0]},{(void*)0,(void*)0,&l_39}},{{&l_819[3][0],&l_39,&l_39},{&l_819[1][0],(void*)0,(void*)0},{&l_819[5][0],(void*)0,(void*)0},{&l_819[3][0],(void*)0,&l_819[4][0]},{&l_819[3][0],&l_39,&l_819[3][0]}},{{(void*)0,(void*)0,(void*)0},{&l_39,&l_819[3][0],&l_819[3][0]},{&l_819[5][0],&l_39,(void*)0},{&l_819[1][0],&l_819[3][0],&l_39},{&l_819[2][0],(void*)0,&l_819[3][0]}},{{&l_819[1][0],&l_819[1][0],(void*)0},{&l_819[5][0],&l_819[2][0],(void*)0},{&l_39,&l_39,&l_819[3][0]},{(void*)0,(void*)0,(void*)0},{&l_819[3][0],&l_39,(void*)0}},{{&l_819[3][0],&l_39,(void*)0},{&l_819[5][0],&l_819[3][0],(void*)0},{&l_819[1][0],&l_819[1][0],&l_819[4][0]},{&l_819[3][0],&l_819[0][0],&l_39},{(void*)0,(void*)0,&l_39}},{{&l_39,&l_39,&l_819[1][0]},{&l_819[5][0],(void*)0,&l_39},{&l_39,&l_39,&l_39},{&l_39,(void*)0,&l_819[4][0]},{&l_819[3][0],&l_819[1][0],(void*)0}},{{&l_39,&l_819[3][0],(void*)0},{&l_39,&l_819[3][0],(void*)0},{&l_39,&l_819[5][0],(void*)0},{&l_819[3][0],&l_819[3][0],&l_819[3][0]},{(void*)0,&l_39,(void*)0}},{{&l_39,&l_39,(void*)0},{&l_819[1][0],(void*)0,&l_819[3][0]},{(void*)0,&l_819[5][0],&l_39},{(void*)0,(void*)0,(void*)0},{&l_819[3][0],&l_39,&l_819[3][0]}},{{&l_39,&l_39,(void*)0},{&l_39,&l_819[3][0],&l_819[3][0]},{&l_819[3][0],(void*)0,&l_819[3][0]},{&l_819[3][0],&l_819[5][0],&l_819[1][0]},{(void*)0,&l_39,(void*)0}},{{&l_819[3][0],&l_39,&l_819[3][0]},{&l_819[2][0],(void*)0,&l_819[2][0]},{&l_819[3][0],&l_819[0][0],&l_39},{&l_39,&l_39,&l_819[3][0]},{(void*)0,&l_39,&l_819[1][0]}}};
                int i, j, k;
                (**l_845) = (*l_38);
                (**l_845) = (**l_845);
            }
            else
            { /* block id: 523 */
                struct S0 l_923 = {-4L};
                struct S0 *l_922 = &l_923;
                return p_13;
                /* statement id: 524 */
                //assert (func_11_rv == &l_6 || func_11_rv == 0);
            }
        }
        (*l_38) = func_65(l_924[4][0], (safe_rshift_func_int8_t_s_u((((safe_add_func_uint8_t_u_u(p_14, (safe_div_func_uint8_t_u_u((p_15 >= (safe_lshift_func_int16_t_s_s(((((safe_div_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(((void*)0 != (*l_845)), (((***l_845) < ((p_12 != (*l_907)) && (safe_div_func_uint32_t_u_u((safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(p_15, 3)), p_15)), 0x650550E3L)))) && p_14))), (***l_845))) || p_14) > (***l_845)) | p_15), 1))), (***l_845))))) >= 0x3C848B0DD09B7344LL) != p_15), p_14)), &l_39, (**l_918));
        /* statement id: 527 */
        assert (l_39 == 0);
    }
    else
    { /* block id: 528 */
        uint64_t l_970 = 0x410E979624AE1FCBLL;
        uint32_t l_972 = 2UL;
        int32_t l_984 = (-1L);
        int8_t l_991 = 0x8BL;
        int32_t **l_1019 = &l_39;
        struct S0 **l_1020 = &l_35;
        int32_t ***l_1080 = &l_38;
        int32_t ****l_1079 = &l_1080;
        int8_t l_1103[7][1] = {{4L},{4L},{0L},{4L},{4L},{0L},{4L}};
        struct S0 *** const l_1119[7][1] = {{&l_920[0][5]},{&l_920[0][0]},{&l_920[0][5]},{&l_920[0][0]},{&l_920[0][5]},{&l_920[0][0]},{&l_920[0][5]}};
        uint16_t l_1146 = 1UL;
        float *l_1167 = &l_914;
        uint64_t l_1200 = 0x10A7C55B63308B15LL;
        int i, j;
        for (l_33 = 0; (l_33 <= 1); l_33 += 1)
        { /* block id: 531 */
            const uint64_t l_953 = 1UL;
            float **l_989 = &l_913;
            struct S0 *l_1005 = &l_926;
            int32_t ***l_1017 = (void*)0;
            int32_t **** const l_1016 = &l_1017;
            const struct S0 **l_1049 = &l_925;
            float ***l_1084 = &l_989;
            int32_t l_1102 = 5L;
            uint32_t l_1128 = 0UL;
        }
        (***l_1080) = ((void*)0 == &l_913);
        (**l_993) = ((safe_sub_func_int64_t_s_s(((p_15 || ((**l_1080) != (void*)0)) < ((p_13 != p_12) || (((((p_15 != ((*l_918) == &l_1020)) < p_14) || (**l_1019)) | 1UL) <= 0xA57A86FBL))), (-1L))) && 0x8A10D199C4583273LL);
        (**l_38) = (0x30E3A2E6639DD4B1LL & ((**l_993) | (((((((safe_mod_func_uint32_t_u_u(p_15, ((safe_mod_func_uint64_t_u_u(5UL, (((safe_sub_func_uint64_t_u_u(((safe_mod_func_uint32_t_u_u(((safe_rshift_func_uint8_t_u_u(0UL, (safe_mod_func_uint64_t_u_u((0x7AA7L | (****l_1079)), (safe_add_func_int32_t_s_s(((((-1L) || p_15) & (**l_1019)) >= 0xF07357D53F3F45D8LL), (****l_1079))))))) > (****l_1079)), 0x12D4AFBAL)) && p_15), p_15)) ^ (**l_38)) & p_15))) & p_15))) && 0x0D39L) <= (-7L)) | p_15) <= 248UL) != (***l_1127)) > p_14)));
    }
    /* facts after branching */
    assert (l_39 == &l_33 || l_39 == 0);
    l_1276[3][5][2] = l_1276[3][5][2];
    l_1279 = (safe_unary_minus_func_uint16_t_u((l_1278 >= (0x9E45AD80215B70D6LL <= ((void*)0 != (*l_1127))))));
    return p_13;
    /* statement id: 690 */
    //assert (func_11_rv == &l_6 || func_11_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_16(int16_t  p_17, const int32_t  p_18, int64_t  p_19, struct S0 * p_20)
{ /* block id: 1 */
    int32_t l_23 = 0xAE974CA7L;
    int32_t *l_22 = &l_23;
    int32_t **l_21 = &l_22;
    struct S0 l_25[10][2] = {{{1L},{0x96497440271DBCABLL}},{{-5L},{-5L}},{{-5L},{0x96497440271DBCABLL}},{{1L},{5L}},{{0x96497440271DBCABLL},{5L}},{{1L},{0x96497440271DBCABLL}},{{-5L},{-5L}},{{-5L},{0x96497440271DBCABLL}},{{1L},{5L}},{{0x96497440271DBCABLL},{5L}}};
    struct S0 *l_24 = &l_25[4][1];
    int i, j;
    (*l_21) = &p_18;
    /* statement id: 2 */
    assert (l_22 == &p_18);
    return p_20;
    /* statement id: 3 */
    //assert (func_16_rv == &l_6 || func_16_rv == 0 || func_16_rv == &l_98 || func_16_rv == &l_789);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_26(int16_t  p_27)
{ /* block id: 22 */
    int32_t *l_57 = (void*)0;
    int32_t **l_58 = &l_57;
    int32_t **l_61 = &l_57;
    int32_t ***l_752 = &l_58;
    int32_t ****l_751 = &l_752;
    struct S0 l_789 = {0x6A920C1C384F78D6LL};
    struct S0 *l_788 = &l_789;
    struct S0 **l_787 = &l_788;
    struct S0 ***l_791 = (void*)0;
    struct S0 ****l_790 = &l_791;
    float l_799 = 0x0.1p+1;
    float *l_798 = &l_799;
    int32_t ****l_805 = &l_752;
    int8_t l_816 = 0x3EL;
    (*l_58) = l_57;
    if (((p_27 < p_27) < (l_61 == (void*)0)))
    { /* block id: 24 */
        int32_t l_63 = 1L;
        const int32_t *l_62 = &l_63;
        int32_t **l_64 = &l_57;
        struct S0 **l_74 = (void*)0;
        (*l_64) = l_62;
        /* statement id: 25 */
        assert (l_57 == &l_63);
        (*l_64) = func_65(func_70(p_27, l_74, p_27), ((!(248UL > (safe_rshift_func_uint16_t_u_u((safe_add_func_int16_t_s_s(0xE9A1L, ((void*)0 == l_751))), 12)))) != p_27), l_64, l_74);
        /* statement id: 447 */
        assert (l_57 == 0);
    }
    else
    { /* block id: 448 */
        int8_t l_797 = 0L;
        for (p_27 = 0; (p_27 == (-6)); p_27 = safe_sub_func_int64_t_s_s(p_27, 1))
        { /* block id: 451 */
            int32_t l_780 = 1L;
            int32_t *l_779 = &l_780;
            (*l_779) = 0x238D4E32L;
            for (l_780 = 13; (l_780 == 21); l_780++)
            { /* block id: 455 */
                if ((*l_779))
                    break;
                (**l_752) = (*l_61);
            }
            (*l_779) = ((((safe_add_func_int8_t_s_s(((safe_sub_func_uint32_t_u_u(((void*)0 == l_787), p_27)) <= (((l_790 == &l_791) == (!p_27)) | (((safe_add_func_int16_t_s_s(p_27, (*l_779))) || (safe_sub_func_int8_t_s_s(((((*l_61) != &l_780) > 4294967293UL) <= p_27), l_797))) == p_27))), (*l_779))) | (*l_779)) && 7UL) < p_27);
        }
    }
    (*l_798) = p_27;
    (*l_787) = func_16((p_27 < ((safe_lshift_func_uint8_t_u_u((p_27 ^ 0x2CF408ADL), 6)) <= (safe_unary_minus_func_uint8_t_u(((l_805 == &l_752) || (safe_mod_func_uint16_t_u_u((safe_add_func_int16_t_s_s((safe_add_func_uint64_t_u_u(p_27, ((safe_add_func_int32_t_s_s(p_27, (((safe_lshift_func_int16_t_s_s((((***l_805) == (*l_58)) == l_816), l_789.f0)) <= 0xFFB33B52DE7AC6C6LL) == 0xD635L))) & 0UL))), p_27)), 1UL))))))), p_27, p_27, (*l_787));
    return p_27;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_30(struct S0 * p_31, struct S0 * p_32)
{ /* block id: 5 */
    int32_t l_40[3][4];
    int32_t *l_43[7];
    struct S0 l_51 = {1L};
    struct S0 *l_50 = &l_51;
    int32_t l_54 = 0L;
    int8_t l_55 = 0x26L;
    int32_t l_56[10][9] = {{(-4L),0xD5949333L,0xD5949333L,(-4L),3L,(-4L),0xD5949333L,0xD5949333L,(-4L)},{0L,0xD5949333L,0x6224F168L,0xD5949333L,0L,0L,0xD5949333L,0x6224F168L,0xD5949333L},{0xD5949333L,3L,0x6224F168L,0x6224F168L,3L,0xD5949333L,3L,0x6224F168L,0x6224F168L},{0L,0L,0xD5949333L,0x6224F168L,0xD5949333L,0L,0L,0xD5949333L,0x6224F168L},{(-4L),3L,(-4L),0xD5949333L,0xD5949333L,(-4L),3L,(-4L),0xD5949333L},{(-4L),0xD5949333L,0xD5949333L,(-4L),3L,(-4L),0xD5949333L,0xD5949333L,(-4L)},{0L,0xD5949333L,0x6224F168L,0xD5949333L,0L,0L,0xD5949333L,0x6224F168L,0xD5949333L},{0xD5949333L,3L,0x6224F168L,0x6224F168L,3L,0xD5949333L,3L,0x6224F168L,0x6224F168L},{0L,0L,0xD5949333L,0x6224F168L,0xD5949333L,0L,0L,0xD5949333L,0x6224F168L},{(-4L),3L,(-4L),0xD5949333L,0xD5949333L,(-4L),3L,(-4L),0xD5949333L}};
    int i, j;
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 4; j++)
            l_40[i][j] = 0x61E7FF51L;
    }
    for (i = 0; i < 7; i++)
        l_43[i] = &l_40[1][0];
    for (l_40[1][2] = 0; (l_40[1][2] != 18); l_40[1][2]++)
    { /* block id: 8 */
        int32_t l_44 = (-6L);
        int32_t l_53 = 6L;
        l_44 = (l_43[6] == (void*)0);
        if (l_44)
            break;
        for (l_44 = 29; (l_44 >= 23); l_44 = safe_sub_func_int32_t_s_s(l_44, 2))
        { /* block id: 13 */
            struct S0 l_49 = {0xECF58A4122E7DFE9LL};
            struct S0 *l_48 = &l_49;
            struct S0 **l_47[4];
            int32_t **l_52 = &l_43[5];
            int i;
            for (i = 0; i < 4; i++)
                l_47[i] = &l_48;
            l_50 = (void*)0;
            /* statement id: 14 */
            assert (l_50 == 0);
            (*l_52) = (void*)0;
            if (l_49.f0)
                break;
        }
        l_53 = l_44;
    }
    /* facts after for loop */
    //assert (l_43[0] == 0 || (l_43[0] >= &l_40[0][0] && l_43[0] <= &l_40[2][3]));
    assert (l_50 == 0 || l_50 == &l_51);
    l_55 = l_54;
    return l_56[4][0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_65(const struct S0 ** p_66, uint32_t  p_67, int32_t ** p_68, struct S0 ** p_69)
{ /* block id: 444 */
    uint32_t l_764 = 0x0BB1D7C1L;
    struct S0 l_769 = {0L};
    struct S0 *l_768[10][10] = {{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769},{&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769,&l_769}};
    struct S0 **l_767 = &l_768[9][5];
    int32_t *l_776 = (void*)0;
    int i, j;
    (**p_68) = (safe_lshift_func_uint16_t_u_s(((safe_div_func_uint32_t_u_u((+(safe_lshift_func_int16_t_s_u(((safe_rshift_func_uint8_t_u_s(0x0EL, (((((safe_lshift_func_int16_t_s_s(((l_764 && (safe_rshift_func_int16_t_s_u((l_764 ^ (l_767 != &l_768[9][5])), 13))) != ((l_764 <= (((safe_sub_func_uint32_t_u_u((safe_div_func_uint64_t_u_u(0x76C7A3F15B850EA8LL, (safe_mod_func_int16_t_s_s(((p_67 != ((l_776 != (*p_68)) == p_67)) != p_67), l_764)))), 4294967293UL)) && 2UL) & l_764)) || p_67)), 5)) == 0x2A0B6EFFDA94055ALL) && (-1L)) != 0x083B7C2618ED9D0ALL) > p_67))) <= 0UL), 12))), 4294967295UL)) & l_764), p_67));
    return l_776;
    /* statement id: 446 */
    //assert (func_65_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0 ** func_70(int32_t  p_71, struct S0 ** p_72, uint32_t  p_73)
{ /* block id: 26 */
    int32_t l_76 = 8L;
    int32_t *l_75 = &l_76;
    int32_t **l_77 = &l_75;
    uint8_t l_93 = 255UL;
    int16_t l_95 = (-1L);
    int32_t *l_96[2][3][8] = {{{&l_76,(void*)0,&l_76,(void*)0,&l_76,&l_76,&l_76,(void*)0},{(void*)0,&l_76,(void*)0,&l_76,(void*)0,&l_76,&l_76,&l_76},{&l_76,(void*)0,&l_76,&l_76,(void*)0,&l_76,(void*)0,&l_76}},{{&l_76,&l_76,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,&l_76},{(void*)0,(void*)0,&l_76,(void*)0,&l_76,&l_76,&l_76,&l_76},{&l_76,&l_76,&l_76,&l_76,(void*)0,&l_76,&l_76,&l_76}}};
    struct S0 l_98 = {-1L};
    struct S0 *l_97 = &l_98;
    struct S0 **l_129 = &l_97;
    struct S0 ***l_128 = &l_129;
    const struct S0 *l_155[8] = {&l_98,(void*)0,&l_98,(void*)0,&l_98,(void*)0,&l_98,(void*)0};
    const struct S0 **l_154 = &l_155[5];
    const struct S0 **l_159 = (void*)0;
    const struct S0 **l_167[5];
    int32_t * const *l_177[6][7] = {{&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1]},{&l_75,&l_75,&l_75,&l_75,&l_75,&l_75,&l_75},{&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1]},{&l_75,&l_75,&l_75,&l_75,&l_75,&l_75,&l_75},{&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1],&l_96[0][2][1]},{&l_75,&l_75,&l_75,&l_75,&l_75,&l_75,&l_75}};
    const struct S0 **l_199[7] = {&l_155[5],&l_155[6],&l_155[6],&l_155[5],&l_155[6],&l_155[6],&l_155[5]};
    const struct S0 **l_258 = &l_155[4];
    const int32_t *l_305[10] = {&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76};
    const int32_t **l_304 = &l_305[4];
    int32_t * const ** const l_308 = &l_177[2][5];
    const struct S0 **l_387 = &l_155[5];
    uint32_t l_456 = 7UL;
    uint8_t l_459 = 0xF7L;
    int32_t l_603 = 0xE8CAD33EL;
    int32_t ***l_608 = &l_77;
    int32_t *l_614 = &l_603;
    float l_704 = 0xB.6D455Fp-85;
    float *l_703 = &l_704;
    uint64_t l_705 = 3UL;
    float l_713 = (-0x7.Cp+1);
    const struct S0 **l_742[7] = {&l_155[2],&l_155[2],&l_155[0],&l_155[2],&l_155[2],&l_155[0],&l_155[2]};
    const struct S0 **l_743 = &l_155[4];
    const struct S0 **l_744 = &l_155[3];
    const struct S0 **l_745 = (void*)0;
    int i, j, k;
    for (i = 0; i < 5; i++)
        l_167[i] = (void*)0;
    (*l_77) = l_75;
    if ((((safe_lshift_func_uint8_t_u_s((safe_lshift_func_int8_t_s_s((+((safe_lshift_func_uint8_t_u_s((safe_div_func_int16_t_s_s(((-7L) >= ((safe_sub_func_uint16_t_u_u(((*l_77) != (*l_77)), (safe_rshift_func_int16_t_s_u((**l_77), 5)))) ^ (**l_77))), (safe_sub_func_uint32_t_u_u((l_93 < ((+l_95) != ((**l_77) > (**l_77)))), (**l_77))))), p_73)) >= (**l_77))), 7)), (*l_75))) ^ (-1L)) & 1L))
    { /* block id: 28 */
        int8_t l_113 = 8L;
        int32_t *l_126 = &l_76;
        uint8_t l_127 = 1UL;
        uint16_t l_133[9][7] = {{65535UL,65529UL,65530UL,65531UL,65531UL,65530UL,65529UL},{1UL,0x2D78L,0x5FA5L,65528UL,0x4EB9L,65535UL,65535UL},{0x4A93L,65535UL,1UL,0xCED9L,1UL,65535UL,0x4A93L},{65535UL,0x2D78L,0xA4BBL,1UL,0xFBACL,0x4EB9L,65527UL},{0xCED9L,0x4A93L,65530UL,65530UL,0x4A93L,0xCED9L,0UL},{0xEE60L,1UL,0xA4BBL,65535UL,8UL,0xFBACL,0xFBACL},{65531UL,0xF98DL,1UL,0xF98DL,65531UL,0x1C71L,65535UL},{65528UL,1UL,0xFBACL,0x2D78L,1UL,0xEE60L,1UL},{65529UL,0x4A93L,0x4A93L,65529UL,0xF98DL,65535UL,0xEE2BL}};
        const struct S0 **l_157 = &l_155[7];
        const struct S0 **l_172 = &l_155[5];
        const struct S0 **l_198 = &l_155[2];
        const struct S0 **l_200 = (void*)0;
        int32_t l_338 = 0xDD6B7BD8L;
        uint8_t l_368 = 0x38L;
        int i, j;
lbl_276:
        (*l_77) = l_96[0][2][2];
        /* statement id: 29 */
        assert (l_75 == 0 || l_75 == &l_76);
        if (p_71)
        { /* block id: 30 */
            struct S0 **l_99 = &l_97;
            int32_t **l_102[9] = {&l_75,&l_96[1][2][0],&l_96[1][2][0],&l_75,&l_96[1][2][0],&l_96[1][2][0],&l_75,&l_96[1][2][0],&l_96[1][2][0]};
            int32_t l_116 = (-1L);
            const int32_t l_150 = 1L;
            const struct S0 **l_156 = &l_155[5];
            int16_t l_185 = 0xF219L;
            const struct S0 **l_197 = &l_155[0];
            int32_t *l_234 = &l_76;
            int i;
            (*l_99) = l_97;
            if ((((safe_div_func_int64_t_s_s(((((void*)0 != l_102[3]) || ((safe_sub_func_int32_t_s_s((safe_sub_func_uint16_t_u_u((((safe_add_func_int32_t_s_s(p_71, ((safe_div_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(l_113, p_73)), (safe_rshift_func_int16_t_s_s((l_116 > (safe_mod_func_uint8_t_u_u((safe_div_func_int8_t_s_s((!0xF26AE3508C96F5F5LL), ((safe_rshift_func_uint8_t_u_s((((((safe_mod_func_int16_t_s_s((l_126 == (void*)0), (*l_126))) <= p_73) > 0L) || 7L) > p_73), 5)) & (*l_126)))), l_127))), (*l_126))))) <= p_73))) == (*l_126)) >= (*l_126)), p_71)), 4294967291UL)) ^ 0xDF9043A1L)) >= p_71), (*l_126))) == p_73) != 0xBDL))
            { /* block id: 32 */
                uint16_t l_139 = 0xF50BL;
                struct S0 ** const *l_149 = (void*)0;
                int32_t l_161[2][2] = {{0xDE98D404L,0xDE98D404L},{0xDE98D404L,0xDE98D404L}};
                int32_t * const *l_162 = &l_96[0][2][2];
                const struct S0 **l_165 = &l_155[5];
                const struct S0 **l_174[9];
                int i, j;
                for (i = 0; i < 9; i++)
                    l_174[i] = (void*)0;
                (*l_77) = l_126;
                /* statement id: 33 */
                assert (l_75 == &l_76);
                if (((void*)0 != (*l_77)))
                { /* block id: 34 */
                    struct S0 ****l_130 = &l_128;
                    int32_t l_142 = 0x4EF14F5BL;
                    const struct S0 **l_158 = &l_155[5];
                    (*l_130) = l_128;
                    for (l_113 = 28; (l_113 != 17); --l_113)
                    { /* block id: 38 */
                        (*l_126) = l_133[7][6];
                        (*l_75) = (safe_rshift_func_uint16_t_u_s((((safe_lshift_func_int16_t_s_s((+l_139), ((safe_div_func_int16_t_s_s(l_142, p_73)) || p_71))) ^ (safe_rshift_func_int8_t_s_u(l_142, 7))) >= (0xC8DDL != ((safe_sub_func_int64_t_s_s(p_73, p_73)) >= ((void*)0 == l_149)))), l_142));
                    }
                    for (l_139 = 0; (l_139 <= 6); l_139 += 1)
                    { /* block id: 44 */
                        float *l_151 = (void*)0;
                        float l_153 = 0x0.5p+1;
                        float *l_152 = &l_153;
                        if (l_150)
                            break;
                        (*l_152) = p_73;
                        (*l_152) = l_139;
                    }
                    return l_159;
                    /* statement id: 49 */
                    //assert (func_70_rv == 0);
                }
                else
                { /* block id: 50 */
                    int32_t **l_160 = &l_75;
                    const struct S0 **l_166[5][6][2] = {{{&l_155[2],&l_155[5]},{&l_155[4],&l_155[5]},{(void*)0,&l_155[1]},{&l_155[6],(void*)0},{&l_155[5],&l_155[5]},{&l_155[5],(void*)0}},{{&l_155[6],&l_155[1]},{(void*)0,&l_155[5]},{&l_155[4],&l_155[5]},{&l_155[2],&l_155[5]},{&l_155[5],&l_155[4]},{&l_155[5],&l_155[5]}},{{&l_155[4],&l_155[5]},{&l_155[5],&l_155[0]},{(void*)0,(void*)0},{&l_155[5],&l_155[7]},{(void*)0,(void*)0},{&l_155[5],&l_155[5]}},{{&l_155[5],&l_155[4]},{&l_155[5],&l_155[4]},{&l_155[5],&l_155[5]},{&l_155[5],(void*)0},{(void*)0,&l_155[7]},{&l_155[5],(void*)0}},{{(void*)0,&l_155[0]},{&l_155[5],&l_155[5]},{&l_155[4],&l_155[5]},{&l_155[5],&l_155[4]},{&l_155[5],&l_155[5]},{&l_155[2],&l_155[5]}}};
                    const struct S0 **l_173 = &l_155[6];
                    int i, j, k;
                    for (l_76 = 0; l_76 < 2; l_76 += 1)
                    {
                        for (l_113 = 0; l_113 < 3; l_113 += 1)
                        {
                            for (p_73 = 0; p_73 < 8; p_73 += 1)
                            {
                                l_96[l_76][l_113][p_73] = &l_76;
                            }
                        }
                    }
                    if (((void*)0 == l_160))
                    { /* block id: 52 */
                        l_161[1][0] = ((-1L) <= p_73);
                    }
                    else
                    { /* block id: 54 */
                        (**l_160) = ((void*)0 != l_162);
                    }
                    if ((&l_128 != &l_149))
                    { /* block id: 57 */
                        int32_t *l_163 = &l_76;
                        const struct S0 **l_164 = &l_155[3];
                        (*l_77) = l_163;
                        return l_167[1];
                        /* statement id: 59 */
                        //assert (func_70_rv == 0);
                    }
                    else
                    { /* block id: 60 */
                        int32_t l_168[1];
                        float l_170 = 0x0.Ep+1;
                        float *l_169 = &l_170;
                        const struct S0 **l_171 = &l_155[4];
                        int i;
                        for (i = 0; i < 1; i++)
                            l_168[i] = 0x7EBBD39CL;
                        (*l_169) = l_168[0];
                        return l_174[0];
                        /* statement id: 62 */
                        //assert (func_70_rv == 0);
                    }
                }
            }
            else
            { /* block id: 65 */
                int64_t l_178 = (-7L);
                int32_t *l_186 = &l_76;
                const struct S0 **l_190[4][3] = {{&l_155[6],(void*)0,&l_155[6]},{&l_155[5],(void*)0,&l_155[5]},{&l_155[6],(void*)0,&l_155[6]},{&l_155[5],(void*)0,&l_155[5]}};
                const struct S0 **l_191 = &l_155[5];
                const struct S0 **l_196 = &l_155[5];
                int32_t l_222 = (-2L);
                int i, j;
                if (((safe_add_func_int16_t_s_s(0L, p_71)) < (1L | (l_177[2][5] != &l_96[0][2][2]))))
                { /* block id: 66 */
                    uint8_t l_182[10][6][1] = {{{9UL},{0x91L},{255UL},{251UL},{247UL},{255UL}},{{0x9BL},{0xE7L},{1UL},{0xDEL},{0xDEL},{1UL}},{{0xE7L},{0x9BL},{255UL},{247UL},{251UL},{255UL}},{{0x91L},{9UL},{0x56L},{3UL},{1UL},{0x4EL}},{{0x4EL},{0x4EL},{1UL},{3UL},{0x56L},{9UL}},{{0x91L},{255UL},{251UL},{247UL},{255UL},{0x9BL}},{{0xE7L},{1UL},{0xDEL},{0xDEL},{1UL},{0xE7L}},{{0x9BL},{255UL},{247UL},{251UL},{255UL},{0x91L}},{{9UL},{0x56L},{3UL},{1UL},{0x4EL},{0x4EL}},{{0x4EL},{0UL},{0xDEL},{0x4EL},{3UL},{255UL}}};
                    int i, j, k;
                    (*l_126) = ((((l_178 || (((0x993B904D00042A17LL <= (p_71 & ((((safe_unary_minus_func_uint64_t_u(((safe_div_func_uint64_t_u_u((*l_126), (l_182[9][1][0] ^ (0UL > 0x22E85F59L)))) | l_178))) >= (safe_add_func_uint64_t_u_u(l_178, p_73))) && 0L) == p_73))) && p_73) > 0UL)) <= l_185) != l_178) ^ 5L);
                    (*l_77) = (void*)0;
                    /* statement id: 68 */
                    assert (l_75 == 0);
                    l_186 = (void*)0;
                    /* statement id: 69 */
                    assert (l_186 == 0);
                }
                else
                { /* block id: 70 */
                    const struct S0 **l_189 = &l_155[5];
                    const struct S0 **l_193 = &l_155[5];
                    const struct S0 **l_194 = &l_155[6];
                    int32_t l_203 = 0x3F7625D6L;
                    (*l_77) = l_126;
                    /* statement id: 71 */
                    assert (l_75 == &l_76);
                    for (l_185 = (-26); (l_185 != (-5)); l_185 = safe_add_func_int8_t_s_s(l_185, 7))
                    { /* block id: 74 */
                        const struct S0 **l_192[3][8] = {{&l_155[0],&l_155[3],&l_155[0],&l_155[1],(void*)0,&l_155[1],&l_155[0],&l_155[3]},{(void*)0,&l_155[1],&l_155[0],&l_155[3],&l_155[0],&l_155[1],(void*)0,&l_155[1]},{(void*)0,&l_155[3],&l_155[5],&l_155[3],(void*)0,&l_155[5],(void*)0,&l_155[3]}};
                        const struct S0 **l_195 = &l_155[5];
                        int i, j;
                        return l_200;
                        /* statement id: 75 */
                        //assert (func_70_rv == 0);
                    }
                    for (l_127 = 0; (l_127 <= 32); ++l_127)
                    { /* block id: 79 */
                        (*l_77) = l_186;
                        if (l_203)
                            continue;
                        if (p_73)
                            break;
                        l_186 = (void*)0;
                        /* statement id: 83 */
                        assert (l_186 == 0);
                    }
                    /* facts after for loop */
                    assert (l_75 == 0 || l_75 == &l_76);
                    assert (l_186 == 0 || l_186 == &l_76);
                }
                /* facts after branching */
                assert (l_186 == 0 || l_186 == &l_76);
                for (l_95 = 0; (l_95 <= 5); l_95 += 1)
                { /* block id: 88 */
                    int32_t *l_235 = &l_76;
                    int32_t l_251 = 0x8B985607L;
                    const struct S0 **l_256 = &l_155[5];
                    int i;
                    l_222 = (safe_div_func_uint16_t_u_u(((safe_mod_func_int64_t_s_s(((0UL == ((safe_div_func_int8_t_s_s((*l_126), (safe_mod_func_uint64_t_u_u(((*l_99) == (*l_99)), (safe_sub_func_uint32_t_u_u(((safe_div_func_int32_t_s_s((((safe_add_func_uint32_t_u_u(((((safe_mod_func_uint32_t_u_u((((((void*)0 == l_102[(l_95 + 1)]) >= ((((safe_lshift_func_int16_t_s_s(0x10FEL, 3)) < (&l_128 != (void*)0)) ^ 0x7AEAL) ^ p_71)) | p_73) && p_73), p_71)) ^ (*l_126)) >= 0x57BED906L) > p_71), 0UL)) & p_73) < 0x8836L), p_73)) ^ (*l_126)), 4L)))))) & (*l_126))) && 1L), p_71)) || 0xFBF69327C09D1445LL), p_73));
                    if ((*l_126))
                    { /* block id: 90 */
                        int8_t l_231 = 9L;
                        float l_233 = 0x1.7p+1;
                        float *l_232 = &l_233;
                        (*l_232) = ((safe_add_func_float_f_f(p_71, (safe_div_func_float_f_f((safe_add_func_float_f_f(0x0.E80D33p+44, ((p_71 >= 0x4.3D034Bp-99) == ((safe_sub_func_float_f_f(p_73, p_73)) != (p_71 >= (l_231 <= (-0x9.1p-1))))))), p_73)))) <= p_73);
                    }
                    else
                    { /* block id: 92 */
                        (*l_77) = l_234;
                        /* statement id: 93 */
                        assert (l_75 == &l_76);
                        (*l_77) = l_235;
                    }
                    for (l_116 = 0; (l_116 <= 6); l_116 += 1)
                    { /* block id: 98 */
                        uint32_t l_236 = 0xF52E07C2L;
                        float *l_252 = (void*)0;
                        float l_254 = 0x0.Dp-1;
                        float *l_253 = &l_254;
                        const struct S0 **l_255 = &l_155[4];
                        const struct S0 **l_257 = &l_155[5];
                        int i, j;
                        (*l_253) = (l_236 > (safe_sub_func_float_f_f(((((l_177[l_95][l_116] != (void*)0) > (safe_div_func_float_f_f((safe_div_func_float_f_f(p_73, (((safe_div_func_float_f_f((p_73 != (safe_sub_func_float_f_f((safe_sub_func_float_f_f(((0x3.0621BFp+45 == (safe_sub_func_float_f_f(p_71, 0xB.741E85p+32))) <= (p_71 <= (*l_235))), p_71)), 0xB.7A73CAp-28))), p_71)) >= 0x4.Ap-1) < (-0x5.6p+1)))), (*l_234)))) >= p_73) > l_251), p_73)));
                        return l_200;
                        /* statement id: 100 */
                        //assert (func_70_rv == 0);
                    }
                }
                (*l_77) = &l_222;
                /* statement id: 103 */
                assert (l_75 == &l_222);
            }
            /* facts after branching */
            //assert (l_75 == dangling);
            for (l_93 = 16; (l_93 > 56); ++l_93)
            { /* block id: 107 */
                float l_266 = 0x0.8p-1;
                float *l_265 = &l_266;
                int32_t l_271 = (-1L);
                const struct S0 **l_279 = &l_155[5];
                (*l_265) = (safe_add_func_float_f_f((p_73 == p_71), (safe_add_func_float_f_f(p_71, (*l_126)))));
                for (p_73 = 0; (p_73 <= 6); p_73 += 1)
                { /* block id: 111 */
                    int i;
                    if ((safe_add_func_int16_t_s_s(((void*)0 == l_199[p_73]), ((safe_rshift_func_int8_t_s_u(l_271, p_71)) < (((&l_199[p_73] == (void*)0) <= (((((safe_mod_func_uint8_t_u_u(((((l_271 <= (255UL == p_71)) != 0x95103CEEL) | p_71) <= 0xA8A70E696E2DC38ALL), p_73)) > 1UL) >= 1UL) || 0x01C23CCAL) < p_73)) && p_73)))))
                    { /* block id: 112 */
                        int32_t *l_277 = (void*)0;
                        if (p_71)
                            goto lbl_276;
                        l_277 = l_126;
                        /* statement id: 114 */
                        assert (l_277 == &l_76);
                    }
                    else
                    { /* block id: 115 */
                        const struct S0 **l_278 = &l_155[7];
                        return l_200;
                        /* statement id: 116 */
                        //assert (func_70_rv == 0);
                    }
                    return l_200;
                    /* statement id: 118 */
                    //assert (func_70_rv == 0);
                }
            }
            (*l_304) = (*l_304);
        }
        else
        { /* block id: 165 */
            (*l_304) = (*l_304);
        }
        /* facts after branching */
        //assert (l_75 == 0 || l_75 == &l_76 || l_75 == dangling);
        for (l_93 = 9; (l_93 >= 48); ++l_93)
        { /* block id: 170 */
            int32_t *l_326 = (void*)0;
            const struct S0 * const l_341 = &l_98;
            int32_t l_364 = 0xC931D84DL;
            int64_t l_384 = 1L;
            const struct S0 **l_386 = &l_155[1];
            const struct S0 **l_388[3][4][10] = {{{&l_155[5],&l_155[5],&l_155[2],&l_155[5],&l_155[5],&l_155[5],&l_155[2],&l_155[5],&l_155[5],&l_155[5]},{&l_155[5],&l_155[5],(void*)0,&l_155[5],(void*)0,&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5]},{&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5]},{(void*)0,&l_155[5],(void*)0,&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],(void*)0,&l_155[5]}},{{&l_155[5],&l_155[5],&l_155[2],&l_155[5],&l_155[5],&l_155[5],&l_155[2],&l_155[5],&l_155[5],&l_155[5]},{&l_155[5],&l_155[5],(void*)0,&l_155[5],(void*)0,&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5]},{&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5]},{(void*)0,&l_155[5],(void*)0,&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],(void*)0,&l_155[5]}},{{&l_155[5],&l_155[5],&l_155[2],&l_155[5],&l_155[5],&l_155[5],&l_155[2],&l_155[5],&l_155[5],&l_155[5]},{&l_155[5],&l_155[5],(void*)0,&l_155[5],(void*)0,&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5]},{&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5]},{(void*)0,&l_155[5],(void*)0,&l_155[5],&l_155[5],&l_155[5],&l_155[5],&l_155[5],(void*)0,&l_155[5]}}};
            int i, j, k;
            for (p_71 = 5; (p_71 >= 0); p_71 -= 1)
            { /* block id: 173 */
                const struct S0 **l_323 = (void*)0;
                float l_328[1];
                float *l_327 = &l_328[0];
                int32_t l_337[8][5][4] = {{{(-4L),0x578F9897L,0x847FEAD8L,0x578F9897L},{0x578F9897L,0x412C3F37L,0x847FEAD8L,0x847FEAD8L},{(-4L),(-4L),0x578F9897L,0x847FEAD8L},{0x247C13D9L,0x412C3F37L,0x247C13D9L,0x578F9897L},{0x247C13D9L,0x578F9897L,0x578F9897L,0x247C13D9L}},{{(-4L),0x578F9897L,0x847FEAD8L,0x578F9897L},{0x578F9897L,0x412C3F37L,0x847FEAD8L,0x847FEAD8L},{(-4L),(-4L),0x578F9897L,0x847FEAD8L},{0x247C13D9L,0x412C3F37L,0x247C13D9L,0x578F9897L},{0x247C13D9L,0x578F9897L,0x578F9897L,0x247C13D9L}},{{(-4L),0x578F9897L,0x412C3F37L,0x247C13D9L},{0x247C13D9L,(-4L),0x412C3F37L,0x412C3F37L},{0x578F9897L,0x578F9897L,0x247C13D9L,0x412C3F37L},{0x847FEAD8L,(-4L),0x847FEAD8L,0x247C13D9L},{0x847FEAD8L,0x247C13D9L,0x247C13D9L,0x847FEAD8L}},{{0x578F9897L,0x247C13D9L,0x412C3F37L,0x247C13D9L},{0x247C13D9L,(-4L),0x412C3F37L,0x412C3F37L},{0x578F9897L,0x578F9897L,0x247C13D9L,0x412C3F37L},{0x847FEAD8L,(-4L),0x847FEAD8L,0x247C13D9L},{0x847FEAD8L,0x247C13D9L,0x247C13D9L,0x847FEAD8L}},{{0x578F9897L,0x247C13D9L,0x412C3F37L,0x247C13D9L},{0x247C13D9L,(-4L),0x412C3F37L,0x412C3F37L},{0x578F9897L,0x578F9897L,0x247C13D9L,0x412C3F37L},{0x847FEAD8L,(-4L),0x847FEAD8L,0x247C13D9L},{0x847FEAD8L,0x247C13D9L,0x247C13D9L,0x847FEAD8L}},{{0x578F9897L,0x247C13D9L,0x412C3F37L,0x247C13D9L},{0x247C13D9L,(-4L),0x412C3F37L,0x412C3F37L},{0x578F9897L,0x578F9897L,0x247C13D9L,0x412C3F37L},{0x847FEAD8L,(-4L),0x847FEAD8L,0x247C13D9L},{0x847FEAD8L,0x247C13D9L,0x247C13D9L,0x847FEAD8L}},{{0x578F9897L,0x247C13D9L,0x412C3F37L,0x247C13D9L},{0x247C13D9L,(-4L),0x412C3F37L,0x412C3F37L},{0x578F9897L,0x578F9897L,0x247C13D9L,0x412C3F37L},{0x847FEAD8L,(-4L),0x847FEAD8L,0x247C13D9L},{0x847FEAD8L,0x247C13D9L,0x247C13D9L,0x847FEAD8L}},{{0x578F9897L,0x247C13D9L,0x412C3F37L,0x247C13D9L},{0x247C13D9L,(-4L),0x412C3F37L,0x412C3F37L},{0x578F9897L,0x578F9897L,0x247C13D9L,0x412C3F37L},{0x847FEAD8L,(-4L),0x847FEAD8L,0x247C13D9L},{0x847FEAD8L,0x247C13D9L,0x247C13D9L,0x847FEAD8L}}};
                uint64_t l_339 = 18446744073709551615UL;
                struct S0 ****l_362 = &l_128;
                int i, j, k;
                for (i = 0; i < 1; i++)
                    l_328[i] = 0x4.66FFBFp+86;
                for (l_127 = 0; (l_127 <= 4); l_127 += 1)
                { /* block id: 176 */
                    return l_323;
                    /* statement id: 177 */
                    //assert (func_70_rv == 0);
                }
                (*l_327) = (safe_add_func_float_f_f((*l_126), (((((void*)0 == l_326) < 0x1.Fp-1) > ((&p_72 != (void*)0) == (0x8.6p+1 <= 0x1.FCF4C6p-88))) >= (*l_126))));
            }
            (*l_304) = l_126;
            return l_200;
            /* statement id: 211 */
            //assert (func_70_rv == 0);
        }
    }
    else
    { /* block id: 213 */
        int32_t *l_393 = &l_76;
        const struct S0 **l_394 = &l_155[5];
        const struct S0 **l_399 = (void*)0;
        int32_t *l_431 = &l_76;
        float l_468 = (-0x1.Ep+1);
        float *l_467 = &l_468;
        int32_t *l_573 = &l_76;
        int32_t l_609[7][5][3] = {{{0x58AE40B8L,0L,0L},{(-1L),0xE2F42064L,0x445486C4L},{(-8L),(-7L),0x4F229DFFL},{0x4DA013A0L,0L,(-5L)},{0L,0xFC92375FL,0L}},{{(-5L),0L,0x4DA013A0L},{0x4F229DFFL,(-7L),(-8L)},{0x445486C4L,0xE2F42064L,(-1L)},{0L,0L,0x58AE40B8L},{0x445486C4L,(-5L),0xE2F42064L}},{{0x4F229DFFL,0x58AE40B8L,1L},{(-5L),9L,9L},{0L,0x4F229DFFL,1L},{0x4DA013A0L,(-7L),0xE2F42064L},{(-8L),0L,0x58AE40B8L}},{{(-1L),(-1L),(-1L)},{0x58AE40B8L,0L,(-8L)},{0xE2F42064L,(-7L),0x4DA013A0L},{1L,0x4F229DFFL,0L},{9L,9L,(-5L)}},{{1L,0x58AE40B8L,0x4F229DFFL},{0xE2F42064L,(-5L),0x445486C4L},{0x58AE40B8L,0L,0L},{(-1L),0xE2F42064L,0x445486C4L},{(-8L),1L,0xFC92375FL}},{{(-1L),(-5L),9L},{0L,0xA7DE5564L,0L},{9L,(-5L),(-1L)},{0xFC92375FL,1L,0L},{0x4DA013A0L,(-1L),0L}},{{3L,3L,0L},{0x4DA013A0L,9L,(-1L)},{0xFC92375FL,0L,(-8L)},{9L,(-2L),(-2L)},{0L,0xFC92375FL,(-8L)}}};
        int32_t ** const *l_632 = &l_77;
        struct S0 ****l_635 = &l_128;
        uint64_t l_679 = 18446744073709551609UL;
        int i, j, k;
        if ((p_73 <= (safe_unary_minus_func_int16_t_s(((safe_lshift_func_int16_t_s_s(0x9CC1L, (+((void*)0 != l_393)))) | (p_73 || p_73))))))
        { /* block id: 214 */
            const struct S0 **l_395 = &l_155[0];
            const struct S0 **l_396 = &l_155[5];
            const struct S0 **l_398 = &l_155[5];
            (*l_77) = l_393;
            for (l_93 = 1; (l_93 <= 6); l_93 += 1)
            { /* block id: 218 */
                const struct S0 **l_397 = &l_155[1];
                (*l_304) = l_393;
                return l_399;
                /* statement id: 220 */
                //assert (func_70_rv == 0);
            }
        }
        else
        { /* block id: 222 */
            int32_t l_416 = 0x595CDAB8L;
            int8_t l_417[8][10] = {{0x0DL,0xBEL,0x18L,0x0DL,0x0DL,0x18L,0xBEL,0x0DL,(-10L),0xBEL},{0x0DL,4L,(-10L),0xBEL,4L,4L,0xBEL,(-10L),4L,0x0DL},{4L,0xBEL,(-10L),4L,0x0DL,(-10L),(-10L),0x0DL,4L,(-10L)},{0x0DL,0x0DL,0x18L,0xBEL,0x0DL,(-10L),0xBEL,0xBEL,(-10L),0x0DL},{0x0DL,(-10L),(-10L),0x0DL,4L,(-10L),0xBEL,4L,4L,0xBEL},{4L,0x0DL,(-10L),(-10L),0x0DL,4L,(-10L),0xBEL,4L,4L},{0x0DL,0xBEL,0x18L,0x0DL,0x0DL,0x18L,0xBEL,0x0DL,(-10L),0xBEL},{0x0DL,4L,(-10L),0xBEL,4L,4L,0xBEL,(-10L),4L,0x0DL}};
            int32_t *l_418[8] = {&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76};
            struct S0 *l_428 = &l_98;
            uint32_t l_460 = 0x2E62D118L;
            struct S0 ****l_461[10] = {&l_128,&l_128,&l_128,&l_128,&l_128,&l_128,&l_128,&l_128,&l_128,&l_128};
            int i, j;
        }
        for (p_73 = 0; (p_73 <= 7); p_73 += 1)
        { /* block id: 287 */
            int i;
            if (p_71)
                break;
            (*l_77) = l_467;
            /* statement id: 289 */
            assert (l_75 == &l_468);
        }
        /* facts after for loop */
        assert (l_75 == &l_468 || l_75 == &l_76);
        if (p_73)
        { /* block id: 291 */
            float l_500 = (-0x4.Dp+1);
            struct S0 *l_501[3][5] = {{(void*)0,&l_98,(void*)0,(void*)0,&l_98},{&l_98,(void*)0,(void*)0,&l_98,(void*)0},{&l_98,&l_98,&l_98,&l_98,&l_98}};
            int32_t *l_502 = &l_76;
            struct S0 ****l_509 = &l_128;
            int32_t ***l_524[5][3] = {{&l_77,&l_77,&l_77},{&l_77,&l_77,&l_77},{&l_77,&l_77,&l_77},{&l_77,&l_77,&l_77},{&l_77,&l_77,&l_77}};
            const struct S0 **l_535 = &l_155[1];
            int i, j;
            if ((safe_lshift_func_int8_t_s_u(p_71, (((void*)0 != l_501[1][1]) != (*l_431)))))
            { /* block id: 292 */
                uint64_t l_503 = 1UL;
                int32_t *l_504 = &l_76;
                (*l_77) = l_502;
                /* statement id: 293 */
                assert (l_75 == &l_76);
                l_503 = 0x0.2p-1;
                (*l_304) = l_504;
            }
            else
            { /* block id: 296 */
                int16_t l_510 = 0x32A8L;
                const struct S0 **l_536 = &l_155[0];
                struct S0 ****l_538 = &l_128;
                int32_t *l_545 = &l_76;
                (*l_431) = (safe_mod_func_uint16_t_u_u(((safe_add_func_uint16_t_u_u(((l_501[2][3] != (void*)0) < ((void*)0 == l_509)), 0x6CB3L)) != (l_510 == (safe_mod_func_uint16_t_u_u(((l_510 & 1UL) ^ (safe_mod_func_uint32_t_u_u(((l_502 != (void*)0) || p_71), 0x2F9841DAL))), p_71)))), (*l_502)));
                if ((safe_mod_func_uint8_t_u_u(0xEBL, (~4294967293UL))))
                { /* block id: 298 */
                    float l_525 = 0x1.4p-1;
                    const int32_t l_531 = 0x2F289225L;
                    const struct S0 **l_537 = &l_155[3];
                    (*l_393) = (safe_mod_func_int16_t_s_s((safe_add_func_uint8_t_u_u(p_71, (((((0x1855961EB2E0E07BLL >= p_73) <= ((void*)0 == l_524[3][1])) > (*l_393)) < (l_510 >= 0x34ABL)) < ((safe_lshift_func_int16_t_s_s((6UL <= 0x7AL), p_73)) ^ (*l_393))))), l_510));
                    for (l_93 = 0; (l_93 <= 1); l_93 += 1)
                    { /* block id: 302 */
                        struct S0 ***l_534 = (void*)0;
                        int i;
                        (*l_77) = l_431;
                        /* statement id: 303 */
                        assert (l_75 == &l_76);
                        (*l_431) = (p_71 < (safe_add_func_uint8_t_u_u((+((((l_155[(l_93 + 2)] != (*l_394)) > (-7L)) & l_531) != p_71)), ((p_73 < (((safe_mod_func_uint32_t_u_u((252UL ^ (((void*)0 != l_534) & 0xB5CFA8EB07649451LL)), l_531)) != p_73) <= 1L)) && l_531))));
                    }
                    return l_399;
                    /* statement id: 306 */
                    //assert (func_70_rv == 0);
                }
                else
                { /* block id: 307 */
                    int32_t *l_544[9] = {&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76,&l_76};
                    int i;
                    (*l_535) = func_16(p_73, l_510, (*l_393), func_16(p_71, (((void*)0 != l_538) >= ((((((p_73 && (!p_71)) == ((safe_sub_func_uint8_t_u_u((safe_div_func_int8_t_s_s((*l_431), p_73)), 0x3EL)) <= p_73)) == (*l_502)) >= p_71) && p_71) ^ (*l_393))), p_73, (***l_509)));
                    (*l_77) = l_544[2];
                    /* statement id: 309 */
                    assert (l_75 == &l_76);
                    (*l_304) = l_545;
                    (*l_431) = ((*l_77) != (void*)0);
                }
                /* facts after branching */
                assert (l_75 == &l_76);
                if (p_71)
                    goto lbl_619;
            }
            /* facts after branching */
            assert (l_75 == &l_76);
            for (p_71 = (-2); (p_71 <= (-14)); p_71--)
            { /* block id: 316 */
                uint32_t l_565 = 18446744073709551607UL;
                int32_t l_568[7][9] = {{0xFD59670EL,0x79697BE9L,0xFD59670EL,0x96857043L,0x79697BE9L,0x30765A50L,0x30765A50L,0x79697BE9L,0x96857043L},{0x47AE4779L,0xA4A8CEA9L,0x47AE4779L,(-8L),0xA4A8CEA9L,8L,8L,0xA4A8CEA9L,(-8L)},{0xFD59670EL,0x79697BE9L,0xFD59670EL,0xDCE70388L,0x30765A50L,0x8788B766L,0x8788B766L,0x30765A50L,0xDCE70388L},{0x1C80C58EL,8L,0x1C80C58EL,6L,8L,0L,0L,8L,6L},{(-10L),0x30765A50L,(-10L),0xDCE70388L,0x30765A50L,0x8788B766L,0x8788B766L,0x30765A50L,0xDCE70388L},{0x1C80C58EL,8L,0x1C80C58EL,6L,8L,0L,0L,8L,6L},{(-10L),0x30765A50L,(-10L),0xDCE70388L,0x30765A50L,0x8788B766L,0x8788B766L,0x30765A50L,0xDCE70388L}};
                int i, j;
            }
lbl_619:
            for (l_76 = 0; (l_76 <= 5); l_76 += 1)
            { /* block id: 342 */
                const uint32_t l_584 = 0UL;
                int32_t * const *l_591 = &l_75;
                const struct S0 **l_616 = &l_155[0];
                if ((safe_rshift_func_int8_t_s_s(0x6FL, (safe_unary_minus_func_uint8_t_u(((safe_mod_func_int64_t_s_s(((!0xECL) < ((void*)0 != (*l_394))), ((+(4294967295UL > (safe_div_func_int64_t_s_s(((0xA9L != (l_584 == ((**l_304) > (safe_rshift_func_uint8_t_u_s((safe_rshift_func_int8_t_s_s((safe_lshift_func_uint8_t_u_s(((&l_393 == l_591) >= p_71), (**l_591))), p_71)), 0))))) >= (**l_591)), 0x68A61375C96C76C8LL)))) && 1UL))) & 4UL))))))
                { /* block id: 343 */
                    for (l_95 = 2; (l_95 >= 0); l_95 -= 1)
                    { /* block id: 346 */
                        float l_592 = 0x8.B6885Fp+47;
                        (*l_304) = (*l_304);
                        if (p_71)
                            break;
                    }
                }
                else
                { /* block id: 350 */
                    float l_597 = 0xA.A88DFEp-98;
                    int32_t l_598 = 1L;
                    l_609[6][2][0] = (safe_mod_func_uint64_t_u_u((safe_lshift_func_uint8_t_u_s(1UL, ((((1UL & (**l_591)) <= 0xCDL) == p_71) <= l_598))), ((safe_rshift_func_uint16_t_u_u((safe_mod_func_int8_t_s_s(l_603, (**l_591))), (((((safe_lshift_func_int16_t_s_s(((safe_lshift_func_int8_t_s_s(((((void*)0 == l_608) || (*l_573)) && (*l_502)), 6)) <= p_71), 11)) ^ 0UL) > (*l_502)) | p_71) ^ 0x7BL))) | p_73)));
                }
                for (l_95 = 0; (l_95 <= 2); l_95 += 1)
                { /* block id: 355 */
                    uint64_t l_610 = 18446744073709551607UL;
                    int32_t *l_613 = &l_609[6][2][0];
                    const struct S0 **l_617[1];
                    const struct S0 **l_618 = (void*)0;
                    int i;
                    for (i = 0; i < 1; i++)
                        l_617[i] = &l_155[5];
                    for (l_93 = 0; (l_93 <= 2); l_93 += 1)
                    { /* block id: 358 */
                        int32_t **l_611 = (void*)0;
                        int32_t **l_612 = &l_431;
                        (*l_77) = &l_609[6][2][0];
                        /* statement id: 359 */
                        assert ((l_75 >= &l_609[0][0][0] && l_75 <= &l_609[6][4][2]));
                        if (l_610)
                            break;
                        (*l_612) = (*l_591);
                        /* statement id: 361 */
                        assert ((l_431 >= &l_609[0][0][0] && l_431 <= &l_609[6][4][2]));
                    }
                    /* facts after for loop */
                    assert ((l_431 >= &l_609[0][0][0] && l_431 <= &l_609[6][4][2]) || l_431 == &l_603 || l_431 == &l_76);
                    for (l_603 = 5; (l_603 >= 0); l_603 -= 1)
                    { /* block id: 365 */
                        (*l_467) = p_71;
                        (*l_77) = l_613;
                        /* statement id: 367 */
                        assert ((l_75 >= &l_609[0][0][0] && l_75 <= &l_609[6][4][2]));
                    }
                    l_431 = l_614;
                    /* statement id: 369 */
                    assert (l_431 == &l_603);
                    for (l_459 = 0; (l_459 <= 1); l_459 += 1)
                    { /* block id: 372 */
                        const struct S0 **l_615[9][6] = {{&l_155[6],(void*)0,(void*)0,(void*)0,&l_155[6],&l_155[6]},{&l_155[5],(void*)0,(void*)0,&l_155[5],&l_155[3],&l_155[5]},{&l_155[5],&l_155[3],&l_155[5],(void*)0,(void*)0,&l_155[5]},{&l_155[6],&l_155[6],(void*)0,(void*)0,(void*)0,&l_155[6]},{(void*)0,&l_155[3],(void*)0,(void*)0,&l_155[3],(void*)0},{&l_155[6],(void*)0,(void*)0,(void*)0,&l_155[6],&l_155[6]},{&l_155[5],(void*)0,(void*)0,&l_155[5],&l_155[3],&l_155[5]},{&l_155[5],&l_155[3],&l_155[5],(void*)0,(void*)0,&l_155[5]},{&l_155[6],&l_155[6],(void*)0,(void*)0,(void*)0,&l_155[6]}};
                        int i, j;
                        return l_618;
                        /* statement id: 373 */
                        //assert (func_70_rv == 0);
                    }
                }
            }
            /* facts after for loop */
            assert ((l_75 >= &l_609[0][0][0] && l_75 <= &l_609[6][4][2]) || l_75 == &l_76);
            assert (l_431 == &l_603 || l_431 == &l_76);
            if ((safe_mod_func_uint8_t_u_u(p_71, (safe_rshift_func_int8_t_s_u(((*l_431) < (((safe_sub_func_int32_t_s_s((safe_lshift_func_int8_t_s_s((safe_sub_func_int64_t_s_s((((safe_rshift_func_int16_t_s_u((l_524[2][0] != l_632), ((((**l_632) != (**l_632)) != (l_635 == &l_128)) > (*l_431)))) || 0L) | 3L), p_73)), p_71)), p_71)) > (*l_431)) <= (*l_502))), p_71)))))
            { /* block id: 378 */
                (*l_393) = p_71;
            }
            else
            { /* block id: 380 */
                const struct S0 **l_648 = &l_155[5];
                (*l_573) = (safe_add_func_int16_t_s_s((&p_72 == &l_129), ((safe_mod_func_int64_t_s_s((0xA4217B113511FACALL == p_71), p_73)) == 0x0FL)));
                (**l_632) = (*l_77);
                for (l_76 = (-10); (l_76 != 3); ++l_76)
                { /* block id: 385 */
                    int32_t **l_644 = &l_431;
                    struct S0 **l_645 = &l_97;
                    if (((*l_393) | ((safe_add_func_uint32_t_u_u(((void*)0 == l_644), p_73)) & (l_645 != (void*)0))))
                    { /* block id: 386 */
                        int32_t *l_646 = &l_603;
                        const struct S0 **l_647 = (void*)0;
                        (**l_632) = l_646;
                        /* statement id: 387 */
                        assert (l_75 == &l_603);
                        return l_647;
                        /* statement id: 388 */
                        //assert (func_70_rv == 0);
                    }
                    else
                    { /* block id: 389 */
                        (*l_304) = (**l_632);
                        /* statement id: 390 */
                        //assert ((l_305[0] >= &l_609[0][0][0] && l_305[0] <= &l_609[6][4][2]) || l_305[0] == &l_76);
                        return l_399;
                        /* statement id: 391 */
                        //assert (func_70_rv == 0);
                    }
                }
            }
        }
        else
        { /* block id: 395 */
            int32_t *l_649 = &l_609[4][1][0];
            int32_t *l_650 = &l_603;
            float l_674 = 0x7.74FE00p+18;
            (*l_304) = l_649;
            /* statement id: 396 */
            //assert ((l_305[0] >= &l_609[0][0][0] && l_305[0] <= &l_609[6][4][2]) || l_305[0] == &l_76);
            (**l_632) = (**l_632);
            (*l_304) = l_650;
            /* statement id: 398 */
            //assert (l_305[0] == &l_603 || (l_305[0] >= &l_609[0][0][0] && l_305[0] <= &l_609[6][4][2]) || l_305[0] == &l_76);
            for (l_456 = 10; (l_456 == 48); l_456++)
            { /* block id: 401 */
                int32_t l_665 = (-1L);
                uint32_t l_693 = 18446744073709551608UL;
            }
        }
        /* facts after branching */
        assert (l_75 == &l_468 || l_75 == &l_76 || (l_75 >= &l_609[0][0][0] && l_75 <= &l_609[6][4][2]));
        //assert (l_305[0] == &l_603 || (l_305[0] >= &l_609[0][0][0] && l_305[0] <= &l_609[6][4][2]) || l_305[0] == &l_76);
        assert (l_431 == &l_603 || l_431 == &l_76);
    }
    /* facts after branching */
    //assert (l_75 == 0 || l_75 == &l_76 || l_75 == dangling);
    //assert (l_305[0] == &l_603 || l_305[0] == dangling || l_305[0] == &l_76);
    (*l_703) = (safe_div_func_float_f_f((safe_div_func_float_f_f(p_73, p_71)), 0xD.C8C685p+71));
    if ((((((void*)0 == &l_128) & (p_73 >= (((((p_71 || (*l_614)) ^ l_705) && (safe_sub_func_int16_t_s_s((((safe_div_func_int16_t_s_s((((((void*)0 == &l_128) | ((safe_unary_minus_func_int16_t_s(((safe_sub_func_int8_t_s_s((1UL && (-9L)), 0xFEL)) > p_71))) != p_73)) == p_73) & p_73), 2L)) > p_73) != 0x703CL), 0x5E04L))) < p_73) ^ p_71))) < p_71) | p_71))
    { /* block id: 432 */
        uint16_t l_718 = 0xAE75L;
        const uint32_t l_719 = 4294967287UL;
        const int32_t **l_731 = &l_305[4];
        int32_t *l_732 = &l_603;
        (*l_614) = (((p_73 < 9L) ^ p_73) ^ ((0x05L & (p_73 >= (safe_mod_func_int64_t_s_s((p_71 != (l_718 ^ 0x8FB5487AL)), ((0xE468L < l_718) & p_71))))) == l_719));
        (*l_614) = (safe_div_func_uint16_t_u_u(((((safe_div_func_uint16_t_u_u((~((p_73 >= 0x0F90AA0FL) & ((safe_sub_func_int64_t_s_s((safe_mod_func_uint8_t_u_u((safe_unary_minus_func_int64_t_s((l_719 < l_718))), (safe_unary_minus_func_int64_t_s(((((((*l_308) == l_731) < (p_71 >= p_73)) > p_73) >= p_73) <= (-3L)))))), p_71)) | p_73))), p_71)) == 0UL) || p_71) <= 0xA7BB6B80C1C8F008LL), (-1L)));
        (**l_608) = l_732;
        /* statement id: 435 */
        assert (l_75 == &l_603);
    }
    else
    { /* block id: 436 */
        int8_t l_739[2];
        int i;
        for (i = 0; i < 2; i++)
            l_739[i] = (-4L);
        for (l_705 = 0; (l_705 == 18); ++l_705)
        { /* block id: 439 */
            (*l_614) = (safe_sub_func_int32_t_s_s(((safe_mod_func_uint32_t_u_u(0xCB22A602L, (((3UL != (0x5FB8E5D72F2D25E9LL || ((0x17CAED3D7042C2BDLL || p_71) != (l_739[0] && p_71)))) && p_71) || (safe_div_func_int8_t_s_s((p_71 || p_71), 255UL))))) != 252UL), 1UL));
        }
    }
    /* facts after branching */
    //assert (l_75 == 0 || l_75 == &l_76 || l_75 == dangling || l_75 == &l_603);
    return l_745;
    /* statement id: 443 */
    //assert (func_70_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 440
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 233
   depth: 2, occurrence: 53
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 4
   depth: 13, occurrence: 3
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 4
   depth: 18, occurrence: 4
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 2
   depth: 28, occurrence: 2
   depth: 29, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 419

XXX times a variable address is taken: 1119
XXX times a pointer is dereferenced on RHS: 224
breakdown:
   depth: 1, occurrence: 136
   depth: 2, occurrence: 50
   depth: 3, occurrence: 22
   depth: 4, occurrence: 10
   depth: 5, occurrence: 6
XXX times a pointer is dereferenced on LHS: 200
breakdown:
   depth: 1, occurrence: 151
   depth: 2, occurrence: 29
   depth: 3, occurrence: 13
   depth: 4, occurrence: 6
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 104
XXX times a pointer is compared with address of another variable: 31
XXX times a pointer is compared with another pointer: 34
XXX times a pointer is qualified to be dereferenced: 1985

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 913
   level: 2, occurrence: 315
   level: 3, occurrence: 129
   level: 4, occurrence: 60
   level: 5, occurrence: 43
XXX number of pointers point to pointers: 277
XXX number of pointers point to scalars: 93
XXX number of pointers point to structs: 49
XXX percent of pointers has null in alias set: 31.3
XXX average alias set size: 1.3

XXX times a non-volatile is read: 1953
XXX times a non-volatile is write: 652
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 10

XXX stmts: 221
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 26
   depth: 2, occurrence: 36
   depth: 3, occurrence: 38
   depth: 4, occurrence: 41
   depth: 5, occurrence: 45

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
********************* end of statistics **********************/

