/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      90378858
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int32_t  f1;
   int32_t  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_32(void);
static int32_t * func_33(const uint32_t  p_34, int32_t * p_35, int16_t  p_36);
static uint32_t  func_37(int32_t * p_38, int32_t  p_39, int8_t  p_40, uint16_t  p_41);
static uint32_t  func_53(int16_t  p_54, float  p_55, struct S0  p_56, int32_t * const  p_57, int32_t * const  p_58);
inline static uint32_t  func_61(const uint16_t  p_62);
static int16_t  func_65(int32_t * p_66);
inline static int32_t * func_67(uint32_t  p_68, int32_t  p_69);
inline static struct S0 * func_70(int32_t * p_71, int32_t * p_72);
static int32_t * func_73(struct S0 * p_74, uint16_t  p_75, float  p_76, const int32_t * p_77, struct S0 * p_78);
static struct S0 * func_79(int32_t * const  p_80, int32_t * p_81, struct S0 * p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_32(void)
{ /* block id: 36 */
    int32_t l_43 = 0x16488A97L;
    int32_t *l_42[10][8][3] = {{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}},{{&l_43,&l_43,&l_43},{&l_43,&l_43,&l_43},{(void*)0,(void*)0,&l_43},{&l_43,&l_43,&l_43},{(void*)0,&l_43,&l_43},{&l_43,&l_43,&l_43},{&l_43,(void*)0,&l_43},{&l_43,&l_43,&l_43}}};
    int32_t * const l_44 = &l_43;
    int32_t l_52 = 2L;
    struct S0 l_333 = {-4L,-5L,0L,18446744073709551611UL};
    int32_t **l_783 = &l_42[1][0][2];
    int32_t ***l_809[5][10][5] = {{{&l_783,&l_783,&l_783,(void*)0,(void*)0},{&l_783,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,&l_783,&l_783,(void*)0},{&l_783,&l_783,(void*)0,&l_783,&l_783},{(void*)0,&l_783,&l_783,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,&l_783},{(void*)0,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,(void*)0,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,(void*)0},{&l_783,(void*)0,&l_783,&l_783,&l_783}},{{&l_783,(void*)0,&l_783,&l_783,(void*)0},{&l_783,&l_783,(void*)0,&l_783,&l_783},{(void*)0,&l_783,&l_783,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,&l_783},{(void*)0,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,(void*)0,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,(void*)0},{&l_783,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,&l_783,&l_783,(void*)0},{&l_783,&l_783,(void*)0,&l_783,&l_783}},{{(void*)0,&l_783,&l_783,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,&l_783},{(void*)0,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,(void*)0,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,(void*)0},{&l_783,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,&l_783,&l_783,(void*)0},{&l_783,&l_783,(void*)0,&l_783,&l_783},{(void*)0,&l_783,&l_783,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,&l_783}},{{(void*)0,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,(void*)0,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,(void*)0},{&l_783,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,&l_783,&l_783,(void*)0},{&l_783,&l_783,(void*)0,&l_783,&l_783},{(void*)0,&l_783,&l_783,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,&l_783},{(void*)0,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,(void*)0,(void*)0,&l_783}},{{&l_783,&l_783,&l_783,(void*)0,(void*)0},{&l_783,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,&l_783,&l_783,(void*)0},{&l_783,&l_783,(void*)0,&l_783,&l_783},{(void*)0,&l_783,&l_783,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,&l_783},{(void*)0,(void*)0,&l_783,&l_783,&l_783},{&l_783,(void*)0,(void*)0,(void*)0,&l_783},{&l_783,&l_783,&l_783,(void*)0,(void*)0},{&l_783,(void*)0,&l_783,&l_783,&l_783}}};
    int32_t ****l_808 = &l_809[3][3][1];
    int32_t *****l_807 = &l_808;
    struct S0 *l_834 = &l_333;
    float l_846[4][6][6] = {{{0x9.87D425p+18,0xC.2B7CDCp-1,0xE.1BA8B8p+93,0xF.369031p+23,0x8.517C91p+73,0x1.Ap-1},{0x8.517C91p+73,0x1.68CCB3p-6,0x0.0p-1,0x1.68CCB3p-6,0x8.517C91p+73,0x4.3p+1},{0xA.93A76Cp+46,0xC.2B7CDCp-1,0x9.3531EEp-18,0xB.11A5C4p+71,0x1.68CCB3p-6,0xE.1BA8B8p+93},{0x6.30EE90p+56,0x1.0p-1,(-0x2.5p-1),0xC.2B7CDCp-1,0x1.0p-1,0xE.1BA8B8p+93},{0xB.11A5C4p+71,0xF.369031p+23,0x9.3531EEp-18,0x8.517C91p+73,0x6.30EE90p+56,0x4.3p+1},{0x1.0p-1,0xA.93A76Cp+46,0x0.0p-1,0x6.30EE90p+56,0x7.281C65p+65,0x1.Ap-1}},{{0x1.0p-1,0x4.A1E1C4p+80,0xE.1BA8B8p+93,0x8.517C91p+73,0x5.47FEEEp-78,(-0x2.3p-1)},{0xB.11A5C4p+71,0x6.30EE90p+56,0x8.95405Ep-66,0xC.2B7CDCp-1,0xC.2B7CDCp-1,0x8.95405Ep-66},{0x6.30EE90p+56,0x6.30EE90p+56,(-0x6.Bp+1),0xB.11A5C4p+71,0x5.47FEEEp-78,(-0x2.5p-1)},{0xA.93A76Cp+46,0x4.A1E1C4p+80,0x1.0p-1,0x1.68CCB3p-6,0x7.281C65p+65,(-0x6.Bp+1)},{0x8.517C91p+73,0xA.93A76Cp+46,0x1.0p-1,0xF.369031p+23,0x6.30EE90p+56,(-0x2.5p-1)},{0x9.87D425p+18,0xF.369031p+23,(-0x6.Bp+1),(-0x1.4p-1),0x1.0p-1,0x8.95405Ep-66}},{{(-0x1.4p-1),0x1.0p-1,0x8.95405Ep-66,(-0x1.4p-1),0x1.68CCB3p-6,(-0x2.3p-1)},{0x9.87D425p+18,0xC.2B7CDCp-1,0xE.1BA8B8p+93,0xF.369031p+23,0x8.517C91p+73,0x1.Ap-1},{0x8.517C91p+73,0x1.68CCB3p-6,0x0.0p-1,0x1.68CCB3p-6,0x8.517C91p+73,0x4.3p+1},{0xA.93A76Cp+46,0xC.2B7CDCp-1,0x9.3531EEp-18,0xB.11A5C4p+71,0x1.68CCB3p-6,0xE.1BA8B8p+93},{0x6.30EE90p+56,0x1.0p-1,(-0x2.5p-1),0xC.2B7CDCp-1,0x1.0p-1,0xE.1BA8B8p+93},{0xB.11A5C4p+71,0xF.369031p+23,0x9.3531EEp-18,0x8.517C91p+73,0x6.30EE90p+56,0x4.3p+1}},{{0x1.0p-1,0xA.93A76Cp+46,0x0.0p-1,0x6.30EE90p+56,0x7.281C65p+65,0x1.Ap-1},{0x1.0p-1,0x4.A1E1C4p+80,0xE.1BA8B8p+93,0x8.517C91p+73,0x5.47FEEEp-78,(-0x2.3p-1)},{0xB.11A5C4p+71,0x6.30EE90p+56,0x8.95405Ep-66,0xC.2B7CDCp-1,0xC.2B7CDCp-1,0x8.95405Ep-66},{0x6.30EE90p+56,0x6.30EE90p+56,0xA.93A76Cp+46,0x1.AC9A92p-46,0x7.1B6D54p+62,0x1.0p-1},{0x4.Fp+1,0x5.Cp-1,0xC.2B7CDCp-1,(-0x1.Bp+1),0xF.608C41p+47,0xA.93A76Cp+46},{0x8.AAAD5Ep+27,0x4.Fp+1,0xC.2B7CDCp-1,0x0.5p-1,0x2.9p+1,0x1.0p-1}}};
    int8_t l_847 = 0x3EL;
    int i, j, k;
    (*l_783) = func_33(func_37(l_42[1][0][2], (l_44 != &l_43), (!((uint16_t)0x8777L + (uint16_t)(0x8B15L & ((uint32_t)4UL + (uint32_t)(*l_44))))), ((uint32_t)l_52 / (uint32_t)(func_53(((uint32_t)__builtin_parityll(__builtin_popcount(func_61(((int16_t)func_65(func_67((*l_44), (*l_44))) + (int16_t)(*l_44))))) / (uint32_t)0x079DABEBL), (*l_44), l_333, &l_43, &l_43) || 0x0EFC4EF4L))), &l_43, (*l_44));
    (*l_44) = (*l_44);
    if ((*l_44))
    { /* block id: 589 */
        int16_t l_784 = 0xDB18L;
        l_784 = 0L;
    }
    else
    { /* block id: 591 */
        uint32_t l_787 = 0x2EDD48E0L;
        int32_t *l_802 = &l_43;
        for (l_43 = 0; (l_43 > (-26)); l_43 -= 1)
        { /* block id: 594 */
            uint16_t l_790 = 0xCE10L;
            uint32_t l_791 = 0xBC9CD077L;
            float l_797[8];
            uint32_t l_798 = 0x84C7D397L;
            const struct S0 l_840 = {0xF469DA1FL,0xB5C3E4C2L,-1L,1UL};
            struct S0 **l_841 = &l_834;
            int32_t *l_842 = (void*)0;
            int32_t ****l_843[10] = {&l_809[3][3][1],&l_809[3][3][1],&l_809[3][5][1],&l_809[3][3][1],&l_809[3][3][1],&l_809[3][5][1],&l_809[3][3][1],&l_809[3][3][1],&l_809[3][5][1],&l_809[3][3][1]};
            int i;
            for (i = 0; i < 8; i = i + 1)
                l_797[i] = (-0x1.Bp-1);
            if (((*l_44) && (l_787 <= ((uint32_t)0xEAF455CEL - (uint32_t)0xBDA9F005L))))
            { /* block id: 595 */
                uint32_t l_792 = 8UL;
                int32_t ***l_806 = &l_783;
                int32_t ****l_805 = &l_806;
                int32_t *****l_804[1][8] = {{&l_805,&l_805,&l_805,&l_805,&l_805,&l_805,&l_805,&l_805}};
                struct S0 * const l_826 = &l_333;
                int i, j;
                (*l_783) = (*l_783);
                if ((l_790 >= (l_791 <= ((l_792 ^ func_37((*l_783), l_790, l_792, ((((uint16_t)((int16_t)l_792 + (int16_t)l_787) << (uint16_t)(*l_44)) <= l_787) & l_792))) >= l_787))))
                { /* block id: 597 */
                    float *l_799 = &l_797[2];
                    (*l_799) = l_798;
                }
                else
                { /* block id: 599 */
                    int8_t l_810[5] = {0x93L,0x93L,0x93L,0x93L,0x93L};
                    float *l_814 = &l_797[0];
                    int32_t l_823 = 0xFEECFE11L;
                    int32_t l_829 = 0x08B7903DL;
                    int i;
                    for (l_333.f2 = 0; (l_333.f2 < (-27)); l_333.f2 -= 6)
                    { /* block id: 602 */
                        int32_t l_803 = 0x4229B4D9L;
                        float *l_813 = &l_797[1];
                        (*l_783) = l_802;
                        if (l_803)
                            continue;
                        l_810[1] = (l_804[0][2] == l_807);
                        l_823 = ((((int16_t)0xC61DL + (int16_t)(l_813 != l_814)) ^ 0x1BD5L) >= ((int32_t)((uint32_t)(l_803 & l_810[1]) % (uint32_t)(*l_802)) - (int32_t)(((uint16_t)(0xA5EEL == ((uint32_t)l_791 - (uint32_t)1UL)) >> (uint16_t)l_790) >= l_810[1])));
                    }
                    for (l_823 = 0; (l_823 > (-1)); l_823 -= 3)
                    { /* block id: 610 */
                        struct S0 *l_828 = &l_333;
                        struct S0 **l_827 = &l_828;
                        if ((*l_802))
                            break;
                        (*l_827) = l_826;
                        if (l_829)
                            continue;
                    }
                }
                l_802 = l_802;
            }
            else
            { /* block id: 617 */
                struct S0 *l_830[1];
                struct S0 **l_831 = (void*)0;
                struct S0 **l_832 = (void*)0;
                struct S0 **l_833[3];
                int32_t l_839 = 0x648E23A7L;
                int i;
                for (i = 0; i < 1; i = i + 1)
                    l_830[i] = &l_333;
                for (i = 0; i < 3; i = i + 1)
                    l_833[i] = &l_830[0];
                l_834 = l_830[0];
                /* statement id: 618 */
                assert (l_834 == &l_333);
                for (l_52 = 0; (l_52 >= (-2)); l_52 -= 1)
                { /* block id: 621 */
                    for (l_790 = 0; (l_790 == 5); l_790 += 9)
                    { /* block id: 624 */
                        (*l_834) = (*l_834);
                    }
                    for (l_790 = 0; (l_790 <= 4); l_790 += 1)
                    { /* block id: 629 */
                        return l_839;
                    }
                    (*l_834) = l_840;
                }
                if ((*l_802))
                    break;
            }
            (*l_841) = &l_840;
            /* statement id: 636 */
            assert (l_834 == &l_840);
            l_842 = l_802;
            /* statement id: 637 */
            assert (l_842 == &l_43);
            for (l_52 = 4; (l_52 >= 0); l_52 -= 1)
            { /* block id: 640 */
                (*l_807) = l_843[1];
                for (l_790 = 0; (l_790 <= 4); l_790 += 1)
                { /* block id: 644 */
                    struct S0 *l_844 = (void*)0;
                    struct S0 *l_845 = &l_333;
                    (*l_845) = (*l_834);
                }
            }
        }
        /* facts after for loop */
        //assert (l_834 == dangling || l_834 == &l_333);
    }
    /* facts after branching */
    //assert (l_834 == dangling || l_834 == &l_333);
    return l_847;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_33(const uint32_t  p_34, int32_t * p_35, int16_t  p_36)
{ /* block id: 542 */
    struct S0 l_732 = {1L,0x1E28D296L,0x290ED8C1L,5UL};
    struct S0 *l_733 = (void*)0;
    int32_t *l_736 = &l_732.f1;
    const struct S0 *l_742 = (void*)0;
    const struct S0 **l_741[3];
    struct S0 *l_743 = &l_732;
    int i;
    for (i = 0; i < 3; i = i + 1)
        l_741[i] = &l_742;
    l_732 = l_732;
    l_743 = &l_732;
    for (l_732.f1 = 9; (l_732.f1 > (-27)); l_732.f1 -= 1)
    { /* block id: 547 */
        uint32_t l_746 = 0x6F276252L;
        struct S0 l_748 = {-6L,0x17DB86CEL,0xB40560D2L,18446744073709551615UL};
        uint32_t l_764[9] = {1UL,0x10E88E2BL,1UL,0x10E88E2BL,1UL,0x10E88E2BL,1UL,0x10E88E2BL,1UL};
        int32_t *l_780[3][5] = {{&l_748.f1,(void*)0,(void*)0,(void*)0,&l_748.f1},{&l_748.f1,(void*)0,(void*)0,(void*)0,&l_748.f1},{&l_748.f1,(void*)0,(void*)0,(void*)0,&l_748.f1}};
        int i, j;
    }
    (*p_35) = (*p_35);
    return p_35;
    /* statement id: 586 */
    //assert (func_33_rv == &l_43);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_37(int32_t * p_38, int32_t  p_39, int8_t  p_40, uint16_t  p_41)
{ /* block id: 446 */
    float l_624 = (-0x4.5p-1);
    int32_t l_625 = 0x13B6CC2CL;
    float *l_626 = &l_624;
    float ****l_656 = (void*)0;
    int32_t l_660 = (-7L);
    struct S0 l_674 = {0L,0xF61A7186L,1L,0x1E276256L};
    struct S0 *l_673 = &l_674;
    (*l_626) = func_61(func_61((__builtin_parityll(l_625) && 0x4174L)));
    for (l_625 = 28; (l_625 > 19); l_625 -= 9)
    { /* block id: 450 */
        uint32_t l_631[4][4][5] = {{{0xEBD9107AL,1UL,0x3BA3C962L,18446744073709551611UL,0x97DB3320L},{0x97DB3320L,0UL,18446744073709551611UL,4UL,0UL},{0xB4F8EDF8L,1UL,0x15A5727BL,18446744073709551615UL,18446744073709551608UL},{0UL,18446744073709551609UL,0x7A285540L,0UL,0x97DB3320L}},{{0x29621CD5L,0UL,0xEBD9107AL,18446744073709551608UL,0x28C68B49L},{0x29621CD5L,0UL,0xCD585AF0L,0UL,0x29621CD5L},{0UL,18446744073709551615UL,0x3BA3C962L,0UL,18446744073709551609UL},{0xB4F8EDF8L,0x6C5E7696L,0UL,0xFE52B2F2L,0x6C5E7696L}},{{0x97DB3320L,0UL,0x88829DCAL,18446744073709551615UL,18446744073709551609UL},{0xEBD9107AL,0xFE52B2F2L,7UL,0xD8F124FFL,0x29621CD5L},{18446744073709551609UL,0x7A285540L,0UL,0x97DB3320L,0x28C68B49L},{0UL,1UL,18446744073709551608UL,0x97DB3320L,0x97DB3320L}},{{18446744073709551611UL,2UL,18446744073709551611UL,0xD8F124FFL,18446744073709551608UL},{0xB4F8EDF8L,0x28C68B49L,0xEBD9107AL,18446744073709551615UL,0UL},{0xFE52B2F2L,18446744073709551609UL,0UL,0xFE52B2F2L,0x97DB3320L},{7UL,0xFE52B2F2L,0xEBD9107AL,0UL,1UL}}};
        float ** const l_644[9][4][7] = {{{(void*)0,(void*)0,&l_626,&l_626,(void*)0,(void*)0,(void*)0},{&l_626,&l_626,&l_626,&l_626,&l_626,&l_626,(void*)0},{(void*)0,(void*)0,&l_626,&l_626,(void*)0,(void*)0,(void*)0},{&l_626,&l_626,&l_626,&l_626,&l_626,&l_626,(void*)0}},{{(void*)0,(void*)0,&l_626,&l_626,(void*)0,(void*)0,(void*)0},{&l_626,&l_626,&l_626,&l_626,&l_626,&l_626,(void*)0},{(void*)0,(void*)0,&l_626,&l_626,(void*)0,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626}},{{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626}},{{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626}},{{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626}},{{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626}},{{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626}},{{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626}},{{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,&l_626,(void*)0,(void*)0,&l_626,(void*)0,&l_626},{(void*)0,(void*)0,&l_626,&l_626,(void*)0,(void*)0,&l_626},{&l_626,(void*)0,&l_626,&l_626,(void*)0,&l_626,(void*)0}}};
        float ** const * const l_643 = &l_644[1][3][3];
        int32_t *l_669 = &l_625;
        int32_t l_691 = 4L;
        struct S0 *l_708 = &l_674;
        int32_t **l_731 = &l_669;
        int i, j, k;
        for (p_41 = (-21); (p_41 < 15); p_41 += 1)
        { /* block id: 453 */
            float **l_646 = &l_626;
            float *** const l_645 = &l_646;
            int32_t l_672[7][3] = {{1L,0x2F7136D0L,0x2F7136D0L},{1L,0x2F7136D0L,0x2F7136D0L},{1L,0x2F7136D0L,0x2F7136D0L},{1L,0x2F7136D0L,0x2F7136D0L},{1L,0x2F7136D0L,0x2F7136D0L},{1L,0x2F7136D0L,0x2F7136D0L},{1L,0x2F7136D0L,0x2F7136D0L}};
            struct S0 *l_680 = &l_674;
            int i, j;
            for (p_39 = 0; (p_39 <= 3); p_39 += 1)
            { /* block id: 456 */
                uint16_t l_632 = 0xFFBBL;
                int32_t *l_633 = &l_625;
                int32_t l_635[9] = {1L,5L,5L,1L,5L,5L,1L,5L,5L};
                struct S0 l_638 = {3L,-9L,0xD2A72C2EL,0x0D8E497EL};
                struct S0 *l_637 = &l_638;
                struct S0 **l_636 = &l_637;
                int32_t ****l_678[6] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                int32_t *****l_677 = &l_678[5];
                int i;
                if (l_632)
                    break;
                for (p_40 = 0; (p_40 <= 3); p_40 += 1)
                { /* block id: 460 */
                    int32_t **l_641 = &l_633;
                    int i, j, k;
                    if ((l_631[p_40][p_39][p_40] >= l_631[p_39][p_39][(p_39 + 1)]))
                    { /* block id: 461 */
                        int32_t **l_634 = &l_633;
                        (*l_634) = l_633;
                    }
                    else
                    { /* block id: 463 */
                        struct S0 * const *l_640 = &l_637;
                        struct S0 * const **l_639 = &l_640;
                        int i, j, k;
                        l_635[0] = (l_631[p_39][p_40][(p_39 + 1)] && p_40);
                        (*l_639) = l_636;
                    }
                    (*l_641) = (void*)0;
                    /* statement id: 467 */
                    assert (l_633 == 0);
                    for (l_638.f3 = 0; (l_638.f3 <= 3); l_638.f3 += 1)
                    { /* block id: 470 */
                        int32_t *l_642 = &l_635[4];
                        (*l_642) = p_39;
                    }
                }
                /* facts after for loop */
                assert (l_633 == 0 || l_633 == &l_625);
                if ((l_643 != l_645))
                { /* block id: 474 */
                    uint32_t l_653 = 0xCB9359C3L;
                    const int32_t *l_655 = &l_635[0];
                    const int32_t **l_654[1];
                    float ***l_659 = &l_646;
                    float ****l_658 = &l_659;
                    struct S0 *l_667 = &l_638;
                    int32_t ****l_676 = (void*)0;
                    int32_t *****l_675[4][8] = {{&l_676,&l_676,&l_676,&l_676,&l_676,&l_676,&l_676,&l_676},{&l_676,&l_676,&l_676,&l_676,&l_676,&l_676,&l_676,&l_676},{&l_676,&l_676,(void*)0,&l_676,&l_676,(void*)0,&l_676,&l_676},{&l_676,&l_676,(void*)0,&l_676,&l_676,(void*)0,(void*)0,(void*)0}};
                    int i, j;
                    for (i = 0; i < 1; i = i + 1)
                        l_654[i] = &l_655;
                    if (((int32_t)(((int16_t)(p_40 || 8UL) >> (int16_t)11) != ((uint16_t)__builtin_clzl(l_653) - (uint16_t)(l_654[0] != (void*)0))) / (int32_t)(p_41 & p_40)))
                    { /* block id: 475 */
                        float *****l_657[10][8] = {{&l_656,&l_656,&l_656,(void*)0,(void*)0,&l_656,&l_656,&l_656},{&l_656,&l_656,&l_656,&l_656,&l_656,&l_656,&l_656,&l_656},{&l_656,&l_656,&l_656,&l_656,&l_656,&l_656,(void*)0,&l_656},{&l_656,&l_656,(void*)0,&l_656,&l_656,&l_656,&l_656,&l_656},{&l_656,&l_656,&l_656,&l_656,&l_656,&l_656,&l_656,&l_656},{&l_656,&l_656,&l_656,&l_656,(void*)0,(void*)0,&l_656,&l_656},{&l_656,&l_656,(void*)0,&l_656,(void*)0,&l_656,(void*)0,&l_656},{&l_656,&l_656,&l_656,(void*)0,(void*)0,&l_656,&l_656,&l_656},{&l_656,&l_656,&l_656,&l_656,&l_656,&l_656,&l_656,&l_656},{&l_656,&l_656,&l_656,&l_656,&l_656,&l_656,(void*)0,&l_656}};
                        int i, j;
                        l_658 = l_656;
                        /* statement id: 476 */
                        assert (l_658 == 0);
                        l_660 = l_631[1][0][1];
                        if (p_40)
                            break;
                        l_660 = p_41;
                    }
                    else
                    { /* block id: 480 */
                        float ***l_661[2];
                        float ***l_662[3][8] = {{&l_646,&l_646,&l_646,&l_646,&l_646,&l_646,&l_646,&l_646},{&l_646,&l_646,&l_646,&l_646,&l_646,&l_646,&l_646,&l_646},{&l_646,&l_646,&l_646,&l_646,&l_646,&l_646,&l_646,&l_646}};
                        const float ***l_663 = (void*)0;
                        float * const *l_665[8][3];
                        float * const **l_664[9] = {&l_665[4][0],&l_665[4][0],&l_665[4][0],&l_665[4][0],&l_665[4][0],&l_665[4][0],&l_665[4][0],&l_665[4][0],&l_665[4][0]};
                        float ***l_666 = &l_646;
                        int32_t *l_668[5];
                        int i, j;
                        for (i = 0; i < 2; i = i + 1)
                            l_661[i] = &l_646;
                        for (i = 0; i < 8; i = i + 1)
                        {
                            for (j = 0; j < 3; j = j + 1)
                                l_665[i][j] = &l_626;
                        }
                        for (i = 0; i < 5; i = i + 1)
                            l_668[i] = (void*)0;
                        (*l_666) = (*l_643);
                        (*l_636) = l_667;
                        p_38 = func_73(func_70(l_668[0], l_669), (((0L ^ func_61(((65528UL & (p_40 | (0xD319L && (((uint16_t)l_672[0][1] / (uint16_t)(65535UL && l_625)) < 0x1FA5L)))) == 0x0BD30E66L))) != (*l_669)) || p_41), p_41, &l_672[0][1], l_673);
                        /* statement id: 483 */
                        assert (p_38 == 0);
                        l_677 = l_675[1][5];
                        /* statement id: 484 */
                        assert (l_677 == 0 || l_677 == &l_676);
                    }
                    /* facts after branching */
                    assert (l_677 == 0 || l_677 == &l_676 || (l_677 >= &l_678[0] && l_677 <= &l_678[5]));
                    assert (l_658 == &l_659 || l_658 == 0);
                }
                else
                { /* block id: 486 */
                    int32_t *l_679 = &l_660;
                    p_38 = &p_39;
                    /* statement id: 487 */
                    assert (p_38 == &p_39);
                }
                /* facts after branching */
                //assert (l_677 == 0 || l_677 == dangling || (l_677 >= &l_678[0] && l_677 <= &l_678[5]));
                l_691 = ((uint16_t)(p_41 || ((int16_t)(((uint32_t)p_41 - (uint32_t)(p_41 == (l_672[2][0] & ((uint16_t)l_672[6][1] >> (uint16_t)8)))) ^ (l_672[0][1] ^ (((p_41 == (0L >= __builtin_ctz(((uint32_t)(((*l_669) || 0x7C8FL) >= (*l_669)) - (uint32_t)p_39)))) == 0xAD9D8C9AL) >= p_40))) / (int16_t)(*l_669))) / (uint16_t)0xCF40L);
            }
            /* facts after for loop */
            assert (l_646 == &l_626 || l_646 == 0);
        }
        for (p_39 = 3; (p_39 >= 0); p_39 -= 1)
        { /* block id: 494 */
            struct S0 *l_692 = (void*)0;
            int32_t l_707 = 7L;
            struct S0 l_728 = {-8L,0x0C2B1FD0L,0x36F61814L,1UL};
            struct S0 l_730 = {0L,0xD351B17BL,-1L,0UL};
            for (p_41 = 0; (p_41 <= 3); p_41 += 1)
            { /* block id: 497 */
                int32_t **l_709 = &l_669;
                int i, j, k;
                (*l_709) = func_73(l_692, ((uint16_t)((((int16_t)((int32_t)2L % (int32_t)((int32_t)(l_631[p_41][p_39][(p_39 + 1)] && ((l_631[p_41][p_39][(p_39 + 1)] <= ((uint16_t)(l_674.f2 < 0x8A39L) >> (uint16_t)((int16_t)l_674.f1 % (int16_t)__builtin_ctz(((int16_t)0x8C9EL << (int16_t)10))))) ^ 4294967295UL)) / (int32_t)p_39)) % (int16_t)p_41) & 0xAD353F23L) > (*l_669)) >> (uint16_t)10), l_707, &l_691, l_708);
                /* statement id: 498 */
                assert (l_669 == 0);
                return l_660;
            }
            for (l_674.f0 = 0; (l_674.f0 <= 3); l_674.f0 += 1)
            { /* block id: 503 */
                int16_t l_713 = 0x7B7CL;
                const int32_t *l_724[3][10] = {{&l_625,&l_674.f0,&l_660,(void*)0,&l_707,&l_625,&l_625,&l_707,(void*)0,&l_660},{&l_674.f0,&l_674.f0,&l_691,(void*)0,&l_707,&l_674.f0,&l_674.f0,&l_707,&l_691,&l_707},{&l_674.f0,&l_625,&l_660,(void*)0,&l_660,&l_625,&l_674.f0,&l_660,(void*)0,&l_707}};
                int32_t * const l_725 = (void*)0;
                int32_t **l_727[3][10] = {{&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669},{&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669},{&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669}};
                struct S0 l_729 = {-5L,9L,-1L,18446744073709551610UL};
                int i, j;
                if (l_707)
                { /* block id: 504 */
                    uint32_t l_712 = 0x94486627L;
                    for (l_674.f1 = 0; (l_674.f1 <= 3); l_674.f1 += 1)
                    { /* block id: 507 */
                        int8_t l_710 = 0L;
                        int32_t l_711 = 0x20F228DCL;
                        l_711 = (func_65(&p_39) < l_710);
                        if (l_712)
                            break;
                        l_713 = (*l_669);
                    }
                }
                else
                { /* block id: 512 */
                    const int16_t l_714 = 0xC5C5L;
                    int32_t *l_715 = &l_707;
                    int16_t l_719 = 0x63FDL;
                    struct S0 l_720 = {7L,0x1C00EDEBL,0xDAF24364L,0x10AE9567L};
                    if (l_714)
                    { /* block id: 513 */
                        int32_t **l_716[2];
                        struct S0 *l_721[10] = {&l_720,&l_720,&l_720,&l_720,&l_720,&l_720,&l_720,&l_720,&l_720,&l_720};
                        int i;
                        for (i = 0; i < 2; i = i + 1)
                            l_716[i] = (void*)0;
                        p_38 = l_715;
                        /* statement id: 514 */
                        assert (p_38 == &l_707);
                        (*p_38) = ((uint16_t)((l_719 & p_41) & p_39) << (uint16_t)p_39);
                    }
                    else
                    { /* block id: 516 */
                        int16_t l_726 = (-10L);
                        return l_726;
                    }
                    /* facts after branching */
                    assert (p_38 == &l_707);
                }
                /* facts after branching */
                //assert (p_38 == &l_707 || p_38 == &l_660 || p_38 == &p_39 || p_38 == 0 || p_38 == &l_43 || p_38 == &l_732.f1);
                p_38 = &l_660;
                /* statement id: 520 */
                assert (p_38 == &l_660);
                l_729 = l_728;
            }
            for (l_674.f3 = 0; (l_674.f3 <= 3); l_674.f3 += 1)
            { /* block id: 525 */
                for (l_728.f0 = 3; (l_728.f0 >= 0); l_728.f0 -= 1)
                { /* block id: 528 */
                    l_730 = (*l_708);
                    for (p_40 = 0; (p_40 <= 3); p_40 += 1)
                    { /* block id: 532 */
                        int i, j, k;
                        return l_631[p_39][l_728.f0][p_39];
                    }
                }
            }
        }
        (*l_731) = &p_39;
        /* statement id: 538 */
        assert (l_669 == &p_39);
        (*l_731) = (*l_731);
    }
    /* facts after for loop */
    //assert (p_38 == &l_660 || p_38 == &p_39 || p_38 == 0 || p_38 == &l_43 || p_38 == &l_732.f1);
    return l_674.f2;
}


/* ------------------------------------------ */
/* 
 * reads : l_43
 * writes:
 */
static uint32_t  func_53(int16_t  p_54, float  p_55, struct S0  p_56, int32_t * const  p_57, int32_t * const  p_58)
{ /* block id: 181 */
    float l_340 = (-0x1.Dp-1);
    float *l_339 = &l_340;
    float * const *l_338[10];
    int32_t l_343 = 0x4560A459L;
    struct S0 l_349 = {9L,0xAAEA8AA2L,0xDAF063AFL,18446744073709551606UL};
    struct S0 *l_348[10] = {&l_349,&l_349,&l_349,&l_349,&l_349,&l_349,&l_349,&l_349,&l_349,&l_349};
    struct S0 **l_347 = &l_348[6];
    int16_t l_362 = 1L;
    float l_440 = 0x6.D7AD73p+54;
    int32_t *l_472 = &l_349.f1;
    int8_t l_508 = 0x12L;
    int32_t **** const l_581 = (void*)0;
    int32_t **** const *l_580 = &l_581;
    int32_t **l_604[10][2] = {{&l_472,&l_472},{&l_472,&l_472},{&l_472,&l_472},{&l_472,&l_472},{&l_472,&l_472},{&l_472,&l_472},{&l_472,&l_472},{&l_472,&l_472},{&l_472,&l_472},{&l_472,&l_472}};
    int32_t **l_605 = &l_472;
    int32_t l_623 = 2L;
    int i, j;
    for (i = 0; i < 10; i = i + 1)
        l_338[i] = &l_339;
    for (p_56.f0 = 0; (p_56.f0 <= 7); ++p_56.f0)
    { /* block id: 184 */
        const float *l_342 = (void*)0;
        const float **l_341[7][1][9] = {{{(void*)0,(void*)0,&l_342,(void*)0,(void*)0,&l_342,&l_342,(void*)0,(void*)0}},{{&l_342,&l_342,&l_342,(void*)0,(void*)0,&l_342,&l_342,&l_342,&l_342}},{{&l_342,&l_342,&l_342,&l_342,&l_342,&l_342,&l_342,&l_342,&l_342}},{{&l_342,&l_342,&l_342,(void*)0,&l_342,&l_342,(void*)0,&l_342,&l_342}},{{(void*)0,&l_342,&l_342,(void*)0,&l_342,(void*)0,&l_342,(void*)0,&l_342}},{{&l_342,&l_342,(void*)0,&l_342,&l_342,&l_342,(void*)0,&l_342,&l_342}},{{&l_342,(void*)0,&l_342,(void*)0,&l_342,(void*)0,&l_342,&l_342,(void*)0}}};
        struct S0 l_346[3][2][10] = {{{{-1L,3L,8L,0UL},{0L,1L,1L,18446744073709551615UL},{-8L,1L,-7L,0xE3BC6F35L},{0L,1L,1L,18446744073709551615UL},{-1L,3L,8L,0UL},{7L,0x2F081EF1L,-3L,18446744073709551612UL},{0L,0xCC8516D3L,0x11995FF3L,18446744073709551613UL},{-1L,3L,8L,0UL},{0xC883CA65L,7L,-9L,0xED37A764L},{-9L,7L,0x8229333FL,18446744073709551611UL}},{{-5L,-1L,0L,0x7B765CC0L},{-1L,3L,-4L,0x7A9D4689L},{0x78D34727L,0xAFDD5D7FL,0xE9E42C7AL,18446744073709551606UL},{-1L,3L,8L,0UL},{0x22C10014L,0xED1AC72EL,-10L,0UL},{0xC4334580L,0xAD4ACA55L,0x8ACACFB8L,2UL},{-9L,7L,0x8229333FL,18446744073709551611UL},{-1L,3L,-4L,0x7A9D4689L},{-1L,3L,-4L,0x7A9D4689L},{-9L,7L,0x8229333FL,18446744073709551611UL}}},{{{0xE1B017B5L,0xF8126BFCL,0xF3970844L,0x9E8BBB4EL},{-1L,3L,8L,0UL},{0x87FEB0DEL,0xAC6C3F52L,-1L,1UL},{0x87FEB0DEL,0xAC6C3F52L,-1L,1UL},{0x87FEB0DEL,0xAC6C3F52L,-1L,1UL},{0x825BB455L,0x93346F6FL,2L,1UL},{0xA4908C5FL,0x0F436BDCL,1L,4UL},{0L,0xD7B1E90CL,-1L,0xF13F1AD5L},{7L,0x2F081EF1L,-3L,18446744073709551612UL},{-8L,1L,-7L,0xE3BC6F35L}},{{0xC4334580L,0xAD4ACA55L,0x8ACACFB8L,2UL},{0x22C10014L,0xED1AC72EL,-10L,0UL},{-1L,3L,8L,0UL},{0x78D34727L,0xAFDD5D7FL,0xE9E42C7AL,18446744073709551606UL},{-1L,3L,-4L,0x7A9D4689L},{-5L,-1L,0L,0x7B765CC0L},{0x78D34727L,0xAFDD5D7FL,0xE9E42C7AL,18446744073709551606UL},{0xC4334580L,0xAD4ACA55L,0x8ACACFB8L,2UL},{0x07567DA4L,-4L,0x81797701L,18446744073709551609UL},{0xC4334580L,0xAD4ACA55L,0x8ACACFB8L,2UL}}},{{{0xC4334580L,0xAD4ACA55L,0x8ACACFB8L,2UL},{0x825BB455L,0x93346F6FL,2L,1UL},{0xBEADC1CBL,0x06B8D2B0L,0xCD6C90BDL,18446744073709551611UL},{0x87FEB0DEL,0xAC6C3F52L,-1L,1UL},{0xBEADC1CBL,0x06B8D2B0L,0xCD6C90BDL,18446744073709551611UL},{0x825BB455L,0x93346F6FL,2L,1UL},{0xC4334580L,0xAD4ACA55L,0x8ACACFB8L,2UL},{-5L,0x8763CD8DL,0xA53E3237L,3UL},{0x825BB455L,0x93346F6FL,2L,1UL},{0x22C10014L,0xED1AC72EL,-10L,0UL}},{{0x825BB455L,0x93346F6FL,2L,1UL},{0xC4334580L,0xAD4ACA55L,0x8ACACFB8L,2UL},{-5L,0x8763CD8DL,0xA53E3237L,3UL},{0x825BB455L,0x93346F6FL,2L,1UL},{0x22C10014L,0xED1AC72EL,-10L,0UL},{7L,0x2F081EF1L,-3L,18446744073709551612UL},{0xBEADC1CBL,0x06B8D2B0L,0xCD6C90BDL,18446744073709551611UL},{0L,0xD7B1E90CL,-1L,0xF13F1AD5L},{-5L,0x8763CD8DL,0xA53E3237L,3UL},{-5L,0x8763CD8DL,0xA53E3237L,3UL}}}};
        struct S0 *l_345 = &l_346[0][0][1];
        struct S0 **l_344[4] = {&l_345,&l_345,&l_345,&l_345};
        int32_t *l_394 = &l_343;
        int16_t l_431[2];
        int32_t *l_447[3];
        int i, j, k;
        for (i = 0; i < 2; i = i + 1)
            l_431[i] = 0xD471L;
        for (i = 0; i < 3; i = i + 1)
            l_447[i] = &l_346[0][0][1].f1;
        if (((uint32_t)((l_338[7] == l_341[2][0][5]) ^ ((void*)0 == &l_338[7])) + (uint32_t)((l_343 > (&p_56 == (void*)0)) | (l_344[3] == l_347))))
        { /* block id: 185 */
            int32_t l_352[3][4];
            uint16_t l_379[1];
            int i, j;
            for (i = 0; i < 3; i = i + 1)
            {
                for (j = 0; j < 4; j = j + 1)
                    l_352[i][j] = 0x5E4DD879L;
            }
            for (i = 0; i < 1; i = i + 1)
                l_379[i] = 0xF215L;
            (*l_339) = ((-(float)(!l_352[1][1])) < ((float)l_349.f1 + (float)l_346[0][0][1].f1));
            for (p_56.f3 = (-17); (p_56.f3 >= 14); p_56.f3 += 7)
            { /* block id: 189 */
                int8_t l_367[1][1];
                int32_t *l_376[2][10] = {{&l_346[0][0][1].f1,&l_352[1][1],&l_346[0][0][1].f1,&l_352[1][1],&l_346[0][0][1].f1,&l_352[1][1],&l_346[0][0][1].f1,&l_352[1][1],&l_346[0][0][1].f1,&l_352[1][1]},{&l_346[0][0][1].f1,&l_352[1][1],&l_346[0][0][1].f1,&l_352[1][1],&l_346[0][0][1].f1,&l_352[1][1],&l_346[0][0][1].f1,&l_352[1][1],&l_346[0][0][1].f1,&l_352[1][1]}};
                int i, j;
                for (i = 0; i < 1; i = i + 1)
                {
                    for (j = 0; j < 1; j = j + 1)
                        l_367[i][j] = (-1L);
                }
                if ((*p_57))
                    break;
                for (p_54 = 0; (p_54 > 22); p_54 += 5)
                { /* block id: 193 */
                    int32_t *l_360 = &l_349.f0;
                    int32_t **l_359 = &l_360;
                    (*l_359) = p_58;
                    /* statement id: 194 */
                    //assert (l_360 == &l_43);
                    for (l_343 = 9; (l_343 >= 0); l_343 -= 1)
                    { /* block id: 197 */
                        const int32_t ** const * const l_366 = (void*)0;
                        const int32_t ** const * const *l_365 = &l_366;
                        (*l_359) = func_67(p_56.f2, p_56.f3);
                        /* statement id: 198 */
                        assert (l_360 == 0);
                        l_367[0][0] = (!(p_54 ^ (p_56.f2 != ((__builtin_parityll((func_65(&l_352[2][0]) < 0xA5C6L)) == l_362) | ((uint16_t)(0x3015L ^ (l_365 == &l_366)) - (uint16_t)p_56.f0)))));
                    }
                    /* facts after for loop */
                    //assert (l_360 == 0 || l_360 == &l_43);
                }
                for (p_54 = 21; (p_54 < (-17)); p_54 -= 1)
                { /* block id: 204 */
                    int32_t * const l_372 = &l_343;
                    int32_t *l_373 = (void*)0;
                    struct S0 *l_375 = &l_346[1][0][1];
                    for (l_349.f3 = 0; (l_349.f3 <= 43); ++l_349.f3)
                    { /* block id: 207 */
                        uint16_t l_374[10] = {1UL,65529UL,1UL,65529UL,1UL,65529UL,1UL,65529UL,1UL,65529UL};
                        int32_t **l_377 = (void*)0;
                        int32_t **l_378 = &l_376[1][4];
                        int i;
                        (*l_378) = l_376[1][4];
                    }
                    return l_352[2][2];
                }
            }
            if (l_379[0])
                break;
        }
        else
        { /* block id: 214 */
            int32_t l_412 = 0x3F2CA31AL;
            struct S0 *l_420 = &l_346[0][1][4];
            for (l_349.f2 = 17; (l_349.f2 == 1); l_349.f2 -= 1)
            { /* block id: 217 */
                uint32_t l_386 = 0xCC62D627L;
                struct S0 l_391 = {0x7BB51946L,0xF8D6F025L,0x3EA5185AL,0xB5BE6EF7L};
                int32_t *l_413 = (void*)0;
                for (p_54 = 27; (p_54 < (-16)); p_54 -= 8)
                { /* block id: 220 */
                    float l_389 = 0x3.2p+1;
                    int32_t l_390 = 0x50C18F83L;
                    for (p_56.f1 = (-16); (p_56.f1 > (-7)); ++p_56.f1)
                    { /* block id: 223 */
                        int32_t *l_388 = &l_346[0][0][1].f1;
                        int32_t **l_387 = &l_388;
                        p_55 = l_386;
                        (*l_387) = p_57;
                        /* statement id: 225 */
                        //assert (l_388 == &l_43);
                        p_55 = (((0x9.174C6Ap+96 > (p_56.f1 >= l_386)) > l_389) != p_54);
                        (*l_345) = p_56;
                    }
                    return l_390;
                }
                for (p_56.f1 = 0; (p_56.f1 <= 3); p_56.f1 += 1)
                { /* block id: 233 */
                    int32_t *l_393[10] = {&l_391.f1,&l_391.f1,&l_391.f1,&l_391.f1,&l_391.f1,&l_391.f1,&l_391.f1,&l_391.f1,&l_391.f1,&l_391.f1};
                    int32_t **l_392 = &l_393[1];
                    int i;
                    (*l_345) = l_391;
                    for (l_386 = 0; (l_386 <= 3); l_386 += 1)
                    { /* block id: 237 */
                        if (l_346[0][0][1].f1)
                            break;
                    }
                    (*l_392) = p_58;
                    /* statement id: 240 */
                    //assert (l_393[0] == &l_43 || l_393[0] == &l_391.f1 || (l_393[0] >= &l_346[0][0][0].f0 && l_393[0] <= &l_346[2][1][9].f0));
                    l_394 = (void*)0;
                    /* statement id: 241 */
                    assert (l_394 == 0);
                }
                if (l_391.f3)
                { /* block id: 243 */
                    int32_t *l_397 = (void*)0;
                    struct S0 * const l_409 = (void*)0;
                    int32_t **l_419[3][1][5] = {{{&l_394,&l_397,&l_397,&l_397,&l_394}},{{&l_394,&l_397,&l_397,&l_397,&l_394}},{{&l_394,&l_397,&l_397,&l_397,&l_394}}};
                    int i, j, k;
                    l_391.f1 = ((float)(func_65(l_397) > (__builtin_ffsl((((int16_t)(&p_57 == &p_57) << (int16_t)1) && ((uint16_t)((uint32_t)((int32_t)(~((int16_t)(l_409 == &p_56) << (int16_t)14)) * (int32_t)(func_65(l_397) == 65535UL)) - (uint32_t)0xD71E8C82L) << (uint16_t)3))) != l_349.f0)) / (float)(-0x1.4p+1));
                    if (((int32_t)__builtin_popcountll(l_412) % (int32_t)0x87C5DDD1L))
                    { /* block id: 245 */
                        struct S0 *l_414 = &l_349;
                        (*l_347) = func_79(&l_343, l_413, l_414);
                    }
                    else
                    { /* block id: 247 */
                        int32_t **l_415 = &l_397;
                        (*l_415) = &l_412;
                        /* statement id: 248 */
                        assert (l_397 == &l_412);
                    }
                    /* facts after branching */
                    assert (l_397 == &l_412 || l_397 == 0);
                    for (l_391.f0 = 1; (l_391.f0 >= 0); l_391.f0 -= 1)
                    { /* block id: 252 */
                        int32_t **l_416[5] = {&l_413,&l_413,&l_413,&l_413,&l_413};
                        int i, j, k;
                        l_413 = l_394;
                        l_412 = ((*p_57) == (-7L));
                        l_346[l_391.f0][l_391.f0][(l_391.f0 + 3)] = l_346[l_391.f0][l_391.f0][(l_391.f0 + 3)];
                        (*l_339) = ((float)(((&l_348[6] == (void*)0) != __builtin_parity(l_412)) <= (p_54 == ((func_65(&l_412) != 0x1.0p+1) < p_56.f3))) - (float)0xB.54A4BAp-56);
                    }
                    /* facts after for loop */
                    assert (l_413 == 0 || l_413 == &l_343);
                    l_394 = (void*)0;
                    /* statement id: 258 */
                    assert (l_394 == 0);
                }
                else
                { /* block id: 259 */
                    struct S0 *l_425 = (void*)0;
                    l_412 = func_65(l_394);
                }
                /* facts after branching */
                assert (l_413 == 0 || l_413 == &l_343);
                for (l_412 = 0; (l_412 <= 1); l_412 += 1)
                { /* block id: 264 */
                    int32_t **l_426 = (void*)0;
                    int32_t **l_427 = &l_394;
                    int i, j, k;
                    (*l_427) = func_67((0x44C4L | p_56.f2), p_54);
                    /* statement id: 265 */
                    assert (l_394 == 0);
                    (*l_347) = &l_346[(l_412 + 1)][l_412][(l_412 + 5)];
                    for (p_56.f1 = 1; (p_56.f1 >= 0); p_56.f1 -= 1)
                    { /* block id: 269 */
                        int32_t *l_428 = (void*)0;
                        int32_t *l_429 = (void*)0;
                        int32_t *l_430 = &l_343;
                        (*l_430) = (*p_58);
                        (*l_427) = (void*)0;
                        (*l_430) = l_431[1];
                        if ((*p_57))
                            break;
                    }
                }
            }
            /* facts after for loop */
            //assert ((l_348[0] >= &l_346[0][0][0] && l_348[0] <= &l_346[2][1][9]) || l_348[0] == 0 || l_348[0] == &l_349 || l_348[0] == dangling);
            assert (l_394 == 0 || l_394 == &l_343);
        }
        /* facts after branching */
        //assert ((l_348[0] >= &l_346[0][0][0] && l_348[0] <= &l_346[2][1][9]) || l_348[0] == 0 || l_348[0] == &l_349 || l_348[0] == dangling);
        assert (l_394 == 0 || l_394 == &l_343);
        l_349.f0 = (l_362 || ((int32_t)(((int16_t)(((uint16_t)(((uint32_t)l_349.f2 % (uint32_t)((l_346[0][0][1].f0 >= (0x98826F6DL < p_56.f2)) ^ __builtin_ctzll(((0x75C50D98L && __builtin_ctzl(((uint16_t)1UL << (uint16_t)13))) & ((int16_t)((int32_t)(*p_58) / (int32_t)p_56.f3) >> (int16_t)12))))) >= 7UL) + (uint16_t)p_56.f0) || 0x2DB0L) / (int16_t)p_56.f1) ^ 65535UL) - (int32_t)4294967295UL));
    }
    /* facts after for loop */
    //assert (l_348[0] == dangling || l_348[0] == 0 || l_348[0] == &l_349);
    if ((((int16_t)p_54 % (int16_t)l_362) ^ func_65(&l_343)))
    { /* block id: 280 */
        struct S0 l_463 = {-9L,9L,4L,0xFA31D04DL};
        int32_t *l_468 = &l_343;
        int32_t l_481[2];
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_481[i] = 0x716BC840L;
        for (l_349.f2 = 0; (l_349.f2 >= (-27)); l_349.f2 -= 4)
        { /* block id: 283 */
            int32_t l_469 = 0L;
            int32_t *****l_490[4];
            struct S0 *l_532 = &l_349;
            int i;
            for (i = 0; i < 4; i = i + 1)
                l_490[i] = (void*)0;
            if (((uint16_t)(l_349.f1 != 4294967292UL) / (uint16_t)0x1785L))
            { /* block id: 284 */
                int32_t *l_455 = &l_349.f0;
                int32_t **l_454 = &l_455;
                uint32_t l_461 = 0x76F1D13DL;
                (*l_454) = p_58;
                /* statement id: 285 */
                //assert (l_455 == &l_43);
                for (l_349.f1 = 0; (l_349.f1 > (-21)); l_349.f1 -= 1)
                { /* block id: 288 */
                    uint32_t l_460 = 4294967295UL;
                    const struct S0 l_462 = {0x7263D5FDL,0x989F679BL,0x2A3292C3L,0x8E2B2039L};
                    l_460 = ((uint16_t)__builtin_ctzl(p_56.f3) / (uint16_t)1UL);
                    for (p_56.f0 = 0; (p_56.f0 <= 9); p_56.f0 += 1)
                    { /* block id: 292 */
                        int i;
                        l_461 = (-0x1.9p-1);
                    }
                    l_463 = l_462;
                    (*l_339) = l_463.f1;
                }
            }
            else
            { /* block id: 298 */
                int32_t *l_465 = &l_349.f1;
                int32_t **l_464[2][10] = {{&l_465,&l_465,&l_465,&l_465,&l_465,&l_465,&l_465,&l_465,&l_465,&l_465},{&l_465,&l_465,&l_465,&l_465,&l_465,&l_465,&l_465,&l_465,&l_465,&l_465}};
                int32_t **l_466 = (void*)0;
                int32_t **l_467 = (void*)0;
                struct S0 *l_473[3];
                int32_t * const *l_479[7];
                int32_t * const **l_478 = &l_479[1];
                int32_t * const ***l_477[1][6];
                int32_t * const *** const *l_476 = &l_477[0][3];
                int i, j;
                for (i = 0; i < 3; i = i + 1)
                    l_473[i] = (void*)0;
                for (i = 0; i < 7; i = i + 1)
                    l_479[i] = &l_468;
                for (i = 0; i < 1; i = i + 1)
                {
                    for (j = 0; j < 6; j = j + 1)
                        l_477[i][j] = &l_478;
                }
                l_468 = p_57;
                /* statement id: 299 */
                //assert (l_468 == &l_43);
                if ((0x3B200AD6L >= (func_65(&l_343) ^ l_469)))
                { /* block id: 300 */
                    p_56 = p_56;
                    for (l_463.f3 = 19; (l_463.f3 < 15); l_463.f3 -= 8)
                    { /* block id: 304 */
                        l_472 = p_57;
                        /* statement id: 305 */
                        //assert (l_472 == &l_43);
                        return p_54;
                    }
                }
                else
                { /* block id: 308 */
                    int32_t *l_480 = (void*)0;
                    l_473[0] = &p_56;
                    /* statement id: 309 */
                    //assert (l_473[0] == &p_56 || l_473[0] == 0);
                    for (l_463.f0 = 0; l_463.f0 < 3; l_463.f0 += 1)
                    {
                        l_473[l_463.f0] = &l_349;
                    }
                    //assert (l_473[0] == &l_349 || l_473[0] == &p_56 || l_473[0] == 0);
                    p_56.f0 = ((uint16_t)(l_476 == (void*)0) << (uint16_t)func_65(l_480));
                }
                /* facts after branching */
                //assert (l_473[0] == &l_349 || l_473[0] == &p_56 || l_473[0] == 0);
            }
            if (l_469)
            { /* block id: 314 */
                if ((*l_468))
                { /* block id: 315 */
                    (*l_472) = (*p_57);
                }
                else
                { /* block id: 317 */
                    return p_56.f1;
                }
                return l_481[0];
            }
            else
            { /* block id: 321 */
                int32_t l_514 = 1L;
                struct S0 l_516 = {-7L,0x1EE181A4L,0xE2F8CDA0L,1UL};
                int32_t l_519 = 0x321D2B17L;
                int32_t **l_536 = (void*)0;
                p_56 = p_56;
                if ((*l_468))
                    continue;
                if (((int32_t)(*p_58) / (int32_t)((int16_t)((uint16_t)0xF388L + (uint16_t)((((uint16_t)p_54 << (uint16_t)10) <= (*p_57)) && ((l_490[2] != l_490[2]) || (-1L)))) - (int16_t)(*l_468))))
                { /* block id: 324 */
                    int32_t **l_491 = &l_468;
                    struct S0 l_515 = {1L,2L,0xBAD9D3F4L,3UL};
                    (*l_347) = &p_56;
                    /* statement id: 325 */
                    //assert (l_348[0] == &p_56 || l_348[0] == dangling || l_348[0] == 0 || l_348[0] == &l_349);
                    (*l_491) = p_58;
                    /* statement id: 326 */
                    //assert (l_468 == &l_43);
                    for (l_349.f3 = (-12); (l_349.f3 < 14); l_349.f3 += 5)
                    { /* block id: 329 */
                        float l_509 = 0x9.764A40p+89;
                        int32_t l_513 = (-7L);
                    }
                    return (*l_468);
                }
                else
                { /* block id: 335 */
                    int32_t l_517 = (-9L);
                    struct S0 *l_529 = &l_349;
                    int32_t **l_535 = &l_472;
                    if (l_517)
                    { /* block id: 336 */
                        struct S0 l_518 = {0xDB152E0CL,0x317D5722L,1L,0xB7D62571L};
                        const int32_t *l_528 = &l_349.f1;
                        l_518 = p_56;
                        (*l_472) = ((-1L) || func_65(func_67(p_56.f1, l_519)));
                        l_468 = &l_517;
                        /* statement id: 339 */
                        assert (l_468 == &l_517);
                    }
                    else
                    { /* block id: 340 */
                        p_56 = p_56;
                    }
                    /* facts after branching */
                    //assert (l_468 == &l_43 || l_468 == &l_343 || l_468 == &l_517);
                    p_56 = l_516;
                    for (p_56.f0 = 0; (p_56.f0 >= 10); p_56.f0 += 9)
                    { /* block id: 346 */
                        int32_t *l_539 = &l_343;
                        struct S0 *l_540[7][2] = {{&l_463,&l_463},{&l_516,&l_463},{&l_463,&l_516},{&l_463,&l_463},{&l_516,&l_463},{&l_463,&l_516},{&l_463,&l_463}};
                        int32_t **l_541 = &l_468;
                        int i, j;
                        (*l_541) = p_58;
                        /* statement id: 347 */
                        //assert (l_468 == &l_43);
                        if ((*p_58))
                            break;
                        (*l_541) = (void*)0;
                        /* statement id: 349 */
                        assert (l_468 == 0);
                    }
                    /* facts after for loop */
                    //assert (l_468 == 0 || l_468 == &l_43 || l_468 == &l_343 || l_468 == &l_517);
                    return p_56.f2;
                }
            }
        }
        /* facts after for loop */
        //assert (l_468 == &l_43 || l_468 == &l_343);
    }
    else
    { /* block id: 355 */
        const uint32_t l_545 = 0xE5045A56L;
        struct S0 *l_546 = &l_349;
        int32_t ****l_553 = (void*)0;
        for (l_343 = 29; (l_343 != 5); l_343 -= 2)
        { /* block id: 358 */
            int32_t **l_544 = &l_472;
            float l_554 = 0xB.E6F00Ap-98;
            int32_t l_590 = 0x3D85B4F8L;
            (*l_544) = (void*)0;
            /* statement id: 359 */
            assert (l_472 == 0);
            for (p_54 = 0; p_54 < 10; p_54 += 1)
            {
                l_348[p_54] = &l_349;
            }
            if (l_545)
                continue;
            if (func_61(func_61(l_545)))
            { /* block id: 362 */
                int32_t ***l_552 = &l_544;
                int32_t ****l_551 = &l_552;
                uint32_t l_555[8];
                int i;
                for (i = 0; i < 8; i = i + 1)
                    l_555[i] = 9UL;
                (***l_551) = func_73(l_546, (((uint16_t)l_545 % (uint16_t)((int32_t)(func_61(p_56.f3) != ((l_551 != l_553) | (func_65((*l_544)) >= (p_56.f1 ^ p_56.f0)))) + (int32_t)(*p_57))) ^ 0L), l_555[5], (*l_544), l_546);
                if ((p_57 == p_58))
                { /* block id: 364 */
                    return p_54;
                }
                else
                { /* block id: 366 */
                    if ((*p_58))
                        break;
                }
            }
            else
            { /* block id: 369 */
                uint32_t l_556[5];
                float **l_592 = &l_339;
                uint16_t l_601[6][5][4] = {{{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L}},{{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L}},{{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L}},{{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L}},{{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L}},{{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L},{0x96F1L,0x2988L,0x96F1L,0x2988L}}};
                int i, j, k;
                for (i = 0; i < 5; i = i + 1)
                    l_556[i] = 0x338B775EL;
                if ((*p_58))
                { /* block id: 370 */
                    if (l_556[4])
                        break;
                }
                else
                { /* block id: 372 */
                    struct S0 l_561 = {8L,-4L,0x4F3AD3B0L,0x3ED05769L};
                    float **l_600 = &l_339;
                    for (p_54 = (-4); (p_54 <= (-22)); p_54 -= 3)
                    { /* block id: 375 */
                        int32_t *l_559 = (void*)0;
                        int32_t *l_560 = &l_349.f1;
                        (*l_560) = (p_56.f1 != 1L);
                    }
                    if ((*p_58))
                    { /* block id: 378 */
                        p_56 = p_56;
                        (*l_544) = &l_343;
                        /* statement id: 380 */
                        assert (l_472 == &l_343);
                    }
                    else
                    { /* block id: 381 */
                        (*l_546) = l_561;
                        (*l_544) = (void*)0;
                    }
                    /* facts after branching */
                    assert (l_472 == 0 || l_472 == &l_343);
                    for (p_54 = (-14); (p_54 <= (-25)); p_54 -= 1)
                    { /* block id: 387 */
                        int32_t *l_564 = &l_561.f1;
                        (*l_546) = p_56;
                        (*l_564) = (*p_58);
                        return p_56.f2;
                    }
                    if (((uint16_t)(-(int16_t)((int16_t)((6UL <= (((uint16_t)((uint32_t)((uint16_t)((uint16_t)((int16_t)(&l_553 == l_580) + (int16_t)((int16_t)(!l_556[3]) >> (int16_t)4)) >> (uint16_t)12) + (uint16_t)0L) % (uint32_t)(((uint32_t)(p_54 <= __builtin_parity(p_56.f3)) / (uint32_t)((uint16_t)(-(uint16_t)(2L >= l_590)) >> (uint16_t)11)) || 0x62E5729DL)) + (uint16_t)p_56.f0) != 0x541AL)) < l_556[2]) / (int16_t)p_54)) / (uint16_t)p_56.f1))
                    { /* block id: 392 */
                        float **l_591 = &l_339;
                        int8_t l_595 = 9L;
                        int32_t **l_602 = &l_472;
                        l_601[5][0][3] = ((l_591 != l_592) < (((uint16_t)l_595 % (uint16_t)((((uint16_t)((uint16_t)__builtin_ctzll(p_56.f3) / (uint16_t)p_54) % (uint16_t)p_56.f2) <= l_595) && (&l_339 == l_600))) | (*p_57)));
                        if ((*p_58))
                            break;
                        if (l_545)
                            break;
                        (*l_602) = p_58;
                        /* statement id: 396 */
                        //assert (l_472 == &l_43);
                    }
                    else
                    { /* block id: 397 */
                        int32_t **l_603 = &l_472;
                        if (l_561.f1)
                            break;
                        (*l_603) = p_58;
                        /* statement id: 399 */
                        //assert (l_472 == &l_43);
                        if ((**l_544))
                            continue;
                    }
                    /* facts after branching */
                    //assert (l_472 == &l_43);
                }
                /* facts after branching */
                //assert (l_472 == &l_43 || l_472 == 0);
            }
            /* facts after branching */
            //assert (l_472 == &l_43 || l_472 == 0);
        }
        /* facts after for loop */
        //assert (l_472 == 0 || l_472 == &l_343 || l_472 == &l_43 || l_472 == &l_349.f1);
    }
    /* facts after branching */
    //assert (l_472 == 0 || l_472 == &l_343 || l_472 == &l_43 || l_472 == &l_349.f1);
    (*l_605) = p_57;
    /* statement id: 406 */
    //assert (l_472 == &l_43);
    for (p_56.f1 = 0; (p_56.f1 <= 9); p_56.f1 += 1)
    { /* block id: 409 */
        int16_t l_606 = 4L;
        struct S0 l_607 = {0x46319EE9L,0x9D2DF288L,-2L,0x99ABF35AL};
        int32_t * const *l_612 = &l_472;
        int32_t * const **l_611 = &l_612;
        int32_t * const ***l_610[1];
        int i;
        for (i = 0; i < 1; i = i + 1)
            l_610[i] = &l_611;
        for (p_54 = 0; (p_54 <= 9); p_54 += 1)
        { /* block id: 412 */
            (*l_605) = func_67(l_606, p_56.f0);
            /* statement id: 413 */
            assert (l_472 == 0);
            l_607 = p_56;
        }
        for (l_508 = 0; (l_508 <= 9); l_508 += 1)
        { /* block id: 418 */
            int32_t **l_608 = &l_472;
            int32_t l_621 = 0x08E751DBL;
            int i;
            (*l_608) = p_58;
            /* statement id: 419 */
            //assert (l_472 == &l_43);
            for (p_54 = 0; (p_54 <= 9); p_54 += 1)
            { /* block id: 422 */
                int32_t ***l_609[8] = {&l_604[5][0],&l_604[5][0],&l_604[5][0],&l_604[5][0],&l_604[5][0],&l_604[5][0],&l_604[5][0],&l_604[5][0]};
                int i;
                (*l_339) = ((void*)0 != l_609[1]);
                (*l_608) = (void*)0;
                /* statement id: 424 */
                assert (l_472 == 0);
                if ((l_610[0] == &l_609[7]))
                { /* block id: 425 */
                    uint32_t l_617 = 0x96E26521L;
                    for (l_607.f0 = 1; (l_607.f0 >= 0); l_607.f0 -= 1)
                    { /* block id: 428 */
                        int32_t **l_613[7] = {&l_472,&l_472,&l_472,&l_472,&l_472,&l_472,&l_472};
                        int32_t **l_614 = (void*)0;
                        int32_t **l_615 = (void*)0;
                        int32_t **l_616 = &l_472;
                        int i, j;
                        (*l_616) = p_57;
                        /* statement id: 429 */
                        //assert (l_472 == &l_43);
                        return l_617;
                    }
                    if ((*p_57))
                        continue;
                }
                else
                { /* block id: 433 */
                    struct S0 l_618 = {0x6DFDF2AAL,1L,2L,5UL};
                    for (l_349.f3 = 0; (l_349.f3 <= 1); l_349.f3 += 1)
                    { /* block id: 436 */
                        int i, j;
                        (*l_608) = (*l_605);
                        l_618 = p_56;
                    }
                }
            }
            /* facts after for loop */
            //assert (l_472 == 0 || l_472 == &l_43);
            (*l_339) = (((void*)0 == p_57) != ((p_56.f0 < ((0x7.5p+1 <= ((float)l_621 + (float)p_56.f1)) == 0x7.8p-1)) >= (-(float)p_56.f0)));
        }
    }
    /* facts after for loop */
    //assert (l_472 == 0 || l_472 == &l_43);
    return l_623;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_61(const uint16_t  p_62)
{ /* block id: 77 */
    int32_t l_153 = 1L;
    int32_t *l_161 = &l_153;
    int32_t **l_160 = &l_161;
    struct S0 l_166 = {-5L,-1L,0x216C10DFL,2UL};
    struct S0 *l_165 = &l_166;
    float l_193 = (-0x1.9p+1);
    float *l_192 = &l_193;
    float **l_191 = &l_192;
    int32_t ****l_203 = (void*)0;
    struct S0 l_268 = {0L,-1L,5L,0x482713B8L};
    float l_291 = 0x9.FC6CF0p+51;
    for (l_153 = (-5); (l_153 > 20); l_153 += 1)
    { /* block id: 80 */
        int8_t l_162 = (-7L);
        struct S0 *l_167 = &l_166;
        if (__builtin_parityll(((uint32_t)((uint16_t)((l_160 != &l_161) == (l_162 < l_162)) << (uint16_t)((int16_t)(l_165 == l_167) - (int16_t)((((uint16_t)(1UL & __builtin_clz(__builtin_popcount(l_162))) - (uint16_t)(*l_161)) >= p_62) && 0xB3132CC5L))) / (uint32_t)l_162)))
        { /* block id: 81 */
            return p_62;
        }
        else
        { /* block id: 83 */
            return l_162;
        }
    }
    for (l_166.f2 = 0; (l_166.f2 <= (-14)); l_166.f2 -= 1)
    { /* block id: 89 */
        uint32_t l_172[9] = {1UL,0xCD07EA0FL,1UL,1UL,0xCD07EA0FL,1UL,1UL,0xCD07EA0FL,1UL};
        struct S0 l_200 = {-10L,0xB070FD17L,0xD34EA4AFL,18446744073709551615UL};
        struct S0 **l_221 = &l_165;
        const int32_t *l_289[9] = {&l_200.f0,&l_268.f0,&l_200.f0,&l_268.f0,&l_200.f0,&l_268.f0,&l_200.f0,&l_268.f0,&l_200.f0};
        const int32_t **l_288 = &l_289[5];
        const int32_t ***l_287 = &l_288;
        const int32_t ****l_286 = &l_287;
        uint32_t l_290[8][10][1] = {{{0x2D1A5683L},{0xA5ECB414L},{0x384A77F9L},{0UL},{0xEE389250L},{0xA4460E21L},{0UL},{0UL},{0xFDCC1E68L},{0x2D1A5683L}},{{0xFDCC1E68L},{0UL},{0UL},{0xA4460E21L},{0xEE389250L},{0UL},{0x384A77F9L},{0xA5ECB414L},{0x2D1A5683L},{0xF496A8B9L}},{{18446744073709551615UL},{0UL},{0x4743BEBDL},{0x4743BEBDL},{0UL},{18446744073709551615UL},{0xF496A8B9L},{0x2D1A5683L},{0xA5ECB414L},{0x384A77F9L}},{{0UL},{0xEE389250L},{0xA4460E21L},{0UL},{0UL},{0xFDCC1E68L},{0x2D1A5683L},{0xFDCC1E68L},{0UL},{0UL}},{{0xA4460E21L},{0xEE389250L},{0UL},{0x384A77F9L},{0xA5ECB414L},{0x2D1A5683L},{0xF496A8B9L},{18446744073709551615UL},{0UL},{0x4743BEBDL}},{{0x4743BEBDL},{0UL},{18446744073709551615UL},{0xF496A8B9L},{0x2D1A5683L},{0xA5ECB414L},{0x384A77F9L},{0UL},{0xEE389250L},{0xA4460E21L}},{{0UL},{0UL},{0xFDCC1E68L},{0x2D1A5683L},{0xFDCC1E68L},{0UL},{0UL},{0xA4460E21L},{0xEE389250L},{0UL}},{{0x384A77F9L},{0xA5ECB414L},{0x2D1A5683L},{0xF496A8B9L},{18446744073709551615UL},{0UL},{0x4743BEBDL},{0x4743BEBDL},{0UL},{18446744073709551615UL}}};
        int8_t l_323[1];
        int i, j, k;
        for (i = 0; i < 1; i = i + 1)
            l_323[i] = 0x31L;
    }
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_65(int32_t * p_66)
{ /* block id: 68 */
    struct S0 l_136 = {0x75CF2B21L,8L,0x557642EFL,18446744073709551615UL};
    struct S0 *l_135 = &l_136;
    int32_t ** const *l_137 = (void*)0;
    const int32_t *l_141 = &l_136.f0;
    int32_t **l_142 = (void*)0;
    int32_t *l_144 = &l_136.f1;
    int32_t **l_143 = &l_144;
    uint16_t l_152 = 65528UL;
    p_66 = func_73(l_135, l_136.f0, (((void*)0 == l_137) < (((float)(((void*)0 != &p_66) > (!l_136.f1)) - (float)l_136.f2) <= l_136.f2)), l_141, &l_136);
    /* statement id: 69 */
    assert (p_66 == 0);
    (*l_143) = func_67((*l_141), (0x109FL <= __builtin_clzl(((0xF5C477D8L <= 0L) & (*l_141)))));
    /* statement id: 70 */
    assert (l_144 == 0);
    if (__builtin_ffsl((&l_136 != (void*)0)))
    { /* block id: 71 */
        uint16_t l_148 = 0xBE6AL;
        int32_t *l_149 = &l_136.f1;
        (*l_149) = ((int16_t)((*l_141) < (-(int32_t)l_148)) - (int16_t)l_148);
    }
    else
    { /* block id: 73 */
        float l_150 = 0x3.Dp-1;
        int32_t l_151 = (-1L);
        return l_151;
    }
    return l_152;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_67(uint32_t  p_68, int32_t  p_69)
{ /* block id: 37 */
    int32_t l_84 = 0L;
    int32_t * const l_83 = &l_84;
    struct S0 l_86[9][6][4] = {{{{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL},{-1L,1L,-8L,8UL}},{{-4L,1L,0x706E1857L,18446744073709551615UL},{0L,0x4278D6BFL,0x67550B10L,1UL},{0L,0x4278D6BFL,0x67550B10L,1UL},{-4L,1L,0x706E1857L,18446744073709551615UL}},{{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{5L,0x2F62330FL,-8L,0xF5ABE080L}},{{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{5L,0x2F62330FL,-8L,0xF5ABE080L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL}},{{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{5L,0x2F62330FL,-8L,0xF5ABE080L},{-1L,1L,-8L,8UL},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL}},{{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{1L,1L,1L,0x1F91351DL},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{1L,1L,1L,0x1F91351DL}}},{{{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL},{-4L,1L,0x706E1857L,18446744073709551615UL},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x1D621011L,4L,0x06DF3F18L,0UL}},{{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{9L,-8L,0x56C84D1BL,0x3B75CAB9L}},{{5L,0x2F62330FL,-8L,0xF5ABE080L},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL},{9L,-8L,0x56C84D1BL,0x3B75CAB9L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L}},{{5L,0x2F62330FL,-8L,0xF5ABE080L},{0L,0x4278D6BFL,0x67550B10L,1UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL}},{{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL}},{{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{-4L,1L,0x706E1857L,18446744073709551615UL}}},{{{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{-1L,1L,-8L,8UL},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL}},{{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{-4L,1L,0x706E1857L,18446744073709551615UL}},{{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL}},{{0L,0x4278D6BFL,0x67550B10L,1UL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL}},{{0x1D621011L,4L,0x06DF3F18L,0UL},{0L,0x4278D6BFL,0x67550B10L,1UL},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L}},{{-4L,1L,0x706E1857L,18446744073709551615UL},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL},{9L,-8L,0x56C84D1BL,0x3B75CAB9L}}},{{{0x1D621011L,4L,0x06DF3F18L,0UL},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x1D621011L,4L,0x06DF3F18L,0UL}},{{0L,0x4278D6BFL,0x67550B10L,1UL},{-4L,1L,0x706E1857L,18446744073709551615UL},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{1L,1L,1L,0x1F91351DL}},{{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{1L,1L,1L,0x1F91351DL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL}},{{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{5L,0x2F62330FL,-8L,0xF5ABE080L},{-1L,1L,-8L,8UL},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL}},{{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{1L,1L,1L,0x1F91351DL},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{1L,1L,1L,0x1F91351DL}},{{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL},{-4L,1L,0x706E1857L,18446744073709551615UL},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x1D621011L,4L,0x06DF3F18L,0UL}}},{{{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{9L,-8L,0x56C84D1BL,0x3B75CAB9L}},{{5L,0x2F62330FL,-8L,0xF5ABE080L},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL},{9L,-8L,0x56C84D1BL,0x3B75CAB9L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L}},{{5L,0x2F62330FL,-8L,0xF5ABE080L},{0L,0x4278D6BFL,0x67550B10L,1UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL}},{{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL}},{{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{-4L,1L,0x706E1857L,18446744073709551615UL}},{{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{-1L,1L,-8L,8UL},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL}}},{{{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{-4L,1L,0x706E1857L,18446744073709551615UL}},{{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL}},{{0L,0x4278D6BFL,0x67550B10L,1UL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL}},{{0x1D621011L,4L,0x06DF3F18L,0UL},{0L,0x4278D6BFL,0x67550B10L,1UL},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L}},{{-4L,1L,0x706E1857L,18446744073709551615UL},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL},{9L,-8L,0x56C84D1BL,0x3B75CAB9L}},{{0x1D621011L,4L,0x06DF3F18L,0UL},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x1D621011L,4L,0x06DF3F18L,0UL}}},{{{0L,0x4278D6BFL,0x67550B10L,1UL},{-4L,1L,0x706E1857L,18446744073709551615UL},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{1L,1L,1L,0x1F91351DL}},{{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{1L,1L,1L,0x1F91351DL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL}},{{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{5L,0x2F62330FL,-8L,0xF5ABE080L},{-1L,1L,-8L,8UL},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL}},{{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{1L,1L,1L,0x1F91351DL},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{1L,1L,1L,0x1F91351DL}},{{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL},{-4L,1L,0x706E1857L,18446744073709551615UL},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x1D621011L,4L,0x06DF3F18L,0UL}},{{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{9L,-8L,0x56C84D1BL,0x3B75CAB9L}}},{{{5L,0x2F62330FL,-8L,0xF5ABE080L},{0x30E9DD37L,0x37C2AE6BL,0x1441E233L,18446744073709551612UL},{9L,-8L,0x56C84D1BL,0x3B75CAB9L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L}},{{5L,0x2F62330FL,-8L,0xF5ABE080L},{0L,0x4278D6BFL,0x67550B10L,1UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL}},{{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL}},{{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{-4L,1L,0x706E1857L,18446744073709551615UL}},{{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{-1L,1L,-8L,8UL},{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL}},{{0x0EF148A9L,0L,0x3634C778L,18446744073709551615UL},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{-4L,1L,0x706E1857L,18446744073709551615UL}}},{{{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{-9L,0x9ABC0A08L,-1L,0x3B2FE496L},{0xAB82AEC7L,0x5175D1B3L,8L,0x9D3B05E2L},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL}},{{0L,0x4278D6BFL,0x67550B10L,1UL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L},{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL}},{{0x1D621011L,4L,0x06DF3F18L,0UL},{0L,0x4278D6BFL,0x67550B10L,1UL},{0x10944B0CL,0xC93CBC91L,-9L,18446744073709551613UL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L}},{{-4L,1L,0x706E1857L,18446744073709551615UL},{5L,0x2F62330FL,-8L,0xF5ABE080L},{0L,0x4278D6BFL,0x67550B10L,1UL},{0x8E54706CL,0x8FDA5E0CL,0x2F289490L,18446744073709551615UL}},{{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL},{-1L,1L,-8L,8UL},{-1L,1L,-8L,8UL},{0x97010273L,0x94210AB9L,0xA2468F5BL,1UL}},{{0x674DCCE6L,1L,-1L,18446744073709551609UL},{0x1D621011L,4L,0x06DF3F18L,0UL},{0xB3486B68L,0x461D90BCL,-1L,0UL},{0x221F4251L,0x17401D8BL,8L,0xC6149AF4L}}}};
    struct S0 *l_85 = &l_86[5][4][3];
    struct S0 **l_128[9][8][3] = {{{&l_85,&l_85,(void*)0},{&l_85,&l_85,&l_85},{(void*)0,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85},{&l_85,&l_85,&l_85}},{{&l_85,&l_85,&l_85},{(void*)0,&l_85,(void*)0},{(void*)0,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85}},{{&l_85,&l_85,&l_85},{&l_85,&l_85,(void*)0},{&l_85,&l_85,&l_85},{&l_85,&l_85,(void*)0},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85},{&l_85,&l_85,(void*)0},{&l_85,&l_85,&l_85}},{{(void*)0,&l_85,&l_85},{(void*)0,(void*)0,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85}},{{(void*)0,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,(void*)0},{(void*)0,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,(void*)0},{&l_85,&l_85,&l_85},{(void*)0,&l_85,(void*)0}},{{&l_85,(void*)0,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85},{(void*)0,&l_85,(void*)0}},{{&l_85,&l_85,&l_85},{(void*)0,(void*)0,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85},{&l_85,&l_85,&l_85},{(void*)0,(void*)0,&l_85}},{{&l_85,&l_85,(void*)0},{(void*)0,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,(void*)0},{(void*)0,(void*)0,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,(void*)0,&l_85}},{{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,(void*)0},{(void*)0,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85},{&l_85,&l_85,&l_85}}};
    struct S0 *l_129 = &l_86[5][3][2];
    int32_t *l_132 = &l_86[5][4][3].f1;
    int32_t **l_131 = &l_132;
    int32_t ***l_130 = &l_131;
    int32_t *l_133 = &l_86[5][4][3].f0;
    int32_t *l_134 = (void*)0;
    int i, j, k;
    l_129 = func_70(func_73(func_79(l_83, &l_84, l_85), p_68, (*l_83), &l_84, &l_86[5][4][3]), &l_84);
    /* statement id: 65 */
    assert (l_129 == 0);
    (*l_130) = &l_83;
    /* statement id: 66 */
    assert (l_131 == &l_83);
    return l_134;
    /* statement id: 67 */
    //assert (func_67_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_70(int32_t * p_71, int32_t * p_72)
{ /* block id: 45 */
    struct S0 l_100 = {0L,-1L,0xBA385945L,0x360C0ABBL};
    struct S0 *l_99 = &l_100;
    struct S0 **l_98 = &l_99;
    const int32_t *l_109[2][10] = {{&l_100.f1,&l_100.f0,&l_100.f0,&l_100.f1,&l_100.f1,&l_100.f1,&l_100.f1,&l_100.f0,&l_100.f0,&l_100.f1},{&l_100.f0,&l_100.f0,&l_100.f0,&l_100.f1,&l_100.f0,&l_100.f1,&l_100.f0,&l_100.f0,&l_100.f0,&l_100.f0}};
    struct S0 *l_117 = &l_100;
    struct S0 *l_118 = &l_100;
    struct S0 *l_119[6];
    struct S0 *l_120[6][8] = {{&l_100,&l_100,(void*)0,&l_100,&l_100,(void*)0,&l_100,&l_100},{&l_100,&l_100,&l_100,&l_100,&l_100,&l_100,&l_100,&l_100},{&l_100,&l_100,&l_100,&l_100,&l_100,&l_100,&l_100,&l_100},{&l_100,&l_100,(void*)0,&l_100,&l_100,(void*)0,&l_100,&l_100},{&l_100,&l_100,&l_100,&l_100,&l_100,&l_100,&l_100,&l_100},{&l_100,&l_100,&l_100,&l_100,&l_100,&l_100,&l_100,&l_100}};
    struct S0 *l_121 = &l_100;
    struct S0 *l_122 = &l_100;
    struct S0 *l_123 = &l_100;
    struct S0 *l_124 = &l_100;
    struct S0 *l_125 = &l_100;
    struct S0 *l_126 = &l_100;
    struct S0 *l_127 = (void*)0;
    int i, j;
    for (i = 0; i < 6; i = i + 1)
        l_119[i] = &l_100;
    l_98 = l_98;
    if ((&l_99 == &l_99))
    { /* block id: 47 */
        int32_t *l_102 = &l_100.f1;
        int32_t **l_101[7] = {&l_102,&l_102,&l_102,&l_102,&l_102,&l_102,&l_102};
        int i;
        p_72 = (void*)0;
        /* statement id: 48 */
        assert (p_72 == 0);
        (*l_99) = (*l_99);
        for (l_100.f0 = 10; (l_100.f0 == 13); l_100.f0 += 6)
        { /* block id: 52 */
            if (l_100.f0)
                break;
        }
    }
    else
    { /* block id: 55 */
        struct S0 l_105 = {0xF6EB6F9EL,0x93F4BB62L,1L,0x0E86605BL};
        int32_t *l_111 = &l_100.f1;
        int32_t **l_110 = &l_111;
        float l_116 = (-0x1.Ap-1);
        float *l_115 = &l_116;
        (*l_99) = l_105;
        if ((*p_72))
        { /* block id: 57 */
            (*l_99) = l_105;
        }
        else
        { /* block id: 59 */
            struct S0 *l_106[2];
            const int32_t *l_114[7] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
            int i;
            for (i = 0; i < 2; i = i + 1)
                l_106[i] = &l_105;
            (*l_110) = func_73(l_106[0], ((-6L) > 0UL), ((0x0.4p+1 != ((float)(l_109[1][0] == p_72) / (float)(l_110 != &l_109[1][0]))) > ((float)(p_71 == (*l_110)) + (float)0x2.0EAEF0p+19)), l_114[1], (*l_98));
            /* statement id: 60 */
            assert (l_111 == 0);
        }
        /* facts after branching */
        assert (l_111 == 0 || l_111 == &l_100.f1);
        (*l_115) = 0xA.CE5CF1p-80;
    }
    /* facts after branching */
    //assert (p_72 == &l_84 || p_72 == 0 || p_72 == &l_343 || p_72 == &l_625);
    return l_127;
    /* statement id: 64 */
    //assert (func_70_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_73(struct S0 * p_74, uint16_t  p_75, float  p_76, const int32_t * p_77, struct S0 * p_78)
{ /* block id: 40 */
    struct S0 l_88 = {0L,1L,1L,0x0407C532L};
    int32_t **l_89 = (void*)0;
    int32_t *l_91 = &l_88.f1;
    int32_t **l_90 = &l_91;
    int32_t *l_92 = &l_88.f1;
    int32_t *l_93 = &l_88.f1;
    int32_t *l_94 = &l_88.f1;
    int32_t *l_95 = &l_88.f0;
    int32_t *l_96 = &l_88.f1;
    int32_t *l_97 = (void*)0;
    (*p_78) = l_88;
    (*l_90) = p_77;
    /* statement id: 42 */
    //assert (l_91 == &l_84 || l_91 == 0 || l_91 == &l_105.f0 || l_91 == &l_136.f0 || (l_91 >= &l_189[0] && l_91 <= &l_189[9]) || l_91 == &l_200.f0 || l_91 == &l_166.f1 || l_91 == &l_268.f0 || (l_91 >= &l_267[0].f1 && l_91 <= &l_267[8].f1) || (l_91 >= &l_672[0][0] && l_91 <= &l_672[6][2]) || l_91 == &l_691 || l_91 == &l_732.f1);
    (*p_78) = l_88;
    return l_97;
    /* statement id: 44 */
    //assert (func_73_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_79(int32_t * const  p_80, int32_t * p_81, struct S0 * p_82)
{ /* block id: 38 */
    struct S0 *l_87 = (void*)0;
    return l_87;
    /* statement id: 39 */
    //assert (func_79_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 231
   depth: 1, occurrence: 30
XXX total union variables: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 286
   depth: 2, occurrence: 64
   depth: 3, occurrence: 10
   depth: 4, occurrence: 7
   depth: 5, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 3
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 276

XXX times a variable address is taken: 521
XXX times a pointer is dereferenced on RHS: 92
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 105
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 5
   depth: 3, occurrence: 5
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 1188

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 503
   level: 2, occurrence: 64
   level: 3, occurrence: 13
   level: 4, occurrence: 9
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 127
XXX number of pointers point to scalars: 93
XXX number of pointers point to structs: 56
XXX percent of pointers has null in alias set: 36.6
XXX average alias set size: 1.49

XXX times a non-volatile is read: 834
XXX times a non-volatile is write: 362
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 262
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 21
   depth: 2, occurrence: 28
   depth: 3, occurrence: 40
   depth: 4, occurrence: 63
   depth: 5, occurrence: 75

XXX percentage a fresh-made variable is used: 18.7
XXX percentage an existing variable is used: 81.3
********************* end of statistics **********************/

