/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      2953696168
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int32_t  f1;
   uint32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
inline static int32_t  func_7(uint16_t  p_8, struct S0  p_9, uint8_t  p_10, uint32_t  p_11, uint32_t  p_12);
static struct S0  func_15(uint8_t  p_16);
static uint8_t  func_17(int32_t  p_18, uint16_t  p_19, uint8_t  p_20);
static int32_t * func_22(uint32_t  p_23, int32_t * p_24);
static int32_t  func_27(int16_t  p_28, uint16_t  p_29);
static int32_t ** func_37(int32_t ** p_38, uint8_t  p_39, int32_t ** p_40, int32_t * p_41);
static int32_t * func_45(int16_t  p_46, uint16_t  p_47, const uint8_t  p_48, int32_t * p_49, int32_t * p_50);
inline static const int32_t * func_61(float  p_62, int32_t * p_63);
inline static int32_t * func_65(uint32_t  p_66);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = (-8);
    uint32_t l_21 = 0x1E2DB80E;
    int32_t *l_495 = (void*)0;
    int32_t **l_494 = &l_495;
    int32_t ***l_493 = &l_494;
    struct S0 l_505 = {0x8341387C,0x710B6FDA,1U};
    struct S0 *l_504 = &l_505;
    int32_t ****l_538 = (void*)0;
    int32_t *****l_537 = &l_538;
    uint32_t l_566 = 4294967295U;
    float l_569 = 0x6.Dp+1;
    float *l_568 = &l_569;
    int32_t *l_625 = &l_505.f0;
    const int32_t l_638 = 0x02968CAF;
    int32_t *l_639 = &l_505.f0;
    const int32_t l_676 = 0xE20BC243;
    uint32_t l_677 = 0x59106904;
    int32_t l_692 = 0x8366D133;
    int32_t *l_695 = &l_692;
    uint32_t l_696 = 1U;
    for (l_2 = 0; (l_2 > 16); l_2 += 1)
    { /* block id: 3 */
        int16_t l_5 = 0x21F1;
        float l_6 = 0x0.6p+1;
        uint16_t l_449 = 0U;
        int32_t *l_474 = &l_2;
        struct S0 l_508 = {0x86CC4AD7,6,4294967295U};
        const struct S0 **l_518 = (void*)0;
        const uint32_t l_544 = 4294967291U;
        int32_t ****l_567 = (void*)0;
        uint32_t l_574 = 8U;
        int32_t ****l_623 = &l_493;
        uint16_t l_624 = 7U;
    }
    (*l_504) = (*l_504);
    return l_696;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_7(uint16_t  p_8, struct S0  p_9, uint8_t  p_10, uint32_t  p_11, uint32_t  p_12)
{ /* block id: 189 */
    float *l_450 = (void*)0;
    float l_452 = 0x1.Dp+1;
    float *l_451 = &l_452;
    int32_t ***l_456 = (void*)0;
    int32_t ****l_455 = &l_456;
    (*l_451) = p_12;
    p_9.f0 = ((int16_t)(l_455 == (void*)0) >> (int16_t)15);
    return p_10;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_15(uint8_t  p_16)
{ /* block id: 181 */
    int32_t *l_420 = (void*)0;
    int32_t **l_419 = &l_420;
    int32_t ***l_418 = &l_419;
    int32_t l_423 = 0x2DE9F1D2;
    uint16_t l_435 = 65530U;
    int32_t l_438 = 0x0F7E0179;
    int16_t l_439 = (-1);
    struct S0 l_442 = {-8,0x2725B358,0x15A19D07};
    struct S0 *l_441 = &l_442;
    struct S0 **l_440 = &l_441;
    struct S0 l_448 = {0xCBC0E3DA,-5,0x4716CAD3};
    if ((p_16 <= (((uint16_t)(((uint16_t)((int16_t)((uint16_t)((void*)0 != l_418) % (uint16_t)(0x6EB2 | (((int32_t)l_423 % (int32_t)((((int16_t)((((((int16_t)((((uint32_t)((uint16_t)0xE6CE * (uint16_t)(((((uint16_t)(+(l_435 <= ((int16_t)p_16 % (int16_t)p_16))) - (uint16_t)p_16) >= p_16) | p_16) & l_438)) + (uint32_t)p_16) ^ p_16) <= p_16) << (int16_t)p_16) | l_439) || p_16) < p_16) && p_16) - (int16_t)p_16) ^ 0U) && p_16)) && (-1)))) << (int16_t)p_16) >> (uint16_t)9) && 1) * (uint16_t)p_16) && 0U)))
    { /* block id: 182 */
        uint8_t l_443 = 0x71;
        l_443 = ((void*)0 != l_440);
    }
    else
    { /* block id: 184 */
        struct S0 *l_444 = &l_442;
        int32_t l_447 = (-9);
        (*l_440) = l_444;
        l_447 = (((uint16_t)p_16 >> (uint16_t)p_16) && p_16);
    }
    return l_448;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_17(int32_t  p_18, uint16_t  p_19, uint8_t  p_20)
{ /* block id: 4 */
    int32_t l_26 = 0x80335900;
    int32_t *l_25 = &l_26;
    float l_30 = 0x2.B0A117p-34;
    int32_t **l_333 = &l_25;
    int32_t ***l_373 = &l_333;
    int32_t ****l_372 = &l_373;
    int32_t *****l_371 = &l_372;
    int32_t l_399 = 0x6952F921;
    struct S0 l_405 = {0x8994FFB7,0xE2BC12E7,0xCDC07732};
    struct S0 *l_404 = &l_405;
    uint8_t l_409 = 0xC1;
    (*l_333) = func_22((((l_25 != &l_26) != (*l_25)) && (p_19 && func_27(p_18, (((0U == ((int16_t)((uint32_t)((&l_26 != &l_26) == 0x9F3C5A4A) + (uint32_t)(*l_25)) % (int16_t)p_20)) <= (*l_25)) != (*l_25))))), &l_26);
    /* statement id: 151 */
    assert (l_25 == 0);
    (*l_333) = (*l_333);
    if (((uint16_t)(&l_333 == (void*)0) << (uint16_t)l_26))
    { /* block id: 153 */
        int32_t ***l_351 = &l_333;
        int32_t ****l_350 = &l_351;
        int32_t *****l_349 = &l_350;
        struct S0 l_369 = {0xE55B3C0C,0x357922EA,0xCE5B989A};
        struct S0 *l_370 = &l_369;
        uint32_t l_387 = 0U;
        if ((!(7U < (((int32_t)((int32_t)p_19 - (int32_t)4294967295U) % (int32_t)p_18) >= p_19))))
        { /* block id: 154 */
            (*l_333) = (void*)0;
        }
        else
        { /* block id: 156 */
            const uint8_t l_343 = 255U;
            struct S0 l_364 = {0xF341124B,0x1A8EAB97,0x31A8F85E};
            struct S0 *l_363 = &l_364;
            int32_t *l_368 = (void*)0;
            for (p_18 = 0; (p_18 <= (-24)); p_18 -= 8)
            { /* block id: 159 */
                int32_t ***l_348 = &l_333;
                int32_t ****l_347 = &l_348;
                int32_t *****l_346 = &l_347;
                int32_t l_352 = 7;
                l_352 = (l_343 >= ((uint16_t)p_20 + (uint16_t)(l_346 != l_349)));
                (****l_346) = (void*)0;
                for (p_20 = 0; (p_20 >= 53); p_20 += 2)
                { /* block id: 164 */
                    (**l_351) = (*l_333);
                }
            }
            l_26 = (((int16_t)((int16_t)((int16_t)9 >> (int16_t)((uint16_t)((((l_363 != (void*)0) == l_364.f1) | (-(uint16_t)p_19)) && (((((uint16_t)0U << (uint16_t)(p_18 ^ ((p_18 < 0x536371DD) && p_20))) || p_18) > p_18) || 0x350790CD)) >> (uint16_t)14)) * (int16_t)p_18) + (int16_t)p_19) || 0x05CB);
            (***l_350) = (****l_349);
            (****l_349) = l_368;
        }
        (*l_370) = l_369;
        l_371 = l_371;
        l_26 = ((int32_t)p_19 % (int32_t)(p_20 && (~(((int16_t)((uint32_t)p_19 + (uint32_t)((((int32_t)p_20 % (int32_t)p_18) < ((uint32_t)p_18 % (uint32_t)(((p_18 && (((uint16_t)p_19 << (uint16_t)11) == (p_19 > p_18))) >= p_20) || p_19))) > l_387)) - (int16_t)p_20) || p_20))));
    }
    else
    { /* block id: 175 */
        uint32_t l_394 = 0U;
        int32_t *l_403 = &l_399;
        int32_t *****l_406 = &l_372;
        int32_t *l_408 = &l_405.f0;
        (*l_403) = ((int32_t)((int32_t)((int16_t)(l_394 >= ((int16_t)((((*l_333) != (void*)0) >= ((uint16_t)l_399 >> (uint16_t)1)) | ((+p_20) | p_19)) << (int16_t)((uint32_t)p_19 + (uint32_t)(((*l_371) == (*l_371)) & p_19)))) - (int16_t)0x5F11) + (int32_t)0x68D6C9D1) + (int32_t)p_18);
        (****l_371) = (**l_373);
    }
    l_26 = p_20;
    return l_409;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_22(uint32_t  p_23, int32_t * p_24)
{ /* block id: 7 */
    int32_t *l_43 = (void*)0;
    int32_t **l_42 = &l_43;
    uint32_t l_57 = 0U;
    int32_t l_326 = 0xECD05820;
    int32_t l_327 = 5;
    int32_t **l_328 = &l_43;
    const int32_t *l_331 = &l_327;
    const int32_t **l_330 = &l_331;
    const int32_t ***l_329 = &l_330;
    int32_t *l_332 = (void*)0;
    for (p_23 = 0; (p_23 != 27); p_23 += 9)
    { /* block id: 10 */
        uint16_t l_44 = 0xB296;
        const uint32_t l_58 = 4294967292U;
        int32_t l_60 = 0xAC80EABF;
        int32_t *l_59 = &l_60;
        int32_t ***l_325 = &l_42;
    }
    (*l_42) = (void*)0;
    l_327 = (((p_23 < p_23) != l_326) < p_23);
    (*l_329) = func_37(&p_24, p_23, &l_43, (*l_328));
    /* statement id: 149 */
    //assert (p_24 == dangling);
    assert (l_330 == 0);
    return l_332;
    /* statement id: 150 */
    //assert (func_22_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_27(int16_t  p_28, uint16_t  p_29)
{ /* block id: 5 */
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_37(int32_t ** p_38, uint8_t  p_39, int32_t ** p_40, int32_t * p_41)
{ /* block id: 132 */
    struct S0 l_313 = {7,0x3C657A09,0x846929B3};
    int32_t *l_318 = &l_313.f0;
    int32_t *l_321 = &l_313.f0;
    int32_t **l_322 = &l_321;
    int32_t **l_323 = &l_321;
    int32_t **l_324 = (void*)0;
    for (p_39 = 0; (p_39 <= 26); p_39 += 6)
    { /* block id: 135 */
        struct S0 *l_314 = &l_313;
        int32_t *l_315 = (void*)0;
        int32_t *l_316 = (void*)0;
        int32_t *l_317 = &l_313.f0;
        (*l_314) = l_313;
        (*l_317) = (&l_314 == (void*)0);
        (*p_40) = func_65((*l_317));
        l_318 = (*p_40);
        /* statement id: 139 */
        assert (l_318 == 0);
    }
    /* facts after for loop */
    assert (l_318 == 0 || l_318 == &l_313.f0);
    (*p_38) = l_321;
    /* statement id: 141 */
    //assert (l_43 == &l_313.f0 || l_43 == 0);
    l_318 = (*p_38);
    /* statement id: 142 */
    assert (l_318 == &l_313.f0);
    return l_324;
    /* statement id: 143 */
    //assert (l_43 == dangling || l_43 == 0);
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_45(int16_t  p_46, uint16_t  p_47, const uint8_t  p_48, int32_t * p_49, int32_t * p_50)
{ /* block id: 11 */
    int32_t l_64 = 0xC0AC77AC;
    const int32_t l_303 = 0x3C535091;
    const int32_t *l_302 = &l_303;
    int32_t l_306 = 0xF1519C01;
    int32_t *l_305 = &l_306;
    int32_t **l_304 = &l_305;
    struct S0 l_308 = {1,0,0x6D4DFEEE};
    struct S0 *l_307 = &l_308;
    const struct S0 *l_310 = &l_308;
    const struct S0 **l_309 = &l_310;
    l_302 = func_61(l_64, p_49);
    /* statement id: 128 */
    //assert (l_302 == &l_60 || l_302 == &l_505.f0 || l_302 == &l_486);
    (*l_304) = p_49;
    /* statement id: 129 */
    //assert (l_305 == &l_60 || l_305 == &l_505.f0 || l_305 == &l_486);
    (*l_309) = l_307;
    return p_50;
    /* statement id: 131 */
    //assert (func_45_rv == 0 || func_45_rv == &l_509.f0 || func_45_rv == &l_2);
}


/* ------------------------------------------ */
/* 
 * reads : l_60 l_505.f0 l_486
 * writes: l_60 l_505.f0 l_486
 */
inline static const int32_t * func_61(float  p_62, int32_t * p_63)
{ /* block id: 12 */
    int32_t l_69 = 0x5BBD97C2;
    int32_t *l_77 = &l_69;
    int32_t **l_76 = &l_77;
    int32_t **l_102 = &l_77;
    uint8_t l_105 = 1U;
    int32_t *l_136 = (void*)0;
    struct S0 l_200 = {-4,0x1C82E662,4294967293U};
    int32_t *l_206 = &l_69;
    uint16_t l_278 = 0x189F;
    int32_t *****l_297 = (void*)0;
    const int32_t *l_300 = &l_69;
    const int32_t *l_301 = &l_69;
    (*l_76) = func_65((((int16_t)l_69 >> (int16_t)((int32_t)(-(uint16_t)(0x506E < ((uint16_t)l_69 << (uint16_t)13))) + (int32_t)(l_69 == ((-(uint32_t)((void*)0 == l_76)) > (+((uint32_t)((((uint32_t)(*l_77) + (uint32_t)(**l_76)) ^ (((uint16_t)(&l_77 == (void*)0) + (uint16_t)8U) | (**l_76))) ^ 0xB0C4F31B) + (uint32_t)(**l_76))))))) <= (**l_76)));
    /* statement id: 17 */
    assert (l_77 == 0);
    if (((uint32_t)((-(uint32_t)((int32_t)(((((int16_t)(((+((void*)0 == l_102)) != l_69) | ((uint16_t)l_105 * (uint16_t)(((void*)0 != &p_63) || (((void*)0 == l_77) ^ (-5))))) % (int16_t)l_105) ^ 0xBB8EBACA) != 0xCF31) | l_69) % (int32_t)(*p_63))) | l_105) + (uint32_t)0x3BA0E388))
    { /* block id: 18 */
        p_63 = p_63;
        for (l_105 = 0; (l_105 != 40); l_105 += 2)
        { /* block id: 22 */
            uint32_t l_108 = 7U;
            (*l_76) = func_65(l_108);
        }
    }
    else
    { /* block id: 25 */
        int32_t l_117 = 8;
        float l_121 = 0x2.FDFBADp-89;
        float *l_120 = &l_121;
        struct S0 l_135 = {3,4,0U};
        int32_t l_181 = (-6);
        int32_t *l_182 = &l_117;
        int32_t l_191 = 0x91000105;
        struct S0 *l_203 = &l_135;
        int32_t ***l_204 = &l_76;
        for (l_69 = 21; (l_69 <= (-9)); l_69 -= 3)
        { /* block id: 28 */
            int32_t l_112 = 0x50DEC7D6;
            int32_t *l_111 = &l_112;
            int32_t l_140 = 0;
            struct S0 l_197 = {0xB6F7AEC4,-5,0xE592CA97};
            (*l_102) = p_63;
            /* statement id: 29 */
            //assert (l_77 == &l_60 || l_77 == &l_505.f0 || l_77 == &l_486);
            l_111 = p_63;
            /* statement id: 30 */
            //assert (l_111 == &l_60 || l_111 == &l_505.f0 || l_111 == &l_486);
            (*l_102) = (*l_76);
        }
        /* facts after for loop */
        //assert (l_77 == &l_60 || l_77 == 0 || l_77 == &l_505.f0 || l_77 == &l_486);
        (*l_203) = l_200;
        (*p_63) = (-1);
        (*l_204) = &l_136;
        /* statement id: 77 */
        assert (l_76 == &l_136);
    }
    /* facts after branching */
    //assert (l_77 == &l_60 || l_77 == 0 || l_77 == &l_505.f0 || l_77 == &l_486);
    assert (l_76 == &l_136 || l_76 == &l_77);
    if ((!(l_206 != p_63)))
    { /* block id: 79 */
        struct S0 *l_213 = &l_200;
        int32_t l_226 = 0x6AD60D6B;
        int32_t ***l_254 = &l_102;
        float *l_288 = (void*)0;
        for (l_200.f1 = 29; (l_200.f1 != (-13)); l_200.f1 -= 6)
        { /* block id: 82 */
            if ((*p_63))
                break;
            return p_63;
            /* statement id: 84 */
            //assert (func_61_rv == &l_60 || func_61_rv == &l_505.f0 || func_61_rv == &l_486);
        }
        if ((((int16_t)(((((int16_t)((((l_206 != l_136) & (l_213 == (void*)0)) | (((int16_t)((uint32_t)((uint16_t)((void*)0 != l_213) << (uint16_t)((uint16_t)((uint16_t)((int16_t)(((*p_63) == l_226) | 1) << (int16_t)l_226) * (uint16_t)(*l_206)) >> (uint16_t)0)) - (uint32_t)(*l_206)) >> (int16_t)l_226) == l_226)) == 4294967295U) * (int16_t)l_226) | l_226) || (*l_206)) > 0xBDD16FCC) >> (int16_t)11) < (*l_206)))
        { /* block id: 86 */
            return p_63;
            /* statement id: 87 */
            //assert (func_61_rv == &l_60 || func_61_rv == &l_505.f0 || func_61_rv == &l_486);
        }
        else
        { /* block id: 88 */
            struct S0 *l_239 = (void*)0;
            int32_t l_242 = (-1);
            int32_t *l_259 = (void*)0;
            for (l_200.f1 = (-24); (l_200.f1 <= (-25)); l_200.f1 -= 6)
            { /* block id: 91 */
                uint32_t l_229 = 0x3F4F6D35;
                float l_261 = 0x4.95513Fp-58;
                float *l_260 = &l_261;
                if ((((l_229 > ((int16_t)((l_229 < ((l_229 && (*l_206)) | ((uint32_t)((int16_t)((((uint16_t)(!((((void*)0 == l_239) <= ((uint32_t)(l_242 && (!((uint16_t)0U >> (uint16_t)((l_226 | (-1)) > l_226)))) + (uint32_t)l_229)) != 0xB15D4968)) % (uint16_t)l_242) & l_229) || l_226) + (int16_t)0x0D4C) % (uint32_t)l_226))) | l_242) + (int16_t)l_229)) <= 0x1D4A) >= 1U))
                { /* block id: 92 */
                    uint16_t l_246 = 0xC2CC;
                    (*l_206) = ((l_246 & l_229) == ((!(l_242 | (*p_63))) != ((uint32_t)((uint16_t)l_246 * (uint16_t)(((uint16_t)(((void*)0 == l_254) && (((int32_t)l_246 % (int32_t)((int16_t)l_242 + (int16_t)0xEA42)) & l_246)) * (uint16_t)l_242) == l_229)) + (uint32_t)(*p_63))));
                }
                else
                { /* block id: 94 */
                    (*l_206) = l_242;
                }
                l_259 = p_63;
                /* statement id: 97 */
                //assert (l_259 == &l_60 || l_259 == &l_505.f0 || l_259 == &l_486);
                (*l_76) = &l_242;
                (*l_260) = p_62;
            }
            /* facts after for loop */
            //assert (l_77 == &l_242 || l_77 == &l_60 || l_77 == 0 || l_77 == &l_505.f0 || l_77 == &l_486);
            assert (l_136 == &l_242 || l_136 == 0);
            //assert (l_259 == &l_60 || l_259 == 0 || l_259 == &l_505.f0 || l_259 == &l_486);
            (*l_213) = l_200;
            for (l_226 = 0; (l_226 > 2); l_226 += 5)
            { /* block id: 104 */
                const int32_t *l_264 = &l_242;
                struct S0 *l_293 = &l_200;
                if ((*p_63))
                    break;
            }
        }
        /* facts after branching */
        //assert (l_77 == dangling || l_77 == &l_60 || l_77 == 0 || l_77 == &l_505.f0 || l_77 == &l_486);
        //assert (l_136 == dangling || l_136 == 0);
    }
    else
    { /* block id: 123 */
        l_297 = (void*)0;
        p_62 = (((float)p_62 + (float)0x1.Dp-1) == p_62);
    }
    /* facts after branching */
    //assert (l_77 == dangling || l_77 == &l_60 || l_77 == 0 || l_77 == &l_505.f0 || l_77 == &l_486);
    //assert (l_136 == dangling || l_136 == 0);
    return p_63;
    /* statement id: 127 */
    //assert (func_61_rv == &l_60 || func_61_rv == &l_505.f0 || func_61_rv == &l_486);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_65(uint32_t  p_66)
{ /* block id: 13 */
    int32_t l_86 = 0x7078C3FC;
    int32_t *l_85 = &l_86;
    int32_t **l_87 = (void*)0;
    int32_t **l_88 = &l_85;
    float l_92 = (-0x10.Dp+1);
    float *l_91 = &l_92;
    int32_t *l_93 = (void*)0;
    (*l_88) = l_85;
    (*l_91) = ((float)((void*)0 != (*l_88)) * (float)0x1.9p+1);
    return l_93;
    /* statement id: 16 */
    //assert (func_65_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 154
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 15
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 14, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 22, occurrence: 2
   depth: 30, occurrence: 1

XXX total number of pointers: 140

XXX times a variable address is taken: 138
XXX times a pointer is dereferenced on RHS: 184
breakdown:
   depth: 1, occurrence: 129
   depth: 2, occurrence: 24
   depth: 3, occurrence: 27
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 78
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 12
   depth: 3, occurrence: 5
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 42
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 615

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 486
   level: 2, occurrence: 140
   level: 3, occurrence: 93
   level: 4, occurrence: 42
   level: 5, occurrence: 38
XXX number of pointers point to pointers: 59
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 29.3
XXX average alias set size: 1.37

XXX times a non-volatile is read: 889
XXX times a non-volatile is write: 234
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 83
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 23
   depth: 2, occurrence: 15
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
********************* end of statistics **********************/

