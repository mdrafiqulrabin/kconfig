/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1119253964
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 20;
   signed f1 : 25;
   const signed f2 : 23;
};

struct S1 {
   unsigned f0 : 19;
   uint64_t  f1;
   const volatile unsigned f2 : 4;
   int32_t  f3;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 0x3099CFE0L;
static int32_t g_30 = 0x17AB6DADL;
static int32_t g_51 = (-1L);
static struct S1 g_64 = {98,0x9D707D8EB7BFBC35LL,0,0x455DBFE6L};/* VOLATILE GLOBAL g_64 */
static int32_t *g_84 = &g_51;
static int32_t **g_83 = &g_84;
static const int32_t *g_89 = &g_51;
static const int32_t **g_88 = &g_89;
static float g_95 = (-0x1.6p-1);
static const volatile struct S1 **g_96 = (void*)0;
static struct S0 g_151 = {940,-855,-854};
static struct S0 * const *g_157 = (void*)0;
static struct S0 g_163 = {-457,-10,1721};
static struct S0 *g_162 = &g_163;
static volatile float g_167 = 0xF.A089C8p-27;/* VOLATILE GLOBAL g_167 */
static volatile float *g_166 = &g_167;
static volatile float **g_165 = &g_166;
static int32_t g_260 = 0x74CEC627L;
static const struct S1 g_297 = {312,0xBB98B66C8A74AC35LL,3,-1L};/* VOLATILE GLOBAL g_297 */
static float g_357 = 0x9.624F09p-0;
static uint32_t g_358 = 0x568F9423L;
static struct S1 g_361 = {473,0xF38A1A9F4418AE18LL,2,3L};/* VOLATILE GLOBAL g_361 */


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_27(void);
static uint64_t  func_35(int32_t ** p_36);
static int32_t  func_39(int64_t  p_40, int64_t  p_41, int32_t * p_42, int32_t ** p_43);
static int32_t ** func_44(int32_t ** p_45, uint64_t  p_46);
static uint32_t  func_57(uint32_t  p_58);
static const struct S1 * func_59(struct S1 * p_60, uint32_t  p_61, int32_t  p_62);
static const uint32_t  func_70(struct S0  p_71);
static int32_t  func_73(struct S0  p_74, uint16_t  p_75, const int32_t * p_76);
static const int16_t  func_85(const int32_t ** p_86, struct S1 * p_87);
static struct S1 * func_90(int32_t * const * p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_30 g_3 g_51 g_83 g_88 g_96 g_84 g_89 g_64.f1 g_64.f0 g_64.f3 g_163.f1 g_163.f2 g_64.f2 g_151.f1 g_165 g_166 g_167 g_151.f0 g_163.f0 g_151.f2 g_297.f3 g_297.f0 g_260 g_358 g_361
 * writes: g_51 g_95 g_96 g_84 g_89 g_64.f3 g_64.f1 g_260 g_167
 */
static struct S1  func_27(void)
{ /* block id: 36 */
    int32_t *l_29 = &g_30;
    int32_t **l_28 = &l_29;
    float *l_356 = &g_357;
    float **l_355 = &l_356;
    (*l_28) = (void*)0;
    if (__builtin_clz((g_30 & (((int64_t)(-5L) / (int64_t)((int32_t)(func_35(&l_29) || g_163.f2) / (int32_t)(g_151.f1 | (l_355 != &g_166)))) && g_358))))
    { /* block id: 256 */
        (*g_83) = (*g_83);
    }
    else
    { /* block id: 258 */
        const volatile struct S1 ***l_360 = &g_96;
        const volatile struct S1 ****l_359 = &l_360;
        (*l_359) = &g_96;
    }
    return g_361;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_30 g_51 g_83 g_88 g_96 g_84 g_89 g_64.f1 g_64.f0 g_64.f3 g_163.f1 g_163.f2 g_64.f2 g_151.f1 g_165 g_166 g_167 g_151.f0 g_163.f0 g_151.f2 g_297.f3 g_297.f0 g_260
 * writes: g_51 g_95 g_96 g_84 g_89 g_64.f3 g_64.f1 g_260 g_167
 */
static uint64_t  func_35(int32_t ** p_36)
{ /* block id: 38 */
    int32_t *l_48 = (void*)0;
    int32_t **l_47 = &l_48;
    int32_t *l_328 = &g_260;
    (*l_328) = (+(!(func_39(g_3, g_30, (*p_36), func_44(l_47, g_30)) || (~2L))));
    if ((0x7EA6B481L <= ((uint64_t)((uint16_t)(__builtin_parity(g_64.f3) > ((int16_t)0L << (int16_t)(((uint16_t)g_3 >> (uint16_t)1) | ((g_297.f3 & (0xBCABL && (18446744073709551607UL == ((int16_t)0xC4D6L << (int16_t)2)))) | 1UL)))) << (uint16_t)14) - (uint64_t)(*l_328))))
    { /* block id: 247 */
        uint64_t l_343 = 1UL;
        return l_343;
    }
    else
    { /* block id: 249 */
        (**g_165) = (*g_166);
        (*p_36) = (*l_47);
    }
    (*g_88) = (*g_88);
    (**g_165) = ((float)(*g_166) - (float)((float)((*l_328) != (*l_328)) + (float)(+((float)((float)(g_297.f0 > 0x0.9p-1) + (float)((float)((((&g_157 != &g_157) > (0xB.567D7Ap+17 != ((*l_328) < (*l_328)))) >= g_260) > (*l_328)) / (float)(*l_328))) / (float)g_297.f0))));
    return g_64.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_51 g_83 g_88 g_96 g_84 g_89 g_64.f1 g_3 g_64.f0 g_64.f3 g_163.f1 g_163.f2 g_64.f2 g_151.f1 g_165 g_166 g_167 g_151.f0 g_163.f0 g_151.f2 g_297.f3 g_297.f0
 * writes: g_51 g_95 g_96 g_84 g_89 g_64.f3 g_64.f1 g_260 g_167
 */
static int32_t  func_39(int64_t  p_40, int64_t  p_41, int32_t * p_42, int32_t ** p_43)
{ /* block id: 41 */
    int16_t l_49 = 0xE91CL;
    int32_t *l_50 = &g_51;
    (*l_50) = l_49;
    (*l_50) = ((int32_t)(0x807CL && ((!g_30) | (((((uint32_t)func_57((*l_50)) / (uint32_t)((uint32_t)(__builtin_ctzll(g_151.f2) ^ (p_40 <= l_49)) % (uint32_t)__builtin_ctzl(g_297.f0))) & g_297.f0) | 0xB75FEBA5L) | g_163.f0))) - (int32_t)p_41);
    (*g_166) = ((float)0x0.2p-1 / (float)(p_41 >= 0x2.9038FEp+34));
    if ((!18446744073709551615UL))
    { /* block id: 234 */
        int32_t *l_323 = &g_30;
        (*g_83) = l_323;
        (*g_88) = (*p_43);
        for (g_64.f1 = 0; (g_64.f1 > 49); g_64.f1 += 1)
        { /* block id: 239 */
            (*p_43) = (*p_43);
        }
    }
    else
    { /* block id: 242 */
        int32_t *l_326 = &g_30;
        (*g_88) = l_326;
    }
    return (*l_50);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_44(int32_t ** p_45, uint64_t  p_46)
{ /* block id: 39 */
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_83 g_88 g_96 g_84 g_89 g_64.f1 g_3 g_30 g_64.f0 g_64.f3 g_51 g_163.f1 g_163.f2 g_64.f2 g_151.f1 g_165 g_166 g_167 g_151.f0 g_163.f0 g_151.f2 g_297.f3
 * writes: g_95 g_96 g_84 g_89 g_64.f3 g_51 g_64.f1 g_260 g_167
 */
static uint32_t  func_57(uint32_t  p_58)
{ /* block id: 43 */
    struct S1 *l_63 = &g_64;
    struct S0 l_72 = {-692,-1434,-597};
    const struct S1 *l_296 = &g_297;
    int32_t *l_298 = &g_64.f3;
    float *l_315 = (void*)0;
    float **l_314 = &l_315;
    l_296 = func_59(l_63, p_58, __builtin_ctzll((+((uint16_t)0x2097L >> (uint16_t)(((uint32_t)func_70(l_72) % (uint32_t)((int64_t)((int16_t)(~l_72.f1) - (int16_t)((uint64_t)l_72.f2 - (uint64_t)0xAB7566744F56941DLL)) + (int64_t)((int16_t)((int16_t)(l_72.f0 | 0xB664D11AL) - (int16_t)p_58) + (int16_t)p_58))) == p_58)))));
    (*l_298) = l_72.f2;
    for (g_64.f3 = (-8); (g_64.f3 < 22); g_64.f3 += 1)
    { /* block id: 226 */
        const int32_t **l_307 = &g_89;
        int32_t l_308 = 0x0FFD9DDAL;
        int32_t *l_309 = &g_51;
        (*l_309) = (((uint32_t)(((int32_t)((*l_298) ^ (*l_298)) % (int32_t)((int16_t)p_58 >> (int16_t)(g_297.f3 < ((-8L) && (-5L))))) == func_85(l_307, &g_64)) % (uint32_t)l_308) > 0xC13450B3EC079514LL);
        return (*l_298);
    }
    (*l_298) = (((((uint32_t)(((0x2354L | g_297.f3) >= (*l_298)) <= g_151.f1) - (uint32_t)(((int32_t)(*l_298) / (int32_t)g_30) ^ (l_314 == &l_315))) & 0x53D0L) <= 1L) > (*l_298));
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads : g_64.f1 g_64.f2 g_64.f3 g_83 g_84 g_30 g_51 g_88 g_163.f1 g_3 g_163.f0 g_151.f2 g_163.f2 g_64.f0 g_166 g_167
 * writes: g_64.f3 g_89 g_51 g_167 g_64.f1 g_84
 */
static const struct S1 * func_59(struct S1 * p_60, uint32_t  p_61, int32_t  p_62)
{ /* block id: 202 */
    int16_t l_281 = 0x32DCL;
    const struct S1 *l_285 = &g_64;
    int32_t *l_293 = &g_51;
    if ((((int16_t)l_281 >> (int16_t)g_64.f1) ^ g_64.f2))
    { /* block id: 203 */
        int32_t l_290 = 0xB679A5ECL;
        for (g_64.f3 = 0; (g_64.f3 != (-18)); g_64.f3 -= 1)
        { /* block id: 206 */
            int32_t *l_284 = (void*)0;
            p_62 = (**g_83);
            (*g_88) = l_284;
            return l_285;
        }
        (*l_293) = ((((((uint16_t)(((**g_83) > p_61) == p_61) >> (uint16_t)l_281) < ((((uint16_t)(g_163.f1 < ((g_3 < (((0x7749A3EBL | l_290) == ((((uint32_t)(&p_62 == l_293) / (uint32_t)0x73FA2BBCL) & 0xD353F1D640A94FD2LL) > (*l_293))) <= 0x1B26L)) && g_163.f0)) << (uint16_t)0) || g_151.f2) | l_290)) & g_51) && g_163.f2) == g_64.f0);
        (*g_166) = (0x0.9p+1 < (*g_166));
    }
    else
    { /* block id: 213 */
        for (g_64.f1 = (-4); (g_64.f1 != 32); g_64.f1 += 9)
        { /* block id: 216 */
            (*g_166) = 0xB.648319p+17;
        }
        (*g_83) = (void*)0;
    }
    return l_285;
}


/* ------------------------------------------ */
/* 
 * reads : g_83 g_88 g_96 g_84 g_89 g_64.f1 g_3 g_30 g_64.f0 g_64.f3 g_51 g_163.f1 g_163.f2 g_64.f2 g_151.f1 g_165 g_166 g_167 g_151.f0
 * writes: g_95 g_96 g_84 g_89 g_64.f3 g_51 g_64.f1 g_260
 */
static const uint32_t  func_70(struct S0  p_71)
{ /* block id: 44 */
    struct S0 l_77 = {-579,-2587,1707};
    uint64_t l_82 = 18446744073709551615UL;
    int32_t * const *l_92 = &g_84;
    const int32_t *l_100 = &g_51;
    float ** const l_234 = (void*)0;
    float ** const *l_233 = &l_234;
    if (func_73(l_77, ((uint32_t)__builtin_bswap32(((((uint16_t)l_82 << (uint16_t)(g_83 == &g_84)) || (((func_85(g_88, func_90(l_92)) > p_71.f0) != 0x4212L) | g_64.f1)) == 0xE27FL)) / (uint32_t)0x2AAC5DA2L), l_100))
    { /* block id: 161 */
        int32_t *l_253 = &g_51;
        const int32_t **l_261 = (void*)0;
        for (g_64.f1 = (-27); (g_64.f1 <= 26); g_64.f1++)
        { /* block id: 164 */
            int32_t l_227 = (-1L);
            float *l_237 = &g_95;
            float **l_236 = &l_237;
            float ***l_235 = &l_236;
            for (g_64.f3 = 0; (g_64.f3 < 26); g_64.f3 += 8)
            { /* block id: 167 */
                float l_247 = 0x0.836A76p-13;
                struct S1 *l_256 = &g_64;
                int32_t l_266 = 0xF9BFE5C0L;
                if ((p_71.f0 | l_227))
                { /* block id: 168 */
                    int16_t l_231 = 0xFB1EL;
                    struct S1 *l_257 = &g_64;
                    if ((-(uint64_t)(((uint64_t)l_231 - (uint64_t)__builtin_parityl((!((l_233 != l_235) >= (**g_88))))) <= p_71.f0)))
                    { /* block id: 169 */
                        (**l_236) = (**g_165);
                    }
                    else
                    { /* block id: 171 */
                        struct S1 *l_249 = &g_64;
                        struct S1 **l_248 = &l_249;
                        struct S1 ***l_250 = &l_248;
                        (***l_235) = ((float)(-(float)((void*)0 == (*g_83))) + (float)((p_71.f1 != ((float)(**g_165) / (float)(p_71.f0 != 0x0.4p+1))) >= ((float)(((float)(g_151.f0 >= l_247) / (float)g_151.f0) >= p_71.f0) - (float)(*l_100))));
                        (*l_250) = l_248;
                    }
                    for (l_227 = 23; (l_227 < 9); --l_227)
                    { /* block id: 177 */
                        (*g_83) = (*g_83);
                        (*g_83) = l_253;
                        return p_71.f0;
                    }
                    for (g_51 = 0; (g_51 > (-29)); --g_51)
                    { /* block id: 184 */
                        int64_t l_258 = 0L;
                        int32_t *l_259 = &g_260;
                        l_258 = (l_256 == l_257);
                        (*l_259) = (*g_84);
                    }
                    (*l_253) = ((l_227 == __builtin_ia32_crc32qi(p_71.f0, l_227)) || p_71.f0);
                }
                else
                { /* block id: 189 */
                    (**g_83) = (~((!(((int64_t)(p_71.f1 || p_71.f0) + (int64_t)p_71.f1) == l_266)) & 0x78AF0DFD19A3497ELL));
                    (*g_84) = __builtin_ctz(l_227);
                }
                (**g_83) = __builtin_ctz(__builtin_ffs(l_227));
                (*g_88) = (*g_88);
            }
        }
    }
    else
    { /* block id: 197 */
        int32_t *l_267 = &g_30;
        (*g_83) = l_267;
    }
    l_100 = (*l_92);
    return g_64.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_30 g_64.f0 g_64.f3 g_96 g_83 g_84 g_88 g_51 g_89 g_163.f1 g_163.f2 g_64.f2 g_151.f1
 * writes: g_95 g_64.f3 g_96 g_84 g_89 g_51
 */
static int32_t  func_73(struct S0  p_74, uint16_t  p_75, const int32_t * p_76)
{ /* block id: 54 */
    float l_101 = 0x1.4p-1;
    int32_t l_107 = (-6L);
    float *l_108 = (void*)0;
    const float **l_145 = (void*)0;
    const float ***l_144 = &l_145;
    const float ****l_143 = &l_144;
    float l_169 = (-0x4.Ap+1);
    const int32_t **l_172 = &g_89;
    g_95 = ((__builtin_popcountl(g_3) == (p_75 <= ((((float)0x6.7p-1 - (float)(g_30 == (+((float)l_107 / (float)l_107)))) == p_74.f1) >= g_30))) > g_64.f0);
    for (g_64.f3 = 0; (g_64.f3 <= 7); g_64.f3 += 1)
    { /* block id: 58 */
        struct S1 *l_111 = &g_64;
        int32_t l_120 = 0x8D4E4AF0L;
        const float *l_122 = (void*)0;
        const float **l_121 = &l_122;
        const float *****l_161 = (void*)0;
        volatile float **l_168 = &g_166;
        struct S0 * const **l_179 = &g_157;
    }
    for (p_75 = (-10); (p_75 <= 20); p_75 += 5)
    { /* block id: 132 */
        uint16_t l_186 = 0UL;
        float *** const *l_195 = (void*)0;
        float *** const **l_194 = &l_195;
        int32_t *l_196 = &g_51;
        struct S0 **l_211 = &g_162;
        struct S0 ***l_210 = &l_211;
        if ((g_64.f3 ^ (func_85(&p_76, &g_64) || ((*p_76) <= (((int64_t)l_186 % (int64_t)l_186) > ((((-1L) || ((*l_143) != &g_165)) && 6UL) > 6UL))))))
        { /* block id: 133 */
            uint32_t l_187 = 0xC22D3DACL;
            p_74.f1 = (l_187 > (0xC01D75DE8CEC1B3ELL ^ (((uint64_t)(((**l_172) & ((uint64_t)(l_187 <= g_30) - (uint64_t)l_187)) <= ((p_74.f1 != (((l_194 == (void*)0) >= l_186) | p_74.f0)) >= l_186)) / (uint64_t)g_163.f1) && (**l_172))));
        }
        else
        { /* block id: 135 */
            (*l_172) = p_76;
            (*g_83) = (*g_83);
            (**g_83) = (*p_76);
        }
        if (l_186)
            continue;
        if ((*g_84))
        { /* block id: 141 */
            int32_t l_204 = (-1L);
            (*g_88) = l_196;
            for (g_51 = (-30); (g_51 >= (-24)); g_51++)
            { /* block id: 145 */
                const volatile struct S1 ***l_200 = &g_96;
                const volatile struct S1 ****l_199 = &l_200;
                int32_t l_201 = (-1L);
                (*g_88) = (*g_83);
                (*l_199) = &g_96;
                l_204 = (((l_201 || (*p_76)) >= ((uint16_t)1UL << (uint16_t)8)) != g_163.f2);
            }
            (*g_84) = (*p_76);
            (*g_83) = l_196;
        }
        else
        { /* block id: 152 */
            float l_206 = (-0x2.Ep+1);
            int32_t l_207 = 0xBDC872F4L;
            struct S0 ***l_212 = (void*)0;
            float **l_218 = &l_108;
            (*g_88) = p_76;
            (*l_196) = (!((g_30 >= (l_207 > (func_85(&g_89, &g_64) ^ (l_210 != l_212)))) >= ((int16_t)(g_64.f2 && ((uint64_t)g_151.f1 % (uint64_t)18446744073709551607UL)) + (int16_t)p_74.f1)));
            (*l_196) = (((g_163.f2 != (0xE2B228E0L && (!(*g_84)))) <= (&g_166 != l_218)) < ((int16_t)((int32_t)(*p_76) % (int32_t)p_74.f2) - (int16_t)p_74.f1));
            (*l_172) = p_76;
        }
        if ((*l_196))
            continue;
    }
    return (**l_172);
}


/* ------------------------------------------ */
/* 
 * reads : g_96 g_83 g_84 g_89 g_88
 * writes: g_96 g_95 g_84 g_89
 */
static const int16_t  func_85(const int32_t ** p_86, struct S1 * p_87)
{ /* block id: 48 */
    const volatile struct S1 ***l_97 = &g_96;
    const int32_t l_98 = 1L;
    float *l_99 = &g_95;
    (*l_97) = g_96;
    (*l_99) = l_98;
    (*g_83) = (*g_83);
    (*g_88) = (*p_86);
    return l_98;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_95
 */
static struct S1 * func_90(int32_t * const * p_91)
{ /* block id: 45 */
    struct S1 *l_93 = (void*)0;
    float *l_94 = &g_95;
    (*l_94) = (l_93 == l_93);
    return l_93;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_30, "g_30", print_hash_value);
    transparent_crc(g_51, "g_51", print_hash_value);
    transparent_crc(g_64.f0, "g_64.f0", print_hash_value);
    transparent_crc(g_64.f1, "g_64.f1", print_hash_value);
    transparent_crc(g_64.f2, "g_64.f2", print_hash_value);
    transparent_crc(g_64.f3, "g_64.f3", print_hash_value);
    transparent_crc_bytes (&g_95, sizeof(g_95), "g_95", print_hash_value);
    transparent_crc(g_151.f0, "g_151.f0", print_hash_value);
    transparent_crc(g_151.f1, "g_151.f1", print_hash_value);
    transparent_crc(g_151.f2, "g_151.f2", print_hash_value);
    transparent_crc(g_163.f0, "g_163.f0", print_hash_value);
    transparent_crc(g_163.f1, "g_163.f1", print_hash_value);
    transparent_crc(g_163.f2, "g_163.f2", print_hash_value);
    transparent_crc_bytes (&g_167, sizeof(g_167), "g_167", print_hash_value);
    transparent_crc(g_260, "g_260", print_hash_value);
    transparent_crc(g_297.f0, "g_297.f0", print_hash_value);
    transparent_crc(g_297.f1, "g_297.f1", print_hash_value);
    transparent_crc(g_297.f2, "g_297.f2", print_hash_value);
    transparent_crc(g_297.f3, "g_297.f3", print_hash_value);
    transparent_crc_bytes (&g_357, sizeof(g_357), "g_357", print_hash_value);
    transparent_crc(g_358, "g_358", print_hash_value);
    transparent_crc(g_361.f0, "g_361.f0", print_hash_value);
    transparent_crc(g_361.f1, "g_361.f1", print_hash_value);
    transparent_crc(g_361.f2, "g_361.f2", print_hash_value);
    transparent_crc(g_361.f3, "g_361.f3", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 78
   depth: 1, occurrence: 3
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 3
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 3
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 50

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 16
   depth: 3, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 4
   depth: 12, occurrence: 1
   depth: 14, occurrence: 4
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 21, occurrence: 1

XXX total number of pointers: 95

XXX times a variable address is taken: 92
XXX times a pointer is dereferenced on RHS: 63
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 10
XXX times a pointer is dereferenced on LHS: 71
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 221

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 209
   level: 2, occurrence: 43
   level: 3, occurrence: 1
XXX number of pointers point to pointers: 48
XXX number of pointers point to scalars: 32
XXX number of pointers point to structs: 15
XXX percent of pointers has null in alias set: 24.2
XXX average alias set size: 1.18

XXX times a non-volatile is read: 373
XXX times a non-volatile is write: 175
XXX times a volatile is read: 8
XXX    times read thru a pointer: 5
XXX times a volatile is write: 7
XXX    times written thru a pointer: 7
XXX times a volatile is available for access: 62
XXX percentage of non-volatile access: 97.3

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 95
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 22
   depth: 2, occurrence: 18
   depth: 3, occurrence: 6
   depth: 4, occurrence: 6
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 23.3
XXX percentage an existing variable is used: 76.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

