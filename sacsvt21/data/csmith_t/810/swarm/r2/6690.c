/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1277665450
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 3;
   signed f1 : 12;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_31(void);
static int32_t  func_38(struct S0  p_39);
static struct S0  func_40(uint32_t  p_41, uint32_t  p_42, float  p_43);
static struct S0  func_46(float  p_47);
static struct S0  func_51(int16_t  p_52, float  p_53, struct S0  p_54, int32_t  p_55);
static int32_t  func_58(const uint32_t  p_59, uint32_t  p_60, uint16_t  p_61, const float  p_62);
static uint32_t  func_64(int16_t  p_65, int32_t  p_66);
static const struct S0 * func_67(struct S0 * p_68);
static uint16_t  func_75(struct S0 * p_76);
static struct S0 * func_77(uint32_t  p_78, uint32_t  p_79, struct S0 * p_80, const int32_t  p_81, float  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 0x77E815F8;
    uint32_t l_545[5][8] = {{2U,1U,9U,9U,1U,2U,1U,0x836B2D66},{1U,1U,4294967288U,0x3D2FE6F7,2U,4294967288U,1U,4294967288U},{0xC9E6D880,0x3D2FE6F7,0x7968F7BF,0x3D2FE6F7,0xC9E6D880,0x94880372,0x3D2FE6F7,0x836B2D66},{0xD374F127,0xC9E6D880,2U,9U,0x3D2FE6F7,0xD374F127,0xD374F127,0x3D2FE6F7},{1U,2U,2U,1U,1U,4294967288U,0x3D2FE6F7,2U}};
    float l_549[8] = {0x1.5p-1,0x1.5p-1,0x1.5p-1,0x1.5p-1,0x1.5p-1,0x1.5p-1,0x1.5p-1,0x1.5p-1};
    struct S0 l_809 = {0,-46};
    struct S0 *l_808 = &l_809;
    struct S0 **l_807[4][10] = {{&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808},{&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808},{&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808},{&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808,&l_808}};
    struct S0 ***l_806 = &l_807[2][4];
    struct S0 ****l_805[1][6][3] = {{{&l_806,&l_806,&l_806},{&l_806,&l_806,&l_806},{&l_806,&l_806,&l_806},{&l_806,&l_806,(void*)0},{&l_806,&l_806,(void*)0},{&l_806,&l_806,&l_806}}};
    struct S0 *****l_804[2][2][7] = {{{&l_805[0][2][0],&l_805[0][5][0],(void*)0,&l_805[0][5][0],&l_805[0][2][0],&l_805[0][2][0],&l_805[0][5][0]},{&l_805[0][5][0],(void*)0,&l_805[0][5][0],&l_805[0][5][0],&l_805[0][5][0],&l_805[0][5][0],(void*)0}},{{&l_805[0][5][0],(void*)0,(void*)0,(void*)0,(void*)0,&l_805[0][5][0],(void*)0},{&l_805[0][5][0],&l_805[0][5][0],&l_805[0][5][0],&l_805[0][5][0],(void*)0,&l_805[0][5][0],&l_805[0][5][0]}}};
    int32_t l_835 = 0x86EC970E;
    int32_t l_836 = (-1);
    struct S0 *l_862 = &l_809;
    uint32_t l_871 = 0x8CAC99B1;
    int32_t *l_895 = &l_835;
    int32_t **l_894 = &l_895;
    int32_t ***l_893 = &l_894;
    int32_t ****l_892 = &l_893;
    float l_900 = 0x7.BF4832p+55;
    const int32_t l_930[8] = {0x390AA8C2,0x390AA8C2,0x390AA8C2,0x390AA8C2,0x390AA8C2,0x390AA8C2,0x390AA8C2,0x390AA8C2};
    float l_942 = 0x8.Fp-1;
    int32_t l_952 = 0x14EDB4D2;
    uint32_t l_998 = 1U;
    struct S0 **l_1002 = &l_808;
    int32_t *l_1040[7][9] = {{&l_32,&l_32,&l_835,&l_836,&l_835,&l_32,&l_32,&l_835,&l_836},{(void*)0,(void*)0,&l_835,&l_32,&l_836,&l_32,(void*)0,&l_32,&l_835},{&l_835,(void*)0,&l_836,&l_32,&l_32,&l_836,(void*)0,&l_835,(void*)0},{&l_835,&l_32,&l_835,&l_32,&l_32,(void*)0,(void*)0,(void*)0,&l_32},{(void*)0,&l_32,&l_32,&l_32,&l_835,&l_32,&l_32,&l_32,(void*)0},{(void*)0,&l_32,&l_32,&l_836,&l_835,(void*)0,&l_32,&l_836,&l_835},{(void*)0,&l_836,&l_836,&l_835,&l_32,&l_32,&l_835,&l_836,&l_836}};
    uint32_t l_1053 = 0xC2D639F9;
    float l_1059 = (-0x4.1p+1);
    float ****l_1068 = (void*)0;
    int16_t l_1069 = 0x4004;
    int32_t l_1090 = 0x797D844D;
    int16_t l_1110[7][9][2] = {{{0x3DE8,0x7E47},{0xC61F,(-1)},{0,(-9)},{6,0x3DE8},{0xF0CF,7},{(-1),0x1E69},{4,(-1)},{0,0},{6,(-1)}},{{0x2AC5,0},{(-1),0x7E47},{0xF0CF,(-1)},{(-9),0},{(-9),(-1)},{0xF0CF,0x7E47},{(-1),0},{0xF12A,0xC61F},{0x6208,0xF9A2}},{{0xF9A2,0x2AC5},{1,0},{0xC61F,0},{7,0xCD9C},{0x6208,(-1)},{(-2),0xC61F},{4,0x86BF},{0xCD9C,0},{1,0x178E}},{{(-1),0x6208},{0xF9A2,0xCD9C},{4,6},{0x178E,6},{4,0xCD9C},{0xF9A2,0x6208},{(-1),0x178E},{1,0},{0xCD9C,0x86BF}},{{4,0xC61F},{(-2),(-1)},{0x6208,0xCD9C},{7,0},{0xC61F,0},{1,0x2AC5},{0xF9A2,0xF9A2},{0x6208,0xC61F},{0xF12A,6}},{{0x2AC5,0x86BF},{7,0x2AC5},{(-1),(-2)},{(-1),0x2AC5},{7,0x86BF},{0x2AC5,6},{0xF12A,0xC61F},{0x6208,0xF9A2},{0xF9A2,0x2AC5}},{{1,0},{0xC61F,0},{7,0xCD9C},{0x6208,(-1)},{(-2),0xC61F},{4,0x86BF},{0xCD9C,0},{1,0x178E},{(-1),0x6208}}};
    struct S0 ***l_1154[3][7] = {{&l_1002,&l_807[2][1],&l_1002,&l_807[2][1],&l_1002,&l_807[2][1],&l_1002},{&l_807[1][7],&l_807[1][7],&l_807[1][7],&l_807[1][7],&l_807[1][7],&l_807[1][7],&l_807[1][7]},{&l_1002,&l_807[2][1],&l_1002,&l_807[2][1],&l_1002,&l_807[2][1],&l_1002}};
    int16_t l_1174 = 3;
    uint32_t l_1194 = 3U;
    int32_t l_1202[6][5][4] = {{{0x1F16E592,0,(-1),0xFDC2D755},{6,0,0xF21756A3,0},{0x30A1C5EF,(-3),8,0xAD7282FB},{0x30A1C5EF,6,0xF21756A3,0x5624A80B},{6,0xAD7282FB,(-1),0}},{{0x1F16E592,0x9241847E,0xAD7282FB,0xA15F4843},{0,0x1ABDF72C,0x4F0D50C7,0x30A1C5EF},{0xE90E2164,8,0xB72FCC84,0xAB78C296},{5,0,6,0x02A6014B},{0x46FA3959,0xD217AD02,0xA15F4843,9}},{{6,0xAB78C296,0xA1362119,0x24CF9B70},{0x5624A80B,0x95A43D8C,0xD217AD02,(-3)},{8,0xD348B25E,0x4940F498,2},{8,0x1F16E592,0x9C08F242,0xE90E2164},{0x4940F498,0x5D97CD26,0x5D97CD26,0x4940F498}},{{(-3),0,0,0},{9,0x24CF9B70,8,0x55435090},{0xF21756A3,0x46A0D47E,0x02A6014B,0x55435090},{0x11AF732A,0x24CF9B70,0x1ABDF72C,0xD7247E28},{(-1),0,6,0xFDC2D755}},{{0xAD7282FB,0x7EDE0C3A,8,0x24CF9B70},{0xF8EDA454,(-1),0,0x5D97CD26},{6,0xF3947FB9,0x46A0D47E,6},{0xA1362119,6,8,0x02A6014B},{0xE90E2164,0,0xD348B25E,0x9C08F242}},{{9,0,7,8},{8,0x46FA3959,0x4F0D50C7,0},{0xD7247E28,6,(-3),5},{8,0x4E9B0E14,5,0x1ABDF72C},{0,0,0,0x6A91B238}}};
    int32_t l_1210 = 0x2A110667;
    int32_t l_1218 = 0xC02B8E51;
    uint32_t l_1249 = 0x164D9706;
    int16_t l_1268 = 0;
    int32_t *l_1300[5][9][5] = {{{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835}},{{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218}},{{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835}},{{(void*)0,&l_1202[5][4][1],&l_1202[5][4][1],(void*)0,&l_1218},{&l_32,&l_835,&l_835,&l_32,&l_835},{(void*)0,(void*)0,(void*)0,&l_1202[2][4][1],&l_1202[5][4][1]},{&l_1090,&l_32,&l_32,&l_1090,&l_1202[5][4][1]},{&l_1202[2][4][1],(void*)0,(void*)0,&l_1202[2][4][1],&l_1202[5][4][1]},{&l_1090,&l_32,&l_32,&l_1090,&l_1202[5][4][1]},{&l_1202[2][4][1],(void*)0,(void*)0,&l_1202[2][4][1],&l_1202[5][4][1]},{&l_1090,&l_32,&l_32,&l_1090,&l_1202[5][4][1]},{&l_1202[2][4][1],(void*)0,(void*)0,&l_1202[2][4][1],&l_1202[5][4][1]}},{{&l_1090,&l_32,&l_32,&l_1090,&l_1202[5][4][1]},{&l_1202[2][4][1],(void*)0,(void*)0,&l_1202[2][4][1],&l_1202[5][4][1]},{&l_1090,&l_32,&l_32,&l_1090,&l_1202[5][4][1]},{&l_1202[2][4][1],(void*)0,(void*)0,&l_1202[2][4][1],&l_1202[5][4][1]},{&l_1090,&l_32,&l_32,&l_1090,&l_1202[5][4][1]},{&l_1202[2][4][1],(void*)0,(void*)0,&l_1202[2][4][1],&l_1202[5][4][1]},{&l_1090,&l_32,&l_32,&l_1090,&l_1202[5][4][1]},{&l_1202[2][4][1],(void*)0,(void*)0,&l_1202[2][4][1],&l_1202[5][4][1]},{&l_1090,&l_32,&l_32,&l_1090,&l_1202[5][4][1]}}};
    const int32_t l_1314 = 0x8B1A1CFA;
    float *l_1333 = &l_942;
    float **l_1332[3];
    float ***l_1331[5][9][2] = {{{&l_1332[1],(void*)0},{&l_1332[1],&l_1332[2]},{&l_1332[2],(void*)0},{&l_1332[1],&l_1332[1]},{&l_1332[1],&l_1332[1]},{&l_1332[1],(void*)0},{&l_1332[2],&l_1332[2]},{&l_1332[1],(void*)0},{&l_1332[1],&l_1332[2]}},{{&l_1332[1],&l_1332[1]},{&l_1332[0],&l_1332[0]},{&l_1332[2],&l_1332[1]},{&l_1332[1],&l_1332[1]},{&l_1332[1],(void*)0},{&l_1332[1],&l_1332[1]},{&l_1332[2],&l_1332[1]},{(void*)0,&l_1332[1]},{&l_1332[1],&l_1332[1]}},{{&l_1332[1],&l_1332[1]},{&l_1332[1],&l_1332[2]},{&l_1332[1],(void*)0},{&l_1332[1],&l_1332[1]},{&l_1332[1],&l_1332[1]},{&l_1332[2],&l_1332[0]},{&l_1332[2],&l_1332[1]},{&l_1332[1],&l_1332[1]},{&l_1332[1],(void*)0}},{{&l_1332[1],&l_1332[2]},{&l_1332[1],&l_1332[1]},{&l_1332[1],&l_1332[1]},{&l_1332[1],&l_1332[1]},{(void*)0,&l_1332[1]},{&l_1332[2],&l_1332[1]},{&l_1332[1],(void*)0},{&l_1332[1],&l_1332[1]},{&l_1332[1],&l_1332[1]}},{{&l_1332[2],&l_1332[0]},{&l_1332[0],&l_1332[1]},{&l_1332[1],&l_1332[2]},{&l_1332[1],(void*)0},{&l_1332[1],&l_1332[2]},{&l_1332[2],(void*)0},{&l_1332[1],&l_1332[1]},{&l_1332[1],&l_1332[1]},{&l_1332[1],(void*)0}}};
    const uint32_t l_1373 = 0x2E5D6BCE;
    uint16_t l_1431 = 0x10FA;
    int16_t l_1463 = 0x9048;
    int32_t l_1481[4] = {0xB1DDD1A6,0xB1DDD1A6,0xB1DDD1A6,0xB1DDD1A6};
    int i, j, k;
    for (i = 0; i < 3; i = i + 1)
        l_1332[i] = &l_1333;
    for (l_32 = 0; (l_32 != 16); l_32 = safe_add_func_int32_t_s_s(l_32, 1))
    { /* block id: 39 */
        int32_t l_35[7][9][4] = {{{1,0,0x488A9733,1},{0,0x6540F213,0x488A9733,0x488A9733},{1,1,0xE62B5609,0x2A41B870},{1,0x90AE7359,0x3FA3C9E4,1},{0x3FA3C9E4,1,0xEAC3EFC1,1},{0,0x3FA3C9E4,0x6540F213,0x3FA3C9E4},{0x3FA3C9E4,1,(-7),0x90AE7359},{0xE62B5609,0,0xEAC3EFC1,(-7)},{0x488A9733,0x8E10A3BD,0x2A41B870,0x3FA3C9E4}},{{0x488A9733,0xEAC3EFC1,0xEAC3EFC1,0x488A9733},{0xE62B5609,0x3FA3C9E4,(-7),0xEAC3EFC1},{0x3FA3C9E4,0x8E10A3BD,0x6540F213,0x90AE7359},{0,0xE62B5609,0xEAC3EFC1,0x90AE7359},{1,0x8E10A3BD,1,0xEAC3EFC1},{0x488A9733,0x3FA3C9E4,1,0x488A9733},{0,0xEAC3EFC1,(-7),0x3FA3C9E4},{0xEAC3EFC1,0x8E10A3BD,(-7),(-7)},{0,0,1,0x90AE7359}},{{0x488A9733,1,1,0x3FA3C9E4},{1,0x3FA3C9E4,0xEAC3EFC1,1},{0,0x3FA3C9E4,0x6540F213,0x3FA3C9E4},{0x3FA3C9E4,1,(-7),0x90AE7359},{0xE62B5609,0,0xEAC3EFC1,(-7)},{0x488A9733,0x8E10A3BD,0x2A41B870,0x3FA3C9E4},{0x488A9733,0xEAC3EFC1,0xEAC3EFC1,0x488A9733},{0xE62B5609,0x3FA3C9E4,(-7),0xEAC3EFC1},{0x3FA3C9E4,0x8E10A3BD,0x6540F213,0x90AE7359}},{{0,0xE62B5609,0xEAC3EFC1,0x90AE7359},{1,0x8E10A3BD,1,0xEAC3EFC1},{0x488A9733,0x3FA3C9E4,1,0x488A9733},{0,0xEAC3EFC1,(-7),0x3FA3C9E4},{0xEAC3EFC1,0x8E10A3BD,(-7),(-7)},{0,0,1,0x90AE7359},{0x488A9733,1,1,0x3FA3C9E4},{1,0x3FA3C9E4,0xEAC3EFC1,1},{0,0x3FA3C9E4,0x6540F213,0x3FA3C9E4}},{{0x3FA3C9E4,1,(-7),0x90AE7359},{0xE62B5609,0,0xEAC3EFC1,(-7)},{0x488A9733,0x8E10A3BD,0x2A41B870,0x3FA3C9E4},{0x488A9733,0xEAC3EFC1,0xEAC3EFC1,0x488A9733},{0xE62B5609,0x3FA3C9E4,(-7),0xEAC3EFC1},{0x3FA3C9E4,0x8E10A3BD,0x6540F213,0x90AE7359},{0,0xE62B5609,0xEAC3EFC1,0x90AE7359},{1,0x8E10A3BD,1,0xEAC3EFC1},{0x488A9733,0x3FA3C9E4,1,0x488A9733}},{{0,0xEAC3EFC1,(-7),0x3FA3C9E4},{0xEAC3EFC1,0x8E10A3BD,(-7),(-7)},{0,0,1,0x90AE7359},{0x488A9733,1,1,0x3FA3C9E4},{1,0x3FA3C9E4,0xEAC3EFC1,1},{0,0x3FA3C9E4,0x6540F213,0x3FA3C9E4},{0x3FA3C9E4,1,(-7),0x90AE7359},{0xE62B5609,0xEAC3EFC1,0x2A41B870,1},{(-7),0xE62B5609,0x90AE7359,1}},{{(-7),0x2A41B870,0x2A41B870,(-7)},{1,1,1,0x2A41B870},{1,0xE62B5609,0x8E10A3BD,1},{0xEAC3EFC1,1,0x2A41B870,1},{0x6540F213,0xE62B5609,0x6540F213,0x2A41B870},{(-7),1,0x488A9733,(-7)},{0xEAC3EFC1,0x2A41B870,1,1},{0x2A41B870,0xE62B5609,1,1},{0xEAC3EFC1,0xEAC3EFC1,0x488A9733,1}}};
        float *l_803[1][3];
        int32_t l_812 = 2;
        int32_t *l_811 = &l_812;
        struct S0 l_813 = {1,35};
        struct S0 *****l_821 = &l_805[0][3][2];
        float ***l_879 = (void*)0;
        float ****l_878 = &l_879;
        const int32_t l_882[5][10][5] = {{{(-6),0x520B04DE,0x6F3E1431,(-5),0xC6A85D25},{0,(-1),0x5735D88E,1,0x0FE3EB0C},{4,0xBB2716CE,0x9C6C5592,1,0xA5FE2030},{0x0FE3EB0C,(-1),0x3B41C91E,1,0x2E69A384},{0x0AAAA78A,0x5C2AE47B,1,(-5),0xC1D6770E},{1,(-1),0x2E69A384,0x2E69A384,(-1)},{0x9823AD1D,0x56FB844E,1,1,0xFFB267C2},{(-3),0,0x5735D88E,1,(-1)},{1,(-5),(-8),(-1),1},{(-3),(-1),(-6),(-3),(-9)}},{{0x9823AD1D,(-5),0x14562C1C,(-5),0x0AAAA78A},{1,0x8EF0024F,1,(-9),(-3)},{0x0AAAA78A,0x520B04DE,0xC6A85D25,0x5C2AE47B,0xFFB267C2},{0x0FE3EB0C,0xFC0F6A4C,0x35B36782,(-1),1},{4,1,0xC6A85D25,(-1),(-9)},{0,(-7),1,(-1),0x2E69A384},{(-6),(-1),0x14562C1C,(-1),(-6)},{0xBB4CAA29,0x0FE3EB0C,(-6),0x2E69A384,1},{0xA5FE2030,0x520B04DE,(-8),(-2),0xC6A85D25},{(-1),(-3),0x5735D88E,0x0FE3EB0C,1}},{{4,(-2),1,1,(-6)},{1,(-1),0x2E69A384,0xFC0F6A4C,0x2E69A384},{0x933B20E7,0x2ECF21C8,1,0xBB2716CE,(-9)},{1,1,0x3B41C91E,0x2E69A384,1},{0xC1D6770E,0x56FB844E,0x9C6C5592,0x4829A511,0xFFB267C2},{(-1),1,0x5735D88E,0,(-3)},{1,0x2ECF21C8,0x6F3E1431,(-1),0x0AAAA78A},{0x8EF0024F,(-1),(-1),0x8EF0024F,(-9)},{(-9),(-2),0x14562C1C,0x2ECF21C8,1},{1,(-3),0x4E6E6A84,0x268867BE,(-7)}},{{4,(-1),0x8275FA5E,0x46E07B41,(-5)},{0xBB4CAA29,1,0xFC0F6A4C,(-6),0x3B41C91E},{(-1),(-9),(-5),0xF65D9BA5,0xD73C679B},{0x2E69A384,0x5735D88E,0xC71CB6ED,(-9),0x96234F26},{0x6F3E1431,1,1,(-1),(-8)},{0xC71CB6ED,0xBB4CAA29,0x5735D88E,0x96234F26,1},{0x6F3E1431,(-1),1,0x520B04DE,(-9)},{0x2E69A384,(-6),0x0FE3EB0C,0xBB4CAA29,0xBB4CAA29},{(-1),8,(-1),(-1),0x6F3E1431},{0xBB4CAA29,0xAB19C1E0,0x268867BE,1,0x96234F26}},{{4,0xF3745E85,0x0AAAA78A,0x56FB844E,0xFFB267C2},{0x124D96B1,(-9),0x268867BE,0x96234F26,(-9)},{0xC6A85D25,0xB34263BB,(-1),(-9),(-5)},{(-6),0x3B41C91E,0x0FE3EB0C,0x3B41C91E,(-6)},{9,0x7CA6A647,1,0xF65D9BA5,0x9C6C5592},{(-7),0xAB19C1E0,0x5735D88E,(-7),0x268867BE},{0xD73C679B,0x520B04DE,1,0x7CA6A647,0x9C6C5592},{0x124D96B1,(-7),0xC71CB6ED,0x268867BE,(-6)},{0x9C6C5592,(-1),(-5),0xF3745E85,(-5)},{0x3BD7E3B9,0x3BD7E3B9,0xFC0F6A4C,(-1),(-9)}}};
        int32_t **l_886 = &l_811;
        int32_t ***l_885 = &l_886;
        int32_t *****l_914[7];
        struct S0 *l_915 = &l_813;
        float l_940[5];
        float l_941[7] = {0x0.1p+1,0x0.1p+1,0x0.1p+1,0x0.1p+1,0x0.1p+1,0x0.1p+1,0x0.1p+1};
        struct S0 ***l_976 = (void*)0;
        struct S0 ***l_977[6][2][6] = {{{(void*)0,(void*)0,(void*)0,&l_807[2][1],&l_807[0][4],&l_807[2][4]},{&l_807[2][9],&l_807[3][0],&l_807[0][2],&l_807[2][1],&l_807[2][1],&l_807[0][2]}},{{(void*)0,(void*)0,(void*)0,&l_807[0][2],(void*)0,&l_807[0][3]},{&l_807[0][3],(void*)0,(void*)0,&l_807[3][0],(void*)0,(void*)0}},{{&l_807[2][8],&l_807[0][3],(void*)0,&l_807[2][9],(void*)0,&l_807[0][3]},{&l_807[0][4],&l_807[2][9],(void*)0,&l_807[2][4],&l_807[2][4],&l_807[0][2]}},{{&l_807[2][4],&l_807[2][4],&l_807[0][2],(void*)0,(void*)0,&l_807[2][4]},{&l_807[2][4],&l_807[2][4],(void*)0,(void*)0,&l_807[2][4],&l_807[2][4]}},{{&l_807[2][4],&l_807[2][9],&l_807[0][3],(void*)0,(void*)0,&l_807[3][0]},{(void*)0,&l_807[0][3],(void*)0,&l_807[2][8],(void*)0,&l_807[2][1]}},{{(void*)0,(void*)0,&l_807[2][8],(void*)0,(void*)0,(void*)0},{&l_807[2][4],(void*)0,(void*)0,(void*)0,&l_807[2][1],&l_807[0][4]}}};
        int32_t l_1019 = 0x175048E2;
        struct S0 *****l_1025[5] = {&l_805[0][4][2],&l_805[0][4][2],&l_805[0][4][2],&l_805[0][4][2],&l_805[0][4][2]};
        int32_t l_1027 = 1;
        const struct S0 l_1058 = {0,-36};
        int i, j, k;
        for (i = 0; i < 1; i = i + 1)
        {
            for (j = 0; j < 3; j = j + 1)
                l_803[i][j] = &l_549[1];
        }
        for (i = 0; i < 7; i = i + 1)
            l_914[i] = &l_892;
        for (i = 0; i < 5; i = i + 1)
            l_940[i] = 0xC.40A749p-16;
        for (l_35[0][3][0] = (-14); (l_35[0][3][0] < 6); l_35[0][3][0] = safe_add_func_uint16_t_u_u(l_35[0][3][0], 4))
        { /* block id: 42 */
            float l_547 = 0xD.150DC9p-84;
            int32_t l_548 = (-1);
            uint32_t l_550 = 0xBF05FC56;
            int32_t *l_799 = &l_548;
            int32_t *l_814[10][10] = {{&l_35[6][1][0],&l_812,&l_32,(void*)0,&l_35[0][3][0],&l_35[0][3][0],(void*)0,(void*)0,&l_35[0][3][0],&l_35[0][3][0]},{&l_35[0][3][0],(void*)0,(void*)0,&l_35[0][3][0],&l_812,&l_812,&l_35[4][8][0],&l_35[6][1][0],&l_35[0][3][0],&l_812},{&l_35[0][3][0],&l_35[6][1][0],(void*)0,&l_35[0][3][0],(void*)0,&l_35[3][5][1],(void*)0,&l_35[4][8][0],&l_35[0][3][0],(void*)0},{&l_35[0][3][0],(void*)0,&l_35[6][1][0],&l_35[0][3][0],&l_35[2][4][2],&l_35[0][3][0],&l_35[6][1][0],(void*)0,&l_35[0][3][0],&l_35[2][4][2]},{&l_812,(void*)0,&l_35[4][8][0],&l_35[0][3][0],&l_548,&l_35[0][3][0],(void*)0,(void*)0,&l_35[0][3][0],&l_548},{&l_35[3][5][1],&l_35[4][8][0],(void*)0,&l_35[0][3][0],&l_35[0][3][0],&l_35[0][3][0],(void*)0,(void*)0,&l_35[0][3][0],&l_35[0][3][0]},{&l_35[0][3][0],(void*)0,(void*)0,&l_35[0][3][0],&l_812,&l_812,&l_35[4][8][0],&l_35[6][1][0],&l_35[0][3][0],&l_812},{&l_35[0][3][0],&l_35[6][1][0],(void*)0,&l_35[0][3][0],(void*)0,&l_35[3][5][1],(void*)0,&l_35[4][8][0],&l_35[0][3][0],(void*)0},{&l_35[0][3][0],(void*)0,&l_35[6][1][0],&l_35[0][3][0],&l_35[2][4][2],&l_35[0][3][0],&l_35[6][1][0],(void*)0,&l_35[0][3][0],&l_35[2][4][2]},{&l_812,(void*)0,&l_35[4][8][0],&l_35[0][3][0],&l_548,&l_35[0][3][0],(void*)0,(void*)0,&l_35[0][3][0],&l_548}};
            float **l_828[10][4] = {{&l_803[0][1],&l_803[0][0],&l_803[0][2],&l_803[0][0]},{&l_803[0][0],&l_803[0][0],(void*)0,&l_803[0][0]},{&l_803[0][2],(void*)0,(void*)0,&l_803[0][2]},{&l_803[0][0],&l_803[0][0],&l_803[0][2],&l_803[0][1]},{&l_803[0][1],(void*)0,&l_803[0][1],&l_803[0][0]},{&l_803[0][1],&l_803[0][0],(void*)0,&l_803[0][0]},{(void*)0,(void*)0,&l_803[0][0],&l_803[0][1]},{(void*)0,&l_803[0][0],&l_803[0][0],&l_803[0][2]},{&l_803[0][0],(void*)0,&l_803[0][0],&l_803[0][0]},{&l_803[0][0],&l_803[0][0],&l_803[0][0],&l_803[0][0]}};
            float ***l_827[3][7][10] = {{{(void*)0,&l_828[5][0],&l_828[4][1],&l_828[4][1],(void*)0,&l_828[9][2],&l_828[4][1],&l_828[2][1],&l_828[4][1],&l_828[2][1]},{(void*)0,&l_828[7][2],(void*)0,(void*)0,&l_828[4][1],&l_828[0][1],(void*)0,(void*)0,&l_828[4][1],&l_828[4][1]},{&l_828[9][3],&l_828[4][1],&l_828[4][1],(void*)0,(void*)0,(void*)0,&l_828[0][2],&l_828[6][3],&l_828[7][0],(void*)0},{&l_828[3][0],&l_828[9][2],&l_828[4][1],&l_828[4][1],&l_828[4][1],&l_828[0][2],(void*)0,&l_828[5][0],&l_828[4][0],&l_828[2][1]},{&l_828[4][1],(void*)0,(void*)0,&l_828[4][1],(void*)0,&l_828[4][1],&l_828[4][1],&l_828[0][2],(void*)0,&l_828[0][2]},{&l_828[4][1],&l_828[4][1],&l_828[9][3],&l_828[4][1],&l_828[9][3],(void*)0,(void*)0,&l_828[4][1],(void*)0,&l_828[0][0]},{&l_828[4][0],&l_828[8][1],&l_828[9][2],&l_828[4][1],&l_828[1][3],&l_828[2][1],&l_828[4][1],&l_828[3][0],&l_828[4][1],&l_828[4][1]}},{{(void*)0,&l_828[8][1],&l_828[8][1],&l_828[4][1],&l_828[7][0],&l_828[9][3],(void*)0,&l_828[0][0],&l_828[1][3],&l_828[4][1]},{(void*)0,(void*)0,&l_828[4][1],(void*)0,&l_828[2][1],(void*)0,(void*)0,&l_828[4][1],&l_828[5][1],&l_828[4][1]},{(void*)0,&l_828[5][1],(void*)0,&l_828[6][3],(void*)0,&l_828[4][1],&l_828[4][1],&l_828[4][1],&l_828[0][0],(void*)0},{(void*)0,(void*)0,&l_828[4][1],&l_828[7][1],&l_828[4][1],&l_828[5][1],&l_828[4][1],&l_828[6][3],(void*)0,&l_828[1][3]},{&l_828[9][2],&l_828[4][0],(void*)0,&l_828[4][1],(void*)0,&l_828[0][2],&l_828[5][1],&l_828[5][1],&l_828[0][2],(void*)0},{&l_828[4][1],&l_828[7][1],&l_828[7][1],&l_828[4][1],&l_828[5][1],(void*)0,&l_828[0][0],&l_828[4][1],&l_828[4][1],(void*)0},{(void*)0,&l_828[4][1],(void*)0,&l_828[4][1],(void*)0,(void*)0,&l_828[7][1],&l_828[0][0],&l_828[4][1],&l_828[3][2]}},{{(void*)0,&l_828[2][1],&l_828[5][0],&l_828[4][1],(void*)0,&l_828[6][3],&l_828[4][1],(void*)0,&l_828[0][2],&l_828[4][1]},{&l_828[4][1],(void*)0,&l_828[4][1],&l_828[4][1],&l_828[6][3],&l_828[9][2],&l_828[4][1],&l_828[4][1],(void*)0,&l_828[4][1]},{&l_828[2][1],&l_828[6][3],&l_828[4][1],&l_828[7][1],&l_828[4][1],(void*)0,&l_828[4][1],&l_828[9][3],&l_828[0][0],(void*)0},{&l_828[3][2],&l_828[5][0],&l_828[4][1],&l_828[6][3],&l_828[4][1],&l_828[8][1],(void*)0,&l_828[4][1],&l_828[5][1],&l_828[4][1]},{&l_828[4][1],&l_828[0][2],&l_828[1][3],(void*)0,(void*)0,&l_828[4][1],(void*)0,(void*)0,&l_828[1][3],&l_828[0][2]},{&l_828[1][3],&l_828[4][1],&l_828[2][0],&l_828[4][1],&l_828[4][1],(void*)0,&l_828[5][1],&l_828[7][2],&l_828[4][1],&l_828[6][3]},{&l_828[4][1],&l_828[4][1],&l_828[4][1],&l_828[4][1],(void*)0,(void*)0,&l_828[5][0],&l_828[4][1],(void*)0,&l_828[4][1]}}};
            float ****l_826 = &l_827[2][2][6];
            float *****l_825 = &l_826;
            struct S0 **l_853 = (void*)0;
            int32_t l_870 = 0;
            struct S0 *l_873 = &l_809;
            const float **l_913[1];
            const float ***l_912 = &l_913[0];
            const float ****l_911 = &l_912;
            int i, j, k;
            for (i = 0; i < 1; i = i + 1)
                l_913[i] = (void*)0;
            l_548 = ((0x4A08DEB2 | func_38((l_35[3][7][3] , func_40(((safe_lshift_func_uint16_t_u_u(((func_46(l_32) , (l_545[0][3] < ((!l_545[4][6]) < l_35[6][4][2]))) , (((7 >= 0U) >= l_545[4][4]) , 0x44C8)), 5)) >= l_548), l_35[5][4][3], l_550)))) || 0x547C);
            l_799 = &l_32;
            /* statement id: 598 */
            assert (l_799 == &l_32);
        }
    }
    return l_1481[3];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_38(struct S0  p_39)
{ /* block id: 397 */
    int32_t l_552 = 0;
    struct S0 l_561 = {0,39};
    const struct S0 *l_560 = &l_561;
    int32_t *l_585[2][7][10] = {{{&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552},{&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,(void*)0,&l_552,&l_552},{(void*)0,&l_552,(void*)0,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552},{(void*)0,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552},{&l_552,&l_552,(void*)0,(void*)0,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552},{&l_552,&l_552,(void*)0,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552},{&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552}},{{&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,(void*)0,&l_552},{&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552},{(void*)0,&l_552,&l_552,&l_552,&l_552,&l_552,(void*)0,&l_552,&l_552,&l_552},{&l_552,&l_552,(void*)0,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552},{&l_552,&l_552,&l_552,&l_552,&l_552,(void*)0,(void*)0,&l_552,&l_552,&l_552},{&l_552,&l_552,&l_552,(void*)0,(void*)0,&l_552,&l_552,&l_552,&l_552,&l_552},{&l_552,&l_552,&l_552,&l_552,&l_552,(void*)0,&l_552,&l_552,&l_552,&l_552}}};
    int32_t **l_584[6][4] = {{&l_585[1][1][1],&l_585[0][5][4],&l_585[1][1][1],&l_585[0][5][4]},{&l_585[1][1][1],&l_585[0][5][4],&l_585[1][1][1],&l_585[0][5][4]},{&l_585[1][1][1],&l_585[0][5][4],&l_585[1][1][1],&l_585[0][5][4]},{&l_585[1][1][1],&l_585[0][5][4],&l_585[1][1][1],&l_585[0][5][4]},{&l_585[1][1][1],&l_585[0][5][4],&l_585[1][1][1],&l_585[0][5][4]},{&l_585[1][1][1],&l_585[0][5][4],&l_585[1][1][1],&l_585[0][5][4]}};
    struct S0 *l_595 = &l_561;
    struct S0 **l_594 = &l_595;
    struct S0 ***l_593 = &l_594;
    uint16_t l_631 = 0x6EF7;
    int32_t *****l_632 = (void*)0;
    float l_659 = (-0x9.2p+1);
    float *l_658 = &l_659;
    float **l_657[1][6][2] = {{{&l_658,&l_658},{(void*)0,&l_658},{&l_658,(void*)0},{&l_658,&l_658},{(void*)0,&l_658},{&l_658,(void*)0}}};
    float ***l_656 = &l_657[0][1][1];
    float ****l_655 = &l_656;
    float l_698 = 0x1.Ep+1;
    uint32_t l_739 = 4294967295U;
    uint32_t l_756 = 4294967286U;
    int i, j, k;
    for (l_552 = 26; (l_552 == 18); l_552 = safe_sub_func_int32_t_s_s(l_552, 8))
    { /* block id: 400 */
        int16_t l_557 = 0xF310;
        struct S0 l_559 = {1,-0};
        struct S0 *l_558 = &l_559;
        struct S0 **l_562 = &l_558;
        int32_t *l_564 = (void*)0;
        int32_t **l_563 = &l_564;
        (*l_558) = func_40((p_39 , l_552), l_552, ((safe_sub_func_float_f_f(((0x0.1p+1 <= (l_557 < p_39.f0)) >= 0x9.12B5C3p+8), ((func_75(&p_39) == l_552) >= l_557))) != p_39.f1));
        (*l_562) = l_560;
        /* statement id: 402 */
        assert (l_558 == &l_561);
        (*l_563) = &l_552;
        /* statement id: 403 */
        assert (l_564 == &l_552);
    }
    for (l_552 = (-21); (l_552 != 15); l_552 = safe_add_func_int32_t_s_s(l_552, 9))
    { /* block id: 407 */
        int32_t l_567 = (-7);
        int32_t *l_570 = &l_552;
        l_561.f1 = l_567;
        for (l_567 = 0; (l_567 < 0); l_567 = safe_add_func_uint32_t_u_u(l_567, 1))
        { /* block id: 411 */
            int32_t **l_571 = &l_570;
            int32_t l_572 = 0x9B88431F;
            (*l_571) = l_570;
            p_39.f1 = (0x890F && (**l_571));
            (*l_571) = &l_552;
            for (l_572 = 0; (l_572 != 0); l_572 = safe_add_func_int32_t_s_s(l_572, 9))
            { /* block id: 417 */
                struct S0 *l_575[1][1];
                int i, j;
                for (i = 0; i < 1; i = i + 1)
                {
                    for (j = 0; j < 1; j = j + 1)
                        l_575[i][j] = &l_561;
                }
                p_39 = p_39;
            }
        }
        return l_552;
    }
    if ((safe_lshift_func_int16_t_s_s(0x98EA, (func_64(func_64(l_552, (p_39.f0 , l_552)), l_561.f1) <= (__builtin_ctzll((l_552 != (0x576930EA == 0U))) & 0xA7F9)))))
    { /* block id: 423 */
        uint32_t l_580 = 4294967287U;
        int32_t **l_583 = (void*)0;
        struct S0 ***l_596 = &l_594;
        int32_t ***l_600 = &l_583;
        int32_t ****l_599 = &l_600;
        int32_t l_651 = 0;
        int32_t *l_650 = &l_651;
        for (l_552 = 14; (l_552 <= (-2)); l_552--)
        { /* block id: 426 */
            float l_582[7][7][2] = {{{0xE.C91175p+67,0x8.62ABD5p+30},{0x9.9D9C05p+5,0x8.62ABD5p+30},{0xE.C91175p+67,0x9.9D9C05p+5},{0x8.1815AAp+28,0x8.1815AAp+28},{0xD.CE3451p+51,0x1.Dp-1},{0xE.C91175p+67,0x2.732F25p+42},{0x1.Dp-1,0x8.62ABD5p+30}},{{0xF.53D707p-6,0x1.Dp-1},{0x8.1815AAp+28,0xD.CE3451p+51},{0x8.1815AAp+28,0x1.Dp-1},{0xF.53D707p-6,0x8.62ABD5p+30},{0x1.Dp-1,0x2.732F25p+42},{0xE.C91175p+67,0x1.Dp-1},{0xD.CE3451p+51,0x8.1815AAp+28}},{{0x8.1815AAp+28,0x9.9D9C05p+5},{0xE.C91175p+67,0x8.62ABD5p+30},{0x9.9D9C05p+5,0x8.62ABD5p+30},{0xE.C91175p+67,0x9.9D9C05p+5},{0x8.1815AAp+28,0x8.1815AAp+28},{0xD.CE3451p+51,0x1.Dp-1},{0xE.C91175p+67,0x2.732F25p+42}},{{0x1.Dp-1,0x8.62ABD5p+30},{0xF.53D707p-6,0x1.Dp-1},{0x8.1815AAp+28,0xD.CE3451p+51},{0x8.1815AAp+28,0x1.Dp-1},{0x8.Cp-1,0xD.CE3451p+51},{0xF.53D707p-6,0x8.410988p-21},{(-0x2.0p+1),0xF.53D707p-6}},{{0x1.8p-1,0x9.9D9C05p+5},{0x9.9D9C05p+5,0x0.Bp-1},{(-0x2.0p+1),0xD.CE3451p+51},{0x0.Bp-1,0xD.CE3451p+51},{(-0x2.0p+1),0x0.Bp-1},{0x9.9D9C05p+5,0x9.9D9C05p+5},{0x1.8p-1,0xF.53D707p-6}},{{(-0x2.0p+1),0x8.410988p-21},{0xF.53D707p-6,0xD.CE3451p+51},{0x8.Cp-1,0xF.53D707p-6},{0x9.9D9C05p+5,0x1.8p-1},{0x9.9D9C05p+5,0xF.53D707p-6},{0x8.Cp-1,0xD.CE3451p+51},{0xF.53D707p-6,0x8.410988p-21}},{{(-0x2.0p+1),0xF.53D707p-6},{0x1.8p-1,0x9.9D9C05p+5},{0x9.9D9C05p+5,0x0.Bp-1},{(-0x2.0p+1),0xD.CE3451p+51},{0x0.Bp-1,0xD.CE3451p+51},{(-0x2.0p+1),0x0.Bp-1},{0x9.9D9C05p+5,0x9.9D9C05p+5}}};
            float *l_581 = &l_582[0][5][1];
            float ***l_591 = (void*)0;
            int32_t l_592 = 0x0BBD24D3;
            int32_t *l_622 = &l_592;
            struct S0 ****l_648 = &l_596;
            float *****l_705 = &l_655;
            int32_t *l_706[5];
            int32_t *****l_707 = (void*)0;
            int i, j, k;
            for (i = 0; i < 5; i = i + 1)
                l_706[i] = &l_592;
            (*l_581) = l_580;
        }
    }
    else
    { /* block id: 532 */
        int16_t l_715[5][10] = {{0xEA50,0x013A,(-1),0x013A,0xEA50,0xEA50,0x013A,(-1),0x013A,0xEA50},{0xEA50,0x013A,(-1),0x013A,0xEA50,0xEA50,0x013A,(-1),0x013A,0xEA50},{0xEA50,0x013A,(-1),0x013A,0xEA50,0xEA50,0x013A,(-1),0x013A,0xEA50},{0xEA50,0x013A,(-1),0x013A,0xEA50,0xEA50,0x013A,(-1),0x013A,0xEA50},{0xEA50,0x013A,(-1),0x013A,0xEA50,0xEA50,0x013A,(-1),0x013A,0xEA50}};
        int32_t l_716[4][7] = {{0xBFC89BE2,5,0xCF917786,5,0xBFC89BE2,0xBFC89BE2,5},{1,(-1),1,5,5,1,(-1)},{5,(-1),0xCF917786,0xCF917786,(-1),5,(-1)},{1,5,5,1,(-1),1,5}};
        const int32_t *****l_719 = (void*)0;
        float ****l_720 = &l_656;
        uint16_t l_725 = 0x7743;
        int i, j;
        l_716[0][5] = ((((void*)0 != &l_584[2][0]) > (l_715[3][6] ^ l_715[2][1])) , ((p_39.f0 <= l_715[3][6]) , (((0x9E8BA389 ^ l_715[3][6]) , p_39.f0) , l_715[3][6])));
        (***l_593) = func_51(((safe_rshift_func_int16_t_s_u(((func_46(((void*)0 != l_719)) , l_720) == (p_39 , (void*)0)), 2)) , (p_39.f1 == (((safe_rshift_func_int16_t_s_s(((safe_add_func_uint32_t_u_u((func_64(p_39.f1, (l_716[3][6] || l_725)) >= 0xAAC23A74), p_39.f0)) ^ p_39.f0), 8)) > p_39.f1) , p_39.f1))), p_39.f0, p_39, p_39.f0);
    }
    for (l_631 = (-12); (l_631 != 41); l_631 = safe_add_func_uint32_t_u_u(l_631, 1))
    { /* block id: 538 */
        struct S0 *l_728[3];
        int32_t *l_729 = (void*)0;
        float l_763 = 0xE.109A75p-91;
        uint16_t l_793 = 0xE38F;
        struct S0 l_798 = {0,33};
        int i;
        for (i = 0; i < 3; i = i + 1)
            l_728[i] = &l_561;
        l_728[2] = (**l_593);
        if (((void*)0 == l_729))
        { /* block id: 540 */
            int32_t *l_730[7];
            struct S0 **l_755 = &l_728[2];
            const float *l_771 = &l_763;
            const float **l_770 = &l_771;
            const float ***l_769 = &l_770;
            const float ****l_768 = &l_769;
            const float *****l_767 = &l_768;
            int i;
            for (i = 0; i < 7; i = i + 1)
                l_730[i] = &l_552;
            l_730[4] = l_730[6];
            for (l_552 = 0; (l_552 >= 0); l_552 -= 1)
            { /* block id: 544 */
                int32_t l_733 = 1;
                int32_t *l_732 = &l_733;
                int32_t *l_774[8] = {&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552,&l_552};
                int32_t *l_775 = &l_733;
                int i;
                (**l_593) = (*l_594);
            }
        }
        else
        { /* block id: 590 */
            uint32_t l_796 = 0xC48E2778;
            int32_t l_797 = 0x3DD52749;
            p_39.f1 = (((safe_add_func_int32_t_s_s(l_796, p_39.f1)) && l_796) ^ l_797);
            (*l_595) = l_798;
        }
        l_729 = l_729;
    }
    return p_39.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_40(uint32_t  p_41, uint32_t  p_42, float  p_43)
{ /* block id: 395 */
    struct S0 l_551[5] = {{0,49},{0,49},{0,49},{0,49},{0,49}};
    int i;
    return l_551[3];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_46(float  p_47)
{ /* block id: 43 */
    int32_t l_48 = 0x9E478DFC;
    struct S0 l_544 = {0,58};
    for (l_48 = 0; (l_48 < (-4)); l_48--)
    { /* block id: 46 */
        uint16_t l_56 = 0xEC7F;
        struct S0 l_57[1][1][9] = {{{{1,33},{1,33},{1,33},{1,33},{1,33},{1,33},{1,33},{1,33},{1,33}}}};
        const int16_t l_63 = 0xCCE6;
        int32_t l_543[3];
        int32_t *l_542 = &l_543[1];
        int i, j, k;
        for (i = 0; i < 3; i = i + 1)
            l_543[i] = 0x68FDAE53;
        l_57[0][0][0] = func_51(l_48, l_56, l_57[0][0][0], func_58(l_63, ((__builtin_ctzl(func_64(l_57[0][0][0].f1, l_56)) & ((0x401D7CD1 == l_57[0][0][0].f1) , 4294967286U)) == l_48), l_48, p_47));
        (*l_542) = (-4);
    }
    return l_544;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_51(int16_t  p_52, float  p_53, struct S0  p_54, int32_t  p_55)
{ /* block id: 388 */
    uint32_t l_530 = 4294967292U;
    float ***l_534[2];
    float ****l_533 = &l_534[1];
    struct S0 *l_541 = (void*)0;
    struct S0 **l_540 = &l_541;
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_534[i] = (void*)0;
    p_53 = ((p_54.f0 & (((l_530 || ((((((safe_add_func_int32_t_s_s(7, (((l_533 == &l_534[1]) , l_530) , p_52))) != (((__builtin_ia32_crc32qi((((((((safe_add_func_float_f_f(func_64(((safe_unary_minus_func_uint16_t_u(((((safe_rshift_func_uint16_t_u_s(__builtin_parityll(p_52), 1)) , l_540) == &l_541) & 0x3CA17C83))) & l_530), l_530), (-0x1.6p+1))) >= (-0x6.Ap-1)) == l_530) < p_54.f0) >= p_54.f0) <= p_53) , l_530), l_530) < 0x291B) , p_55) < 0xD183)) ^ 4U) || 0xD4FD) != l_530) > p_54.f0)) == l_530) > 4U)) , l_530);
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_58(const uint32_t  p_59, uint32_t  p_60, uint16_t  p_61, const float  p_62)
{ /* block id: 386 */
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_64(int16_t  p_65, int32_t  p_66)
{ /* block id: 47 */
    struct S0 l_70 = {0,-9};
    struct S0 *l_69 = &l_70;
    struct S0 **l_363[3];
    struct S0 **l_364 = &l_69;
    struct S0 ****l_387 = (void*)0;
    int32_t l_403 = 0x1995FF3E;
    int32_t *l_402 = &l_403;
    struct S0 *l_450 = &l_70;
    float **l_473[2][2][5];
    uint32_t l_503 = 0xFB282178;
    float l_526 = 0x8.07F388p-81;
    int i, j, k;
    for (i = 0; i < 3; i = i + 1)
        l_363[i] = &l_69;
    for (i = 0; i < 2; i = i + 1)
    {
        for (j = 0; j < 2; j = j + 1)
        {
            for (k = 0; k < 5; k = k + 1)
                l_473[i][j][k] = (void*)0;
        }
    }
    (*l_364) = func_67(l_69);
    /* statement id: 253 */
    assert (l_69 == &l_70 || l_69 == 0);
    if (p_66)
    { /* block id: 254 */
        int16_t l_367 = 0x66E1;
        int32_t l_370 = 1;
        int32_t *l_369[1][5][7] = {{{&l_370,&l_370,&l_370,&l_370,&l_370,&l_370,&l_370},{&l_370,&l_370,&l_370,&l_370,&l_370,(void*)0,(void*)0},{&l_370,&l_370,&l_370,&l_370,&l_370,&l_370,&l_370},{&l_370,&l_370,&l_370,&l_370,&l_370,&l_370,(void*)0},{&l_370,&l_370,&l_370,&l_370,&l_370,&l_370,&l_370}}};
        int32_t **l_368 = &l_369[0][4][4];
        float l_375 = (-0x1.6p-1);
        float *l_374 = &l_375;
        float **l_373 = &l_374;
        float ***l_372 = &l_373;
        float ****l_371[7] = {&l_372,&l_372,&l_372,&l_372,&l_372,&l_372,&l_372};
        float *****l_376 = &l_371[5];
        int i, j, k;
        for (p_65 = (-19); (p_65 <= (-24)); p_65 = safe_sub_func_uint16_t_u_u(p_65, 2))
        { /* block id: 257 */
            l_367 = 0x0BC05A12;
        }
        (*l_368) = &p_66;
        /* statement id: 260 */
        //assert (l_369[0][0][0] == &p_66 || l_369[0][0][0] == 0 || l_369[0][0][0] == &l_370);
        (*l_368) = &p_66;
        (*l_376) = l_371[0];
    }
    else
    { /* block id: 263 */
        uint32_t l_388 = 4294967295U;
        for (p_66 = 0; (p_66 > 19); p_66 = safe_add_func_int32_t_s_s(p_66, 1))
        { /* block id: 266 */
            int32_t l_389 = 0x4FB4660F;
            int32_t l_391 = 0x9840CDF6;
            int32_t *l_390 = &l_391;
            int32_t **l_392 = &l_390;
            (*l_390) = (((safe_add_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((safe_sub_func_int32_t_s_s(__builtin_ctzl(l_70.f1), (safe_sub_func_int32_t_s_s(p_66, 0xD3999685)))), 14)), (((void*)0 == l_387) <= (l_388 == p_66)))) < (__builtin_ctzll(l_388) != l_389)) != l_70.f1);
            (*l_392) = &p_66;
            /* statement id: 268 */
            assert (l_390 == &p_66);
        }
    }
    if ((safe_rshift_func_int16_t_s_u(p_65, l_70.f1)))
    { /* block id: 271 */
        struct S0 l_396 = {0,-33};
        int32_t l_401 = 1;
        int32_t *l_400 = &l_401;
        int32_t **l_404 = &l_400;
        if (__builtin_bswap64(l_70.f1))
        { /* block id: 272 */
            struct S0 l_395 = {1,47};
            l_396 = l_395;
        }
        else
        { /* block id: 274 */
            int32_t l_399 = (-8);
            int32_t *l_398 = &l_399;
            int32_t **l_397 = &l_398;
            (*l_397) = &p_66;
            /* statement id: 275 */
            assert (l_398 == &p_66);
        }
        (*l_400) = __builtin_ia32_crc32qi(p_66, p_66);
        (*l_404) = l_402;
        /* statement id: 278 */
        assert (l_400 == &l_403);
    }
    else
    { /* block id: 279 */
        int32_t **l_405[4] = {&l_402,&l_402,&l_402,&l_402};
        uint16_t l_414 = 0x7084;
        struct S0 *l_417 = &l_70;
        struct S0 l_434 = {1,8};
        float *****l_451 = (void*)0;
        uint16_t l_523 = 0xBF08;
        struct S0 **l_529 = &l_417;
        int i;
        l_402 = &l_403;
        if ((((safe_lshift_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((((((*l_402) , ((0x562F ^ p_66) , (p_66 , (safe_rshift_func_uint16_t_u_u(((safe_mod_func_uint16_t_u_u((((((__builtin_parity(p_66) , p_66) == (((0x1.0141EDp+12 < ((0xB.7E60A7p+35 != (-0x10.6p+1)) != (*l_402))) > p_65) <= 0x0.C87FEBp+37)) , 0x6C3F52E7) , p_66) != p_65), (*l_402))) == 0U), p_65))))) || p_66) || (*l_402)) <= p_66), p_66)), l_414)) , (*l_402)) ^ 65535U))
        { /* block id: 281 */
            int32_t *l_418[1][10] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
            float l_429[5][8] = {{(-0x2.8p-1),0xD.23A04Bp+30,(-0x2.8p-1),(-0x2.8p-1),0xD.23A04Bp+30,(-0x2.8p-1),(-0x2.8p-1),0xD.23A04Bp+30},{0xD.23A04Bp+30,(-0x2.8p-1),(-0x2.8p-1),0xD.23A04Bp+30,(-0x2.8p-1),(-0x2.8p-1),0xD.23A04Bp+30,(-0x2.8p-1)},{0xD.23A04Bp+30,0xD.23A04Bp+30,0x6.5D5A57p+10,0xD.23A04Bp+30,0xD.23A04Bp+30,0x6.5D5A57p+10,0xD.23A04Bp+30,0xD.23A04Bp+30},{(-0x2.8p-1),0xD.23A04Bp+30,(-0x2.8p-1),(-0x2.8p-1),0xD.23A04Bp+30,(-0x2.8p-1),(-0x2.8p-1),0xD.23A04Bp+30},{0xD.23A04Bp+30,(-0x2.8p-1),(-0x2.8p-1),0xD.23A04Bp+30,(-0x2.8p-1),(-0x2.8p-1),0xD.23A04Bp+30,(-0x2.8p-1)}};
            float *l_428[5][7] = {{&l_429[0][7],&l_429[3][3],&l_429[1][1],&l_429[0][4],&l_429[0][4],&l_429[0][4],&l_429[0][4]},{&l_429[0][4],&l_429[0][2],&l_429[0][4],&l_429[1][5],&l_429[0][4],&l_429[0][7],&l_429[0][4]},{&l_429[1][1],&l_429[3][3],&l_429[0][7],&l_429[1][5],&l_429[0][7],&l_429[3][3],&l_429[1][1]},{&l_429[3][3],&l_429[0][4],&l_429[0][4],&l_429[0][4],(void*)0,&l_429[0][7],(void*)0},{&l_429[3][3],(void*)0,(void*)0,&l_429[3][3],&l_429[0][4],&l_429[0][4],&l_429[1][5]}};
            float **l_427 = &l_428[0][3];
            float ***l_426[1][4][9] = {{{&l_427,&l_427,&l_427,&l_427,&l_427,(void*)0,(void*)0,&l_427,&l_427},{&l_427,&l_427,&l_427,&l_427,&l_427,&l_427,&l_427,&l_427,&l_427},{&l_427,&l_427,(void*)0,&l_427,&l_427,(void*)0,&l_427,&l_427,&l_427},{&l_427,&l_427,&l_427,&l_427,&l_427,&l_427,&l_427,&l_427,&l_427}}};
            float ****l_425 = &l_426[0][1][6];
            const struct S0 l_433 = {0,-31};
            int i, j, k;
            for (l_403 = 0; (l_403 <= 3); l_403 += 1)
            { /* block id: 284 */
                struct S0 ***l_415[4];
                struct S0 ****l_416 = &l_415[2];
                int i;
                for (i = 0; i < 4; i = i + 1)
                    l_415[i] = (void*)0;
                (*l_416) = l_415[3];
            }
            if (func_75(l_417))
            { /* block id: 287 */
                uint32_t l_424 = 0x94D6FB67;
                for (l_414 = 0; (l_414 <= 3); l_414 += 1)
                { /* block id: 290 */
                    int32_t ***l_422 = &l_405[1];
                    int32_t ****l_421 = &l_422;
                    int i;
                    for (p_65 = 0; (p_65 <= 2); p_65 += 1)
                    { /* block id: 293 */
                        struct S0 **l_419 = (void*)0;
                        struct S0 **l_420 = &l_417;
                        int32_t *****l_423 = &l_421;
                        int i;
                        l_418[0][5] = (void*)0;
                    }
                    (***l_422) = p_66;
                }
                return l_424;
            }
            else
            { /* block id: 301 */
                struct S0 **l_431 = &l_69;
                int32_t *l_432 = &l_403;
                struct S0 l_439[9] = {{1,12},{1,-51},{1,12},{1,12},{1,-51},{1,12},{1,12},{1,-51},{1,12}};
                int i;
                if (((__builtin_parity(p_65) & (l_425 != (void*)0)) != p_65))
                { /* block id: 302 */
                    struct S0 l_430 = {0,-10};
                    l_432 = ((((l_430 , &l_69) == l_431) | (*l_402)) , l_432);
                }
                else
                { /* block id: 304 */
                    l_434 = (p_65 , l_433);
                    (*l_402) = p_66;
                    l_418[0][5] = (void*)0;
                    return p_66;
                }
                (*l_432) = ((((func_75(&l_434) ^ (safe_mod_func_uint16_t_u_u(0x6B4F, func_75((*l_364))))) && ((((func_75(&l_434) , (safe_lshift_func_int16_t_s_u(p_65, 7))) , ((p_65 < 0x4406B3DE) & p_65)) > 0) != 2U)) == 0x5AB1950F) , p_66);
                (*l_417) = l_439[1];
            }
            l_418[0][5] = l_428[1][1];
            /* statement id: 313 */
            //assert (l_418[0][0] == 0 || (l_418[0][0] >= &l_429[0][0] && l_418[0][0] <= &l_429[4][7]));
        }
        else
        { /* block id: 314 */
            uint16_t l_443 = 0xFD7D;
            float l_491 = 0x9.0p+1;
            float *l_490[10];
            float *l_492[10][10] = {{&l_491,&l_491,&l_491,&l_491,(void*)0,&l_491,&l_491,(void*)0,&l_491,&l_491},{(void*)0,(void*)0,&l_491,&l_491,&l_491,&l_491,(void*)0,(void*)0,&l_491,&l_491},{(void*)0,&l_491,&l_491,&l_491,&l_491,&l_491,(void*)0,&l_491,&l_491,&l_491},{&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,(void*)0,&l_491,&l_491},{&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,(void*)0,(void*)0,&l_491,(void*)0},{&l_491,&l_491,&l_491,(void*)0,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491},{&l_491,&l_491,(void*)0,&l_491,&l_491,&l_491,&l_491,&l_491,(void*)0,&l_491},{&l_491,&l_491,(void*)0,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491},{&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491},{&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491,&l_491}};
            int32_t l_494 = 0;
            struct S0 l_499 = {1,-6};
            int i, j;
            for (i = 0; i < 10; i = i + 1)
                l_490[i] = &l_491;
            if (p_65)
            { /* block id: 315 */
                uint32_t l_442 = 0x5A5474C6;
                float ****l_453 = (void*)0;
                float *****l_452 = &l_453;
                struct S0 l_463[8] = {{1,-49},{1,-49},{1,35},{1,-49},{1,-49},{1,35},{1,-49},{1,-49}};
                struct S0 **l_493[10];
                int i;
                for (i = 0; i < 10; i = i + 1)
                    l_493[i] = &l_450;
                if (((safe_add_func_uint16_t_u_u(l_442, (*l_402))) && ((((l_443 | __builtin_ffsll(l_442)) && p_66) != ((safe_sub_func_uint32_t_u_u((p_65 | (safe_add_func_uint16_t_u_u(0x7F93, (p_65 || p_65)))), p_65)) , (-1))) & 0x0EC3F2DD)))
                { /* block id: 316 */
                    struct S0 l_462 = {1,38};
                    if ((!(~func_75(l_450))))
                    { /* block id: 317 */
                        return l_442;
                    }
                    else
                    { /* block id: 319 */
                        l_452 = l_451;
                        /* statement id: 320 */
                        assert (l_452 == 0);
                    }
                    /* facts after branching */
                    assert (l_452 == 0);
                    for (l_442 = 0; (l_442 > 56); l_442 = safe_add_func_int16_t_s_s(l_442, 3))
                    { /* block id: 324 */
                        int32_t l_458 = 1;
                        uint32_t l_459 = 0xA31A0487;
                        l_459 = (safe_sub_func_float_f_f(__builtin_ctzl(l_458), p_66));
                    }
                    for (l_403 = (-29); (l_403 <= (-5)); l_403 = safe_add_func_int16_t_s_s(l_403, 1))
                    { /* block id: 329 */
                        l_402 = &p_66;
                        /* statement id: 330 */
                        assert (l_402 == &p_66);
                        l_463[6] = l_462;
                        return p_66;
                    }
                    for (l_442 = 0; l_442 < 3; l_442 += 1)
                    {
                        l_363[l_442] = &l_450;
                    }
                    //assert (l_363[0] == &l_450 || l_363[0] == &l_69);
                }
                else
                { /* block id: 335 */
                    int16_t l_464 = 9;
                    struct S0 *l_475[10] = {&l_70,&l_434,&l_70,&l_434,&l_70,&l_434,&l_70,&l_434,&l_70,&l_434};
                    int i;
                    if (p_66)
                    { /* block id: 336 */
                        float **l_474 = (void*)0;
                        l_464 = 0xA1109BFE;
                        (*l_402) = ((-0x1.Ep-1) > (((p_66 , ((safe_add_func_float_f_f(((safe_sub_func_float_f_f((func_75(func_77((p_65 ^ (((safe_lshift_func_uint16_t_u_u(__builtin_clz(__builtin_clz(func_75(&l_434))), ((l_473[1][0][0] != l_474) ^ 0x2936))) <= (*l_402)) > 0x5252CC8E)), p_65, l_475[4], p_65, l_464)) >= p_65), p_65)) != p_65), p_66)) == 0xB.3DE23Ep+25)) >= p_65) == l_464));
                    }
                    else
                    { /* block id: 339 */
                        return p_66;
                    }
                    (*l_402) = (safe_sub_func_uint16_t_u_u((p_66 && p_65), ((safe_lshift_func_int16_t_s_u(((safe_rshift_func_uint16_t_u_s((safe_add_func_int32_t_s_s((safe_add_func_int32_t_s_s(0, ((!((p_66 , ((*l_402) <= ((*l_402) , 0x26C908BA))) < (!func_75(&l_434)))) < 0xED9D69DA))), 1)), 6)) == (*l_402)), p_65)) | 0x882C)));
                }
                /* facts after branching */
                //assert (l_363[0] == &l_450 || l_363[0] == &l_69);
                assert (l_452 == &l_453 || l_452 == 0);
                if ((safe_add_func_uint16_t_u_u((*l_402), ((0xDBE755F0 ^ (l_442 , l_463[6].f0)) , ((l_490[6] != l_492[1][2]) || (&l_473[1][1][0] != (void*)0))))))
                { /* block id: 344 */
                    struct S0 *l_496 = &l_434;
                    l_494 = (l_493[2] != l_493[1]);
                    (*l_402) = (+(p_66 <= (l_496 != &l_434)));
                }
                else
                { /* block id: 347 */
                    struct S0 l_497 = {1,26};
                    (*l_450) = l_497;
                    (*l_402) = func_75(&l_434);
                    for (l_494 = 9; (l_494 >= 0); l_494 -= 1)
                    { /* block id: 352 */
                        int32_t *l_498[5] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                        int i;
                        l_402 = l_498[2];
                    }
                    /* facts after for loop */
                    assert (l_402 == 0 || l_402 == &l_403);
                }
                /* facts after branching */
                assert (l_402 == 0 || l_402 == &l_403);
            }
            else
            { /* block id: 356 */
                uint16_t l_513[3][9];
                int32_t l_514 = 0x7DD07D60;
                float ***l_519 = &l_473[0][1][4];
                float ****l_518[10][6][1] = {{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}},{{&l_519},{&l_519},{&l_519},{&l_519},{&l_519},{&l_519}}};
                float *****l_517 = &l_518[9][0][0];
                int i, j, k;
                for (i = 0; i < 3; i = i + 1)
                {
                    for (j = 0; j < 9; j = j + 1)
                        l_513[i][j] = 1U;
                }
                (*l_417) = l_499;
                for (p_65 = 0; (p_65 >= 22); p_65 = safe_add_func_int16_t_s_s(p_65, 1))
                { /* block id: 360 */
                    int32_t *l_502 = &l_494;
                    l_502 = &l_494;
                    return l_503;
                }
                for (l_494 = 0; (l_494 <= 3); l_494 += 1)
                { /* block id: 366 */
                    uint32_t l_515[4][6][3] = {{{0xF1835DE4,1U,0x32753B20},{9U,0x7C43A5B1,0x7ABA84B9},{4294967292U,0xF59FB5F4,4294967295U},{4294967295U,4294967295U,0xE2B52312},{4294967292U,0xF1835DE4,0xF59FB5F4},{9U,0xE2B52312,9U}},{{0xF1835DE4,8U,8U},{1U,9U,9U},{0x32753B20,0xBEE2DFE1,0xF59FB5F4},{0x7ABA84B9,0xA77C823C,0xE2B52312},{4294967295U,4294967290U,4294967295U},{0xE2B52312,0xA77C823C,0x7ABA84B9}},{{0xF59FB5F4,0xBEE2DFE1,0x32753B20},{9U,9U,1U},{8U,8U,0xF1835DE4},{9U,0xE2B52312,9U},{0xF59FB5F4,0xF1835DE4,4294967292U},{0xE2B52312,4294967295U,4294967295U}},{{4294967295U,0xF59FB5F4,4294967292U},{0x7ABA84B9,0x7C43A5B1,9U},{0x32753B20,1U,0xF1835DE4},{1U,4294967287U,0xA77C823C},{8U,0xF1835DE4,4294967295U},{4294967287U,9U,1U}}};
                    float *****l_516 = (void*)0;
                    int i, j, k;
                    for (l_503 = 0; (l_503 <= 3); l_503 += 1)
                    { /* block id: 369 */
                        struct S0 l_504[3] = {{1,63},{1,63},{1,63}};
                        int i;
                        l_514 = ((l_504[1] , (safe_add_func_float_f_f(0x1.Ep+1, (0x3.2752A7p+36 >= l_504[1].f0)))) == (safe_sub_func_float_f_f(__builtin_ctzll((p_65 , (((safe_sub_func_uint32_t_u_u((p_65 <= (safe_rshift_func_int16_t_s_u(0xCCAA, 4))), ((((p_65 && l_513[1][6]) ^ 0x493DAA7E) && 0xD0027B49) < p_66))) & p_66) >= p_66))), p_65)));
                        return l_515[1][1][0];
                    }
                    p_66 = p_65;
                    for (l_443 = 0; (l_443 <= 3); l_443 += 1)
                    { /* block id: 376 */
                        l_517 = l_516;
                        /* statement id: 377 */
                        assert (l_517 == 0);
                    }
                }
                /* facts after for loop */
                assert (l_517 == 0 || (l_517 >= &l_518[0][0][0] && l_517 <= &l_518[9][5][0]));
            }
            /* facts after branching */
            //assert (l_363[0] == &l_450 || l_363[0] == &l_69);
            assert (l_402 == 0 || l_402 == &l_403);
        }
        /* facts after branching */
        //assert (l_363[0] == &l_450 || l_363[0] == &l_69);
        assert (l_402 == 0 || l_402 == &l_403);
        p_66 = ((l_70.f0 & (__builtin_bswap32((p_65 <= (safe_lshift_func_int16_t_s_s((((~l_523) >= (safe_rshift_func_int16_t_s_u(p_66, 14))) != l_70.f0), 10)))) <= __builtin_clzl((p_66 , ((safe_add_func_int32_t_s_s(((((__builtin_popcount(p_66) || p_66) , 0x51DA55F1) == p_66) >= 0xBEEC8E51), l_503)) ^ p_65))))) > p_65);
        (*l_529) = func_67(&l_434);
        /* statement id: 383 */
        assert (l_417 == 0 || l_417 == &l_434);
    }
    /* facts after branching */
    //assert (l_363[0] == &l_450 || l_363[0] == &l_69);
    assert (l_402 == 0 || l_402 == &l_403);
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0 * func_67(struct S0 * p_68)
{ /* block id: 48 */
    const uint16_t l_71 = 0x9135;
    uint32_t l_88 = 4294967294U;
    int32_t l_131 = 0x265A2DF7;
    int32_t *l_130 = &l_131;
    struct S0 l_133[3][2][5] = {{{{0,2},{0,23},{0,-46},{0,-46},{0,23}},{{0,2},{0,23},{0,-46},{0,-46},{0,23}}},{{{0,2},{0,23},{0,-46},{0,-46},{0,23}},{{0,2},{0,23},{0,-46},{0,-46},{0,23}}},{{{0,2},{0,23},{0,-46},{0,-46},{0,23}},{{0,2},{0,23},{0,-46},{0,-46},{0,23}}}};
    struct S0 *l_132 = &l_133[0][1][4];
    uint32_t l_198 = 0U;
    const float **l_246 = (void*)0;
    struct S0 **l_284 = &l_132;
    struct S0 ***l_283 = &l_284;
    struct S0 ****l_282 = &l_283;
    int32_t **l_356 = &l_130;
    const struct S0 *l_358 = &l_133[2][0][3];
    const struct S0 *l_359 = &l_133[0][1][4];
    const struct S0 *l_360[5];
    const struct S0 *l_361 = &l_133[0][1][4];
    const struct S0 *l_362 = (void*)0;
    int i, j, k;
    for (i = 0; i < 5; i = i + 1)
        l_360[i] = &l_133[0][1][4];
    if (l_71)
    { /* block id: 49 */
        uint32_t l_72 = 0xB686461D;
        struct S0 l_90 = {1,-31};
        struct S0 *l_89[5][3][2] = {{{&l_90,&l_90},{&l_90,&l_90},{&l_90,&l_90}},{{&l_90,&l_90},{&l_90,&l_90},{(void*)0,&l_90}},{{&l_90,&l_90},{&l_90,&l_90},{&l_90,&l_90}},{{(void*)0,&l_90},{&l_90,&l_90},{&l_90,&l_90}},{{&l_90,&l_90},{&l_90,&l_90},{&l_90,&l_90}}};
        int32_t l_104[4] = {(-1),(-1),(-1),(-1)};
        int32_t *l_103 = &l_104[2];
        float l_193 = (-0x2.4p+1);
        float *l_192 = &l_193;
        float **l_191 = &l_192;
        int16_t l_268[4];
        uint32_t l_273 = 0x6D0909EE;
        int i, j, k;
        for (i = 0; i < 4; i = i + 1)
            l_268[i] = 4;
        (*l_103) = (((l_72 >= l_72) , ((safe_rshift_func_uint16_t_u_u((func_75(func_77((((safe_mod_func_uint32_t_u_u(0x68F5B79C, (safe_rshift_func_int16_t_s_u(l_72, ((l_71 , (__builtin_popcount(l_71) >= (!__builtin_ffsl(((l_72 <= ((((((*p_68) , l_71) , 0) , l_71) == l_72) ^ l_71)) > l_71))))) , l_71))))) ^ l_72) , l_72), l_88, l_89[0][1][0], l_72, l_90.f0)) | l_71), 12)) && l_71)) , l_88);
        if ((*l_103))
        { /* block id: 58 */
            const float l_114 = 0x9.B7B1ACp+95;
            int32_t l_115 = 0x6C34CEF8;
            int32_t *l_124 = &l_104[2];
            int32_t **l_136 = &l_124;
            int16_t l_148 = 0;
            for (l_72 = 0; (l_72 != 58); l_72 = safe_add_func_int16_t_s_s(l_72, 1))
            { /* block id: 61 */
                struct S0 *l_112 = &l_90;
                int32_t l_113[3];
                struct S0 l_117 = {0,39};
                int32_t **l_125 = &l_124;
                float l_134 = 0xD.0EEEB2p-2;
                float *l_135 = &l_134;
                int i;
                for (i = 0; i < 3; i = i + 1)
                    l_113[i] = 0;
                for (l_88 = 0; (l_88 <= 3); l_88 += 1)
                { /* block id: 64 */
                    int i;
                    if ((((((safe_rshift_func_int16_t_s_s(0xDC41, (~((safe_mod_func_uint32_t_u_u((l_104[l_88] , (l_104[l_88] == ((l_88 , (((&l_104[2] != (void*)0) , l_112) == ((*l_103) , ((((l_113[1] || l_113[2]) < l_115) | (-1)) , (void*)0)))) , l_104[l_88]))), l_113[0])) ^ l_88)))) ^ l_71) , l_113[2]) , 0xB5FA) <= 0xCAF6))
                    { /* block id: 65 */
                        l_89[0][1][0] = ((!l_71) , p_68);
                    }
                    else
                    { /* block id: 67 */
                        l_117 = (*p_68);
                    }
                    for (l_115 = 1; (l_115 >= 0); l_115 -= 1)
                    { /* block id: 72 */
                        uint16_t l_122 = 1U;
                        int32_t *l_123 = &l_115;
                        int i, j, k;
                        (*l_103) = (safe_sub_func_uint32_t_u_u(((l_115 | (safe_add_func_int16_t_s_s((__builtin_parity(l_71) , l_117.f1), (l_122 < l_113[1])))) != l_104[l_88]), (((l_104[l_88] ^ 1U) , 65529U) , l_71)));
                        l_89[(l_115 + 1)][l_115][l_115] = func_77(((l_104[l_88] > 4294967295U) == l_71), (((*l_103) | ((void*)0 == l_89[l_88][(l_115 + 1)][l_115])) == ((-1) != ((l_115 , &l_115) != l_123))), p_68, (*l_103), l_117.f0);
                        if ((*l_103))
                            continue;
                        l_124 = &l_104[2];
                        /* statement id: 76 */
                        assert ((l_124 >= &l_104[0] && l_124 <= &l_104[3]));
                    }
                }
                if ((*l_103))
                    continue;
                if (l_71)
                    goto lbl_357;
                (*l_125) = &l_115;
                /* statement id: 80 */
                assert (l_124 == &l_115);
                (*l_135) = (((safe_add_func_float_f_f((*l_124), ((((func_75(func_77((safe_sub_func_uint32_t_u_u(((**l_125) > ((void*)0 != l_130)), (*l_124))), ((void*)0 == &l_90), func_77((*l_124), (func_75(l_132) < 4), p_68, (**l_125), (*l_103)), (*l_124), (**l_125))) | (**l_125)) , 0xF.AF86A2p+48) < (*l_103)) < l_134))) > (*l_103)) != (*l_124));
            }
            /* facts after for loop */
            //assert (l_89[0][0][0] == &l_70 || l_89[0][0][0] == 0 || l_89[0][0][0] == &l_90 || l_89[0][0][0] == &l_434 || l_89[0][0][0] == &l_809);
            assert (l_124 == &l_115 || (l_124 >= &l_104[0] && l_124 <= &l_104[3]));
            (*l_136) = (void*)0;
            /* statement id: 83 */
            assert (l_124 == 0);
            if (((0x115AE511 < 0x292229A3) & ((!__builtin_parityl((65527U & (*l_130)))) , (((safe_mod_func_uint16_t_u_u(((*l_130) != (safe_lshift_func_uint16_t_u_u(0x8751, 3))), (((safe_rshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_u(((*l_130) & ((*l_103) > (*l_130))), 10)), 4)) ^ l_148) , (*l_130)))) , (*l_130)) <= (-7)))))
            { /* block id: 84 */
                uint32_t l_149[7] = {0x8A2AEEF2,0x8A2AEEF2,0x598743DC,0x8A2AEEF2,0x8A2AEEF2,0x598743DC,0x8A2AEEF2};
                int i;
                (*l_130) = l_149[1];
            }
            else
            { /* block id: 86 */
                int32_t l_154 = 0;
                int32_t *l_166 = &l_104[2];
                for (l_88 = (-13); (l_88 == 2); l_88 = safe_add_func_int16_t_s_s(l_88, 1))
                { /* block id: 89 */
                    struct S0 **l_157 = &l_132;
                    int32_t l_162 = (-7);
                    for (l_72 = 0; (l_72 <= 39); l_72 = safe_add_func_uint16_t_u_u(l_72, 4))
                    { /* block id: 92 */
                        (*l_130) = (*l_130);
                        (*p_68) = (*p_68);
                    }
                    l_154 = (*l_103);
                    (*p_68) = (*p_68);
                    if ((((*p_68) , l_103) == ((*l_130) , l_130)))
                    { /* block id: 98 */
                        int32_t *l_155[5][4][7] = {{{&l_131,&l_104[2],&l_115,&l_104[0],(void*)0,&l_115,&l_104[2]},{&l_104[2],&l_104[2],&l_115,&l_115,&l_115,&l_115,&l_115},{&l_115,(void*)0,&l_115,(void*)0,(void*)0,&l_115,&l_115},{(void*)0,(void*)0,&l_115,&l_104[2],&l_104[2],&l_104[2],&l_104[2]}},{{&l_115,&l_131,&l_104[1],&l_104[1],&l_131,&l_115,&l_104[0]},{&l_104[3],&l_115,&l_104[2],&l_115,&l_115,&l_115,&l_104[2]},{&l_131,&l_115,(void*)0,&l_115,&l_104[0],&l_115,(void*)0},{&l_115,&l_115,&l_104[2],&l_131,&l_115,(void*)0,&l_115}},{{&l_104[0],&l_131,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_115,(void*)0,&l_115,(void*)0,&l_115,&l_115,&l_104[1]},{&l_104[0],(void*)0,&l_131,&l_104[2],&l_104[0],(void*)0,&l_115},{(void*)0,&l_104[2],&l_131,&l_115,&l_115,&l_131,&l_104[2]}},{{&l_104[0],&l_104[2],(void*)0,&l_104[0],&l_131,(void*)0,(void*)0},{&l_115,(void*)0,&l_115,&l_115,&l_104[2],&l_115,&l_104[2]},{&l_104[0],&l_104[2],&l_104[2],&l_104[0],(void*)0,(void*)0,&l_131},{&l_115,&l_104[2],&l_115,&l_115,&l_115,&l_104[2],&l_115}},{{&l_104[2],(void*)0,&l_131,&l_104[0],&l_131,(void*)0,&l_104[2]},{&l_104[2],&l_104[1],&l_104[2],&l_115,&l_115,&l_104[2],&l_115},{&l_104[0],&l_115,&l_104[1],&l_131,(void*)0,(void*)0,&l_131},{&l_104[2],&l_104[2],&l_104[2],&l_104[3],&l_104[2],(void*)0,&l_104[2]}}};
                        int32_t ***l_156 = &l_136;
                        int i, j, k;
                        l_155[2][0][5] = &l_104[2];
                        (*l_136) = &l_131;
                        /* statement id: 100 */
                        assert (l_124 == &l_131);
                        l_156 = &l_136;
                    }
                    else
                    { /* block id: 102 */
                        uint16_t l_165[10] = {0x43E2,0x43E2,0x43E2,0x43E2,0x43E2,0x43E2,0x43E2,0x43E2,0x43E2,0x43E2};
                        int i;
                        l_157 = l_157;
                        (*l_103) = (safe_sub_func_float_f_f(((*l_132) , (((*l_130) && ((l_162 && (65528U == l_154)) < ((safe_mod_func_int16_t_s_s((__builtin_bswap64(((*l_130) || (*l_103))) != l_154), l_154)) , (*l_130)))) , l_154)), l_165[2]));
                        if (l_154)
                            break;
                        l_130 = &l_131;
                    }
                }
                /* facts after for loop */
                assert (l_124 == 0 || l_124 == &l_131);
                if ((*l_130))
                { /* block id: 109 */
                    if (((*l_103) && func_75(&l_133[2][0][4])))
                    { /* block id: 110 */
                        l_103 = l_166;
                    }
                    else
                    { /* block id: 112 */
                        int32_t ****l_167 = (void*)0;
                        int32_t ***l_169[1][1][5];
                        int32_t ****l_168 = &l_169[0][0][4];
                        int i, j, k;
                        for (i = 0; i < 1; i = i + 1)
                        {
                            for (j = 0; j < 1; j = j + 1)
                            {
                                for (k = 0; k < 5; k = k + 1)
                                    l_169[i][j][k] = &l_136;
                            }
                        }
                        (*l_168) = &l_136;
                    }
                    (*l_136) = &l_104[2];
                    /* statement id: 115 */
                    assert ((l_124 >= &l_104[0] && l_124 <= &l_104[3]));
                }
                else
                { /* block id: 116 */
                    (*l_103) = __builtin_popcount((*l_166));
                }
                /* facts after branching */
                assert (l_124 == 0 || l_124 == &l_131 || (l_124 >= &l_104[0] && l_124 <= &l_104[3]));
                (*l_136) = &l_104[2];
                /* statement id: 119 */
                assert ((l_124 >= &l_104[0] && l_124 <= &l_104[3]));
                for (l_115 = 0; (l_115 != (-15)); l_115 = safe_sub_func_int16_t_s_s(l_115, 5))
                { /* block id: 122 */
                    uint32_t l_190 = 0U;
                    float ***l_194[4] = {&l_191,&l_191,&l_191,&l_191};
                    int i;
                    (**l_136) = (safe_rshift_func_int16_t_s_u((__builtin_ffs((~(~((safe_sub_func_float_f_f((safe_add_func_float_f_f((*l_103), (safe_sub_func_float_f_f(__builtin_parity((*l_103)), (*l_103))))), (*l_124))) , (safe_rshift_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(((((((safe_sub_func_int32_t_s_s((safe_add_func_uint32_t_u_u((((*l_130) , (-3)) , (*l_103)), (-4))), (*l_103))) , (*l_124)) != 0xA109) | l_190) | (*l_130)) || 0x70C6), (*l_130))), 13)))))) != l_190), 0));
                    l_191 = l_191;
                    if ((**l_136))
                    { /* block id: 125 */
                        (*l_132) = (*p_68);
                        (*l_136) = &l_131;
                        /* statement id: 127 */
                        assert (l_124 == &l_131);
                    }
                    else
                    { /* block id: 128 */
                        const struct S0 *l_196 = &l_90;
                        const struct S0 **l_195 = &l_196;
                        (*l_136) = (*l_136);
                        (*l_124) = ((&l_89[0][1][0] != ((((*l_136) == (void*)0) < __builtin_bswap32(l_190)) , l_195)) && (*l_103));
                    }
                    (*l_130) = (*l_103);
                }
                /* facts after for loop */
                assert ((l_124 >= &l_104[0] && l_124 <= &l_104[3]) || l_124 == &l_131);
            }
            /* facts after branching */
            assert ((l_124 >= &l_104[0] && l_124 <= &l_104[3]) || l_124 == &l_131 || l_124 == 0);
        }
        else
        { /* block id: 135 */
            struct S0 l_197 = {1,-11};
            int32_t **l_208 = &l_130;
            int32_t ***l_207 = &l_208;
            struct S0 **l_221 = &l_89[0][1][0];
            struct S0 ****l_240 = (void*)0;
            (*l_132) = l_197;
            if (__builtin_parityl(l_198))
            { /* block id: 137 */
lbl_215:
                for (l_88 = 0; (l_88 >= 33); l_88 = safe_add_func_uint16_t_u_u(l_88, 1))
                { /* block id: 140 */
                    return p_68;
                    /* statement id: 141 */
                    //assert (func_67_rv == &l_70 || func_67_rv == &l_434 || func_67_rv == &l_809);
                }
            }
            else
            { /* block id: 143 */
                int32_t l_209[4][7][9] = {{{1,0xAA1FC9FD,0x8B1CBCA9,1,0xBCDD2221,0x8B1CBCA9,0x8B1CBCA9,0xBCDD2221,1},{4,0xBBE3BBB7,4,0,(-6),0,4,0xBBE3BBB7,4},{1,0xBCDD2221,0x8B1CBCA9,0x8B1CBCA9,0xBCDD2221,1,0x8B1CBCA9,0xAA1FC9FD,1},{0x2CC53BE7,0xBBE3BBB7,0x2CC53BE7,0,7,0,0x2CC53BE7,0xBBE3BBB7,0x2CC53BE7},{1,0xAA1FC9FD,0x8B1CBCA9,1,0xBCDD2221,0x8B1CBCA9,0x8B1CBCA9,0xBCDD2221,1},{4,0xBBE3BBB7,4,0,(-6),0,4,0xBBE3BBB7,4},{1,0xBCDD2221,0x8B1CBCA9,0x8B1CBCA9,0xBCDD2221,1,0x8B1CBCA9,0xAA1FC9FD,1}},{{0x2CC53BE7,0xBBE3BBB7,0x2CC53BE7,0,7,0,0x2CC53BE7,0xBBE3BBB7,0x2CC53BE7},{1,0xAA1FC9FD,0x8B1CBCA9,1,0xBCDD2221,0x8B1CBCA9,0x8B1CBCA9,0xBCDD2221,1},{4,0xBBE3BBB7,4,0,(-6),0,4,0xBBE3BBB7,4},{1,0xBCDD2221,0x8B1CBCA9,0x8B1CBCA9,0xBCDD2221,1,0x8B1CBCA9,0xAA1FC9FD,1},{0x2CC53BE7,0xBBE3BBB7,0x2CC53BE7,0,7,0,0x2CC53BE7,0xBBE3BBB7,0x2CC53BE7},{1,0xAA1FC9FD,0x8B1CBCA9,1,0xBCDD2221,0x8B1CBCA9,0x8B1CBCA9,0xBCDD2221,1},{4,0xBBE3BBB7,4,0,(-6),0,4,0xBBE3BBB7,4}},{{1,0xBCDD2221,0x8B1CBCA9,0x8B1CBCA9,0xBCDD2221,1,0x8B1CBCA9,0xAA1FC9FD,1},{0x2CC53BE7,0xBBE3BBB7,0x2CC53BE7,0,7,0,0x2CC53BE7,0xBBE3BBB7,0x2CC53BE7},{1,0xAA1FC9FD,0x8B1CBCA9,0xF5187878,1,0,0,1,0xF5187878},{0x9CBAC53C,0,0x9CBAC53C,0x9656563E,4,0x9656563E,0x9CBAC53C,0,0x9CBAC53C},{0xF5187878,1,0,0,1,0xF5187878,0,0x8B1CBCA9,0xF5187878},{0x17E4DA92,0,0x17E4DA92,0x9656563E,0x2CC53BE7,0x9656563E,0x17E4DA92,0,0x17E4DA92},{0xF5187878,0x8B1CBCA9,0,0xF5187878,1,0,0,1,0xF5187878}},{{0x9CBAC53C,0,0x9CBAC53C,0x9656563E,4,0x9656563E,0x9CBAC53C,0,0x9CBAC53C},{0xF5187878,1,0,0,1,0xF5187878,0,0x8B1CBCA9,0xF5187878},{0x17E4DA92,0,0x17E4DA92,0x9656563E,0x2CC53BE7,0x9656563E,0x17E4DA92,0,0x17E4DA92},{0xF5187878,0x8B1CBCA9,0,0xF5187878,1,0,0,1,0xF5187878},{0x9CBAC53C,0,0x9CBAC53C,0x9656563E,4,0x9656563E,0x9CBAC53C,0,0x9CBAC53C},{0xF5187878,1,0,0,1,0xF5187878,0,0x8B1CBCA9,0xF5187878},{0x17E4DA92,0,0x17E4DA92,0x9656563E,0x2CC53BE7,0x9656563E,0x17E4DA92,0,0x17E4DA92}}};
                uint32_t l_213 = 0x32E5C04B;
                struct S0 ***l_234[4][4] = {{&l_221,&l_221,&l_221,&l_221},{&l_221,&l_221,&l_221,&l_221},{&l_221,&l_221,&l_221,&l_221},{&l_221,&l_221,&l_221,&l_221}};
                struct S0 ****l_241 = (void*)0;
                int i, j, k;
                if ((safe_mod_func_int16_t_s_s(l_197.f1, (*l_103))))
                { /* block id: 144 */
                    uint32_t l_210 = 0x445E9411;
                    if (((&l_132 == (void*)0) <= ((((((l_207 != &l_208) || l_209[1][3][3]) >= l_210) | ((safe_add_func_uint32_t_u_u(0xFD0F9B15, 0xC5CD07EA)) != l_209[1][3][6])) && 0xC8ED) == l_213)))
                    { /* block id: 145 */
                        const uint32_t l_214 = 0x9128E193;
                        (**l_208) = l_213;
                        (*l_130) = (0xDA43A824 <= ((**l_208) < l_214));
                        if (l_71)
                            goto lbl_215;
                        (**l_207) = &l_104[2];
                        /* statement id: 149 */
                        assert ((l_130 >= &l_104[0] && l_130 <= &l_104[3]));
                    }
                    else
                    { /* block id: 150 */
                        uint32_t l_216 = 0xE2E7F7A6;
                        int32_t **l_217 = &l_103;
                        struct S0 **l_218[7];
                        int i;
                        for (i = 0; i < 7; i = i + 1)
                            l_218[i] = (void*)0;
                        (*p_68) = (*p_68);
                        (***l_207) = ((*l_130) >= ((l_216 <= (func_75(p_68) && ((l_210 && 0xAAAE0652) <= (**l_208)))) > ((void*)0 != l_217)));
                        l_89[0][1][0] = p_68;
                        /* statement id: 153 */
                        //assert (l_89[0][0][0] == &l_70 || l_89[0][0][0] == 0 || l_89[0][0][0] == &l_90 || l_89[0][0][0] == &l_434 || l_89[0][0][0] == &l_809);
                        (*l_217) = &l_104[2];
                    }
                    /* facts after branching */
                    //assert (l_89[0][0][0] == &l_70 || l_89[0][0][0] == 0 || l_89[0][0][0] == &l_90 || l_89[0][0][0] == &l_434 || l_89[0][0][0] == &l_809);
                    assert (l_130 == &l_131 || (l_130 >= &l_104[0] && l_130 <= &l_104[3]));
                    for (l_210 = 9; (l_210 > 53); l_210 = safe_add_func_int16_t_s_s(l_210, 9))
                    { /* block id: 158 */
                        if ((**l_208))
                            break;
                        (*l_130) = 0x0.Cp+1;
                        return p_68;
                        /* statement id: 161 */
                        //assert (func_67_rv == &l_70 || func_67_rv == &l_434 || func_67_rv == &l_809);
                    }
                    if ((((l_221 != &p_68) || (((&l_208 == (void*)0) , (safe_rshift_func_int16_t_s_s((((safe_mod_func_uint32_t_u_u((safe_sub_func_uint16_t_u_u(((*l_130) || ((l_210 , ((safe_sub_func_int16_t_s_s((__builtin_clz(((safe_mod_func_uint32_t_u_u(4294967295U, (**l_208))) >= func_75(p_68))) && l_210), 0U)) || 0xD823)) < 4294967292U)), l_210)), (*l_130))) ^ 1U) == 0xD70B6333), 4))) != (*l_130))) , l_213))
                    { /* block id: 163 */
                        int32_t *l_232 = (void*)0;
                        (**l_207) = l_232;
                        /* statement id: 164 */
                        assert (l_130 == 0);
                    }
                    else
                    { /* block id: 165 */
                        int32_t ****l_233 = &l_207;
                        const struct S0 ****l_235 = (void*)0;
                        struct S0 ****l_236[10] = {&l_234[3][1],&l_234[3][1],(void*)0,&l_234[3][1],&l_234[3][1],(void*)0,&l_234[3][1],&l_234[3][1],(void*)0,&l_234[3][1]};
                        int i;
                        (*l_233) = &l_208;
                        l_234[1][3] = l_234[3][1];
                        (*l_208) = &l_104[0];
                        /* statement id: 168 */
                        assert ((l_130 >= &l_104[0] && l_130 <= &l_104[3]));
                    }
                    /* facts after branching */
                    assert ((l_130 >= &l_104[0] && l_130 <= &l_104[3]) || l_130 == 0);
                }
                else
                { /* block id: 170 */
                    int16_t l_237 = 0x660A;
                    struct S0 *l_250 = &l_133[0][1][4];
                    if (((((l_237 <= (((*l_130) < (safe_sub_func_float_f_f((((*l_103) >= (0x1.4p+1 != (**l_208))) != (*l_130)), ((*l_103) == 0x0.9p+1)))) >= (l_240 != l_241))) < (*l_130)) > l_209[1][3][3]) , l_237))
                    { /* block id: 171 */
                        struct S0 l_242[5][3][7] = {{{{0,54},{1,-57},{0,54},{1,-8},{0,61},{0,4},{1,-57}},{{0,30},{0,53},{1,-30},{0,-8},{1,-27},{0,30},{1,22}},{{1,3},{1,61},{0,61},{0,54},{1,34},{0,4},{0,-10}}},{{{1,21},{0,-35},{0,1},{1,-14},{0,1},{0,-35},{1,21}},{{1,60},{0,61},{1,22},{1,61},{0,-40},{1,-30},{0,31}},{{1,-6},{1,-27},{0,55},{1,0},{0,30},{0,8},{1,-27}}},{{{1,-8},{1,34},{1,22},{1,27},{1,-35},{1,-8},{1,-35}},{{0,55},{0,1},{0,1},{0,55},{1,-28},{0,27},{1,-23}},{{0,2},{0,-40},{0,61},{1,34},{1,3},{1,61},{0,61}}},{{{1,-23},{1,-6},{1,22},{0,27},{0,30},{0,1},{0,8}},{{1,22},{1,60},{0,-5},{0,54},{0,54},{0,-5},{1,60}},{{1,-6},{1,21},{0,53},{1,-27},{1,53},{1,-6},{1,2}}},{{{1,62},{1,3},{0,4},{0,-5},{0,-54},{1,27},{0,54}},{{1,0},{0,30},{0,8},{1,-27},{0,27},{0,-47},{0,-47}},{{1,-8},{0,54},{1,-57},{0,54},{1,-8},{0,61},{0,4}}}};
                        const struct S0 l_243 = {1,-63};
                        float ***l_247 = &l_191;
                        int i, j, k;
                        (*p_68) = l_242[2][2][6];
                        (**l_207) = ((l_243 , (safe_mod_func_uint16_t_u_u(func_75(&l_133[0][1][0]), (**l_208)))) , &l_131);
                        (**l_207) = &l_131;
                        (*l_247) = l_246;
                        /* statement id: 175 */
                        assert (l_191 == 0);
                    }
                    else
                    { /* block id: 176 */
                        int32_t *l_248 = &l_209[0][4][8];
                        struct S0 l_249[4] = {{0,-48},{0,-48},{0,-48},{0,-48}};
                        int i;
                        (*l_208) = l_248;
                        /* statement id: 177 */
                        assert ((l_130 >= &l_209[0][0][0] && l_130 <= &l_209[3][6][8]));
                        if (l_197.f0)
                            goto lbl_251;
                        (*p_68) = l_249[2];
lbl_251:
                        p_68 = l_250;
                        /* statement id: 179 */
                        assert ((p_68 >= &l_133[0][0][0] && p_68 <= &l_133[2][1][4]));
                        (*l_208) = (void*)0;
                        /* statement id: 181 */
                        assert (l_130 == 0);
                    }
                    /* facts after branching */
                    //assert ((p_68 >= &l_133[0][0][0] && p_68 <= &l_133[2][1][4]) || p_68 == &l_70 || p_68 == &l_434 || p_68 == &l_809);
                    assert (l_130 == 0 || l_130 == &l_131);
                    assert (l_191 == &l_192 || l_191 == 0);
                }
                /* facts after branching */
                //assert ((p_68 >= &l_133[0][0][0] && p_68 <= &l_133[2][1][4]) || p_68 == &l_70 || p_68 == &l_434 || p_68 == &l_809);
                //assert (l_89[0][0][0] == &l_70 || l_89[0][0][0] == 0 || l_89[0][0][0] == &l_90 || l_89[0][0][0] == &l_434 || l_89[0][0][0] == &l_809);
                assert (l_130 == 0 || l_130 == &l_131 || (l_130 >= &l_104[0] && l_130 <= &l_104[3]));
                assert (l_191 == &l_192 || l_191 == 0);
                for (l_213 = (-3); (l_213 < 45); l_213 = safe_add_func_int32_t_s_s(l_213, 1))
                { /* block id: 186 */
                    const int32_t l_254 = 0x9E3C08EB;
                    (*l_103) = (((void*)0 == &l_234[2][2]) ^ (0U & (l_254 > (l_254 , ((safe_rshift_func_int16_t_s_s((func_75((*l_221)) && (l_254 == l_254)), 10)) & 4294967293U)))));
                }
                (**l_207) = ((*l_103) , (((((+(0xE561 == ((((safe_lshift_func_int16_t_s_u((1 >= l_209[3][4][3]), (func_75((*l_221)) != (safe_lshift_func_uint16_t_u_u((~(((!(l_133[0][1][4].f1 < l_197.f0)) ^ ((safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(0xCA6C, l_209[1][3][3])), (*l_103))) > 0x623C)) >= 0x7A3A9C7E)), 6))))) >= 65535U) >= l_268[0]) ^ 0xBB92))) , 65535U) == (*l_103)) >= l_209[2][0][7]) , (void*)0));
                /* statement id: 189 */
                assert (l_130 == 0);
                (*l_192) = ((safe_add_func_float_f_f(l_213, ((((safe_add_func_float_f_f((-0x9.0p-1), 0x1.F22320p+17)) == (*l_103)) > l_209[0][6][3]) >= (((l_209[0][2][0] != (*l_103)) < (*l_103)) > 0x3.98F95Ap+16)))) < l_273);
            }
            /* facts after branching */
            //assert ((p_68 >= &l_133[0][0][0] && p_68 <= &l_133[2][1][4]) || p_68 == &l_70 || p_68 == &l_434 || p_68 == &l_809);
            //assert (l_89[0][0][0] == &l_70 || l_89[0][0][0] == 0 || l_89[0][0][0] == &l_90 || l_89[0][0][0] == &l_434 || l_89[0][0][0] == &l_809);
            assert (l_130 == 0 || l_130 == &l_131);
            assert (l_191 == &l_192 || l_191 == 0);
        }
        /* facts after branching */
        //assert ((p_68 >= &l_133[0][0][0] && p_68 <= &l_133[2][1][4]) || p_68 == &l_70 || p_68 == &l_434 || p_68 == &l_809);
        //assert (l_89[0][0][0] == &l_70 || l_89[0][0][0] == 0 || l_89[0][0][0] == &l_90 || l_89[0][0][0] == &l_434 || l_89[0][0][0] == &l_809);
        assert (l_130 == 0 || l_130 == &l_131);
        assert (l_191 == &l_192 || l_191 == 0);
    }
    else
    { /* block id: 193 */
        int32_t l_285 = 0x1DA71828;
        int32_t l_338 = 3;
        int32_t l_343 = 0x75C88BA1;
        int32_t **l_355 = (void*)0;
        int32_t ***l_354 = &l_355;
        for (l_198 = 0; (l_198 >= 1); l_198 = safe_add_func_int32_t_s_s(l_198, 9))
        { /* block id: 196 */
            int16_t l_286[10][10] = {{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)},{0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1),0xCB5D,(-1)}};
            struct S0 *l_297 = (void*)0;
            const float ***l_302 = (void*)0;
            int32_t *l_344[2][1];
            int32_t **l_347 = &l_344[0][0];
            int32_t ***l_346 = &l_347;
            int i, j;
            for (i = 0; i < 2; i = i + 1)
            {
                for (j = 0; j < 1; j = j + 1)
                    l_344[i][j] = &l_285;
            }
            if ((((((safe_sub_func_float_f_f((safe_sub_func_float_f_f(((safe_add_func_float_f_f((l_282 != (void*)0), 0xC.713B82p-50)) != __builtin_clzl(l_285)), l_286[3][5])), (safe_add_func_float_f_f(((((l_285 == (*l_130)) , func_75(func_77(func_75((***l_282)), (*l_130), p_68, (*l_130), l_285))) != l_286[3][5]) <= 0x1.Ep+1), 0xC.3CC2A6p+44)))) , 0U) <= l_285) > (-1)) , l_285))
            { /* block id: 197 */
                (*l_130) = (-3);
                for (l_285 = (-20); (l_285 <= (-30)); l_285 = safe_sub_func_uint32_t_u_u(l_285, 3))
                { /* block id: 201 */
                    const struct S0 *l_291 = &l_133[0][1][4];
                    return p_68;
                    /* statement id: 202 */
                    //assert (func_67_rv == &l_70 || func_67_rv == &l_434 || func_67_rv == &l_809);
                }
            }
            else
            { /* block id: 204 */
                int32_t l_296 = (-1);
                struct S0 ***l_341 = (void*)0;
                for (l_131 = 0; (l_131 >= (-9)); l_131 = safe_sub_func_uint32_t_u_u(l_131, 4))
                { /* block id: 207 */
                    uint16_t l_300 = 0U;
                    float **l_323 = (void*)0;
                    int32_t *l_325 = (void*)0;
                    float l_331[10];
                    float *l_330[10][10] = {{&l_331[8],&l_331[3],&l_331[6],&l_331[3],&l_331[8],&l_331[6],(void*)0,(void*)0,&l_331[6],&l_331[8]},{&l_331[8],&l_331[0],&l_331[0],&l_331[8],&l_331[1],&l_331[8],&l_331[8],&l_331[8],&l_331[1],&l_331[8]},{&l_331[8],&l_331[8],&l_331[8],&l_331[1],&l_331[8],&l_331[0],&l_331[0],&l_331[8],&l_331[1],&l_331[8]},{(void*)0,(void*)0,&l_331[6],&l_331[8],&l_331[3],&l_331[6],&l_331[3],&l_331[8],&l_331[6],(void*)0},{&l_331[3],&l_331[6],&l_331[8],&l_331[1],&l_331[3],&l_331[3],&l_331[1],&l_331[8],&l_331[6],&l_331[1]},{&l_331[8],&l_331[8],&l_331[6],&l_331[3],&l_331[8],&l_331[3],&l_331[6],&l_331[8],&l_331[8],&l_331[8]},{&l_331[1],&l_331[0],(void*)0,&l_331[8],&l_331[8],(void*)0,&l_331[0],&l_331[1],(void*)0,&l_331[1]},{&l_331[8],&l_331[6],&l_331[3],&l_331[8],&l_331[3],&l_331[6],&l_331[8],&l_331[8],&l_331[8],&l_331[8]},{&l_331[8],&l_331[1],&l_331[3],&l_331[3],&l_331[1],&l_331[8],&l_331[6],&l_331[1],&l_331[6],&l_331[8]},{&l_331[0],&l_331[1],(void*)0,&l_331[1],&l_331[0],(void*)0,&l_331[8],&l_331[8],(void*)0,&l_331[0]}};
                    struct S0 l_332 = {1,-24};
                    uint32_t l_337[6][6] = {{0x04CCA799,0xF53EBCDE,0xF53EBCDE,0x04CCA799,0xF53EBCDE,0xF53EBCDE},{0x04CCA799,0xF53EBCDE,0xF53EBCDE,0x04CCA799,0xF53EBCDE,0xF53EBCDE},{0x04CCA799,0xF53EBCDE,0xF53EBCDE,0x04CCA799,0xF53EBCDE,0xF53EBCDE},{0x04CCA799,0xF53EBCDE,0xF53EBCDE,0x04CCA799,0xF53EBCDE,0xF53EBCDE},{0x04CCA799,0xF53EBCDE,0xF53EBCDE,0x04CCA799,0xF53EBCDE,0xF53EBCDE},{0x04CCA799,0xF53EBCDE,0xF53EBCDE,0x04CCA799,0xF53EBCDE,0xF53EBCDE}};
                    int i, j;
                    for (i = 0; i < 10; i = i + 1)
                        l_331[i] = 0xD.36A48Ep-53;
                    if ((safe_add_func_uint16_t_u_u(l_296, ((func_75(l_297) , (__builtin_ctz(__builtin_ctzll(l_296)) , ((3 ^ (safe_sub_func_int16_t_s_s((((((-1) < (l_285 < l_285)) != l_286[3][5]) | l_300) || l_286[2][7]), l_285))) > l_285))) & l_286[6][5]))))
                    { /* block id: 208 */
                        int32_t l_301[5][3][7] = {{{9,9,0xE6CA84D6,0x44118BEC,0xF496A8B9,0x44118BEC,0xE6CA84D6},{(-1),(-1),0xEBA78A47,(-8),0xA77F9E04,(-8),0xEBA78A47},{9,9,0xE6CA84D6,0x44118BEC,0xF496A8B9,0x44118BEC,0xE6CA84D6}},{{(-1),(-1),0xEBA78A47,(-8),0xA77F9E04,(-8),0xEBA78A47},{9,9,0xE6CA84D6,0x44118BEC,0xF496A8B9,0x44118BEC,0xE6CA84D6},{(-1),(-1),0xEBA78A47,(-8),0xA77F9E04,(-8),0xEBA78A47}},{{9,9,0xE6CA84D6,0x44118BEC,0xF496A8B9,0x44118BEC,0xE6CA84D6},{(-1),(-1),0xEBA78A47,(-8),0xA77F9E04,(-8),0xEBA78A47},{9,9,0xE6CA84D6,0x44118BEC,0xF496A8B9,0x44118BEC,0xE6CA84D6}},{{(-1),(-1),0xEBA78A47,(-8),0xA77F9E04,(-8),0xEBA78A47},{9,9,0xE6CA84D6,0x44118BEC,0xF496A8B9,0x44118BEC,0xE6CA84D6},{(-1),(-1),0xEBA78A47,(-8),0xA77F9E04,(-8),0xEBA78A47}},{{9,9,0xE6CA84D6,0x44118BEC,0xF496A8B9,0x44118BEC,0xE6CA84D6},{(-1),(-1),0xEBA78A47,(-8),0xA77F9E04,(-6),(-1)},{0xF496A8B9,0xF496A8B9,9,0x3BEBD9D3,0xA5683038,0x3BEBD9D3,9}}};
                        int i, j, k;
                        if (l_301[3][1][5])
                            break;
                        l_285 = ((void*)0 != l_302);
                        if (l_301[2][0][3])
                            break;
                        if (l_286[3][5])
                            break;
                    }
                    else
                    { /* block id: 213 */
                        if (l_296)
                            break;
                    }
                }
                for (l_131 = 0; (l_131 <= (-1)); l_131 = safe_sub_func_uint32_t_u_u(l_131, 6))
                { /* block id: 230 */
                    float l_342[10] = {(-0x1.Fp+1),(-0x1.Fp+1),(-0x1.Fp+1),(-0x1.Fp+1),(-0x1.Fp+1),(-0x1.Fp+1),(-0x1.Fp+1),(-0x1.Fp+1),(-0x1.Fp+1),(-0x1.Fp+1)};
                    int32_t **l_345[2][9] = {{&l_344[0][0],&l_344[0][0],&l_344[0][0],&l_344[1][0],&l_344[1][0],&l_344[0][0],&l_344[0][0],&l_344[0][0],&l_344[1][0]},{&l_344[0][0],&l_344[1][0],&l_344[1][0],&l_344[0][0],&l_344[0][0],&l_344[0][0],&l_344[1][0],&l_344[1][0],&l_344[0][0]}};
                    int i, j;
                    l_344[1][0] = (((((((&l_285 != (void*)0) != ((void*)0 == &p_68)) | (__builtin_bswap64((__builtin_ctz(l_338) >= (l_341 != (void*)0))) ^ (*l_130))) != (*l_130)) > l_343) != l_296) , l_344[0][0]);
                    for (l_343 = 0; l_343 < 2; l_343 += 1)
                    {
                        for (l_296 = 0; l_296 < 9; l_296 += 1)
                        {
                            l_345[l_343][l_296] = &l_130;
                        }
                    }
                    if ((((void*)0 == l_346) , 0x23BF89DE))
                    { /* block id: 233 */
                        int32_t l_348 = 0x2185C57E;
                        float *l_350 = &l_342[8];
                        (*l_347) = &l_131;
                        (*l_350) = ((l_348 , (!l_296)) <= l_348);
                        (**l_346) = &l_296;
                    }
                    else
                    { /* block id: 237 */
                        int32_t *l_351 = &l_338;
                        l_351 = (*l_347);
                        /* statement id: 238 */
                        assert (l_351 == &l_296 || l_351 == &l_131 || l_351 == &l_285);
                        if (l_285)
                            continue;
                    }
                }
                /* facts after for loop */
                //assert (l_344[0][0] == &l_296 || l_344[0][0] == &l_131 || l_344[0][0] == &l_285);
                (**l_347) = __builtin_bswap64((~0xAD08A1AE));
                l_130 = &l_131;
            }
            /* facts after branching */
            //assert (l_344[0][0] == dangling || l_344[0][0] == &l_131 || l_344[0][0] == &l_285);
            (*l_130) = (!((((l_354 != &l_347) == ((void*)0 != &l_355)) != __builtin_popcountl((*l_130))) != ((__builtin_parityll((*l_130)) > 0xB.5E8790p+14) >= (*l_130))));
            if ((*l_130))
                break;
        }
    }
    /* facts after branching */
    //assert ((p_68 >= &l_133[0][0][0] && p_68 <= &l_133[2][1][4]) || p_68 == &l_70 || p_68 == &l_434 || p_68 == &l_809);
    assert (l_130 == 0 || l_130 == &l_131);
lbl_357:
    (*l_356) = &l_131;
    /* statement id: 249 */
    assert (l_130 == &l_131);
    (*l_132) = (***l_283);
    return l_362;
    /* statement id: 252 */
    //assert (func_67_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_75(struct S0 * p_76)
{ /* block id: 53 */
    int32_t *l_98 = (void*)0;
    int32_t l_99 = (-1);
    int32_t *l_100 = &l_99;
    float l_101 = 0x8.4D69EAp+53;
    int16_t l_102 = 0xE902;
    (*l_100) = __builtin_ctzll(((!(l_98 == (void*)0)) < l_99));
    l_100 = &l_99;
    return l_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_77(uint32_t  p_78, uint32_t  p_79, struct S0 * p_80, const int32_t  p_81, float  p_82)
{ /* block id: 50 */
    int32_t l_92 = 0x4EB764FA;
    int32_t *l_91[7];
    int32_t **l_93[2][7][1] = {{{&l_91[5]},{(void*)0},{(void*)0},{(void*)0},{(void*)0},{(void*)0},{&l_91[5]}},{{(void*)0},{(void*)0},{(void*)0},{(void*)0},{(void*)0},{&l_91[5]},{(void*)0}}};
    int32_t *l_94[2][1];
    struct S0 l_96 = {0,34};
    struct S0 *l_95[5];
    int i, j, k;
    for (i = 0; i < 7; i = i + 1)
        l_91[i] = &l_92;
    for (i = 0; i < 2; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
            l_94[i][j] = &l_92;
    }
    for (i = 0; i < 5; i = i + 1)
        l_95[i] = &l_96;
    l_94[1][0] = l_91[0];
    return p_80;
    /* statement id: 52 */
    //assert (func_77_rv == 0 || func_77_rv == &l_90 || func_77_rv == &l_70 || func_77_rv == &l_434 || func_77_rv == &l_561 || func_77_rv == &l_809 || func_77_rv == &l_813 || func_77_rv == &l_1117);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 460
   depth: 1, occurrence: 52
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 125
breakdown:
   indirect level: 0, occurrence: 52
   indirect level: 1, occurrence: 33
   indirect level: 2, occurrence: 13
   indirect level: 3, occurrence: 13
   indirect level: 4, occurrence: 8
   indirect level: 5, occurrence: 6
XXX full-bitfields structs in the program: 52
breakdown:
   indirect level: 0, occurrence: 52
XXX times a bitfields struct's address is taken: 71
XXX times a bitfields struct on LHS: 9
XXX times a bitfields struct on RHS: 82
XXX times a single bitfield on LHS: 7
XXX times a single bitfield on RHS: 198

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 267
   depth: 2, occurrence: 52
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 5
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 340

XXX times a variable address is taken: 965
XXX times a pointer is dereferenced on RHS: 428
breakdown:
   depth: 1, occurrence: 267
   depth: 2, occurrence: 67
   depth: 3, occurrence: 43
   depth: 4, occurrence: 51
XXX times a pointer is dereferenced on LHS: 197
breakdown:
   depth: 1, occurrence: 127
   depth: 2, occurrence: 31
   depth: 3, occurrence: 29
   depth: 4, occurrence: 10
XXX times a pointer is compared with null: 52
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 19
XXX times a pointer is qualified to be dereferenced: 1918

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 917
   level: 2, occurrence: 233
   level: 3, occurrence: 159
   level: 4, occurrence: 99
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 199
XXX number of pointers point to scalars: 98
XXX number of pointers point to structs: 43
XXX percent of pointers has null in alias set: 36.8
XXX average alias set size: 1.53

XXX times a non-volatile is read: 2399
XXX times a non-volatile is write: 728
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 10

XXX stmts: 234
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 30
   depth: 2, occurrence: 28
   depth: 3, occurrence: 34
   depth: 4, occurrence: 47
   depth: 5, occurrence: 69

XXX percentage a fresh-made variable is used: 20.9
XXX percentage an existing variable is used: 79.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

