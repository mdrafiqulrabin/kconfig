/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1899464174
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 5;
   int32_t  f1;
   unsigned f2 : 14;
   unsigned f3 : 24;
   const unsigned f4 : 29;
   unsigned f5 : 21;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 22;
   signed f1 : 5;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint64_t g_9 = 1UL;
static int32_t g_51 = 8L;
static int32_t *g_50 = &g_51;
static struct S1 g_55 = {661,-3};
static struct S0 g_115 = {-4,0xFB248F24L,11,801,22450,1336};
static struct S0 *g_123 = &g_115;
static struct S0 **g_122 = &g_123;
static struct S0 ***g_121 = &g_122;
static int32_t *g_138 = &g_51;
static int32_t **g_165 = (void*)0;
static int32_t ***g_164 = &g_165;
static int32_t ****g_163 = &g_164;
static struct S1 *g_252 = &g_55;
static int64_t g_258 = 7L;
static struct S0 *****g_286 = (void*)0;
static int32_t g_307 = 0x2F513778L;
static struct S1 **g_520 = &g_252;
static struct S1 ***g_519 = &g_520;
static int64_t g_570 = (-1L);


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_28(void);
static uint16_t  func_29(uint64_t  p_30, int8_t  p_31);
static int32_t * func_33(struct S0  p_34, const int8_t  p_35);
static struct S0  func_36(int32_t  p_37, const int32_t * p_38, int32_t  p_39, const int64_t  p_40, const struct S0  p_41);
static int16_t  func_42(uint32_t  p_43, int32_t  p_44, int32_t * p_45, int32_t * p_46);
static int32_t * func_52(struct S1  p_53, int32_t  p_54);
static int32_t * func_56(const uint64_t  p_57, struct S1  p_58);
static struct S1  func_65(int32_t * p_66, int32_t * p_67, int32_t * p_68);
static int32_t * func_69(const int32_t * p_70);
static struct S1  func_80(int32_t * p_81, uint16_t  p_82, int8_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_9 g_50 g_55 g_51 g_121 g_122 g_123 g_115.f5 g_115.f2 g_115.f4 g_115.f3 g_138 g_163 g_115.f0 g_115.f1 g_164 g_165 g_252 g_307 g_258 g_520 g_519
 * writes: g_55 g_51 g_121 g_138 g_165 g_115.f1 g_307 g_258 g_123 g_9 g_164 g_519
 */
static uint64_t  func_28(void)
{ /* block id: 36 */
    uint64_t l_32 = 18446744073709551615UL;
    uint32_t l_493 = 1UL;
    int32_t *l_515 = &g_307;
    const struct S1 **l_518 = (void*)0;
    const struct S1 ***l_517 = &l_518;
    struct S1 l_522 = {-1245,1};
    int32_t ***l_529 = &g_165;
    uint64_t l_542 = 0xEB383CFDE086A9AALL;
    const uint32_t l_576 = 0x9DCCA4E8L;
    struct S0 ****l_579 = &g_121;
    int64_t l_581 = 0L;
    struct S0 ****l_591 = &g_121;
    int32_t *l_634 = &g_51;
    struct S1 ****l_638 = &g_519;
    if ((0L > func_29(g_9, l_32)))
    { /* block id: 39 */
        int8_t l_49 = (-1L);
        int32_t *l_459 = (void*)0;
        const struct S0 l_494 = {2,3L,25,979,13421,587};
        int32_t **l_514 = &g_138;
        (*l_514) = func_33(func_36(((func_42(((safe_mod_func_uint16_t_u_u(g_9, func_29(g_9, l_49))) <= (g_50 != &g_51)), ((void*)0 == &g_51), func_52(g_55, l_32), l_459) >= l_493) && 0xDBAC78C2EEBBADC4LL), l_459, g_115.f2, g_115.f0, l_494), g_115.f2);
        /* statement id: 427 */
        assert (g_123 == 0 || g_123 == &g_115);
        assert (g_138 == &g_115.f1);
        (*g_252) = func_65(l_515, l_515, l_515);
        (*l_514) = (*l_514);
        return (**l_514);
    }
    else
    { /* block id: 431 */
        int32_t *l_516 = (void*)0;
        int32_t ***l_521 = &g_165;
        int32_t *****l_548 = &g_163;
        uint32_t l_580 = 0xBBF36C55L;
        const uint32_t l_614 = 0UL;
        struct S1 *l_627 = (void*)0;
        int32_t *l_629 = &g_115.f1;
        int32_t *l_636 = &g_307;
        (**g_520) = l_522;
        (*g_164) = (void*)0;
        if (((safe_mod_func_int64_t_s_s((((((safe_sub_func_uint64_t_u_u(g_9, (g_55.f0 >= ((l_521 != l_529) && (safe_rshift_func_int16_t_s_u(__builtin_clzll((safe_lshift_func_int16_t_s_s((safe_sub_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u((g_115.f5 == 0x35FCF616L), (*l_515))), (safe_mod_func_uint32_t_u_u(0x9402B95AL, func_29(((safe_add_func_uint16_t_u_u((func_29(g_55.f0, l_542) && 0xA711357EE0AC2BCBLL), 65534UL)) < 0xED6EL), g_115.f2))))), g_115.f1))), g_115.f2)))))) >= g_115.f2) == 0L) & g_115.f5) != (*l_515)), g_55.f0)) <= 0x717F3EA9L))
        { /* block id: 434 */
            uint32_t l_547 = 0xC6778101L;
            for (g_115.f1 = (-23); (g_115.f1 == 1); g_115.f1 = safe_add_func_uint64_t_u_u(g_115.f1, 7))
            { /* block id: 437 */
                int16_t l_549 = (-1L);
                int16_t l_550 = 0L;
                (*g_138) = ((safe_add_func_uint32_t_u_u(3UL, l_547)) | ((((g_115.f4 && g_51) > g_115.f3) <= (((&g_163 == l_548) > 4294967295UL) <= l_549)) || l_550));
            }
            for (g_9 = (-7); (g_9 >= 1); g_9 = safe_add_func_int16_t_s_s(g_9, 1))
            { /* block id: 442 */
                int32_t l_555 = 0xAED09289L;
                (*g_138) = (safe_rshift_func_int16_t_s_s(g_51, 13));
                if (l_555)
                    continue;
                (*g_163) = (*g_163);
                if (l_547)
                    break;
            }
        }
        else
        { /* block id: 448 */
            int32_t *l_561 = &g_307;
            int32_t *l_609 = (void*)0;
            struct S1 *l_628 = (void*)0;
            int32_t **l_637 = &l_561;
            for (l_493 = (-5); (l_493 > 28); l_493 = safe_add_func_int32_t_s_s(l_493, 1))
            { /* block id: 451 */
                (*g_50) = 1L;
            }
            for (l_542 = 0; (l_542 < 58); l_542 = safe_add_func_int16_t_s_s(l_542, 5))
            { /* block id: 456 */
                int32_t **l_567 = &g_50;
                int32_t *l_595 = &g_51;
                struct S1 l_596 = {-1276,3};
            }
            if (((((safe_lshift_func_int16_t_s_s(g_307, 4)) && ((g_115.f3 | (((safe_add_func_uint32_t_u_u((*l_561), func_29(g_51, g_55.f0))) >= ((safe_rshift_func_uint16_t_u_s(g_115.f3, 15)) & (safe_lshift_func_int16_t_s_u((((((void*)0 == (**g_519)) & g_115.f2) && g_115.f5) < (*l_561)), g_307)))) >= 0L)) && g_115.f2)) != 5L) & (*l_561)))
            { /* block id: 499 */
                int32_t l_607 = 0xFF860DD9L;
                int32_t l_612 = 0x9BF8E11CL;
                int32_t **l_617 = &l_609;
                if (l_607)
                { /* block id: 500 */
                    uint32_t l_611 = 0UL;
                    (**g_520) = (***g_519);
                    if ((*l_515))
                    { /* block id: 502 */
                        int32_t *l_608 = &g_115.f1;
                        int32_t **l_610 = &g_138;
                        l_608 = l_608;
                        (*l_608) = ((void*)0 != &g_164);
                        (*l_610) = l_609;
                        /* statement id: 505 */
                        assert (g_138 == 0);
                        l_612 = l_611;
                    }
                    else
                    { /* block id: 507 */
                        (*l_515) = ((void*)0 == (*g_122));
                        (*g_138) = ((8L == g_55.f0) | g_115.f4);
                        (*g_138) = (*g_50);
                        (*l_515) = l_612;
                    }
                    /* facts after branching */
                    assert (g_138 == &g_51 || g_138 == 0);
                }
                else
                { /* block id: 513 */
                    int32_t **l_613 = &l_561;
                    (*l_613) = func_69(&l_612);
                    /* statement id: 514 */
                    //assert (g_138 == &g_51 || g_138 == dangling);
                    assert (l_561 == 0);
                }
                /* facts after branching */
                //assert (g_138 == &g_51 || g_138 == dangling || g_138 == 0);
                assert (l_561 == 0 || l_561 == &g_307);
                (*l_617) = &l_612;
                /* statement id: 516 */
                assert (l_609 == &l_612);
                if ((*g_50))
                { /* block id: 517 */
                    return g_115.f2;
                }
                else
                { /* block id: 519 */
                    int32_t l_625 = 5L;
                    for (g_115.f1 = 0; (g_115.f1 <= (-18)); g_115.f1--)
                    { /* block id: 522 */
                        int8_t l_620 = 8L;
                        l_620 = (-1L);
                        if (l_620)
                            continue;
                        if (l_620)
                            break;
                        (*l_515) = ((safe_add_func_uint32_t_u_u((((*g_50) & (safe_add_func_uint32_t_u_u(((0x9B50L | ((0xBB03DB8F9C0AE2BFLL ^ l_625) | (~(g_115.f3 & g_307)))) != func_29(g_258, g_55.f1)), 0xC4E3260AL))) >= g_9), (**l_617))) != g_258);
                    }
                    return g_9;
                }
            }
            else
            { /* block id: 530 */
                int32_t *l_630 = &g_51;
                int32_t **l_631 = (void*)0;
                int32_t **l_632 = (void*)0;
                int32_t **l_633 = &g_138;
                struct S1 l_635 = {1741,-1};
                l_628 = l_627;
                (*l_633) = func_56(g_115.f0, func_65(l_629, l_630, l_561));
                /* statement id: 532 */
                assert (g_138 == &g_115.f1 || g_138 == &g_307 || g_138 == &g_51);
                l_635 = func_65(l_561, &g_307, l_609);
                l_609 = l_636;
                /* statement id: 534 */
                assert (l_609 == &g_307);
            }
            /* facts after branching */
            assert (g_138 == &g_115.f1 || g_138 == &g_307 || g_138 == &g_51);
            assert (l_609 == &g_307);
            (*l_637) = &g_51;
            /* statement id: 536 */
            assert (l_561 == &g_51);
        }
        /* facts after branching */
        assert (g_138 == &g_115.f1 || g_138 == &g_307 || g_138 == &g_51);
    }
    /* facts after branching */
    assert (g_138 == &g_115.f1 || g_138 == &g_307 || g_138 == &g_51);
    (*l_638) = &g_520;
    return (*l_634);
}


/* ------------------------------------------ */
/* 
 * reads : g_9
 * writes:
 */
static uint16_t  func_29(uint64_t  p_30, int8_t  p_31)
{ /* block id: 37 */
    return g_9;
}


/* ------------------------------------------ */
/* 
 * reads : g_115.f1 g_9 g_252 g_55
 * writes: g_55 g_115.f1
 */
static int32_t * func_33(struct S0  p_34, const int8_t  p_35)
{ /* block id: 413 */
    const int32_t ***l_503 = (void*)0;
    const int32_t ****l_502 = &l_503;
    int32_t *l_504 = &g_115.f1;
    struct S0 ***l_505 = &g_122;
lbl_506:
    p_34.f0 = (&g_164 != l_502);
    if ((((void*)0 == l_504) && func_29((*l_504), ((l_505 != &g_122) >= ((l_505 == (void*)0) || 0xA1F8DC3EBF0EA038LL)))))
    { /* block id: 415 */
        if (g_115.f1)
            goto lbl_506;
    }
    else
    { /* block id: 417 */
        const int32_t *l_510 = &g_51;
        (*g_252) = (*g_252);
        (*l_504) = ((*l_504) < (safe_lshift_func_uint16_t_u_s((safe_unary_minus_func_uint32_t_u(0x4744210FL)), (l_504 != l_510))));
        for (g_115.f1 = 0; (g_115.f1 > (-26)); g_115.f1 = safe_sub_func_uint32_t_u_u(g_115.f1, 9))
        { /* block id: 422 */
            uint32_t l_513 = 0x70CBFEF9L;
            p_34.f1 = l_513;
        }
    }
    return l_504;
    /* statement id: 426 */
    //assert (func_33_rv == &g_115.f1);
}


/* ------------------------------------------ */
/* 
 * reads : g_115.f2 g_50
 * writes: g_51
 */
static struct S0  func_36(int32_t  p_37, const int32_t * p_38, int32_t  p_39, const int64_t  p_40, const struct S0  p_41)
{ /* block id: 410 */
    struct S0 ****l_500 = &g_121;
    struct S0 *****l_499 = &l_500;
    int32_t l_501 = 1L;
    (*g_50) = (safe_mod_func_uint32_t_u_u(((safe_lshift_func_uint16_t_u_u((g_115.f2 >= ((void*)0 != l_499)), 4)) ^ (-6L)), ((-1L) & ((l_501 | __builtin_ctzl((p_41.f2 != p_41.f0))) > 0xC09D5D710E138C77LL))));
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads : g_307 g_9 g_115.f1 g_51 g_115.f4 g_138 g_50 g_252 g_55
 * writes: g_307 g_138 g_9 g_51 g_115.f1 g_55
 */
static int16_t  func_42(uint32_t  p_43, int32_t  p_44, int32_t * p_45, int32_t * p_46)
{ /* block id: 393 */
    int64_t l_486 = 1L;
    int32_t ***l_489 = &g_165;
    int32_t *l_490 = (void*)0;
    int32_t **l_492 = &l_490;
    for (g_307 = 0; (g_307 < 8); g_307 = safe_add_func_int64_t_s_s(g_307, 6))
    { /* block id: 396 */
        int32_t *l_462 = &g_307;
        int32_t **l_463 = &g_138;
        (*l_463) = l_462;
        /* statement id: 397 */
        assert (g_138 == &g_307);
        for (g_9 = 9; (g_9 > 25); g_9 = safe_add_func_int16_t_s_s(g_9, 1))
        { /* block id: 400 */
            int16_t l_466 = 0x90E0L;
            int8_t l_485 = 0x22L;
            int32_t *l_491 = &g_51;
            (*g_50) = (l_466 < (safe_sub_func_int64_t_s_s(l_466, ((safe_add_func_int32_t_s_s(((safe_add_func_uint32_t_u_u(((safe_sub_func_int16_t_s_s(0x5E9CL, (safe_sub_func_uint64_t_u_u((*l_462), (safe_mod_func_uint16_t_u_u((safe_add_func_int32_t_s_s(((((safe_add_func_uint16_t_u_u(((((((*p_45) >= (safe_sub_func_uint16_t_u_u((__builtin_ia32_crc32qi(g_115.f4, func_29((**l_463), (*l_462))) >= g_307), l_466))) <= l_485) == 0x1908866DL) | p_43) | p_43), l_486)) & 0x4ACBL) && p_44) > l_486), (*p_45))), (-1L))))))) <= p_43), 4294967295UL)) | p_44), (*p_45))) >= p_43))));
            (*p_45) = (safe_add_func_uint32_t_u_u(0x9A5A0DD6L, (&l_463 != l_489)));
            (*g_252) = func_65((*l_463), l_490, l_491);
        }
        (*g_50) = (*g_138);
        (*g_252) = (*g_252);
    }
    /* facts after for loop */
    //assert (g_138 == &g_307 || g_138 == &g_115.f1 || g_138 == dangling);
    (*l_492) = &p_44;
    /* statement id: 408 */
    assert (l_490 == &p_44);
    return g_55.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_51 g_55.f0 g_55.f1 g_55 g_50 g_121 g_122 g_123 g_115.f5 g_115.f2 g_115.f4 g_115.f3 g_138 g_163 g_115.f0 g_115.f1 g_164 g_165 g_252 g_307 g_258
 * writes: g_55 g_51 g_121 g_138 g_165 g_115.f1 g_307 g_258 g_123
 */
static int32_t * func_52(struct S1  p_53, int32_t  p_54)
{ /* block id: 40 */
    struct S1 l_59 = {-797,0};
    int32_t **l_428 = &g_138;
    int32_t *l_458 = &g_51;
    (*l_428) = func_56(__builtin_parityll(g_9), l_59);
    /* statement id: 364 */
    assert (g_138 == &g_307 || g_138 == &g_51 || g_138 == &g_115.f1);
    if ((**l_428))
    { /* block id: 365 */
        int32_t *l_429 = &g_115.f1;
        (*l_428) = l_429;
        /* statement id: 366 */
        assert (g_138 == &g_115.f1);
        return l_429;
        /* statement id: 367 */
        //assert (func_52_rv == &g_115.f1);
    }
    else
    { /* block id: 368 */
        int32_t **l_435 = &g_50;
        struct S0 ****l_449 = &g_121;
        (*g_50) = (safe_sub_func_uint64_t_u_u((**l_428), (~((safe_sub_func_uint16_t_u_u(1UL, (((**l_428) < ((((void*)0 != l_435) >= ((!(func_29(g_115.f4, p_54) && p_53.f1)) & p_54)) > 1L)) < 1UL))) != 65535UL))));
        if ((0xE5556FB1F53E0E9FLL || (safe_lshift_func_int16_t_s_u(((((safe_rshift_func_uint16_t_u_u((safe_add_func_uint16_t_u_u((((safe_mod_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s(g_55.f1, (**l_428))) ^ ((void*)0 == &l_428)), g_51)) > ((safe_add_func_int16_t_s_s((__builtin_ffsll((((l_449 != l_449) == func_29(((**l_428) ^ 0x716B1088389EF7ADLL), p_53.f0)) && (**l_428))) <= p_53.f1), (**l_428))) > g_51)) < g_115.f2), 0xD4AAL)), p_53.f1)) || (**l_435)) && g_115.f4) ^ 0xE652F08D15717C87LL), p_53.f1))))
        { /* block id: 370 */
            int8_t l_453 = 0x4BL;
            (*l_428) = (*l_435);
            /* statement id: 371 */
            assert (g_138 == &g_51);
            for (p_54 = 18; (p_54 == 24); p_54 = safe_add_func_uint16_t_u_u(p_54, 4))
            { /* block id: 374 */
                int16_t l_452 = 1L;
                l_453 = l_452;
            }
            (*l_428) = (*l_428);
        }
        else
        { /* block id: 378 */
            int32_t *l_454 = &g_115.f1;
            l_454 = (*l_435);
            /* statement id: 379 */
            assert (l_454 == &g_51);
            for (g_258 = 0; (g_258 > 29); g_258 = safe_add_func_uint16_t_u_u(g_258, 1))
            { /* block id: 382 */
                int8_t l_457 = 0xBDL;
                (*g_122) = (void*)0;
                /* statement id: 383 */
                assert (g_123 == 0);
                if (l_457)
                    break;
            }
            /* facts after for loop */
            assert (g_123 == 0 || g_123 == &g_115);
        }
        /* facts after branching */
        assert (g_123 == 0 || g_123 == &g_115);
        (*l_428) = func_69((*l_435));
        /* statement id: 387 */
        assert (g_138 == 0);
        (**l_435) = ((-1L) || (**l_435));
    }
    /* facts after branching */
    assert (g_123 == 0 || g_123 == &g_115);
    assert (g_138 == 0);
    (*l_428) = (*l_428);
    (*l_428) = &p_54;
    /* statement id: 391 */
    assert (g_138 == &p_54);
    return l_458;
    /* statement id: 392 */
    //assert (g_138 == dangling);
    //assert (func_52_rv == &g_51);
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_51 g_55.f0 g_55.f1 g_55 g_50 g_121 g_122 g_123 g_115.f5 g_115.f2 g_115.f4 g_115.f3 g_138 g_163 g_115.f0 g_115.f1 g_164 g_165 g_252 g_307 g_258
 * writes: g_55 g_51 g_121 g_138 g_165 g_115.f1 g_307 g_258 g_123
 */
static int32_t * func_56(const uint64_t  p_57, struct S1  p_58)
{ /* block id: 41 */
    uint32_t l_60 = 0x93B3BBBBL;
    int32_t *l_306 = &g_307;
    int32_t *l_309 = &g_307;
    int32_t l_387 = 0xB97D02AEL;
    int32_t *l_411 = &g_115.f1;
    if (((l_60 <= (safe_add_func_int64_t_s_s((l_60 ^ g_9), l_60))) && (safe_rshift_func_uint16_t_u_s(((&g_51 != (void*)0) >= g_51), 6))))
    { /* block id: 42 */
        const int32_t *l_71 = &g_51;
        (*g_252) = func_65(func_69(l_71), l_306, l_306);
        /* statement id: 229 */
        //assert (g_138 == &g_51 || g_138 == dangling);
    }
    else
    { /* block id: 230 */
        int32_t *l_310 = (void*)0;
        int32_t l_335 = 1L;
        struct S1 l_341 = {-908,-1};
        int32_t *****l_409 = &g_163;
        (*g_252) = func_65(l_309, l_310, l_309);
        if ((((__builtin_bswap64((safe_add_func_uint64_t_u_u(((g_115.f2 || (safe_add_func_int16_t_s_s((((((safe_rshift_func_int16_t_s_u((g_115.f1 || p_57), (safe_mod_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u(((((safe_add_func_int32_t_s_s(((p_58.f1 < p_58.f1) ^ (~g_55.f0)), __builtin_popcount(((p_58.f0 | ((safe_sub_func_uint32_t_u_u((p_57 && 0xB9B8584FL), g_115.f4)) < p_58.f0)) > g_9)))) ^ p_57) == (*l_309)) > (*l_309)), 0x314AL)) | p_58.f1), (*l_309))))) ^ g_115.f4) || g_258) || g_258) && 0L), g_115.f4))) ^ 0x6308C6F954EC6FA8LL), 0L))) < 0xDE4736B5L) != p_58.f0) && p_58.f0))
        { /* block id: 232 */
            for (l_60 = 0; (l_60 < 1); l_60 = safe_add_func_int32_t_s_s(l_60, 1))
            { /* block id: 235 */
                if ((*l_309))
                    break;
                (*g_138) = 0xC0AAC958L;
                (*g_252) = p_58;
            }
        }
        else
        { /* block id: 240 */
            int32_t *l_328 = &g_51;
            int32_t **l_329 = (void*)0;
            int32_t **l_330 = &l_328;
            const int32_t l_346 = 0x3AF4C397L;
            (*l_330) = l_328;
            if ((*l_309))
            { /* block id: 242 */
                int32_t l_331 = 0x1DDFA2F9L;
                l_331 = (*l_309);
lbl_342:
                p_58.f1 = ((safe_sub_func_uint32_t_u_u((+p_57), l_335)) || (safe_unary_minus_func_uint32_t_u(__builtin_ffs(p_57))));
                for (g_307 = 0; (g_307 != 27); g_307 = safe_add_func_int64_t_s_s(g_307, 9))
                { /* block id: 247 */
                    for (g_115.f1 = 16; (g_115.f1 >= 1); g_115.f1--)
                    { /* block id: 250 */
                        (*g_252) = l_341;
                    }
                    if (p_58.f1)
                        continue;
                    if (l_335)
                        goto lbl_342;
                    (*g_138) = p_58.f1;
                }
                (*l_309) = ((safe_unary_minus_func_uint16_t_u(g_115.f4)) < (((((void*)0 == &l_328) >= (((safe_mod_func_uint32_t_u_u(0x91999558L, 0xD6DFFD78L)) > l_346) > (safe_rshift_func_int16_t_s_s((*l_309), (0x545660DAL ^ ((!g_55.f1) <= 0x0D9CL)))))) <= p_58.f1) == (*l_306)));
            }
            else
            { /* block id: 258 */
                int32_t *l_350 = &g_51;
                (*g_252) = func_65(l_306, &l_335, &l_335);
                return l_350;
                /* statement id: 260 */
                //assert (func_56_rv == &g_51);
            }
            return l_309;
            /* statement id: 262 */
            //assert (func_56_rv == &g_307);
        }
        if ((*l_309))
        { /* block id: 264 */
            int32_t *l_351 = &g_307;
            int32_t **l_352 = &l_309;
            (*g_50) = (-1L);
            (*l_352) = l_351;
        }
        else
        { /* block id: 267 */
            uint32_t l_373 = 0x0E923B78L;
            struct S1 **l_374 = &g_252;
            for (l_60 = 0; (l_60 <= 26); l_60 = safe_add_func_uint64_t_u_u(l_60, 1))
            { /* block id: 270 */
                int32_t *l_358 = &g_115.f1;
                if ((*l_309))
                { /* block id: 271 */
                    for (l_335 = 0; (l_335 != 0); l_335 = safe_add_func_int32_t_s_s(l_335, 5))
                    { /* block id: 274 */
                        int32_t **l_357 = &g_138;
                        (*l_309) = (&g_163 == &g_163);
                        (*l_357) = &l_335;
                        /* statement id: 276 */
                        assert (g_138 == &l_335);
                        (*l_357) = l_358;
                        /* statement id: 277 */
                        assert (g_138 == &g_115.f1);
                        (*g_50) = ((void*)0 == (*g_121));
                    }
                }
                else
                { /* block id: 280 */
                    int32_t *l_361 = &l_335;
                    if (p_58.f1)
                        break;
                    for (l_335 = 0; (l_335 == 26); l_335 = safe_add_func_int64_t_s_s(l_335, 1))
                    { /* block id: 284 */
                        (*g_138) = (*l_309);
                    }
                    return l_309;
                    /* statement id: 287 */
                    //assert (func_56_rv == &g_307);
                }
            }
            /* facts after for loop */
            assert (g_138 == &g_115.f1 || g_138 == &g_51);
            for (l_335 = 0; (l_335 >= (-4)); l_335 = safe_sub_func_int64_t_s_s(l_335, 3))
            { /* block id: 292 */
                for (g_258 = 11; (g_258 < 24); g_258 = safe_add_func_int64_t_s_s(g_258, 7))
                { /* block id: 295 */
                    for (g_307 = 0; (g_307 < (-1)); g_307 = safe_sub_func_int64_t_s_s(g_307, 4))
                    { /* block id: 298 */
                        return l_306;
                        /* statement id: 299 */
                        //assert (func_56_rv == &g_307);
                    }
                }
            }
            for (g_51 = 0; (g_51 < 19); g_51 = safe_add_func_uint64_t_u_u(g_51, 8))
            { /* block id: 305 */
                struct S0 *l_370 = &g_115;
                const struct S1 **l_375 = (void*)0;
                const struct S1 ***l_376 = &l_375;
                (**g_121) = l_370;
                (*l_306) = (safe_lshift_func_uint16_t_u_s((l_373 > ((void*)0 != l_374)), 6));
                (*l_376) = l_375;
            }
        }
        /* facts after branching */
        assert (g_138 == &g_115.f1 || g_138 == &g_51);
        for (g_258 = 0; (g_258 <= (-30)); g_258--)
        { /* block id: 313 */
            uint32_t l_383 = 0xF53BB106L;
            int32_t ***l_390 = (void*)0;
            int32_t *l_403 = &g_115.f1;
        }
    }
    /* facts after branching */
    //assert (g_138 == &g_115.f1 || g_138 == &g_51 || g_138 == dangling);
    return l_411;
    /* statement id: 363 */
    //assert (func_56_rv == &g_115.f1);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_65(int32_t * p_66, int32_t * p_67, int32_t * p_68)
{ /* block id: 227 */
    struct S1 l_308 = {-1004,-4};
    return l_308;
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_55.f0 g_55.f1 g_9 g_55 g_50 g_121 g_122 g_123 g_115.f5 g_115.f2 g_115.f4 g_115.f3 g_138 g_163 g_115.f0 g_115.f1 g_164 g_165 g_307
 * writes: g_55 g_51 g_121 g_138 g_165 g_115.f1 g_307
 */
static int32_t * func_69(const int32_t * p_70)
{ /* block id: 43 */
    uint32_t l_72 = 0x17913DA5L;
    int32_t *l_77 = (void*)0;
    struct S1 l_210 = {1810,-3};
    int32_t *****l_218 = &g_163;
    int32_t l_230 = 0xC3FCEF47L;
    struct S0 ****l_285 = &g_121;
    struct S0 *****l_284 = &l_285;
    int32_t *l_305 = (void*)0;
    if (((((l_72 & ((4294967295UL >= 1L) ^ (*p_70))) < ((safe_rshift_func_int16_t_s_u(l_72, (safe_mod_func_int64_t_s_s((l_77 == p_70), (safe_mod_func_uint32_t_u_u(__builtin_popcountl(l_72), 0x85F1C2B4L)))))) == l_72)) != 1L) > (*p_70)))
    { /* block id: 44 */
        int32_t *l_84 = &g_51;
        int32_t l_85 = (-3L);
        struct S1 *l_209 = (void*)0;
        struct S1 l_211 = {400,-2};
        struct S1 *l_212 = (void*)0;
        struct S1 *l_213 = &l_210;
        l_210 = func_80(l_84, func_29(l_85, (safe_add_func_int64_t_s_s((safe_unary_minus_func_int32_t_s(((((!(safe_rshift_func_int16_t_s_u(((safe_rshift_func_int16_t_s_s((((((g_55.f0 & g_55.f1) <= ((g_55.f0 > g_55.f0) && (safe_add_func_uint16_t_u_u((*l_84), ((void*)0 != p_70))))) >= 0xE2BB11FE8BE9C2C5LL) | g_55.f1) & (*l_84)), (*l_84))) && 0xE4D3L), 8))) >= g_9) <= (*l_84)) != g_55.f1))), g_51))), (*l_84));
        /* statement id: 149 */
        //assert (g_138 == &g_51 || g_138 == dangling || g_138 == &g_115.f1 || g_138 == &g_307);
        l_210 = l_211;
        g_55 = g_55;
        (*l_213) = l_210;
    }
    else
    { /* block id: 153 */
        uint64_t l_214 = 0xCE08CD4FB8BF2FC4LL;
        struct S1 l_216 = {-1059,-2};
        int32_t *l_217 = &g_115.f1;
        struct S0 *l_228 = &g_115;
        int32_t ***l_231 = &g_165;
        l_216 = l_210;
        l_217 = l_77;
        /* statement id: 155 */
        assert (l_217 == 0);
        (*g_138) = ((0x4189961142FEC1EDLL || (l_218 == l_218)) && (l_216.f1 & g_55.f0));
        if ((0UL & ((safe_add_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(((__builtin_popcount((__builtin_ctzl(__builtin_popcountl(g_55.f1)) && ((((safe_rshift_func_int16_t_s_s(((safe_mul_func_int32_t_s_s((safe_unary_minus_func_int32_t_s(((g_115.f2 >= g_115.f4) ^ g_9))), ((void*)0 == l_228))) > 4294967295UL), 15)) & g_115.f2) < g_115.f0) | 0x538CD09A4D5CBF6CLL))) | 0x2D7C546D17D0ED01LL) != 0x5330C45750431255LL), l_216.f1)), g_115.f4)) <= 0x4A1DDCEFL)))
        { /* block id: 157 */
            int32_t *l_229 = &g_51;
            const uint16_t l_240 = 0x17EFL;
        }
        else
        { /* block id: 220 */
            struct S1 l_304 = {1812,-0};
            (*g_138) = (safe_add_func_int16_t_s_s(g_115.f4, ((*g_138) || __builtin_bswap64(g_115.f2))));
            l_216 = l_304;
        }
    }
    /* facts after branching */
    //assert (g_138 == &g_51 || g_138 == dangling || g_138 == &g_115.f1 || g_138 == &g_307);
    p_70 = l_305;
    /* statement id: 225 */
    assert (p_70 == 0);
    return l_305;
    /* statement id: 226 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_51 g_50 g_121 g_9 g_122 g_123 g_115.f5 g_115.f2 g_115.f4 g_115.f3 g_138 g_163 g_115.f0 g_115.f1 g_164 g_165 g_307
 * writes: g_55 g_51 g_121 g_138 g_165 g_115.f1 g_307
 */
static struct S1  func_80(int32_t * p_81, uint16_t  p_82, int8_t  p_83)
{ /* block id: 45 */
    uint16_t l_106 = 2UL;
    int32_t *l_118 = &g_51;
    struct S1 l_189 = {-113,-2};
    int32_t *****l_192 = &g_163;
    struct S0 ***l_201 = &g_122;
    int32_t *l_207 = (void*)0;
    for (p_83 = 0; (p_83 >= (-19)); p_83--)
    { /* block id: 48 */
        const struct S1 l_98 = {564,1};
        struct S1 *l_99 = &g_55;
        (*l_99) = l_98;
        return (*l_99);
    }
    if (((&g_55 != (void*)0) | (safe_sub_func_int64_t_s_s(g_51, (safe_add_func_int16_t_s_s(0x6E38L, (safe_rshift_func_uint16_t_u_u(((p_82 <= ((void*)0 != &g_55)) == l_106), p_83))))))))
    { /* block id: 52 */
        int32_t *l_108 = (void*)0;
        int32_t **l_107 = &l_108;
        (*l_107) = (void*)0;
        (*l_107) = &g_51;
        /* statement id: 54 */
        assert (l_108 == &g_51);
        for (p_82 = 0; (p_82 >= 42); p_82 = safe_add_func_uint64_t_u_u(p_82, 1))
        { /* block id: 57 */
            struct S0 *l_117 = &g_115;
            struct S0 **l_116 = &l_117;
            for (p_83 = 9; (p_83 <= (-10)); p_83 = safe_sub_func_uint64_t_u_u(p_83, 7))
            { /* block id: 60 */
                struct S0 *l_114 = &g_115;
                struct S0 **l_113 = &l_114;
                (*l_113) = (void*)0;
                /* statement id: 61 */
                assert (l_114 == 0);
                (*g_50) = ((void*)0 != &g_50);
                if ((*p_81))
                    continue;
            }
            (*l_116) = &g_115;
            (*l_107) = l_118;
        }
    }
    else
    { /* block id: 68 */
        struct S1 l_119 = {-1727,-3};
        struct S1 *l_120 = &l_119;
        struct S0 ****l_124 = (void*)0;
        struct S0 ****l_125 = (void*)0;
        struct S0 ****l_126 = &g_121;
        int32_t **l_128 = &l_118;
        int32_t ***l_127 = &l_128;
        int32_t *l_208 = (void*)0;
        (*l_120) = l_119;
        (*l_126) = g_121;
        (*l_127) = &g_50;
        /* statement id: 71 */
        assert (l_128 == &g_50);
        if ((18446744073709551615UL || ((***l_127) && (safe_mod_func_int32_t_s_s(func_29((**l_128), (0xCD949914L > __builtin_parityll(__builtin_ctzll((**l_128))))), (((safe_mod_func_int32_t_s_s((safe_add_func_int32_t_s_s((*g_50), (*g_50))), 0x9BDABD65L)) && 0x996C8B9EL) || p_82))))))
        { /* block id: 72 */
            int32_t ***l_147 = &l_128;
            struct S1 l_206 = {-1338,-1};
            if (((void*)0 == (**g_121)))
            { /* block id: 73 */
                int32_t l_135 = (-1L);
                int32_t **l_150 = &l_118;
                int32_t l_181 = 0xB096275EL;
                if (l_135)
                { /* block id: 74 */
                    int32_t *l_136 = &l_135;
                    int32_t **l_137 = (void*)0;
                    struct S1 l_145 = {-783,-1};
                    g_138 = l_136;
                    /* statement id: 75 */
                    assert (g_138 == &l_135);
                    for (g_51 = 0; (g_51 < (-18)); g_51--)
                    { /* block id: 78 */
                        int32_t l_143 = 0x15494F35L;
                        struct S1 l_144 = {1134,-4};
                        (*l_136) = (safe_mod_func_uint16_t_u_u(g_55.f1, l_143));
                        if ((*l_136))
                            break;
                        return l_144;
                        /* statement id: 81 */
                        //assert (g_138 == dangling);
                    }
                    (*l_120) = l_145;
                }
                else
                { /* block id: 84 */
                    (*g_50) = (!((*p_81) <= g_9));
                    if (func_29(l_135, p_82))
                    { /* block id: 86 */
                        (**l_128) = ((*g_50) == g_115.f5);
                    }
                    else
                    { /* block id: 88 */
                        int32_t ****l_148 = &l_127;
                        int32_t *l_149 = &g_115.f1;
                        (*l_148) = l_147;
                        l_149 = &g_51;
                        /* statement id: 90 */
                        assert (l_149 == &g_51);
                        g_138 = &g_51;
                        /* statement id: 91 */
                        assert (g_138 == &g_51);
                    }
                    (*l_120) = g_55;
                }
                /* facts after branching */
                assert (g_138 == &g_51 || g_138 == &l_135 || g_138 == &g_115.f1 || g_138 == &g_307);
                (*l_150) = &g_51;
                if (((safe_mod_func_uint64_t_u_u(p_82, func_29((***l_127), ((~0x2EDB36A152264B8ELL) == (((__builtin_ctz((*l_118)) >= (-1L)) == g_51) & __builtin_ctz(g_115.f2)))))) != (***l_147)))
                { /* block id: 96 */
                    int64_t l_160 = 0L;
                    (***l_127) = (g_115.f4 == (p_82 > (((((safe_add_func_uint64_t_u_u((safe_lshift_func_uint16_t_u_s(g_115.f5, (g_55.f1 ^ (((g_115.f3 > (safe_add_func_uint16_t_u_u(0x6AFDL, p_83))) <= ((func_29((**l_128), p_82) >= p_82) == 0xA5FE3C0FC352BBFDLL)) & 1L)))), l_160)) != (-8L)) == 3UL) == 0xBB48L) != (*g_138))));
                    if (((*l_118) > (***l_127)))
                    { /* block id: 98 */
                        (*p_81) = ((((safe_add_func_uint32_t_u_u(((**l_128) ^ ((g_163 != &g_164) < p_83)), ((*p_81) <= 4294967295UL))) == (safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_s((l_160 >= (__builtin_ctzll((safe_add_func_int16_t_s_s(((safe_lshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s((65535UL == (+((((safe_sub_func_int16_t_s_s(((safe_add_func_int64_t_s_s(p_82, p_83)) && g_115.f3), g_51)) < 18446744073709551610UL) == g_55.f0) && 1UL))), l_181)), g_115.f0)) && 0x576304A0L), 0xB7B0L))) >= (**l_128))), g_115.f3)), g_51))) != g_115.f1) && (***l_127));
                        (*l_150) = &g_51;
                        (*l_150) = p_81;
                        /* statement id: 101 */
                        assert (l_118 == &g_51 || l_118 == &g_307);
                        (*g_164) = (void*)0;
                    }
                    else
                    { /* block id: 103 */
                        struct S1 **l_182 = &l_120;
                        (*l_182) = &g_55;
                        /* statement id: 104 */
                        assert (l_120 == &g_55);
                    }
                    /* facts after branching */
                    assert (l_118 == &g_51 || l_118 == &g_307);
                    assert (l_120 == &g_55 || l_120 == &l_119);
                    for (l_181 = 0; (l_181 > (-13)); l_181 = safe_sub_func_int64_t_s_s(l_181, 1))
                    { /* block id: 108 */
                        (***l_147) = func_29((***l_127), g_115.f5);
                    }
                }
                else
                { /* block id: 111 */
                    for (l_135 = 9; (l_135 == 14); l_135 = safe_add_func_int64_t_s_s(l_135, 1))
                    { /* block id: 114 */
                        (*p_81) = func_29((0x80A444081C4FB29ELL <= (safe_lshift_func_int16_t_s_u(g_55.f1, 6))), p_82);
                        (*l_118) = (*p_81);
                    }
                    (*l_150) = (**l_147);
                }
                /* facts after branching */
                assert (l_118 == &g_51 || l_118 == &g_307);
                assert (l_120 == &g_55 || l_120 == &l_119);
            }
            else
            { /* block id: 120 */
                (*l_120) = l_189;
            }
            /* facts after branching */
            assert (l_118 == &g_51 || l_118 == &g_307);
            assert (l_120 == &g_55 || l_120 == &l_119);
            //assert (g_138 == &g_51 || g_138 == dangling || g_138 == &g_115.f1 || g_138 == &g_307);
            for (p_82 = 22; (p_82 > 52); p_82 = safe_add_func_int16_t_s_s(p_82, 9))
            { /* block id: 125 */
                struct S0 ***l_197 = &g_122;
                int32_t l_200 = 0L;
                struct S1 l_202 = {-1634,2};
                (*l_120) = g_55;
                l_192 = &g_163;
                for (p_83 = 0; (p_83 >= 11); p_83 = safe_add_func_int16_t_s_s(p_83, 1))
                { /* block id: 130 */
                    int32_t **l_203 = &l_118;
                    (*p_81) = (safe_add_func_uint32_t_u_u(((-1L) < func_29(g_115.f2, p_83)), 0xBE7C8CA6L));
                    (**l_128) = ((&g_122 == l_197) <= (safe_lshift_func_int16_t_s_s(l_200, (l_201 != &g_122))));
                    (*l_120) = l_202;
                    (*l_203) = p_81;
                }
                for (g_115.f1 = 0; (g_115.f1 >= (-10)); g_115.f1 = safe_sub_func_int32_t_s_s(g_115.f1, 7))
                { /* block id: 138 */
                    return l_206;
                }
            }
            (*l_127) = (***l_192);
            /* statement id: 142 */
            assert (l_128 == 0);
        }
        else
        { /* block id: 143 */
            l_208 = l_207;
        }
        /* facts after branching */
        assert (l_118 == &g_51 || l_118 == &g_307);
        assert (l_120 == &g_55 || l_120 == &l_119);
        assert (l_128 == &g_50 || l_128 == 0);
        //assert (g_138 == &g_51 || g_138 == dangling || g_138 == &g_115.f1 || g_138 == &g_307);
    }
    /* facts after branching */
    assert (l_118 == &g_51 || l_118 == &g_307);
    //assert (g_138 == &g_51 || g_138 == dangling || g_138 == &g_115.f1 || g_138 == &g_307);
    p_81 = l_207;
    /* statement id: 147 */
    assert (p_81 == 0);
    return l_189;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_9, "g_9", print_hash_value);
    transparent_crc(g_51, "g_51", print_hash_value);
    transparent_crc(g_55.f0, "g_55.f0", print_hash_value);
    transparent_crc(g_55.f1, "g_55.f1", print_hash_value);
    transparent_crc(g_115.f0, "g_115.f0", print_hash_value);
    transparent_crc(g_115.f1, "g_115.f1", print_hash_value);
    transparent_crc(g_115.f2, "g_115.f2", print_hash_value);
    transparent_crc(g_115.f3, "g_115.f3", print_hash_value);
    transparent_crc(g_115.f4, "g_115.f4", print_hash_value);
    transparent_crc(g_115.f5, "g_115.f5", print_hash_value);
    transparent_crc(g_258, "g_258", print_hash_value);
    transparent_crc(g_307, "g_307", print_hash_value);
    transparent_crc(g_570, "g_570", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 148
   depth: 1, occurrence: 19
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 40
breakdown:
   indirect level: 0, occurrence: 19
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 18
breakdown:
   indirect level: 0, occurrence: 18
XXX times a bitfields struct's address is taken: 17
XXX times a bitfields struct on LHS: 7
XXX times a bitfields struct on RHS: 33
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 132

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 245
   depth: 2, occurrence: 45
   depth: 3, occurrence: 4
   depth: 4, occurrence: 11
   depth: 5, occurrence: 5
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 4
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 164

XXX times a variable address is taken: 178
XXX times a pointer is dereferenced on RHS: 151
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 27
   depth: 3, occurrence: 9
XXX times a pointer is dereferenced on LHS: 137
breakdown:
   depth: 1, occurrence: 125
   depth: 2, occurrence: 8
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 901

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 985
   level: 2, occurrence: 256
   level: 3, occurrence: 232
   level: 4, occurrence: 47
   level: 5, occurrence: 20
XXX number of pointers point to pointers: 81
XXX number of pointers point to scalars: 68
XXX number of pointers point to structs: 15
XXX percent of pointers has null in alias set: 31.1
XXX average alias set size: 1.29

XXX times a non-volatile is read: 857
XXX times a non-volatile is write: 371
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 209
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 43
   depth: 2, occurrence: 33
   depth: 3, occurrence: 41
   depth: 4, occurrence: 31
   depth: 5, occurrence: 34

XXX percentage a fresh-made variable is used: 15.9
XXX percentage an existing variable is used: 84.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

