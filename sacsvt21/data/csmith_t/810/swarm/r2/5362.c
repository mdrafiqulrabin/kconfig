/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3723757566
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   int32_t  f1;
   uint32_t  f2;
   uint32_t  f3;
   uint16_t  f4;
   int32_t  f5;
   uint16_t  f6;
   int32_t  f7;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   unsigned f0 : 25;
   uint8_t  f1;
};
#pragma pack(pop)

struct S2 {
   unsigned f0 : 22;
   uint32_t  f1;
   uint32_t  f2;
   int16_t  f3;
   uint16_t  f4;
   struct S1  f5;
};

union U3 {
   uint16_t  f0;
   struct S0  f1;
   struct S0  f2;
   uint8_t  f3;
   signed f4 : 12;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
inline static uint16_t  func_13(int32_t  p_14, struct S2  p_15, int32_t  p_16, struct S2  p_17);
inline static struct S2  func_18(uint32_t  p_19, struct S0  p_20, union U3  p_21);
inline static int32_t  func_22(struct S2  p_23, uint8_t  p_24, int16_t  p_25, uint32_t  p_26);
static int32_t  func_28(uint32_t  p_29, uint32_t  p_30, uint32_t  p_31);
inline static int32_t  func_34(int16_t  p_35, int16_t  p_36, int32_t  p_37);
inline static uint16_t  func_38(struct S1  p_39);
inline static int32_t  func_44(uint32_t  p_45);
static int32_t  func_50(int32_t  p_51, int32_t  p_52, struct S1  p_53, uint16_t  p_54, uint8_t  p_55);
static int32_t  func_56(uint32_t  p_57, uint16_t  p_58, uint8_t  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_8 = 0x7AB6;
    struct S2 l_27 = {406,0U,2U,-1,0xEE3B,{5328,0xB7}};
    uint16_t l_33 = 65530U;
    struct S0 l_360 = {0x506B,0x47CE6028,0xBEE72BB2,4294967287U,9U,-3,0x86A0,0x7D16861A};
    union U3 l_361 = {65535U};
    int32_t *l_495 = &l_360.f7;
    int32_t l_500 = 0x887EBCF7;
    if (((uint32_t)((uint32_t)((int32_t)(l_8 & ((((int16_t)((2 ^ (((uint16_t)func_13(l_8, func_18((l_8 & (func_22(l_27, (((-9) < l_8) > func_28((~(l_33 || func_34((l_27.f3 & 1U), l_27.f5.f1, l_27.f5.f1))), l_27.f0, l_27.f2)), l_8, l_27.f4) | l_33)), l_360, l_361), l_27.f2, l_27) >> (uint16_t)10) ^ 0U)) == l_33) >> (int16_t)l_27.f5.f0) > l_360.f2) && 0x4C1ED878)) + (int32_t)(-8)) - (uint32_t)l_27.f0) - (uint32_t)0xE84CE56A))
    { /* block id: 212 */
        int32_t **l_496 = &l_495;
        (*l_496) = l_495;
        for (l_27.f1 = 3; (l_27.f1 < 56); l_27.f1++)
        { /* block id: 216 */
            uint32_t l_499 = 0U;
            return l_499;
        }
        (*l_495) = 0xD72A3678;
    }
    else
    { /* block id: 220 */
        (*l_495) = ((*l_495) < 0xCF16);
    }
    l_495 = (void*)0;
    /* statement id: 223 */
    assert (l_495 == 0);
    return l_500;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_13(int32_t  p_14, struct S2  p_15, int32_t  p_16, struct S2  p_17)
{ /* block id: 164 */
    struct S0 l_403 = {0x55C8,1,0x0025942E,0xEBC26506,65535U,-1,1U,0x8BBD86BD};
    struct S0 *l_402 = &l_403;
    struct S0 **l_401 = &l_402;
    struct S0 ***l_400 = &l_401;
    struct S0 ****l_399 = &l_400;
    uint32_t l_408 = 4294967290U;
    int16_t l_411 = 0x689C;
    struct S2 l_437 = {1608,1U,4294967286U,7,0x3564,{2687,0x3B}};
    struct S2 *l_436 = &l_437;
    int32_t ***l_452 = (void*)0;
    struct S0 ***l_486 = &l_401;
    uint16_t l_494 = 0x449F;
    if ((!(0x052B1F58 && ((((~(l_399 == (void*)0)) < l_403.f6) & (((int16_t)(((((uint16_t)l_403.f0 >> (uint16_t)0) || (l_403.f1 == l_408)) | (((uint16_t)l_411 << (uint16_t)2) >= l_403.f1)) >= 4294967295U) % (int16_t)0xD745) && l_408)) & l_403.f1))))
    { /* block id: 165 */
        int32_t *l_414 = &l_403.f7;
        union U3 l_432 = {65535U};
        union U3 *l_431 = &l_432;
        struct S0 l_440 = {0,-1,4294967286U,0xAA0234A3,65535U,-8,5U,0x3A858D1D};
        int32_t ****l_464 = &l_452;
        int32_t *****l_463 = &l_464;
        for (l_411 = 0; (l_411 >= 25); l_411 += 8)
        { /* block id: 168 */
            int32_t **l_415 = &l_414;
            int32_t l_442 = 8;
            struct S2 **l_449 = &l_436;
            struct S2 ***l_448 = &l_449;
            uint32_t l_479 = 0U;
            (*l_415) = l_414;
        }
        l_414 = &p_14;
        /* statement id: 205 */
        assert (l_414 == &p_14);
        (*l_414) = p_17.f1;
        (*l_414) = 0x8FD94906;
    }
    else
    { /* block id: 208 */
        int32_t l_493 = 0xF04A6633;
        p_14 = (p_14 | ((int32_t)((int16_t)(l_486 != (*l_399)) << (int16_t)((int16_t)(((p_15.f3 && ((((int16_t)((int16_t)((5U > ((p_17.f4 <= 0x912BAE1B) >= ((1U && l_493) & p_15.f2))) != 4294967287U) << (int16_t)4) >> (int16_t)14) == l_494) > p_17.f2)) >= p_17.f4) > l_493) - (int16_t)l_493)) + (int32_t)3));
    }
    return l_403.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S2  func_18(uint32_t  p_19, struct S0  p_20, union U3  p_21)
{ /* block id: 155 */
    struct S2 l_364 = {1521,1U,0U,1,0x3A68,{3138,0x6C}};
    union U3 l_371 = {0x58A2};
    union U3 *l_370 = &l_371;
    union U3 **l_369 = &l_370;
    int32_t *****l_374 = (void*)0;
    struct S0 *l_395 = (void*)0;
    struct S0 **l_394 = &l_395;
    int32_t l_396 = 0x3005CFBD;
    for (p_20.f6 = (-27); (p_20.f6 >= 30); p_20.f6 += 9)
    { /* block id: 158 */
        return l_364;
    }
    p_21.f1.f7 = ((uint16_t)((uint16_t)((void*)0 != l_369) + (uint16_t)(-1)) + (uint16_t)(((int16_t)((((void*)0 != l_374) && ((int16_t)(0xF462 && (((int32_t)((uint16_t)p_20.f4 >> (uint16_t)10) + (int32_t)((int16_t)((uint32_t)((int16_t)p_20.f2 << (int16_t)((0U >= l_364.f3) || p_19)) + (uint32_t)l_364.f2) >> (int16_t)6)) >= 0x24AEB1D1)) % (int16_t)p_20.f2)) != l_364.f4) << (int16_t)l_364.f5.f1) & l_371.f0));
    l_371.f1.f7 = (((uint32_t)p_20.f6 + (uint32_t)0x5683FCD8) != ((((~1) == p_20.f6) <= p_20.f6) || ((uint16_t)((int16_t)((((void*)0 != l_394) == (l_364.f1 || (l_396 > l_364.f1))) ^ 0x9389) >> (int16_t)p_20.f2) + (uint16_t)p_20.f2)));
    return l_364;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_22(struct S2  p_23, uint8_t  p_24, int16_t  p_25, uint32_t  p_26)
{ /* block id: 145 */
    union U3 *l_340 = (void*)0;
    union U3 **l_341 = &l_340;
    union U3 ****l_342 = (void*)0;
    union U3 ***l_343 = &l_341;
    int32_t l_352 = (-10);
    int32_t l_353 = 6;
    (*l_341) = l_340;
    l_343 = &l_341;
    for (p_25 = 0; (p_25 > 12); p_25++)
    { /* block id: 150 */
        union U3 l_355 = {0U};
        union U3 *l_354 = &l_355;
        int32_t *l_356 = (void*)0;
        int32_t *l_357 = &l_355.f1.f7;
        struct S2 l_358 = {14,0x6B6975B6,0xB9C6CFBC,0x825A,0x2649,{3425,0U}};
        struct S2 *l_359 = &l_358;
        (*l_357) = ((((int16_t)p_23.f4 >> (int16_t)(p_26 != ((uint16_t)(p_24 ^ p_23.f5.f1) << (uint16_t)0))) != ((((uint32_t)l_352 - (uint32_t)(((l_352 <= (l_353 & ((((l_354 == (**l_343)) == p_23.f5.f0) ^ 1) && l_353))) != 0x9F6E) >= 0x9876)) == l_355.f0) || p_23.f3)) || p_25);
        (*l_359) = l_358;
    }
    return l_352;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_28(uint32_t  p_29, uint32_t  p_30, uint32_t  p_31)
{ /* block id: 143 */
    int32_t l_339 = 0;
    return l_339;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_34(int16_t  p_35, int16_t  p_36, int32_t  p_37)
{ /* block id: 1 */
    struct S1 l_40 = {4479,1U};
    int32_t l_227 = 0x66276FC4;
    int32_t *l_226 = &l_227;
    struct S2 l_239 = {1693,0x24A29CC7,0x544CB16B,0xFED0,0x5638,{1935,0xF8}};
    struct S2 *l_238 = &l_239;
    int32_t **l_254 = (void*)0;
    struct S0 l_284 = {0x2CA9,0x6B8E888B,0U,4294967294U,65533U,0x257DEBD9,0x1D54,0x2B14F8C3};
    struct S0 *l_283 = &l_284;
    struct S0 **l_282 = &l_283;
    struct S0 ***l_281 = &l_282;
    union U3 *l_290 = (void*)0;
    struct S2 **l_328 = &l_238;
    if ((func_38(l_40) > p_36))
    { /* block id: 77 */
        int32_t **l_228 = &l_226;
        (*l_228) = l_226;
    }
    else
    { /* block id: 79 */
        uint16_t l_229 = 0x812C;
        int32_t *l_232 = &l_227;
        struct S0 l_235 = {0x5234,0x3A6FFE6D,0xE1E2EF9C,4294967289U,1U,0x40514D0C,65535U,-1};
        struct S0 *l_234 = &l_235;
        int32_t **l_249 = &l_232;
        int32_t ***l_248 = &l_249;
        int32_t ****l_247 = &l_248;
        int32_t *****l_246 = &l_247;
        struct S1 *l_260 = &l_40;
        int32_t l_268 = 4;
        struct S2 **l_317 = &l_238;
        union U3 **l_322 = &l_290;
        union U3 ***l_321 = &l_322;
        struct S0 ****l_326 = &l_281;
lbl_230:
        l_229 = (*l_226);
        if (p_37)
        { /* block id: 81 */
            int32_t l_231 = 0xDADBB84C;
            int32_t **l_255 = &l_226;
            struct S0 ****l_285 = &l_281;
            struct S2 *l_286 = (void*)0;
            struct S2 **l_287 = &l_238;
            if (l_40.f1)
                goto lbl_230;
            if (l_231)
            { /* block id: 83 */
                int32_t **l_233 = &l_232;
                struct S0 **l_236 = (void*)0;
                struct S0 **l_237 = &l_234;
                (*l_233) = l_232;
                (*l_237) = l_234;
            }
            else
            { /* block id: 86 */
                struct S0 l_241 = {0x0E6B,0xD3E5C67D,4294967295U,0xAA033F47,65535U,0x5CE67DD8,0xBB4E,-3};
                int32_t **l_250 = &l_226;
                uint32_t l_265 = 0x24BBF924;
                int32_t *****l_269 = (void*)0;
                union U3 l_279 = {65535U};
                union U3 *l_278 = &l_279;
                if (((l_231 > (l_238 != (void*)0)) != ((*l_232) | (l_232 == &l_231))))
                { /* block id: 87 */
                    int32_t *l_240 = (void*)0;
                    l_240 = l_240;
                    l_241 = l_241;
                }
                else
                { /* block id: 90 */
                    int32_t **l_245 = &l_232;
                    int32_t ***l_244 = &l_245;
                    int32_t ****l_243 = &l_244;
                    int32_t *****l_242 = &l_243;
                    (**l_245) = (l_242 != l_246);
                    if (l_241.f6)
                        goto lbl_251;
lbl_251:
                    (**l_249) = (l_250 == (**l_247));
                    (**l_246) = (void*)0;
                    /* statement id: 94 */
                    assert (l_248 == 0);
                }
                /* facts after branching */
                assert (l_248 == 0 || l_248 == &l_249);
                (**l_250) = p_36;
                (*l_249) = &l_231;
                /* statement id: 97 */
                assert (l_232 == &l_231);
                if (((uint16_t)3U >> (uint16_t)(l_254 != l_255)))
                { /* block id: 98 */
                    int32_t l_270 = 1;
                    (*l_226) = ((((uint16_t)(((uint16_t)(&l_40 != l_260) << (uint16_t)(*l_232)) == (((uint16_t)65534U + (uint16_t)(p_37 == 65532U)) < ((int16_t)(l_265 != ((int32_t)((l_268 < (l_269 != (void*)0)) & (**l_255)) + (int32_t)l_270)) << (int16_t)8))) % (uint16_t)p_35) || 0xFEE4) >= p_37);
                }
                else
                { /* block id: 100 */
                    for (l_231 = 0; (l_231 == 21); ++l_231)
                    { /* block id: 103 */
                        return p_36;
                    }
                    if ((&l_234 == &l_234))
                    { /* block id: 106 */
                        return p_35;
                    }
                    else
                    { /* block id: 108 */
                        uint8_t l_276 = 9U;
                        int32_t ****l_277 = &l_248;
                        union U3 *l_280 = (void*)0;
                        (*l_226) = (*l_232);
                        (**l_250) = (((0xC6ADC05C == (+(p_37 ^ ((((int16_t)0xF24D - (int16_t)(l_276 <= p_37)) <= ((*l_246) != l_277)) && ((l_278 != l_280) || 0x23EA))))) || p_37) || 0U);
                    }
                }
            }
            /* facts after branching */
            assert (l_232 == &l_231 || l_232 == &l_227);
            assert (l_248 == 0 || l_248 == &l_249);
            (*l_285) = l_281;
            (*l_287) = l_286;
            /* statement id: 115 */
            assert (l_238 == 0);
        }
        else
        { /* block id: 116 */
            int32_t *l_288 = &l_284.f7;
            union U3 **l_289 = (void*)0;
            struct S2 **l_293 = &l_238;
            int32_t ****l_315 = &l_248;
            (*l_249) = l_288;
            /* statement id: 117 */
            assert (l_232 == &l_284.f7);
            l_290 = (void*)0;
            (****l_246) = (****l_246);
            for (l_284.f0 = 0; (l_284.f0 <= 21); l_284.f0 += 1)
            { /* block id: 122 */
                struct S0 ***l_313 = &l_282;
                int32_t l_314 = 0xF0262F68;
                struct S2 **l_316 = &l_238;
                struct S0 **l_319 = &l_234;
                (*l_234) = (*l_234);
                (****l_247) = (((void*)0 == l_293) >= (((uint16_t)(((int32_t)(((int16_t)(((p_36 && ((((int32_t)(+p_37) + (int32_t)p_37) & (((int16_t)p_35 << (int16_t)(((uint16_t)(0U | (((((int32_t)((p_35 <= ((uint16_t)(&l_282 == l_313) % (uint16_t)p_37)) ^ 4294967287U) + (int32_t)p_35) && p_35) == 0U) && (*l_226))) % (uint16_t)(*l_288)) | p_35)) != p_35)) <= 0xBAF7)) >= 65533U) | 0xBECA) >> (int16_t)8) ^ 3) - (int32_t)0xBA9923A2) != p_35) % (uint16_t)l_314) ^ p_36));
                l_315 = (void*)0;
                /* statement id: 125 */
                assert (l_315 == 0);
                if ((((*l_288) & (((((l_316 == l_317) >= ((((*l_232) & 4) <= 1U) == ((((*l_226) != (~(((void*)0 == (*l_281)) != p_36))) <= p_35) == 0x54EA))) <= (*l_226)) != (**l_249)) == 0U)) & l_314))
                { /* block id: 126 */
                    uint16_t l_320 = 65533U;
                    (***l_248) = ((((((*l_281) != l_319) <= l_320) ^ p_37) ^ ((0 <= (p_35 ^ ((l_321 != (void*)0) && ((((!0x6E393A55) ^ l_314) ^ l_320) == 0xE53EB804)))) <= p_37)) >= p_35);
                }
                else
                { /* block id: 128 */
                    for (l_284.f1 = 0; (l_284.f1 < (-16)); l_284.f1 -= 1)
                    { /* block id: 131 */
                        struct S0 *****l_327 = &l_326;
                        (**l_316) = (**l_317);
                        (*l_327) = l_326;
                    }
                }
            }
            /* facts after for loop */
            assert (l_315 == 0 || l_315 == &l_248);
        }
        /* facts after branching */
        //assert (l_232 == &l_284.f7 || l_232 == dangling || l_232 == &l_227);
        assert (l_238 == &l_239 || l_238 == 0);
        assert (l_248 == 0 || l_248 == &l_249);
        return p_37;
    }
    (*l_328) = &l_239;
    (*l_226) = (((((((((*l_226) && (3U | (-(uint32_t)p_36))) > p_36) >= p_37) && (*l_226)) || ((uint32_t)(*l_226) + (uint32_t)(((uint16_t)p_35 - (uint16_t)((uint16_t)(!(((-(int16_t)(+((((*l_226) || (*l_226)) || (*l_226)) | 1U))) & 0xE0C47D54) == p_35)) + (uint16_t)0x348D)) <= p_35))) | (*l_226)) >= 0xEBC9) ^ p_36);
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_38(struct S1  p_39)
{ /* block id: 2 */
    int16_t l_43 = 0x29F1;
    struct S1 l_86 = {4208,0x87};
    int32_t l_225 = 7;
    int32_t *l_224 = &l_225;
    (*l_224) = ((uint32_t)(l_43 | (func_44(((((uint32_t)((int16_t)(func_50(l_43, func_56(((((uint16_t)l_43 >> (uint16_t)12) == ((p_39.f0 & (((((int32_t)l_43 + (int32_t)(l_43 ^ (((int16_t)((int16_t)p_39.f0 >> (int16_t)((int16_t)(0x59DFF04C || l_43) - (int16_t)0xB9E2)) << (int16_t)15) && 1))) > l_43) & 0x3C96AADB) | 1)) && 4294967295U)) && l_43), p_39.f0, p_39.f0), l_86, p_39.f1, l_86.f0) && p_39.f1) % (int16_t)(-1)) + (uint32_t)p_39.f0) != p_39.f0) & p_39.f1)) > l_86.f0)) + (uint32_t)p_39.f0);
    return p_39.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_44(uint32_t  p_45)
{ /* block id: 58 */
    struct S2 l_155 = {812,0x7D48C05A,0U,-6,0U,{2339,1U}};
    struct S2 *l_154 = &l_155;
    struct S2 **l_156 = &l_154;
    int32_t l_167 = 0x0F280869;
    union U3 l_197 = {0x6083};
    union U3 *l_196 = &l_197;
    int32_t l_213 = 0x5B34FF2D;
    (*l_156) = l_154;
    if (l_155.f5.f1)
    { /* block id: 60 */
        int16_t l_161 = 9;
        int32_t l_169 = (-9);
        int32_t *l_168 = &l_169;
        int32_t **l_170 = &l_168;
        (*l_168) = (((uint16_t)(((int16_t)((l_161 <= (((uint32_t)(((uint16_t)1U + (uint16_t)p_45) || (((0xFD68 | (!2)) == ((0x9456 > (((l_167 & p_45) >= (p_45 < l_161)) == p_45)) || 1)) || 65535U)) - (uint32_t)l_155.f3) < l_161)) && p_45) >> (int16_t)13) ^ 2U) + (uint16_t)0xBC3B) ^ p_45);
        (*l_170) = &l_169;
        return l_155.f4;
    }
    else
    { /* block id: 64 */
        struct S2 *l_173 = &l_155;
        int32_t l_176 = 0xE97C8AD5;
        uint8_t l_183 = 0x3F;
        union U3 **l_210 = &l_196;
        union U3 ***l_209 = &l_210;
        if (((uint16_t)((((l_173 != l_173) < (((uint16_t)(4294967290U && l_176) >> (uint16_t)p_45) ^ ((p_45 != (((uint16_t)1U << (uint16_t)4) || l_176)) == ((uint32_t)((((((uint32_t)(l_155.f3 > p_45) % (uint32_t)l_183) != l_176) == 4294967288U) >= 0x6836) | 0U) - (uint32_t)1U)))) == l_155.f1) ^ p_45) >> (uint16_t)8))
        { /* block id: 65 */
            struct S1 l_184 = {2363,0xF5};
            struct S1 *l_185 = &l_184;
            int32_t *l_200 = (void*)0;
            int32_t *l_201 = &l_197.f1.f7;
lbl_202:
            (*l_185) = l_184;
            (*l_201) = ((int16_t)((uint16_t)(((uint16_t)(l_183 <= ((uint16_t)l_184.f1 - (uint16_t)l_183)) + (uint16_t)(((int16_t)((l_196 != (void*)0) != (((int16_t)(p_45 > l_176) % (int16_t)l_184.f0) == (p_45 < p_45))) >> (int16_t)10) < p_45)) < l_176) % (uint16_t)l_155.f5.f1) + (int16_t)0x3621);
            if (p_45)
                goto lbl_202;
        }
        else
        { /* block id: 69 */
            union U3 ****l_220 = &l_209;
            int32_t l_221 = 0x5C9785EC;
            int32_t l_222 = 0xBCBC8BFC;
            int32_t *l_223 = &l_221;
            l_176 = (((((p_45 & (((int16_t)1 << (int16_t)((uint16_t)((int32_t)(1 < ((void*)0 != l_209)) - (int32_t)(((((int16_t)(((l_213 ^ ((uint16_t)(((((int16_t)(((0x6BF8 == (l_183 | (((uint16_t)((void*)0 == l_220) >> (uint16_t)2) < l_221))) ^ p_45) <= p_45) % (int16_t)5) || l_176) != l_176) <= l_155.f2) - (uint16_t)1U)) <= p_45) == p_45) - (int16_t)l_155.f1) && l_221) != 8) & p_45)) >> (uint16_t)p_45)) & 0x4C52370E)) != 0x6625) && 0x74B2) | l_155.f5.f0) <= l_176);
            (*l_223) = l_222;
        }
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_50(int32_t  p_51, int32_t  p_52, struct S1  p_53, uint16_t  p_54, uint8_t  p_55)
{ /* block id: 22 */
    int32_t *l_91 = (void*)0;
    int32_t **l_90 = &l_91;
    int32_t ***l_89 = &l_90;
    int32_t ****l_88 = &l_89;
    int32_t *****l_87 = &l_88;
    union U3 l_139 = {0U};
    union U3 *l_138 = &l_139;
    union U3 **l_140 = &l_138;
    uint32_t l_149 = 1U;
    union U3 ***l_150 = &l_140;
    union U3 ****l_151 = &l_150;
    struct S1 l_152 = {2985,0xB7};
    struct S1 *l_153 = &l_152;
    if (p_53.f0)
    { /* block id: 23 */
        struct S2 l_92 = {449,0U,0x3ABC15DB,0xBE44,0xD75F,{1147,0x47}};
        struct S2 *l_93 = &l_92;
        struct S0 l_97 = {0xC261,-1,0U,0xA3FDD5FB,0xF51E,0x022C1C42,0x94EC,0};
        struct S0 *l_96 = &l_97;
        l_87 = l_87;
        (*l_93) = l_92;
        for (p_55 = 0; (p_55 >= 29); p_55 += 8)
        { /* block id: 28 */
            struct S1 l_99 = {2455,0xC9};
            if ((&l_92 != (void*)0))
            { /* block id: 29 */
                struct S0 **l_98 = &l_96;
                struct S1 *l_100 = &l_99;
                (*l_98) = l_96;
                (*l_100) = l_99;
                (**l_98) = (**l_98);
            }
            else
            { /* block id: 33 */
                int32_t l_111 = 0x1AF4752A;
                if (p_54)
                { /* block id: 34 */
                    int32_t l_105 = 1;
                    struct S1 *l_112 = &l_99;
                    p_52 = ((int16_t)(((uint32_t)0x10E39645 + (uint32_t)l_105) & (((int16_t)p_51 >> (int16_t)3) && (((((+l_105) < (((uint16_t)l_111 << (uint16_t)0) < p_52)) || ((void*)0 != l_112)) ^ ((uint16_t)p_55 - (uint16_t)l_99.f1)) >= 1U))) % (int16_t)p_51);
                }
                else
                { /* block id: 36 */
                    int32_t **l_119 = &l_91;
                    p_52 = ((-1) != (((uint16_t)((((int32_t)((void*)0 == l_119) + (int32_t)0xB50370D8) != l_111) < (((uint16_t)((uint16_t)((((int32_t)((int16_t)(-(uint32_t)p_53.f0) >> (int16_t)2) % (int32_t)p_54) <= ((uint32_t)0x100589B8 % (uint32_t)p_55)) || l_111) - (uint16_t)p_55) << (uint16_t)12) || l_92.f4)) >> (uint16_t)p_51) > p_53.f0));
                }
                if (l_92.f3)
                    goto lbl_137;
            }
        }
        for (p_55 = 0; (p_55 >= 3); p_55 += 3)
        { /* block id: 43 */
            p_52 = (0xAC0DF8BE <= ((uint16_t)0U >> (uint16_t)3));
            (**l_89) = (***l_88);
            if (l_97.f3)
                continue;
        }
    }
    else
    { /* block id: 48 */
lbl_137:
        (**l_89) = (void*)0;
        (*l_140) = l_138;
        p_52 = ((((uint16_t)(((int16_t)(((uint16_t)p_53.f0 + (uint16_t)(((int16_t)0x9A04 - (int16_t)((l_149 || 0x10A6) || (&p_53 == &p_53))) | p_54)) & p_54) << (int16_t)3) == ((((&p_52 != (void*)0) ^ 0xBDE6) | 0x48FE) || p_53.f0)) % (uint16_t)p_53.f0) != 0x8979) <= p_51);
        (*l_151) = l_150;
    }
    (*l_153) = l_152;
    (***l_88) = &p_52;
    /* statement id: 56 */
    assert (l_91 == &p_52);
    return p_53.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_56(uint32_t  p_57, uint16_t  p_58, uint8_t  p_59)
{ /* block id: 3 */
    int32_t l_73 = 0x39976036;
    int32_t *l_72 = &l_73;
    for (p_57 = 0; (p_57 != 5); p_57 += 5)
    { /* block id: 6 */
        int32_t **l_74 = &l_72;
        int32_t ****l_83 = (void*)0;
        int32_t ***l_85 = &l_74;
        int32_t ****l_84 = &l_85;
        (*l_74) = l_72;
        for (l_73 = 4; (l_73 == (-8)); l_73 -= 9)
        { /* block id: 10 */
            int32_t l_82 = 1;
            if ((*l_72))
            { /* block id: 11 */
                uint8_t l_79 = 0xC6;
                int32_t l_81 = 0xEE192EF5;
                int32_t *l_80 = &l_81;
                (*l_80) = (((uint16_t)(0x652606BD < (p_59 && p_57)) + (uint16_t)l_79) > 9);
                if ((**l_74))
                    break;
                (*l_80) = 0;
            }
            else
            { /* block id: 15 */
                return l_82;
            }
        }
        (*l_84) = &l_74;
    }
    return p_58;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 99
   depth: 1, occurrence: 9
   depth: 2, occurrence: 4
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 37
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 16
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 24
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 28
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 25

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 146
   depth: 2, occurrence: 16
   depth: 3, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 28, occurrence: 1
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 118

XXX times a variable address is taken: 117
XXX times a pointer is dereferenced on RHS: 48
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 17
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 64
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 156

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 86
   level: 2, occurrence: 33
   level: 3, occurrence: 9
   level: 4, occurrence: 11
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 72
XXX number of pointers point to scalars: 18
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 21.2
XXX average alias set size: 1.09

XXX times a non-volatile is read: 500
XXX times a non-volatile is write: 180
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 2

XXX stmts: 118
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 31
   depth: 2, occurrence: 20
   depth: 3, occurrence: 19
   depth: 4, occurrence: 13
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 23.9
XXX percentage an existing variable is used: 76.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

