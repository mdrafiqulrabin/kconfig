/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1478967736
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   uint32_t  f4;
   int32_t  f5;
   int32_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static struct S0  func_30(uint32_t  p_31, int32_t  p_32, uint32_t  p_33);
static int32_t  func_37(float  p_38);
static const struct S0 * func_48(struct S0 * p_49, struct S0 * p_50);
static struct S0 * func_51(struct S0 * p_52, int32_t  p_53, int16_t  p_54);
static uint32_t  func_62(const struct S0 * p_63, struct S0 * p_64, const uint32_t  p_65);
static const struct S0 * func_66(int16_t  p_67, int16_t  p_68);
static int16_t  func_69(struct S0 * p_70, int32_t  p_71);
static uint32_t  func_77(uint32_t  p_78, struct S0 * p_79, uint32_t  p_80, const int32_t  p_81);
static const int32_t  func_83(const uint32_t  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_34 = 4294967288UL;
    struct S0 *l_611 = (void*)0;
    struct S0 l_612 = {0xD0B4CBE2L,1L,0x899FF7E0L,-6L,7UL,0x9ED660DDL,0xA891C6EBL};
    int32_t *l_613 = &l_612.f5;
    int32_t **l_614 = &l_613;
    float *l_617 = (void*)0;
    float l_619 = 0x1.4p+1;
    float *l_618 = &l_619;
    int32_t *l_620 = &l_612.f2;
    uint32_t l_621 = 18446744073709551615UL;
    l_612 = func_30((l_34 & ((int32_t)l_34 - (int32_t)l_34)), func_37((l_34 < (((-0x4.Ap-1) == (l_34 , ((float)((float)(0x8.Ap+1 <= (((float)((0x4.7A7BF7p-26 >= (l_34 <= l_34)) == 0x5.Ap+1) + (float)l_34) <= l_34)) + (float)l_34) - (float)l_34))) == (-0x1.2p+1)))), l_34);
    (*l_614) = l_613;
    (*l_618) = ((float)(*l_613) + (float)__builtin_bswap32((**l_614)));
    (*l_614) = l_620;
    return l_621;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_30(uint32_t  p_31, int32_t  p_32, uint32_t  p_33)
{ /* block id: 299 */
    uint32_t l_404 = 18446744073709551615UL;
    struct S0 l_406 = {1L,0xA5A3F1FCL,0xB049E0BFL,-6L,4294967295UL,-1L,0xA2DC8A22L};
    int32_t *l_413 = &l_406.f2;
    float l_459 = 0x1.FC0F28p-73;
    float *l_458 = &l_459;
    float **l_457 = &l_458;
    int32_t **l_465 = &l_413;
    uint16_t l_531 = 65535UL;
    uint32_t l_596 = 0x6A0C7446L;
    int32_t ***l_600 = &l_465;
    float l_603 = 0x2.8p+1;
    int32_t *l_604 = (void*)0;
    int32_t *l_605 = &l_406.f6;
    float ****l_610 = (void*)0;
    if (p_33)
    { /* block id: 300 */
        float l_401 = 0x1.2p+1;
        float *l_400 = &l_401;
        int32_t l_405 = 0x85252EDAL;
        struct S0 *l_446 = (void*)0;
        int32_t l_462 = (-1L);
        const int32_t *l_474 = &l_406.f5;
        const int32_t **l_473 = &l_474;
        int32_t ***l_498 = &l_465;
        int32_t ****l_497 = &l_498;
        int32_t *****l_496 = &l_497;
        const struct S0 *l_540 = &l_406;
        const float *l_554 = (void*)0;
        const float **l_553 = &l_554;
        const float ***l_552 = &l_553;
        const uint32_t l_584 = 0xDCFF2DC4L;
        int32_t l_599 = 5L;
        const uint32_t l_601 = 1UL;
        (*l_400) = 0xD.985EBFp-9;
        if (((uint16_t)((l_404 , 0UL) && p_31) + (uint16_t)l_405))
        { /* block id: 302 */
            struct S0 l_412 = {1L,0xAC3E4CD2L,-1L,0x533699D0L,4294967291UL,0xE9C7D38CL,0xCD710A78L};
            int32_t **l_414 = &l_413;
            (*l_400) = (l_406 , 0xB.6B8AEEp+67);
            for (l_406.f3 = 0; (l_406.f3 != (-15)); l_406.f3 -= 5)
            { /* block id: 306 */
                int32_t *l_409 = (void*)0;
                int32_t *l_410 = &l_405;
                struct S0 l_411 = {1L,0L,0L,-1L,4294967295UL,0x9C6F0162L,0L};
                (*l_410) = l_405;
                l_412 = l_411;
            }
            (*l_414) = l_413;
        }
        else
        { /* block id: 311 */
            int32_t **l_415 = &l_413;
            struct S0 l_424 = {0L,0x25FD403CL,0x1F83F742L,0xBE7A1A03L,0UL,0xE55BC6F4L,-8L};
            int32_t ***l_429 = &l_415;
            int32_t ****l_428 = &l_429;
            int32_t *****l_454 = &l_428;
            float ****l_475 = (void*)0;
            (*l_415) = &l_405;
            if ((((uint16_t)(**l_415) - (uint16_t)(__builtin_parityll((*l_413)) >= (((**l_415) > ((int16_t)(func_37((*l_413)) , (1UL & ((int32_t)(**l_415) - (int32_t)l_405))) >> (int16_t)0)) & (*l_413)))) >= l_405))
            { /* block id: 313 */
                for (l_406.f0 = 0; (l_406.f0 <= (-20)); l_406.f0 -= 6)
                { /* block id: 316 */
                    return l_424;
                }
                p_32 = (-1L);
                for (l_424.f2 = 1; (l_424.f2 >= 15); l_424.f2 += 1)
                { /* block id: 322 */
                    int32_t l_427 = 0x2A454FFEL;
                    int32_t *l_432 = &l_424.f2;
                    struct S0 *l_434 = &l_406;
                    if (p_31)
                    { /* block id: 323 */
                        (*l_400) = (l_405 == l_427);
                        (*l_400) = (((void*)0 != l_428) != ((float)0x0.7p+1 - (float)0x8.8BF8B1p+77));
                    }
                    else
                    { /* block id: 326 */
                        struct S0 *l_433 = &l_406;
                        (***l_428) = l_432;
                        (*l_433) = l_424;
                    }
                    (*l_434) = l_406;
                }
            }
            else
            { /* block id: 332 */
                const struct S0 *l_445 = &l_406;
                const int32_t l_451 = (-3L);
                int32_t l_452 = (-1L);
                float ***l_488 = (void*)0;
                struct S0 *l_489 = &l_406;
                if (((((int16_t)(-4L) - (int16_t)((uint32_t)((int16_t)func_62(func_66((3L && ((int16_t)0xD321L - (int16_t)(p_31 , ((int16_t)p_32 % (int16_t)1UL)))), p_31), &l_424, l_405) % (int16_t)p_31) - (uint32_t)l_405)) > p_33) | l_451))
                { /* block id: 333 */
                    (*l_413) = __builtin_bswap32((*l_413));
                    (*l_415) = &p_32;
                    if (p_31)
                    { /* block id: 336 */
                        (****l_428) = (*l_413);
                        l_452 = p_31;
                    }
                    else
                    { /* block id: 339 */
                        int32_t *****l_453 = &l_428;
                        l_454 = l_453;
                    }
                    (****l_454) = (*l_415);
                }
                else
                { /* block id: 343 */
                    struct S0 **l_455 = (void*)0;
                    const struct S0 **l_456 = &l_445;
                    float ***l_460 = (void*)0;
                    float ***l_461 = &l_457;
                    (*l_456) = l_445;
                    (*l_461) = l_457;
                }
                (**l_429) = (p_31 , &l_405);
                if ((**l_415))
                { /* block id: 348 */
                    (*l_458) = l_462;
                    for (l_406.f6 = (-6); (l_406.f6 <= (-7)); l_406.f6 -= 1)
                    { /* block id: 352 */
                        struct S0 l_466 = {-1L,0xD9FA6931L,0xED792735L,1L,0xCF85484AL,0L,-8L};
                        struct S0 *l_467 = &l_466;
                        l_465 = (***l_454);
                        (*l_467) = l_466;
                        return l_424;
                    }
                }
                else
                { /* block id: 357 */
                    int16_t l_483 = 0x91BBL;
                    uint32_t l_490 = 0x53B0071AL;
                    if ((func_37(p_33) > (((int16_t)((uint16_t)6UL * (uint16_t)((***l_429) & (~0x8A28L))) << (int16_t)5) , ((void*)0 == l_473))))
                    { /* block id: 358 */
                        float *****l_476 = &l_475;
                        struct S0 *l_477 = &l_424;
                        (*l_476) = l_475;
                        (*l_477) = (*l_445);
                        (*l_477) = (p_32 , l_424);
                    }
                    else
                    { /* block id: 362 */
                        int16_t l_480 = 0x3EC1L;
                        (*l_458) = ((float)l_480 * (float)((float)((l_406 , l_483) > (__builtin_clzll(p_31) > func_69(&l_424, (***l_429)))) * (float)p_31));
                        (**l_457) = (((float)p_31 - (float)(*l_413)) == ((float)((((l_488 != &l_457) > func_69(func_51(((__builtin_parity(l_483) , (0L != p_32)) , l_489), l_480, p_31), l_490)) <= p_33) >= p_32) + (float)0x0.411ACEp+77));
                        (***l_429) = 0x05BBEE20L;
                        return l_406;
                    }
                }
                for (l_424.f3 = 0; (l_424.f3 == (-19)); l_424.f3 -= 1)
                { /* block id: 371 */
                    struct S0 l_493 = {0x1A1E9AEDL,0x75A7E47CL,0L,0L,0xF1E4962FL,0x3548150AL,1L};
                    int32_t *****l_499 = &l_497;
                    (*l_489) = l_493;
                    if (p_33)
                    { /* block id: 373 */
                        uint16_t l_494 = 65535UL;
                        int32_t l_502 = 1L;
                        l_502 = ((((l_494 , ((***l_429) && ((((~(l_496 != (p_31 , l_499))) >= ((uint16_t)(__builtin_parityll(l_451) ^ 4294967295UL) * (uint16_t)(-5L))) && p_31) < p_31))) , p_31) == p_33) != p_32);
                    }
                    else
                    { /* block id: 375 */
                        (*l_458) = (**l_415);
                        l_493 = l_406;
                        p_32 = (p_31 && (*****l_499));
                    }
                    (*l_489) = l_406;
                }
            }
        }
        for (l_462 = 23; (l_462 != 19); l_462 -= 1)
        { /* block id: 386 */
            struct S0 *l_511 = &l_406;
            int32_t l_520 = 0x10D0315CL;
            float **l_537 = &l_400;
            const struct S0 *l_543 = (void*)0;
            int32_t *l_561 = &l_406.f2;
            int32_t *****l_590 = &l_497;
        }
        p_32 = (p_33 | (((((((((((~0x7D23L) || (l_596 == ((uint16_t)func_62(&l_406, (p_31 , (p_31 , &l_406)), p_31) * (uint16_t)l_599))) , (*l_552)) != (void*)0) || 0UL) != p_32) == p_33) , l_600) != (void*)0) < l_601) >= p_31));
    }
    else
    { /* block id: 433 */
        struct S0 l_602 = {0xB32115BCL,0xE60CE41AL,9L,0x50F65B8BL,0x7ABCC978L,0x8946FC38L,-6L};
        return l_602;
    }
    (*l_465) = (void*)0;
    (*l_605) = p_31;
    (**l_600) = ((((uint16_t)p_31 << (uint16_t)((int16_t)__builtin_parityll(p_33) * (int16_t)(l_610 == l_610))) <= p_32) , &p_32);
    return l_406;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_37(float  p_38)
{ /* block id: 37 */
    int32_t l_45 = (-8L);
    struct S0 l_385 = {0L,0x7D4B7D85L,0xBEB43ED5L,1L,0xF7ED305FL,0x5C55A6DBL,0x6E405D19L};
    struct S0 *l_384 = &l_385;
    int16_t l_396 = 0x08A8L;
    int32_t *l_397 = &l_385.f6;
    int32_t **l_398 = &l_397;
    uint16_t l_399 = 65532UL;
    for (l_45 = 0; (l_45 <= 6); l_45 += 1)
    { /* block id: 40 */
        int32_t l_55 = 0x1B09C821L;
        const struct S0 *l_395 = (void*)0;
        const struct S0 **l_394 = &l_395;
        (*l_394) = func_48(func_51((l_55 , (void*)0), l_55, l_55), l_384);
        if (l_385.f2)
            continue;
        if (l_396)
            break;
    }
    l_397 = &l_45;
    (*l_398) = &l_45;
    (*l_384) = (*l_384);
    return l_399;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0 * func_48(struct S0 * p_49, struct S0 * p_50)
{ /* block id: 286 */
    const int32_t *l_386 = (void*)0;
    int32_t l_389 = 7L;
    int32_t *l_388 = &l_389;
    int32_t **l_387 = &l_388;
    float l_391 = (-0x6.1p+1);
    float *l_390 = &l_391;
    const struct S0 l_393 = {0x6F6BB869L,7L,0x29A9F4B6L,0x4BF22C21L,0xD5FA84D3L,0x9400A60BL,0x6B061BF0L};
    const struct S0 *l_392 = &l_393;
    (*l_387) = l_386;
    (*l_390) = 0x2.5p-1;
    (*l_387) = (*l_387);
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_51(struct S0 * p_52, int32_t  p_53, int16_t  p_54)
{ /* block id: 41 */
    const struct S0 l_59 = {0x84B505D0L,0xCD43A1E2L,6L,-2L,0x26315BFEL,0x1EC6C048L,6L};
    const struct S0 *l_58 = &l_59;
    struct S0 l_246 = {0L,0x29E7C32AL,0xBFF7CC21L,0x93EBF62BL,0x3680A182L,0x553D69D3L,0xC18B8741L};
    struct S0 *l_245 = &l_246;
    int32_t *l_323 = &l_246.f2;
    int16_t l_376 = 0xE60AL;
    uint32_t l_379 = 1UL;
    float l_381 = 0x0.Dp-1;
    float *l_380 = &l_381;
    struct S0 *l_382 = &l_246;
    int32_t **l_383 = &l_323;
    if (((uint16_t)(((l_58 != &l_59) , l_59.f5) | (((uint16_t)p_53 * (uint16_t)65531UL) == (0x1939L > 3L))) >> (uint16_t)(0x7DDC4EA3L <= func_62(func_66(func_69(p_52, l_59.f6), p_53), l_245, p_54))))
    { /* block id: 230 */
        int32_t *l_303 = &l_246.f5;
        uint32_t l_322 = 0x84E41F5CL;
        struct S0 l_337 = {0x78FE824BL,0x8217980DL,-7L,-1L,4294967287UL,0L,0x9F7C56E5L};
        for (p_54 = 12; (p_54 <= (-30)); p_54 -= 1)
        { /* block id: 233 */
            int32_t **l_304 = &l_303;
            (*l_304) = l_303;
            (*l_304) = (void*)0;
        }
        for (p_54 = 0; (p_54 > 12); p_54 += 1)
        { /* block id: 239 */
            int32_t **l_313 = &l_303;
            int32_t l_338 = 0L;
            for (l_246.f4 = 0; (l_246.f4 == 55); l_246.f4 += 1)
            { /* block id: 242 */
                int32_t ***l_309 = (void*)0;
                int32_t ****l_310 = &l_309;
                struct S0 l_339 = {0xEBC1DC1DL,-1L,-1L,0x06D11D72L,0UL,0xD771F687L,0xFBCA4FFCL};
                (*l_310) = l_309;
                if (((((((p_54 != ((int16_t)((void*)0 == l_313) + (int16_t)(__builtin_parityl(((((float)((float)((func_69(p_52, l_59.f3) >= (-0x10.Ap+1)) < (0x1.Cp+1 <= __builtin_clzll(((int16_t)(((uint16_t)((((void*)0 != l_313) != p_53) || 0L) - (uint16_t)l_246.f0) == p_54) >> (int16_t)11)))) - (float)p_53) - (float)p_53) >= l_322) , 0xB6934789L)) || p_53))) , l_323) == l_323) , p_53) , p_54) != 0x392BCE64L))
                { /* block id: 244 */
                    struct S0 **l_324 = &l_245;
                    struct S0 l_325 = {-1L,0x0BCBD8F1L,0x4546C99FL,1L,0UL,0x5F262337L,0x8D430450L};
                    const int32_t l_328 = 2L;
                    (*l_324) = &l_59;
                    l_325 = (**l_324);
                    if (p_54)
                    { /* block id: 247 */
                        float l_329 = (-0x6.Ap-1);
                        (*l_324) = (void*)0;
                        (*l_313) = (void*)0;
                        (*l_323) = ((uint16_t)p_53 >> (uint16_t)(l_325.f5 , l_328));
                    }
                    else
                    { /* block id: 251 */
                        int16_t l_334 = (-8L);
                        int32_t *l_340 = &l_325.f2;
                        (*l_323) = ((int32_t)((*l_323) > (((uint32_t)(p_54 | 0x50B5D90FL) - (uint32_t)l_334) ^ (*l_323))) % (int32_t)((uint16_t)(l_337 , (p_54 <= ((p_52 != (void*)0) > (*l_323)))) % (uint16_t)l_338));
                        l_303 = (p_54 , (l_339 , l_340));
                        return p_52;
                    }
                }
                else
                { /* block id: 256 */
                    return p_52;
                }
            }
            for (l_246.f5 = (-9); (l_246.f5 != (-2)); l_246.f5 += 1)
            { /* block id: 262 */
                uint32_t l_348 = 0xDE05E415L;
                struct S0 *l_351 = &l_337;
                (*l_351) = ((-(uint32_t)((uint32_t)((int32_t)(p_53 != func_83(p_53)) % (int32_t)p_53) % (uint32_t)(*l_323))) , (*l_351));
            }
        }
    }
    else
    { /* block id: 266 */
        struct S0 l_352 = {0xBA570378L,0L,1L,0x301A20F0L,0x71E1CBA1L,7L,0x6DA0623DL};
        int32_t *l_353 = &l_246.f5;
        int32_t **l_358 = &l_353;
        int32_t ***l_357 = &l_358;
        (*l_245) = l_352;
        l_353 = l_323;
        for (l_352.f5 = 23; (l_352.f5 >= 3); l_352.f5 -= 1)
        { /* block id: 271 */
            int32_t *l_356 = &l_352.f5;
            l_323 = l_356;
        }
        if ((l_357 != (void*)0))
        { /* block id: 274 */
            int32_t l_361 = (-2L);
            uint32_t l_367 = 4294967292UL;
            (**l_357) = (*l_358);
            (*l_358) = ((&l_358 != ((((p_54 , p_53) | p_54) > ((int32_t)((((***l_357) <= l_361) , ((((((float)(***l_357) * (float)l_361) , ((!(((float)((__builtin_clz((***l_357)) != 0x1.3p+1) < p_54) * (float)(-0x1.1p-1)) <= (*l_353))) , l_367)) || 0x6E46L) > (*l_323)) & l_367)) <= (*l_353)) % (int32_t)1L)) , &l_358)) , (void*)0);
        }
        else
        { /* block id: 277 */
            (**l_357) = (void*)0;
            (*l_323) = (!(-(uint16_t)(p_53 , p_54)));
        }
    }
    (*l_380) = ((((uint32_t)((uint32_t)l_246.f3 - (uint32_t)((((__builtin_ffs((func_77((__builtin_parity(((p_53 & ((int16_t)p_54 % (int16_t)p_53)) , p_54)) , ((p_54 && l_376) >= (((((uint16_t)0UL * (uint16_t)p_53) , (-0x7.5p-1)) , l_379) != p_53))), p_52, p_53, p_54) , p_54)) < p_54) == (-0x1.Cp+1)) , &l_58) != &l_245)) + (uint32_t)l_59.f5) | p_53) , 0xB.74A590p-8);
    (*l_382) = (*l_58);
    (*l_383) = l_380;
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_62(const struct S0 * p_63, struct S0 * p_64, const uint32_t  p_65)
{ /* block id: 195 */
    uint32_t l_249 = 1UL;
    int32_t l_253 = 0L;
    const int32_t **l_257 = (void*)0;
    const int32_t ***l_256 = &l_257;
    int32_t l_274 = 0x09BB11AEL;
    struct S0 l_277 = {1L,0x35A2EF25L,3L,-1L,0x71C78C10L,0x7D3ECDBFL,0x9D43D75DL};
    struct S0 *l_276 = &l_277;
    struct S0 **l_275 = &l_276;
    float *l_285 = (void*)0;
    float l_298 = 0xF.715371p+61;
    if (((int32_t)l_249 + (int32_t)(__builtin_ffs(l_249) | ((-(int32_t)(l_249 < p_65)) | (p_65 <= (((((0UL >= p_65) > ((int16_t)(l_253 | 0x36DCL) >> (int16_t)l_249)) >= l_249) && p_65) ^ p_65))))))
    { /* block id: 196 */
        struct S0 l_259 = {0xEB809281L,0xF83735A5L,0L,0L,0x21D59750L,0xABC08B88L,1L};
        struct S0 *l_258 = &l_259;
        float l_264 = 0xD.BC2A71p+65;
        float *l_263 = &l_264;
        for (l_249 = 0; (l_249 > 45); l_249 += 1)
        { /* block id: 199 */
            struct S0 **l_260 = &l_258;
            l_256 = (void*)0;
            (*l_260) = l_258;
        }
        l_253 = p_65;
        (*l_263) = (((((int16_t)p_65 >> (int16_t)6) == p_65) ^ 9L) , p_65);
    }
    else
    { /* block id: 205 */
        const int32_t *l_265 = &l_253;
        int32_t *l_267 = &l_253;
        int32_t **l_266 = &l_267;
        (*l_266) = l_265;
        l_253 = p_65;
        for (l_249 = (-22); (l_249 >= 6); l_249 += 1)
        { /* block id: 210 */
            struct S0 l_270 = {1L,0xD91489F9L,0xF7C5DDF7L,-1L,0xCA0AF4E1L,0x5C576665L,-4L};
            (*p_64) = l_270;
        }
        for (l_249 = (-12); (l_249 >= 30); l_249 += 7)
        { /* block id: 215 */
            int32_t *l_273 = &l_253;
            (*l_266) = l_273;
            if (p_65)
                continue;
            (*p_64) = (*p_64);
        }
    }
    (*l_275) = func_66(p_65, l_274);
    for (l_277.f4 = 9; (l_277.f4 < 22); l_277.f4 += 3)
    { /* block id: 224 */
        struct S0 l_282 = {0L,-10L,0xB7E9D353L,-1L,0x2AD3A7C0L,0xD4C3E8A8L,0xFDAFAEC7L};
        float l_284 = (-0x9.Cp+1);
        float *l_283 = &l_284;
        int32_t *l_300 = &l_282.f5;
        int32_t **l_299 = &l_300;
        l_282.f5 = ((float)p_65 - (float)((l_282 , (l_283 == l_285)) == ((((float)__builtin_bswap32(((!(-(int16_t)p_65)) > func_77(l_282.f1, &l_282, p_65, (((uint16_t)((((float)((((float)((float)(p_65 < 0xC.8C5570p-77) - (float)(-0x1.3p-1)) * (float)p_65) >= 0x1.Ap-1) < 0x8.2CF235p+50) + (float)p_65) , l_282.f5) , 8UL) * (uint16_t)p_65) || p_65)))) + (float)0x4.0p+1) < (-0x1.Dp+1)) <= (-0x1.2p+1))));
        (*l_299) = (void*)0;
        (*p_64) = (*p_64);
    }
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0 * func_66(int16_t  p_67, int16_t  p_68)
{ /* block id: 141 */
    struct S0 *l_189 = (void*)0;
    struct S0 **l_190 = (void*)0;
    struct S0 l_191 = {1L,-1L,6L,-9L,0xE1C8D462L,1L,-10L};
    struct S0 *l_192 = &l_191;
    const int32_t *l_200 = &l_191.f6;
    const int32_t **l_199 = &l_200;
    const struct S0 *l_240 = &l_191;
    const struct S0 *l_241 = &l_191;
    const struct S0 *l_242 = &l_191;
    const struct S0 *l_243 = &l_191;
    const struct S0 *l_244 = (void*)0;
    l_189 = l_189;
    l_189 = l_189;
    (*l_192) = (l_191 , l_191);
    for (l_191.f2 = 18; (l_191.f2 <= 6); l_191.f2 -= 4)
    { /* block id: 147 */
        int16_t l_201 = 0xB6A0L;
        struct S0 **l_207 = &l_189;
        int32_t **l_210 = (void*)0;
        int32_t ***l_209 = &l_210;
        uint32_t l_236 = 4294967295UL;
        int32_t *l_239 = (void*)0;
    }
    return l_244;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_69(struct S0 * p_70, int32_t  p_71)
{ /* block id: 42 */
    uint16_t l_76 = 0xD441L;
    struct S0 *l_82 = (void*)0;
    int32_t l_172 = (-1L);
    int32_t *l_171 = &l_172;
    if (((uint16_t)(((uint32_t)p_71 - (uint32_t)l_76) | func_77((p_70 == l_82), l_82, (func_83(p_71) & (l_76 >= ((+(l_171 == &l_172)) | (*l_171)))), (*l_171))) >> (uint16_t)4))
    { /* block id: 134 */
        int32_t *l_185 = &l_172;
        const int32_t *l_187 = &l_172;
        const int32_t **l_186 = &l_187;
        (*l_186) = l_185;
    }
    else
    { /* block id: 136 */
        int32_t l_188 = 9L;
        (*l_171) = (*l_171);
        return l_188;
    }
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_77(uint32_t  p_78, struct S0 * p_79, uint32_t  p_80, const int32_t  p_81)
{ /* block id: 122 */
    uint32_t l_179 = 0xC0E6D3FFL;
    int32_t l_181 = 0x872FA332L;
    int32_t *l_180 = &l_181;
    int32_t **l_182 = &l_180;
    struct S0 l_183 = {0L,1L,0x1FDF78E1L,0xECE3592EL,0x31D69C6CL,0xE70D6C77L,-1L};
    struct S0 *l_184 = &l_183;
    for (p_78 = 0; (p_78 != 11); p_78 += 1)
    { /* block id: 125 */
        int32_t *l_175 = (void*)0;
        int32_t **l_176 = &l_175;
        struct S0 l_177 = {0x88898D0BL,0x58DE8A0DL,0x83A45DBAL,-1L,0x3DA66330L,0x89493EADL,0x2A9FDAC8L};
        struct S0 *l_178 = &l_177;
        (*l_176) = l_175;
        (*l_178) = l_177;
        l_179 = __builtin_parity(p_80);
    }
    l_180 = l_180;
    (*l_182) = &l_181;
    (*l_184) = l_183;
    return p_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_83(const uint32_t  p_84)
{ /* block id: 43 */
    int32_t l_86 = 0L;
    int32_t *l_85 = &l_86;
    int32_t **l_87 = &l_85;
    struct S0 l_118 = {-7L,0L,-3L,-9L,0x5757325AL,-1L,0x016E9852L};
    struct S0 l_128 = {7L,-1L,0xE1296421L,0xF86792DBL,0x0B25D924L,-1L,-3L};
    l_85 = l_85;
    (*l_87) = &l_86;
    for (l_86 = 21; (l_86 != (-2)); l_86 -= 1)
    { /* block id: 48 */
        int32_t l_90 = 0x9B4DB59FL;
        int32_t l_100 = 0x5A291505L;
        const struct S0 l_127 = {0x52B1B1FAL,0xA7086DEEL,0x808A6355L,0L,4294967295UL,0xC22977FDL,0x66E85BCFL};
        int32_t ***l_150 = (void*)0;
        for (l_90 = 0; (l_90 < (-21)); l_90 -= 2)
        { /* block id: 51 */
            int32_t l_93 = (-7L);
            struct S0 l_119 = {-1L,2L,0x68E4F1A1L,0x6DEAED54L,0x57EB9077L,0xC5754D5CL,0x110172C6L};
            int32_t *l_120 = &l_93;
            struct S0 *l_155 = &l_118;
        }
    }
    for (l_128.f3 = (-21); (l_128.f3 < (-23)); l_128.f3 -= 9)
    { /* block id: 110 */
        int32_t *l_158 = &l_118.f6;
        int32_t ***l_167 = &l_87;
        if (p_84)
        { /* block id: 111 */
            float l_160 = 0x2.CE1111p-35;
            float *l_159 = &l_160;
            (*l_87) = l_158;
            l_118 = l_128;
            (*l_159) = 0x0.0p+1;
            if ((*l_158))
                break;
        }
        else
        { /* block id: 116 */
            struct S0 l_161 = {0x7E95F642L,0L,0xDB30E8A7L,0xAF8E2B3DL,0x35D9A7C6L,-10L,1L};
            l_161 = l_118;
        }
        (*l_158) = (((+0x91B0L) & (((int32_t)(*l_158) - (int32_t)(((((uint16_t)(*l_158) << (uint16_t)14) , p_84) <= (-4L)) & ((**l_87) > ((((((void*)0 == l_167) ^ (((uint16_t)(**l_87) >> (uint16_t)p_84) , 0xE7F41821L)) , p_84) ^ 0xF0EDL) == 0L)))) || (***l_167))) < p_84);
    }
    return p_84;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 145
   depth: 1, occurrence: 28
XXX total union variables: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 206
   depth: 2, occurrence: 31
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 165

XXX times a variable address is taken: 168
XXX times a pointer is dereferenced on RHS: 75
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 18
   depth: 3, occurrence: 10
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 118
breakdown:
   depth: 1, occurrence: 106
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 318

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 380
   level: 2, occurrence: 66
   level: 3, occurrence: 27
   level: 4, occurrence: 12
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 63
XXX number of pointers point to scalars: 56
XXX number of pointers point to structs: 46
XXX percent of pointers has null in alias set: 27.3
XXX average alias set size: 1.33

XXX times a non-volatile is read: 702
XXX times a non-volatile is write: 332
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 161
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 45
   depth: 1, occurrence: 33
   depth: 2, occurrence: 25
   depth: 3, occurrence: 12
   depth: 4, occurrence: 19
   depth: 5, occurrence: 27

XXX percentage a fresh-made variable is used: 22.7
XXX percentage an existing variable is used: 77.3
********************* end of statistics **********************/

