/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      525805750
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_31(void);
static int8_t  func_51(uint32_t  p_52);
static uint32_t  func_55(int32_t  p_56, uint32_t  p_57, uint16_t  p_58, int32_t  p_59);
static uint64_t  func_63(int32_t  p_64);
static uint8_t  func_65(uint8_t  p_66, int32_t  p_67, int32_t  p_68, uint32_t  p_69, int8_t  p_70);
static uint64_t  func_74(uint32_t  p_75, uint64_t  p_76, uint16_t  p_77);
static int64_t  func_79(uint8_t  p_80);
static uint64_t  func_85(uint32_t  p_86, int32_t  p_87, uint8_t  p_88);
static uint16_t  func_95(uint64_t  p_96, int16_t  p_97, uint8_t  p_98);
static int64_t  func_99(uint32_t  p_100, uint16_t  p_101, int32_t  p_102, int8_t  p_103, int32_t  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_31(void)
{ /* block id: 36 */
    int32_t l_36 = 5L;
    int8_t l_333 = (-1L);
    if ((18446744073709551607UL & ((int16_t)((uint16_t)__builtin_ctzll(l_36) << (uint16_t)7) * (int16_t)((uint8_t)((uint64_t)((((((uint32_t)l_36 - (uint32_t)l_36) == ((uint64_t)l_36 % (uint64_t)((uint64_t)((int32_t)(((int8_t)func_51(((((uint32_t)l_36 - (uint32_t)(l_36 ^ func_55(((+(l_36 <= l_36)) && l_36), l_36, l_36, l_36))) >= (-1L)) || l_36)) >> (int8_t)3) , (-2L)) - (int32_t)4294967291UL) + (uint64_t)l_36))) & l_36) == 0xD816L) < l_333) + (uint64_t)l_36) % (uint8_t)l_333))))
    { /* block id: 165 */
        int32_t *l_336 = (void*)0;
        int32_t **l_335 = &l_336;
        int32_t ***l_334 = &l_335;
        int32_t ****l_337 = &l_334;
        (*l_337) = l_334;
        return l_333;
    }
    else
    { /* block id: 168 */
        int32_t l_342 = 0L;
        for (l_333 = 14; (l_333 <= (-23)); l_333 -= 1)
        { /* block id: 171 */
            int32_t *l_340 = &l_36;
            int32_t ***l_345 = (void*)0;
            int32_t ****l_344 = &l_345;
            int32_t *****l_343 = &l_344;
            l_340 = &l_36;
            (*l_340) = (+(l_342 | (((l_333 == l_342) , (*l_340)) != (((l_333 ^ (*l_340)) & (((l_343 == &l_344) < (*l_340)) | 0xCEE0769A12CBEF5CLL)) & l_333))));
        }
        return l_36;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_51(uint32_t  p_52)
{ /* block id: 163 */
    int8_t l_332 = 0x31L;
    return l_332;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_55(int32_t  p_56, uint32_t  p_57, uint16_t  p_58, int32_t  p_59)
{ /* block id: 37 */
    int32_t l_73 = 0x708880D0L;
    uint32_t l_246 = 18446744073709551615UL;
    int16_t l_248 = 0xE662L;
    int32_t l_270 = 1L;
    int32_t *l_269 = &l_270;
    int32_t ****l_288 = (void*)0;
    int32_t **l_290 = (void*)0;
    int32_t **l_291 = &l_269;
    int32_t *l_292 = &l_270;
    for (p_58 = 0; (p_58 >= 16); ++p_58)
    { /* block id: 40 */
        int32_t l_83 = 0x4ADCF861L;
        int32_t l_257 = 0x53969774L;
        int32_t *l_271 = (void*)0;
        uint16_t l_287 = 0x0682L;
        p_56 = (func_63((0x66L & func_65((((int64_t)l_73 - (int64_t)func_74((((l_73 != (((!func_79((((uint16_t)((l_83 > l_83) <= p_58) * (uint16_t)((~__builtin_parityll(((__builtin_popcountll(func_85(p_56, l_73, p_59)) <= l_73) != l_246))) ^ 0xEF3CA3E2L)) || l_73))) >= l_73) && l_73)) | l_246) >= l_73), l_246, l_248)) < p_59), l_246, l_257, l_257, p_56))) == l_246);
        l_271 = l_269;
        for (l_246 = (-20); (l_246 > 22); l_246 += 7)
        { /* block id: 129 */
            int32_t l_286 = 0x4B791F81L;
            int32_t *****l_289 = &l_288;
            if (p_59)
                break;
            (*l_289) = ((((int8_t)((0UL >= ((uint16_t)((((((void*)0 == &p_56) , p_56) & (((uint8_t)((p_57 >= func_79((p_58 == ((uint8_t)func_63((p_56 , (((0xABA3EDC0E5944C72LL ^ ((int64_t)(((int16_t)(p_59 , l_286) << (int16_t)(*l_271)) , p_58) + (int64_t)p_57)) , p_56) , l_287))) - (uint8_t)p_57)))) > 0x1CL) << (uint8_t)p_59) | p_59)) ^ 0x1991L) >= p_57) + (uint16_t)l_286)) > 2L) % (int8_t)l_286) && (*l_269)) , l_288);
        }
        if ((*l_269))
            continue;
    }
    (*l_291) = &p_56;
    (*l_291) = (p_58 , l_292);
    for (p_56 = (-2); (p_56 < 0); p_56 += 2)
    { /* block id: 139 */
        int64_t l_295 = 2L;
        int32_t *****l_315 = &l_288;
        uint32_t l_326 = 18446744073709551613UL;
    }
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_63(int32_t  p_64)
{ /* block id: 121 */
    int32_t l_267 = 0xBFBAFD82L;
    int32_t *l_266 = &l_267;
    int32_t **l_265 = &l_266;
    int32_t ***l_268 = &l_265;
    (*l_268) = l_265;
    (***l_268) = (***l_268);
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_65(uint8_t  p_66, int32_t  p_67, int32_t  p_68, uint32_t  p_69, int8_t  p_70)
{ /* block id: 110 */
    uint32_t l_258 = 18446744073709551615UL;
    int32_t l_260 = 0xF62BBA29L;
    int32_t *l_259 = &l_260;
    int32_t **l_261 = &l_259;
    (*l_259) = ((l_258 , p_68) | l_258);
    (*l_261) = &l_260;
    (**l_261) = (*l_259);
    for (p_70 = 0; (p_70 != (-15)); p_70 -= 3)
    { /* block id: 116 */
        int32_t *l_264 = &l_260;
        (*l_261) = l_264;
        (*l_261) = (*l_261);
    }
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_74(uint32_t  p_75, uint64_t  p_76, uint16_t  p_77)
{ /* block id: 102 */
    int32_t *l_254 = (void*)0;
    int32_t **l_255 = &l_254;
    uint64_t l_256 = 0UL;
    for (p_75 = 8; (p_75 != 8); p_75 += 3)
    { /* block id: 105 */
        int32_t l_252 = 9L;
        int32_t *l_251 = &l_252;
        int32_t **l_253 = &l_251;
        (*l_253) = l_251;
    }
    (*l_255) = l_254;
    return l_256;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_79(uint8_t  p_80)
{ /* block id: 100 */
    int16_t l_247 = (-9L);
    return l_247;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_85(uint32_t  p_86, int32_t  p_87, uint8_t  p_88)
{ /* block id: 41 */
    int64_t l_105 = (-8L);
    int32_t l_108 = 0L;
    uint8_t l_245 = 0x36L;
    if ((((uint64_t)((uint16_t)((uint16_t)func_95((((p_86 && (func_99(p_87, l_105, __builtin_ia32_crc32qi(p_88, __builtin_popcount(((l_105 | l_105) >= (p_86 , (((int16_t)__builtin_parityll(l_105) % (int16_t)l_105) <= p_86))))), l_105, l_108) <= 1UL)) > p_86) , p_87), l_105, l_108) << (uint16_t)l_105) << (uint16_t)11) % (uint64_t)p_86) == l_105))
    { /* block id: 80 */
        int64_t l_221 = 1L;
        int32_t **l_234 = (void*)0;
        if (l_221)
        { /* block id: 81 */
            int32_t l_232 = (-8L);
            int32_t **l_240 = (void*)0;
            int32_t *l_242 = &l_108;
            int32_t **l_241 = &l_242;
            if (((int8_t)(((uint8_t)l_221 + (uint8_t)((int16_t)p_86 >> (int16_t)(p_86 <= ((void*)0 == &p_87)))) , ((int16_t)l_221 % (int16_t)((int16_t)l_232 * (int16_t)(!0UL)))) >> (int8_t)(p_88 != 65535UL)))
            { /* block id: 82 */
                int32_t ***l_235 = &l_234;
                (*l_235) = l_234;
            }
            else
            { /* block id: 84 */
                for (l_221 = (-21); (l_221 < (-19)); l_221++)
                { /* block id: 87 */
                    int32_t *l_238 = &l_232;
                    int32_t **l_239 = &l_238;
                    (*l_239) = l_238;
                }
            }
            (*l_241) = &l_232;
            return p_86;
        }
        else
        { /* block id: 93 */
            uint64_t l_243 = 0x7EFD3BFD25B55C4BLL;
            return l_243;
        }
    }
    else
    { /* block id: 96 */
        int32_t *l_244 = &l_108;
        (*l_244) = 1L;
    }
    return l_245;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_95(uint64_t  p_96, int16_t  p_97, uint8_t  p_98)
{ /* block id: 44 */
    int16_t l_109 = 0xBC08L;
    int32_t l_115 = (-1L);
    int32_t *l_114 = &l_115;
    int32_t **l_218 = &l_114;
    int32_t ***l_217 = &l_218;
    int32_t ****l_216 = &l_217;
    if (((p_98 ^ p_98) ^ ((p_96 | (l_109 > ((uint64_t)0xE7BE98B872472F85LL - (uint64_t)(l_109 | (p_97 , (((uint8_t)(p_96 , l_109) >> (uint8_t)l_109) , p_97)))))) >= p_98)))
    { /* block id: 45 */
        int32_t *l_124 = &l_115;
        int8_t l_136 = (-1L);
        int64_t l_150 = (-1L);
        int16_t l_153 = 0xA635L;
        int16_t l_165 = (-2L);
        int32_t *l_181 = (void*)0;
        l_114 = l_114;
        if ((+(((uint16_t)0x3CC5L * (uint16_t)(*l_114)) | p_96)))
        { /* block id: 47 */
            int8_t l_135 = 0x12L;
            int32_t **l_144 = (void*)0;
            uint8_t l_166 = 0UL;
            l_114 = &l_115;
            if (p_98)
            { /* block id: 49 */
                uint64_t l_119 = 0UL;
                int32_t **l_137 = &l_114;
                (*l_124) = ((l_119 == (func_99(p_96, ((int16_t)(p_97 , l_119) << (int16_t)9), ((((int16_t)(l_124 != (((((uint16_t)(+((p_96 || ((uint16_t)((int16_t)(*l_124) * (int16_t)((((((~(l_119 , ((int8_t)((p_98 < p_96) <= p_97) * (int8_t)p_97))) , p_98) , 0x16D66C253094EEE5LL) ^ p_98) == l_135) && p_97)) % (uint16_t)0xA9CEL)) < l_135)) >> (uint16_t)p_97) , (void*)0) != &l_115) , &l_115)) << (int16_t)0) != (*l_124)) || p_96), l_136, l_119) ^ l_135)) <= 1UL);
                (*l_114) = (-3L);
                (*l_137) = &l_115;
            }
            else
            { /* block id: 53 */
                int64_t l_145 = 0xFF246F767204C5B3LL;
                int16_t l_151 = 0xE860L;
                int32_t **l_152 = &l_114;
                (**l_152) = ((int8_t)((uint8_t)((0x9DL && (((uint32_t)(l_144 == (func_99(p_98, l_145, (func_99(p_96, (func_99((((((uint16_t)((uint16_t)p_96 >> (uint16_t)p_96) >> (uint16_t)6) , ((p_97 , (((func_99(p_96, l_145, l_150, (*l_124), l_151) < 0xB9A73505L) , l_152) == l_152)) || (*l_114))) | (**l_152)) , (*l_114)), (*l_124), p_96, p_98, (*l_124)) , (*l_124)), p_97, (*l_114), p_96) ^ p_96), l_153, (*l_124)) , (void*)0)) + (uint32_t)l_135) != p_97)) > (*l_114)) * (uint8_t)0xC7L) * (int8_t)p_98);
                (*l_152) = (((255UL & ((uint16_t)(__builtin_clz(((uint16_t)p_98 * (uint16_t)((uint8_t)(p_98 ^ p_96) - (uint8_t)((+((p_97 , func_99((((uint8_t)(0UL > (*l_124)) - (uint8_t)l_135) , ((int16_t)((void*)0 == l_152) - (int16_t)l_165)), (*l_124), (*l_124), p_96, l_166)) != p_96)) == p_98)))) | 0UL) * (uint16_t)0x1215L)) && (*l_114)) , (void*)0);
                (*l_124) = p_98;
            }
        }
        else
        { /* block id: 58 */
            uint64_t l_169 = 18446744073709551615UL;
            int32_t ***l_179 = (void*)0;
            int32_t ****l_180 = &l_179;
            (*l_180) = ((((((int8_t)__builtin_parityl(p_98) >> (int8_t)1) && p_97) && l_169) , ((uint8_t)(-(uint8_t)func_99(((uint16_t)(*l_124) >> (uint16_t)((uint8_t)l_169 * (uint8_t)(65528UL & (p_98 > (((uint16_t)((((l_169 < p_96) != l_169) | p_96) < p_98) >> (uint16_t)p_97) == (*l_114)))))), p_96, p_96, p_98, (*l_124))) << (uint8_t)p_97)) , l_179);
            l_181 = (void*)0;
            for (p_97 = 0; (p_97 < 7); p_97 += 9)
            { /* block id: 63 */
                uint64_t l_187 = 0x0240E7FB8437FCE8LL;
                (*l_124) = (*l_114);
                (*l_114) = (((*l_114) > ((((((int16_t)(!l_187) << (int16_t)(*l_114)) & ((18446744073709551615UL ^ (((((p_97 & (-(int32_t)(((~p_96) == (p_98 | 0x36D3L)) , ((uint8_t)__builtin_bswap32(__builtin_parityll(p_96)) * (uint8_t)0x15L)))) <= p_98) , p_96) | l_187) , 0L)) & p_96)) || p_96) < (*l_124)) < p_96)) , p_97);
            }
        }
    }
    else
    { /* block id: 68 */
        int32_t l_193 = (-1L);
        int8_t l_202 = 0x14L;
        int32_t **l_209 = &l_114;
        int32_t ***l_208 = &l_209;
        if ((+func_99(((p_97 >= (l_193 == (((int16_t)((((uint8_t)(l_193 , ((int32_t)1L - (int32_t)(func_99((*l_114), l_193, (&l_115 != (((0UL < ((uint16_t)p_97 + (uint16_t)p_98)) > 0x3DL) , &l_115)), l_193, (*l_114)) , (-10L)))) << (uint8_t)1) , p_97) , (-9L)) * (int16_t)0x77CFL) , 0xE9L))) != p_98), p_98, (*l_114), l_202, (*l_114))))
        { /* block id: 69 */
            int64_t l_207 = 0x5C62FD6A48C62504LL;
            int32_t ***l_211 = &l_209;
            (*l_114) = ((int8_t)(((int8_t)l_193 * (int8_t)(l_207 != (((*l_114) , l_208) == ((+(*l_114)) , ((*l_114) , l_211))))) == __builtin_parityl(p_98)) * (int8_t)0UL);
            (**l_209) = ((p_96 ^ (***l_211)) == 7UL);
        }
        else
        { /* block id: 72 */
            (**l_209) = 6L;
        }
        (*l_114) = (-10L);
        (***l_208) = (((0xCF4DL < 0x9112L) <= (((int32_t)p_96 + (int32_t)((uint16_t)p_96 + (uint16_t)(&l_208 != l_216))) < (((***l_217) , ((int8_t)6L >> (int8_t)((__builtin_ffsl(p_98) , 0x9E7AL) & p_98))) ^ (****l_216)))) != (-5L));
        (***l_216) = (*l_218);
    }
    return p_96;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_99(uint32_t  p_100, uint16_t  p_101, int32_t  p_102, int8_t  p_103, int32_t  p_104)
{ /* block id: 42 */
    return p_102;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 76
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 32, occurrence: 2
   depth: 41, occurrence: 1

XXX total number of pointers: 51

XXX times a variable address is taken: 55
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 43
   depth: 2, occurrence: 4
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 39
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 5
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 121

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 77
   level: 2, occurrence: 11
   level: 3, occurrence: 9
   level: 4, occurrence: 8
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 35
XXX number of pointers point to scalars: 16
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.5
XXX average alias set size: 1.08

XXX times a non-volatile is read: 433
XXX times a non-volatile is write: 107
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 70
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 19
   depth: 2, occurrence: 16
   depth: 3, occurrence: 10
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 19
XXX percentage an existing variable is used: 81
********************* end of statistics **********************/

