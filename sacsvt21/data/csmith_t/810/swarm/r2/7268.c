/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      1511405126
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint8_t  f0;
   uint8_t  f1;
   uint8_t  f2;
   signed f3 : 8;
};
#pragma pack(pop)

union U1 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static float  func_2(uint32_t  p_3, uint32_t  p_4, union U1  p_5);
static uint16_t  func_8(uint32_t  p_9, float  p_10);
static float  func_20(union U1  p_21, int16_t  p_22);
static int16_t  func_32(uint16_t  p_33, uint8_t  p_34, union U1  p_35);
static uint32_t  func_43(uint8_t  p_44, union U1  p_45);
static struct S0  func_46(float  p_47, uint32_t  p_48, uint32_t  p_49, uint16_t  p_50, int32_t  p_51);
static float  func_52(uint8_t  p_53, uint32_t  p_54, uint32_t  p_55, uint32_t  p_56, uint32_t  p_57);
static uint32_t  func_67(uint8_t  p_68, union U1  p_69, uint32_t  p_70);
static uint32_t  func_73(uint16_t  p_74, uint32_t  p_75, union U1  p_76);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_11 = 4294967289U;
    union U1 l_23 = {0xB06C0E26};
    int32_t l_31 = 0x72DDB74A;
    int32_t l_40 = 1;
    int32_t l_346 = 0x401FB3B3;
    int32_t l_347 = 1;
    int32_t l_348 = (-1);
    int32_t l_420 = 0x6BDB23A2;
    int32_t l_421 = 9;
    int32_t l_422 = 0x30DE378C;
    uint32_t l_539 = 5U;
    l_539 = func_2(((l_422 = (l_421 = (((int32_t)((l_420 = (((func_8(l_11, ((float)((float)(l_11 == (l_11 >= ((float)(((float)l_11 / (float)func_20(l_23, ((uint16_t)(l_348 = (l_347 = (l_346 = (l_11 & ((uint16_t)((uint16_t)(~(l_31 = 1)) << (uint16_t)func_32((((int32_t)((((uint32_t)((l_40 = 65535U) == ((uint32_t)func_43(l_23.f0, l_23) - (uint32_t)l_11)) - (uint32_t)0x202BD4F3) != 4294967295U) != l_11) + (int32_t)l_11) != l_23.f0), l_11, l_23)) / (uint16_t)l_23.f0))))) << (uint16_t)l_23.f0))) > 0x8.16C334p-86) - (float)0x3.1p-1))) - (float)l_23.f0) + (float)0x1.2p-1)) && l_346) >= l_23.f0) >= l_23.f0)) == 0) - (int32_t)l_11) < l_23.f0))) == l_11), l_23.f0, l_23);
    l_422 = l_539;
    return l_421;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_2(uint32_t  p_3, uint32_t  p_4, union U1  p_5)
{ /* block id: 151 */
    struct S0 l_426 = {0xF5,4U,0x63,4};
    uint32_t l_445 = 4294967288U;
    int32_t l_534 = 0x87F0C31D;
    int32_t l_535 = (-5);
    struct S0 l_537 = {0x49,0x68,246U,14};
    for (p_3 = (-12); (p_3 != 23); p_3 += 1)
    { /* block id: 154 */
        struct S0 l_425 = {2U,9U,246U,14};
        uint8_t l_478 = 254U;
        l_426 = l_425;
        for (p_5.f0 = 0; (p_5.f0 <= 20); p_5.f0 += 5)
        { /* block id: 158 */
            uint8_t l_438 = 246U;
            int32_t l_447 = 0x88B6863D;
            uint32_t l_449 = 0U;
            int32_t l_490 = 4;
            struct S0 l_493 = {0xD4,0x07,0x18,10};
            int16_t l_533 = 0x82D1;
            int16_t l_536 = 0x85EF;
            struct S0 l_538 = {2U,255U,0x3A,13};
            for (l_425.f2 = 5; (l_425.f2 != 44); l_425.f2 += 1)
            { /* block id: 161 */
                int32_t l_437 = 0x8419561D;
                int32_t l_446 = 0;
                int32_t l_448 = 1;
                int32_t l_491 = (-2);
                l_426.f3 = (0x3A977B04 < (65528U ^ (l_448 = (((((((int16_t)(((int16_t)((int16_t)((((l_437 = 0U) >= l_438) | ((p_4 && (l_447 = (((((((uint16_t)l_438 + (uint16_t)(l_446 = ((0xE181D6DF >= (((((((((uint16_t)((int16_t)p_3 << (int16_t)11) >> (uint16_t)3) < p_3) != l_438) & p_3) | p_3) < 9U) < l_445) > l_446)) ^ l_425.f0))) != 65535U) > p_5.f0) || p_4) || l_425.f2) <= 0xC464))) ^ p_4)) | 6) / (int16_t)p_4) / (int16_t)p_5.f0) <= l_425.f2) - (int16_t)p_5.f0) > 0xE8D6) == l_425.f2) != l_425.f2) | l_448) || p_5.f0))));
                l_425.f3 = ((p_3 == p_5.f0) ^ l_449);
                for (p_4 = 0; (p_4 == 28); p_4 += 1)
                { /* block id: 170 */
                    uint32_t l_476 = 0xCA9BB82E;
                    int32_t l_477 = 1;
                    int32_t l_492 = (-1);
                    struct S0 l_494 = {0x13,0xA1,2U,6};
                    l_426.f3 = (((l_478 = ((((uint32_t)(-(int16_t)(((int32_t)(((int32_t)((-4) == l_445) + (int32_t)(((uint16_t)0xC1E1 + (uint16_t)((uint32_t)((int16_t)((int16_t)p_5.f0 >> (int16_t)8) / (int16_t)l_448) + (uint32_t)(1 ^ p_5.f0))) <= ((int16_t)l_447 << (int16_t)((uint32_t)(((int32_t)(l_477 = ((l_425.f3 = (((((~((l_438 <= l_447) >= p_5.f0)) | p_4) || p_3) > l_425.f2) || l_476)) | p_3)) / (int32_t)p_5.f0) > p_5.f0) % (uint32_t)l_445)))) && 0x29E1D5F6) / (int32_t)(-1)) == p_4)) % (uint32_t)p_4) < p_3) ^ 0x6686D26A)) && 0x09AC77AA) >= 0);
                    l_493 = func_46(l_447, l_446, l_445, (l_449 != (l_492 = ((((int16_t)((int16_t)((((((p_5.f0 | (((((uint32_t)(p_3 > (l_491 = ((-1) != ((l_437 = (l_425.f3 = (-(uint32_t)(((int16_t)(l_490 = (l_477 && (l_448 = (l_477 = 0U)))) >> (int16_t)5) <= 0x7DC4)))) | (-1))))) % (uint32_t)l_476) > 0xA0E5) != p_4) & 1U)) > l_476) == l_476) == l_447) > p_3) < p_4) / (int16_t)p_4) >> (int16_t)p_3) || l_491) != 0xE080124D))), p_3);
                    if (l_491)
                        break;
                    l_426 = l_494;
                }
            }
            l_537 = func_46((l_426.f3 = p_4), (l_447 = ((int16_t)((((int32_t)((l_490 = ((l_535 = ((uint16_t)p_5.f0 / (uint16_t)((uint16_t)(0xC52450AC || 0U) / (uint16_t)(((uint16_t)((uint32_t)((int32_t)((int16_t)l_493.f2 % (int16_t)((uint16_t)(((int16_t)((int16_t)(((uint16_t)(((int16_t)(((int16_t)((((l_534 = ((uint16_t)(((p_4 >= ((uint32_t)((((((int32_t)((l_425.f3 = 0x1C0B2F29) >= ((int16_t)p_5.f0 % (int16_t)(((int32_t)(p_5.f0 ^ l_425.f2) % (int32_t)0x87919D20) ^ 0x5EEF4D79))) / (int32_t)p_4) < 0x4832) | l_533) > 0) || l_425.f3) % (uint32_t)l_533)) & l_426.f0) < p_3) + (uint16_t)p_3)) || p_3) != l_449) != l_425.f2) + (int16_t)l_426.f0) && 0x515C32A6) / (int16_t)l_426.f1) || p_5.f0) >> (uint16_t)l_425.f0) <= l_425.f1) << (int16_t)2) >> (int16_t)5) | 3) >> (uint16_t)0)) / (int32_t)0xAFC61B7E) - (uint32_t)0x912B3F79) - (uint16_t)65534U) && l_490)))) | 65528U)) && p_3) % (int32_t)0x6A287461) > l_493.f0) <= l_536) % (int16_t)0x56FE)), l_493.f3, p_5.f0, l_536);
            l_538 = (l_493 = l_493);
            l_425 = l_426;
        }
        return p_3;
    }
    return p_3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_8(uint32_t  p_9, float  p_10)
{ /* block id: 127 */
    int32_t l_352 = (-1);
    int32_t l_377 = 0x4DAF0B04;
    uint8_t l_400 = 0xAC;
    int32_t l_402 = 1;
    struct S0 l_419 = {0x00,0x20,0x0E,8};
    p_10 = (l_352 <= ((float)((float)(0xF.9DC24Ap+88 > (((float)p_9 / (float)0xC.62972Fp-3) < ((l_352 <= p_9) >= ((float)((float)l_352 + (float)((float)((float)(l_352 > ((float)(!((float)(((((0x5.92E37Cp-13 >= p_10) == 0xE.C46E65p-98) == (-0x2.5p+1)) == (-0x1.Cp+1)) <= l_352) / (float)p_10)) - (float)0x0.EB53D8p+50)) + (float)l_352) / (float)l_352)) + (float)l_352)))) / (float)(-0x5.7p-1)) + (float)l_352));
    for (l_352 = 18; (l_352 <= (-28)); --l_352)
    { /* block id: 131 */
        uint16_t l_376 = 0xFEFC;
        int32_t l_401 = 0x1BB542E9;
        int32_t l_418 = 1;
        l_402 = ((int16_t)(l_377 = l_376) + (int16_t)((int16_t)(0xF462 | (((uint32_t)((uint32_t)p_9 - (uint32_t)((uint16_t)p_9 >> (uint16_t)(((uint32_t)l_352 % (uint32_t)(l_401 = ((uint16_t)(((int16_t)(((!(((((0x73B4 & (((~(((uint16_t)(65535U && ((l_352 <= (((((uint16_t)(p_9 > l_376) % (uint16_t)p_9) <= l_352) ^ l_376) != p_9)) != p_9)) - (uint16_t)l_376) && l_352)) >= l_376) <= p_9)) < p_9) == p_9) ^ l_400) & l_400)) && p_9) || 0x7DD1) % (int16_t)p_9) & l_400) + (uint16_t)p_9))) == 0xBED8))) - (uint32_t)0x489AE162) < 65535U)) % (int16_t)5U));
        for (l_401 = 25; (l_401 > 26); l_401 += 1)
        { /* block id: 137 */
            int32_t l_411 = 0xE7064428;
            int32_t l_414 = 0x79CFFCAE;
            l_418 = (((float)(p_10 = (((-0x1.0p-1) == (0x5.Ap+1 <= ((p_10 < l_376) <= ((((((((float)((float)(l_402 = (((l_411 = l_411) != ((float)(p_10 >= (((p_10 < l_414) < (-(float)((float)l_401 - (float)p_10))) > p_10)) + (float)p_10)) != l_414)) / (float)(-0x9.2p+1)) / (float)l_377) <= p_10) >= p_10) < l_400) <= 0x3.5BE0EEp-94) == l_376) != l_401)))) <= 0xF.35E3E4p+67)) - (float)p_9) <= (-0x1.Fp-1));
            if (p_9)
                break;
            return l_352;
        }
    }
    l_419 = l_419;
    return l_377;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_20(union U1  p_21, int16_t  p_22)
{ /* block id: 120 */
    int32_t l_351 = 0x5EC50204;
    for (p_21.f0 = 0; (p_21.f0 > 33); ++p_21.f0)
    { /* block id: 123 */
        return l_351;
    }
    return l_351;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_32(uint16_t  p_33, uint8_t  p_34, union U1  p_35)
{ /* block id: 108 */
    int32_t l_323 = 0;
    int32_t l_336 = (-1);
    int32_t l_337 = 0x062EDEC9;
    int32_t l_341 = 0xB20B721F;
    float l_342 = 0x0.19BA98p-74;
    int16_t l_343 = 0x8080;
    int32_t l_344 = 0x11A4CF9E;
    int32_t l_345 = 0x285D37B3;
    l_345 = (l_323 = (((((float)p_33 - (float)(p_35.f0 >= ((float)l_323 / (float)((float)((float)(l_344 = ((float)((float)((float)((float)((((l_323 > ((((p_34 != ((l_337 = (l_336 = p_35.f0)) <= ((p_34 < ((l_342 = (p_33 <= (l_341 = ((float)(!(p_34 < l_323)) / (float)0x1.CEB2B0p-62)))) != p_33)) != 0x6.D6D275p+5))) >= l_323) > l_343) < l_343)) >= p_33) != l_343) <= l_323) / (float)p_35.f0) + (float)p_34) - (float)0x1.6C8AD9p-2) - (float)0xD.DD005Bp+79)) - (float)l_343) + (float)(-0x1.0p+1))))) < l_343) <= l_343) == l_323));
    return l_341;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_43(uint8_t  p_44, union U1  p_45)
{ /* block id: 3 */
    float l_58 = 0x9.Bp+1;
    int32_t l_59 = 0x80008586;
    int32_t l_60 = 1;
    int32_t l_61 = 0x720F84B0;
    int16_t l_66 = 8;
    struct S0 l_239 = {0xE4,253U,0xB2,9};
    float l_317 = 0x2.4p-1;
    float l_318 = (-0x1.Dp-1);
    l_239 = func_46(func_52((l_60 = ((l_59 = (p_44 < p_44)) <= p_45.f0)), l_61, (p_45.f0 ^ (l_61 >= ((0U || p_44) > (((uint16_t)((((uint32_t)(0 <= l_61) / (uint32_t)p_45.f0) || (-7)) < l_61) + (uint16_t)l_66) < p_45.f0)))), l_66, l_61), p_45.f0, l_66, l_66, p_45.f0);
    if (((((int16_t)((int16_t)((uint16_t)((int32_t)((((((int32_t)(l_239.f3 = l_61) + (int32_t)0x709B9CAC) <= (((uint32_t)((int32_t)(((uint16_t)((l_66 ^ ((((uint32_t)p_45.f0 + (uint32_t)((int16_t)(!l_59) - (int16_t)((uint32_t)(((l_59 <= ((uint16_t)(l_60 = 0xCDDC) + (uint16_t)3U)) && (p_45.f0 < 4294967295U)) | 65527U) / (uint32_t)p_44))) && p_44) | p_44)) < l_239.f1) % (uint16_t)l_66) && p_45.f0) / (int32_t)l_61) + (uint32_t)p_44) & p_45.f0)) < l_66) & 0x122F168F) && l_239.f3) - (int32_t)l_239.f2) << (uint16_t)12) << (int16_t)8) - (int16_t)1U) ^ l_59) > 0x3ACF053E))
    { /* block id: 100 */
        int32_t l_281 = 0x43E1014F;
        int32_t l_290 = 0xD2AB77A9;
        l_60 = ((int16_t)((uint32_t)0x9DCD7773 + (uint32_t)((int16_t)(((uint32_t)(((((0x6457C80C & ((int32_t)(((int16_t)(0xFD831AC0 ^ ((int16_t)((((int16_t)l_281 + (int16_t)(((uint32_t)l_281 + (uint32_t)((uint32_t)((int16_t)(p_44 || ((uint16_t)p_45.f0 / (uint16_t)l_281)) << (int16_t)15) % (uint32_t)0x569C1910)) > l_290)) <= 1) | l_60) >> (int16_t)14)) >> (int16_t)p_44) != 1U) % (int32_t)p_45.f0)) || 0) == 0x672E) || 0x8921) > l_281) + (uint32_t)p_45.f0) >= l_290) % (int16_t)l_61)) << (int16_t)l_290);
    }
    else
    { /* block id: 102 */
        return p_44;
    }
    l_60 = (((float)(l_239.f3 == l_239.f1) - (float)((((float)((float)(((float)(!0x1.Ap-1) - (float)((float)((-(float)((float)(0x0.Cp+1 < ((((float)((float)(l_239.f0 < ((((-0x1.Ap+1) != (((float)((float)l_66 + (float)(((float)((p_44 != (l_61 = ((float)p_44 + (float)l_317))) < l_239.f0) + (float)p_45.f0) > l_318)) / (float)0xA.0CB7C3p+26) < l_66)) >= l_59) != l_239.f0)) + (float)p_45.f0) + (float)l_239.f1) == l_239.f2) >= l_59)) + (float)p_45.f0)) < p_44) + (float)0xE.7404A6p-54)) == l_60) / (float)l_60) + (float)0x0.1p-1) == p_45.f0) == p_45.f0)) > 0x6.7509E5p+15);
    return l_239.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_46(float  p_47, uint32_t  p_48, uint32_t  p_49, uint16_t  p_50, int32_t  p_51)
{ /* block id: 85 */
    struct S0 l_232 = {0x33,0U,0U,14};
    struct S0 l_237 = {255U,0xB8,253U,3};
    l_232 = l_232;
lbl_238:
    for (p_50 = 3; (p_50 > 1); p_50 -= 7)
    { /* block id: 89 */
        int32_t l_235 = 0x33E0742F;
        struct S0 l_236 = {250U,0x20,0xFD,-12};
        l_235 = 0;
        l_236 = l_236;
    }
    l_232 = (l_237 = l_232);
    if (l_232.f1)
        goto lbl_238;
    return l_237;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_52(uint8_t  p_53, uint32_t  p_54, uint32_t  p_55, uint32_t  p_56, uint32_t  p_57)
{ /* block id: 6 */
    union U1 l_72 = {4294967295U};
    int32_t l_79 = 0x165AAE70;
    int32_t l_87 = 1;
    int32_t l_150 = (-3);
    struct S0 l_153 = {6U,6U,9U,1};
    if (p_56)
    { /* block id: 7 */
        uint32_t l_71 = 0x77F141C5;
        int32_t l_90 = 9;
        struct S0 l_203 = {250U,255U,1U,-3};
        l_150 = ((func_67(l_71, l_72, func_73((((-1) | (((l_79 = 0xB60A95A2) & (l_90 = ((int16_t)((int32_t)((int16_t)(l_87 = ((~l_72.f0) ^ 3U)) - (int16_t)(0xAFB55E8A <= ((int32_t)0x9F6C8506 + (int32_t)0x20822C3E))) % (int32_t)0xCE5052DE) + (int16_t)0xB76E))) <= l_71)) <= p_53), l_72.f0, l_72)) >= p_53) > 0x04DE);
        for (p_56 = (-18); (p_56 != 55); p_56 += 1)
        { /* block id: 45 */
            uint32_t l_162 = 4294967295U;
            uint32_t l_202 = 4294967289U;
            struct S0 l_204 = {1U,8U,0U,-14};
            l_153 = l_153;
            l_87 = (((int32_t)(l_87 > ((((l_71 & ((p_55 | l_71) < p_56)) != ((~(1U <= (l_150 = p_57))) && (((int16_t)((-(int32_t)(l_162 & (((((int16_t)((int16_t)l_71 / (int16_t)0xF91D) - (int16_t)0xEA2D) != l_162) <= 0U) >= l_162))) && p_56) >> (int16_t)p_56) && l_79))) == 0) ^ 0xA04B778E)) - (int32_t)l_71) && 9U);
            if ((((uint16_t)(((p_55 | ((l_153.f3 = (!(65526U < l_79))) || ((((int16_t)(l_71 ^ p_55) + (int16_t)(l_87 = 0x7E5D)) || ((uint32_t)(-(int32_t)(l_153.f3 = l_79)) - (uint32_t)(l_153.f1 > ((int32_t)((((uint16_t)p_53 / (uint16_t)l_72.f0) & l_71) | l_153.f2) / (int32_t)0x32FC06C7)))) && 0x37C9))) | p_54) & p_56) << (uint16_t)11) == p_57))
            { /* block id: 52 */
                return p_56;
            }
            else
            { /* block id: 54 */
                int16_t l_198 = (-1);
                struct S0 l_201 = {255U,0xF1,0xE8,-4};
                for (l_72.f0 = 22; (l_72.f0 == 25); l_72.f0 += 1)
                { /* block id: 57 */
                    int16_t l_195 = 0xABD1;
                    int32_t l_199 = 0xC7A9A96A;
                    if (p_56)
                    { /* block id: 58 */
                        int32_t l_183 = 0xE8F995CB;
                        struct S0 l_200 = {0x06,0U,0U,15};
                        l_183 = ((((l_199 = ((uint16_t)((p_53 & l_183) == ((((~p_56) ^ (((uint32_t)((((((uint32_t)1U % (uint32_t)((uint32_t)((uint16_t)(!p_57) >> (uint16_t)14) - (uint32_t)(-(int16_t)(l_71 | ((l_195 = 0x177B) > (((int32_t)l_153.f3 - (int32_t)p_57) >= l_198)))))) || 0xE6ED) == p_54) | l_162) || 65535U) - (uint32_t)p_55) || 0xF74B)) > p_53) <= l_198)) / (uint16_t)p_54)) <= l_150) ^ 4U) & p_53);
                        l_183 = l_162;
                        l_201 = l_200;
                        if (p_54)
                            continue;
                    }
                    else
                    { /* block id: 65 */
                        return l_202;
                    }
                    if (p_53)
                        continue;
                    l_203 = l_153;
                }
            }
            l_204 = l_203;
        }
        return p_56;
    }
    else
    { /* block id: 75 */
        uint8_t l_211 = 0U;
        uint8_t l_217 = 246U;
        int32_t l_218 = 0x2B6AA699;
        struct S0 l_219 = {0U,6U,0xAD,3};
        l_153 = l_153;
        l_218 = (((l_153.f2 != ((uint16_t)((l_150 >= p_53) > ((0xBB4F55AC <= ((int32_t)(((p_56 != (0x706FC589 <= (0x6E377ABB && (((((((((int16_t)(l_211 && ((p_55 = (((int16_t)((int16_t)((-(int16_t)p_57) <= l_153.f0) - (int16_t)0xB6E2) << (int16_t)l_211) && (-1))) ^ l_153.f1)) - (int16_t)4U) && l_87) && l_153.f3) > l_211) ^ p_53) & p_54) == p_53) != 8)))) && 0x60E320F6) == 0x75AD3DD4) / (int32_t)p_54)) || 0xAC2C)) << (uint16_t)l_211)) & 65527U) != l_217);
        l_219 = l_219;
    }
    l_87 = (l_153.f2 & (l_153.f3 = (4294967294U >= (((int16_t)0xB5AA >> (int16_t)(((int32_t)((int16_t)p_56 % (int16_t)((int16_t)(((uint16_t)l_87 % (uint16_t)p_55) < (p_57 | ((int32_t)((l_72.f0 < (((l_150 = 0x2623D089) && 0x9581409F) > p_57)) != 0x3001) - (int32_t)0x5A11B485))) << (int16_t)11)) % (int32_t)l_72.f0) < p_57)) != p_57))));
    return l_79;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_67(uint8_t  p_68, union U1  p_69, uint32_t  p_70)
{ /* block id: 17 */
    uint32_t l_129 = 6U;
    int32_t l_130 = 0x26F05796;
    int32_t l_131 = 0x13C76A60;
    int32_t l_132 = (-1);
    int32_t l_133 = 0;
    int32_t l_137 = 1;
    int32_t l_138 = 0x0E8A9312;
    int16_t l_148 = (-1);
    struct S0 l_149 = {0x4A,255U,0xE0,-4};
    for (p_70 = 29; (p_70 >= 32); ++p_70)
    { /* block id: 20 */
        struct S0 l_110 = {0x38,8U,0xB2,13};
        uint32_t l_134 = 0x100029D1;
        uint16_t l_135 = 0U;
        for (p_68 = (-29); (p_68 < 10); p_68 += 1)
        { /* block id: 23 */
            struct S0 l_111 = {0x2F,1U,255U,-14};
            int32_t l_136 = 1;
            l_111 = l_110;
            l_138 = (l_137 = (0U != ((l_136 = ((int32_t)((l_135 = ((((int16_t)((int32_t)(((int16_t)(-(uint32_t)((int16_t)((l_133 = ((int32_t)0x0A5F0D23 + (int32_t)(l_132 = ((p_68 != (l_111.f3 = (l_111.f0 | (l_131 = ((((uint16_t)((p_70 <= (((uint16_t)((p_68 && (l_130 = ((((l_110.f3 != l_129) ^ (l_111.f0 < p_68)) >= p_69.f0) == p_70))) != 1) << (uint16_t)l_111.f1) > l_129)) | p_69.f0) % (uint16_t)p_68) < 0) <= l_129))))) && l_111.f2)))) != p_68) % (int16_t)p_70)) << (int16_t)10) != p_68) + (int32_t)p_69.f0) >> (int16_t)15) | l_134) == 0)) == l_110.f2) - (int32_t)8U)) && 0x16196426)));
            l_130 = (l_110.f3 = l_133);
            l_110.f3 = (((float)((float)l_138 / (float)l_110.f3) + (float)(0xD.56DE09p+72 > ((((float)l_132 + (float)((float)((l_130 <= (-(float)l_148)) != ((p_70 < ((-0x8.Cp+1) == ((-0x6.2p-1) > l_110.f0))) != 0x7.A91489p+65)) - (float)0x1.1p+1)) < l_148) < 0x7.5p+1))) > l_111.f3);
        }
        l_149 = l_149;
        if (p_69.f0)
            break;
    }
    return l_138;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_73(uint16_t  p_74, uint32_t  p_75, union U1  p_76)
{ /* block id: 11 */
    int16_t l_91 = 0xDA0B;
    int32_t l_98 = (-9);
    int32_t l_103 = 0xA4AF1292;
    int32_t l_104 = 0x71001949;
    int32_t l_105 = 0xAC15C258;
    l_105 = ((l_91 < (0xF.361030p-95 == ((float)((float)(-0x1.7p-1) / (float)(l_91 < 0x0.8p-1)) / (float)(((l_104 = ((float)((l_98 = (p_76.f0 != l_91)) < (((float)(l_103 = ((float)(0x0.Bp-1 == (l_91 <= 0x8.7p+1)) - (float)l_91)) + (float)l_91) < p_76.f0)) - (float)l_91)) != p_75) <= l_91)))) >= (-0x1.1p+1));
    return p_74;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 87
   depth: 1, occurrence: 20
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 21
XXX times a bitfields struct on RHS: 17
XXX times a single bitfield on LHS: 14
XXX times a single bitfield on RHS: 9

XXX max expression depth: 54
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 15, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 2
   depth: 25, occurrence: 3
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 3
   depth: 34, occurrence: 3
   depth: 38, occurrence: 1
   depth: 39, occurrence: 1
   depth: 46, occurrence: 1
   depth: 54, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 445
XXX times a non-volatile is write: 123
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 80
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 19
   depth: 2, occurrence: 15
   depth: 3, occurrence: 5
   depth: 4, occurrence: 7
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 19
XXX percentage an existing variable is used: 81
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

