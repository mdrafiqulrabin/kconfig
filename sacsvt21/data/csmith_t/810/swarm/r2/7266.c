/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2832383786
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 3;
   unsigned f1 : 12;
   uint8_t  f2;
   signed f3 : 6;
   signed f4 : 19;
   unsigned f5 : 19;
   unsigned f6 : 8;
   unsigned f7 : 1;
};
#pragma pack(pop)

union U1 {
   const uint64_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_8 = (-6L);
static struct S0 g_32 = {0,63,0x3CL,-1,-216,720,4,0};
static struct S0 g_72 = {0,0,254UL,0,-338,381,2,0};
static float g_92 = 0xC.EC93CBp+0;
static int32_t *g_105 = &g_8;
static int32_t **g_104 = &g_105;
static struct S0 ***g_118 = (void*)0;
static int32_t g_183 = (-7L);
static float *g_195 = (void*)0;
static float **g_194 = &g_195;
static float ***g_193 = &g_194;
static union U1 g_230 = {0x975CF2B2128A0557LL};
static union U1 *g_229 = &g_230;
static int32_t g_243 = 0L;
static int32_t ***g_434 = &g_104;
static int32_t ****g_433 = &g_434;
static int32_t *****g_441 = (void*)0;
static union U1 **g_476 = &g_229;
static union U1 ***g_475 = &g_476;
static const struct S0 *g_621 = &g_72;
static const struct S0 **g_620 = &g_621;
static const struct S0 ***g_619 = &g_620;
static const struct S0 ****g_618 = &g_619;
static const struct S0 *****g_617 = &g_618;


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_1(void);
static int64_t  func_6(uint32_t  p_7);
inline static struct S0  func_17(uint32_t  p_18);
static float  func_21(const uint32_t  p_22, float  p_23, const int64_t  p_24, int8_t  p_25);
inline static uint32_t  func_26(struct S0  p_27, uint8_t  p_28, float  p_29, const int32_t  p_30, union U1  p_31);
static float  func_37(uint64_t  p_38, const int32_t  p_39, int32_t  p_40);
static int8_t  func_43(uint32_t  p_44);
static int64_t  func_45(uint64_t  p_46);
static uint16_t  func_47(float  p_48, int32_t  p_49, uint8_t  p_50, uint64_t  p_51);
inline static int16_t  func_59(const int16_t  p_60, const uint32_t  p_61, uint32_t  p_62, struct S0  p_63);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_32 g_72.f0 g_72.f7 g_72.f2 g_229 g_230 g_104 g_105 g_243 g_230.f0 g_72.f4 g_183 g_72.f6 g_72.f1 g_118 g_72 g_433 g_434 g_475 g_476 g_193 g_194 g_617 g_619 g_620 g_621 g_618 g_195
 * writes: g_72 g_92 g_105 g_229 g_32.f2 g_243 g_8 g_441 g_475 g_183 g_617 g_32.f4 g_621
 */
static uint8_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_5 = 0x3CL;
    struct S0 l_410 = {-1,22,255UL,5,-714,452,0,0};
    float l_417 = 0x0.Dp+1;
    uint16_t l_426 = 65532UL;
    int16_t l_427 = 0x4711L;
    int64_t l_428 = 0L;
    int32_t ****l_435 = &g_434;
    struct S0 *l_439 = &l_410;
    struct S0 **l_438 = &l_439;
    struct S0 ***l_437 = &l_438;
    int16_t l_440 = 0x02F0L;
    const union U1 *l_484 = &g_230;
    const union U1 **l_483 = &l_484;
    uint8_t l_523 = 255UL;
    int64_t l_535 = 9L;
    uint32_t l_579 = 0xB51946FFL;
    int32_t l_600 = 1L;
    float **l_643 = &g_195;
    int32_t l_681 = 0x74E5CD82L;
    if (((~((((safe_div_func_float_f_f((((l_5 > (func_6(g_8) || ((g_230.f0 <= (((l_5 , (safe_add_func_float_f_f(((l_410 , (safe_add_func_float_f_f((safe_sub_func_float_f_f((((safe_lshift_func_int8_t_s_s(l_410.f2, 5)) , ((safe_sub_func_int64_t_s_s(((safe_mod_func_uint16_t_u_u((safe_add_func_int8_t_s_s(((safe_sub_func_int16_t_s_s(l_410.f7, (((1UL <= 0x58L) != l_410.f2) < l_410.f4))) < l_410.f3), g_32.f5)), 1L)) < g_32.f3), 0xC53D9A7A357069F2LL)) , l_426)) > 0xC.AF62C8p-1), l_410.f2)), l_410.f4))) > l_427), l_428))) , (void*)0) != &g_183)) || 0x7EB242AB39A41F48LL))) , g_72) , (-0x5.Cp+1)), l_410.f2)) == l_410.f3) , l_410.f0) , 0xCCL)) || g_72.f0))
    { /* block id: 153 */
        int32_t *l_429 = &g_8;
        int32_t ****l_436 = &g_434;
        struct S0 *l_446 = &l_410;
        const float l_454 = 0x1.5p+1;
        uint32_t l_486 = 0UL;
        union U1 ***l_530 = &g_476;
        int16_t l_543 = 0x3642L;
        uint32_t l_601 = 1UL;
        int32_t l_602 = 1L;
        (*g_104) = l_429;
        /* statement id: 154 */
        assert (g_105 == &g_8);
        for (l_5 = 28; (l_5 <= 52); l_5 = safe_add_func_int8_t_s_s(l_5, 1))
        { /* block id: 157 */
            int32_t *l_432 = &g_8;
            (*g_104) = (void*)0;
            /* statement id: 158 */
            assert (g_105 == 0);
            (*g_104) = (l_5 , l_432);
            /* statement id: 159 */
            assert (g_105 == &g_8);
        }
        if (((((*l_429) < ((void*)0 != g_433)) | ((g_72.f5 || (l_435 != (func_17((*l_429)) , l_436))) > (((void*)0 == l_437) <= 0UL))) ^ l_440))
        { /* block id: 161 */
            uint64_t l_453 = 0x4180C50B6E6383F7LL;
            float *l_455 = &l_417;
            int64_t l_471 = 0L;
            g_441 = &l_435;
            /* statement id: 162 */
            assert (g_441 == &l_435);
            (*l_455) = ((-0x5.Ep-1) == (-(((****l_436) >= (((((~((safe_mul_func_uint32_t_u_u(0x7C366842L, ((void*)0 == l_446))) & (!(safe_add_func_uint16_t_u_u((!((safe_lshift_func_int8_t_s_u((&g_194 != &g_194), 3)) > g_72.f1)), (2UL & (*l_429))))))) | l_453) , g_72.f5) != (-9L)) , l_454)) == 0x0.5p-1)));
            (*g_104) = (void*)0;
            /* statement id: 164 */
            assert (g_105 == 0);
            if ((~(safe_rshift_func_int16_t_s_s(l_453, 10))))
            { /* block id: 165 */
                int32_t l_464 = 0x1AC5BB03L;
                struct S0 ***l_469 = &l_438;
                for (g_72.f2 = 0; (g_72.f2 == 4); g_72.f2 = safe_add_func_uint16_t_u_u(g_72.f2, 4))
                { /* block id: 168 */
                    int64_t l_470 = 1L;
                    (*l_455) = (((-l_453) > ((safe_div_func_float_f_f((*l_429), ((((g_118 == ((l_464 <= (safe_lshift_func_int8_t_s_s(l_453, ((safe_add_func_int16_t_s_s(g_72.f5, 0x1D3BL)) > g_72.f2)))) , l_469)) || g_72.f6) ^ g_32.f1) , l_470))) >= (-0x1.Bp+1))) >= l_470);
                    (***l_436) = (void*)0;
                }
                (*l_429) = l_471;
            }
            else
            { /* block id: 173 */
                struct S0 l_474 = {-0,44,0UL,-2,-599,51,15,0};
                for (g_32.f2 = 23; (g_32.f2 < 34); g_32.f2 = safe_add_func_int16_t_s_s(g_32.f2, 1))
                { /* block id: 176 */
                    (*l_446) = l_474;
                }
                (***g_433) = (***g_433);
                if (l_453)
                { /* block id: 180 */
                    (*l_455) = g_32.f0;
                }
                else
                { /* block id: 182 */
                    union U1 ****l_477 = &g_475;
                    int32_t l_485 = 0x80B2E258L;
                    (*l_477) = g_475;
                    for (g_8 = 0; (g_8 >= 8); g_8 = safe_add_func_int8_t_s_s(g_8, 4))
                    { /* block id: 186 */
                        int32_t l_482 = (-1L);
                        int32_t l_487 = 0x44CBA513L;
                        (*l_455) = ((((((((safe_div_func_uint8_t_u_u(l_482, (l_482 || ((l_483 != ((*g_229) , (*g_475))) != ((1UL ^ ((-7L) < l_485)) ^ ((g_72.f7 , l_486) && g_72.f3)))))) || 248UL) , l_485) | g_32.f4) >= g_72.f6) < 0xB17A40FEAA9D32C3LL) , 0x0.455BDAp+18) != l_487);
                        l_482 = ((***l_435) != (**g_434));
                    }
                }
            }
        }
        else
        { /* block id: 192 */
            uint8_t l_510 = 0x0BL;
            uint8_t l_522 = 0x45L;
            int32_t l_533 = (-2L);
            uint32_t l_534 = 0xE4DD879EL;
            const union U1 *l_542 = (void*)0;
            for (g_183 = 0; (g_183 >= (-18)); g_183 = safe_sub_func_uint32_t_u_u(g_183, 9))
            { /* block id: 195 */
                int32_t l_524 = 0x441597BEL;
                for (l_486 = 0; (l_486 > 42); l_486++)
                { /* block id: 198 */
                    (***l_436) = (*g_104);
                    (*g_105) = (**g_104);
                }
                (****l_435) = (*g_105);
                (*l_429) = (((((safe_mod_func_uint32_t_u_u((1UL > ((((safe_unary_minus_func_uint64_t_u(((safe_unary_minus_func_uint32_t_u((safe_rshift_func_int8_t_s_s((safe_sub_func_int16_t_s_s((~(!0x9E7026B4L)), 0x2ACEL)), (safe_div_func_uint8_t_u_u(((g_32.f1 > ((func_17((((((safe_lshift_func_int8_t_s_s((safe_div_func_uint8_t_u_u(l_510, (((safe_sub_func_int16_t_s_s((safe_add_func_int32_t_s_s((safe_sub_func_int64_t_s_s(1L, ((1L ^ (g_72.f5 ^ (safe_lshift_func_uint8_t_u_s((safe_unary_minus_func_uint32_t_u((safe_div_func_uint64_t_u_u(((void*)0 == (***l_436)), 0xE04F13F1AD50CB38LL)))), g_32.f6)))) , g_72.f5))), 0xB8D2B03CL)), (*l_429))) > 4294967287UL) || (*l_429)))), (****l_436))) & g_32.f2) != g_72.f6) , (*l_429)) < 0xFCL)) , g_72.f7) <= g_8)) , l_522), l_523)))))) , 18446744073709551608UL))) > l_524) <= (-1L)) , 0xC883CA65L)), (*l_429))) , l_524) & g_32.f0) , g_32.f5) > g_230.f0);
                /* statement id: 203 */
                assert (g_105 == &g_243);
            }
            if ((safe_lshift_func_int8_t_s_u(((!l_522) && (((((((((((((void*)0 != &g_118) , ((((l_530 != ((safe_lshift_func_uint8_t_u_u((****l_435), 7)) , l_530)) >= ((void*)0 != (**g_434))) && ((g_243 && (*l_429)) != g_72.f1)) >= (*l_429))) | (****l_435)) >= g_243) & 3L) && l_522) != 9L) , 0xC.EE6359p-96) >= l_533) > (*l_429)) , (-3L)) , l_534)), (****l_436))))
            { /* block id: 205 */
                (**g_104) = (l_535 , l_522);
            }
            else
            { /* block id: 207 */
                (***l_435) = (*g_104);
                return g_72.f5;
            }
            for (l_534 = (-9); (l_534 != 16); l_534 = safe_add_func_int64_t_s_s(l_534, 5))
            { /* block id: 213 */
                uint32_t l_548 = 0x1F9DA301L;
                (****l_435) = (***g_434);
                if ((l_534 , ((safe_div_func_uint64_t_u_u((((((safe_rshift_func_uint8_t_u_u(g_32.f3, (g_32.f7 , (((void*)0 == l_542) , g_32.f4)))) ^ (((l_543 <= (((g_72.f0 , ((((safe_sub_func_uint8_t_u_u((l_548 & 0L), l_533)) , g_243) < (****l_435)) , (****l_436))) && 0x7DB8553A23FCF359LL) < (****l_436))) | 5L) , l_522)) , 6L) | 0xF7AB69D3E77C2C50LL) == g_32.f4), (****l_435))) , l_510)))
                { /* block id: 215 */
                    int32_t l_557 = (-1L);
                    int64_t l_587 = 0x793941A4D1BE87E4LL;
                    struct S0 l_599 = {1,28,0x5AL,3,-398,340,14,0};
                    if ((l_510 > (g_32.f3 , ((((((safe_div_func_int8_t_s_s(g_72.f3, (safe_add_func_uint64_t_u_u(l_548, (safe_mod_func_int64_t_s_s(g_72.f2, g_243)))))) < (((**g_475) != (l_557 , (**l_530))) >= (****l_435))) != g_72.f2) & g_32.f0) <= 0xFA6652B3F937DB2FLL) > g_230.f0))))
                    { /* block id: 216 */
                        if (l_533)
                            break;
                        (*g_104) = (**g_434);
                        if ((***g_434))
                            continue;
                        (**l_437) = &g_72;
                        /* statement id: 220 */
                        assert (l_439 == &g_72);
                    }
                    else
                    { /* block id: 221 */
                        float *l_558 = (void*)0;
                        int32_t l_567 = 0L;
                        union U1 ***l_578 = &g_476;
                        (*l_429) = l_548;
                        (**g_104) = (l_510 , ((-10L) != (safe_rshift_func_uint8_t_u_s((safe_lshift_func_int16_t_s_u(8L, ((safe_div_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u((l_567 , (safe_rshift_func_uint8_t_u_s(((g_32.f4 != g_72.f1) == (safe_sub_func_uint8_t_u_u((safe_lshift_func_int8_t_s_s((safe_lshift_func_int16_t_s_u(g_72.f3, 1)), ((((safe_lshift_func_uint8_t_u_u(g_72.f0, 3)) , l_578) == l_578) , l_579))), l_557))), 6))), 6)), g_32.f6)) | l_548))), g_32.f7))));
                        (*l_439) = func_17((((((safe_mod_func_uint16_t_u_u((safe_unary_minus_func_uint32_t_u((g_32.f2 && (safe_lshift_func_uint8_t_u_s(((safe_lshift_func_int16_t_s_u(g_8, 4)) != g_32.f6), ((****l_435) && l_587)))))), (safe_rshift_func_uint16_t_u_u(((safe_unary_minus_func_uint8_t_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_int8_t_s_s((safe_sub_func_uint64_t_u_u((safe_rshift_func_int8_t_s_s(((((l_599 , (*g_193)) == (*g_193)) , (*g_193)) != (void*)0), 4)), l_600)), (****l_435))), 0)))) && l_601), g_72.f6)))) | 0x71L) <= 0x2CA31A0487C5DDD1LL) <= l_548) ^ l_510));
                        /* statement id: 224 */
                        assert (g_105 == &g_243);
                    }
                    /* facts after branching */
                    assert (l_439 == &l_410 || l_439 == &g_72);
                    return l_602;
                }
                else
                { /* block id: 227 */
                    return l_522;
                }
            }
            (***g_433) = (*g_104);
        }
        /* facts after branching */
        assert (g_105 == &g_8 || g_105 == &g_243 || g_105 == 0);
        assert (g_441 == 0 || g_441 == &l_435);
    }
    else
    { /* block id: 233 */
        float l_622 = 0xF.B08F21p-55;
        int32_t l_623 = 0xDDA3BFDCL;
        union U1 *l_734 = &g_230;
        int32_t l_737 = 0xF8CDA0F1L;
        float l_738 = 0x1.Fp-1;
        int16_t l_739 = 0x2E0CL;
        int32_t *l_740 = &g_243;
        for (l_426 = 8; (l_426 > 50); l_426++)
        { /* block id: 236 */
            int8_t l_635 = (-1L);
            int32_t *l_636 = &l_623;
            struct S0 l_637 = {-0,40,0x2BL,-0,-442,293,3,0};
            (*l_636) = ((safe_div_func_uint64_t_u_u((safe_mod_func_int64_t_s_s((safe_add_func_uint16_t_u_u(g_32.f0, ((safe_add_func_int64_t_s_s(((safe_lshift_func_int16_t_s_s(1L, 8)) , (safe_add_func_uint16_t_u_u((g_617 == &g_618), l_623))), ((!((9UL & (((((safe_div_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((((safe_add_func_float_f_f(((((safe_div_func_int32_t_s_s(0xD20FD68BL, ((safe_div_func_uint16_t_u_u(0x9616L, l_623)) , (-2L)))) > 0x3E85252CL) >= l_623) , l_635), l_635)) , l_635) || g_72.f2), g_243)), g_32.f3)) != 0x3EC22B56A814C93DLL) >= (-7L)) , (*g_619)) != (void*)0)) > l_623)) >= g_32.f5))) , g_8))), 1UL)), g_32.f7)) <= g_32.f7);
            (***l_437) = l_637;
            (*g_104) = l_636;
            /* statement id: 239 */
            assert (g_105 == &l_623);
        }
        /* facts after for loop */
        //assert (g_105 == &l_623 || g_105 == dangling);
        for (l_600 = 0; (l_600 < 21); l_600++)
        { /* block id: 243 */
            float l_656 = (-0x1.1p-1);
            struct S0 ***l_658 = &l_438;
            int32_t l_659 = (-1L);
            if ((safe_unary_minus_func_int8_t_s((((safe_lshift_func_int8_t_s_s(((g_72.f1 , (*g_193)) == l_643), (((safe_mod_func_int16_t_s_s((((safe_mod_func_int64_t_s_s((((((safe_rshift_func_int16_t_s_u((safe_lshift_func_int8_t_s_s(((safe_div_func_uint8_t_u_u(l_623, g_72.f1)) , (safe_unary_minus_func_int8_t_s((l_658 != (void*)0)))), 2)), g_72.f1)) | ((18446744073709551611UL > l_623) != g_72.f2)) ^ g_72.f3) && 0UL) , 1L), g_230.f0)) >= 0L) == g_32.f5), l_623)) == l_659) ^ 0UL))) && 4294967295UL) <= l_623))))
            { /* block id: 244 */
                (**l_438) = (***l_437);
                (***g_433) = &l_623;
                /* statement id: 246 */
                assert (g_105 == &l_623);
            }
            else
            { /* block id: 247 */
                union U1 ****l_660 = &g_475;
                int32_t l_678 = 0x74346C89L;
                const int16_t l_680 = (-1L);
                uint32_t l_708 = 0UL;
                uint16_t l_721 = 65530UL;
                int32_t *l_722 = &l_623;
                (*l_660) = (void*)0;
                /* statement id: 248 */
                assert (g_475 == 0);
                for (l_428 = 7; (l_428 >= (-24)); l_428 = safe_sub_func_uint64_t_u_u(l_428, 2))
                { /* block id: 251 */
                    int64_t l_679 = 0xCDDD9A3E2C44E361LL;
                    int32_t **l_707 = &g_105;
                    int32_t l_720 = 0x0F4BBF22L;
                    l_623 = (((((**g_476) , (g_72.f7 > (!((safe_sub_func_uint64_t_u_u(((~(g_32.f7 || ((safe_unary_minus_func_uint8_t_u(((safe_div_func_uint8_t_u_u((safe_lshift_func_int8_t_s_s((safe_unary_minus_func_int32_t_s((safe_unary_minus_func_uint64_t_u(g_32.f3)))), 7)), (((g_72.f3 <= ((void*)0 == &g_476)) | ((1UL > (((safe_sub_func_int8_t_s_s((safe_rshift_func_int8_t_s_s(((void*)0 == &g_8), l_678)), l_679)) == 2L) , g_72.f0)) >= l_679)) , g_183))) != l_680))) >= g_243))) == 0UL), g_32.f4)) & g_32.f5)))) , 0x48CCA81666CA0C63LL) > 1UL) , l_681);
                    for (l_659 = (-13); (l_659 != (-1)); l_659 = safe_add_func_uint16_t_u_u(l_659, 1))
                    { /* block id: 255 */
                        int32_t *l_684 = (void*)0;
                        int32_t *l_685 = &g_243;
                        (*g_104) = l_684;
                        /* statement id: 256 */
                        assert (g_105 == 0);
                        (*l_685) = 1L;
                    }
                    for (l_426 = 0; (l_426 == 53); l_426 = safe_add_func_uint8_t_u_u(l_426, 4))
                    { /* block id: 261 */
                        int32_t *l_709 = &l_623;
                        (*l_439) = (**g_620);
                        (*l_709) = 0xAC462864L;
                    }
                    (***l_435) = (((g_72.f2 & ((safe_div_func_int64_t_s_s((safe_div_func_uint16_t_u_u(((safe_rshift_func_int8_t_s_s((((safe_lshift_func_uint16_t_u_u(((l_623 , (safe_div_func_int32_t_s_s(((l_678 & (((0x27EBF0865A2843D5LL > (((g_183 && 4UL) | (l_720 & l_623)) <= ((((((l_623 , (-1L)) | g_32.f6) && 1L) >= g_32.f7) && l_721) || g_8))) >= 3L) || l_659)) | 0xDE4DL), l_623))) || g_8), g_72.f2)) , (****g_618)) , (-10L)), 0)) <= g_243), l_680)), g_243)) < l_659)) >= g_32.f4) , (void*)0);
                    /* statement id: 265 */
                    assert (g_105 == 0);
                }
                /* facts after for loop */
                //assert (g_105 == 0 || g_105 == &l_623 || g_105 == dangling);
                (*l_722) = 0xE4BC88F1L;
                (**g_434) = &l_659;
                /* statement id: 268 */
                assert (g_105 == &l_659);
            }
            /* facts after branching */
            assert (g_105 == &l_659 || g_105 == &l_623);
        }
        /* facts after for loop */
        assert (g_475 == 0 || g_475 == &g_476);
        (*l_740) = ((safe_lshift_func_uint16_t_u_s((((g_32.f1 >= (!(!(safe_unary_minus_func_uint16_t_u(((((safe_rshift_func_int16_t_s_s(g_32.f0, ((safe_unary_minus_func_uint64_t_u(1UL)) < ((((safe_unary_minus_func_int16_t_s((safe_rshift_func_int16_t_s_u(l_623, ((((4294967293UL != ((l_734 == (*g_476)) != ((safe_rshift_func_uint16_t_u_u(g_243, 1)) || (l_737 ^ l_623)))) > g_230.f0) ^ 255UL) & l_410.f7))))) ^ 0xA5B4L) >= g_72.f3) && g_32.f4)))) , (void*)0) == &g_475) > l_739)))))) ^ g_183) & 5L), 2)) != g_72.f0);
    }
    /* facts after branching */
    //assert (g_105 == dangling || g_105 == &g_8 || g_105 == &g_243 || g_105 == 0);
    assert (g_441 == 0 || g_441 == &l_435);
    assert (g_475 == 0 || g_475 == &g_476);
    for (l_579 = 15; (l_579 > 23); l_579 = safe_add_func_uint16_t_u_u(l_579, 1))
    { /* block id: 275 */
        int32_t *l_743 = &l_681;
        int32_t *****l_744 = &l_435;
        (***g_433) = (((void*)0 != (*g_194)) , l_743);
        /* statement id: 276 */
        assert (g_105 == &l_681);
        g_441 = l_744;
        /* statement id: 277 */
        assert (g_441 == &l_435);
        g_617 = &g_618;
    }
    /* facts after for loop */
    //assert (g_105 == &l_681 || g_105 == dangling || g_105 == &g_8 || g_105 == &g_243 || g_105 == 0);
    g_32.f4 = l_410.f5;
    (***g_618) = (*g_620);
    return g_32.f6;
    /* statement id: 282 */
    //assert (g_105 == dangling || g_105 == &g_8 || g_105 == &g_243 || g_105 == 0);
    //assert (g_441 == 0 || g_441 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_32 g_72.f0 g_72.f7 g_72.f2 g_229 g_230 g_104 g_105 g_243 g_230.f0 g_72.f4 g_183 g_72.f6 g_72.f1 g_118
 * writes: g_72 g_92 g_105 g_229 g_32.f2 g_243 g_8
 */
static int64_t  func_6(uint32_t  p_7)
{ /* block id: 1 */
    const uint64_t l_9 = 0xD2C87A7525D2D915LL;
    int32_t l_338 = 6L;
    union U1 **l_340 = (void*)0;
    union U1 ***l_339 = &l_340;
    struct S0 *l_348 = &g_32;
    struct S0 **l_347 = &l_348;
    struct S0 ****l_366 = (void*)0;
    int32_t *l_369 = &g_8;
    uint64_t l_378 = 0x92E8C8DB16D8EFE9LL;
    float ***l_379 = &g_194;
    uint32_t l_390 = 2UL;
    l_338 = (l_9 >= ((safe_add_func_float_f_f((safe_add_func_float_f_f((!((((((safe_add_func_uint32_t_u_u(1UL, (func_17(p_7) , (0x4A0AEEF7L || ((l_9 == (0x8DL >= g_32.f6)) ^ ((*g_105) , l_9)))))) , 0x8.90215Ap+62) < p_7) >= p_7) < p_7) > 0x0.0B2586p-72)), p_7)), l_9)) >= l_9));
    /* statement id: 121 */
    assert (g_105 == &g_243);
    if (((p_7 || ((l_338 && (p_7 & ((l_9 != (0xA849F018L <= p_7)) == (l_339 != &l_340)))) , ((((-1L) == l_9) < l_9) , 0UL))) > 0x94DFDEB248284AA0LL))
    { /* block id: 122 */
        const struct S0 ****l_341 = (void*)0;
        const struct S0 *****l_342 = &l_341;
        struct S0 **l_349 = &l_348;
        int32_t l_351 = 0x9BFA9311L;
        (*g_104) = &l_338;
        /* statement id: 123 */
        assert (g_105 == &l_338);
        (*l_342) = l_341;
        for (p_7 = 0; (p_7 <= 8); p_7 = safe_add_func_uint8_t_u_u(p_7, 9))
        { /* block id: 127 */
            uint32_t l_350 = 18446744073709551615UL;
            int32_t *l_367 = &l_338;
            struct S0 *l_368 = &g_32;
            if (((func_17(((g_32.f6 > 0xA9F9E3E2L) || ((safe_sub_func_uint16_t_u_u(((void*)0 != &g_118), ((l_9 != ((l_347 != l_349) > p_7)) || (g_183 , 0L)))) < l_350))) , g_118) != g_118))
            { /* block id: 128 */
                if ((*g_105))
                    break;
            }
            else
            { /* block id: 130 */
                l_351 = (l_350 > 0xB.ECA6CAp-12);
                if (l_9)
                    continue;
                (*g_105) = (safe_lshift_func_uint16_t_u_u((safe_mod_func_int8_t_s_s(((safe_div_func_uint8_t_u_u((safe_div_func_int64_t_s_s((((g_32.f0 | (0x97F4BBE4L >= ((safe_add_func_uint32_t_u_u((0x9ED9L || ((safe_sub_func_uint32_t_u_u(p_7, (safe_div_func_int16_t_s_s(((l_366 != (((((((**l_347) , (*g_229)) , (*l_342)) == (*l_342)) > 5L) && 0x252EL) , (*l_342))) | p_7), g_32.f3)))) & p_7)), 0x1B005505L)) != (-8L)))) == 0x80CFL) <= p_7), g_243)), l_350)) <= g_243), g_32.f7)), 3));
                (*g_104) = l_367;
                /* statement id: 134 */
                assert (g_105 == &l_338);
            }
            (*l_349) = l_368;
        }
        /* facts after for loop */
        assert (g_105 == &g_243 || g_105 == &l_338);
        (*g_104) = &l_351;
        /* statement id: 138 */
        assert (g_105 == &l_351);
    }
    else
    { /* block id: 139 */
        int32_t *l_370 = &g_8;
        float *l_371 = &g_92;
        (*g_104) = l_369;
        /* statement id: 140 */
        assert (g_105 == &g_8);
        (*g_104) = l_370;
        (*g_104) = &l_338;
        /* statement id: 142 */
        assert (g_105 == &l_338);
        (*l_371) = 0x0.A3C46Bp+27;
    }
    /* facts after branching */
    //assert (g_105 == &l_338 || g_105 == dangling);
    if ((safe_lshift_func_uint8_t_u_u(p_7, (!(g_8 < ((safe_mod_func_int32_t_s_s((!((p_7 <= (((l_378 ^ 0x2768A1F6C9FF6B8ALL) , (((void*)0 == l_379) | g_72.f6)) <= g_32.f1)) && (*l_369))), (*l_369))) , p_7))))))
    { /* block id: 145 */
        union U1 *l_384 = &g_230;
        float ***l_385 = &g_194;
        int32_t l_391 = 9L;
        union U1 ***l_403 = &l_340;
        int32_t l_406 = (-10L);
        (*l_369) = ((safe_sub_func_float_f_f(((((safe_lshift_func_int16_t_s_u(((*l_369) & ((void*)0 == l_384)), (l_385 == (void*)0))) == p_7) & (((0x50L <= (safe_mod_func_int64_t_s_s((safe_rshift_func_int16_t_s_s((((*l_369) != (*l_369)) >= g_32.f0), l_390)), l_391))) >= 0x472EL) || 1L)) , p_7), (*l_369))) , p_7);
        (*l_369) = ((g_230.f0 & (safe_div_func_int16_t_s_s(((((g_32.f0 && (safe_add_func_uint32_t_u_u(((safe_div_func_int16_t_s_s((((~0xA6E4L) != p_7) ^ ((safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(g_32.f6, 4)), 0)) , (0x15F0D0E1L && ((void*)0 != l_403)))), (safe_rshift_func_uint16_t_u_u(p_7, 2)))) | l_406), p_7))) , l_406) | 0L) ^ p_7), g_32.f4))) != 4UL);
    }
    else
    { /* block id: 148 */
        struct S0 *l_407 = &g_32;
        l_407 = (void*)0;
        /* statement id: 149 */
        assert (l_407 == 0);
        (*g_104) = &l_338;
        /* statement id: 150 */
        assert (g_105 == &l_338);
    }
    return (*l_369);
    /* statement id: 152 */
    //assert (g_105 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_32 g_72.f0 g_72.f7 g_72.f2 g_229 g_230 g_104 g_105 g_243 g_230.f0 g_72.f4 g_183 g_72.f6 g_72.f1
 * writes: g_72 g_92 g_105 g_229 g_32.f2 g_243
 */
inline static struct S0  func_17(uint32_t  p_18)
{ /* block id: 2 */
    int16_t l_19 = (-1L);
    float *l_335 = &g_92;
    float ***l_336 = &g_194;
    struct S0 l_337 = {1,38,0x34L,-7,-269,79,13,0};
    (*l_335) = (((g_8 <= l_19) , (0x5.86255Dp+40 == (!((g_8 != ((func_21(func_26(g_32, p_18, ((safe_div_func_float_f_f((safe_div_func_float_f_f(g_32.f1, func_37((8L <= (func_43(l_19) > g_243)), l_19, l_19))), l_19)) != l_19), p_18, g_230), l_19, p_18, g_32.f1) , g_72.f1) > l_19)) <= l_19)))) < (-0x1.Cp+1));
    /* statement id: 118 */
    assert (g_105 == &g_243);
    (*g_104) = ((p_18 || (l_336 != (void*)0)) , (*g_104));
    return l_337;
}


/* ------------------------------------------ */
/* 
 * reads : g_72.f2 g_243 g_230.f0 g_32.f2 g_183 g_32.f0 g_72.f0 g_72.f6 g_105 g_32.f3
 * writes: g_32.f2 g_243
 */
static float  func_21(const uint32_t  p_22, float  p_23, const int64_t  p_24, int8_t  p_25)
{ /* block id: 103 */
    uint16_t l_298 = 0xEC67L;
    union U1 *l_308 = &g_230;
    struct S0 l_312 = {1,9,0UL,7,435,493,8,0};
    const int32_t *l_333 = &g_243;
    const int32_t **l_334 = &l_333;
    if (((g_72.f2 | (0xD0L != (safe_lshift_func_uint16_t_u_s((safe_div_func_int32_t_s_s(l_298, (safe_rshift_func_uint8_t_u_u((g_243 || (!(0x890D70B6333A4172LL && g_230.f0))), 1)))), 11)))) | ((l_298 , (safe_lshift_func_uint8_t_u_u((safe_div_func_uint32_t_u_u(0x0155A2B3L, 4294967289UL)), 1))) < 1UL)))
    { /* block id: 104 */
        struct S0 *l_306 = &g_32;
        struct S0 *l_307 = &g_72;
        l_307 = l_306;
        /* statement id: 105 */
        assert (l_307 == &g_32);
    }
    else
    { /* block id: 106 */
        union U1 **l_309 = &l_308;
        int32_t l_330 = 1L;
        uint16_t l_331 = 65530UL;
        uint8_t l_332 = 0x8EL;
        (*l_309) = l_308;
        for (g_32.f2 = 0; (g_32.f2 != 44); g_32.f2 = safe_add_func_int8_t_s_s(g_32.f2, 1))
        { /* block id: 110 */
            struct S0 *l_313 = (void*)0;
            struct S0 *l_314 = &l_312;
            int32_t l_319 = 2L;
            union U1 *l_323 = &g_230;
            (*l_314) = l_312;
            (*g_105) = (g_183 <= (safe_sub_func_int8_t_s_s((g_32.f0 > (((l_312 , (l_319 , (!(((safe_sub_func_uint64_t_u_u(0x560447B2E25A390CLL, g_72.f0)) >= ((l_323 == l_323) ^ (safe_rshift_func_uint16_t_u_s((safe_lshift_func_uint8_t_u_u((safe_add_func_uint32_t_u_u(((l_330 != g_72.f6) , l_331), g_72.f6)), p_25)), 6)))) > l_332)))) & l_331) == 9L)), 0x32L)));
        }
        return g_32.f3;
    }
    (*l_334) = l_333;
    return p_24;
}


/* ------------------------------------------ */
/* 
 * reads : g_104 g_32.f7
 * writes: g_105
 */
inline static uint32_t  func_26(struct S0  p_27, uint8_t  p_28, float  p_29, const int32_t  p_30, union U1  p_31)
{ /* block id: 100 */
    int32_t *l_291 = &g_243;
    (*g_104) = l_291;
    /* statement id: 101 */
    assert (g_105 == &g_243);
    return g_32.f7;
}


/* ------------------------------------------ */
/* 
 * reads : g_32.f0 g_243
 * writes: g_92
 */
static float  func_37(uint64_t  p_38, const int32_t  p_39, int32_t  p_40)
{ /* block id: 96 */
    union U1 **l_276 = &g_229;
    union U1 ***l_275 = &l_276;
    int32_t l_277 = (-9L);
    int64_t l_282 = 0xC06C30A758AB5E42LL;
    union U1 l_283 = {0x529B3CD36BC43A74LL};
    int32_t ****l_285 = (void*)0;
    int32_t *****l_284 = &l_285;
    const int64_t l_288 = 0xC54E92F58A89B082LL;
    float *l_289 = &g_92;
    int16_t l_290 = 0x6A65L;
    (*l_275) = &g_229;
    (*l_289) = (l_277 < (((safe_div_func_float_f_f(p_40, (safe_sub_func_float_f_f((l_282 < 0x0.2p+1), ((((((l_283 , l_284) == (((2UL > (&g_105 != ((((safe_sub_func_uint16_t_u_u((65526UL && p_39), g_32.f0)) <= p_40) | g_243) , (void*)0))) != p_40) , &l_285)) < l_288) < 0x6.154063p-84) <= p_39) == p_40))))) >= 0x1.5p-1) < p_39));
    return l_290;
}


/* ------------------------------------------ */
/* 
 * reads : g_32.f7 g_32.f4 g_32 g_72.f0 g_72.f7 g_72.f2 g_229 g_230 g_104 g_105 g_8 g_243 g_230.f0 g_72.f4 l_338
 * writes: g_72 g_92 g_105 g_229
 */
static int8_t  func_43(uint32_t  p_44)
{ /* block id: 3 */
    int16_t l_52 = (-6L);
    uint32_t l_67 = 0x44DB2854L;
    struct S0 l_68 = {-1,1,0x93L,-6,-106,40,13,0};
    uint32_t l_244 = 1UL;
    int32_t *l_248 = (void*)0;
    float ***l_269 = &g_194;
    float ***l_270 = &g_194;
    uint8_t l_274 = 0UL;
    l_68.f3 = (func_45((func_47(l_52, g_32.f7, g_32.f4, (safe_mod_func_uint64_t_u_u((((safe_div_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u(func_59(p_44, (safe_lshift_func_uint8_t_u_s(p_44, (~0x5FL))), l_67, l_68), 10)), p_44)) | l_52) == (-4L)), 0x6E0DAEE255298A7BLL))) != g_32.f3)) ^ l_244);
    if (l_68.f6)
    { /* block id: 82 */
        float l_263 = 0x0.1p+1;
        uint8_t l_271 = 0UL;
        struct S0 *l_272 = &g_32;
        for (l_67 = 0; (l_67 > 25); l_67 = safe_add_func_int64_t_s_s(l_67, 9))
        { /* block id: 85 */
            union U1 **l_247 = &g_229;
            (*l_247) = &g_230;
            return p_44;
        }
        (*g_104) = l_248;
        /* statement id: 89 */
        assert (g_105 == 0);
        (*g_104) = (*g_104);
        l_68.f3 = (safe_lshift_func_int8_t_s_u((safe_lshift_func_int8_t_s_s((p_44 < (safe_rshift_func_int8_t_s_u((safe_lshift_func_uint8_t_u_s((l_68 , ((((0xD0A975BA9DFC485CLL != (safe_sub_func_int16_t_s_s((safe_div_func_int32_t_s_s(((safe_div_func_int8_t_s_s((((g_230.f0 && (((((safe_add_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((0x4DFAA35959F26372LL > ((((~((((0x802269A3159ADB9CLL < g_72.f4) <= (((l_269 == l_270) >= p_44) ^ g_72.f4)) == g_72.f7) | p_44)) , p_44) & 0x0DF51878L) > l_271)) , l_271), l_271)), p_44)) || g_230.f0) , l_272) != (void*)0) | p_44)) & 0L) < g_8), 247UL)) < 9L), 0xC36080E9L)), g_32.f5))) <= 6UL) , 251UL) | 0UL)), p_44)), l_271))), 3)), p_44));
    }
    else
    { /* block id: 92 */
        struct S0 *l_273 = &g_72;
        l_273 = &l_68;
        /* statement id: 93 */
        assert (l_273 == &l_68);
    }
    /* facts after branching */
    //assert (g_105 == &g_8 || g_105 == 0 || g_105 == &l_338 || g_105 == &g_243);
    return l_274;
}


/* ------------------------------------------ */
/* 
 * reads : g_243
 * writes:
 */
static int64_t  func_45(uint64_t  p_46)
{ /* block id: 79 */
    return g_243;
}


/* ------------------------------------------ */
/* 
 * reads : g_72.f0 g_32.f1 g_32.f5 g_72.f7 g_72.f2 g_229 g_230 g_104 g_105 g_8 l_338 g_243
 * writes: g_92 g_72.f2 g_105
 */
static uint16_t  func_47(float  p_48, int32_t  p_49, uint8_t  p_50, uint64_t  p_51)
{ /* block id: 8 */
    int16_t l_90 = (-5L);
    float *l_91 = &g_92;
    struct S0 ***l_119 = (void*)0;
    uint32_t l_165 = 0x3E4380B9L;
    int32_t ***l_178 = &g_104;
    (*l_91) = (safe_add_func_float_f_f((safe_add_func_float_f_f(g_72.f0, ((safe_sub_func_float_f_f(((safe_sub_func_float_f_f((((safe_add_func_float_f_f(((p_48 != p_51) < (safe_sub_func_float_f_f(((-(p_50 == (0x0.9p-1 <= g_32.f1))) >= ((p_51 < (safe_add_func_float_f_f(g_32.f5, (safe_sub_func_float_f_f(0x0.Bp-1, (-0x1.7p-1)))))) < 0x8.FE4960p-18)), 0x7.D7CBC1p-58))), 0x2.5CE947p+67)) > 0x8.AEE56Cp-71) <= l_90), l_90)) >= 0x3.237AE9p+61), l_90)) <= g_72.f7))), p_48));
    for (p_49 = 0; (p_49 >= 3); p_49 = safe_add_func_uint8_t_u_u(p_49, 1))
    { /* block id: 12 */
        struct S0 l_112 = {1,8,0x52L,-6,-701,39,5,0};
        struct S0 *l_143 = &g_72;
        struct S0 **l_142 = &l_143;
        float **l_166 = &l_91;
        int32_t *l_242 = &g_8;
        for (g_72.f2 = 0; (g_72.f2 > 47); g_72.f2 = safe_add_func_int64_t_s_s(g_72.f2, 6))
        { /* block id: 15 */
            uint32_t l_144 = 0xBCE55470L;
            int32_t ***l_171 = &g_104;
            struct S0 **l_177 = &l_143;
            struct S0 l_184 = {0,43,0x04L,-2,-276,78,2,0};
            struct S0 l_185 = {-0,12,0xA0L,1,713,598,5,0};
            uint64_t l_208 = 0x6C2B630719000718LL;
            for (p_51 = 0; (p_51 <= 55); p_51 = safe_add_func_uint64_t_u_u(p_51, 6))
            { /* block id: 18 */
                struct S0 *l_100 = &g_32;
                struct S0 **l_99 = &l_100;
                struct S0 ***l_101 = &l_99;
                int32_t *l_109 = (void*)0;
                int8_t l_170 = 0xF2L;
                int32_t ***l_174 = &g_104;
                (*l_101) = l_99;
            }
            l_185 = l_184;
        }
        for (l_165 = 19; (l_165 >= 1); l_165 = safe_sub_func_int16_t_s_s(l_165, 1))
        { /* block id: 71 */
            int32_t *****l_234 = (void*)0;
            int32_t *****l_235 = (void*)0;
            int32_t ****l_237 = &l_178;
            int32_t *****l_236 = &l_237;
            (*l_236) = &l_178;
            (***l_237) = (((safe_sub_func_float_f_f(p_48, (safe_div_func_float_f_f(p_48, (-0x10.Cp-1))))) < (0x0.1p-1 >= ((*g_229) , ((l_112.f2 <= (*****l_236)) != (&g_104 != l_178))))) , l_242);
            /* statement id: 73 */
            assert (g_105 == &g_8);
            if (p_51)
                continue;
        }
        (**l_166) = p_51;
    }
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_32
 * writes: g_72
 */
inline static int16_t  func_59(const int16_t  p_60, const uint32_t  p_61, uint32_t  p_62, struct S0  p_63)
{ /* block id: 4 */
    int32_t *l_69 = &g_8;
    int32_t **l_70 = &l_69;
    struct S0 *l_71 = &g_72;
    (*l_70) = l_69;
    (*l_71) = g_32;
    return p_63.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_32.f0, "g_32.f0", print_hash_value);
    transparent_crc(g_32.f1, "g_32.f1", print_hash_value);
    transparent_crc(g_32.f2, "g_32.f2", print_hash_value);
    transparent_crc(g_32.f3, "g_32.f3", print_hash_value);
    transparent_crc(g_32.f4, "g_32.f4", print_hash_value);
    transparent_crc(g_32.f5, "g_32.f5", print_hash_value);
    transparent_crc(g_32.f6, "g_32.f6", print_hash_value);
    transparent_crc(g_32.f7, "g_32.f7", print_hash_value);
    transparent_crc(g_72.f0, "g_72.f0", print_hash_value);
    transparent_crc(g_72.f1, "g_72.f1", print_hash_value);
    transparent_crc(g_72.f2, "g_72.f2", print_hash_value);
    transparent_crc(g_72.f3, "g_72.f3", print_hash_value);
    transparent_crc(g_72.f4, "g_72.f4", print_hash_value);
    transparent_crc(g_72.f5, "g_72.f5", print_hash_value);
    transparent_crc(g_72.f6, "g_72.f6", print_hash_value);
    transparent_crc(g_72.f7, "g_72.f7", print_hash_value);
    transparent_crc_bytes (&g_92, sizeof(g_92), "g_92", print_hash_value);
    transparent_crc(g_183, "g_183", print_hash_value);
    transparent_crc(g_230.f0, "g_230.f0", print_hash_value);
    transparent_crc(g_243, "g_243", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 152
   depth: 1, occurrence: 11
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 32
breakdown:
   indirect level: 0, occurrence: 11
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 2
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 17
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 138

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 171
   depth: 2, occurrence: 25
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 4
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 3
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 34, occurrence: 1
   depth: 36, occurrence: 2

XXX total number of pointers: 118

XXX times a variable address is taken: 128
XXX times a pointer is dereferenced on RHS: 88
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 11
   depth: 3, occurrence: 13
   depth: 4, occurrence: 13
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 87
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 7
   depth: 3, occurrence: 11
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 425

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 215
   level: 2, occurrence: 71
   level: 3, occurrence: 77
   level: 4, occurrence: 46
   level: 5, occurrence: 13
XXX number of pointers point to pointers: 65
XXX number of pointers point to scalars: 28
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 18.6
XXX average alias set size: 1.12

XXX times a non-volatile is read: 810
XXX times a non-volatile is write: 250
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 141
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 33
   depth: 2, occurrence: 25
   depth: 3, occurrence: 25
   depth: 4, occurrence: 15
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

