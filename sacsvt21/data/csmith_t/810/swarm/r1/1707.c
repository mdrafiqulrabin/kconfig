/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3167263106
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int16_t  func_15(const uint16_t * p_16, uint16_t * p_17, uint16_t  p_18, uint16_t * p_19);
static uint16_t ** func_34(uint32_t  p_35, uint32_t  p_36, int32_t * p_37, int32_t  p_38);
static int16_t  func_50(int16_t  p_51, int16_t * p_52, uint16_t  p_53);
static uint32_t  func_54(int32_t  p_55, uint32_t  p_56);
inline static int16_t * func_72(uint32_t  p_73, uint32_t  p_74, uint16_t  p_75);
static int32_t  func_77(uint32_t  p_78);
inline static int32_t  func_79(int32_t  p_80, const int32_t  p_81);
inline static uint16_t * func_88(uint32_t  p_89, uint16_t  p_90);
static uint32_t  func_91(uint32_t  p_92, uint32_t  p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_12 = 0x69BD697EL;
    uint16_t l_14 = 0UL;
    uint16_t *l_13 = &l_14;
    int16_t l_27 = (-1L);
    int16_t *l_26 = &l_27;
    int32_t l_28 = (-9L);
    uint32_t l_29 = 0UL;
    int16_t l_290 = 0L;
    uint16_t l_291 = 8UL;
    uint16_t ****l_318 = (void*)0;
    if (((safe_mod_func_int32_t_s_s((safe_add_func_uint16_t_u_u((((safe_sub_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((0L && ((((*l_13) = l_12) != (l_12 > ((*l_26) = (func_15(l_13, l_13, ((l_28 = (((safe_add_func_int16_t_s_s((safe_mod_func_int16_t_s_s(((*l_26) = (safe_div_func_int16_t_s_s((1UL >= 1UL), (1L && l_12)))), l_12)), l_12)) ^ l_12) > 0xE1D4595AL)) > l_29), l_13) | l_290)))) > l_290)), 11)), l_291)) != l_12) >= 1L), l_12)), 1L)) < l_290))
    { /* block id: 100 */
        int32_t l_292 = 5L;
        return l_292;
    }
    else
    { /* block id: 102 */
        uint32_t l_301 = 9UL;
        int32_t l_302 = 0x961C7848L;
        int32_t *l_303 = &l_12;
        int32_t *l_304 = &l_302;
        int32_t **l_305 = &l_303;
        (*l_303) = (safe_sub_func_int32_t_s_s(((safe_add_func_uint16_t_u_u(65534UL, (safe_mod_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s(l_301, 11)) == l_302), (l_28 | 0x256FL))))) != l_301), 6L));
        (*l_305) = l_304;
        /* statement id: 104 */
        assert (l_303 == &l_302);
    }
    for (l_28 = 0; (l_28 != 0); l_28 = safe_add_func_uint32_t_u_u(l_28, 5))
    { /* block id: 108 */
        int16_t **l_309 = (void*)0;
        int16_t ***l_308 = &l_309;
        int16_t **l_310 = &l_26;
        uint16_t **l_317 = &l_13;
        uint16_t ***l_316 = &l_317;
        uint16_t ****l_315 = &l_316;
        uint16_t ****l_320 = (void*)0;
        uint16_t ****l_321 = &l_316;
        int16_t ***l_322 = &l_310;
        int32_t *l_323 = (void*)0;
        int32_t *l_324 = &l_12;
        (*l_324) = ((((*l_308) = &l_26) != l_310) < (safe_lshift_func_int16_t_s_s(((l_315 == l_318) >= (!(l_29 | 0x4CA5L))), (((l_320 = l_318) != (l_321 = l_318)) == (&l_310 == l_322)))));
        /* statement id: 112 */
        assert (l_309 == &l_26);
        assert (l_321 == 0);
    }
    return l_27;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_15(const uint16_t * p_16, uint16_t * p_17, uint16_t  p_18, uint16_t * p_19)
{ /* block id: 4 */
    int32_t l_31 = 0x017A68FAL;
    int32_t *l_30 = &l_31;
    int16_t l_61 = 0xEAA9L;
    int16_t *l_60 = &l_61;
    int32_t **l_288 = (void*)0;
    int32_t **l_289 = &l_30;
    l_30 = l_30;
    (*l_30) = 0x10CBEDFAL;
    for (p_18 = 0; (p_18 <= 41); p_18 = safe_add_func_uint32_t_u_u(p_18, 1))
    { /* block id: 9 */
        uint32_t l_40 = 4294967295UL;
        uint32_t *l_39 = &l_40;
        int32_t l_43 = 0xD2E84CBFL;
        int16_t l_59 = 0x8F0BL;
        int16_t *l_58 = &l_59;
        uint16_t l_280 = 0xCD3EL;
        uint16_t *l_279 = &l_280;
        uint16_t **l_278 = &l_279;
        uint16_t ***l_277 = &l_278;
        int32_t **l_281 = &l_30;
        const int32_t *l_285 = (void*)0;
        const int32_t **l_284 = &l_285;
    }
    (*l_289) = (void*)0;
    /* statement id: 97 */
    assert (l_30 == 0);
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t ** func_34(uint32_t  p_35, uint32_t  p_36, int32_t * p_37, int32_t  p_38)
{ /* block id: 84 */
    int32_t l_270 = 0L;
    int32_t l_271 = (-4L);
    uint16_t l_274 = 0UL;
    uint16_t *l_273 = &l_274;
    uint16_t **l_272 = &l_273;
    uint16_t **l_275 = &l_273;
    uint16_t **l_276 = (void*)0;
    l_271 = (safe_mul_func_uint16_t_u_u((p_38 | 1UL), l_270));
    return l_276;
    /* statement id: 86 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_50(int16_t  p_51, int16_t * p_52, uint16_t  p_53)
{ /* block id: 14 */
    uint32_t l_267 = 0UL;
    for (p_51 = (-9); (p_51 >= 12); ++p_51)
    { /* block id: 17 */
        int32_t l_230 = 0x1DAF28E7L;
        for (p_53 = 0; (p_53 != 18); p_53 = safe_add_func_int16_t_s_s(p_53, 3))
        { /* block id: 20 */
            int32_t l_67 = 0xA0D3D7FBL;
            int32_t *l_66 = &l_67;
            int32_t l_69 = 0x18431BB5L;
            int32_t *l_68 = &l_69;
            uint16_t l_239 = 0xAFC0L;
            uint16_t *l_238 = &l_239;
            uint16_t **l_237 = &l_238;
            uint16_t ***l_236 = &l_237;
            uint16_t ****l_235 = &l_236;
            (*l_68) = ((*l_66) = p_51);
            for (l_67 = 5; (l_67 == 11); l_67 = safe_add_func_uint16_t_u_u(l_67, 7))
            { /* block id: 25 */
                int16_t *l_243 = (void*)0;
                int16_t **l_242 = &l_243;
                int32_t l_244 = (-6L);
                if (p_53)
                { /* block id: 26 */
                    uint32_t l_76 = 0xDCDEDC29L;
                    int16_t **l_216 = (void*)0;
                    int16_t l_219 = 6L;
                    int16_t *l_218 = &l_219;
                    int16_t **l_217 = &l_218;
                    int32_t *l_245 = &l_244;
                    int32_t **l_246 = &l_66;
                    (*l_68) = (((*l_217) = func_72(p_53, l_76, p_53)) != &p_51);
                    /* statement id: 73 */
                    assert (l_218 == 0);
                    (*l_245) = (safe_rshift_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u((safe_div_func_uint32_t_u_u(p_53, 0xA7DBD609L)), ((p_51 || ((safe_div_func_uint16_t_u_u((safe_add_func_int32_t_s_s((0L & (l_230 & (safe_div_func_int16_t_s_s((safe_mod_func_int32_t_s_s((l_235 != (void*)0), (((*l_68) = ((safe_mul_func_int16_t_s_s((*p_52), ((((l_242 != (void*)0) != (*p_52)) > p_53) == l_76))) <= 4294967295UL)) | 0xEB18F663L))), l_244)))), (-1L))), (*l_66))) || p_51)) || 0xF1CB64C1L))) > 6UL), 7));
                    (*l_246) = &l_67;
                }
                else
                { /* block id: 77 */
                    int16_t l_266 = 0x18BEL;
                    (*l_68) = ((safe_rshift_func_uint16_t_u_s((~(safe_lshift_func_int16_t_s_s(0x8378L, 13))), (safe_lshift_func_int16_t_s_s(((safe_add_func_int32_t_s_s((safe_div_func_int32_t_s_s(((((safe_div_func_int32_t_s_s(1L, ((p_53 > ((l_244 > (safe_mul_func_uint16_t_u_u(p_53, ((*p_52) < (safe_rshift_func_uint16_t_u_u((p_51 != (safe_div_func_uint16_t_u_u((*l_68), l_266))), p_51)))))) ^ l_267)) || l_266))) > (*l_68)) != l_266) && 0xCFC60001L), 4294967295UL)), 0x18EB078AL)) & l_230), 0)))) != l_230);
                }
            }
        }
    }
    return (*p_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_54(int32_t  p_55, uint32_t  p_56)
{ /* block id: 11 */
    uint32_t l_57 = 0xDCEDB1A7L;
    return l_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t * func_72(uint32_t  p_73, uint32_t  p_74, uint16_t  p_75)
{ /* block id: 27 */
    int32_t *l_203 = (void*)0;
    int32_t l_204 = (-1L);
    int32_t *l_207 = (void*)0;
    int32_t *l_208 = &l_204;
    int16_t l_210 = 0xFAF8L;
    int16_t *l_209 = &l_210;
    int16_t *l_211 = &l_210;
    int16_t *l_212 = &l_210;
    int16_t *l_213 = &l_210;
    int16_t *l_214 = &l_210;
    int16_t *l_215 = (void*)0;
    l_204 = func_77(p_73);
    (*l_208) = (safe_rshift_func_uint16_t_u_u(p_74, 6));
    return l_215;
    /* statement id: 71 */
    //assert (func_72_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_77(uint32_t  p_78)
{ /* block id: 28 */
    const int16_t *l_82 = (void*)0;
    int16_t l_85 = 0x7242L;
    int16_t *l_84 = &l_85;
    int16_t **l_83 = &l_84;
    int16_t *l_86 = (void*)0;
    int16_t *l_87 = &l_85;
    int32_t l_94 = 0xC67586E0L;
    uint16_t **l_199 = (void*)0;
    uint16_t *l_201 = (void*)0;
    uint16_t **l_200 = &l_201;
    int32_t *l_202 = &l_94;
    (*l_202) = func_79(((l_82 != ((*l_83) = (void*)0)) & (((*l_87) = l_85) == 0x4637L)), (((*l_200) = func_88(func_91(l_94, (&l_94 != &l_94)), (safe_lshift_func_uint16_t_u_u(p_78, p_78)))) == (void*)0));
    /* statement id: 67 */
    assert (l_84 == 0);
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_79(int32_t  p_80, const int32_t  p_81)
{ /* block id: 65 */
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t * func_88(uint32_t  p_89, uint16_t  p_90)
{ /* block id: 39 */
    int32_t *l_120 = (void*)0;
    int32_t **l_121 = &l_120;
    int16_t l_124 = 0x4290L;
    uint16_t l_126 = 0xD092L;
    uint16_t *l_125 = &l_126;
    int16_t l_133 = 0L;
    uint16_t *l_198 = (void*)0;
    (*l_121) = l_120;
    if (((safe_mul_func_int16_t_s_s(p_90, l_124)) >= (l_125 != &l_126)))
    { /* block id: 41 */
        uint16_t *l_129 = (void*)0;
        uint16_t l_131 = 0UL;
        uint16_t *l_130 = &l_131;
        int16_t *l_132 = &l_124;
        int32_t l_134 = 1L;
        l_134 = (((*l_132) = (safe_mod_func_int32_t_s_s(((void*)0 != &l_120), ((((*l_130) = ((*l_125) = p_90)) ^ p_90) || 0L)))) ^ l_133);
    }
    else
    { /* block id: 46 */
        uint32_t l_137 = 0xE41CA980L;
        const int16_t l_140 = 1L;
        const int16_t *l_139 = &l_140;
        const int16_t **l_138 = &l_139;
        uint16_t l_150 = 0x0092L;
        uint16_t *l_149 = &l_150;
        int32_t l_152 = 0L;
        int32_t *l_151 = &l_152;
        int32_t l_195 = 0x77C06B42L;
        uint16_t ***l_196 = (void*)0;
        (*l_151) = (safe_add_func_int16_t_s_s((p_90 >= (l_137 || ((*l_125) = ((p_89 && (&l_124 != ((*l_138) = &l_133))) ^ p_90)))), (safe_add_func_int32_t_s_s((((safe_add_func_uint16_t_u_u((p_90 > (((*l_149) = (safe_mod_func_uint16_t_u_u(((((safe_div_func_uint16_t_u_u(l_137, l_137)) || p_90) || 1L) > (-1L)), p_89))) || 65535UL)), 0x1B86L)) <= p_90) >= 0x1AEEC80AL), l_140))));
        /* statement id: 50 */
        assert (l_139 == &l_140 || l_139 == &l_133);
        (*l_121) = &l_152;
        /* statement id: 51 */
        assert (l_120 == &l_152);
        for (l_133 = 0; (l_133 > 8); ++l_133)
        { /* block id: 54 */
            int16_t l_155 = 0x90C5L;
            uint32_t l_169 = 0xC3CA6ABCL;
            uint32_t *l_168 = &l_169;
            int32_t l_172 = (-1L);
            uint16_t ****l_197 = &l_196;
            (*l_120) = (l_155 < ((void*)0 == &p_89));
            l_172 = (safe_mul_func_int16_t_s_s(((((safe_add_func_int32_t_s_s(((safe_mul_func_int16_t_s_s(((safe_sub_func_int16_t_s_s(5L, (**l_121))) | 4294967293UL), (((safe_mul_func_uint32_t_u_u(((!((p_90 | ((void*)0 != (*l_121))) & ((safe_unary_minus_func_uint32_t_u(((*l_168) = 0xC710B0ACL))) || l_169))) | (safe_lshift_func_uint16_t_u_s((*l_120), p_90))), 0L)) == (*l_151)) | 8L))) ^ (*l_120)), (*l_151))) > p_90) && 0L) != (**l_121)), (**l_121)));
            (*l_120) = (((safe_mod_func_int32_t_s_s((0x7CABE74AL && 0xB1B449E2L), 4294967295UL)) >= (safe_lshift_func_uint16_t_u_u((safe_unary_minus_func_int16_t_s((safe_lshift_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u((0xE9B38868L >= (safe_mul_func_uint32_t_u_u(p_90, 0L))), (safe_sub_func_int32_t_s_s((*l_151), (safe_unary_minus_func_int32_t_s((p_89 >= (safe_add_func_int32_t_s_s((safe_rshift_func_int16_t_s_s(((l_195 = (0xA28B5F6DL >= p_90)) && 65531UL), l_155)), p_90))))))))), l_169)), (*l_151))), 2)))), p_90))) ^ p_89);
            (*l_197) = l_196;
        }
    }
    /* facts after branching */
    //assert (l_120 == dangling || l_120 == 0);
    return l_198;
    /* statement id: 63 */
    //assert (func_88_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_91(uint32_t  p_92, uint32_t  p_93)
{ /* block id: 31 */
    int32_t l_97 = 0x947E9E58L;
    int32_t *l_96 = &l_97;
    int32_t **l_95 = &l_96;
    int16_t *l_102 = (void*)0;
    int16_t l_112 = 0x51EAL;
    int16_t *l_111 = &l_112;
    uint16_t *l_113 = (void*)0;
    uint16_t l_115 = 65526UL;
    uint16_t *l_114 = &l_115;
    int32_t *l_116 = (void*)0;
    int32_t *l_117 = &l_97;
    (*l_95) = (void*)0;
    /* statement id: 32 */
    assert (l_96 == 0);
    (*l_95) = (*l_95);
    (*l_95) = (void*)0;
    (*l_117) = ((((safe_lshift_func_uint16_t_u_s((safe_mod_func_uint32_t_u_u(((void*)0 == l_102), (((((p_93 < (p_92 < (p_92 >= ((*l_114) = (safe_div_func_int16_t_s_s(((*l_111) = ((safe_add_func_uint32_t_u_u(p_92, p_93)) == ((safe_mul_func_uint16_t_u_u(((p_93 ^ (safe_mod_func_uint32_t_u_u(((-3L) < p_92), 0x24A103C2L))) ^ p_93), p_92)) == p_92))), p_92)))))) && (-1L)) > p_93) | p_92) || p_92))), 3)) > l_97) > 1UL) <= p_92);
    return p_93;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 54
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 9
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 96

XXX times a variable address is taken: 79
XXX times a pointer is dereferenced on RHS: 21
breakdown:
   depth: 1, occurrence: 18
   depth: 2, occurrence: 3
XXX times a pointer is dereferenced on LHS: 47
breakdown:
   depth: 1, occurrence: 47
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 114

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 78
   level: 2, occurrence: 20
XXX number of pointers point to pointers: 38
XXX number of pointers point to scalars: 58
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 32.3
XXX average alias set size: 1.07

XXX times a non-volatile is read: 225
XXX times a non-volatile is write: 111
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 47
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 9
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4

XXX percentage a fresh-made variable is used: 16.5
XXX percentage an existing variable is used: 83.5
********************* end of statistics **********************/

