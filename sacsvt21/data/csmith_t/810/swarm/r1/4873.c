/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --uint8 --no-float --math64 --no-inline-function --no-muls --safe-math --no-packed-struct --no-paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1726570016
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 30;
   unsigned f1 : 27;
   signed f2 : 17;
   signed f3 : 25;
   unsigned f4 : 4;
   signed f5 : 11;
   uint8_t  f6;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_31(void);
static int32_t  func_44(int16_t  p_45, uint64_t  p_46, uint8_t  p_47);
static uint8_t  func_49(int32_t  p_50, uint32_t  p_51);
static uint32_t  func_52(int64_t  p_53, uint32_t  p_54, uint8_t  p_55, int16_t  p_56);
static uint16_t  func_61(int64_t  p_62);
static int64_t  func_63(int32_t  p_64, uint16_t  p_65, uint8_t  p_66);
static int32_t  func_67(int8_t  p_68, int16_t  p_69, uint8_t  p_70, int32_t  p_71);
static uint32_t  func_72(struct S0  p_73, struct S0  p_74);
static uint8_t  func_87(uint64_t  p_88, uint8_t  p_89, int32_t  p_90);
static int64_t  func_97(int32_t  p_98);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_31(void)
{ /* block id: 36 */
    int16_t l_32 = 0x2F3FL;
    int32_t l_33 = (-9L);
    int32_t l_34 = 0xD0BB94D0L;
    int32_t l_35 = (-9L);
    int32_t l_36 = 6L;
    int32_t l_37 = 0L;
    uint64_t l_38 = 18446744073709551611UL;
    struct S0 l_75 = {15410,7066,8,228,0,10,255UL};
    uint16_t l_187 = 65527UL;
    int32_t l_190 = 0L;
    uint64_t l_242 = 0x9DA0880A19A2165DLL;
    ++l_38;
    for (l_32 = 19; (l_32 < 28); ++l_32)
    { /* block id: 40 */
        uint32_t l_43 = 0x2FA814B1L;
        uint16_t l_77 = 65534UL;
        int16_t l_84 = 0x8CA1L;
        int16_t l_188 = (-1L);
        uint64_t l_189 = 0UL;
        struct S0 l_240 = {12888,5239,121,-2800,3,1,246UL};
        if (l_43)
        { /* block id: 41 */
            uint32_t l_48 = 0x040C3F30L;
            struct S0 l_239 = {28838,6575,219,2945,1,17,1UL};
            l_33 ^= func_44(l_48, ((func_49(l_43, func_52(l_34, (((safe_div_func_int16_t_s_s((__builtin_parityl(((((safe_mod_func_uint16_t_u_u(func_61(func_63(func_67((func_72(l_75, l_75) > (l_77 >= (((safe_add_func_int64_t_s_s(l_48, (((safe_mod_func_int32_t_s_s((safe_div_func_int16_t_s_s((l_48 == 0x4BL), 0x9347L)), l_37)) | l_48) >= (-1L)))) ^ l_43) ^ l_48))), l_48, l_84, l_48), l_75.f1, l_77)), l_187)) && l_188) > l_189) == l_32)) >= l_189), l_190)) | 7UL) || l_48), l_48, l_77)) < 0xFEL) & 0x92C9271733CD6398LL), l_48);
            l_239 = l_75;
        }
        else
        { /* block id: 124 */
            struct S0 l_241 = {4159,4892,260,4130,3,0,7UL};
            l_241 = l_240;
            l_241.f2 = l_240.f6;
        }
    }
    l_35 = (l_242 < l_35);
    return l_75.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_44(int16_t  p_45, uint64_t  p_46, uint8_t  p_47)
{ /* block id: 119 */
    struct S0 l_238 = {22734,8815,261,3300,3,-1,0xD2L};
    l_238 = l_238;
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_49(int32_t  p_50, uint32_t  p_51)
{ /* block id: 116 */
    int32_t l_227 = 0x0487FC37L;
    uint16_t l_236 = 3UL;
    int32_t l_237 = (-8L);
    l_237 ^= (safe_div_func_uint32_t_u_u((safe_add_func_int64_t_s_s((l_227 < ((((safe_add_func_uint32_t_u_u((p_51 >= ((((p_51 | 0x3C069BDDL) > ((((safe_mod_func_uint64_t_u_u(0UL, l_227)) & 0L) < (safe_lshift_func_uint8_t_u_s((safe_mul_func_uint64_t_u_u(p_51, 0UL)), 6))) & p_51)) && 0x13FAL) == p_50)), p_50)) < 2L) < l_227) || l_236)), p_51)), p_51));
    return l_227;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_52(int64_t  p_53, uint32_t  p_54, uint8_t  p_55, int16_t  p_56)
{ /* block id: 110 */
    uint16_t l_202 = 65535UL;
    int64_t l_213 = 0xC25720279D622751LL;
    int32_t l_214 = 0x84E9DB0BL;
    struct S0 l_215 = {6958,492,93,3168,2,41,0x96L};
    int64_t l_222 = 0x6757B94B598FB196LL;
    l_214 = (safe_unary_minus_func_int8_t_s((safe_mod_func_int32_t_s_s((safe_mod_func_int32_t_s_s(((safe_rshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(((safe_div_func_int32_t_s_s((p_55 == (-4L)), 4L)) | l_202), l_202)), l_202)) == (safe_mod_func_uint8_t_u_u(((((((safe_lshift_func_int8_t_s_u((safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint8_t_u_u((p_53 == (safe_div_func_int64_t_s_s((__builtin_popcountl(p_56) | p_55), p_56))), p_54)), 5)), l_202)) || l_202) <= p_55) <= l_213) ^ p_56) <= p_56), l_214))), l_213)), p_55))));
    l_215 = l_215;
    l_215 = l_215;
    l_215.f3 = func_63((safe_sub_func_uint64_t_u_u((safe_lshift_func_uint16_t_u_s(__builtin_ctzl((safe_sub_func_int64_t_s_s(p_55, (-1L)))), 9)), (1L >= 0xAFFF13C767B02383LL))), l_215.f3, l_222);
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_61(int64_t  p_62)
{ /* block id: 87 */
    uint32_t l_157 = 0UL;
    struct S0 l_158 = {14275,11421,-300,4413,0,-37,0x7CL};
    uint8_t l_169 = 8UL;
    l_158.f5 = (p_62 && ((l_157 & (4294967294UL | func_72(l_158, l_158))) > func_97((0UL | ((1L >= ((0UL & p_62) >= 4294967292UL)) | 0x3FL)))));
    for (l_157 = 0; (l_157 > 13); l_157++)
    { /* block id: 91 */
        int32_t l_164 = 0x0FF38971L;
        struct S0 l_182 = {25158,10634,187,1129,2,7,1UL};
        for (p_62 = 1; (p_62 == (-20)); p_62 = safe_sub_func_uint16_t_u_u(p_62, 5))
        { /* block id: 94 */
            uint64_t l_163 = 18446744073709551608UL;
            l_158.f2 = l_163;
            l_164 |= p_62;
        }
        if (p_62)
            break;
        if (p_62)
        { /* block id: 99 */
            uint64_t l_170 = 4UL;
            struct S0 l_181 = {4133,6024,68,-4160,1,-18,0x97L};
            l_158.f5 = (p_62 ^ ((((safe_lshift_func_int8_t_s_s((safe_add_func_uint64_t_u_u(l_169, (func_63(l_158.f4, l_170, (safe_add_func_uint8_t_u_u(((safe_lshift_func_int16_t_s_s((__builtin_parityll(l_158.f1) & func_67(l_158.f5, ((safe_rshift_func_int8_t_s_s((safe_rshift_func_int16_t_s_u(p_62, 7)), 1)) <= (safe_sub_func_int8_t_s_s(((0x61C211F742CEBDE3LL || l_158.f1) != p_62), 0xA8L))), l_164, l_164)), l_169)) & l_170), l_164))) | p_62))), p_62)) >= p_62) < l_170) == l_164));
            l_158 = l_181;
        }
        else
        { /* block id: 102 */
            l_182 = l_158;
        }
        if (l_169)
            break;
    }
    l_158.f5 |= (l_157 < (safe_mod_func_uint16_t_u_u((safe_mod_func_uint64_t_u_u(1UL, __builtin_bswap64(p_62))), p_62)));
    l_158 = l_158;
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_63(int32_t  p_64, uint16_t  p_65, uint8_t  p_66)
{ /* block id: 84 */
    struct S0 l_156 = {22855,1754,338,-224,0,10,0xAAL};
    l_156 = l_156;
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_67(int8_t  p_68, int16_t  p_69, uint8_t  p_70, int32_t  p_71)
{ /* block id: 46 */
    uint32_t l_92 = 0x0ED6CA13L;
    int16_t l_99 = (-1L);
    uint32_t l_100 = 0x19D5C01CL;
    int32_t l_151 = 0xCABD61F3L;
    int32_t l_155 = 1L;
    l_151 = (safe_lshift_func_uint8_t_u_u(func_87((safe_unary_minus_func_uint64_t_u(p_71)), l_92, ((safe_rshift_func_int8_t_s_u(((safe_mod_func_int64_t_s_s(func_97((l_99 == l_100)), (safe_div_func_uint64_t_u_u((safe_sub_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((((safe_unary_minus_func_int64_t_s(((l_92 < 1L) == 7UL))) ^ 0L) > p_71), l_99)), l_100)), l_100)))) >= 0x799ADA34L), p_70)) || l_99)), l_100));
    for (l_151 = 3; (l_151 >= 15); l_151++)
    { /* block id: 79 */
        uint32_t l_154 = 0x20FE39EBL;
        if (l_154)
            break;
        l_155 = l_154;
    }
    return l_100;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_72(struct S0  p_73, struct S0  p_74)
{ /* block id: 42 */
    int32_t l_76 = 0xDFE98D7EL;
    l_76 = 0L;
    p_73.f2 &= p_74.f0;
    return l_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_87(uint64_t  p_88, uint8_t  p_89, int32_t  p_90)
{ /* block id: 73 */
    int16_t l_148 = 1L;
    uint32_t l_149 = 1UL;
    int32_t l_150 = 0x9F9EEF7BL;
    l_150 &= __builtin_bswap64((safe_lshift_func_int16_t_s_s(l_148, l_149)));
    return p_90;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_97(int32_t  p_98)
{ /* block id: 47 */
    uint32_t l_104 = 0x4358B9E0L;
    int32_t l_105 = 9L;
    int32_t l_119 = 0x99CB9CEBL;
    uint8_t l_127 = 0xF4L;
    int32_t l_130 = 3L;
    int32_t l_131 = 6L;
    uint8_t l_132 = 0xE7L;
    struct S0 l_138 = {2432,259,290,-3719,0,-14,2UL};
    if (p_98)
    { /* block id: 48 */
        int32_t l_101 = (-2L);
        l_105 = __builtin_parityl((__builtin_parityll(l_101) >= (safe_lshift_func_uint8_t_u_u(l_104, p_98))));
    }
    else
    { /* block id: 50 */
        int16_t l_110 = (-2L);
        struct S0 l_111 = {9936,1716,312,-838,2,-7,0x68L};
        if ((safe_add_func_uint32_t_u_u(p_98, (((0xA33FE8F1E0EF155DLL >= (p_98 >= ((safe_div_func_uint64_t_u_u(((l_110 < (func_72(l_111, l_111) < (((((safe_lshift_func_int16_t_s_s((safe_rshift_func_uint8_t_u_u(p_98, 2)), 0)) || __builtin_ctzll((((safe_add_func_uint8_t_u_u((l_111.f2 ^ l_105), l_105)) && p_98) ^ p_98))) != 0xF4L) != 0x3A129387L) >= p_98))) <= l_111.f4), 0x9FFB2EF76CAF4455LL)) ^ p_98))) || 4294967288UL) ^ 0xD6L))))
        { /* block id: 51 */
            int64_t l_118 = (-2L);
            int32_t l_120 = 6L;
            uint32_t l_121 = 5UL;
            ++l_121;
            if ((p_98 > p_98))
            { /* block id: 53 */
                l_120 = 0L;
                return p_98;
            }
            else
            { /* block id: 56 */
                l_120 |= (p_98 == p_98);
                for (l_118 = 0; (l_118 <= (-2)); l_118 = safe_sub_func_uint64_t_u_u(l_118, 5))
                { /* block id: 60 */
                    int8_t l_126 = 0x66L;
                    l_126 = p_98;
                }
                return l_127;
            }
        }
        else
        { /* block id: 65 */
            l_119 = (safe_lshift_func_uint16_t_u_s(5UL, 2));
        }
    }
    l_132--;
    l_119 &= (((__builtin_clz(((safe_div_func_uint32_t_u_u((__builtin_clz((~(func_72(l_138, l_138) >= (l_105 || __builtin_ctzl(l_138.f1))))) != __builtin_popcountll(p_98)), p_98)) <= 0xB1D7879CL)) >= 1L) & l_104) != 1L);
    l_138 = l_138;
    return l_138.f6;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 62
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 12
breakdown:
   indirect level: 0, occurrence: 12
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 10
XXX times a bitfields struct on RHS: 18
XXX times a single bitfield on LHS: 7
XXX times a single bitfield on RHS: 11

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 9
   depth: 3, occurrence: 1
   depth: 5, occurrence: 2
   depth: 9, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 41, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 188
XXX times a non-volatile is write: 40
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 60
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 9
   depth: 2, occurrence: 12
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 31.5
XXX percentage an existing variable is used: 68.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

