/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2720982410
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 19;
   unsigned f1 : 28;
   unsigned f2 : 14;
   unsigned f3 : 2;
   unsigned f4 : 9;
   unsigned f5 : 28;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_30(void);
static struct S0  func_31(int16_t  p_32, uint32_t  p_33, struct S0  p_34);
static uint16_t  func_37(int32_t  p_38, struct S0  p_39, const int32_t  p_40);
static struct S0  func_46(int32_t  p_47, int32_t * p_48);
static int32_t * func_49(int32_t * const  p_50, uint32_t  p_51, int32_t * p_52, int32_t * p_53, int32_t * p_54);
static int32_t * const  func_55(int32_t * p_56, int16_t  p_57);
static uint16_t  func_67(int32_t * const  p_68, struct S0 * p_69, int32_t * p_70);
static int32_t * func_71(struct S0  p_72);
static struct S0  func_73(int16_t  p_74, struct S0 * p_75, int32_t * p_76, struct S0 * p_77);
static struct S0 * func_80(int32_t * p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_30(void)
{ /* block id: 36 */
    int16_t l_42 = 6L;
    struct S0 l_43 = {655,619,1,1,17,8804};
    struct S0 l_335 = {453,11997,73,1,8,14556};
    struct S0 *l_334 = &l_335;
    struct S0 l_338 = {602,2437,68,0,16,5954};
    (*l_334) = func_31((safe_rshift_func_int16_t_s_u(0x8A60L, func_37((+l_42), l_43, l_43.f5))), l_43.f1, ((*l_334) = l_43));
    (*l_334) = l_338;
    return l_43.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_31(int16_t  p_32, uint32_t  p_33, struct S0  p_34)
{ /* block id: 225 */
    struct S0 l_336 = {507,6305,39,0,12,1687};
    struct S0 *l_337 = &l_336;
    (*l_337) = l_336;
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_37(int32_t  p_38, struct S0  p_39, const int32_t  p_40)
{ /* block id: 37 */
    int32_t l_45 = 0xE45DB0FFL;
    int32_t *l_44 = &l_45;
    int32_t l_215 = 0L;
    uint32_t l_217 = 4294967290UL;
    uint32_t *l_216 = &l_217;
    struct S0 l_236 = {-153,15947,17,0,4,7701};
    struct S0 *l_235 = &l_236;
    int32_t **l_238 = &l_44;
    int32_t ***l_237 = &l_238;
    uint32_t l_289 = 0x6B89E338L;
    int16_t l_330 = 0xDE9AL;
    int16_t * const l_329 = &l_330;
    int16_t * const *l_328 = &l_329;
    int16_t * const **l_327 = &l_328;
    (*l_44) = p_39.f2;
    (*l_235) = func_46(p_39.f3, func_49(func_55(&l_45, (*l_44)), ((*l_216) = (p_39.f0 && (p_39.f1 | l_215))), l_216, l_44, l_44));
    if (((&l_44 != ((*l_237) = &l_44)) & (p_39.f0 | 0x54FCL)))
    { /* block id: 147 */
        int32_t l_256 = 0x6AE91A37L;
        for (l_45 = 0; (l_45 == (-30)); l_45 = safe_sub_func_int16_t_s_s(l_45, 1))
        { /* block id: 150 */
            int32_t l_245 = 0xCDD2221DL;
            int32_t *l_246 = (void*)0;
            int32_t l_248 = 0xDCB3132CL;
            int32_t *l_247 = &l_248;
            if ((p_39.f5 && (p_39.f4 = (1L ^ 1L))))
            { /* block id: 152 */
                int32_t l_242 = 1L;
                int32_t *l_241 = &l_242;
                (*l_241) = (((*l_216) = p_39.f3) != p_38);
            }
            else
            { /* block id: 155 */
                return p_39.f3;
            }
            p_39.f0 = (safe_rshift_func_uint16_t_u_u((l_245 && 65535UL), 4));
            (*l_247) = 0x4E466CC9L;
            for (l_217 = 17; (l_217 <= 15); l_217 = safe_sub_func_int16_t_s_s(l_217, 1))
            { /* block id: 162 */
                struct S0 l_255 = {-525,4135,11,1,15,5259};
                int32_t * const l_257 = &l_45;
                int32_t *l_258 = &l_45;
                int32_t **l_259 = &l_247;
            }
        }
    }
    else
    { /* block id: 179 */
        struct S0 l_260 = {274,661,120,0,3,8101};
        int32_t **l_261 = &l_44;
        int32_t l_322 = (-7L);
        int16_t *l_333 = (void*)0;
        int16_t **l_332 = &l_333;
        int16_t ***l_331 = &l_332;
        l_260 = (*l_235);
        (*l_261) = &p_40;
        /* statement id: 181 */
        assert (l_44 == &p_40);
        for (l_217 = 0; (l_217 > 48); l_217 = safe_add_func_int32_t_s_s(l_217, 3))
        { /* block id: 184 */
            uint16_t l_267 = 0x7621L;
            uint16_t *l_266 = &l_267;
            int32_t *** const l_268 = &l_238;
            int32_t l_318 = 1L;
        }
        p_39.f0 = ((safe_rshift_func_int16_t_s_u((l_327 == l_331), 7)) == 0xC1ADL);
    }
    /* facts after branching */
    assert (l_44 == &p_40 || l_44 == &l_45);
    (*l_238) = (**l_237);
    return p_39.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_46(int32_t  p_47, int32_t * p_48)
{ /* block id: 142 */
    int32_t l_232 = 0xF8ABBA1DL;
    int32_t *l_231 = &l_232;
    int32_t **l_233 = (void*)0;
    struct S0 l_234 = {-526,8683,118,1,5,7859};
    l_231 = l_231;
    return l_234;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_49(int32_t * const  p_50, uint32_t  p_51, int32_t * p_52, int32_t * p_53, int32_t * p_54)
{ /* block id: 134 */
    uint32_t l_218 = 4294967295UL;
    int32_t l_229 = 3L;
    int32_t *l_228 = &l_229;
    if (l_218)
    { /* block id: 135 */
        int16_t l_223 = 0L;
        uint16_t l_225 = 65527UL;
        uint16_t *l_224 = &l_225;
        (*p_53) = (safe_lshift_func_uint16_t_u_s((safe_lshift_func_uint16_t_u_u(l_223, ((*l_224) = 0xD8F5L))), (((l_218 == p_51) ^ (((l_218 <= 1UL) ^ (1L | p_51)) == __builtin_ctzl(l_218))) | (-1L))));
    }
    else
    { /* block id: 138 */
        int32_t l_227 = (-5L);
        int32_t *l_226 = &l_227;
        int32_t *l_230 = &l_227;
        return p_52;
        /* statement id: 139 */
        //assert (func_49_rv == &l_217);
    }
    return p_53;
    /* statement id: 141 */
    //assert (func_49_rv == &l_45);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_55(int32_t * p_56, int16_t  p_57)
{ /* block id: 39 */
    struct S0 l_58 = {466,4101,2,1,14,15369};
    struct S0 *l_59 = (void*)0;
    struct S0 *l_60 = (void*)0;
    struct S0 *l_61 = &l_58;
    struct S0 l_62 = {-322,12638,122,1,9,9959};
    int32_t * const l_214 = (void*)0;
    l_62 = ((*l_61) = l_58);
    for (p_57 = (-15); (p_57 < (-25)); p_57 = safe_sub_func_uint16_t_u_u(p_57, 3))
    { /* block id: 44 */
        int16_t l_79 = (-1L);
        int16_t *l_78 = &l_79;
        struct S0 *l_89 = (void*)0;
        int32_t l_208 = (-1L);
        const int32_t *l_207 = &l_208;
        if (((*p_56) = (safe_add_func_uint16_t_u_u(func_67(func_71(func_73(((*l_78) = l_62.f2), func_80(p_56), p_56, l_89)), &l_62, p_56), p_57))))
        { /* block id: 121 */
            for (l_79 = (-7); (l_79 == 0); l_79 = safe_add_func_uint16_t_u_u(l_79, 4))
            { /* block id: 124 */
                int32_t **l_209 = (void*)0;
                int32_t *l_211 = &l_208;
                int32_t **l_210 = &l_211;
                (*l_210) = l_207;
            }
        }
        else
        { /* block id: 127 */
            int32_t *l_212 = (void*)0;
            int32_t **l_213 = &l_212;
            (*l_213) = l_212;
        }
    }
    (*l_61) = (*l_61);
    return l_214;
    /* statement id: 132 */
    //assert (func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_45
 * writes: l_45
 */
static uint16_t  func_67(int32_t * const  p_68, struct S0 * p_69, int32_t * p_70)
{ /* block id: 87 */
    uint8_t l_147 = 0x10L;
    struct S0 l_149 = {390,11988,28,1,16,7075};
    int32_t *l_155 = (void*)0;
    struct S0 *l_176 = &l_149;
    int16_t **l_184 = (void*)0;
    int16_t l_204 = 0xF2B2L;
    if ((safe_add_func_uint16_t_u_u(((*p_70) == (*p_70)), ((safe_unary_minus_func_uint16_t_u(l_147)) <= (0xA99CDC6EL == (safe_unary_minus_func_uint32_t_u(l_147)))))))
    { /* block id: 88 */
        struct S0 *l_150 = (void*)0;
        int32_t l_153 = 0x7796E21EL;
        int32_t *l_152 = &l_153;
        int32_t **l_151 = &l_152;
        (*p_70) = (*p_70);
        (*p_69) = l_149;
        (*l_151) = func_71(func_73(l_149.f3, l_150, p_70, l_150));
        /* statement id: 91 */
        assert (l_152 == 0);
    }
    else
    { /* block id: 92 */
        struct S0 l_154 = {520,56,86,1,18,2513};
        int32_t l_198 = 0x148879A0L;
        int32_t *l_197 = &l_198;
        (*p_69) = l_154;
        p_70 = func_71(l_154);
        /* statement id: 94 */
        assert (p_70 == 0);
        for (l_147 = (-2); (l_147 < 47); l_147 = safe_add_func_int32_t_s_s(l_147, 1))
        { /* block id: 97 */
            int16_t l_164 = (-9L);
            uint32_t l_165 = 0xB1AF397CL;
            int32_t *l_166 = (void*)0;
            int32_t *l_167 = (void*)0;
            int32_t l_169 = (-3L);
            int32_t *l_168 = &l_169;
            int16_t l_181 = 0xCBC4L;
            int16_t *l_180 = &l_181;
            uint16_t l_183 = 65535UL;
            uint16_t *l_182 = &l_183;
            int16_t **l_185 = &l_180;
            if ((safe_sub_func_int32_t_s_s((((safe_mod_func_int32_t_s_s(l_164, ((*l_168) = l_165))) <= ((safe_lshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(0x833BL, 15)), (safe_rshift_func_int16_t_s_s((((&l_149 == (l_176 = (void*)0)) || (l_149.f4 > ((*l_182) = ((!(safe_lshift_func_int16_t_s_s(((*l_180) = l_154.f3), (l_154.f4 & l_154.f4)))) != 0x2E04F2ECL)))) > l_149.f5), 6)))) == l_154.f3)) >= l_154.f3), l_149.f1)))
            { /* block id: 102 */
                uint32_t l_191 = 0xECD82EB3L;
                uint32_t *l_190 = &l_191;
                int32_t l_192 = 0xCE8C50E4L;
                uint32_t l_195 = 18446744073709551609UL;
                struct S0 l_202 = {605,4088,88,0,0,798};
                l_185 = l_184;
                /* statement id: 103 */
                assert (l_185 == 0);
                if (((((safe_lshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((void*)0 == &p_70), 10)), l_154.f3)) != ((*l_190) = (*l_168))) != l_192) && ((*l_168) = (((*l_190) = l_192) < (safe_mod_func_uint16_t_u_u(l_195, l_154.f4))))))
                { /* block id: 107 */
                    return l_192;
                }
                else
                { /* block id: 109 */
                    uint8_t l_196 = 1UL;
                    struct S0 *l_199 = (void*)0;
                    struct S0 **l_200 = (void*)0;
                    struct S0 **l_201 = &l_199;
                    l_202 = l_202;
                }
            }
            else
            { /* block id: 114 */
                int32_t l_203 = 1L;
                return l_203;
            }
            /* facts after branching */
            assert (l_176 == 0);
            assert (l_185 == 0);
        }
        /* facts after for loop */
        assert (l_176 == 0 || l_176 == &l_149);
    }
    /* facts after branching */
    //assert (p_70 == 0 || p_70 == &l_45);
    assert (l_176 == 0 || l_176 == &l_149);
    return l_204;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_71(struct S0  p_72)
{ /* block id: 56 */
    int16_t l_104 = 0x7FFAL;
    uint32_t l_110 = 0x5470A06CL;
    uint32_t *l_109 = &l_110;
    struct S0 l_118 = {171,5278,21,1,7,9746};
    struct S0 *l_117 = &l_118;
    int32_t *l_119 = (void*)0;
    int32_t l_121 = 0x361DE361L;
    int32_t *l_120 = &l_121;
    int32_t l_122 = 0x0432F2B5L;
    int32_t l_124 = 0L;
    int32_t *l_123 = &l_124;
    uint32_t l_125 = 4294967292UL;
    int32_t **l_126 = &l_120;
    int32_t *l_140 = &l_124;
    int32_t *l_141 = &l_121;
    int32_t *l_142 = &l_121;
    int32_t *l_143 = (void*)0;
    (*l_117) = func_73((((*l_123) = (safe_mod_func_uint16_t_u_u(__builtin_clz(l_104), (((safe_add_func_int32_t_s_s(((((((*l_120) = (p_72.f2 < (safe_lshift_func_uint16_t_u_u((l_118.f0 = ((((((*l_109) = (p_72.f2 & p_72.f1)) <= l_104) ^ (~p_72.f4)) && p_72.f0) || ((!(safe_lshift_func_uint16_t_u_s((safe_rshift_func_int16_t_s_s((l_117 == &l_118), 11)), 11))) ^ l_104))), p_72.f0)))) | l_122) <= p_72.f3) | 0xAF60L) & p_72.f2), 2L)) | p_72.f1) || 6L)))) < l_125), l_117, l_123, l_117);
    (*l_126) = &l_121;
lbl_139:
    for (l_124 = 0; (l_124 >= 29); l_124 = safe_add_func_uint32_t_u_u(l_124, 1))
    { /* block id: 65 */
        struct S0 l_131 = {-264,8238,99,1,20,13500};
        int32_t * const l_136 = (void*)0;
        const int32_t *l_138 = (void*)0;
        const int32_t **l_137 = &l_138;
        if (p_72.f3)
        { /* block id: 66 */
            uint32_t *l_133 = (void*)0;
            for (l_110 = 0; (l_110 < 45); l_110 = safe_add_func_uint32_t_u_u(l_110, 1))
            { /* block id: 69 */
                uint32_t *l_132 = &l_125;
                l_131 = l_131;
                p_72.f0 = ((l_133 = l_132) != l_132);
                /* statement id: 72 */
                assert (l_133 == &l_125);
            }
            /* facts after for loop */
            assert (l_133 == &l_125 || l_133 == 0);
            if (l_125)
                goto lbl_139;
        }
        else
        { /* block id: 74 */
            for (l_104 = 0; (l_104 <= 12); l_104 = safe_add_func_int32_t_s_s(l_104, 1))
            { /* block id: 77 */
                (*l_117) = (*l_117);
            }
        }
        (*l_137) = l_136;
        (*l_117) = l_131;
    }
    (*l_120) = p_72.f5;
    return l_143;
    /* statement id: 86 */
    //assert (func_71_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_45
 */
static struct S0  func_73(int16_t  p_74, struct S0 * p_75, int32_t * p_76, struct S0 * p_77)
{ /* block id: 49 */
    struct S0 l_90 = {-55,15326,57,1,8,6092};
    struct S0 *l_91 = &l_90;
    struct S0 l_93 = {567,16165,98,1,11,4475};
    struct S0 *l_92 = &l_93;
    int16_t l_97 = (-1L);
    int16_t *l_96 = &l_97;
    int16_t **l_95 = &l_96;
    const int16_t *l_100 = &l_97;
    const int16_t **l_99 = &l_100;
    const int16_t ***l_98 = &l_99;
    struct S0 l_101 = {-345,11091,117,0,15,14935};
    (*l_92) = ((*l_91) = l_90);
    (*p_76) = l_90.f1;
    (*p_76) = (!(-10L));
    (*l_98) = l_95;
    /* statement id: 54 */
    assert (l_99 == &l_96);
    return l_101;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_80(int32_t * p_81)
{ /* block id: 46 */
    struct S0 l_82 = {-459,6455,124,0,19,807};
    struct S0 *l_83 = &l_82;
    struct S0 *l_84 = &l_82;
    struct S0 *l_85 = &l_82;
    struct S0 *l_86 = &l_82;
    struct S0 *l_87 = &l_82;
    struct S0 *l_88 = (void*)0;
    (*l_83) = l_82;
    return l_88;
    /* statement id: 48 */
    //assert (func_80_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 71
   depth: 1, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 26
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 11
XXX full-bitfields structs in the program: 15
breakdown:
   indirect level: 0, occurrence: 15
XXX times a bitfields struct's address is taken: 25
XXX times a bitfields struct on LHS: 7
XXX times a bitfields struct on RHS: 34
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 51

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 20, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 112

XXX times a variable address is taken: 91
XXX times a pointer is dereferenced on RHS: 32
breakdown:
   depth: 1, occurrence: 18
   depth: 2, occurrence: 9
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 64
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 362

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 133
   level: 2, occurrence: 24
   level: 3, occurrence: 19
XXX number of pointers point to pointers: 24
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 24
XXX percent of pointers has null in alias set: 33.9
XXX average alias set size: 1.16

XXX times a non-volatile is read: 300
XXX times a non-volatile is write: 163
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 70
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 17
   depth: 2, occurrence: 10
   depth: 3, occurrence: 9
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 14.8
XXX percentage an existing variable is used: 85.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

