/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2306134450
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_28(void);
static uint32_t  func_34(uint16_t  p_35, uint32_t  p_36);
static uint64_t  func_39(int32_t  p_40, uint64_t  p_41);
static int32_t * func_44(uint32_t  p_45, int16_t  p_46);
static int32_t * func_48(uint64_t  p_49, uint64_t  p_50, int16_t  p_51, int32_t * p_52, int32_t  p_53);
static uint64_t  func_54(uint64_t  p_55, int32_t * p_56, uint32_t  p_57, uint64_t  p_58);
static uint64_t  func_61(uint32_t  p_62);
static int32_t * const  func_65(uint32_t  p_66, int32_t  p_67, int64_t  p_68, int16_t  p_69, int32_t ** p_70);
static uint32_t  func_73(uint64_t  p_74);
static int32_t * func_81(int32_t * p_82, uint64_t  p_83, int32_t ** p_84, int32_t  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_28(void)
{ /* block id: 36 */
    int32_t l_30 = 0L;
    int32_t *l_29 = &l_30;
    int32_t **l_31 = &l_29;
    int64_t l_431 = (-9L);
    (*l_31) = l_29;
    (*l_29) = (((safe_mod_func_uint32_t_u_u(func_34((*l_29), (safe_sub_func_uint64_t_u_u(func_39(((((void*)0 != &l_29) < ((*l_31) == (*l_31))) <= (-3L)), (*l_29)), 4UL))), (**l_31))) > (**l_31)) || (*l_29));
    (**l_31) = (*l_29);
    return l_431;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_34(uint16_t  p_35, uint32_t  p_36)
{ /* block id: 303 */
    int64_t l_428 = 0x72D43E78350BCA18LL;
    int32_t l_430 = 0xC2EC3A34L;
    int32_t *l_429 = &l_430;
    (*l_429) = l_428;
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_39(int32_t  p_40, uint64_t  p_41)
{ /* block id: 38 */
    uint64_t l_380 = 0x7314760B1892D0D0LL;
    int32_t l_410 = (-6L);
    int32_t *l_409 = &l_410;
    int32_t ** const l_408 = &l_409;
    int32_t ** const *l_407 = &l_408;
    int32_t ** const **l_406 = &l_407;
    int32_t ** const ***l_405 = &l_406;
    const int32_t *l_421 = &l_410;
    const int32_t * const l_426 = &l_410;
    for (p_40 = 0; (p_40 < 26); p_40 = safe_add_func_int32_t_s_s(p_40, 7))
    { /* block id: 41 */
        uint64_t l_47 = 0xE85FCB4448110CBBLL;
        const int32_t l_379 = (-9L);
        const int32_t *l_378 = &l_379;
        const int32_t **l_377 = &l_378;
        int32_t l_384 = 1L;
        int32_t *l_383 = &l_384;
        (*l_377) = func_44(l_47, p_40);
        /* statement id: 284 */
        assert (l_378 == 0);
        (*l_377) = func_48((&p_40 == (void*)0), (l_380 > 0x7AFF41B1098895E4LL), (safe_rshift_func_uint16_t_u_s(__builtin_clzl(p_40), 12)), l_383, (l_380 & (safe_mod_func_int16_t_s_s(l_380, 1L))));
        /* statement id: 285 */
        assert (l_378 == &l_384);
        (*l_383) = ((safe_sub_func_uint32_t_u_u(p_41, __builtin_popcount((*l_383)))) != p_41);
    }
    if ((l_380 & (((-6L) == (0L < ((((-2L) > (safe_sub_func_uint16_t_u_u(__builtin_clzl(p_40), (safe_lshift_func_uint16_t_u_u(p_40, 8))))) || p_41) || (safe_add_func_uint16_t_u_u((((safe_sub_func_int64_t_s_s(1L, 7L)) != l_380) < l_380), p_40))))) || l_380)))
    { /* block id: 288 */
        int32_t l_401 = 0xABD2FAB7L;
        int32_t *l_400 = &l_401;
        int32_t *l_411 = (void*)0;
        (*l_400) = (safe_rshift_func_uint16_t_u_s((!(p_40 | __builtin_ctzl(l_380))), p_40));
        (*l_400) = p_41;
        (**l_408) = (p_41 > (!(safe_lshift_func_int16_t_s_s((l_405 != &l_406), 0))));
        (***l_406) = func_81((**l_407), ((&l_401 == l_411) ^ ((safe_lshift_func_uint16_t_u_u((safe_mod_func_uint64_t_u_u((((safe_rshift_func_int16_t_s_s((func_73(p_40) || (safe_sub_func_uint16_t_u_u(((~p_41) <= ((*****l_405) >= (**l_408))), p_40))), (*l_400))) <= p_41) < p_41), p_40)), 13)) != 18446744073709551608UL)), &l_409, p_40);
        /* statement id: 292 */
        assert (l_409 == 0);
    }
    else
    { /* block id: 293 */
        const int32_t *l_422 = &l_410;
        int32_t **l_427 = &l_409;
        l_422 = l_421;
        for (p_40 = 13; (p_40 > 8); p_40 = safe_sub_func_uint16_t_u_u(p_40, 5))
        { /* block id: 297 */
            uint32_t l_425 = 0x82B68CC4L;
            return l_425;
        }
        (*l_427) = l_426;
    }
    /* facts after branching */
    assert (l_409 == &l_410 || l_409 == 0);
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_44(uint32_t  p_45, int16_t  p_46)
{ /* block id: 42 */
    int32_t l_60 = 9L;
    int32_t *l_59 = &l_60;
    int32_t *l_64 = (void*)0;
    int32_t l_374 = 0x7865A1F3L;
    int32_t **l_375 = &l_64;
    int32_t *l_376 = (void*)0;
    (*l_375) = func_48(func_54(p_46, l_59, p_46, ((func_61((((!(&l_59 != (void*)0)) ^ __builtin_ia32_crc32qi((*l_59), (*l_59))) && (l_64 != (void*)0))) == p_45) || (*l_59))), p_46, p_45, l_59, l_374);
    /* statement id: 281 */
    assert (l_64 == &l_60);
    (*l_375) = (*l_375);
    return l_376;
    /* statement id: 283 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_48(uint64_t  p_49, uint64_t  p_50, int16_t  p_51, int32_t * p_52, int32_t  p_53)
{ /* block id: 279 */
    return p_52;
    /* statement id: 280 */
    //assert (func_48_rv == &l_60 || func_48_rv == &l_384);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_54(uint64_t  p_55, int32_t * p_56, uint32_t  p_57, uint64_t  p_58)
{ /* block id: 61 */
    int64_t l_125 = 0x03F479F84CD17FF1LL;
    int32_t l_155 = 0x81ACCAB4L;
    int32_t *l_154 = &l_155;
    int32_t **l_153 = &l_154;
    int32_t * const ****l_206 = (void*)0;
    int32_t *** const l_216 = &l_153;
    int32_t *** const *l_215 = &l_216;
    int32_t **l_232 = &l_154;
    int32_t **l_316 = (void*)0;
    int32_t ***l_333 = &l_316;
    int32_t ****l_332 = &l_333;
    int32_t *****l_331 = &l_332;
    uint32_t l_372 = 4294967295UL;
    int16_t l_373 = (-5L);
    for (p_58 = 25; (p_58 > 14); --p_58)
    { /* block id: 64 */
        uint32_t l_122 = 0x06D4EB3EL;
        int32_t *l_159 = (void*)0;
        int32_t *l_167 = (void*)0;
        for (p_57 = 0; (p_57 >= 32); p_57++)
        { /* block id: 67 */
            int32_t l_126 = 0x366C4368L;
            int32_t l_151 = 0x63F81597L;
            int32_t *l_150 = &l_151;
        }
        (**l_153) = (((p_58 || (+((((safe_lshift_func_uint16_t_u_u(p_55, 3)) != ((((18446744073709551615UL <= 1L) && ((safe_rshift_func_uint16_t_u_s(((safe_sub_func_uint16_t_u_u((((void*)0 != p_56) != (*p_56)), (((l_167 == l_167) || (*l_154)) < p_57))) == p_58), p_58)) | p_58)) | (**l_153)) || p_57)) <= (*l_154)) != 6UL))) <= (**l_153)) && (**l_153));
        if ((*p_56))
            continue;
    }
    (*p_56) = (*p_56);
    for (p_58 = 0; (p_58 > 60); p_58 = safe_add_func_uint64_t_u_u(p_58, 2))
    { /* block id: 106 */
        int32_t *l_170 = &l_155;
        int32_t ** const l_178 = (void*)0;
        int32_t ***l_256 = &l_232;
        int32_t ****l_255 = &l_256;
        int32_t *l_282 = &l_155;
        (*l_170) = (p_55 <= (l_170 != (*l_153)));
    }
    for (p_55 = 0; (p_55 == 40); p_55 = safe_add_func_int16_t_s_s(p_55, 3))
    { /* block id: 246 */
        int32_t ***l_330 = &l_232;
        int32_t ****l_329 = &l_330;
        int32_t ***** const l_328 = &l_329;
        const uint16_t l_348 = 0x446BL;
        if ((1L <= 0xF58D22E0L))
        { /* block id: 247 */
            uint32_t l_345 = 0UL;
            l_331 = l_328;
            /* statement id: 248 */
            assert (l_331 == &l_329);
            for (p_57 = 0; (p_57 <= 53); p_57++)
            { /* block id: 251 */
                const int32_t ***l_338 = (void*)0;
                const int32_t ****l_337 = &l_338;
                const int32_t *****l_336 = &l_337;
            }
        }
        else
        { /* block id: 270 */
            int32_t l_367 = 2L;
            (****l_329) = l_367;
            return l_367;
        }
        /* facts after branching */
        assert (l_331 == &l_329);
        (**l_232) = ((**l_153) || (safe_add_func_uint16_t_u_u(((****l_328) != (void*)0), func_61((safe_rshift_func_int16_t_s_u((func_73((func_61((p_58 & ((void*)0 != (*l_328)))) & (0xE859488B623E1638LL ^ p_57))) <= p_58), l_372))))));
        (*l_328) = (*l_331);
        (****l_329) = (*****l_328);
    }
    /* facts after for loop */
    //assert (l_331 == dangling || l_331 == &l_332);
    return l_373;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_61(uint32_t  p_62)
{ /* block id: 43 */
    int32_t l_75 = 0x158E9D28L;
    int32_t l_108 = 0x742D117BL;
    const int32_t *l_107 = &l_108;
    const int32_t **l_106 = &l_107;
    int32_t *l_110 = (void*)0;
    int32_t **l_109 = &l_110;
    int32_t *l_115 = &l_108;
    (*l_109) = func_65((safe_mod_func_uint64_t_u_u((0x0AACC702L > func_73(l_75)), (-1L))), p_62, p_62, (((~l_75) ^ (l_106 == &l_107)) & (**l_106)), l_109);
    (*l_115) = ((**l_106) & (safe_rshift_func_int16_t_s_s((**l_106), 2)));
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_65(uint32_t  p_66, int32_t  p_67, int64_t  p_68, int16_t  p_69, int32_t ** p_70)
{ /* block id: 55 */
    int32_t l_112 = 0xF1EAAC29L;
    int32_t *l_111 = &l_112;
    l_111 = l_111;
    return (*p_70);
    /* statement id: 57 */
    //assert (func_65_rv == 0 || func_65_rv == &l_155 || func_65_rv == &l_60);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_73(uint64_t  p_74)
{ /* block id: 44 */
    int64_t l_76 = (-10L);
    int32_t l_78 = 0x954656E2L;
    int32_t *l_77 = &l_78;
    const int32_t *l_80 = &l_78;
    const int32_t **l_79 = &l_80;
    int64_t l_103 = 0L;
    int64_t l_104 = 6L;
    (*l_77) = l_76;
    if (l_76)
        goto lbl_94;
    (*l_79) = &l_78;
lbl_94:
    (*l_79) = func_81(&l_78, (*l_77), &l_77, (**l_79));
    /* statement id: 51 */
    //assert (l_77 == dangling);
    assert (l_80 == 0);
    l_78 = (p_74 >= (((p_74 < ((safe_mod_func_int64_t_s_s(p_74, (p_74 && ((p_74 & (safe_mod_func_uint16_t_u_u((safe_add_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_u(p_74, 11)) && 7UL), ((l_103 != 0UL) ^ p_74))), 0x3967L))) >= p_74)))) | l_104)) & p_74) && p_74));
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_60
 */
static int32_t * func_81(int32_t * p_82, uint64_t  p_83, int32_t ** p_84, int32_t  p_85)
{ /* block id: 47 */
    uint32_t l_86 = 18446744073709551608UL;
    int32_t l_88 = 0x32BC12A5L;
    int32_t *l_87 = &l_88;
    int32_t *l_89 = &l_88;
    int32_t *l_90 = &l_88;
    int32_t *l_91 = &l_88;
    int32_t *l_92 = &l_88;
    int32_t *l_93 = (void*)0;
    (*p_82) = l_86;
    (*p_84) = l_87;
    /* statement id: 49 */
    //assert (l_77 == &l_88);
    return l_93;
    /* statement id: 50 */
    //assert (l_77 == dangling);
    //assert (func_81_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 100
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 8
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1

XXX total number of pointers: 109

XXX times a variable address is taken: 109
XXX times a pointer is dereferenced on RHS: 106
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 24
   depth: 3, occurrence: 9
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 96
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 16
   depth: 3, occurrence: 8
   depth: 4, occurrence: 6
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 447

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 174
   level: 2, occurrence: 53
   level: 3, occurrence: 29
   level: 4, occurrence: 20
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.8
XXX average alias set size: 1.25

XXX times a non-volatile is read: 618
XXX times a non-volatile is write: 266
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 55
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 18
   depth: 2, occurrence: 5

XXX percentage a fresh-made variable is used: 14.3
XXX percentage an existing variable is used: 85.7
********************* end of statistics **********************/

