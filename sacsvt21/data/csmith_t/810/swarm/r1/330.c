/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2242832176
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   uint64_t  f1;
   uint32_t  f2;
   uint32_t  f3;
   int64_t  f4;
   const int16_t  f5;
   int64_t  f6;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const uint16_t  func_29(void);
static int32_t * func_30(uint32_t  p_31, const int32_t * p_32, int32_t * p_33, const int32_t * p_34);
static int32_t * func_36(const int32_t  p_37, int32_t * p_38);
static const uint16_t  func_41(float  p_42, int32_t * p_43, int32_t * p_44);
static int32_t * func_45(const int32_t * p_46, int32_t * p_47, const int32_t * p_48);
static int32_t * func_62(int32_t * const  p_63, int32_t * p_64);
static int32_t * func_65(int32_t  p_66, struct S0  p_67);
static struct S0  func_68(uint16_t  p_69, uint32_t  p_70, int32_t * p_71, struct S0  p_72, const uint32_t  p_73);
static uint16_t  func_76(int32_t  p_77, int32_t * p_78, int32_t * p_79);
static int32_t * func_80(float  p_81, const int32_t * p_82, struct S0  p_83, int32_t  p_84, int32_t * p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_35 = 0xB58331C5L;
    int32_t l_40 = 1L;
    int32_t *l_39 = &l_40;
    int32_t **l_535 = &l_39;
    struct S0 *l_558 = (void*)0;
    struct S0 **l_557 = &l_558;
    struct S0 ***l_556 = &l_557;
    const uint16_t l_574 = 65535UL;
    float *l_579 = (void*)0;
    float **l_578 = &l_579;
    float ***l_577 = &l_578;
    float *l_581 = (void*)0;
    float l_583 = 0x0.8p+1;
    float *l_582 = &l_583;
    const float l_584 = (-0x6.Cp-1);
    const int32_t l_585 = 0xF02715E0L;
    (*l_535) = func_30(l_35, func_36(((l_39 == (void*)0) >= func_41((*l_39), func_45((((*l_39) < ((~((*l_39) > (*l_39))) <= (safe_sub_func_uint64_t_u_u((((((*l_39) , ((*l_39) , (*l_39))) < (*l_39)) < (*l_39)) > 1UL), 0UL)))) , &l_40), &l_40, &l_40), &l_40)), &l_40), &l_40, &l_40);
    for (l_35 = 10; (l_35 != 10); l_35 = safe_add_func_uint64_t_u_u(l_35, 9))
    { /* block id: 323 */
        uint32_t l_550 = 4294967295UL;
        struct S0 l_560 = {0L,0xFA146107DB0D4896LL,4294967290UL,0xE7A89DF4L,0x1FA80B8F6F7FDB96LL,1L,-1L};
        int32_t *l_564 = &l_40;
        for (l_40 = (-14); (l_40 > (-5)); l_40 = safe_add_func_int64_t_s_s(l_40, 5))
        { /* block id: 326 */
            int32_t l_540 = 1L;
            struct S0 ***l_559 = &l_557;
            for (l_540 = 10; (l_540 != 28); ++l_540)
            { /* block id: 329 */
                int32_t *l_543 = &l_40;
                struct S0 l_565 = {3L,0xBB54BD615530713DLL,2UL,0x5A9FEDD1L,-1L,1L,0x05BDD70CE76D961DLL};
                float l_567 = 0xF.A9B5E3p-62;
                float *l_566 = &l_567;
                int32_t l_569 = 0xCF8AA51BL;
                int32_t *l_568 = &l_569;
                (*l_535) = l_543;
                (*l_566) = ((safe_mod_func_int32_t_s_s((((*l_543) || (safe_mod_func_uint16_t_u_u(((*l_543) == (l_550 <= ((!(safe_lshift_func_uint16_t_u_s((l_550 < (safe_sub_func_int16_t_s_s((((l_556 == l_559) , l_560) , (((safe_lshift_func_int16_t_s_u((~((0x8D09BE0D3AE8310ELL ^ (func_68((**l_535), (*l_543), l_564, l_565, (*l_543)) , (*l_543))) , (*l_564))), 5)) && (**l_535)) && 0x1EFDL)), (*l_564)))), (*l_543)))) <= (**l_535)))), l_540))) == 0x54F8L), (*l_39))) , l_540);
                (*l_568) = ((*l_564) <= (*l_564));
            }
            for (l_560.f6 = 1; (l_560.f6 >= 14); l_560.f6 = safe_add_func_int64_t_s_s(l_560.f6, 1))
            { /* block id: 336 */
                for (l_560.f2 = 0; (l_560.f2 >= 49); ++l_560.f2)
                { /* block id: 339 */
                    return l_574;
                }
                for (l_560.f1 = 0; (l_560.f1 > 59); l_560.f1++)
                { /* block id: 344 */
                    float ****l_580 = &l_577;
                    (*l_580) = l_577;
                }
            }
            if (l_540)
                continue;
        }
    }
    (*l_582) = (-0x4.Ep+1);
    return l_585;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(uint32_t  p_31, const int32_t * p_32, int32_t * p_33, const int32_t * p_34)
{ /* block id: 317 */
    struct S0 l_529 = {0x4613L,1UL,4294967295UL,0x18DC6315L,0xFA732BECF8EA8647LL,0x1757L,0x944300DDB63E37F8LL};
    float l_534 = (-0x6.Ap-1);
    float *l_533 = &l_534;
    float **l_532 = &l_533;
    float ***l_531 = &l_532;
    float ****l_530 = &l_531;
    (***l_531) = (l_529 , (l_530 != &l_531));
    return p_33;
    /* statement id: 319 */
    //assert (func_30_rv == &l_40);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(const int32_t  p_37, int32_t * p_38)
{ /* block id: 314 */
    uint32_t l_524 = 0x03E5DB0AL;
    float l_526 = 0x0.3p-1;
    float *l_525 = &l_526;
    int32_t l_528 = 1L;
    int32_t *l_527 = &l_528;
    (*l_525) = l_524;
    return p_38;
    /* statement id: 316 */
    //assert (func_36_rv == &l_40);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_41(float  p_42, int32_t * p_43, int32_t * p_44)
{ /* block id: 303 */
    int32_t l_508 = 0xC3D62FD9L;
    struct S0 l_518 = {-1L,0x286D6DA56A923163LL,0x0385E88DL,18446744073709551615UL,-6L,4L,0x0F104D1C60CBB4FALL};
    struct S0 *l_517 = &l_518;
    struct S0 **l_516 = &l_517;
    struct S0 ***l_515 = &l_516;
    struct S0 ****l_519 = &l_515;
    int32_t *l_522 = &l_508;
    int32_t **l_521 = &l_522;
    const int64_t l_523 = (-9L);
lbl_520:
    for (l_508 = (-15); (l_508 > 18); l_508 = safe_add_func_uint16_t_u_u(l_508, 1))
    { /* block id: 306 */
        int32_t *l_512 = (void*)0;
        int32_t **l_511 = &l_512;
        float l_514 = (-0x1.Ep-1);
        float *l_513 = &l_514;
        (*l_511) = p_43;
        /* statement id: 307 */
        //assert (l_512 == 0 || l_512 == &l_40);
        (*l_513) = (-0x1.5p+1);
    }
    (*l_519) = l_515;
    if (l_508)
        goto lbl_520;
    (*l_521) = &l_508;
    return l_523;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_45(const int32_t * p_46, int32_t * p_47, const int32_t * p_48)
{ /* block id: 37 */
    int16_t l_52 = 0x30B1L;
    int32_t l_56 = 0x83A09977L;
    int32_t *l_55 = &l_56;
    struct S0 l_87 = {0L,0xED357DCCC76BF08ELL,4294967291UL,18446744073709551611UL,0x5178915D48947DE6LL,-5L,-5L};
    struct S0 *l_392 = &l_87;
    struct S0 **l_391 = &l_392;
    float l_414 = 0xE.283284p+47;
    float *l_413 = &l_414;
    float * const *l_412 = &l_413;
    float * const **l_411 = &l_412;
    int64_t l_482 = (-10L);
    if (l_52)
    { /* block id: 38 */
        int32_t l_54 = 0xE548E01AL;
        int32_t *l_53 = &l_54;
        return p_47;
        /* statement id: 39 */
        //assert (func_45_rv == &l_40);
    }
    else
    { /* block id: 40 */
        uint64_t l_59 = 1UL;
        int32_t *l_86 = &l_56;
        int32_t *l_313 = &l_56;
        struct S0 l_314 = {0xC326L,18446744073709551615UL,1UL,0xC9CA6B34L,0x5A74A0215C4462B6LL,0x1B35L,0x7BFAF387689AE391LL};
        struct S0 *l_368 = &l_87;
        struct S0 **l_367 = &l_368;
        struct S0 ***l_366 = &l_367;
        struct S0 ****l_365 = &l_366;
        uint64_t l_374 = 7UL;
        uint16_t l_382 = 65535UL;
        int16_t l_433 = 9L;
        float *****l_447 = (void*)0;
        const int32_t *l_450 = (void*)0;
        const int32_t **l_449 = &l_450;
        float l_478 = 0xB.941B8Cp-10;
        for (l_56 = (-15); (l_56 >= 9); l_56 = safe_add_func_uint16_t_u_u(l_56, 7))
        { /* block id: 43 */
            if (l_59)
                break;
        }
        for (l_59 = (-13); (l_59 != 40); ++l_59)
        { /* block id: 48 */
            uint32_t l_74 = 0x0BBE0E20L;
            int32_t *l_375 = &l_56;
            int32_t l_381 = 0xC8A839D5L;
            struct S0 l_383 = {0xE0EAL,18446744073709551615UL,0xC9C4C84BL,18446744073709551615UL,0x1BA1B34EAD64265CLL,0x0574L,6L};
            float * const * const *l_415 = &l_412;
            int32_t **l_416 = &l_313;
        }
        for (l_314.f4 = 0; (l_314.f4 != 6); ++l_314.f4)
        { /* block id: 242 */
            uint8_t l_420 = 0x96L;
            struct S0 l_423 = {0xB6B8L,0xDC092EF3164F34E5LL,4UL,0x219A541FL,0xAFB936777711359FLL,-1L,0x631843F403EBEA63LL};
            float ****l_446 = (void*)0;
            float *****l_445 = &l_446;
            struct S0 **l_451 = (void*)0;
            int32_t *l_462 = &l_56;
            int32_t ** const l_504 = &l_55;
            int32_t ** const *l_503 = &l_504;
            if ((*p_47))
            { /* block id: 243 */
                uint16_t l_426 = 65535UL;
                struct S0 l_434 = {0L,0xBFE8EF02D1D45230LL,8UL,1UL,0x30E39718DDC09939LL,-1L,-8L};
                int32_t *l_456 = &l_56;
                const int32_t * const *l_461 = &l_450;
                const int32_t * const **l_460 = &l_461;
                (*l_313) = (~__builtin_ctzl(l_420));
                if ((safe_sub_func_uint64_t_u_u(((*l_55) >= ((l_423 , (__builtin_clzll((l_426 <= (((l_423.f0 != (safe_add_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((-6L), (safe_add_func_uint16_t_u_u(l_433, (1L && (l_423.f5 < func_76((*p_48), &l_56, p_47))))))), (*l_86)))) > (*l_86)) <= l_426))) , l_434)) , (*l_55))), (*l_86))))
                { /* block id: 245 */
                    int32_t *l_435 = &l_56;
                    const int32_t *l_437 = &l_56;
                    const int32_t **l_436 = &l_437;
                    (*l_436) = l_435;
                    for (l_87.f4 = (-6); (l_87.f4 <= (-6)); l_87.f4++)
                    { /* block id: 249 */
                        int32_t *l_440 = &l_56;
                        l_440 = p_47;
                        /* statement id: 250 */
                        //assert (l_440 == &l_40);
                        (*l_436) = &l_56;
                    }
                    if ((safe_div_func_int16_t_s_s(l_434.f3, (safe_add_func_uint64_t_u_u(((*l_435) , 0xA3151D1CFE56B442LL), (*l_55))))))
                    { /* block id: 253 */
                        uint8_t l_448 = 247UL;
                        l_447 = l_445;
                        /* statement id: 254 */
                        assert (l_447 == &l_446);
                        l_449 = (((l_448 && l_420) <= (*p_46)) , &p_48);
                        /* statement id: 255 */
                        assert (l_449 == &p_48);
                    }
                    else
                    { /* block id: 256 */
                        uint32_t l_454 = 0x814CA008L;
                        int32_t * const l_455 = (void*)0;
                        int32_t *l_457 = (void*)0;
                        (*l_435) = (l_451 == (void*)0);
                        (**l_412) = (((safe_rshift_func_uint16_t_u_s((*l_55), l_434.f2)) == ((*l_55) | l_454)) , (*l_313));
                        p_47 = func_62(l_455, l_435);
                        /* statement id: 259 */
                        assert (p_47 == &l_56);
                        return l_457;
                        /* statement id: 260 */
                        //assert (func_45_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_447 == &l_446);
                    assert (l_449 == &p_48);
                }
                else
                { /* block id: 262 */
                    return p_47;
                    /* statement id: 263 */
                    //assert (func_45_rv == &l_40);
                }
                /* facts after branching */
                assert (l_447 == &l_446);
                assert (l_449 == &p_48);
                if ((*l_313))
                    break;
                //assert (l_447 == dangling);
                for (l_87.f3 = (-27); (l_87.f3 > 12); l_87.f3++)
                { /* block id: 268 */
                    l_462 = func_65((l_460 == (void*)0), (***l_366));
                    /* statement id: 269 */
                    assert (l_462 == 0);
                }
                /* facts after for loop */
                assert (l_462 == 0 || l_462 == &l_56);
            }
            else
            { /* block id: 271 */
                int32_t l_463 = 0x2F43C110L;
                (***l_411) = (l_463 , (-(func_76((*p_48), func_80(((*l_55) != ((((*l_462) > (safe_div_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u(func_76((*p_48), func_65(__builtin_clz((*l_55)), (*l_368)), l_462), (*l_55))) || (*l_462)), l_463))) || (*l_55)) , (*l_55))), p_46, (****l_365), (*p_48), p_47), &l_56) <= 0x3.0p+1)));
            }
            /* facts after branching */
            //assert (l_447 == 0 || l_447 == dangling || l_447 == &l_446);
            assert (l_462 == 0 || l_462 == &l_56);
            for (l_314.f1 = (-29); (l_314.f1 > 38); l_314.f1 = safe_add_func_uint32_t_u_u(l_314.f1, 3))
            { /* block id: 276 */
                uint8_t l_471 = 247UL;
                float ***l_472 = (void*)0;
                struct S0 *l_473 = &l_87;
                int32_t *l_479 = (void*)0;
                (*l_391) = (*l_391);
                (*l_86) = (((l_471 > ((((*l_55) < l_478) == 0x4.Fp-1) > (*l_55))) , 0x9DBEBBF000EBF231LL) , (*p_48));
                return l_479;
                /* statement id: 279 */
                //assert (func_45_rv == 0);
            }
            for (l_87.f2 = (-30); (l_87.f2 < 30); l_87.f2 = safe_add_func_uint32_t_u_u(l_87.f2, 3))
            { /* block id: 283 */
                uint32_t l_483 = 0x10EF6010L;
                float * const ***l_484 = (void*)0;
                int32_t **l_502 = &l_462;
                int32_t ***l_501 = &l_502;
                if (((l_423.f3 <= l_482) != 8UL))
                { /* block id: 284 */
                    float *****l_485 = &l_446;
                    int32_t l_486 = (-8L);
                    if (l_483)
                        break;
                    (*l_485) = l_484;
                    if (l_486)
                        continue;
                    (***l_411) = ((safe_div_func_float_f_f(__builtin_bswap32(l_486), l_483)) == ((*l_55) == l_423.f4));
                }
                else
                { /* block id: 289 */
                    int32_t l_495 = 0L;
                    int32_t l_507 = 1L;
                    if (__builtin_parityll((*l_313)))
                    { /* block id: 290 */
                        return p_47;
                        /* statement id: 291 */
                        //assert (func_45_rv == &l_40);
                    }
                    else
                    { /* block id: 292 */
                        float * const *l_505 = (void*)0;
                        int32_t l_506 = 0x403DDED2L;
                        l_507 = ((((((***l_366) , 0UL) > (((*l_55) >= (safe_add_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s((*l_55), 8)), (safe_rshift_func_int16_t_s_s(l_495, ((safe_sub_func_int16_t_s_s(0x810DL, (safe_add_func_int64_t_s_s((((safe_unary_minus_func_uint16_t_u((l_501 == l_503))) , ((l_505 == (void*)0) > l_495)) , (-1L)), 0xE471CA4684CC45CELL)))) | 1UL)))))) < (**l_504))) , 0x0.9p+1) <= l_506) != (*l_55));
                        return p_47;
                        /* statement id: 294 */
                        //assert (func_45_rv == &l_40);
                    }
                }
                (***l_365) = (**l_366);
                (*l_449) = p_48;
            }
        }
        /* facts after for loop */
        //assert (l_447 == 0 || l_447 == dangling);
        //assert (l_450 == &l_40 || l_450 == 0);
        assert (l_449 == &l_450 || l_449 == &p_48);
    }
    return p_47;
    /* statement id: 302 */
    //assert (func_45_rv == &l_40);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_62(int32_t * const  p_63, int32_t * p_64)
{ /* block id: 190 */
    int32_t l_345 = 0x86541363L;
    int32_t *l_344 = &l_345;
    int32_t **l_346 = (void*)0;
    int32_t **l_347 = &l_344;
    (*l_347) = l_344;
    return p_64;
    /* statement id: 192 */
    //assert (func_62_rv == 0 || func_62_rv == &l_56);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_65(int32_t  p_66, struct S0  p_67)
{ /* block id: 169 */
    int32_t * const *l_324 = (void*)0;
    int32_t * const **l_323 = &l_324;
    int32_t l_333 = 0L;
    struct S0 l_337 = {1L,0xEDB85EC9B8C997FFLL,4294967295UL,1UL,1L,0x8AD6L,3L};
    int32_t *l_340 = &l_333;
    int32_t *l_341 = &l_333;
    int32_t *l_342 = &l_333;
    int32_t *l_343 = (void*)0;
    for (p_67.f6 = 0; (p_67.f6 >= 8); ++p_67.f6)
    { /* block id: 172 */
        float **l_325 = (void*)0;
        int32_t l_326 = 1L;
        for (p_67.f3 = 21; (p_67.f3 <= 1); p_67.f3 = safe_sub_func_int16_t_s_s(p_67.f3, 1))
        { /* block id: 175 */
            int32_t *l_320 = (void*)0;
            int32_t **l_319 = &l_320;
            float l_322 = 0xD.BA16F0p-9;
            float *l_321 = &l_322;
            (*l_319) = (void*)0;
            (*l_321) = p_66;
            (*l_319) = (*l_319);
        }
        l_323 = l_323;
        l_326 = ((void*)0 == l_325);
    }
    for (p_67.f4 = 0; (p_67.f4 >= 23); ++p_67.f4)
    { /* block id: 185 */
        uint32_t l_336 = 0x3FCAEC78L;
        int32_t *l_339 = &l_333;
        int32_t **l_338 = &l_339;
        (*l_338) = func_80((safe_add_func_float_f_f(0x3.B875ECp-9, (p_67.f4 <= (-0x5.7p-1)))), func_80(((safe_rshift_func_uint16_t_u_s(l_333, 2)) , p_66), ((((((p_67.f5 <= p_67.f1) & p_67.f5) <= (safe_lshift_func_uint16_t_u_s(1UL, p_67.f4))) , l_336) <= p_67.f4) , (void*)0), p_67, l_336, &l_333), l_337, p_67.f0, &l_333);
        /* statement id: 186 */
        assert (l_339 == 0);
        p_66 = __builtin_ctz(p_67.f4);
    }
    return l_343;
    /* statement id: 189 */
    //assert (func_65_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_68(uint16_t  p_69, uint32_t  p_70, int32_t * p_71, struct S0  p_72, const uint32_t  p_73)
{ /* block id: 167 */
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads : l_40
 * writes:
 */
static uint16_t  func_76(int32_t  p_77, int32_t * p_78, int32_t * p_79)
{ /* block id: 58 */
    const int32_t l_112 = 0x33D3A0D6L;
    const int32_t *l_111 = &l_112;
    struct S0 l_113 = {1L,3UL,4294967289UL,0xE7E4EBB7L,0x4EAE4C08A2B653F5LL,0xD1B7L,1L};
    struct S0 *l_125 = (void*)0;
    struct S0 ** const l_124 = &l_125;
    int32_t l_128 = 0L;
    int32_t *l_127 = &l_128;
    float l_169 = 0x9.665516p+42;
    float *l_168 = &l_169;
    float **l_167 = &l_168;
    uint8_t l_182 = 255UL;
    int16_t l_217 = (-5L);
    int32_t **l_311 = (void*)0;
    int32_t *l_312 = &l_128;
    if ((*p_79))
    { /* block id: 59 */
        int64_t l_108 = 0x214255FA7FFF3577LL;
        const int32_t *l_121 = &l_112;
        struct S0 *l_131 = (void*)0;
        struct S0 l_153 = {-2L,0x0C00B44CA3D13A51LL,4294967295UL,0x94A997FCL,0x46356B4AE7F92F19LL,5L,0x20F02422DCD2DC6FLL};
        int32_t l_188 = 7L;
        float **l_230 = &l_168;
        uint32_t l_278 = 0xFBD02E40L;
        for (p_77 = (-11); (p_77 != 19); p_77 = safe_add_func_int64_t_s_s(p_77, 3))
        { /* block id: 62 */
            int32_t l_105 = 1L;
            struct S0 l_115 = {-3L,18446744073709551609UL,4294967295UL,18446744073709551611UL,0xDA29A6A910B13A75LL,-1L,-9L};
            int32_t *l_130 = &l_128;
            uint64_t l_154 = 18446744073709551615UL;
            int32_t l_161 = 0x941D4D58L;
            float l_164 = 0xA.601976p-47;
            float *l_163 = &l_164;
            float **l_162 = &l_163;
            int64_t l_235 = 2L;
            int32_t *l_270 = &l_105;
            for (l_105 = 2; (l_105 >= 14); ++l_105)
            { /* block id: 65 */
                float l_110 = (-0x7.Fp+1);
                float *l_109 = &l_110;
                int32_t l_114 = 2L;
                struct S0 **l_126 = &l_125;
                int32_t *l_134 = &l_128;
                uint64_t l_146 = 1UL;
                int32_t l_194 = 0x54E2514EL;
                int32_t **l_196 = &l_134;
            }
            if ((*l_121))
                break;
        }
    }
    else
    { /* block id: 155 */
        uint16_t l_307 = 0UL;
        for (l_113.f2 = 0; (l_113.f2 > 15); l_113.f2 = safe_add_func_int64_t_s_s(l_113.f2, 3))
        { /* block id: 158 */
            int32_t **l_310 = &l_127;
            (*l_127) = p_77;
            (*l_127) = ((((safe_mod_func_int64_t_s_s((((safe_sub_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s((p_77 > (*p_79)), 6)), (((*l_127) >= (((safe_add_func_uint32_t_u_u((safe_sub_func_int64_t_s_s(__builtin_clzl(p_77), (p_77 >= __builtin_parityl(l_307)))), ((safe_mod_func_uint32_t_u_u(0x13CCD52CL, p_77)) , (*p_79)))) >= 0xEC81F890L) , l_307)) != l_307))) != (*l_111)) != (*l_127)), 0x84784CF4E84C1D61LL)) | (*l_127)) >= (*l_127)) , (-1L));
            (*l_310) = &p_77;
            /* statement id: 161 */
            assert (l_127 == &p_77);
        }
        /* facts after for loop */
        assert (l_127 == &p_77 || l_127 == &l_128);
    }
    /* facts after branching */
    assert (l_127 == &p_77 || l_127 == &l_128);
    l_127 = func_80(((l_113 , p_77) , ((p_77 < 0x8.5p-1) == (*l_127))), func_80((*l_111), &l_112, l_113, (*p_79), &l_128), l_113, (*l_111), &l_128);
    /* statement id: 164 */
    assert (l_127 == 0);
    (*l_312) = (*p_79);
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_80(float  p_81, const int32_t * p_82, struct S0  p_83, int32_t  p_84, int32_t * p_85)
{ /* block id: 49 */
    int32_t l_88 = (-1L);
    float l_90 = 0x1.4p+1;
    float *l_89 = &l_90;
    int32_t l_98 = 0L;
    int32_t *l_97 = &l_98;
    int32_t *l_99 = &l_98;
    int32_t *l_100 = &l_98;
    int32_t *l_101 = &l_98;
    int32_t *l_102 = (void*)0;
    (*l_89) = l_88;
    for (p_83.f4 = 1; (p_83.f4 == (-29)); p_83.f4 = safe_sub_func_int32_t_s_s(p_83.f4, 1))
    { /* block id: 53 */
        uint32_t l_93 = 0xE2962DE1L;
        struct S0 l_95 = {8L,1UL,4294967288UL,0x4F543A9BL,0x6E5D1C1BBB80EAEALL,0xC79EL,-1L};
        struct S0 *l_94 = &l_95;
        struct S0 **l_96 = &l_94;
        l_93 = l_88;
        (*l_96) = l_94;
    }
    return l_102;
    /* statement id: 57 */
    //assert (func_80_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 139
   depth: 1, occurrence: 18
XXX total union variables: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 27
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 15, occurrence: 1
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 175

XXX times a variable address is taken: 169
XXX times a pointer is dereferenced on RHS: 192
breakdown:
   depth: 1, occurrence: 183
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 70
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 2
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 460

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 661
   level: 2, occurrence: 34
   level: 3, occurrence: 23
   level: 4, occurrence: 5
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 82
XXX number of pointers point to scalars: 84
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 30.3
XXX average alias set size: 1.28

XXX times a non-volatile is read: 804
XXX times a non-volatile is write: 202
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 98
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 16
   depth: 2, occurrence: 15
   depth: 3, occurrence: 16
   depth: 4, occurrence: 12
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 17.9
XXX percentage an existing variable is used: 82.1
********************* end of statistics **********************/

