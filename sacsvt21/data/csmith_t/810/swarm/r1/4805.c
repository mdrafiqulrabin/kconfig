/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3690687246
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint16_t  f0;
   uint16_t  f1;
   uint32_t  f2;
   uint32_t  f3;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static uint16_t  func_30(int16_t  p_31, uint32_t  p_32);
static uint16_t  func_50(int16_t  p_51);
static uint32_t  func_57(uint32_t  p_58);
static int32_t * func_62(struct S0  p_63, int32_t * p_64);
static int32_t * func_66(int32_t * p_67);
static int32_t * func_68(struct S0  p_69, int32_t * p_70);
static struct S0  func_71(struct S0  p_72, int32_t  p_73);
static struct S0  func_74(int32_t  p_75);
static int32_t  func_81(int32_t  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    int32_t l_41 = (-1);
    uint16_t l_42 = 0xFAA2;
    int32_t l_47 = 0xE4DE5A82;
    uint32_t l_543 = 0xA9FAF105;
    uint16_t l_544 = 0U;
    int32_t *l_583 = &l_41;
    int16_t l_584 = 0xED09;
    (*l_583) = (0xD0B5486B >= (0xA221 | (func_30((safe_rshift_func_int16_t_s_s((((safe_mul_func_int16_t_s_s(((safe_lshift_func_int16_t_s_u((l_41 ^ (l_42 > (((((safe_lshift_func_int16_t_s_s(((__builtin_bswap32((safe_mod_func_uint16_t_u_u(l_47, (safe_mod_func_uint16_t_u_u(func_50((safe_unary_minus_func_uint16_t_u((safe_lshift_func_int16_t_s_s(((((safe_lshift_func_int16_t_s_s((l_41 >= func_57(l_42)), (!(safe_rshift_func_int16_t_s_u((safe_mod_func_int32_t_s_s(func_81((safe_lshift_func_int16_t_s_u(l_41, 14))), l_47)), 12))))) < 1U) != l_41) ^ l_47), 14))))), 0xB55B))))) <= l_42) ^ l_47), 6)) > l_41) >= 0x92C7058C) >= 65531U) == l_42))), 11)) | l_42), l_543)) & l_42) | l_42), 2)), l_544) & (-3))));
    return l_584;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_30(int16_t  p_31, uint32_t  p_32)
{ /* block id: 395 */
    struct S0 *l_554 = (void*)0;
    struct S0 **l_553 = &l_554;
    struct S0 ***l_552 = &l_553;
    struct S0 ****l_551 = &l_552;
    struct S0 *****l_550 = &l_551;
    int32_t l_565 = 9;
    uint32_t l_572 = 1U;
    for (p_31 = (-19); (p_31 > (-20)); p_31 = safe_sub_func_uint32_t_u_u(p_31, 5))
    { /* block id: 398 */
        int32_t l_560 = 0;
        int32_t *l_573 = &l_565;
        int32_t l_578 = (-5);
        if (p_31)
        { /* block id: 399 */
            for (p_32 = 5; (p_32 > 40); p_32 = safe_add_func_int32_t_s_s(p_32, 1))
            { /* block id: 402 */
                struct S0 *****l_549 = (void*)0;
                int32_t *l_557 = (void*)0;
                int32_t l_559 = 0xC2BCBF23;
                int32_t *l_558 = &l_559;
                if (p_32)
                    break;
                l_550 = l_549;
                (*l_558) = ((p_31 <= (safe_lshift_func_uint16_t_u_s(p_31, 10))) < p_31);
            }
            if (l_560)
                continue;
        }
        else
        { /* block id: 408 */
            int32_t *l_561 = &l_560;
            (*l_561) = p_31;
        }
        (*l_573) = (l_560 != (!(((safe_sub_func_uint16_t_u_u(l_565, func_50(__builtin_clzl(((safe_rshift_func_int16_t_s_u(l_565, func_57((l_560 >= l_565)))) < (safe_sub_func_int32_t_s_s(l_560, (func_57((safe_lshift_func_int16_t_s_u(0xA52F, 15))) >= p_31)))))))) >= 0x20C5) | l_572)));
        (*l_573) = (safe_rshift_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(l_578, (safe_sub_func_int16_t_s_s((-1), ((safe_sub_func_int32_t_s_s(0x7C5DAA34, p_31)) > l_572))))), 13));
    }
    return p_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_50(int16_t  p_51)
{ /* block id: 343 */
    uint16_t l_489 = 65533U;
    int32_t l_495 = (-1);
    struct S0 l_502 = {0x9554,5U,0x30A5FB24,4294967295U};
    int32_t l_539 = 0x5570AE59;
    uint32_t l_542 = 0x0E1EBB0A;
    if (((p_51 <= l_489) > ((l_489 ^ ((((func_81((((safe_add_func_uint32_t_u_u((p_51 && (safe_mod_func_int32_t_s_s((0x24CBD5D1 <= 0x3CD70492), p_51))), p_51)) > p_51) & l_489)) < p_51) >= p_51) > 1U) && 0xC615)) ^ l_489)))
    { /* block id: 344 */
        int16_t l_494 = 0x256C;
        int32_t *l_497 = &l_495;
        int32_t **l_496 = &l_497;
        l_495 = __builtin_ffs((l_494 && func_81(p_51)));
        (*l_496) = &l_495;
        for (l_489 = 0; (l_489 > 19); l_489 = safe_add_func_uint32_t_u_u(l_489, 1))
        { /* block id: 349 */
            uint32_t l_507 = 0x12B29C78;
            int32_t *l_509 = (void*)0;
            struct S0 l_520 = {65532U,0x38C7,0x74718098,0x1574A506};
            for (l_495 = 0; (l_495 >= 14); l_495 = safe_add_func_int16_t_s_s(l_495, 1))
            { /* block id: 352 */
                int32_t l_513 = (-1);
                struct S0 l_517 = {0x9C1E,0x47E4,0xD72817AE,6U};
            }
        }
    }
    else
    { /* block id: 381 */
        int32_t *l_522 = &l_495;
        struct S0 l_523 = {0xC16A,0x071D,0x97D27F54,0xD161D73B};
        int32_t **l_524 = &l_522;
        struct S0 *l_525 = (void*)0;
        int32_t *l_532 = &l_495;
        l_522 = l_522;
        (*l_524) = func_68(l_523, func_62(l_523, &l_495));
        l_502 = l_502;
        (*l_532) = (safe_mul_func_uint16_t_u_u(p_51, __builtin_ctz((safe_rshift_func_uint16_t_u_u(__builtin_ctzl(func_81(p_51)), (__builtin_ffsl(__builtin_parityll((safe_rshift_func_int16_t_s_s(((__builtin_parity(__builtin_popcountll(p_51)) > (((__builtin_popcount(p_51) < 2) != p_51) == p_51)) || 7U), l_489)))) | 0x1C3F60DE))))));
    }
    for (l_502.f0 = (-28); (l_502.f0 >= 25); l_502.f0 = safe_add_func_uint32_t_u_u(l_502.f0, 6))
    { /* block id: 389 */
        int32_t *l_535 = (void*)0;
        int32_t *l_536 = &l_495;
        if (p_51)
            break;
        (*l_536) = l_502.f0;
        (*l_536) = (((safe_mod_func_uint16_t_u_u(__builtin_popcount(l_539), p_51)) == ((((safe_mod_func_uint32_t_u_u(0xC3FDE41B, (*l_536))) >= ((&l_535 == &l_535) < p_51)) | l_542) > (*l_536))) || p_51);
    }
    return l_502.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_57(uint32_t  p_58)
{ /* block id: 37 */
    uint32_t l_59 = 0x5866B388;
    struct S0 l_65 = {65535U,65529U,0U,4294967295U};
    int16_t l_124 = 0x9778;
    int32_t *l_149 = (void*)0;
    struct S0 ***l_383 = (void*)0;
    struct S0 ****l_382 = &l_383;
    struct S0 *l_390 = &l_65;
    int32_t l_394 = (-9);
    int32_t l_420 = 0x34AED8E4;
    uint32_t l_475 = 0x75B70FD3;
    int32_t l_480 = 0x0A4364D8;
    int32_t **l_481 = &l_149;
    if ((p_58 != l_59))
    { /* block id: 38 */
        int32_t l_61 = 0xADCDA6A4;
        int32_t *l_60 = &l_61;
        int32_t **l_374 = (void*)0;
        int32_t **l_375 = (void*)0;
        int32_t **l_376 = &l_60;
        int16_t l_407 = 6;
        struct S0 **l_422 = (void*)0;
        struct S0 ***l_421 = &l_422;
        struct S0 *l_454 = &l_65;
        (*l_60) = 1;
        (*l_376) = func_62(l_65, func_66(func_68(func_71(func_74(l_65.f3), l_124), l_149)));
        for (l_61 = (-17); (l_61 < (-9)); l_61 = safe_add_func_uint16_t_u_u(l_61, 2))
        { /* block id: 257 */
            int32_t l_391 = 0xCEA31313;
            int32_t *l_398 = &l_61;
            struct S0 *l_426 = &l_65;
            int16_t l_441 = (-1);
        }
        l_149 = &l_394;
    }
    else
    { /* block id: 330 */
        struct S0 l_473 = {0x9753,0x3827,4294967291U,1U};
        int32_t **l_474 = &l_149;
        (*l_474) = func_68(l_473, &l_420);
        (*l_149) = l_475;
    }
    for (l_65.f3 = 29; (l_65.f3 < 60); l_65.f3 = safe_add_func_int32_t_s_s(l_65.f3, 5))
    { /* block id: 336 */
        int32_t **l_478 = (void*)0;
        int32_t **l_479 = &l_149;
        (*l_479) = (void*)0;
        if (p_58)
            continue;
    }
    l_420 = l_480;
    (*l_481) = &l_394;
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_62(struct S0  p_63, int32_t * p_64)
{ /* block id: 218 */
    uint16_t l_339 = 0xCDE4;
    struct S0 *l_342 = (void*)0;
    struct S0 l_343 = {1U,0x77D8,0x4BDD627B,8U};
    int32_t l_345 = 0x7B5E04BF;
    int32_t *l_344 = &l_345;
    int32_t l_354 = (-6);
    int32_t *l_368 = (void*)0;
    int32_t *l_369 = (void*)0;
    int32_t *l_370 = (void*)0;
    int32_t *l_371 = &l_345;
    int32_t *l_372 = &l_345;
    int32_t *l_373 = (void*)0;
    l_343 = func_71(func_74(__builtin_ffs(__builtin_ctzll(((6U != p_63.f2) ^ l_339)))), (safe_sub_func_uint16_t_u_u((((-1) == func_81(l_339)) & l_339), l_339)));
    (*l_344) = __builtin_bswap32(l_343.f2);
    if ((*l_344))
    { /* block id: 221 */
        int32_t **l_346 = &l_344;
        int32_t l_349 = 0x3E966DBC;
        int32_t *l_355 = &l_349;
        (*l_346) = p_64;
        if (l_339)
            goto lbl_351;
lbl_351:
        l_349 = (safe_add_func_int16_t_s_s(7, (func_81(l_349) <= __builtin_parityl((+p_63.f3)))));
        for (l_343.f0 = 0; (l_343.f0 > 36); l_343.f0 = safe_add_func_int16_t_s_s(l_343.f0, 6))
        { /* block id: 227 */
            if (l_343.f1)
                break;
        }
        (*l_355) = (func_81(l_354) < p_63.f2);
    }
    else
    { /* block id: 231 */
        struct S0 **l_357 = &l_342;
        struct S0 ***l_356 = &l_357;
        int32_t l_360 = 0x9955880D;
        int32_t **l_367 = &l_344;
        (*l_356) = &l_342;
        for (l_339 = 0; (l_339 != 5); l_339++)
        { /* block id: 235 */
            (*l_357) = &p_63;
            (*l_344) = (*l_344);
            if (l_360)
                continue;
            if ((__builtin_parity((((safe_rshift_func_int16_t_s_s((*l_344), 0)) == (l_360 | 0xE77D)) < (safe_mul_func_int16_t_s_s(0x4486, 0x6286)))) >= (p_63.f2 & (-7))))
            { /* block id: 239 */
                int32_t l_365 = 0xDE13DCA1;
                struct S0 l_366 = {0xABC9,0U,1U,4294967292U};
                (*l_344) = l_365;
                l_366 = (*l_342);
                (*l_344) = 0x5A4F5450;
            }
            else
            { /* block id: 243 */
                p_63 = func_74(((*l_344) >= ((void*)0 != p_64)));
                p_64 = &l_360;
                if ((*l_344))
                    continue;
            }
        }
        (*l_367) = func_68(p_63, p_64);
        (*l_367) = (*l_367);
    }
    (*l_371) = ((p_63.f0 | 65533U) <= l_343.f3);
    return l_373;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_66(int32_t * p_67)
{ /* block id: 84 */
    struct S0 l_154 = {0x6261,0x54E0,0x4D058532,4U};
    struct S0 *l_155 = &l_154;
    int32_t l_162 = 0x1C76BB48;
    int32_t l_211 = 0x132D04EE;
    int32_t *l_210 = &l_211;
    int32_t *l_250 = &l_211;
    int32_t **l_254 = &l_250;
    int32_t ***l_253 = &l_254;
    struct S0 ***l_262 = (void*)0;
    struct S0 *l_281 = &l_154;
    int32_t *l_328 = &l_211;
    int32_t *l_329 = (void*)0;
lbl_171:
    (*l_155) = l_154;
    for (l_154.f2 = 0; (l_154.f2 <= 28); l_154.f2 = safe_add_func_uint32_t_u_u(l_154.f2, 1))
    { /* block id: 88 */
        struct S0 **l_158 = &l_155;
        struct S0 ***l_159 = &l_158;
        int32_t l_166 = (-8);
        (*l_159) = l_158;
        if (l_154.f3)
            continue;
        for (l_154.f3 = 27; (l_154.f3 == 50); l_154.f3++)
        { /* block id: 93 */
            uint16_t l_165 = 0xA740;
            int32_t *l_168 = &l_166;
            int32_t **l_167 = &l_168;
            if (l_162)
                break;
            for (l_154.f0 = 0; (l_154.f0 < 43); l_154.f0 = safe_add_func_int16_t_s_s(l_154.f0, 1))
            { /* block id: 97 */
                l_166 = l_165;
            }
            (*l_167) = func_68((***l_159), p_67);
            for (l_162 = 0; (l_162 != (-25)); l_162 = safe_sub_func_uint16_t_u_u(l_162, 1))
            { /* block id: 103 */
                struct S0 *l_172 = &l_154;
                int32_t l_173 = 4;
                if (l_165)
                    goto lbl_171;
                (**l_159) = l_172;
                if (l_173)
                    break;
            }
        }
    }
    for (l_154.f3 = 0; (l_154.f3 >= 58); l_154.f3++)
    { /* block id: 112 */
        struct S0 **l_190 = &l_155;
        int32_t l_191 = (-4);
        int32_t l_282 = 0;
        uint32_t l_320 = 0x4A689631;
        for (l_154.f1 = 10; (l_154.f1 != 32); l_154.f1 = safe_add_func_uint16_t_u_u(l_154.f1, 1))
        { /* block id: 115 */
            int32_t l_184 = 0x36B179DC;
            int32_t l_186 = (-9);
            int32_t *l_185 = &l_186;
            struct S0 **l_189 = (void*)0;
            struct S0 ***l_188 = &l_189;
            uint32_t l_205 = 4294967293U;
            int32_t ***l_255 = &l_254;
            int32_t *l_260 = (void*)0;
            int32_t *l_302 = &l_211;
            uint32_t l_321 = 0xDF46E708;
            if (((l_154.f3 | func_81((safe_rshift_func_uint16_t_u_s(func_81((safe_rshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(l_184, 4)), (((void*)0 != l_185) >= (!(0 | (((void*)0 != l_188) > (((l_190 != l_190) && l_191) < l_191)))))))), l_162)))) & (*l_185)))
            { /* block id: 116 */
                uint32_t l_197 = 1U;
                int32_t *l_208 = &l_191;
                struct S0 *l_226 = &l_154;
                int32_t *l_305 = &l_191;
                if (((+(l_191 & (*l_185))) < (safe_sub_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u(l_154.f0, l_191)), l_197))))
                { /* block id: 117 */
                    uint32_t l_202 = 0x507010F8;
                    l_205 = (safe_sub_func_int16_t_s_s(((l_154.f3 == l_197) > (safe_mod_func_uint32_t_u_u(l_154.f0, l_202))), (safe_sub_func_uint16_t_u_u(l_197, ((void*)0 == (*l_190))))));
                    for (l_154.f0 = 28; (l_154.f0 <= 15); l_154.f0 = safe_sub_func_uint16_t_u_u(l_154.f0, 1))
                    { /* block id: 121 */
                        int32_t **l_209 = &l_208;
                        (*l_190) = &l_154;
                        (*l_209) = func_68(func_71((*l_155), l_154.f3), func_68((*l_155), l_208));
                    }
                    p_67 = func_68((**l_190), func_68((*l_155), p_67));
                }
                else
                { /* block id: 126 */
                    int32_t **l_212 = &l_210;
                    struct S0 l_213 = {0x7B70,0xE5EE,0x85A6AE0B,1U};
                    (*l_212) = l_210;
                    l_213 = func_74((*l_210));
                }
                if ((*l_185))
                { /* block id: 130 */
                    struct S0 ***l_220 = &l_189;
                    int32_t l_221 = 0;
                    struct S0 *l_222 = (void*)0;
                    struct S0 l_224 = {65527U,0x1F0E,0x0B645F29,0x22F73C68};
                    struct S0 *l_223 = &l_224;
                    int32_t **l_225 = &l_208;
                    uint32_t l_239 = 0x26938DC3;
                    (*l_223) = func_74((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((0x5F29 | (safe_lshift_func_int16_t_s_u((l_220 == l_220), (*l_185)))), 5)), l_221)));
                    (*l_225) = func_68((**l_190), func_68((*l_155), p_67));
                    if (func_81(((*l_185) == l_197)))
                    { /* block id: 133 */
                        int32_t l_238 = 0;
                        (*l_190) = l_226;
                        l_239 = ((safe_mod_func_int16_t_s_s((safe_add_func_uint16_t_u_u((safe_unary_minus_func_int32_t_s(3)), (l_191 & (safe_sub_func_uint32_t_u_u((func_81(l_191) >= ((((safe_mod_func_int16_t_s_s(func_81((safe_rshift_func_int16_t_s_u(__builtin_ctzl((*l_210)), 12))), (__builtin_bswap64(__builtin_bswap32(func_81(l_238))) || (*l_210)))) >= l_238) ^ 0U) >= (*l_210))), (*l_210)))))), 0xFEC1)) != 4U);
                        (*l_185) = (((safe_lshift_func_uint16_t_u_u((*l_210), (*l_210))) <= 1) ^ ((*l_210) <= (l_238 && ((*l_210) || ((((*l_185) || (l_238 >= (!((safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s((*l_185), (*l_185))), 14)) == (-1))))) <= (*l_210)) && (*l_210))))));
                    }
                    else
                    { /* block id: 137 */
                        struct S0 **l_249 = &l_226;
                        (*l_188) = l_249;
                        return l_208;
                    }
                }
                else
                { /* block id: 141 */
                    (*l_190) = &l_154;
                }
                p_67 = l_208;
                if ((l_250 == &l_211))
                { /* block id: 145 */
                    struct S0 l_256 = {0xCD73,65531U,0x8D9C584D,0x3C817C74};
                    struct S0 *l_257 = &l_256;
                    for (l_191 = (-26); (l_191 == (-27)); l_191 = safe_sub_func_int16_t_s_s(l_191, 7))
                    { /* block id: 148 */
                        p_67 = &l_191;
                    }
                    l_255 = l_253;
                    (**l_253) = func_68((*l_226), (**l_255));
                    (*l_257) = l_256;
                }
                else
                { /* block id: 154 */
                    int32_t l_261 = 0x4F9DCC43;
                    struct S0 ***l_284 = &l_190;
                    int32_t *l_308 = (void*)0;
                    for (l_154.f0 = 0; (l_154.f0 == 4); l_154.f0++)
                    { /* block id: 157 */
                        (*l_250) = (*l_185);
                        return l_260;
                    }
                    if (((*l_185) < __builtin_popcountl(l_261)))
                    { /* block id: 161 */
                        struct S0 ****l_263 = &l_188;
                        (***l_255) = (1 != (-1));
                        (*l_263) = l_262;
                    }
                    else
                    { /* block id: 164 */
                        uint16_t l_270 = 65535U;
                        struct S0 l_276 = {0U,0xB420,0xBD9F06A9,1U};
                        struct S0 *l_275 = &l_276;
                        int32_t *l_283 = (void*)0;
                        (*l_275) = func_74((safe_lshift_func_uint16_t_u_u(((*l_250) > (safe_add_func_int32_t_s_s((-2), ((safe_mul_func_int16_t_s_s(l_270, (safe_rshift_func_int16_t_s_s((l_261 > l_191), 15)))) > (((0x0083EB55 && ((*l_250) != l_191)) && (safe_mul_func_int16_t_s_s(l_191, 0x00C2))) >= (-1)))))), (***l_255))));
                        (*l_210) = ((*l_210) | 0x7A45);
                        (***l_253) = (((l_276.f1 < __builtin_ctzl(l_191)) || (safe_sub_func_int32_t_s_s((((func_81(((l_261 && ((safe_mul_func_uint16_t_u_u((l_276.f0 == ((-10) & __builtin_parity(((void*)0 != l_281)))), l_282)) | l_270)) | l_276.f0)) < 0) == (*l_250)) || l_276.f3), (*l_185)))) | (**l_254));
                        return l_283;
                    }
                    if (__builtin_ffsll(((func_81(((void*)0 != l_284)) & l_191) <= l_261)))
                    { /* block id: 170 */
                        int32_t l_287 = (-1);
                        struct S0 *l_289 = &l_154;
                        struct S0 l_301 = {0U,65535U,0x56730D74,0U};
                        struct S0 *l_300 = &l_301;
                        (***l_255) = ((safe_sub_func_uint32_t_u_u(l_287, (+((**l_284) != l_289)))) ^ (safe_rshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((l_261 || (**l_254)), ((0 == (safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(l_261, (*l_250))), (safe_mod_func_int16_t_s_s(__builtin_ctz((*l_250)), l_282))))) && l_261))), l_197)));
                        (**l_255) = func_68((*l_289), &l_261);
                        (*l_190) = l_226;
                        (*l_300) = (*l_226);
                    }
                    else
                    { /* block id: 175 */
                        int32_t *l_303 = &l_191;
                        int32_t *l_304 = &l_186;
                        int32_t *l_306 = &l_191;
                        int32_t *l_307 = &l_191;
                        return l_308;
                    }
                }
            }
            else
            { /* block id: 179 */
                struct S0 l_309 = {0x41CA,65535U,0x44861314,4294967295U};
                (**l_255) = (*l_254);
                (**l_255) = p_67;
                l_309 = func_71((**l_190), (*l_185));
                if (l_191)
                { /* block id: 183 */
                    uint32_t l_322 = 4U;
                    struct S0 **l_325 = (void*)0;
                    (*l_210) = (((((((safe_mod_func_uint32_t_u_u((*l_185), (safe_rshift_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s((safe_mul_func_uint16_t_u_u((*l_210), (l_282 < (safe_mod_func_uint32_t_u_u(l_320, l_309.f1))))), 11)) || ((0xB689 & (l_320 | (0x44646C51 | l_309.f0))) && 0x8416)), 3)))) == l_321) & 2) | 7) <= (*l_302)) && (*l_302)) && 0xB2A09282);
                    l_322 = (*l_185);
                    (*l_302) = (((l_309.f1 || ((safe_rshift_func_int16_t_s_u(((*l_188) != l_325), 10)) == l_322)) && 0xFEDC4550) <= l_322);
                    for (l_282 = 0; (l_282 < 3); l_282 = safe_add_func_int16_t_s_s(l_282, 1))
                    { /* block id: 189 */
                        (**l_253) = p_67;
                    }
                }
                else
                { /* block id: 192 */
                    (*l_210) = (func_81(l_309.f1) ^ (*l_185));
                }
            }
            (*l_190) = (*l_190);
            return l_329;
        }
        return p_67;
    }
    for (l_154.f0 = (-6); (l_154.f0 == 17); l_154.f0 = safe_add_func_uint16_t_u_u(l_154.f0, 1))
    { /* block id: 203 */
        struct S0 l_335 = {0x0BC7,65535U,4294967295U,0x4B4B9B85};
        struct S0 *l_338 = &l_335;
        for (l_154.f3 = (-15); (l_154.f3 > 53); l_154.f3 = safe_add_func_int16_t_s_s(l_154.f3, 7))
        { /* block id: 206 */
            uint32_t l_334 = 6U;
            l_335 = func_74(l_334);
            for (l_335.f3 = 0; (l_335.f3 > 19); l_335.f3 = safe_add_func_int32_t_s_s(l_335.f3, 4))
            { /* block id: 210 */
                (*l_254) = p_67;
            }
        }
        (*l_338) = l_335;
        (*l_328) = (p_67 == (*l_254));
    }
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_68(struct S0  p_69, int32_t * p_70)
{ /* block id: 80 */
    int32_t l_150 = 5;
    int32_t l_153 = (-1);
    int32_t *l_152 = &l_153;
    int32_t **l_151 = &l_152;
    l_150 = 0x6FC21787;
    (*l_151) = p_70;
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_71(struct S0  p_72, int32_t  p_73)
{ /* block id: 69 */
    uint32_t l_125 = 0x49BDABD6;
    int16_t l_133 = 0x5673;
    struct S0 l_137 = {65529U,65532U,0xF16C98A2,0x6184417F};
    if ((l_125 || (0 == 0x1FA2)))
    { /* block id: 70 */
        int32_t l_127 = 0x0817FF2A;
        int32_t *l_126 = &l_127;
        int32_t l_130 = 0x9192873B;
        (*l_126) = l_125;
        (*l_126) = (((safe_lshift_func_int16_t_s_u((-1), 0)) == (0xE927CFDA <= ((((*l_126) > ((0xD34F & (*l_126)) <= l_130)) >= (safe_add_func_uint16_t_u_u(l_133, ((&l_130 == &p_73) <= (-6))))) || (*l_126)))) < l_125);
        (*l_126) = p_73;
    }
    else
    { /* block id: 74 */
        int32_t l_135 = 0;
        int32_t *l_134 = &l_135;
        int32_t **l_136 = &l_134;
        (*l_136) = l_134;
        return l_137;
    }
    p_73 = ((safe_lshift_func_int16_t_s_u(p_72.f3, (safe_add_func_int16_t_s_s((l_137.f2 != p_72.f1), (safe_mod_func_int16_t_s_s(l_133, p_72.f0)))))) != (p_72.f3 ^ (safe_sub_func_uint32_t_u_u((+(safe_mul_func_uint16_t_u_u(l_137.f2, (l_137.f2 > (0x85F4 >= p_72.f0))))), 0x9B53D0E5))));
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_74(int32_t  p_75)
{ /* block id: 40 */
    int32_t l_77 = 0xDA513E67;
    int32_t *l_76 = &l_77;
    int16_t l_101 = (-10);
    struct S0 l_119 = {1U,3U,1U,4294967295U};
    struct S0 *l_118 = &l_119;
    int32_t **l_122 = &l_76;
    struct S0 l_123 = {1U,0x4991,0x032C2DE0,0x6AD74ACF};
    (*l_76) = p_75;
    (*l_76) = ((safe_add_func_uint32_t_u_u((~0), func_81((p_75 && ((4294967288U < ((*l_76) > ((*l_76) || ((p_75 == p_75) != (*l_76))))) || ((void*)0 != &p_75)))))) == 1U);
    for (p_75 = 1; (p_75 != 13); p_75++)
    { /* block id: 59 */
        struct S0 *l_117 = (void*)0;
        int32_t l_120 = 0x3D0BAECB;
        for (l_77 = (-18); (l_77 != (-18)); l_77 = safe_add_func_uint32_t_u_u(l_77, 1))
        { /* block id: 62 */
            int32_t **l_98 = &l_76;
            int32_t *l_121 = &l_120;
            (*l_98) = (void*)0;
            (*l_121) = (safe_add_func_int32_t_s_s((p_75 ^ p_75), (l_101 <= (safe_rshift_func_int16_t_s_s(p_75, (((((safe_add_func_int32_t_s_s((+p_75), (safe_add_func_int32_t_s_s((safe_mod_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u((safe_sub_func_int32_t_s_s((safe_rshift_func_uint16_t_u_s(p_75, 10)), (p_75 <= (l_117 == l_118)))), 7U)), 0x0BAF9C35)), l_120)))) ^ l_120) & p_75) || l_120) == p_75))))));
            l_122 = &l_121;
        }
    }
    return l_123;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_81(int32_t  p_82)
{ /* block id: 42 */
    int32_t *l_84 = (void*)0;
    int32_t **l_83 = &l_84;
    struct S0 l_85 = {1U,0x6072,4294967295U,0x29496125};
    struct S0 *l_86 = &l_85;
    int32_t l_88 = 0x7316A37A;
    int32_t *l_87 = &l_88;
    (*l_83) = &p_82;
    (*l_86) = l_85;
    (*l_84) = p_82;
    if ((&p_82 != l_87))
    { /* block id: 46 */
        return p_82;
    }
    else
    { /* block id: 48 */
        struct S0 l_91 = {65535U,0xB4D6,0x42281945,7U};
        for (l_85.f2 = 0; (l_85.f2 == 8); l_85.f2 = safe_add_func_int32_t_s_s(l_85.f2, 1))
        { /* block id: 51 */
            struct S0 *l_92 = (void*)0;
            struct S0 *l_93 = &l_91;
            (*l_93) = l_91;
        }
    }
    return p_82;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 129
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 191
   depth: 2, occurrence: 34
   depth: 3, occurrence: 12
   depth: 4, occurrence: 3
   depth: 5, occurrence: 5
   depth: 6, occurrence: 2
   depth: 7, occurrence: 4
   depth: 9, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 131

XXX times a variable address is taken: 126
XXX times a pointer is dereferenced on RHS: 80
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 8
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 95
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 439

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 451
   level: 2, occurrence: 73
   level: 3, occurrence: 34
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 48
XXX number of pointers point to scalars: 57
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 38.2
XXX average alias set size: 1.57

XXX times a non-volatile is read: 575
XXX times a non-volatile is write: 272
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 170
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 46
   depth: 2, occurrence: 22
   depth: 3, occurrence: 22
   depth: 4, occurrence: 21
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 18.8
XXX percentage an existing variable is used: 81.2
********************* end of statistics **********************/

