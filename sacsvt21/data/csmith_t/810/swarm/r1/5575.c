/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1865064920
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
   signed f1 : 7;
   unsigned f2 : 13;
   signed f3 : 5;
   unsigned : 0;
   signed f4 : 23;
   unsigned f5 : 25;
};

struct S1 {
   int16_t  f0;
};

struct S2 {
   unsigned f0 : 28;
   const unsigned f1 : 8;
   unsigned f2 : 22;
   signed f3 : 21;
   signed f4 : 22;
   signed f5 : 13;
   uint32_t  f6;
   unsigned : 0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_35(void);
static int32_t * func_49(int32_t * p_50);
static struct S1 * func_52(float * p_53, struct S1 * p_54);
static float * func_55(int32_t  p_56, int32_t  p_57, int32_t * p_58, float * p_59);
static int32_t * func_61(float * p_62, struct S1 * p_63, uint16_t  p_64, int32_t * p_65, uint32_t  p_66);
static float * func_67(float * p_68, int32_t  p_69);
static float * func_70(int32_t * const  p_71, int16_t  p_72, struct S1 * p_73, float * p_74);
static struct S1  func_82(uint16_t  p_83, int32_t  p_84);
static int32_t  func_90(const struct S2  p_91);
static float  func_104(float  p_105);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_35(void)
{ /* block id: 36 */
    struct S0 l_36[4][4][3] = {{{{5037,7,70,-0,2438,4229},{6321,-7,32,-1,2122,4864},{5037,7,70,-0,2438,4229}},{{511,-7,65,2,850,4862},{6628,-0,77,1,2279,4699},{511,-7,65,2,850,4862}},{{5037,7,70,-0,2438,4229},{6321,-7,32,-1,2122,4864},{5037,7,70,-0,2438,4229}},{{511,-7,65,2,850,4862},{6628,-0,77,1,2279,4699},{511,-7,65,2,850,4862}}},{{{5037,7,70,-0,2438,4229},{6321,-7,32,-1,2122,4864},{5037,7,70,-0,2438,4229}},{{511,-7,65,2,850,4862},{6628,-0,77,1,2279,4699},{511,-7,65,2,850,4862}},{{5037,7,70,-0,2438,4229},{6321,-7,32,-1,2122,4864},{5037,7,70,-0,2438,4229}},{{511,-7,65,2,850,4862},{6628,-0,77,1,2279,4699},{511,-7,65,2,850,4862}}},{{{5037,7,70,-0,2438,4229},{6321,-7,32,-1,2122,4864},{5037,7,70,-0,2438,4229}},{{511,-7,65,2,850,4862},{6628,-0,77,1,2279,4699},{511,-7,65,2,850,4862}},{{5037,7,70,-0,2438,4229},{6321,-7,32,-1,2122,4864},{5037,7,70,-0,2438,4229}},{{511,-7,65,2,850,4862},{6628,-0,77,1,2279,4699},{511,-7,65,2,850,4862}}},{{{5037,7,70,-0,2438,4229},{6321,-7,32,-1,2122,4864},{5037,7,70,-0,2438,4229}},{{511,-7,65,2,850,4862},{6628,-0,77,1,2279,4699},{511,-7,65,2,850,4862}},{{5037,7,70,-0,2438,4229},{6321,-7,32,-1,2122,4864},{5037,7,70,-0,2438,4229}},{{511,-7,65,2,850,4862},{6729,-4,45,-4,1180,5188},{-1214,9,11,-2,443,838}}}};
    int32_t l_37 = 0x74F57B17L;
    const struct S2 l_907 = {12902,7,320,733,1290,15,18446744073709551606UL};
    float l_912[2];
    float *l_911 = &l_912[1];
    struct S1 l_914 = {0xB14AL};
    struct S1 *l_913 = &l_914;
    int32_t *l_927 = &l_37;
    int32_t l_928[10][6][4] = {{{0xD356672AL,1L,(-1L),(-2L)},{0L,0x524DF1CFL,0x6AB62EF8L,(-1L)},{0xA09C70FCL,0x524DF1CFL,0xA09C70FCL,(-2L)},{0x524DF1CFL,1L,3L,0L},{0L,(-1L),0L,1L},{0x943C640EL,0L,0L,0x943C640EL}},{{0L,(-2L),3L,0xA09C70FCL},{0x524DF1CFL,0x14609EC5L,0xA09C70FCL,0L},{0xA09C70FCL,0L,0x6AB62EF8L,0L},{0L,0x14609EC5L,(-1L),0xA09C70FCL},{0xD356672AL,(-2L),0L,0x943C640EL},{(-1L),0L,1L,1L}},{{(-1L),(-1L),0L,0L},{0xD356672AL,1L,(-1L),(-2L)},{0L,0x524DF1CFL,0x6AB62EF8L,(-1L)},{0xA09C70FCL,0x524DF1CFL,0xA09C70FCL,(-2L)},{0x524DF1CFL,1L,3L,0L},{0L,(-1L),0L,1L}},{{0x943C640EL,0L,0L,0x943C640EL},{0L,(-2L),3L,0xA09C70FCL},{0x524DF1CFL,0x14609EC5L,0xA09C70FCL,0L},{0xA09C70FCL,0L,0x6AB62EF8L,0L},{0L,0x14609EC5L,(-1L),0xA09C70FCL},{0xD356672AL,(-2L),0L,0x943C640EL}},{{(-1L),0L,1L,1L},{(-1L),(-1L),0L,0L},{0xD356672AL,1L,(-1L),(-2L)},{0L,0x524DF1CFL,0x6AB62EF8L,(-1L)},{0xA09C70FCL,0x524DF1CFL,0xA09C70FCL,(-2L)},{0x524DF1CFL,1L,3L,0L}},{{0L,(-1L),0L,1L},{0x943C640EL,0L,0L,0x943C640EL},{0L,(-2L),3L,0xA09C70FCL},{0x524DF1CFL,0x14609EC5L,0xA09C70FCL,0L},{0xA09C70FCL,0L,0x6AB62EF8L,0L},{0L,0x14609EC5L,(-1L),0xA09C70FCL}},{{0xD356672AL,(-2L),0L,0x943C640EL},{(-1L),0L,1L,1L},{(-1L),(-1L),0L,0L},{0xD356672AL,1L,(-1L),(-2L)},{0L,0x524DF1CFL,0x6AB62EF8L,(-1L)},{0xA09C70FCL,0x524DF1CFL,0xA09C70FCL,(-2L)}},{{0x524DF1CFL,1L,3L,0L},{0L,(-1L),0L,1L},{0x943C640EL,0L,0L,0x943C640EL},{0L,(-2L),3L,0xA09C70FCL},{0x524DF1CFL,0x14609EC5L,0xA09C70FCL,0L},{0xA09C70FCL,0x524DF1CFL,0xD356672AL,0x524DF1CFL}},{{0x943C640EL,3L,0L,1L},{0xA09C70FCL,0x14609EC5L,0x524DF1CFL,(-1L)},{0L,0x943C640EL,0L,0L},{0L,0L,0x524DF1CFL,(-2L)},{0xA09C70FCL,0L,0L,0x14609EC5L},{0x943C640EL,0L,0xD356672AL,0L}},{{1L,0L,1L,0x14609EC5L},{0L,0L,0x6AB62EF8L,(-2L)},{(-2L),0L,0x943C640EL,0L},{(-1L),0x943C640EL,0x943C640EL,(-1L)},{(-2L),0x14609EC5L,0x6AB62EF8L,1L},{0L,3L,1L,0x524DF1CFL}}};
    int i, j, k;
    for (i = 0; i < 2; i = i + 1)
        l_912[i] = (-0x1.4p+1);
    for (l_37 = 0; (l_37 <= 2); l_37 += 1)
    { /* block id: 39 */
        uint32_t l_38 = 1UL;
        float l_44[6] = {0x2.9p+1,0x2.9p+1,0x2.9p+1,0x2.9p+1,0x2.9p+1,0x2.9p+1};
        float * const l_43[10] = {&l_44[2],&l_44[2],&l_44[2],&l_44[2],&l_44[2],&l_44[2],&l_44[2],&l_44[2],&l_44[2],&l_44[2]};
        int32_t l_48 = 9L;
        struct S2 ***l_902[4];
        struct S2 ****l_901 = &l_902[0];
        struct S2 *****l_900 = &l_901;
        struct S1 *l_917 = &l_914;
        float *l_918 = &l_912[1];
        const int32_t *l_920 = &l_48;
        const int32_t **l_919 = &l_920;
        uint32_t l_921 = 0UL;
        int i;
        for (i = 0; i < 4; i = i + 1)
            l_902[i] = (void*)0;
        if (l_38)
        { /* block id: 40 */
            for (l_38 = 0; (l_38 <= 2); l_38 += 1)
            { /* block id: 43 */
                float l_40 = 0x7.F73980p-50;
                float *l_39 = &l_40;
                (*l_39) = l_37;
                return l_38;
            }
        }
        else
        { /* block id: 47 */
            float l_42 = 0x7.8p-1;
            float *l_41[8] = {&l_42,&l_42,&l_42,&l_42,&l_42,&l_42,&l_42,&l_42};
            int32_t l_47[10][5][2] = {{{0xA9286DF4L,0x6C79A83AL},{0L,0x34C2E397L},{0x38D03D8EL,1L},{(-1L),0x9B1000BAL},{0x6C79A83AL,(-10L)}},{{0x54824FF2L,0xCA6696B4L},{0xF3A6950EL,0xF3A6950EL},{0x38D03D8EL,0x6C79A83AL},{0L,0xFCF39588L},{0xCA6696B4L,(-1L)}},{{(-1L),0xCA6696B4L},{0x34C2E397L,0L},{0x34C2E397L,0xCA6696B4L},{(-1L),(-1L)},{0xCA6696B4L,0xFCF39588L}},{{0L,0x6C79A83AL},{0x38D03D8EL,0xF3A6950EL},{0xF3A6950EL,0xCA6696B4L},{0x54824FF2L,(-10L)},{0x6C79A83AL,0x9B1000BAL}},{{(-1L),1L},{0x38D03D8EL,0x34C2E397L},{0L,0x6C79A83AL},{0xA9286DF4L,(-1L)},{1L,0x9B1000BAL}},{{0x54824FF2L,0x7338D581L},{0x34C2E397L,0x38D03D8EL},{0xF3A6950EL,1L},{0xA9286DF4L,0xFCF39588L},{0x7338D581L,0xFCF39588L}},{{0xA9286DF4L,1L},{0xF3A6950EL,0x38D03D8EL},{0x34C2E397L,0x7338D581L},{0x54824FF2L,0x9B1000BAL},{1L,(-1L)}},{{0xA9286DF4L,0x6C79A83AL},{0L,0x34C2E397L},{0x38D03D8EL,1L},{(-1L),0x9B1000BAL},{0x6C79A83AL,(-10L)}},{{0x54824FF2L,0xCA6696B4L},{0xF3A6950EL,0xF3A6950EL},{0x38D03D8EL,0x6C79A83AL},{0L,0xFCF39588L},{0xCA6696B4L,(-1L)}},{{(-1L),0xCA6696B4L},{0x34C2E397L,0L},{0x34C2E397L,0xCA6696B4L},{(-1L),(-1L)},{0xCA6696B4L,0xFCF39588L}}};
            struct S1 *l_897 = (void*)0;
            struct S1 l_899 = {0xEAF1L};
            struct S1 *l_898 = &l_899;
            const struct S2 l_910 = {120,13,1882,-1330,-1611,67,0x28B92421L};
            int32_t *l_916[10] = {&l_47[1][2][0],&l_47[1][2][0],&l_47[1][2][0],&l_47[1][2][0],&l_47[1][2][0],&l_47[1][2][0],&l_47[1][2][0],&l_47[1][2][0],&l_47[1][2][0],&l_47[1][2][0]};
            int32_t **l_915 = &l_916[6];
            int i, j, k;
            if ((l_41[4] != l_43[6]))
            { /* block id: 48 */
                int32_t l_46 = (-3L);
                int32_t *l_45[8] = {&l_46,&l_46,&l_46,&l_46,&l_46,&l_46,&l_46,&l_46};
                int i;
                l_47[1][2][0] = l_38;
                l_48 = l_38;
            }
            else
            { /* block id: 51 */
                int32_t *l_51 = &l_37;
                int32_t *l_890 = &l_37;
                struct S2 l_892 = {5864,12,854,305,1190,-86,1UL};
                struct S2 *l_891 = &l_892;
                for (l_48 = 0; (l_48 <= 2); l_48 += 1)
                { /* block id: 54 */
                    int32_t **l_885 = &l_51;
                    for (l_38 = 0; (l_38 <= 2); l_38 += 1)
                    { /* block id: 57 */
                        return l_37;
                    }
                    (*l_885) = func_49(l_51);
                    for (l_38 = 0; (l_38 <= 2); l_38 += 1)
                    { /* block id: 784 */
                        struct S2 l_887[3][1] = {{{13035,14,1697,-1273,-1044,-44,0x66C73404L}},{{13035,14,1697,-1273,-1044,-44,0x66C73404L}},{{13035,14,1697,-1273,-1044,-44,0x66C73404L}}};
                        struct S2 * const l_886 = &l_887[2][0];
                        struct S2 *l_889[3][8];
                        struct S2 **l_888 = &l_889[1][5];
                        int i, j;
                        for (i = 0; i < 3; i = i + 1)
                        {
                            for (j = 0; j < 8; j = j + 1)
                                l_889[i][j] = (void*)0;
                        }
                        (*l_888) = l_886;
                        /* statement id: 785 */
                        //assert ((l_889[0][0] >= &l_887[0][0] && l_889[0][0] <= &l_887[2][0]) || l_889[0][0] == 0);
                        (*l_885) = (void*)0;
                        /* statement id: 786 */
                        assert (l_51 == 0);
                        (*l_885) = l_890;
                        /* statement id: 787 */
                        assert (l_51 == &l_37);
                    }
                }
                l_47[1][2][0] = (l_891 == (void*)0);
                l_48 = (((((uint16_t)65535UL + (uint16_t)l_48) | (0xA2F0L | l_37)) != (*l_51)) | __builtin_popcountl(l_47[5][4][1]));
            }
            (*l_898) = func_82((l_48 > ((uint32_t)l_47[9][4][1] % (uint32_t)(l_48 && 0x7FD8L))), l_37);
            l_900 = l_900;
            (*l_915) = func_61(func_49(func_55(__builtin_clz(((int16_t)((int16_t)func_90(l_907) << (int16_t)l_48) - (int16_t)((int16_t)func_90(l_910) % (int16_t)l_910.f5))), l_907.f5, &l_48, l_911)), l_913, l_910.f2, &l_48, l_910.f5);
            /* statement id: 795 */
            //assert (l_916[0] == &l_48 || l_916[0] == 0 || (l_916[0] >= &l_47[0][0][0] && l_916[0] <= &l_47[9][4][1]));
        }
        (*l_919) = func_70(&l_48, (((l_907.f6 >= __builtin_ctzll(l_38)) && l_907.f3) == (l_907.f2 == l_48)), l_917, l_918);
        /* statement id: 797 */
        assert ((l_920 >= &l_912[0] && l_920 <= &l_912[1]));
        for (l_38 = 0; (l_38 <= 2); l_38 += 1)
        { /* block id: 800 */
            uint16_t l_922 = 0x0DBCL;
            (*l_918) = l_921;
            if (l_907.f4)
                break;
            for (l_914.f0 = 2; (l_914.f0 >= 0); l_914.f0 -= 1)
            { /* block id: 805 */
                int32_t l_925 = 0xF2E679FDL;
                int32_t *l_926 = (void*)0;
                if (l_922)
                    break;
                l_925 = (((uint16_t)(**l_919) / (uint16_t)(*l_920)) & __builtin_bswap32((l_925 <= 0L)));
            }
        }
    }
    (*l_913) = (*l_913);
    (*l_927) = l_914.f0;
    for (l_37 = 0; l_37 < 2; l_37 += 1)
    {
        l_912[l_37] = 0x1.Ap-1;
    }
    return l_928[0][1][3];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_49(int32_t * p_50)
{ /* block id: 60 */
    uint32_t l_60 = 0x16A45A29L;
    float l_78 = 0xE.4BF019p+89;
    float *l_77[8] = {&l_78,&l_78,&l_78,&l_78,&l_78,&l_78,&l_78,&l_78};
    struct S1 l_80 = {-7L};
    struct S1 *l_79[8][2] = {{&l_80,&l_80},{&l_80,&l_80},{&l_80,&l_80},{&l_80,&l_80},{&l_80,&l_80},{&l_80,&l_80},{&l_80,&l_80},{&l_80,&l_80}};
    float *l_81 = &l_78;
    const struct S1 *l_884 = &l_80;
    const struct S1 **l_883 = &l_884;
    int i, j;
    (*l_883) = func_52(func_55(l_60, ((void*)0 != p_50), func_61(func_67(func_70(p_50, ((int32_t)(l_77[4] == p_50) + (int32_t)l_60), l_79[3][0], l_81), (*p_50)), l_79[5][1], l_60, p_50, l_60), p_50), l_79[3][0]);
    return p_50;
    /* statement id: 780 */
    //assert (func_49_rv == &l_37 || func_49_rv == &l_48);
}


/* ------------------------------------------ */
/* 
 * reads : l_37 l_48
 * writes:
 */
static struct S1 * func_52(float * p_53, struct S1 * p_54)
{ /* block id: 599 */
    const struct S2 l_702 = {15733,10,1986,-297,747,12,18446744073709551606UL};
    uint32_t l_703 = 0x79408B1BL;
    int32_t l_710[2][2][4] = {{{0x7A1FE74BL,0x7A1FE74BL,0L,0xA55814CFL},{0xA55814CFL,0L,0L,0L}},{{0x7A1FE74BL,4L,1L,0L},{0L,4L,4L,0L}}};
    const int32_t *l_709[7] = {&l_710[0][1][3],&l_710[0][1][3],&l_710[0][1][3],&l_710[0][1][3],&l_710[0][1][3],&l_710[0][1][3],&l_710[0][1][3]};
    const int32_t **l_708 = &l_709[6];
    float l_716[5];
    float *l_715 = &l_716[0];
    struct S2 l_720 = {8776,1,1852,-413,33,65,18446744073709551613UL};
    struct S2 *l_719 = &l_720;
    struct S1 l_756 = {0x6D4DL};
    struct S1 *l_755 = &l_756;
    struct S0 *l_773 = (void*)0;
    int16_t l_859 = 0xA9C3L;
    float *l_869 = &l_716[0];
    int i, j, k;
    for (i = 0; i < 5; i = i + 1)
        l_716[i] = 0xC.719C6Cp-89;
    l_710[1][0][1] = ((func_90(l_702) & l_703) & __builtin_popcountl(((int16_t)(((int32_t)0xF81534ACL + (int32_t)(((void*)0 != l_708) != ((int16_t)func_90(l_702) * (int16_t)(((((int16_t)((**l_708) <= (**l_708)) / (int16_t)0xCC4DL) || (**l_708)) < (**l_708)) != (-8L))))) || (**l_708)) >> (int16_t)(**l_708))));
    (*l_715) = __builtin_ffsll((**l_708));
    for (l_703 = 0; (l_703 <= 6); l_703 += 1)
    { /* block id: 604 */
        struct S2 l_718 = {15275,13,1083,552,54,-84,7UL};
        struct S2 *l_717 = &l_718;
        struct S0 l_772 = {752,-8,27,2,2690,234};
        struct S0 *l_771 = &l_772;
        int32_t *l_777 = &l_710[1][1][1];
        int32_t **l_776 = &l_777;
        int32_t ***l_775 = &l_776;
        struct S1 *l_815 = &l_756;
        int32_t l_868 = 0x3C16C33BL;
        l_719 = l_717;
        /* statement id: 605 */
        assert (l_719 == &l_718);
        (*l_715) = (*p_53);
        for (l_718.f6 = 0; (l_718.f6 <= 6); l_718.f6 += 1)
        { /* block id: 609 */
            uint32_t l_738 = 0xA5ABDA1FL;
            int32_t ***l_774 = (void*)0;
            int32_t l_801 = 1L;
            struct S1 l_811 = {-1L};
            for (l_720.f6 = 0; (l_720.f6 <= 1); l_720.f6 += 1)
            { /* block id: 612 */
                int32_t l_721 = 0L;
                for (l_721 = 1; (l_721 <= 4); l_721 += 1)
                { /* block id: 615 */
                    int32_t l_722 = 0x736FACC7L;
                    int32_t l_732 = 1L;
                    for (l_722 = 4; (l_722 >= 0); l_722 -= 1)
                    { /* block id: 618 */
                        int32_t *l_737 = (void*)0;
                        int i, j, k;
                        l_710[l_720.f6][l_720.f6][(l_720.f6 + 1)] = ((l_710[l_720.f6][l_720.f6][l_720.f6] ^ __builtin_parity(l_718.f0)) || l_718.f0);
                        l_709[l_703] = p_53;
                        (*p_54) = func_82(((uint16_t)l_722 / (uint16_t)(__builtin_clzll(l_722) && ((int16_t)(!l_722) >> (int16_t)((uint32_t)((uint16_t)l_732 >> (uint16_t)(-(uint16_t)l_718.f0)) % (uint32_t)(l_718.f6 || 8L))))), (((uint32_t)(l_732 == l_722) - (uint32_t)0xF116C491L) <= l_721));
                        l_738 = ((~__builtin_ctzll(l_721)) > 4L);
                    }
                }
            }
        }
        for (l_756.f0 = 0; (l_756.f0 <= 6); l_756.f0 += 1)
        { /* block id: 705 */
            const struct S0 *l_813[5];
            struct S0 **l_814 = &l_771;
            int32_t l_824 = 0x2D237C0AL;
            struct S1 *l_846 = &l_756;
            struct S0 l_856[6][5] = {{{7469,-2,72,-2,735,4465},{2312,-3,61,-3,1158,1475},{-5773,6,27,4,1408,4381},{-5773,6,27,4,1408,4381},{2312,-3,61,-3,1158,1475}},{{-7843,-0,77,-3,-1664,4418},{-5433,-5,61,-2,-1138,3425},{-6931,4,76,3,849,859},{-6931,4,76,3,849,859},{-5433,-5,61,-2,-1138,3425}},{{7469,-2,72,-2,735,4465},{2312,-3,61,-3,1158,1475},{-5773,6,27,4,1408,4381},{-5773,6,27,4,1408,4381},{2312,-3,61,-3,1158,1475}},{{-7843,-0,77,-3,-1664,4418},{-5433,-5,61,-2,-1138,3425},{-6931,4,76,3,849,859},{-6931,4,76,3,849,859},{-5433,-5,61,-2,-1138,3425}},{{7469,-2,72,-2,735,4465},{2312,-3,61,-3,1158,1475},{-5773,6,27,4,1408,4381},{-5773,6,27,4,1408,4381},{2312,-3,61,-3,1158,1475}},{{-7843,-0,77,-3,-1664,4418},{-5433,-5,61,-2,-1138,3425},{-6931,4,76,3,849,859},{-6931,4,76,3,849,859},{-5433,-5,61,-2,-1138,3425}}};
            int32_t ***l_878 = &l_776;
            int i, j;
            for (i = 0; i < 5; i = i + 1)
                l_813[i] = &l_772;
            (*l_814) = l_813[1];
            for (l_720.f6 = 0; (l_720.f6 <= 4); l_720.f6 += 1)
            { /* block id: 709 */
                (**l_814) = (*l_771);
                return p_54;
                /* statement id: 711 */
                //assert (func_52_rv == &l_80);
            }
        }
    }
    /* facts after for loop */
    //assert (l_709[0] == &l_37 || l_709[0] == &l_78 || (l_709[0] >= &l_710[0][0][0] && l_709[0] <= &l_710[1][1][3]) || l_709[0] == &l_48);
    //assert (l_719 == dangling || l_719 == &l_720);
    (*l_755) = (*l_755);
    return p_54;
    /* statement id: 778 */
    //assert (func_52_rv == &l_80);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_55(int32_t  p_56, int32_t  p_57, int32_t * p_58, float * p_59)
{ /* block id: 597 */
    float l_700 = 0x8.D4EF9Fp-59;
    float *l_699[2][8] = {{&l_700,&l_700,&l_700,&l_700,&l_700,&l_700,&l_700,&l_700},{&l_700,&l_700,&l_700,&l_700,&l_700,&l_700,&l_700,&l_700}};
    float *l_701[3];
    int i, j;
    for (i = 0; i < 3; i = i + 1)
        l_701[i] = &l_700;
    return p_58;
    /* statement id: 598 */
    //assert (func_55_rv == &l_37 || func_55_rv == &l_78 || func_55_rv == &l_48);
}


/* ------------------------------------------ */
/* 
 * reads : l_37 l_48
 * writes:
 */
static int32_t * func_61(float * p_62, struct S1 * p_63, uint16_t  p_64, int32_t * p_65, uint32_t  p_66)
{ /* block id: 511 */
    struct S0 l_598[4] = {{5949,-9,1,1,981,5508},{5949,-9,1,1,981,5508},{5949,-9,1,1,981,5508},{5949,-9,1,1,981,5508}};
    int32_t l_602 = 0L;
    struct S1 *l_614 = (void*)0;
    struct S1 **l_613[1];
    struct S1 ***l_612 = &l_613[0];
    struct S1 ****l_611[9][2] = {{&l_612,&l_612},{&l_612,&l_612},{&l_612,&l_612},{&l_612,&l_612},{&l_612,&l_612},{&l_612,&l_612},{&l_612,&l_612},{&l_612,&l_612},{&l_612,&l_612}};
    struct S1 l_643 = {0xAA9DL};
    struct S1 *l_642 = &l_643;
    const struct S0 *l_650[7];
    const struct S0 * const *l_649 = &l_650[4];
    const struct S0 * const ** const l_648 = &l_649;
    const struct S0 * const ** const *l_647 = &l_648;
    int i, j;
    for (i = 0; i < 1; i = i + 1)
        l_613[i] = &l_614;
    for (i = 0; i < 7; i = i + 1)
        l_650[i] = &l_598[1];
    for (p_64 = 0; (p_64 <= 3); p_64 += 1)
    { /* block id: 514 */
        int32_t l_601 = 0x5593A567L;
        int32_t *l_600 = &l_601;
        int32_t **l_599 = &l_600;
        struct S1 * const **l_622 = (void*)0;
        struct S1 * const ***l_621 = &l_622;
        struct S1 *l_676 = (void*)0;
        (*l_599) = p_62;
        /* statement id: 515 */
        //assert (l_600 == &l_78 || l_600 == &l_48);
        if (l_602)
            continue;
        if ((((((*l_600) ^ __builtin_popcountll(p_64)) != ((int16_t)p_64 >> (int16_t)2)) > l_602) & p_66))
        { /* block id: 517 */
            struct S1 l_607 = {0x9934L};
            struct S1 *l_606 = &l_607;
            struct S1 **l_605[8][4][3] = {{{&l_606,&l_606,(void*)0},{&l_606,&l_606,(void*)0},{&l_606,&l_606,&l_606},{(void*)0,&l_606,&l_606}},{{(void*)0,&l_606,&l_606},{&l_606,&l_606,(void*)0},{(void*)0,(void*)0,&l_606},{&l_606,&l_606,&l_606}},{{(void*)0,&l_606,&l_606},{(void*)0,&l_606,&l_606},{&l_606,(void*)0,&l_606},{&l_606,&l_606,&l_606}},{{&l_606,(void*)0,&l_606},{(void*)0,&l_606,(void*)0},{&l_606,(void*)0,&l_606},{&l_606,&l_606,&l_606}},{{&l_606,(void*)0,&l_606},{&l_606,&l_606,(void*)0},{&l_606,&l_606,(void*)0},{&l_606,&l_606,&l_606}},{{&l_606,(void*)0,(void*)0},{(void*)0,&l_606,&l_606},{&l_606,&l_606,(void*)0},{&l_606,&l_606,&l_606}},{{(void*)0,&l_606,(void*)0},{&l_606,&l_606,(void*)0},{&l_606,&l_606,&l_606},{&l_606,&l_606,&l_606}},{{&l_606,&l_606,(void*)0},{&l_606,&l_606,&l_606},{&l_606,(void*)0,&l_606},{&l_606,&l_606,&l_606}}};
            struct S1 ***l_610 = &l_605[7][0][1];
            struct S1 ****l_609 = &l_610;
            int i, j, k;
            for (l_601 = 0; (l_601 <= 3); l_601 += 1)
            { /* block id: 520 */
                for (p_66 = 0; (p_66 <= 3); p_66 += 1)
                { /* block id: 523 */
                    struct S1 ***l_608 = &l_605[2][2][1];
                    (*l_608) = l_605[0][3][0];
                    return p_62;
                    /* statement id: 525 */
                    //assert (func_61_rv == &l_78 || func_61_rv == &l_48);
                }
                l_611[0][0] = l_609;
            }
            /* facts after for loop */
            //assert (l_611[0][0] == &l_610 || l_611[0][0] == 0 || l_611[0][0] == &l_612 || l_611[0][0] == dangling);
        }
        else
        { /* block id: 529 */
            struct S0 *l_655 = &l_598[0];
            struct S0 **l_654 = &l_655;
            struct S0 *** const l_653 = &l_654;
            struct S0 *** const *l_652 = &l_653;
            struct S0 *** const ** const l_651 = &l_652;
            int32_t l_658 = (-6L);
            (**l_599) = (*p_65);
            for (p_66 = 0; (p_66 <= 3); p_66 += 1)
            { /* block id: 533 */
                const float l_627 = 0x1.Bp+1;
                struct S0 *l_633 = &l_598[1];
                struct S0 **l_632 = &l_633;
                struct S1 l_678 = {-9L};
                int32_t *l_681 = &l_601;
                (**l_599) = (((uint16_t)((int16_t)(((int16_t)(**l_599) - (int16_t)((void*)0 != l_621)) & ((int32_t)((int16_t)l_602 * (int16_t)(0x2F64F399L || (*p_65))) - (int32_t)p_66)) >> (int16_t)6) >> (uint16_t)((*p_65) ^ (((int16_t)((int16_t)(((*p_65) & p_66) != (-9L)) + (int16_t)p_64) - (int16_t)0x71EAL) && (*p_65)))) > (-1L));
                if ((*l_600))
                { /* block id: 535 */
                    struct S0 ***l_634 = &l_632;
                    int32_t *l_635 = &l_602;
                    (*l_634) = l_632;
                    return p_62;
                    /* statement id: 537 */
                    //assert (func_61_rv == &l_78 || func_61_rv == &l_48);
                }
                else
                { /* block id: 538 */
                    (*l_599) = p_62;
                    /* statement id: 539 */
                    //assert (l_600 == &l_78 || l_600 == &l_48);
                    (*p_62) = l_602;
                    (**l_612) = (void*)0;
                }
                /* facts after branching */
                //assert (l_600 == &l_78 || l_600 == &l_48);
                for (l_601 = 0; (l_601 <= 3); l_601 += 1)
                { /* block id: 545 */
                    struct S0 ***l_637[5];
                    struct S0 **** const l_636 = &l_637[2];
                    struct S0 l_644 = {-4758,-4,54,-4,248,5052};
                    int i;
                    for (i = 0; i < 5; i = i + 1)
                        l_637[i] = &l_632;
                    for (l_602 = 0; (l_602 <= 3); l_602 += 1)
                    { /* block id: 548 */
                        struct S0 ****l_639 = &l_637[3];
                        struct S0 *****l_638 = &l_639;
                        const int32_t *l_640 = &l_602;
                        int32_t **l_641 = &l_600;
                        (*l_638) = l_636;
                        (*l_641) = l_640;
                        /* statement id: 550 */
                        assert (l_600 == &l_602);
                    }
                    l_642 = p_63;
                    /* statement id: 552 */
                    //assert (l_642 == &l_80 || l_642 == &l_914);
                    l_598[p_66] = l_644;
                }
                /* facts after for loop */
                //assert (l_600 == &l_602 || l_600 == &l_78 || l_600 == &l_48);
                if (((l_647 == (void*)0) | (l_651 != &l_652)))
                { /* block id: 555 */
                    struct S2 l_662[5][8][6] = {{{{4065,9,930,751,-976,64,0x93B0BB7EL},{2671,15,637,978,1906,0,0xCE68F8E5L},{835,2,318,476,435,4,0x48899227L},{1587,15,528,-144,-1180,-38,0x67AC3D79L},{835,2,318,476,435,4,0x48899227L},{2671,15,637,978,1906,0,0xCE68F8E5L}},{{12032,15,236,-748,-299,-26,0x144BAA01L},{14139,13,1891,1447,-1711,41,0x118D152BL},{7828,6,297,-538,1159,67,0UL},{11747,10,1889,-241,1341,85,0x3D6B8D8EL},{1355,5,432,344,1948,-64,18446744073709551615UL},{1511,1,286,-505,-1091,-6,18446744073709551606UL}},{{12964,7,427,-532,1649,89,3UL},{3457,14,1144,1388,1590,-57,0x42E79C25L},{9707,10,1431,354,1408,57,0UL},{14061,11,1925,27,1908,-70,0x37CBDCF3L},{1637,8,84,1217,-497,52,18446744073709551615UL},{12805,9,1297,1277,934,55,18446744073709551609UL}},{{14014,0,414,590,1641,37,0xA9F08262L},{3457,14,1144,1388,1590,-57,0x42E79C25L},{513,9,1292,-1347,-1610,-54,0xF51782F0L},{2786,5,1449,-747,1805,87,6UL},{1355,5,432,344,1948,-64,18446744073709551615UL},{4065,9,930,751,-976,64,0x93B0BB7EL}},{{14306,12,1794,-140,-2008,-68,0x224A557DL},{14139,13,1891,1447,-1711,41,0x118D152BL},{13142,14,768,312,573,46,0x5ECFBEB2L},{7828,6,297,-538,1159,67,0UL},{835,2,318,476,435,4,0x48899227L},{9707,10,1431,354,1408,57,0UL}},{{2714,2,1523,666,-1035,-53,1UL},{2671,15,637,978,1906,0,0xCE68F8E5L},{15416,12,528,845,1923,76,1UL},{3457,14,1144,1388,1590,-57,0x42E79C25L},{4065,9,930,751,-976,64,0x93B0BB7EL},{835,2,318,476,435,4,0x48899227L}},{{14788,1,210,-752,998,19,1UL},{3359,14,1141,770,-940,-76,0xF6A1F299L},{11747,10,1889,-241,1341,85,0x3D6B8D8EL},{8570,8,1007,-485,-659,-74,0x056A8F8FL},{12964,7,427,-532,1649,89,3UL},{2786,5,1449,-747,1805,87,6UL}},{{14139,13,1891,1447,-1711,41,0x118D152BL},{2786,5,1449,-747,1805,87,6UL},{15702,5,310,1030,-1151,9,0x67FA6A8FL},{15702,5,310,1030,-1151,9,0x67FA6A8FL},{2786,5,1449,-747,1805,87,6UL},{14139,13,1891,1447,-1711,41,0x118D152BL}}},{{{10057,2,90,-783,-1576,-57,0xC294BD45L},{12805,9,1297,1277,934,55,18446744073709551609UL},{3359,14,1141,770,-940,-76,0xF6A1F299L},{14306,12,1794,-140,-2008,-68,0x224A557DL},{791,13,1218,-271,100,-7,0xBF36417FL},{12032,15,236,-748,-299,-26,0x144BAA01L}},{{1355,5,432,344,1948,-64,18446744073709551615UL},{9942,3,77,863,1209,10,0xF9DB931BL},{14014,0,414,590,1641,37,0xA9F08262L},{5876,1,835,1226,-1679,84,0x30555440L},{1477,11,199,900,1289,52,18446744073709551615UL},{4707,11,1952,-822,1208,89,0xAFE4EF1DL}},{{1355,5,432,344,1948,-64,18446744073709551615UL},{6885,15,2016,1297,783,-11,18446744073709551610UL},{5876,1,835,1226,-1679,84,0x30555440L},{14306,12,1794,-140,-2008,-68,0x224A557DL},{8469,0,869,-250,2018,-50,0xE305F968L},{9942,3,77,863,1209,10,0xF9DB931BL}},{{10057,2,90,-783,-1576,-57,0xC294BD45L},{791,13,1218,-271,100,-7,0xBF36417FL},{1476,14,322,444,-1255,57,1UL},{15702,5,310,1030,-1151,9,0x67FA6A8FL},{513,9,1292,-1347,-1610,-54,0xF51782F0L},{7787,6,1903,-1040,-1260,53,1UL}},{{14139,13,1891,1447,-1711,41,0x118D152BL},{14788,1,210,-752,998,19,1UL},{9001,5,1277,-292,-1462,37,0xDC2CBAEEL},{8570,8,1007,-485,-659,-74,0x056A8F8FL},{4707,11,1952,-822,1208,89,0xAFE4EF1DL},{1587,15,528,-144,-1180,-38,0x67AC3D79L}},{{14788,1,210,-752,998,19,1UL},{15416,12,528,845,1923,76,1UL},{10057,2,90,-783,-1576,-57,0xC294BD45L},{3457,14,1144,1388,1590,-57,0x42E79C25L},{8570,8,1007,-485,-659,-74,0x056A8F8FL},{8469,0,869,-250,2018,-50,0xE305F968L}},{{2714,2,1523,666,-1035,-53,1UL},{7828,6,297,-538,1159,67,0UL},{8570,8,1007,-485,-659,-74,0x056A8F8FL},{7828,6,297,-538,1159,67,0UL},{2714,2,1523,666,-1035,-53,1UL},{1476,14,322,444,-1255,57,1UL}},{{14306,12,1794,-140,-2008,-68,0x224A557DL},{14061,11,1925,27,1908,-70,0x37CBDCF3L},{791,13,1218,-271,100,-7,0xBF36417FL},{2786,5,1449,-747,1805,87,6UL},{3457,14,1144,1388,1590,-57,0x42E79C25L},{3359,14,1141,770,-940,-76,0xF6A1F299L}}},{{{14014,0,414,590,1641,37,0xA9F08262L},{8469,0,869,-250,2018,-50,0xE305F968L},{12805,9,1297,1277,934,55,18446744073709551609UL},{14061,11,1925,27,1908,-70,0x37CBDCF3L},{12032,15,236,-748,-299,-26,0x144BAA01L},{3359,14,1141,770,-940,-76,0xF6A1F299L}},{{12964,7,427,-532,1649,89,3UL},{9001,5,1277,-292,-1462,37,0xDC2CBAEEL},{791,13,1218,-271,100,-7,0xBF36417FL},{11747,10,1889,-241,1341,85,0x3D6B8D8EL},{6885,15,2016,1297,783,-11,18446744073709551610UL},{1476,14,322,444,-1255,57,1UL}},{{12032,15,236,-748,-299,-26,0x144BAA01L},{513,9,1292,-1347,-1610,-54,0xF51782F0L},{8570,8,1007,-485,-659,-74,0x056A8F8FL},{1587,15,528,-144,-1180,-38,0x67AC3D79L},{9001,5,1277,-292,-1462,37,0xDC2CBAEEL},{8469,0,869,-250,2018,-50,0xE305F968L}},{{4065,9,930,751,-976,64,0x93B0BB7EL},{14306,12,1794,-140,-2008,-68,0x224A557DL},{10057,2,90,-783,-1576,-57,0xC294BD45L},{14139,13,1891,1447,-1711,41,0x118D152BL},{14014,0,414,590,1641,37,0xA9F08262L},{1587,15,528,-144,-1180,-38,0x67AC3D79L}},{{1587,15,528,-144,-1180,-38,0x67AC3D79L},{11060,0,1412,-1281,476,2,0xD71DE4F4L},{9001,5,1277,-292,-1462,37,0xDC2CBAEEL},{2365,15,668,-933,903,64,0x1F2B0B24L},{7787,6,1903,-1040,-1260,53,1UL},{7787,6,1903,-1040,-1260,53,1UL}},{{9001,5,1277,-292,-1462,37,0xDC2CBAEEL},{1476,14,322,444,-1255,57,1UL},{1476,14,322,444,-1255,57,1UL},{9001,5,1277,-292,-1462,37,0xDC2CBAEEL},{15416,12,528,845,1923,76,1UL},{9942,3,77,863,1209,10,0xF9DB931BL}},{{15702,5,310,1030,-1151,9,0x67FA6A8FL},{12964,7,427,-532,1649,89,3UL},{5876,1,835,1226,-1679,84,0x30555440L},{12805,9,1297,1277,934,55,18446744073709551609UL},{14306,12,1794,-140,-2008,-68,0x224A557DL},{4707,11,1952,-822,1208,89,0xAFE4EF1DL}},{{1476,14,322,444,-1255,57,1UL},{13142,14,768,312,573,46,0x5ECFBEB2L},{14014,0,414,590,1641,37,0xA9F08262L},{2714,2,1523,666,-1035,-53,1UL},{14306,12,1794,-140,-2008,-68,0x224A557DL},{12032,15,236,-748,-299,-26,0x144BAA01L}}},{{{9942,3,77,863,1209,10,0xF9DB931BL},{12964,7,427,-532,1649,89,3UL},{3359,14,1141,770,-940,-76,0xF6A1F299L},{4065,9,930,751,-976,64,0x93B0BB7EL},{15416,12,528,845,1923,76,1UL},{14139,13,1891,1447,-1711,41,0x118D152BL}},{{791,13,1218,-271,100,-7,0xBF36417FL},{1476,14,322,444,-1255,57,1UL},{15702,5,310,1030,-1151,9,0x67FA6A8FL},{513,9,1292,-1347,-1610,-54,0xF51782F0L},{7787,6,1903,-1040,-1260,53,1UL},{2786,5,1449,-747,1805,87,6UL}},{{256,0,1277,244,-445,-54,0xE3DE8B0CL},{11060,0,1412,-1281,476,2,0xD71DE4F4L},{11747,10,1889,-241,1341,85,0x3D6B8D8EL},{12032,15,236,-748,-299,-26,0x144BAA01L},{14014,0,414,590,1641,37,0xA9F08262L},{835,2,318,476,435,4,0x48899227L}},{{6885,15,2016,1297,783,-11,18446744073709551610UL},{14306,12,1794,-140,-2008,-68,0x224A557DL},{15416,12,528,845,1923,76,1UL},{3359,14,1141,770,-940,-76,0xF6A1F299L},{1355,5,432,344,1948,-64,18446744073709551615UL},{3359,14,1141,770,-940,-76,0xF6A1F299L}},{{9942,3,77,863,1209,10,0xF9DB931BL},{14306,12,1794,-140,-2008,-68,0x224A557DL},{9942,3,77,863,1209,10,0xF9DB931BL},{14788,1,210,-752,998,19,1UL},{2671,15,637,978,1906,0,0xCE68F8E5L},{1637,8,84,1217,-497,52,18446744073709551615UL}},{{10057,2,90,-783,-1576,-57,0xC294BD45L},{1355,5,432,344,1948,-64,18446744073709551615UL},{14306,12,1794,-140,-2008,-68,0x224A557DL},{2671,15,637,978,1906,0,0xCE68F8E5L},{8469,0,869,-250,2018,-50,0xE305F968L},{9707,10,1431,354,1408,57,0UL}},{{14014,0,414,590,1641,37,0xA9F08262L},{7828,6,297,-538,1159,67,0UL},{3359,14,1141,770,-940,-76,0xF6A1F299L},{2671,15,637,978,1906,0,0xCE68F8E5L},{7787,6,1903,-1040,-1260,53,1UL},{14788,1,210,-752,998,19,1UL}},{{10057,2,90,-783,-1576,-57,0xC294BD45L},{1587,15,528,-144,-1180,-38,0x67AC3D79L},{3457,14,1144,1388,1590,-57,0x42E79C25L},{14788,1,210,-752,998,19,1UL},{11747,10,1889,-241,1341,85,0x3D6B8D8EL},{14014,0,414,590,1641,37,0xA9F08262L}}},{{{9942,3,77,863,1209,10,0xF9DB931BL},{3457,14,1144,1388,1590,-57,0x42E79C25L},{791,13,1218,-271,100,-7,0xBF36417FL},{3359,14,1141,770,-940,-76,0xF6A1F299L},{5876,1,835,1226,-1679,84,0x30555440L},{15702,5,310,1030,-1151,9,0x67FA6A8FL}},{{2671,15,637,978,1906,0,0xCE68F8E5L},{11060,0,1412,-1281,476,2,0xD71DE4F4L},{2365,15,668,-933,903,64,0x1F2B0B24L},{8469,0,869,-250,2018,-50,0xE305F968L},{4065,9,930,751,-976,64,0x93B0BB7EL},{256,0,1277,244,-445,-54,0xE3DE8B0CL}},{{4707,11,1952,-822,1208,89,0xAFE4EF1DL},{835,2,318,476,435,4,0x48899227L},{1511,1,286,-505,-1091,-6,18446744073709551606UL},{14306,12,1794,-140,-2008,-68,0x224A557DL},{14306,12,1794,-140,-2008,-68,0x224A557DL},{1511,1,286,-505,-1091,-6,18446744073709551606UL}},{{256,0,1277,244,-445,-54,0xE3DE8B0CL},{256,0,1277,244,-445,-54,0xE3DE8B0CL},{4707,11,1952,-822,1208,89,0xAFE4EF1DL},{1637,8,84,1217,-497,52,18446744073709551615UL},{7828,6,297,-538,1159,67,0UL},{1476,14,322,444,-1255,57,1UL}},{{14061,11,1925,27,1908,-70,0x37CBDCF3L},{2671,15,637,978,1906,0,0xCE68F8E5L},{12964,7,427,-532,1649,89,3UL},{11747,10,1889,-241,1341,85,0x3D6B8D8EL},{513,9,1292,-1347,-1610,-54,0xF51782F0L},{4707,11,1952,-822,1208,89,0xAFE4EF1DL}},{{9001,5,1277,-292,-1462,37,0xDC2CBAEEL},{14061,11,1925,27,1908,-70,0x37CBDCF3L},{12964,7,427,-532,1649,89,3UL},{9707,10,1431,354,1408,57,0UL},{256,0,1277,244,-445,-54,0xE3DE8B0CL},{1476,14,322,444,-1255,57,1UL}},{{2786,5,1449,-747,1805,87,6UL},{9707,10,1431,354,1408,57,0UL},{4707,11,1952,-822,1208,89,0xAFE4EF1DL},{1355,5,432,344,1948,-64,18446744073709551615UL},{12964,7,427,-532,1649,89,3UL},{1511,1,286,-505,-1091,-6,18446744073709551606UL}},{{1355,5,432,344,1948,-64,18446744073709551615UL},{12964,7,427,-532,1649,89,3UL},{1511,1,286,-505,-1091,-6,18446744073709551606UL},{1476,14,322,444,-1255,57,1UL},{14139,13,1891,1447,-1711,41,0x118D152BL},{256,0,1277,244,-445,-54,0xE3DE8B0CL}}}};
                    struct S2 *l_661[1];
                    int i, j, k;
                    for (i = 0; i < 1; i = i + 1)
                        l_661[i] = &l_662[3][6][3];
                    for (l_602 = 12; (l_602 > (-27)); l_602 -= 1)
                    { /* block id: 558 */
                        if ((**l_599))
                            break;
                    }
                    (*l_642) = func_82(l_658, (*p_65));
                    for (l_602 = 0; (l_602 >= (-14)); l_602 -= 1)
                    { /* block id: 564 */
                        struct S2 **l_663 = &l_661[0];
                        int32_t *l_664 = &l_658;
                        (*l_663) = l_661[0];
                        return p_65;
                        /* statement id: 566 */
                        //assert (func_61_rv == &l_37 || func_61_rv == &l_48);
                    }
                    (*l_599) = func_67(p_62, ((int32_t)(((uint16_t)((uint16_t)65535UL * (uint16_t)(0L & 0x848BL)) / (uint16_t)p_64) >= ((uint16_t)0UL % (uint16_t)__builtin_ctz(p_66))) / (int32_t)((uint16_t)p_66 + (uint16_t)0UL)));
                    /* statement id: 568 */
                    //assert (l_600 == &l_78 || l_600 == &l_48);
                }
                else
                { /* block id: 569 */
                    for (l_658 = 1; (l_658 >= 0); l_658 -= 1)
                    { /* block id: 572 */
                        int32_t l_675 = 1L;
                        int32_t *l_677 = &l_602;
                        if (l_675)
                            break;
                        (*l_599) = l_677;
                        /* statement id: 574 */
                        assert (l_600 == &l_602);
                        l_678 = func_82(p_64, l_643.f0);
                        (*l_599) = p_62;
                        /* statement id: 576 */
                        //assert (l_600 == &l_78 || l_600 == &l_48);
                    }
                    for (l_678.f0 = 2; (l_678.f0 < 6); l_678.f0 += 7)
                    { /* block id: 580 */
                        int32_t *l_682[4];
                        int i;
                        for (i = 0; i < 4; i = i + 1)
                            l_682[i] = &l_602;
                        (*l_599) = (*l_599);
                        return p_65;
                        /* statement id: 582 */
                        //assert (func_61_rv == &l_37 || func_61_rv == &l_48);
                    }
                }
            }
            /* facts after for loop */
            //assert (l_600 == &l_602 || l_600 == &l_78 || l_600 == &l_48);
            (*p_63) = func_82(p_64, ((*l_600) || (p_64 > l_643.f0)));
        }
        /* facts after branching */
        //assert (l_600 == &l_602 || l_600 == &l_78 || l_600 == &l_48);
    }
    /* facts after for loop */
    //assert (l_611[0][0] == dangling || l_611[0][0] == 0 || l_611[0][0] == &l_612);
    //assert (l_642 == &l_80 || l_642 == &l_643 || l_642 == &l_914);
    p_65 = p_65;
    for (p_64 = 29; (p_64 >= 10); p_64 -= 4)
    { /* block id: 592 */
        int32_t l_696 = 0L;
        (*p_62) = ((float)(((-(float)((float)(*p_62) / (float)func_104((*p_62)))) <= ((((*p_62) >= ((float)((float)__builtin_parityl(l_696) / (float)((((float)(-0x2.9p-1) * (float)0x4.1DA055p+85) > (*p_62)) > 0x0.9p-1)) - (float)0x7.9D703Fp-74)) > 0xA.992549p-9) > 0x1.1p+1)) != l_696) / (float)l_602);
        l_598[3] = (***l_648);
    }
    return p_62;
    /* statement id: 596 */
    //assert (func_61_rv == &l_78 || func_61_rv == &l_48);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_67(float * p_68, int32_t  p_69)
{ /* block id: 509 */
    float l_597 = 0x6.FC049Ep+49;
    float *l_596 = &l_597;
    return p_68;
    /* statement id: 510 */
    //assert (func_67_rv == &l_78 || func_67_rv == &l_37 || (func_67_rv >= &l_716[0] && func_67_rv <= &l_716[4]) || func_67_rv == &l_48);
}


/* ------------------------------------------ */
/* 
 * reads : l_37 l_48
 * writes:
 */
static float * func_70(int32_t * const  p_71, int16_t  p_72, struct S1 * p_73, float * p_74)
{ /* block id: 61 */
    int32_t l_85 = 2L;
    float l_89 = 0x7.58758Ap+69;
    float *l_88 = &l_89;
    const struct S2 l_92 = {10555,8,844,-1094,-177,32,7UL};
    struct S1 l_394 = {0x4A2AL};
    const int32_t *l_486[1];
    struct S2 l_495 = {4106,5,1004,1256,-353,-53,0x56934976L};
    struct S2 * const l_494 = &l_495;
    struct S2 * const *l_493[1][9][7] = {{{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494},{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494},{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494},{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494},{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494},{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494},{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494},{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494},{&l_494,&l_494,&l_494,&l_494,&l_494,&l_494,&l_494}}};
    float ** const ***l_541 = (void*)0;
    float l_549 = 0x4.356C01p-32;
    int i, j, k;
    for (i = 0; i < 1; i = i + 1)
        l_486[i] = (void*)0;
    l_394 = func_82(l_85, ((uint16_t)p_72 >> (uint16_t)(((p_74 != l_88) != l_85) > (func_90(l_92) & (func_90(l_92) ^ 0xFCF7L)))));
    for (p_72 = (-23); (p_72 < (-1)); p_72 += 1)
    { /* block id: 369 */
        float * const *l_397 = &l_88;
        struct S0 l_400 = {2040,1,14,4,1686,2343};
        int32_t l_408 = (-1L);
        int32_t *l_407 = &l_408;
        struct S2 *l_505 = &l_495;
        struct S2 **l_504 = &l_505;
        struct S2 ***l_503 = &l_504;
        struct S2 ****l_502 = &l_503;
        struct S2 *****l_501 = &l_502;
        struct S1 l_588 = {-9L};
        if (__builtin_popcountl(p_72))
        { /* block id: 370 */
            uint16_t l_398[7] = {0x4D9FL,0x0542L,0x0542L,0x4D9FL,0x0542L,0x0542L,0x4D9FL};
            int32_t l_406 = 7L;
            int32_t *l_405 = &l_406;
            struct S2 l_417[4][2][4] = {{{{12826,10,501,-255,1264,-23,18446744073709551615UL},{15167,4,1736,852,961,-29,0xF31A1003L},{169,6,117,-1217,34,-12,18446744073709551614UL},{14833,9,1480,-820,1533,-78,0xE724AF6CL}},{{7948,13,639,868,1214,-50,0x7E46297CL},{9366,9,1584,-572,-889,-21,0x92F2680EL},{15167,4,1736,852,961,-29,0xF31A1003L},{15167,4,1736,852,961,-29,0xF31A1003L}}},{{{730,7,1135,-1390,1631,-22,0x92094387L},{730,7,1135,-1390,1631,-22,0x92094387L},{15167,4,1736,852,961,-29,0xF31A1003L},{4326,11,1113,-1289,2002,-60,18446744073709551615UL}},{{7948,13,639,868,1214,-50,0x7E46297CL},{7095,0,1422,-756,311,39,0x0B08B0A6L},{169,6,117,-1217,34,-12,18446744073709551614UL},{9366,9,1584,-572,-889,-21,0x92F2680EL}}},{{{12826,10,501,-255,1264,-23,18446744073709551615UL},{169,6,117,-1217,34,-12,18446744073709551614UL},{4326,11,1113,-1289,2002,-60,18446744073709551615UL},{169,6,117,-1217,34,-12,18446744073709551614UL}},{{4326,11,1113,-1289,2002,-60,18446744073709551615UL},{169,6,117,-1217,34,-12,18446744073709551614UL},{12826,10,501,-255,1264,-23,18446744073709551615UL},{9366,9,1584,-572,-889,-21,0x92F2680EL}}},{{{169,6,117,-1217,34,-12,18446744073709551614UL},{7095,0,1422,-756,311,39,0x0B08B0A6L},{7948,13,639,868,1214,-50,0x7E46297CL},{4326,11,1113,-1289,2002,-60,18446744073709551615UL}},{{15167,4,1736,852,961,-29,0xF31A1003L},{730,7,1135,-1390,1631,-22,0x92094387L},{730,7,1135,-1390,1631,-22,0x92094387L},{15167,4,1736,852,961,-29,0xF31A1003L}}}};
            struct S2 *l_416 = &l_417[2][0][3];
            int i, j, k;
            (**l_397) = (&p_74 != l_397);
            for (l_394.f0 = 0; (l_394.f0 <= 6); l_394.f0 += 1)
            { /* block id: 374 */
                const struct S2 l_402[9][3][9] = {{{{5085,9,1970,136,934,45,3UL},{6708,8,697,692,-1038,19,1UL},{9463,3,692,267,-1210,82,0x9C9CC418L},{6708,8,697,692,-1038,19,1UL},{5085,9,1970,136,934,45,3UL},{10393,6,114,-871,-707,80,1UL},{5726,8,1556,998,-429,88,18446744073709551606UL},{16315,10,1940,-1358,439,74,18446744073709551615UL},{2351,4,1241,-4,-590,49,0x287F9EC9L}},{{3559,4,1996,292,1597,-47,0xC696D2CCL},{13707,3,403,-1297,-1418,-85,0xCEDCD0D5L},{9209,6,762,-103,-706,-49,1UL},{11023,4,543,854,813,-43,0x6205BBEEL},{11307,15,1787,-186,1305,-68,0x23A7828EL},{5668,13,1098,-872,-1412,-42,1UL},{2492,3,1255,-421,-1828,-79,2UL},{11792,12,1675,918,195,58,3UL},{15608,8,1415,9,-1450,22,18446744073709551610UL}},{{13429,8,1258,-1205,786,-45,0xB4FC96F6L},{15493,2,1267,-1217,848,64,1UL},{13651,5,1498,514,-123,-31,5UL},{1433,10,974,-1429,1255,-14,18446744073709551609UL},{9020,10,1640,-1251,117,-37,0xD8874411L},{9463,3,692,267,-1210,82,0x9C9CC418L},{16315,10,1940,-1358,439,74,18446744073709551615UL},{5660,10,1256,-717,-1706,4,8UL},{15640,4,231,1313,-546,-36,0x8B1A76D8L}}},{{{6100,14,400,1264,-1265,38,18446744073709551615UL},{14429,11,1935,-39,-1416,-47,0x9974B571L},{13768,10,364,465,1482,-19,0UL},{9463,3,692,267,-1210,82,0x9C9CC418L},{3530,15,433,819,-94,-58,1UL},{2931,15,1714,-52,911,72,0UL},{9020,10,1640,-1251,117,-37,0xD8874411L},{4784,3,1388,734,-1609,75,18446744073709551609UL},{14944,13,384,-635,-1557,-40,0xED279660L}},{{6495,3,266,-957,-437,27,0x5D42C206L},{11792,12,1675,918,195,58,3UL},{10050,0,369,121,-1765,-33,0xB300B62BL},{5185,8,1383,-263,2040,-32,0xCC5A4AFAL},{2637,15,1570,-996,1847,-24,0x54253CF6L},{9808,1,862,931,-1577,-42,18446744073709551612UL},{6848,10,119,1181,1075,-4,0x6F203C2EL},{8598,15,763,487,1716,23,1UL},{12507,12,602,-989,198,0,18446744073709551612UL}},{{9354,13,1786,-1284,-1987,50,18446744073709551615UL},{12138,9,22,-1139,-199,70,9UL},{653,14,1293,830,1856,89,0x1AA630F6L},{12471,1,1768,-886,-893,-60,0x5A27DE33L},{10067,6,1258,-922,359,-88,7UL},{7368,5,1992,290,-590,-64,0UL},{5275,11,284,-623,1655,-3,18446744073709551615UL},{6633,13,347,587,-384,55,1UL},{188,7,1588,854,-2022,-68,9UL}}},{{{12507,12,602,-989,198,0,18446744073709551612UL},{16295,15,75,-109,1870,5,18446744073709551615UL},{5548,5,2004,1225,575,5,0xCC03AC7AL},{11986,9,1185,-71,190,-49,0UL},{9354,13,1786,-1284,-1987,50,18446744073709551615UL},{6495,3,266,-957,-437,27,0x5D42C206L},{15640,4,231,1313,-546,-36,0x8B1A76D8L},{16315,10,1940,-1358,439,74,18446744073709551615UL},{3171,11,611,-990,-396,46,18446744073709551608UL}},{{9808,1,862,931,-1577,-42,18446744073709551612UL},{7106,3,1168,1137,1301,74,0xF5346B59L},{9902,6,1332,-428,1801,54,0x8B23FD4FL},{16295,15,75,-109,1870,5,18446744073709551615UL},{14398,9,1150,-317,-703,18,0x618F63C8L},{15997,12,710,996,1285,87,0xCAC81F49L},{9463,3,692,267,-1210,82,0x9C9CC418L},{7368,5,1992,290,-590,-64,0UL},{7106,3,1168,1137,1301,74,0xF5346B59L}},{{12862,8,1336,172,878,-71,0x1514C04CL},{9618,11,1704,-283,1000,-88,0xC739653BL},{11792,12,1675,918,195,58,3UL},{2528,10,1739,-889,-990,-7,0x418FF270L},{8193,14,770,831,597,-71,0x9A998834L},{8850,7,1388,-129,979,-52,0xF4399E85L},{9463,3,692,267,-1210,82,0x9C9CC418L},{15640,4,231,1313,-546,-36,0x8B1A76D8L},{2637,15,1570,-996,1847,-24,0x54253CF6L}}},{{{6633,13,347,587,-384,55,1UL},{6568,10,286,-1215,-1758,-54,0x4B1F418CL},{174,9,1207,817,1177,-68,0x3165345CL},{5664,14,1336,850,296,-2,18446744073709551612UL},{12357,1,1440,-1034,312,-10,18446744073709551608UL},{8615,3,50,41,124,-29,0x4A564DF0L},{15640,4,231,1313,-546,-36,0x8B1A76D8L},{5660,10,1256,-717,-1706,4,8UL},{16315,10,1940,-1358,439,74,18446744073709551615UL}},{{13250,2,1953,1256,121,-16,0x3966BF46L},{5726,8,1556,998,-429,88,18446744073709551606UL},{4301,11,1127,462,-2043,-59,0x189666E3L},{14648,7,955,1262,1489,51,18446744073709551615UL},{14944,13,384,-635,-1557,-40,0xED279660L},{7106,3,1168,1137,1301,74,0xF5346B59L},{5275,11,284,-623,1655,-3,18446744073709551615UL},{4093,10,1382,174,995,49,1UL},{9808,1,862,931,-1577,-42,18446744073709551612UL}},{{15297,4,985,1255,465,12,0xBA1DA512L},{12250,4,1008,-1167,1240,-2,0x1BA3C89FL},{9265,11,1099,1080,-46,73,0xBDFCB6BEL},{8598,15,763,487,1716,23,1UL},{9363,11,1139,-753,941,67,18446744073709551608UL},{11986,9,1185,-71,190,-49,0UL},{6848,10,119,1181,1075,-4,0x6F203C2EL},{15297,4,985,1255,465,12,0xBA1DA512L},{4844,11,1660,721,-1588,-52,0x2D75E256L}}},{{{10179,0,1797,-1144,306,-36,18446744073709551610UL},{5662,14,936,397,-1316,-10,0x136F0ECDL},{5275,11,284,-623,1655,-3,18446744073709551615UL},{10722,0,190,-254,2034,48,0x391FA4E1L},{5056,3,1931,-742,1331,-47,0xD29C3FC8L},{14398,9,1150,-317,-703,18,0x618F63C8L},{9020,10,1640,-1251,117,-37,0xD8874411L},{689,7,676,1277,1386,-60,0x44FC28B5L},{689,7,676,1277,1386,-60,0x44FC28B5L}},{{16315,10,1940,-1358,439,74,18446744073709551615UL},{6495,3,266,-957,-437,27,0x5D42C206L},{5662,14,936,397,-1316,-10,0x136F0ECDL},{5726,8,1556,998,-429,88,18446744073709551606UL},{5662,14,936,397,-1316,-10,0x136F0ECDL},{6495,3,266,-957,-437,27,0x5D42C206L},{16315,10,1940,-1358,439,74,18446744073709551615UL},{12862,8,1336,172,878,-71,0x1514C04CL},{6100,14,400,1264,-1265,38,18446744073709551615UL}},{{14398,9,1150,-317,-703,18,0x618F63C8L},{4093,10,1382,174,995,49,1UL},{551,7,1169,-585,-1216,57,6UL},{15297,4,985,1255,465,12,0xBA1DA512L},{10393,6,114,-871,-707,80,1UL},{14241,2,479,297,1594,-47,0xFF1B54D9L},{2492,3,1255,-421,-1828,-79,2UL},{14944,13,384,-635,-1557,-40,0xED279660L},{8040,3,1365,-38,-263,-29,0x4776CCF4L}}},{{{6568,10,286,-1215,-1758,-54,0x4B1F418CL},{10179,0,1797,-1144,306,-36,18446744073709551610UL},{7657,8,2011,-670,-1361,-78,18446744073709551609UL},{2623,10,519,1426,1579,10,18446744073709551615UL},{8193,14,770,831,597,-71,0x9A998834L},{13707,3,403,-1297,-1418,-85,0xCEDCD0D5L},{2528,10,1739,-889,-990,-7,0x418FF270L},{12862,8,1336,172,878,-71,0x1514C04CL},{6633,13,347,587,-384,55,1UL}},{{5662,14,936,397,-1316,-10,0x136F0ECDL},{15493,2,1267,-1217,848,64,1UL},{2623,10,519,1426,1579,10,18446744073709551615UL},{9902,6,1332,-428,1801,54,0x8B23FD4FL},{10765,2,2022,375,16,30,0xC2AD7E1AL},{10105,5,1661,-1193,545,-27,0UL},{10117,6,229,-517,528,-35,1UL},{689,7,676,1277,1386,-60,0x44FC28B5L},{10358,10,60,-1440,393,9,18446744073709551614UL}},{{3559,4,1996,292,1597,-47,0xC696D2CCL},{10393,6,114,-871,-707,80,1UL},{8940,9,1314,220,-641,54,1UL},{14648,7,955,1262,1489,51,18446744073709551615UL},{10722,0,190,-254,2034,48,0x391FA4E1L},{16295,15,75,-109,1870,5,18446744073709551615UL},{1433,10,974,-1429,1255,-14,18446744073709551609UL},{15297,4,985,1255,465,12,0xBA1DA512L},{10857,3,1257,1275,916,-4,1UL}}},{{{6495,3,266,-957,-437,27,0x5D42C206L},{10117,6,229,-517,528,-35,1UL},{12507,12,602,-989,198,0,18446744073709551612UL},{7106,3,1168,1137,1301,74,0xF5346B59L},{15608,8,1415,9,-1450,22,18446744073709551610UL},{11023,4,543,854,813,-43,0x6205BBEEL},{5660,10,1256,-717,-1706,4,8UL},{4093,10,1382,174,995,49,1UL},{15493,2,1267,-1217,848,64,1UL}},{{13429,8,1258,-1205,786,-45,0xB4FC96F6L},{15608,8,1415,9,-1450,22,18446744073709551610UL},{5275,11,284,-623,1655,-3,18446744073709551615UL},{12166,4,202,47,-691,44,18446744073709551611UL},{1474,4,271,-686,448,24,0x1CBB4EB2L},{14944,13,384,-635,-1557,-40,0xED279660L},{551,7,1169,-585,-1216,57,6UL},{5660,10,1256,-717,-1706,4,8UL},{188,7,1588,854,-2022,-68,9UL}},{{4844,11,1660,721,-1588,-52,0x2D75E256L},{13250,2,1953,1256,121,-16,0x3966BF46L},{1756,4,238,-707,342,82,8UL},{14944,13,384,-635,-1557,-40,0xED279660L},{188,7,1588,854,-2022,-68,9UL},{2931,15,1714,-52,911,72,0UL},{10358,10,60,-1440,393,9,18446744073709551614UL},{15640,4,231,1313,-546,-36,0x8B1A76D8L},{16295,15,75,-109,1870,5,18446744073709551615UL}}},{{{3119,6,595,-348,354,89,0x161E4228L},{4093,10,1382,174,995,49,1UL},{15581,3,12,-745,-1525,11,0x8703EC12L},{5185,8,1383,-263,2040,-32,0xCC5A4AFAL},{15290,10,1349,547,561,-87,18446744073709551612UL},{2492,3,1255,-421,-1828,-79,2UL},{8615,3,50,41,124,-29,0x4A564DF0L},{7368,5,1992,290,-590,-64,0UL},{16295,15,75,-109,1870,5,18446744073709551615UL}},{{7657,8,2011,-670,-1361,-78,18446744073709551609UL},{12138,9,22,-1139,-199,70,9UL},{15640,4,231,1313,-546,-36,0x8B1A76D8L},{8940,9,1314,220,-641,54,1UL},{5275,11,284,-623,1655,-3,18446744073709551615UL},{9902,6,1332,-428,1801,54,0x8B23FD4FL},{653,14,1293,830,1856,89,0x1AA630F6L},{5726,8,1556,998,-429,88,18446744073709551606UL},{5056,3,1931,-742,1331,-47,0xD29C3FC8L}},{{8965,1,232,-1048,749,-30,0x39D9E66DL},{12471,1,1768,-886,-893,-60,0x5A27DE33L},{5664,14,1336,850,296,-2,18446744073709551612UL},{10179,0,1797,-1144,306,-36,18446744073709551610UL},{12138,9,22,-1139,-199,70,9UL},{9020,10,1640,-1251,117,-37,0xD8874411L},{7368,5,1992,290,-590,-64,0UL},{1033,3,1004,120,1486,12,8UL},{3530,15,433,819,-94,-58,1UL}}},{{{10117,6,229,-517,528,-35,1UL},{2492,3,1255,-421,-1828,-79,2UL},{12108,13,60,-469,459,25,18446744073709551607UL},{551,7,1169,-585,-1216,57,6UL},{13768,10,364,465,1482,-19,0UL},{9265,11,1099,1080,-46,73,0xBDFCB6BEL},{6633,13,347,587,-384,55,1UL},{7657,8,2011,-670,-1361,-78,18446744073709551609UL},{2492,3,1255,-421,-1828,-79,2UL}},{{9265,11,1099,1080,-46,73,0xBDFCB6BEL},{12166,4,202,47,-691,44,18446744073709551611UL},{10857,3,1257,1275,916,-4,1UL},{12862,8,1336,172,878,-71,0x1514C04CL},{10067,6,1258,-922,359,-88,7UL},{11307,15,1787,-186,1305,-68,0x23A7828EL},{8965,1,232,-1048,749,-30,0x39D9E66DL},{5085,9,1970,136,934,45,3UL},{11023,4,543,854,813,-43,0x6205BBEEL}},{{1033,3,1004,120,1486,12,8UL},{7601,7,1268,123,-618,47,0x307045C1L},{9363,11,1139,-753,941,67,18446744073709551608UL},{2492,3,1255,-421,-1828,-79,2UL},{16295,15,75,-109,1870,5,18446744073709551615UL},{2492,3,1255,-421,-1828,-79,2UL},{9363,11,1139,-753,941,67,18446744073709551608UL},{7601,7,1268,123,-618,47,0x307045C1L},{1033,3,1004,120,1486,12,8UL}}}};
                int i, j, k;
                for (l_85 = 0; (l_85 <= 6); l_85 += 1)
                { /* block id: 377 */
                    struct S0 l_399 = {1956,-7,0,4,1308,2517};
                    int32_t l_404 = 4L;
                    int32_t *l_403 = &l_404;
                    l_400 = l_399;
                    (*l_88) = 0x3.343D12p-69;
                    (*l_403) = (~func_90(l_402[2][0][1]));
                }
            }
            l_407 = l_405;
            /* statement id: 383 */
            assert (l_407 == &l_406);
            for (l_394.f0 = 0; (l_394.f0 < (-9)); l_394.f0 -= 1)
            { /* block id: 386 */
                uint32_t l_413 = 18446744073709551615UL;
                if (((int32_t)(*l_405) % (int32_t)l_413))
                { /* block id: 387 */
                    for (l_413 = 0; (l_413 > 10); l_413 += 1)
                    { /* block id: 390 */
                        struct S2 **l_418 = &l_416;
                        (*l_418) = l_416;
                    }
                }
                else
                { /* block id: 393 */
                    float *l_419 = &l_89;
                    return p_74;
                    /* statement id: 394 */
                    //assert (func_70_rv == &l_78 || (func_70_rv >= &l_912[0] && func_70_rv <= &l_912[1]));
                }
                for (l_85 = 16; (l_85 != (-30)); l_85 -= 1)
                { /* block id: 398 */
                    for (l_413 = 0; (l_413 < 9); l_413 += 1)
                    { /* block id: 401 */
                        const struct S2 *l_427 = &l_417[2][0][3];
                        (*l_405) = (!((uint16_t)0xEED9L >> (uint16_t)((l_427 != &l_417[2][0][3]) || 0xADB7L)));
                        if ((*p_71))
                            continue;
                        (*l_405) = l_413;
                    }
                }
            }
        }
        else
        { /* block id: 408 */
            float l_451 = 0x9.7p-1;
            int32_t l_453 = (-7L);
            struct S0 l_467 = {-1166,-3,40,-0,-2398,432};
            const struct S2 l_499 = {6279,8,1427,-1368,-1212,-66,0xF4587C97L};
            struct S2 * const ****l_500 = (void*)0;
            int32_t *l_515 = (void*)0;
            struct S0 *l_529 = &l_400;
            struct S0 **l_528 = &l_529;
            struct S0 ***l_527 = &l_528;
            struct S0 ****l_526 = &l_527;
            struct S0 *****l_525 = &l_526;
            float ** const ***l_542[3][10] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
            uint32_t l_589 = 0UL;
            int i, j;
            if ((*p_71))
            { /* block id: 409 */
                int32_t l_434[5] = {(-6L),(-6L),(-6L),(-6L),(-6L)};
                float * const **l_458 = &l_397;
                float * const *** const l_457 = &l_458;
                int i;
                if ((5UL > ((int16_t)((((uint16_t)((0xAB5EB85CL | (0x7B77L <= ((uint16_t)__builtin_ia32_crc32qi(p_72, p_72) << (uint16_t)6))) && ((-6L) <= ((0L != (((*p_71) < p_72) <= (-6L))) == (*p_71)))) >> (uint16_t)13) > p_72) < l_434[4]) << (int16_t)l_434[4])))
                { /* block id: 410 */
                    float l_452[2];
                    int16_t l_454 = 0x2367L;
                    int i;
                    for (i = 0; i < 2; i = i + 1)
                        l_452[i] = 0x0.Cp-1;
                    if ((((uint16_t)(__builtin_parityl((((uint32_t)(__builtin_ffs(((p_72 && (-1L)) ^ ((uint16_t)65532UL >> (uint16_t)8))) != (*p_71)) % (uint32_t)func_90(l_92)) < ((uint32_t)((uint16_t)((uint16_t)((int32_t)(*p_71) - (int32_t)(((int16_t)0x2AFBL >> (int16_t)0) && (*p_71))) * (uint16_t)p_72) * (uint16_t)l_453) + (uint32_t)0x963A6AC4L))) >= 0xD4ACL) * (uint16_t)l_454) & (-1L)))
                    { /* block id: 411 */
                        int32_t **l_455 = (void*)0;
                        int32_t *l_456 = &l_434[0];
                        l_456 = p_74;
                        /* statement id: 412 */
                        //assert (l_456 == &l_78 || (l_456 >= &l_912[0] && l_456 <= &l_912[1]));
                    }
                    else
                    { /* block id: 413 */
                        float **l_462[8][2];
                        float ***l_461[10] = {&l_462[5][0],&l_462[5][0],&l_462[5][0],&l_462[5][0],&l_462[5][0],&l_462[5][0],&l_462[5][0],&l_462[5][0],&l_462[5][0],&l_462[5][0]};
                        float ****l_460 = &l_461[8];
                        float *****l_459 = &l_460;
                        int i, j;
                        for (i = 0; i < 8; i = i + 1)
                        {
                            for (j = 0; j < 2; j = j + 1)
                                l_462[i][j] = &l_88;
                        }
                        (*l_459) = l_457;
                        /* statement id: 414 */
                        assert (l_460 == &l_458);
                        if (l_453)
                            break;
                    }
                }
                else
                { /* block id: 417 */
                    struct S0 **l_465 = (void*)0;
                    struct S0 ***l_464 = &l_465;
                    struct S0 ****l_463 = &l_464;
                    int32_t l_475 = 1L;
                    int32_t *l_487[5][1];
                    int i, j;
                    for (i = 0; i < 5; i = i + 1)
                    {
                        for (j = 0; j < 1; j = j + 1)
                            l_487[i][j] = (void*)0;
                    }
                    if (l_434[4])
                    { /* block id: 418 */
                        struct S0 *****l_466 = &l_463;
                        struct S0 *l_468[4] = {&l_400,&l_400,&l_400,&l_400};
                        struct S0 **l_469 = &l_468[0];
                        int i;
                        (*l_466) = l_463;
                        l_400 = l_467;
                        (*l_469) = l_468[0];
                        if ((*p_71))
                            break;
                    }
                    else
                    { /* block id: 423 */
                        int32_t *l_470 = &l_453;
                        const int32_t *l_472 = &l_434[4];
                        const int32_t **l_471 = &l_472;
                        (*l_471) = l_470;
                        /* statement id: 424 */
                        assert (l_472 == &l_453);
                        (****l_457) = ((float)l_475 / (float)((float)((float)(l_475 >= ((*p_74) >= (*p_74))) / (float)((float)func_104((*p_74)) - (float)((float)(*p_74) - (float)l_434[1]))) * (float)((float)func_104((*p_74)) - (float)l_434[4])));
                        l_486[0] = (*l_471);
                        /* statement id: 426 */
                        //assert (l_486[0] == &l_453 || l_486[0] == 0 || l_486[0] == dangling);
                        l_487[1][0] = &l_475;
                        /* statement id: 427 */
                        //assert (l_487[0][0] == &l_475 || l_487[0][0] == 0);
                    }
                    /* facts after branching */
                    //assert (l_486[0] == &l_453 || l_486[0] == 0 || l_486[0] == dangling);
                    //assert (l_487[0][0] == &l_475 || l_487[0][0] == 0);
                    (*l_88) = ((*p_74) < (*p_74));
                    for (l_475 = 10; (l_475 != 23); l_475 += 1)
                    { /* block id: 432 */
                        struct S2 ***l_491 = (void*)0;
                        struct S2 ****l_490[2][6] = {{&l_491,(void*)0,&l_491,&l_491,&l_491,&l_491},{(void*)0,(void*)0,&l_491,&l_491,&l_491,(void*)0}};
                        struct S2 *****l_492 = &l_490[1][4];
                        int i, j;
                        (*l_492) = l_490[1][4];
                        (*l_407) = (*p_71);
                    }
                }
                /* facts after branching */
                //assert (l_486[0] == &l_453 || l_486[0] == 0 || l_486[0] == dangling);
            }
            else
            { /* block id: 437 */
                uint32_t l_506[6];
                float ***l_537[3];
                float ****l_536 = &l_537[1];
                struct S2 *l_538[6][2];
                int32_t *l_539[5][4] = {{(void*)0,&l_408,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{&l_453,&l_408,&l_453,(void*)0},{&l_453,(void*)0,(void*)0,&l_453},{(void*)0,(void*)0,(void*)0,(void*)0}};
                float **l_560 = &l_88;
                uint16_t l_576 = 1UL;
                struct S0 *l_583 = (void*)0;
                int i, j;
                for (i = 0; i < 6; i = i + 1)
                    l_506[i] = 0UL;
                for (i = 0; i < 3; i = i + 1)
                    l_537[i] = (void*)0;
                for (i = 0; i < 6; i = i + 1)
                {
                    for (j = 0; j < 2; j = j + 1)
                        l_538[i][j] = &l_495;
                }
                l_506[1] = (((l_493[0][6][2] == &l_494) >= (-(int16_t)0x68BFL)) || (((func_90(l_499) != (l_467.f3 >= p_72)) | 0UL) != (l_500 == l_501)));
                for (l_85 = (-2); (l_85 <= 3); l_85 += 1)
                { /* block id: 441 */
                    const int32_t *l_510 = &l_408;
                    float **l_518 = (void*)0;
                    const float **l_520 = (void*)0;
                    const float ***l_519 = &l_520;
                    for (l_453 = 5; (l_453 >= 1); l_453 -= 1)
                    { /* block id: 444 */
                        const struct S2 l_509 = {13241,10,1518,685,686,46,0x098C8D03L};
                        int32_t **l_511 = &l_407;
                        (*l_407) = func_90(l_509);
                        (*l_511) = l_510;
                    }
                    for (l_394.f0 = (-14); (l_394.f0 != (-1)); l_394.f0 += 1)
                    { /* block id: 450 */
                        int32_t **l_514[5];
                        struct S0 l_516[10] = {{3152,-5,79,2,-631,5440},{-1611,-8,80,2,2683,2484},{-1876,2,89,-4,-1854,4462},{-1876,2,89,-4,-1854,4462},{-1611,-8,80,2,2683,2484},{3152,-5,79,2,-631,5440},{-1611,-8,80,2,2683,2484},{-1876,2,89,-4,-1854,4462},{-1876,2,89,-4,-1854,4462},{-1611,-8,80,2,2683,2484}};
                        struct S0 *l_517 = &l_516[1];
                        int i;
                        for (i = 0; i < 5; i = i + 1)
                            l_514[i] = &l_407;
                        l_515 = p_74;
                        /* statement id: 451 */
                        //assert (l_515 == &l_78 || (l_515 >= &l_912[0] && l_515 <= &l_912[1]));
                        (*l_517) = l_516[1];
                    }
                    (*l_519) = l_518;
                    if (((((((int16_t)0x9867L << (int16_t)p_72) > ((uint16_t)((void*)0 == l_525) * (uint16_t)__builtin_parityll((*l_510)))) > ((uint32_t)((int16_t)(func_90((*l_494)) < ((((int16_t)((void*)0 == l_536) * (int16_t)p_72) ^ 8UL) | p_72)) + (int16_t)l_506[0]) - (uint32_t)(*l_510))) < 9L) || p_72))
                    { /* block id: 455 */
                        int32_t **l_540[6][3][1] = {{{&l_539[0][0]},{&l_515},{&l_539[0][0]}},{{&l_515},{&l_539[0][0]},{&l_515}},{{&l_539[0][0]},{&l_515},{&l_539[0][0]}},{{&l_515},{&l_539[0][0]},{&l_515}},{{&l_539[0][0]},{&l_515},{&l_539[0][0]}},{{&l_515},{&l_539[0][0]},{&l_515}}};
                        int i, j, k;
                        (**l_503) = l_538[4][1];
                        l_539[0][0] = (void*)0;
                        l_539[1][1] = p_74;
                        l_542[0][7] = l_541;
                    }
                    else
                    { /* block id: 460 */
                        if ((*p_71))
                            break;
                    }
                }
                /* facts after for loop */
                //assert (l_515 == &l_78 || l_515 == 0 || (l_515 >= &l_912[0] && l_515 <= &l_912[1]));
                //assert (l_539[0][0] == &l_78 || l_539[0][0] == &l_453 || l_539[0][0] == 0 || l_539[0][0] == &l_408 || (l_539[0][0] >= &l_912[0] && l_539[0][0] <= &l_912[1]));
                if (((int16_t)((int16_t)((uint16_t)p_72 - (uint16_t)(func_90(l_499) ^ (((uint16_t)((p_74 == (void*)0) || 0xC38ECF03L) * (uint16_t)((((int16_t)p_72 / (int16_t)((int16_t)((int16_t)(((int32_t)(*p_71) + (int32_t)((l_560 != &l_88) < p_72)) != p_72) >> (int16_t)0) - (int16_t)65535UL)) || p_72) <= 0x94D8L)) || p_72))) * (int16_t)(*l_407)) << (int16_t)p_72))
                { /* block id: 464 */
                    float ** const *l_568 = &l_560;
                    float ** const **l_567 = &l_568;
                    float ** const ***l_566 = &l_567;
                    int32_t *l_573 = (void*)0;
                    for (l_453 = 27; (l_453 <= 16); l_453 -= 1)
                    { /* block id: 467 */
                        struct S2 ***l_569[8];
                        const struct S2 *l_572 = &l_92;
                        const struct S2 **l_571 = &l_572;
                        const struct S2 ***l_570 = &l_571;
                        int i;
                        for (i = 0; i < 8; i = i + 1)
                            l_569[i] = &l_504;
                        (*l_407) = (~((int32_t)(*p_71) - (int32_t)((l_566 == (void*)0) == (*p_71))));
                        (*l_570) = &l_494;
                        /* statement id: 469 */
                        assert (l_571 == &l_494);
                    }
                    l_573 = p_74;
                    /* statement id: 471 */
                    //assert (l_573 == &l_78 || (l_573 >= &l_912[0] && l_573 <= &l_912[1]));
                }
                else
                { /* block id: 472 */
                    for (l_394.f0 = 0; (l_394.f0 == 2); l_394.f0 += 9)
                    { /* block id: 475 */
                        float **l_577 = &l_88;
                        struct S1 l_578 = {-1L};
                        if (l_576)
                            break;
                        l_577 = l_577;
                        (*p_73) = l_578;
                        l_486[0] = &l_408;
                    }
                    /* facts after for loop */
                    //assert (l_486[0] == &l_408 || l_486[0] == 0 || l_486[0] == dangling);
                    for (l_394.f0 = 19; (l_394.f0 <= (-26)); l_394.f0 -= 1)
                    { /* block id: 483 */
                        l_495.f4 = ((float)(*p_74) - (float)((*p_74) <= ((-0x1.6p-1) >= (*p_74))));
                        l_583 = (void*)0;
                    }
                }
                /* facts after branching */
                //assert (l_486[0] == &l_408 || l_486[0] == 0 || l_486[0] == dangling);
                for (l_394.f0 = 7; (l_394.f0 < 12); l_394.f0 += 1)
                { /* block id: 490 */
                    for (l_576 = 0; (l_576 == 37); l_576 += 1)
                    { /* block id: 493 */
                        (**l_527) = (***l_526);
                    }
                    (*p_73) = l_588;
                }
            }
            /* facts after branching */
            //assert (l_486[0] == &l_408 || l_486[0] == 0 || l_486[0] == dangling || l_486[0] == &l_453);
            //assert (l_515 == &l_78 || l_515 == 0 || (l_515 >= &l_912[0] && l_515 <= &l_912[1]));
            if (l_589)
                continue;
            //assert (l_486[0] == 0 || l_486[0] == dangling);
        }
        /* facts after branching */
        //assert (l_486[0] == &l_408 || l_486[0] == 0 || l_486[0] == dangling);
        //assert (l_407 == &l_408 || l_407 == dangling);
        (****l_501) = (****l_501);
        for (l_408 = (-28); (l_408 <= (-1)); l_408 += 1)
        { /* block id: 504 */
            int32_t l_595 = 0xD2B7156BL;
            (*p_74) = (!(((*p_74) != (((float)l_595 / (float)(*p_74)) == l_595)) >= (-0x1.1p+1)));
        }
    }
    /* facts after for loop */
    //assert (l_486[0] == 0 || l_486[0] == dangling);
    return p_74;
    /* statement id: 508 */
    //assert (func_70_rv == &l_78 || (func_70_rv >= &l_912[0] && func_70_rv <= &l_912[1]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_82(uint16_t  p_83, int32_t  p_84)
{ /* block id: 275 */
    struct S0 *l_307 = (void*)0;
    struct S0 **l_308[5] = {&l_307,&l_307,&l_307,&l_307,&l_307};
    struct S0 *l_309 = (void*)0;
    int32_t *l_314 = (void*)0;
    const struct S2 l_327 = {4160,4,446,138,-1036,23,0x21E32876L};
    int32_t l_328 = 0xBBDB3903L;
    struct S1 l_369 = {1L};
    int32_t *l_373 = &l_328;
    int i;
    l_309 = l_307;
    for (p_84 = 7; (p_84 <= (-15)); p_84 -= 1)
    { /* block id: 279 */
        int32_t l_313 = (-1L);
        int32_t *l_312 = &l_313;
        const struct S2 l_315 = {11709,13,1190,-675,-1528,1,0xA207F862L};
        struct S0 l_322[3] = {{7736,4,87,-3,-233,3715},{7736,4,87,-3,-233,3715},{7736,4,87,-3,-233,3715}};
        struct S0 l_325 = {-7290,6,64,-1,2158,5774};
        float *l_345 = (void*)0;
        float **l_344 = &l_345;
        float ***l_343 = &l_344;
        float ****l_342 = &l_343;
        struct S1 l_351 = {0xB813L};
        struct S0 *l_371 = &l_322[0];
        struct S1 l_379 = {-5L};
        struct S1 *l_385 = (void*)0;
        int i;
        l_314 = l_312;
        /* statement id: 280 */
        assert (l_314 == &l_313);
        if ((((*l_314) == ((void*)0 == &p_84)) | __builtin_popcountl(func_90(l_315))))
        { /* block id: 281 */
            uint16_t l_316 = 0x88DEL;
            int32_t l_319[8] = {0x1254CA76L,1L,1L,0x1254CA76L,1L,1L,0x1254CA76L,1L};
            int i;
            if (l_316)
            { /* block id: 282 */
                int32_t **l_317 = &l_312;
                (*l_317) = &p_84;
                /* statement id: 283 */
                assert (l_312 == &p_84);
                if ((*l_312))
                    break;
                //assert (l_314 == dangling);
            }
            else
            { /* block id: 285 */
                int32_t **l_318 = &l_314;
                (*l_318) = &p_84;
                /* statement id: 286 */
                assert (l_314 == &p_84);
                l_319[4] = p_83;
            }
            /* facts after branching */
            assert (l_312 == &l_313 || l_312 == &p_84);
            assert (l_314 == &p_84 || l_314 == &l_313);
        }
        else
        { /* block id: 289 */
            int32_t **l_320 = (void*)0;
            int32_t **l_321[4] = {&l_312,&l_312,&l_312,&l_312};
            int i;
            l_314 = &p_84;
            /* statement id: 290 */
            assert (l_314 == &p_84);
        }
        /* facts after branching */
        assert (l_312 == &l_313 || l_312 == &p_84);
        assert (l_314 == &p_84 || l_314 == &l_313);
        l_322[2] = l_322[0];
        for (p_83 = 0; (p_83 < 51); p_83 += 1)
        { /* block id: 295 */
            struct S0 l_326 = {1269,7,73,0,-2652,4836};
            float **l_382[10][7] = {{(void*)0,&l_345,&l_345,&l_345,&l_345,&l_345,&l_345},{&l_345,&l_345,&l_345,&l_345,&l_345,&l_345,&l_345},{&l_345,&l_345,&l_345,&l_345,&l_345,&l_345,&l_345},{(void*)0,&l_345,&l_345,&l_345,(void*)0,&l_345,&l_345},{&l_345,&l_345,(void*)0,&l_345,&l_345,&l_345,&l_345},{&l_345,(void*)0,&l_345,(void*)0,&l_345,&l_345,(void*)0},{&l_345,(void*)0,&l_345,&l_345,(void*)0,&l_345,&l_345},{&l_345,(void*)0,&l_345,&l_345,&l_345,&l_345,&l_345},{&l_345,&l_345,&l_345,&l_345,&l_345,&l_345,&l_345},{&l_345,&l_345,&l_345,&l_345,&l_345,(void*)0,(void*)0}};
            struct S1 *l_383 = &l_369;
            int32_t *l_391 = &l_328;
            int i, j;
            l_326 = l_325;
            l_328 = func_90(l_327);
        }
    }
    /* facts after for loop */
    //assert (l_314 == &p_84 || l_314 == dangling || l_314 == 0);
    return l_369;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_90(const struct S2  p_91)
{ /* block id: 62 */
    int32_t l_101 = (-8L);
    float l_280 = (-0x4.2p-1);
    float *l_281 = &l_280;
    struct S0 l_289[3] = {{884,-8,7,-0,1226,1234},{884,-8,7,-0,1226,1234},{884,-8,7,-0,1226,1234}};
    struct S0 *l_288[5] = {&l_289[2],&l_289[2],&l_289[2],&l_289[2],&l_289[2]};
    struct S0 **l_287 = &l_288[4];
    struct S0 ***l_286 = &l_287;
    struct S0 ****l_285 = &l_286;
    int i;
    (*l_281) = ((float)(-0x3.5p+1) - (float)((0x3.852BC5p-17 == 0x0.6p-1) < ((float)p_91.f3 * (float)((float)(((float)0x9.3439BFp-33 / (float)(l_101 > ((float)p_91.f4 + (float)p_91.f6))) >= func_104((((float)(-(float)p_91.f3) + (float)l_101) == l_101))) * (float)l_280))));
    for (l_101 = 10; (l_101 > (-25)); l_101 -= 1)
    { /* block id: 255 */
        uint32_t l_284 = 0xE81CB5ADL;
        struct S0 * const **l_292 = (void*)0;
        struct S0 * const ***l_291 = &l_292;
        struct S0 * const ****l_290[10][4][2] = {{{&l_291,&l_291},{&l_291,(void*)0},{(void*)0,&l_291},{&l_291,(void*)0}},{{(void*)0,&l_291},{(void*)0,&l_291},{&l_291,&l_291},{&l_291,&l_291}},{{&l_291,&l_291},{(void*)0,&l_291},{&l_291,&l_291},{(void*)0,&l_291}},{{&l_291,(void*)0},{&l_291,&l_291},{(void*)0,&l_291},{&l_291,&l_291}},{{(void*)0,&l_291},{&l_291,&l_291},{&l_291,&l_291},{&l_291,&l_291}},{{(void*)0,&l_291},{(void*)0,(void*)0},{&l_291,&l_291},{(void*)0,(void*)0}},{{&l_291,&l_291},{&l_291,(void*)0},{&l_291,(void*)0},{&l_291,&l_291}},{{&l_291,(void*)0},{(void*)0,&l_291},{&l_291,(void*)0},{(void*)0,&l_291}},{{(void*)0,&l_291},{&l_291,&l_291},{&l_291,&l_291},{&l_291,&l_291}},{{(void*)0,&l_291},{&l_291,&l_291},{(void*)0,&l_291},{&l_291,(void*)0}}};
        struct S0 *****l_293 = (void*)0;
        int32_t *l_295 = &l_101;
        int32_t **l_294 = &l_295;
        int i, j, k;
        if (l_284)
            break;
        l_285 = l_285;
        if (p_91.f3)
            continue;
        (*l_294) = &l_101;
    }
    for (l_101 = 0; (l_101 <= 4); l_101 += 1)
    { /* block id: 263 */
        int32_t l_302 = (-3L);
        l_289[1].f1 = ((float)((float)0xB.30DE8Fp+63 - (float)p_91.f5) * (float)p_91.f3);
        if (((int16_t)(-9L) << (int16_t)l_302))
        { /* block id: 265 */
            int32_t *l_304 = &l_101;
            int32_t **l_303 = &l_304;
            if (l_302)
                break;
            if (l_101)
                break;
            (*l_303) = &l_101;
        }
        else
        { /* block id: 269 */
            int32_t *l_306 = &l_101;
            int32_t **l_305 = &l_306;
            (*l_305) = (void*)0;
            /* statement id: 270 */
            assert (l_306 == 0);
            (*l_281) = p_91.f4;
        }
    }
    return p_91.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_104(float  p_105)
{ /* block id: 63 */
    uint32_t l_109 = 0xEF1402E7L;
    struct S1 l_157 = {0x3BD2L};
    int32_t *l_189 = (void*)0;
    struct S0 l_212 = {-3211,1,18,4,849,361};
    struct S0 *l_271 = &l_212;
    int32_t **l_272 = (void*)0;
    int32_t **l_273 = &l_189;
    uint32_t l_279 = 0xF184546CL;
    if ((l_109 > (((uint16_t)l_109 / (uint16_t)l_109) > ((uint16_t)l_109 % (uint16_t)(l_109 ^ ((int32_t)(l_109 || (((int16_t)((uint16_t)l_109 >> (uint16_t)10) / (int16_t)l_109) ^ ((int32_t)((uint16_t)(((((uint32_t)(((int32_t)l_109 + (int32_t)(-8L)) ^ l_109) / (uint32_t)l_109) == 65535UL) >= l_109) && l_109) >> (uint16_t)1) / (int32_t)l_109))) / (int32_t)(-10L)))))))
    { /* block id: 64 */
        int32_t l_130 = 5L;
        struct S1 l_158 = {1L};
        struct S0 l_170[1][10][7] = {{{{5188,-8,76,-2,2642,3490},{4734,7,29,-2,-1061,4678},{-8085,3,74,3,-1589,649},{4734,7,29,-2,-1061,4678},{5188,-8,76,-2,2642,3490},{5188,-8,76,-2,2642,3490},{4734,7,29,-2,-1061,4678}},{{-8025,-8,76,1,-179,2921},{5857,-2,9,-3,2319,5725},{-8025,-8,76,1,-179,2921},{1710,10,49,-4,1151,2815},{1710,10,49,-4,1151,2815},{-8025,-8,76,1,-179,2921},{5857,-2,9,-3,2319,5725}},{{4734,7,29,-2,-1061,4678},{-3322,-8,82,-0,-1465,4549},{-8085,3,74,3,-1589,649},{-8085,3,74,3,-1589,649},{-3322,-8,82,-0,-1465,4549},{4734,7,29,-2,-1061,4678},{-3322,-8,82,-0,-1465,4549}},{{-8025,-8,76,1,-179,2921},{1710,10,49,-4,1151,2815},{1710,10,49,-4,1151,2815},{-8025,-8,76,1,-179,2921},{5857,-2,9,-3,2319,5725},{-8025,-8,76,1,-179,2921},{1710,10,49,-4,1151,2815}},{{5188,-8,76,-2,2642,3490},{5188,-8,76,-2,2642,3490},{4734,7,29,-2,-1061,4678},{-8085,3,74,3,-1589,649},{4734,7,29,-2,-1061,4678},{5188,-8,76,-2,2642,3490},{5188,-8,76,-2,2642,3490}},{{4998,-4,52,-4,2890,4896},{1710,10,49,-4,1151,2815},{-375,-10,48,2,1101,2040},{1710,10,49,-4,1151,2815},{4998,-4,52,-4,2890,4896},{4998,-4,52,-4,2890,4896},{1710,10,49,-4,1151,2815}},{{-5685,0,85,-4,1734,4496},{-3322,-8,82,-0,-1465,4549},{-5685,0,85,-4,1734,4496},{4734,7,29,-2,-1061,4678},{4734,7,29,-2,-1061,4678},{-5685,0,85,-4,1734,4496},{-3322,-8,82,-0,-1465,4549}},{{1710,10,49,-4,1151,2815},{5857,-2,9,-3,2319,5725},{-375,-10,48,2,1101,2040},{-375,-10,48,2,1101,2040},{5857,-2,9,-3,2319,5725},{1710,10,49,-4,1151,2815},{5857,-2,9,-3,2319,5725}},{{-8085,3,74,3,-1589,649},{-5685,0,85,-4,1734,4496},{-5685,0,85,-4,1734,4496},{-8085,3,74,3,-1589,649},{5188,-8,76,-2,2642,3490},{-8085,3,74,3,-1589,649},{-5685,0,85,-4,1734,4496}},{{1710,10,49,-4,1151,2815},{1710,10,49,-4,1151,2815},{-8025,-8,76,1,-179,2921},{5857,-2,9,-3,2319,5725},{-8025,-8,76,1,-179,2921},{1710,10,49,-4,1151,2815},{1710,10,49,-4,1151,2815}}}};
        struct S0 *l_200 = (void*)0;
        struct S0 **l_199 = &l_200;
        int32_t l_203 = 0x43894A63L;
        uint16_t l_228 = 65535UL;
        int i, j, k;
        if ((((((l_130 > (0x2ECBAF5AL != ((uint32_t)l_109 / (uint32_t)(-(int16_t)((-1L) <= ((uint16_t)(l_109 | l_109) / (uint16_t)6UL)))))) ^ (((((((int16_t)0x72C3L - (int16_t)l_130) ^ l_109) || 0x65F2B768L) ^ l_130) & l_109) <= 0xD8C1B616L)) > l_109) >= 7L) & l_130))
        { /* block id: 65 */
            int32_t *l_141 = &l_130;
            int16_t l_155[6][10][4] = {{{0x09CCL,0xFFD8L,0xAEAEL,0xE69CL},{0xAEAEL,0xE69CL,0xECE3L,0x35A4L},{(-1L),1L,0xD1A4L,0x7C7DL},{6L,0xA9FDL,7L,0xE69CL},{8L,(-1L),0L,(-10L)},{6L,0x399FL,(-1L),(-1L)},{1L,0x35A4L,9L,6L},{(-7L),0x09CCL,0x4DC0L,0x4DC0L},{6L,6L,0x1D69L,0L},{(-3L),0L,7L,(-1L)}},{{0x4DC0L,0x3331L,2L,7L},{(-1L),0x3331L,0x7C89L,(-1L)},{0x3331L,0L,0xAEAEL,0L},{0x8898L,6L,0L,0x4DC0L},{0x493EL,0x09CCL,0xFA84L,6L},{(-1L),0x35A4L,0x77FDL,(-1L)},{(-10L),0x399FL,0L,(-10L)},{0x09CCL,(-1L),1L,0xE69CL},{0x3331L,0xA9FDL,0xECE3L,0x7C7DL},{7L,1L,2L,0x35A4L}},{{6L,0xE69CL,0xF5D4L,0xE69CL},{(-3L),0xFFD8L,0L,0x493EL},{0xECE3L,0x399FL,0x4DC0L,9L},{1L,0x7C7DL,(-7L),6L},{1L,0x8898L,0x4DC0L,6L},{0xECE3L,6L,0L,0x77FDL},{(-3L),1L,0xF5D4L,(-1L)},{6L,0xAEAEL,2L,(-1L)},{7L,0x3331L,0xECE3L,0xFFD8L},{0x3331L,1L,1L,0L}},{{0x09CCL,0xECE3L,0L,6L},{(-10L),0x09CCL,0x77FDL,0xECE3L},{(-1L),0x7C7DL,0xFA84L,(-1L)},{0x493EL,0L,0L,0x493EL},{0x8898L,(-1L),0xAEAEL,0xA9FDL},{0x3331L,0xE69CL,0x7C89L,0x7C7DL},{(-1L),(-7L),2L,0x7C7DL},{0x4DC0L,0xE69CL,7L,0xA9FDL},{(-3L),(-1L),0x1D69L,0x493EL},{6L,0L,0x4DC0L,(-1L)}},{{(-7L),0x7C7DL,9L,0xECE3L},{1L,0x09CCL,(-1L),6L},{6L,0xECE3L,0L,0L},{8L,1L,7L,0xFFD8L},{0xAEAEL,0x64C0L,(-1L),0xFFD8L},{0xFFD8L,0L,0xF5D4L,(-10L)},{0L,0x35A4L,0L,0xC3C4L},{0L,7L,0x92AAL,0xAEAEL},{8L,(-3L),0xC3C4L,7L},{0xB111L,(-7L),0xC3C4L,(-1L)}},{{8L,2L,0x92AAL,8L},{0L,0xB111L,0L,0xECE3L},{0L,0xECE3L,0xF5D4L,1L},{0xFFD8L,0xA9FDL,(-1L),(-7L)},{0xAEAEL,0x7C89L,0x58DEL,0xECE3L},{0xFA84L,(-10L),0xC010L,1L},{7L,2L,0x3331L,0x4DC0L},{0xA9FDL,1L,(-1L),7L},{0L,0L,1L,1L},{7L,7L,0x7C7DL,0x8898L}}};
            struct S1 *l_163 = &l_157;
            uint32_t l_164 = 0xC68CCC04L;
            struct S0 l_176 = {-5832,-6,33,-3,125,3784};
            const float l_193 = 0x0.0p-1;
            const float *l_192 = &l_193;
            const float **l_191 = &l_192;
            int i, j, k;
            if ((((uint16_t)(l_130 < (!(l_141 == (void*)0))) >> (uint16_t)((int16_t)l_130 / (int16_t)65526UL)) < ((l_130 <= 3UL) | l_130)))
            { /* block id: 66 */
                int32_t l_144 = (-3L);
                uint32_t l_145[9][9][3] = {{{0x8C6B94EFL,1UL,4294967293UL},{0x15D0954AL,0x177FA41FL,0xA5E5C784L},{4294967293UL,0x59BCE111L,4294967295UL},{0x96E4AE6EL,0x177FA41FL,0x70918AE1L},{0UL,1UL,0UL},{0x177FA41FL,3UL,4294967295UL},{1UL,4294967295UL,1UL},{0x70918AE1L,4294967295UL,4294967295UL},{1UL,0x62C2F114L,0x031382D9L}},{{0x70918AE1L,5UL,0xA7B65799L},{1UL,1UL,1UL},{0x177FA41FL,1UL,0x9AD1E1EAL},{0UL,0x725F5692L,1UL},{0x96E4AE6EL,1UL,0UL},{4294967293UL,0UL,1UL},{0x15D0954AL,0x9AD1E1EAL,0x9AD1E1EAL},{0x8C6B94EFL,1UL,1UL},{4294967290UL,4294967295UL,0xA7B65799L}},{{0UL,0x466E0B1FL,0x031382D9L},{0xA7B65799L,0x96E4AE6EL,4294967295UL},{0x59BCE111L,0x466E0B1FL,1UL},{4294967295UL,4294967295UL,4294967295UL},{0x466E0B1FL,1UL,0UL},{1UL,0x9AD1E1EAL,0x70918AE1L},{1UL,0UL,4294967295UL},{3UL,1UL,0xA5E5C784L},{1UL,0x725F5692L,4294967293UL}},{{1UL,1UL,4294967295UL},{0x466E0B1FL,1UL,4294967295UL},{4294967295UL,5UL,1UL},{0x59BCE111L,0x62C2F114L,6UL},{0xA7B65799L,4294967295UL,1UL},{0UL,4294967295UL,4294967295UL},{4294967290UL,3UL,4294967295UL},{0x8C6B94EFL,1UL,4294967293UL},{0x15D0954AL,0x177FA41FL,0xA5E5C784L}},{{4294967293UL,0x59BCE111L,4294967295UL},{0x96E4AE6EL,0x177FA41FL,0x70918AE1L},{0UL,1UL,0UL},{0x177FA41FL,3UL,4294967295UL},{1UL,4294967295UL,1UL},{0x70918AE1L,4294967295UL,4294967295UL},{1UL,0x59BCE111L,0x466E0B1FL},{4294967295UL,1UL,3UL},{4294967293UL,4294967293UL,0x62C2F114L}},{{0x9AD1E1EAL,0xA7B65799L,4294967295UL},{0x671F1E86L,1UL,4294967293UL},{5UL,0x96E4AE6EL,0x70918AE1L},{1UL,0x671F1E86L,4294967293UL},{4294967290UL,4294967295UL,4294967295UL},{0x031382D9L,0UL,0x62C2F114L},{0xA5E5C784L,1UL,3UL},{0x8C6B94EFL,4294967295UL,0x466E0B1FL},{3UL,5UL,0UL}},{{0x725F5692L,4294967295UL,0UL},{0x857B7439L,1UL,0x857B7439L},{4294967295UL,0UL,0x671F1E86L},{0xA7B65799L,4294967295UL,4294967295UL},{0UL,0x671F1E86L,6UL},{0x15D0954AL,0x96E4AE6EL,0x177FA41FL},{0UL,1UL,1UL},{0xA7B65799L,0xA7B65799L,1UL},{4294967295UL,4294967293UL,4294967295UL}},{{0x857B7439L,1UL,0xA7B65799L},{0x725F5692L,0x59BCE111L,1UL},{3UL,0x857B7439L,0xA7B65799L},{0x8C6B94EFL,4294967295UL,4294967295UL},{0xA5E5C784L,0x15D0954AL,1UL},{0x031382D9L,0x62C2F114L,1UL},{4294967290UL,0x9AD1E1EAL,0x177FA41FL},{1UL,0x725F5692L,6UL},{5UL,0x9AD1E1EAL,4294967295UL}},{{0x671F1E86L,0x62C2F114L,0x671F1E86L},{0x9AD1E1EAL,0x15D0954AL,0x857B7439L},{4294967293UL,4294967295UL,0UL},{4294967295UL,0x857B7439L,0UL},{0UL,0x59BCE111L,0x466E0B1FL},{4294967295UL,1UL,3UL},{4294967293UL,4294967293UL,0x62C2F114L},{0x9AD1E1EAL,0xA7B65799L,4294967295UL},{0x671F1E86L,1UL,4294967293UL}}};
                int i, j, k;
                if (l_144)
                { /* block id: 67 */
                    return p_105;
                }
                else
                { /* block id: 69 */
                    struct S0 l_153[2] = {{2194,3,87,-0,1239,4366},{2194,3,87,-0,1239,4366}};
                    int i;
                    for (l_109 = 0; (l_109 <= 2); l_109 += 1)
                    { /* block id: 72 */
                        float l_149[5][3][9] = {{{0x1.Fp-1,0x1.1p+1,(-0x1.8p+1),0x1.1p+1,0x1.Fp-1,(-0x2.6p-1),0x1.1p+1,(-0x2.5p+1),(-0x5.1p+1)},{0x1.1p+1,0x5.0C0348p-41,(-0x1.8p+1),(-0x2.5p+1),0x5.0C0348p-41,(-0x5.1p+1),0x5.0C0348p-41,(-0x2.5p+1),(-0x1.8p+1)},{0x1.Fp-1,0x1.Fp-1,(-0x5.1p+1),(-0x2.5p+1),0x1.1p+1,(-0x2.6p-1),0x1.Fp-1,0x1.1p+1,(-0x1.8p+1)}},{{(-0x2.6p+1),0x5.0C0348p-41,0x0.1p+1,0x1.1p+1,0x1.1p+1,0x0.1p+1,0x5.0C0348p-41,(-0x2.6p+1),(-0x5.1p+1)},{(-0x2.6p+1),0x1.1p+1,(-0x5.1p+1),(-0x2.6p+1),0x5.0C0348p-41,0x0.1p+1,0x1.1p+1,0x1.1p+1,0x0.1p+1},{0x1.Fp-1,0x1.1p+1,(-0x1.8p+1),0x1.1p+1,0x1.Fp-1,(-0x2.6p-1),0x1.1p+1,(-0x2.5p+1),(-0x5.1p+1)}},{{0x1.1p+1,0x5.0C0348p-41,(-0x1.8p+1),(-0x2.5p+1),0x5.0C0348p-41,(-0x5.1p+1),0x5.0C0348p-41,(-0x2.5p+1),(-0x1.8p+1)},{0x1.Fp-1,0x1.Fp-1,(-0x5.1p+1),(-0x2.5p+1),0x1.1p+1,(-0x2.6p-1),0x1.Fp-1,0x1.1p+1,(-0x1.8p+1)},{(-0x2.6p+1),0x3.9A7C64p+25,(-0x2.5p+1),(-0x1.5p-1),(-0x1.5p-1),(-0x2.5p+1),0x3.9A7C64p+25,(-0x1.Ap+1),(-0x2.6p+1)}},{{(-0x1.Ap+1),(-0x1.5p-1),(-0x2.6p+1),(-0x1.Ap+1),0x3.9A7C64p+25,(-0x2.5p+1),(-0x1.5p-1),(-0x1.5p-1),(-0x2.5p+1)},{0x7.CF268Ap-63,(-0x1.5p-1),0x5.0C0348p-41,(-0x1.5p-1),0x7.CF268Ap-63,0x1.1p+1,(-0x1.5p-1),(-0x1.1p+1),(-0x2.6p+1)},{(-0x1.5p-1),0x3.9A7C64p+25,0x5.0C0348p-41,(-0x1.1p+1),0x3.9A7C64p+25,(-0x2.6p+1),0x3.9A7C64p+25,(-0x1.1p+1),0x5.0C0348p-41}},{{0x7.CF268Ap-63,0x7.CF268Ap-63,(-0x2.6p+1),(-0x1.1p+1),(-0x1.5p-1),0x1.1p+1,0x7.CF268Ap-63,(-0x1.5p-1),0x5.0C0348p-41},{(-0x1.Ap+1),0x3.9A7C64p+25,(-0x2.5p+1),(-0x1.5p-1),(-0x1.5p-1),(-0x2.5p+1),0x3.9A7C64p+25,(-0x1.Ap+1),(-0x2.6p+1)},{(-0x1.Ap+1),(-0x1.5p-1),(-0x2.6p+1),(-0x1.Ap+1),0x3.9A7C64p+25,(-0x2.5p+1),(-0x1.5p-1),(-0x1.5p-1),(-0x2.5p+1)}}};
                        float *l_148[10][6] = {{(void*)0,(void*)0,&l_149[1][0][4],&l_149[2][0][8],(void*)0,&l_149[2][0][8]},{(void*)0,(void*)0,&l_149[2][0][8],(void*)0,(void*)0,&l_149[3][1][5]},{&l_149[2][0][8],(void*)0,&l_149[0][0][5],&l_149[4][2][0],(void*)0,&l_149[1][0][4]},{&l_149[1][0][4],&l_149[4][0][8],(void*)0,(void*)0,&l_149[4][0][8],&l_149[1][0][4]},{&l_149[4][2][0],&l_149[2][0][8],&l_149[0][0][5],(void*)0,&l_149[1][0][4],&l_149[3][1][5]},{&l_149[4][0][8],&l_149[2][0][8],&l_149[2][0][8],&l_149[1][0][4],&l_149[2][0][8],&l_149[2][0][8]},{&l_149[4][0][8],&l_149[3][1][5],&l_149[1][0][4],(void*)0,&l_149[0][0][5],&l_149[2][0][8]},{&l_149[4][2][0],&l_149[1][0][4],&l_149[4][0][8],(void*)0,(void*)0,&l_149[4][0][8]},{&l_149[1][0][4],&l_149[1][0][4],(void*)0,&l_149[4][2][0],&l_149[0][0][5],(void*)0},{&l_149[2][0][8],&l_149[3][1][5],(void*)0,(void*)0,&l_149[2][0][8],(void*)0}};
                        const int32_t l_150 = 0x6CD91451L;
                        struct S0 *l_154 = &l_153[1];
                        int i, j, k;
                        p_105 = ((float)0x1.Ap+1 / (float)p_105);
                        if (l_150)
                            continue;
                        (*l_141) = ((uint32_t)l_150 + (uint32_t)l_150);
                        (*l_154) = l_153[1];
                    }
                }
            }
            else
            { /* block id: 79 */
                int16_t l_174 = 4L;
                struct S0 l_175 = {6369,10,33,-0,1938,5363};
                float l_177[1];
                int i;
                for (i = 0; i < 1; i = i + 1)
                    l_177[i] = 0x1.3p-1;
                for (l_109 = 0; (l_109 <= 3); l_109 += 1)
                { /* block id: 82 */
                    float l_166 = 0x0.13514Cp-71;
                    float *l_165 = &l_166;
                    int32_t l_169 = 0x443C5982L;
                    (*l_141) = l_130;
                    (*l_141) = __builtin_popcount((-(uint16_t)l_109));
                    l_158 = l_157;
                    (*l_165) = (0x8.2AF4CEp+3 <= (((float)((*l_141) > (l_109 <= ((float)(*l_141) + (float)(l_130 == ((void*)0 != l_163))))) - (float)l_164) > l_158.f0));
                    for (l_164 = 0; (l_164 <= 3); l_164 += 1)
                    { /* block id: 89 */
                        struct S0 *l_171 = &l_170[0][5][0];
                        p_105 = ((float)p_105 + (float)l_169);
                        (*l_171) = l_170[0][9][5];
                        if ((*l_141))
                            break;
                    }
                }
                for (l_157.f0 = 0; (l_157.f0 < 20); l_157.f0 += 9)
                { /* block id: 97 */
                    for (l_130 = 0; l_130 < 6; l_130 += 1)
                    {
                        for (l_109 = 0; l_109 < 10; l_109 += 1)
                        {
                            for (l_158.f0 = 0; l_158.f0 < 4; l_158.f0 += 1)
                            {
                                l_155[l_130][l_109][l_158.f0] = 1L;
                            }
                        }
                    }
                    if (l_174)
                        break;
                    l_176 = l_175;
                }
                (*l_141) = (__builtin_popcountl(l_170[0][9][5].f0) < ((*l_141) & ((int16_t)(*l_141) >> (int16_t)13)));
            }
            for (l_157.f0 = 0; (l_157.f0 <= 0); l_157.f0 += 1)
            { /* block id: 106 */
                int32_t l_182 = 3L;
                if ((((int32_t)0xD081FCDCL % (int32_t)l_182) | (l_109 == (*l_141))))
                { /* block id: 107 */
                    float l_184[7] = {0x1.Bp-1,0x1.Bp-1,0x1.Bp-1,0x1.Bp-1,0x1.Bp-1,0x1.Bp-1,0x1.Bp-1};
                    float *l_183 = &l_184[5];
                    int i;
                    (*l_183) = p_105;
                }
                else
                { /* block id: 109 */
                    for (l_164 = 0; (l_164 <= 3); l_164 += 1)
                    { /* block id: 112 */
                        return p_105;
                    }
                }
                (*l_141) = ((uint32_t)(*l_141) % (uint32_t)((int32_t)l_157.f0 - (int32_t)l_182));
                for (l_164 = 0; (l_164 <= 0); l_164 += 1)
                { /* block id: 119 */
                    int32_t **l_190 = &l_189;
                    for (l_109 = 0; (l_109 <= 3); l_109 += 1)
                    { /* block id: 122 */
                        int i, j, k;
                        return l_155[(l_164 + 5)][(l_164 + 2)][l_109];
                    }
                    l_189 = l_189;
                    (*l_190) = l_189;
                    for (l_182 = 3; (l_182 >= 0); l_182 -= 1)
                    { /* block id: 129 */
                        const float ***l_194 = (void*)0;
                        int i, j, k;
                        l_191 = l_191;
                        if (l_155[l_164][l_157.f0][(l_157.f0 + 2)])
                            break;
                        (*l_141) = l_182;
                    }
                }
            }
        }
        else
        { /* block id: 136 */
            int32_t *l_197 = (void*)0;
            int32_t **l_198 = &l_189;
            for (l_130 = 0; (l_130 < 10); l_130 += 1)
            { /* block id: 139 */
                return p_105;
            }
            (*l_198) = l_197;
        }
        for (l_157.f0 = 0; (l_157.f0 >= 0); l_157.f0 -= 1)
        { /* block id: 146 */
            struct S0 ***l_201 = &l_199;
            int32_t l_202[3];
            struct S2 *l_209 = (void*)0;
            struct S2 **l_218 = &l_209;
            struct S2 ***l_217 = &l_218;
            uint32_t l_248 = 0x2CF23584L;
            int i;
            for (i = 0; i < 3; i = i + 1)
                l_202[i] = (-9L);
            (*l_201) = l_199;
            for (l_130 = 0; (l_130 >= 0); l_130 -= 1)
            { /* block id: 150 */
                int32_t * const l_204 = &l_202[1];
                struct S0 l_211 = {5323,2,83,-3,410,1329};
                struct S0 l_220 = {-4901,-0,31,-3,2579,5217};
                struct S1 l_237 = {0x4DACL};
                l_203 = l_202[2];
                for (l_109 = 0; (l_109 <= 0); l_109 += 1)
                { /* block id: 154 */
                    uint32_t l_210 = 1UL;
                    for (l_203 = 0; (l_203 <= 0); l_203 += 1)
                    { /* block id: 157 */
                        int32_t **l_205 = &l_189;
                        struct S1 *l_206 = &l_157;
                        struct S1 **l_207 = &l_206;
                        struct S2 *l_208[8];
                        int i;
                        for (i = 0; i < 8; i = i + 1)
                            l_208[i] = (void*)0;
                        (*l_205) = l_204;
                        /* statement id: 158 */
                        assert ((l_189 >= &l_202[0] && l_189 <= &l_202[2]));
                        (*l_207) = l_206;
                        l_209 = l_208[2];
                        if ((**l_205))
                            continue;
                    }
                    /* facts after for loop */
                    assert ((l_189 >= &l_202[0] && l_189 <= &l_202[2]) || l_189 == 0);
                    return l_210;
                }
                if ((*l_204))
                { /* block id: 165 */
                    l_212 = l_211;
                    for (l_109 = 0; (l_109 <= 0); l_109 += 1)
                    { /* block id: 169 */
                        struct S2 **l_214 = &l_209;
                        struct S2 ***l_213 = &l_214;
                        (*l_213) = &l_209;
                    }
                    return l_170[0][9][5].f4;
                }
                else
                { /* block id: 173 */
                    int32_t *l_215 = (void*)0;
                    for (l_203 = 0; (l_203 >= 0); l_203 -= 1)
                    { /* block id: 176 */
                        int32_t **l_216 = &l_189;
                        (*l_216) = l_215;
                        if ((*l_204))
                            continue;
                        l_217 = l_217;
                        (*l_204) = (l_216 == (void*)0);
                    }
                    for (l_203 = 2; (l_203 >= 0); l_203 -= 1)
                    { /* block id: 184 */
                        struct S0 *l_219[5];
                        int i, j, k;
                        for (i = 0; i < 5; i = i + 1)
                            l_219[i] = (void*)0;
                        l_220 = l_170[l_157.f0][(l_203 + 3)][(l_157.f0 + 6)];
                        (*l_204) = l_202[l_130];
                        if ((*l_204))
                            break;
                        if (l_202[l_130])
                            continue;
                    }
                }
                for (l_158.f0 = 0; (l_158.f0 >= 0); l_158.f0 -= 1)
                { /* block id: 193 */
                    float l_225 = (-0x1.7p-1);
                    int32_t l_229 = (-1L);
                    int32_t *l_241 = (void*)0;
                }
            }
            l_202[2] = l_202[2];
            for (l_228 = 0; (l_228 <= 0); l_228 += 1)
            { /* block id: 211 */
                float l_245 = 0x6.D023BCp+67;
                float *l_244 = &l_245;
                int32_t l_246 = 0L;
                struct S1 l_249 = {0xAFB5L};
                (*l_244) = p_105;
                (*l_244) = (__builtin_bswap32(l_170[0][9][5].f5) != p_105);
                for (l_130 = 0; (l_130 <= 0); l_130 += 1)
                { /* block id: 216 */
                    float l_259 = 0xE.79DBF3p-75;
                    const int32_t l_260 = 0xE27D56CCL;
                    int32_t *l_265 = &l_203;
                    if ((l_246 > 1UL))
                    { /* block id: 217 */
                        if (l_158.f0)
                            break;
                    }
                    else
                    { /* block id: 219 */
                        int32_t *l_247 = &l_202[2];
                        int i, j, k;
                        l_170[l_228][(l_130 + 4)][(l_228 + 5)] = l_170[l_228][(l_130 + 4)][(l_228 + 5)];
                        (*l_247) = 6L;
                    }
                    if (l_248)
                    { /* block id: 223 */
                        int16_t l_256 = 2L;
                        l_249 = l_158;
                        l_170[0][9][5].f0 = ((l_202[2] && __builtin_popcountl(l_246)) != ((uint32_t)((int32_t)((int16_t)((0xF9BDL < (l_212.f4 & (0L | (l_256 <= ((((((uint16_t)l_260 % (uint16_t)((uint16_t)l_202[2] >> (uint16_t)8)) & 5L) || l_260) != (-10L)) <= 0x38D6L))))) ^ l_256) << (int16_t)2) + (int32_t)l_256) + (uint32_t)l_248));
                    }
                    else
                    { /* block id: 226 */
                        int32_t *l_263 = &l_202[2];
                        int32_t **l_264[6] = {&l_263,&l_263,&l_263,&l_263,&l_263,&l_263};
                        int i, j, k;
                        (*l_263) = (&l_189 != (void*)0);
                        (*l_199) = &l_170[l_228][(l_157.f0 + 3)][(l_228 + 3)];
                        /* statement id: 228 */
                        assert ((l_200 >= &l_170[0][0][0] && l_200 <= &l_170[0][9][6]));
                        l_265 = l_263;
                        /* statement id: 229 */
                        assert ((l_265 >= &l_202[0] && l_265 <= &l_202[2]));
                    }
                    /* facts after branching */
                    assert ((l_265 >= &l_202[0] && l_265 <= &l_202[2]) || l_265 == &l_203);
                    for (l_158.f0 = (-26); (l_158.f0 < 28); l_158.f0 += 1)
                    { /* block id: 233 */
                        int32_t **l_268 = &l_189;
                        (*l_268) = l_189;
                        if (l_158.f0)
                            continue;
                    }
                }
            }
        }
        /* facts after for loop */
        assert ((l_200 >= &l_170[0][0][0] && l_200 <= &l_170[0][9][6]) || l_200 == 0);
    }
    else
    { /* block id: 240 */
        struct S0 *l_270 = &l_212;
        struct S0 **l_269[10] = {&l_270,&l_270,&l_270,&l_270,&l_270,&l_270,&l_270,&l_270,&l_270,&l_270};
        int i;
        l_271 = &l_212;
        return p_105;
    }
    (*l_273) = l_189;
    for (l_109 = 1; (l_109 > 17); l_109 += 6)
    { /* block id: 247 */
        int32_t l_276 = (-8L);
        int32_t l_278 = 0xD7D68073L;
        int32_t *l_277 = &l_278;
        l_276 = l_212.f3;
        (*l_273) = l_277;
        /* statement id: 249 */
        assert (l_189 == &l_278);
    }
    /* facts after for loop */
    //assert (l_189 == dangling || l_189 == 0);
    return l_279;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_35();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 219
   depth: 1, occurrence: 48
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 14
XXX zero bitfields defined in structs: 2
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 72
breakdown:
   indirect level: 0, occurrence: 32
   indirect level: 1, occurrence: 24
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 7
XXX full-bitfields structs in the program: 22
breakdown:
   indirect level: 0, occurrence: 22
XXX times a bitfields struct's address is taken: 38
XXX times a bitfields struct on LHS: 15
XXX times a bitfields struct on RHS: 49
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 41

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 331
   depth: 2, occurrence: 87
   depth: 3, occurrence: 6
   depth: 4, occurrence: 6
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 5
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 21, occurrence: 1

XXX total number of pointers: 295

XXX times a variable address is taken: 493
XXX times a pointer is dereferenced on RHS: 136
breakdown:
   depth: 1, occurrence: 109
   depth: 2, occurrence: 21
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 135
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 11
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 525

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 870
   level: 2, occurrence: 118
   level: 3, occurrence: 22
   level: 4, occurrence: 18
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 151
XXX number of pointers point to scalars: 79
XXX number of pointers point to structs: 65
XXX percent of pointers has null in alias set: 24.7
XXX average alias set size: 1.36

XXX times a non-volatile is read: 1014
XXX times a non-volatile is write: 475
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 302
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 31
   depth: 2, occurrence: 39
   depth: 3, occurrence: 45
   depth: 4, occurrence: 66
   depth: 5, occurrence: 89

XXX percentage a fresh-made variable is used: 28.2
XXX percentage an existing variable is used: 71.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

