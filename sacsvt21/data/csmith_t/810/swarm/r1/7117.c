/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      68251472
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_34(void);
inline static float  func_41(uint8_t  p_42, uint16_t  p_43, uint32_t  p_44, int32_t  p_45, uint16_t  p_46);
static uint8_t  func_47(int32_t  p_48, int16_t  p_49, float  p_50, uint32_t  p_51, int16_t  p_52);
static int32_t  func_62(uint32_t  p_63, uint32_t  p_64);
static int32_t  func_78(int32_t * p_79, int32_t * p_80, int16_t  p_81, int32_t  p_82, uint16_t  p_83);
static uint16_t  func_89(int32_t * p_90);
inline static uint16_t  func_97(uint16_t  p_98, int16_t  p_99, float  p_100);
inline static int16_t  func_102(uint8_t  p_103, int16_t  p_104, int32_t * p_105, float  p_106);
inline static int16_t  func_107(int32_t * p_108, int32_t * p_109);
inline static int32_t * func_116(uint8_t  p_117, uint8_t  p_118, int32_t * p_119, int16_t  p_120);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_34(void)
{ /* block id: 36 */
    uint32_t l_55 = 0x68F62C4D;
    uint8_t l_65 = 2U;
    uint32_t l_66 = 0x137D3709;
    int32_t l_67 = 0x36EAE117;
    int32_t l_68 = 9;
    uint32_t l_69 = 0x7A8D1D9D;
    uint16_t l_275 = 0xE741;
    int32_t l_287 = 0x18EE9594;
    int32_t *l_289 = (void*)0;
    int32_t **l_288 = &l_289;
    int32_t l_294 = 0x11DFD7D1;
    int32_t l_302 = 0;
    l_287 = ((float)((float)(((float)0x3.89B583p+45 - (float)func_41(func_47(((int16_t)l_55 >> (int16_t)(((int16_t)(((uint32_t)((__builtin_ia32_crc32qi(((uint16_t)l_55 >> (uint16_t)4), l_55) != (func_62(l_65, l_55) != ((func_62(l_65, l_66) ^ l_66) , l_55))) < l_55) / (uint32_t)l_67) < l_55) + (int16_t)l_68) && 0x1F6E)), l_65, l_69, l_68, l_55), l_68, l_65, l_66, l_275)) <= l_67) + (float)0x1.0p-1) / (float)l_69);
    (*l_288) = &l_287;
    (*l_288) = func_116(((*l_289) >= ((uint16_t)(**l_288) + (uint16_t)((int16_t)(**l_288) + (int16_t)(__builtin_ffsl((**l_288)) & (**l_288))))), l_294, (*l_288), (1 == 0x4629));
    (**l_288) = (((int16_t)(*l_289) % (int16_t)((uint16_t)(&l_289 != &l_289) >> (uint16_t)2)) >= ((**l_288) , (func_97(((((int16_t)(**l_288) >> (int16_t)11) >= (-(uint16_t)(**l_288))) < (**l_288)), (*l_289), (((func_78((*l_288), (*l_288), (**l_288), (**l_288), (*l_289)) == (*l_289)) , (**l_288)) < 0x9.51EC3Ep+44)) && (*l_289))));
    return l_302;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_41(uint8_t  p_42, uint16_t  p_43, uint32_t  p_44, int32_t  p_45, uint16_t  p_46)
{ /* block id: 122 */
    int32_t l_278 = 0x2A9ED5AC;
    float l_280 = 0xE.625EF2p+57;
    float *l_279 = &l_280;
    int32_t l_282 = 1;
    int32_t *l_281 = &l_282;
    (*l_279) = ((float)(-0x3.Fp+1) + (float)l_278);
    (*l_281) = p_42;
    for (l_282 = 0; (l_282 < (-21)); l_282 -= 1)
    { /* block id: 127 */
        float **l_285 = &l_279;
        float ***l_286 = &l_285;
        (*l_286) = l_285;
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_47(int32_t  p_48, int16_t  p_49, float  p_50, uint32_t  p_51, int16_t  p_52)
{ /* block id: 39 */
    int32_t l_76 = 0x5F0A8622;
    int32_t *l_210 = (void*)0;
    uint32_t l_274 = 0x762820C0;
    for (p_48 = 11; (p_48 != 20); p_48 += 3)
    { /* block id: 42 */
        int32_t l_86 = (-7);
        int32_t *l_85 = &l_86;
        float l_96 = 0x1.Fp+1;
        int32_t l_209 = (-8);
        if (p_49)
        { /* block id: 43 */
            float l_72 = 0x6.02C9AAp+21;
            int32_t l_73 = 1;
            int32_t *l_77 = &l_73;
            int16_t l_221 = (-9);
            uint8_t l_222 = 0xB9;
            (*l_77) = (((func_62(p_49, p_52) || (((l_73 < l_73) < p_52) > p_51)) , ((((((uint16_t)(__builtin_popcount(l_76) & 0x0510) >> (uint16_t)14) > p_52) > 0x06F6) >= p_51) >= p_51)) > 4294967290U);
            if ((*l_77))
            { /* block id: 45 */
                int32_t *l_84 = &l_73;
                int32_t **l_192 = &l_77;
                int32_t ***l_191 = &l_192;
                (*l_85) = func_78(l_84, l_85, (&p_48 == &p_48), (((((uint32_t)(func_89(&l_86) , (p_49 >= p_48)) / (uint32_t)__builtin_ctzll((*l_84))) != p_51) > p_49) , p_49), p_52);
                if (((uint16_t)p_52 << (uint16_t)p_51))
                { /* block id: 84 */
                    int32_t ****l_193 = &l_191;
                    (*l_193) = l_191;
                    if (p_48)
                        break;
                    (*l_77) = 0;
                }
                else
                { /* block id: 88 */
                    int16_t l_198 = 6;
                    if ((((p_49 != ((uint32_t)(((int16_t)(((l_198 < (*l_77)) , ((uint16_t)((int16_t)(((int32_t)((int16_t)l_76 >> (int16_t)p_51) + (int32_t)((**l_192) , ((int32_t)p_52 % (int32_t)func_62((*l_77), p_49)))) >= l_76) / (int16_t)l_209) % (uint16_t)(-1))) ^ l_198) / (int16_t)(-1)) < p_49) % (uint32_t)0x895D01DB)) != (-5)) != 0U))
                    { /* block id: 89 */
                        uint32_t l_217 = 4294967291U;
                        float *l_218 = &l_72;
                        (*l_192) = l_210;
                        (*l_218) = ((float)((float)(l_198 >= p_48) - (float)((float)l_198 + (float)l_198)) + (float)l_217);
                        (*l_192) = (**l_191);
                    }
                    else
                    { /* block id: 93 */
                        int32_t **l_219 = &l_210;
                        float *l_220 = &l_72;
                        (*l_192) = &l_73;
                        (*l_191) = l_219;
                        (*l_220) = (*l_77);
                    }
                    return l_221;
                }
            }
            else
            { /* block id: 100 */
                int32_t l_239 = 0x927C989E;
                uint8_t l_250 = 0x3C;
                int32_t **l_266 = &l_77;
                l_85 = ((p_50 <= ((l_76 , (__builtin_ctzl(p_52) >= p_50)) <= func_102(p_51, p_48, &l_86, l_222))) , (void*)0);
                (*l_77) = ((int32_t)(l_76 && ((*l_77) <= (!(((uint16_t)p_51 << (uint16_t)((int16_t)(&p_48 != ((((int16_t)(-4) << (int16_t)7) && ((p_49 > 0x0.FA3BE2p-64) , ((int32_t)p_49 % (int32_t)(((-(float)(p_48 > p_52)) , p_51) , p_49)))) , &l_73)) << (int16_t)11)) < p_48)))) / (int32_t)p_52);
                for (p_49 = 7; (p_49 == (-10)); p_49--)
                { /* block id: 105 */
                    float l_248 = 0x2.7p+1;
                    int32_t *l_249 = (void*)0;
                    int32_t **l_251 = &l_77;
                    (*l_251) = &p_48;
                    (*l_251) = (void*)0;
                    for (p_51 = (-29); (p_51 >= 16); ++p_51)
                    { /* block id: 110 */
                        float *l_254 = &l_96;
                        int32_t l_265 = 0;
                        (*l_254) = p_48;
                        (*l_254) = (((float)(-(float)((p_48 , p_49) , p_52)) + (float)(((((uint32_t)(-(int16_t)0x26C3) / (uint32_t)((uint32_t)((((func_102(((((float)(p_49 , (l_265 != 0x9.45EB10p-87)) / (float)__builtin_clz(p_48)) <= p_50) , l_265), p_48, &l_86, p_51) <= l_250) , l_266) != (void*)0) , 0x5A3005F4) - (uint32_t)p_48)) != l_265) , p_50) == 0xC.3CF241p+57)) < p_49);
                    }
                }
            }
            l_77 = ((p_48 , p_51) , &p_48);
        }
        else
        { /* block id: 117 */
            int32_t l_273 = 1;
            return l_273;
        }
    }
    return l_274;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_62(uint32_t  p_63, uint32_t  p_64)
{ /* block id: 37 */
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_78(int32_t * p_79, int32_t * p_80, int16_t  p_81, int32_t  p_82, uint16_t  p_83)
{ /* block id: 53 */
    uint16_t l_101 = 0x01C1;
    int32_t l_111 = (-2);
    int32_t *l_110 = &l_111;
    float l_188 = (-0x1.7p+1);
    float *l_187 = &l_188;
    (*l_187) = func_62(p_83, ((((func_97(l_101, func_102(p_81, func_107(l_110, &l_111), l_110, (p_81 , (func_62((~(((uint32_t)((((p_82 == l_101) , 9) , 0x5970) == p_83) % (uint32_t)0xAC2CC221) , p_82)), p_81) > l_101))), p_82) && p_81) , 8U) && 0U) & 0x52D1));
    return (*p_79);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_111 l_183
 */
static uint16_t  func_89(int32_t * p_90)
{ /* block id: 46 */
    int32_t l_91 = (-1);
    for (l_91 = 0; (l_91 == 15); ++l_91)
    { /* block id: 49 */
        float l_94 = 0x9.935178p+61;
        int32_t l_95 = 0xDE68BD5E;
        (*p_90) = l_95;
    }
    return l_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_97(uint16_t  p_98, int16_t  p_99, float  p_100)
{ /* block id: 79 */
    uint32_t l_186 = 1U;
    return l_186;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_102(uint8_t  p_103, int16_t  p_104, int32_t * p_105, float  p_106)
{ /* block id: 76 */
    int16_t l_170 = (-1);
    int32_t l_183 = 0xD366BA46;
    int32_t *l_182 = &l_183;
    float l_185 = 0x2.0DBC48p+38;
    float *l_184 = &l_185;
    (*l_184) = ((((float)p_103 / (float)(l_170 < __builtin_ctzll(((((uint32_t)l_170 % (uint32_t)l_170) ^ (((((uint16_t)0x8A2D + (uint16_t)((((uint16_t)(-(uint16_t)(((int16_t)(l_170 > ((l_170 , (*p_105)) & 0x7B01F996)) >> (int16_t)1) , p_104)) >> (uint16_t)p_104) < 0) | (*l_182))) || p_104) > (*l_182)) & (*l_182))) ^ (*l_182))))) == (*l_182)) < p_103);
    return p_103;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_107(int32_t * p_108, int32_t * p_109)
{ /* block id: 54 */
    float l_112 = 0x2.6D3C1Dp+68;
    int32_t l_113 = (-1);
    uint16_t l_123 = 0x4ABD;
    int32_t *l_164 = &l_113;
    int32_t **l_163 = &l_164;
    int32_t ***l_162 = &l_163;
    (*p_109) = l_113;
    for (l_113 = 26; (l_113 < 10); l_113 -= 3)
    { /* block id: 58 */
        float l_122 = 0xA.CD5B9Ap-18;
        int32_t *l_150 = (void*)0;
        int32_t **l_149 = &l_150;
        (*l_149) = func_116((4294967293U || (~l_113)), l_123, &l_113, l_113);
        if ((*p_109))
            continue;
        (*p_108) = ((((((((uint16_t)((((int16_t)(**l_149) / (int16_t)(((((-1) & (((int32_t)(~func_62(((uint16_t)func_89(p_109) + (uint16_t)(*l_150)), ((int32_t)__builtin_ctz(((**l_149) && (((**l_149) , (void*)0) == p_108))) / (int32_t)(*l_150)))) / (int32_t)l_123) , l_113)) , &l_150) != &l_150) && 0x7AE26BD8)) >= 0xE7D7DB6C) > l_113) >> (uint16_t)9) , (*l_150)) ^ 0x52BC) , 0xEE533B9E) , p_108) == &l_113) >= l_123);
        if (l_123)
            continue;
    }
    (*l_162) = &p_108;
    (***l_162) = (*l_164);
    return (***l_162);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_116(uint8_t  p_117, uint8_t  p_118, int32_t * p_119, int16_t  p_120)
{ /* block id: 59 */
    int32_t *l_124 = (void*)0;
    int32_t **l_125 = &l_124;
    int32_t l_146 = 0xBB7C4EAE;
    float l_148 = 0xE.FCE132p+78;
    float *l_147 = &l_148;
    (*l_125) = l_124;
    for (p_118 = 9; (p_118 == 15); p_118 += 4)
    { /* block id: 63 */
        uint32_t l_130 = 0xA67FE427;
        l_130 = ((int32_t)(*p_119) % (int32_t)0x9A1B0F83);
    }
    (*l_147) = ((float)((float)(((int32_t)(p_120 || ((*p_119) > 1)) % (int32_t)p_120) , p_117) + (float)((((int16_t)((*l_125) != (void*)0) >> (int16_t)6) , (((int16_t)((int16_t)(((int32_t)(-(int16_t)l_146) + (int32_t)(*p_119)) >= p_117) << (int16_t)p_120) << (int16_t)1) , l_146)) > p_120)) + (float)l_146);
    return p_119;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 62
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 11, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 24, occurrence: 1
   depth: 26, occurrence: 2
   depth: 32, occurrence: 1

XXX total number of pointers: 40

XXX times a variable address is taken: 47
XXX times a pointer is dereferenced on RHS: 49
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 31
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 1
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 1
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 113

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 101
   level: 2, occurrence: 32
   level: 3, occurrence: 3
XXX number of pointers point to pointers: 13
XXX number of pointers point to scalars: 27
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 15
XXX average alias set size: 1.32

XXX times a non-volatile is read: 340
XXX times a non-volatile is write: 76
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 61
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 8
   depth: 2, occurrence: 4
   depth: 3, occurrence: 5
   depth: 4, occurrence: 8
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 17.4
XXX percentage an existing variable is used: 82.6
********************* end of statistics **********************/

