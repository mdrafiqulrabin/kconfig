/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3825086182
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 1;
   unsigned f1 : 18;
   int16_t  f2;
   int32_t  f3;
   uint32_t  f4;
   const uint32_t  f5;
   int16_t  f6;
   int32_t  f7;
   int16_t  f8;
   uint32_t  f9;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_1(void);
inline static struct S0  func_2(int32_t  p_3, const uint32_t  p_4);
static struct S0  func_5(struct S0  p_6, int32_t  p_7, uint32_t  p_8, int16_t  p_9);
static uint32_t  func_15(int16_t  p_16, uint32_t  p_17, int16_t  p_18, uint32_t  p_19);
static int16_t  func_24(uint32_t  p_25, int16_t  p_26, uint32_t  p_27, struct S0  p_28);
static int32_t  func_31(int32_t * p_32, int32_t  p_33, int32_t * p_34, uint32_t  p_35, int32_t * p_36);
static int32_t  func_37(const int32_t * p_38, int32_t  p_39);
static int32_t * func_48(struct S0  p_49, int32_t  p_50);
static const uint32_t  func_52(int32_t * p_53, struct S0  p_54, uint32_t  p_55, int32_t  p_56);
inline static struct S0  func_57(uint32_t  p_58, int32_t * p_59, const uint32_t  p_60, const int16_t  p_61, struct S0  p_62);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_1(void)
{ /* block id: 0 */
    struct S0 l_10 = {-0,90,0xE8F5,0x172DDB74,0x71A6E483,1U,4,2,7,0x7E280BFE};
    int32_t l_30 = (-6);
    int32_t *l_29 = &l_30;
    uint32_t l_40 = 0x8CFB9963;
    int32_t l_381 = 8;
    int16_t *l_492 = &l_10.f2;
    int16_t **l_491 = &l_492;
    int16_t ***l_493 = &l_491;
    int32_t l_498 = (-3);
    (*l_29) = (func_2(((func_5(l_10, (safe_rshift_func_int16_t_s_u(l_10.f8, (safe_lshift_func_uint16_t_u_s(l_10.f3, 0)))), func_15(((safe_rshift_func_uint16_t_u_s(0xCF71, ((safe_mod_func_uint16_t_u_u((((l_10.f8 & l_10.f3) && (func_24((((*l_29) = l_10.f7) <= ((func_31(l_29, func_37(l_29, l_40), l_29, l_40, l_29) , 65535U) == l_10.f1)), l_10.f1, l_381, l_10) | l_10.f5)) != l_381), l_10.f9)) > 6U))) & l_10.f4), l_10.f8, l_10.f2, l_10.f6), l_10.f9) , (*l_29)) ^ 0xDE15898B), l_10.f5) , (*l_29));
    for (l_10.f7 = 0; (l_10.f7 == 0); l_10.f7 = safe_add_func_int16_t_s_s(l_10.f7, 9))
    { /* block id: 210 */
        int32_t *l_489 = (void*)0;
        int32_t **l_490 = &l_489;
        (*l_490) = l_489;
        (*l_29) = (*l_29);
    }
    (*l_493) = l_491;
    for (l_10.f2 = 0; (l_10.f2 < 6); l_10.f2 = safe_add_func_uint16_t_u_u(l_10.f2, 1))
    { /* block id: 217 */
        int32_t *l_496 = &l_10.f3;
        int32_t **l_497 = &l_29;
        (*l_497) = l_496;
        /* statement id: 218 */
        assert (l_29 == &l_10.f3);
        (*l_497) = (*l_497);
    }
    /* facts after for loop */
    assert (l_29 == &l_10.f3 || l_29 == &l_30);
    return l_498;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_2(int32_t  p_3, const uint32_t  p_4)
{ /* block id: 190 */
    uint16_t l_446 = 0x3799;
    uint16_t *l_445 = &l_446;
    int16_t l_448 = 0;
    int16_t *l_447 = &l_448;
    uint32_t l_457 = 2U;
    uint32_t *l_456 = &l_457;
    struct S0 l_458 = {0,50,0xDE59,0xAC4A36EE,0x288F30DE,4294967290U,0xC18C,1,0xA585,7U};
    uint32_t ***l_459 = (void*)0;
    uint32_t ****l_460 = (void*)0;
    uint32_t ****l_461 = &l_459;
    int32_t *l_462 = &l_458.f3;
    int32_t **l_469 = &l_462;
    int32_t ***l_468 = &l_469;
    int32_t ****l_467 = &l_468;
    const struct S0 l_475 = {-0,236,0x1B7E,0xB912B3F7,0U,0x54554EEE,1,4,3,0xBDEF841D};
    const struct S0 *l_474 = &l_475;
    const struct S0 **l_473 = &l_474;
    const struct S0 ***l_472 = &l_473;
    int16_t *l_480 = &l_458.f6;
    int32_t *l_485 = &l_458.f3;
    struct S0 l_486 = {0,300,0x43D1,-8,0U,1U,-8,-1,0x3F15,4U};
    (*l_462) = ((p_4 >= ((0x4A229037 & (((safe_unary_minus_func_uint32_t_u((((*l_445) = 6U) || ((*l_447) = p_4)))) , (((!(((*l_461) = (((safe_sub_func_int16_t_s_s(l_448, (safe_div_func_int16_t_s_s((func_57(((*l_456) = (l_446 == ((((((safe_add_func_int32_t_s_s(0, (l_446 | (p_3 < 0xD882)))) , l_448) && p_4) == l_448) || l_448) <= 0x77EB))), l_456, l_446, l_448, l_458) , p_4), l_446)))) , 0xBD97) , l_459)) != (void*)0)) >= p_4) > 0x9EB89612)) , p_4)) && 0x60B70825)) & p_4);
    (****l_467) = (p_3 < ((safe_mod_func_int16_t_s_s(((*l_462) <= ((((safe_rshift_func_uint16_t_u_s(1U, 2)) || (((*l_447) = ((void*)0 != l_467)) | ((*l_480) = ((l_458.f0 = (***l_468)) & (safe_div_func_int32_t_s_s((((((void*)0 == l_472) >= (safe_mod_func_int16_t_s_s((((safe_add_func_uint32_t_u_u((****l_467), (*l_462))) == 0U) , (**l_469)), p_3))) < (*l_462)) < p_4), p_4)))))) >= p_4) || 0x776C4493)), 8)) ^ p_3));
    (***l_467) = func_48((*l_474), p_3);
    /* statement id: 200 */
    assert (l_462 == 0);
    l_485 = ((**l_468) = func_48((***l_472), (((*l_445) = 1U) == ((65528U > ((*l_447) = (p_3 >= p_3))) < ((((*l_456) = (safe_lshift_func_int16_t_s_u(0x8DA1, 3))) , (safe_lshift_func_uint16_t_u_s((p_4 && (l_480 == (void*)0)), p_3))) <= p_3)))));
    /* statement id: 205 */
    assert (l_485 == 0);
    return l_486;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_5(struct S0  p_6, int32_t  p_7, uint32_t  p_8, int16_t  p_9)
{ /* block id: 182 */
    struct S0 **l_438 = (void*)0;
    struct S0 ***l_437 = &l_438;
    const uint32_t l_440 = 0x9BD36923;
    const uint32_t *l_439 = &l_440;
    int32_t l_442 = (-10);
    int32_t *l_441 = &l_442;
    struct S0 l_443 = {-0,372,0xAB36,-1,0xEEF1A464,4294967294U,2,0x600ED8D9,4,0x906698C8};
    for (p_6.f4 = 7; (p_6.f4 >= 25); p_6.f4++)
    { /* block id: 185 */
        int32_t l_434 = 1;
        int32_t *l_433 = &l_434;
        (*l_433) = (-7);
    }
    (*l_441) = (((p_6.f6 , (void*)0) == (p_6 , l_437)) > ((void*)0 != l_439));
    return l_443;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_15(int16_t  p_16, uint32_t  p_17, int16_t  p_18, uint32_t  p_19)
{ /* block id: 175 */
    int32_t ***l_405 = (void*)0;
    int32_t ****l_404 = &l_405;
    int32_t *l_408 = (void*)0;
    int32_t *l_409 = (void*)0;
    int32_t l_411 = 0x6D1F9C30;
    int32_t *l_410 = &l_411;
    uint16_t l_418 = 0x8AD0;
    uint16_t *l_417 = &l_418;
    uint32_t l_422 = 0xACF74116;
    uint32_t *l_421 = &l_422;
    uint32_t *l_424 = (void*)0;
    uint32_t **l_423 = &l_424;
    int32_t l_426 = (-1);
    int32_t *l_425 = &l_426;
    int32_t l_427 = 0xD3889C08;
    int32_t *l_428 = (void*)0;
    int32_t *l_429 = &l_427;
    int16_t l_430 = 0x5F02;
    (*l_429) = ((((((l_404 == &l_405) <= (((safe_div_func_int32_t_s_s((((*l_410) = 0xBB9BA463) | (safe_div_func_int32_t_s_s(((*l_425) = ((!(safe_lshift_func_uint16_t_u_s(((*l_417) = 5U), 10))) == (p_17 <= (((*l_421) = p_17) > ((void*)0 != l_423))))), 1U))), p_19)) > p_16) ^ 0)) < 0x397F) | 0xE42F) , p_17) == l_427);
    return l_430;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_24(uint32_t  p_25, int16_t  p_26, uint32_t  p_27, struct S0  p_28)
{ /* block id: 163 */
    uint32_t l_386 = 0U;
    int32_t l_389 = (-3);
    uint32_t l_391 = 0x1A3DFBA8;
    uint32_t *l_390 = &l_391;
    uint32_t **l_392 = &l_390;
    int32_t l_396 = 0xFD67946D;
    int32_t *l_395 = &l_396;
    uint16_t l_397 = 0x5ED4;
    int32_t *l_398 = (void*)0;
    int32_t *l_399 = (void*)0;
    int32_t *l_400 = (void*)0;
    int32_t l_402 = (-1);
    int32_t *l_401 = &l_402;
    uint32_t l_403 = 4U;
    for (p_28.f4 = (-28); (p_28.f4 != 26); p_28.f4 = safe_add_func_int32_t_s_s(p_28.f4, 6))
    { /* block id: 166 */
        return p_28.f7;
    }
    l_403 = ((0xB148 != (safe_mod_func_int32_t_s_s(l_386, (((((safe_add_func_uint16_t_u_u((((*l_390) = ((0x06CB < l_389) != 0)) , (&l_391 != ((*l_392) = &p_27))), (((*l_401) = (safe_lshift_func_uint16_t_u_u(l_386, (((((((*l_395) = p_28.f5) || (*l_395)) ^ 65530U) && (-1)) | p_28.f3) & l_397)))) || (*l_401)))) , 0xB442) ^ p_25) || (*l_401)) , 0xA5E41AAB)))) <= 4294967295U);
    /* statement id: 173 */
    assert (l_390 == &p_27);
    return p_28.f9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(int32_t * p_32, int32_t  p_33, int32_t * p_34, uint32_t  p_35, int32_t * p_36)
{ /* block id: 9 */
    int32_t l_47 = 1;
    int32_t *l_46 = &l_47;
    struct S0 l_51 = {-0,281,1,1,1U,4U,0xB55E,-10,-1,0x6B0C40B3};
    uint16_t l_70 = 0x6E08;
    uint16_t *l_69 = &l_70;
    uint32_t *l_364 = (void*)0;
    uint32_t l_366 = 0U;
    uint32_t *l_365 = &l_366;
    struct S0 *l_377 = &l_51;
    struct S0 **l_376 = &l_377;
    uint16_t l_378 = 0x49C5;
    l_46 = &p_33;
    /* statement id: 10 */
    assert (l_46 == &p_33);
    (*l_46) = func_37(func_48(l_51, ((*l_46) , ((((*l_365) = (func_52((func_57(p_35, &l_47, (!(p_35 , ((&p_33 == (void*)0) == ((safe_sub_func_uint16_t_u_u(((*l_69) = (safe_mod_func_uint16_t_u_u(p_33, (safe_unary_minus_func_int32_t_s(0xAFAEF9AD))))), 65526U)) , (*l_46))))), p_33, l_51) , &p_33), l_51, (*l_46), (*l_46)) && (*l_46))) , p_33) || (*l_46)))), l_51.f8);
    if ((((safe_div_func_int32_t_s_s((((*l_46) = (((((*l_46) == ((*l_46) <= (safe_div_func_int16_t_s_s((((*l_46) != (safe_sub_func_uint32_t_u_u((l_376 != (((*l_46) || ((((*l_69) = (*l_46)) | (*l_46)) & p_35)) , &l_377)), (-3)))) , 0xEA55), (*l_46))))) || (*l_46)) >= (*l_46)) , (*l_46))) >= l_47), l_378)) != l_51.f5) , (*l_46)))
    { /* block id: 158 */
        uint32_t l_379 = 0x6600051D;
        return l_379;
    }
    else
    { /* block id: 160 */
        uint16_t l_380 = 0xDA6F;
        return l_380;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_37(const int32_t * p_38, int32_t  p_39)
{ /* block id: 2 */
    uint32_t l_45 = 5U;
    for (p_39 = 0; (p_39 == 15); p_39 = safe_add_func_uint16_t_u_u(p_39, 1))
    { /* block id: 5 */
        int32_t l_44 = 0xF961DFA2;
        int32_t *l_43 = &l_44;
        (*l_43) = 5;
    }
    return l_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_48(struct S0  p_49, int32_t  p_50)
{ /* block id: 152 */
    int32_t l_368 = 0;
    int32_t *l_367 = &l_368;
    int32_t *l_369 = (void*)0;
    (*l_367) = p_49.f9;
    return l_369;
    /* statement id: 154 */
    //assert (func_48_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_52(int32_t * p_53, struct S0  p_54, uint32_t  p_55, int32_t  p_56)
{ /* block id: 139 */
    const int32_t l_335 = 0x7DCAFD54;
    int16_t l_347 = 0xFD0A;
    int16_t *l_346 = &l_347;
    int16_t l_349 = 0x8D55;
    int16_t *l_348 = &l_349;
    uint16_t l_350 = 0x02D2;
    int32_t l_351 = 0xE5027362;
    uint32_t l_353 = 0x7064428E;
    uint32_t *l_352 = &l_353;
    int32_t l_355 = 0x1DE3CCF8;
    int32_t *l_354 = &l_355;
    struct S0 *l_358 = (void*)0;
    const int16_t l_361 = 9;
    int32_t l_362 = 0xDB23A2BF;
    uint16_t *l_363 = &l_350;
    (*l_354) = ((safe_sub_func_uint16_t_u_u((safe_add_func_uint32_t_u_u((safe_mod_func_int32_t_s_s((safe_add_func_uint16_t_u_u(l_335, (l_335 , (safe_rshift_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((((safe_unary_minus_func_int32_t_s(((~(((safe_mul_func_int32_t_s_s(0, ((*l_352) = ((safe_add_func_int16_t_s_s((l_351 = (l_350 = (((l_335 != 2) == ((*p_53) = l_335)) | (((*l_348) = (((*l_346) = (p_54.f6 || l_335)) >= p_54.f1)) > 0xA305)))), l_335)) < l_335)))) == (-1)) | l_335)) >= (-6)))) && p_54.f5) > p_56), l_335)), l_335))))), l_335)), p_54.f4)), l_335)) > l_335);
    (*l_354) = ((safe_rshift_func_int16_t_s_u((l_358 == (void*)0), 6)) == (safe_div_func_uint16_t_u_u(((*l_363) = (l_361 == ((((*l_354) ^ (((*l_352) = ((p_54.f0 || (((void*)0 != &l_352) , ((void*)0 != &l_350))) & 65535U)) != (*l_354))) ^ l_362) == p_54.f6))), p_54.f6)));
    return p_54.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_57(uint32_t  p_58, int32_t * p_59, const uint32_t  p_60, const int16_t  p_61, struct S0  p_62)
{ /* block id: 12 */
    int32_t l_72 = (-1);
    int32_t *l_71 = &l_72;
    int32_t **l_73 = &l_71;
    struct S0 l_76 = {-0,294,0,-1,1U,0xF288C1B9,-1,0xB7E04BE0,0xDECC,0x6B58F18C};
    struct S0 *l_75 = &l_76;
    struct S0 **l_74 = &l_75;
    uint16_t l_94 = 6U;
    uint16_t *l_93 = &l_94;
    uint32_t l_135 = 0x9D52E2DA;
    int16_t l_201 = (-6);
    uint32_t **l_231 = (void*)0;
    uint32_t ***l_230 = &l_231;
    uint32_t l_256 = 4294967295U;
    (*l_73) = l_71;
    (*l_74) = &p_62;
    /* statement id: 14 */
    assert (l_75 == &p_62);
    if ((safe_mod_func_uint32_t_u_u(4294967287U, (safe_lshift_func_int16_t_s_u((safe_mod_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(0x961B9AEE, p_62.f5)), ((safe_sub_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((*l_71), p_62.f8)), ((((safe_mod_func_int16_t_s_s((safe_mod_func_int16_t_s_s(p_58, 0xC8F0)), ((((**l_74) , l_93) != (void*)0) || 0x72693068))) & (*p_59)) && p_58) || 0xE153))) , (*l_71)))), p_62.f7)))))
    { /* block id: 15 */
        struct S0 *l_96 = &l_76;
        struct S0 **l_95 = &l_96;
        int32_t l_134 = 1;
        uint16_t *l_161 = &l_94;
        int32_t ***l_166 = &l_73;
        (*l_95) = (p_60 , ((*l_74) = (void*)0));
        /* statement id: 17 */
        assert (l_75 == 0);
        assert (l_96 == 0);
        for (p_62.f4 = 0; (p_62.f4 <= 55); p_62.f4 = safe_add_func_uint32_t_u_u(p_62.f4, 2))
        { /* block id: 20 */
            const struct S0 l_105 = {0,304,0xF12B,0,5U,0x1E4501C6,6,-4,0x819B,7U};
            uint32_t l_150 = 5U;
        }
        (*l_166) = (void*)0;
        /* statement id: 54 */
        assert (l_73 == 0);
    }
    else
    { /* block id: 55 */
        int32_t *l_167 = &l_72;
        struct S0 **l_168 = &l_75;
        int32_t l_177 = 0x50DD38C2;
        int32_t l_183 = 0xD2BA4BAB;
        uint32_t l_212 = 0xFB7BDAAF;
        uint32_t *l_211 = &l_212;
        uint32_t **l_210 = &l_211;
        uint32_t ***l_209 = &l_210;
        uint16_t *l_243 = &l_94;
        int32_t ***l_277 = &l_73;
        int32_t ****l_276 = &l_277;
        struct S0 **l_290 = &l_75;
        (*l_73) = l_167;
        if ((p_58 , (((0 & (l_168 == &l_75)) > ((~((*l_167) = p_60)) != (safe_lshift_func_uint16_t_u_s(((*l_93) = ((p_62.f0 ^ ((!(safe_rshift_func_uint16_t_u_s(((p_62.f6 <= (safe_div_func_int16_t_s_s(p_62.f5, l_177))) >= p_58), 0))) | p_60)) < p_62.f7)), 4)))) > 2U)))
        { /* block id: 59 */
            return p_62;
        }
        else
        { /* block id: 61 */
            int32_t l_187 = (-1);
            int16_t *l_199 = &l_76.f8;
            int16_t *l_200 = &l_76.f6;
            int32_t *l_208 = &l_76.f3;
            (*p_59) = ((0xCEAB ^ (((safe_div_func_uint16_t_u_u((((*l_200) = ((*l_199) = (!((safe_sub_func_uint32_t_u_u(l_183, (safe_unary_minus_func_uint16_t_u((((safe_lshift_func_uint16_t_u_s((l_187 >= ((safe_mod_func_int32_t_s_s((0xD1B8 < (safe_mod_func_uint16_t_u_u((safe_div_func_uint32_t_u_u(p_62.f6, ((*l_167) || ((*l_167) = ((((*l_93) = ((safe_rshift_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(l_187, (p_62.f8 | (safe_unary_minus_func_uint32_t_u((*l_167)))))), l_187)) < (*l_167))) | (**l_73)) , p_62.f8))))), l_187))), l_187)) > l_187)), 14)) <= 0x8DA9) < p_61))))) , p_62.f4)))) || p_62.f4), p_62.f3)) , l_200) != l_199)) <= p_62.f5);
            (*l_208) = (((0xDBC9 != (0xB860 & (((l_201 == ((*l_167) = (safe_lshift_func_uint16_t_u_u(((*l_93) = (safe_sub_func_int16_t_s_s(p_58, (p_62.f0 == (safe_add_func_uint32_t_u_u((*l_71), ((*p_59) = (*p_59)))))))), 2)))) ^ l_187) < ((p_62.f8 & p_62.f7) ^ l_183)))) == 0x76D6EEA9) & l_187);
        }
        (*l_209) = (void*)0;
        /* statement id: 72 */
        assert (l_210 == 0);
        for (l_76.f8 = 0; (l_76.f8 == (-2)); l_76.f8 = safe_sub_func_int16_t_s_s(l_76.f8, 2))
        { /* block id: 75 */
            uint16_t l_215 = 0xC7E9;
            int32_t ***l_221 = &l_73;
            int32_t ***l_222 = &l_73;
            struct S0 l_254 = {-0,45,0,0xCAE6DAE2,0x023DFF76,0x65F32281,-1,1,0x9493,4294967295U};
            uint32_t **l_273 = (void*)0;
            if (l_215)
                break;
            for (l_76.f7 = 14; (l_76.f7 <= 4); l_76.f7 = safe_sub_func_int16_t_s_s(l_76.f7, 9))
            { /* block id: 79 */
                uint32_t l_229 = 0x50AFB25A;
                uint16_t *l_242 = &l_215;
                const int32_t *l_244 = &l_72;
                int32_t ****l_278 = &l_277;
                const int32_t **l_318 = (void*)0;
                struct S0 **l_322 = &l_75;
                for (p_58 = 22; (p_58 == 37); p_58++)
                { /* block id: 82 */
                    int32_t ***l_220 = &l_73;
                    int32_t ***l_223 = &l_73;
                    int32_t ****l_224 = (void*)0;
                    int32_t ****l_225 = (void*)0;
                    int32_t ****l_226 = &l_222;
                    uint32_t ***l_232 = &l_231;
                    uint32_t ****l_233 = &l_232;
                    int32_t *l_241 = (void*)0;
                    int16_t *l_259 = &l_254.f8;
                    struct S0 **l_288 = &l_75;
                    struct S0 ***l_289 = &l_168;
                    const int32_t **l_312 = &l_244;
                    const int32_t ***l_311 = &l_312;
                }
                return p_62;
            }
            if ((*p_59))
                break;
        }
    }
    /* facts after branching */
    assert (l_73 == &l_71 || l_73 == 0);
    assert (l_75 == &p_62 || l_75 == 0);
    for (l_72 = 0; (l_72 == 8); l_72 = safe_add_func_int16_t_s_s(l_72, 4))
    { /* block id: 134 */
        int32_t *l_325 = &l_76.f3;
        int32_t **l_326 = &l_325;
        if ((*l_71))
            break;
        (*l_326) = l_325;
    }
    return p_62;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 76
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 18
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 7
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 11

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 6, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 4
   depth: 21, occurrence: 2
   depth: 24, occurrence: 2
   depth: 27, occurrence: 1
   depth: 29, occurrence: 2
   depth: 34, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 127

XXX times a variable address is taken: 115
XXX times a pointer is dereferenced on RHS: 81
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 9
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 108
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 4
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 413

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 268
   level: 2, occurrence: 36
   level: 3, occurrence: 37
   level: 4, occurrence: 13
XXX number of pointers point to pointers: 50
XXX number of pointers point to scalars: 70
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 28.3
XXX average alias set size: 1.12

XXX times a non-volatile is read: 553
XXX times a non-volatile is write: 265
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 59
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 18
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2

XXX percentage a fresh-made variable is used: 15.5
XXX percentage an existing variable is used: 84.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

