/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      393601276
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
};

struct S1 {
   unsigned f0 : 4;
   unsigned f1 : 24;
   signed f2 : 11;
   unsigned f3 : 1;
   signed f4 : 2;
   unsigned f5 : 17;
   signed f6 : 20;
};

struct S2 {
   int16_t  f0;
   int32_t  f1;
   struct S1  f2;
   uint32_t  f3;
   int32_t  f4;
   int32_t  f5;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_27(void);
inline static uint16_t  func_34(int32_t  p_35);
static uint16_t  func_41(struct S0  p_42);
static struct S2  func_44(int16_t  p_45);
static struct S0  func_47(struct S0  p_48, uint32_t  p_49);
static int16_t  func_53(int16_t  p_54, struct S2  p_55, uint32_t  p_56, uint16_t  p_57);
inline static uint32_t  func_59(uint32_t  p_60, struct S2  p_61, uint32_t  p_62, int16_t  p_63);
static struct S2  func_65(int32_t  p_66, int16_t  p_67);
static uint32_t  func_70(int32_t  p_71, uint32_t  p_72, int16_t  p_73, struct S2  p_74);
inline static uint32_t  func_88(int16_t  p_89, int32_t  p_90, struct S0  p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_27(void)
{ /* block id: 36 */
    uint16_t l_28 = 65535U;
    uint32_t l_29 = 0xE19F23E5;
    uint32_t l_38 = 1U;
    struct S0 l_43 = {0xA094};
    struct S2 l_252 = {1,0x40D86849,{2,3086,-23,0,-1,151,575},0U,-10,1};
    l_29 = l_28;
    if (__builtin_clz(((int16_t)l_29 - (int16_t)(((uint16_t)func_34(((int16_t)8 % (int16_t)(((l_38 & ((uint16_t)func_41(l_43) << (uint16_t)8)) <= ((((uint32_t)(l_43.f0 || func_70(l_28, func_59(l_29, func_44(((0U & l_38) <= l_38)), l_43.f0, l_29), l_38, l_252)) % (uint32_t)0xE7697F25) || 0) | 0x93D3)) ^ l_252.f0))) % (uint16_t)l_252.f5) || l_29))))
    { /* block id: 206 */
        uint32_t l_310 = 1U;
        l_252 = l_252;
        return l_310;
    }
    else
    { /* block id: 209 */
        l_252.f2.f6 = (l_252.f2.f2 != l_38);
    }
    return l_252.f2.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_34(int32_t  p_35)
{ /* block id: 165 */
    uint32_t l_253 = 4294967295U;
    struct S1 l_254 = {3,3647,22,0,-0,82,1007};
    struct S2 l_268 = {0xFA20,0x3B6ED61A,{2,1766,-4,0,-0,197,-943},0xC0651202,1,7};
    struct S0 l_273 = {0x341C};
    if (l_253)
    { /* block id: 166 */
        struct S1 l_255 = {3,3812,-28,0,-1,119,750};
        struct S2 l_269 = {0,0x32B3647B,{3,3943,-19,0,-1,112,-350},0xD96F55D1,0x1BC6CD9A,1};
        struct S0 l_274 = {0x1158};
        int32_t l_279 = (-1);
        int32_t l_298 = 0xA9D95EAD;
        if (__builtin_popcountl(p_35))
        { /* block id: 167 */
            uint16_t l_263 = 1U;
            l_255 = l_254;
            for (p_35 = 0; (p_35 != 0); p_35 += 5)
            { /* block id: 171 */
                int32_t l_260 = (-1);
                int32_t l_272 = 1;
                l_254.f6 = (((uint16_t)(((l_260 >= ((uint16_t)0x2235 << (uint16_t)(((l_263 && (((uint16_t)(((((uint16_t)(((0U < l_255.f3) | l_260) < (((p_35 > p_35) ^ ((((p_35 > p_35) != 1U) == l_254.f6) & p_35)) > p_35)) + (uint16_t)6U) == l_254.f6) <= 0x8B3B) & 0) >> (uint16_t)13) < 0x4F759F00)) && 0U) || p_35))) & l_255.f0) || 4294967293U) << (uint16_t)p_35) < 0xD0D9);
                l_269 = l_268;
                l_272 = ((int32_t)p_35 - (int32_t)l_269.f1);
                l_274 = l_273;
            }
            l_269 = l_269;
        }
        else
        { /* block id: 178 */
            uint16_t l_280 = 0xBE8B;
            struct S0 l_287 = {65527U};
            int32_t l_289 = (-7);
            if (l_269.f4)
            { /* block id: 179 */
                struct S1 l_275 = {2,2405,-6,0,1,273,-757};
                struct S0 l_278 = {65526U};
                l_269.f2 = l_275;
                l_254.f6 = (((((uint16_t)func_41(func_47(l_278, l_279)) % (uint16_t)p_35) == l_280) ^ ((int32_t)((__builtin_parityll(l_268.f5) && p_35) && l_269.f2.f0) - (int32_t)l_280)) && l_273.f0);
                for (l_269.f0 = 0; (l_269.f0 == 24); l_269.f0 += 9)
                { /* block id: 184 */
                    for (p_35 = 4; (p_35 == 14); p_35 += 9)
                    { /* block id: 187 */
                        uint32_t l_288 = 0x0A512BFD;
                        l_273 = func_47(l_287, p_35);
                        l_288 = p_35;
                    }
                }
            }
            else
            { /* block id: 192 */
                l_289 = 0xADFF3299;
            }
            l_269 = l_269;
            l_274 = l_287;
        }
        l_269.f2.f6 = ((int32_t)2 % (int32_t)func_53((((uint16_t)((uint16_t)((int16_t)(l_269.f5 < 0x56FF) >> (int16_t)__builtin_parityl(l_298)) % (uint16_t)l_269.f2.f2) * (uint16_t)(((uint16_t)65528U >> (uint16_t)12) ^ ((int16_t)((int32_t)((int16_t)0 % (int16_t)0x9FA5) % (int32_t)0x51BE30D7) << (int16_t)3))) >= 1U), l_268, l_269.f2.f3, l_269.f5));
    }
    else
    { /* block id: 199 */
        uint32_t l_307 = 0x1B625347;
        l_307 = (p_35 != 0);
        return l_268.f2.f5;
    }
    l_268.f2.f4 = l_254.f3;
    l_254.f2 = ((int16_t)l_254.f3 % (int16_t)p_35);
    return l_268.f2.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_41(struct S0  p_42)
{ /* block id: 38 */
    uint32_t l_46 = 4294967295U;
    struct S2 l_248 = {-7,1,{2,3058,9,0,1,358,-851},4294967294U,0x37F1068F,-6};
    int32_t l_249 = 0x7671808F;
    l_248 = func_44(l_46);
    l_249 = 0x995BE46C;
    return p_42.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_44(int16_t  p_45)
{ /* block id: 39 */
    struct S0 l_50 = {65535U};
    struct S2 l_58 = {0x53E8,2,{0,2564,-34,0,0,300,-395},4294967295U,0xD0D4A498,0x597FB6F8};
    int32_t l_239 = 0xC49628F9;
    l_50 = func_47(l_50, (((uint16_t)((((func_53(p_45, l_58, l_58.f1, l_58.f5) > ((uint16_t)((uint16_t)l_58.f2.f4 - (uint16_t)(p_45 > ((int32_t)0 % (int32_t)l_58.f2.f5))) << (uint16_t)l_58.f4)) && l_239) <= 0xDF1E) < p_45) * (uint16_t)0x2342) | p_45));
    l_58.f2.f2 = p_45;
    l_58 = l_58;
    return l_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_47(struct S0  p_48, uint32_t  p_49)
{ /* block id: 146 */
    int32_t l_242 = (-1);
    int32_t l_244 = (-1);
    struct S0 l_247 = {0xAA63};
    for (p_49 = 0; (p_49 == 42); p_49 += 3)
    { /* block id: 149 */
        uint16_t l_245 = 0U;
        int32_t l_246 = 0x6681958A;
        if (l_242)
        { /* block id: 150 */
            return p_48;
        }
        else
        { /* block id: 152 */
            int16_t l_243 = 0x3B14;
            l_244 = l_243;
            l_246 = __builtin_parityl(l_245);
        }
    }
    return l_247;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_53(int16_t  p_54, struct S2  p_55, uint32_t  p_56, uint16_t  p_57)
{ /* block id: 40 */
    int32_t l_64 = 0x8954837A;
    struct S0 l_92 = {65535U};
    struct S2 l_96 = {-7,0,{3,2282,23,0,-0,18,527},0x1F03B47F,1,0x9D718AB8};
    uint32_t l_98 = 0x3D6DB513;
    uint32_t l_172 = 0xEEA47A0F;
    struct S2 l_218 = {2,1,{2,2655,18,0,-1,61,388},0xF4A9CFAD,0xF14D3C65,-8};
    if ((func_59(l_64, func_65(((uint32_t)func_70(p_55.f2.f3, p_54, ((int16_t)((((int32_t)(((int16_t)l_64 - (int16_t)(-(uint16_t)0x1C92)) == (p_57 != ((int16_t)((int32_t)((uint16_t)((((-1) >= (func_88(l_64, l_64, l_92) != l_64)) & l_64) > l_92.f0) * (uint16_t)0U) - (int32_t)0U) % (int16_t)p_55.f1))) % (int32_t)l_92.f0) & l_92.f0) || 0xA0B358DD) >> (int16_t)13), l_96) % (uint32_t)l_98), l_96.f2.f6), p_55.f2.f5, l_96.f0) > p_55.f2.f3))
    { /* block id: 63 */
        int16_t l_129 = (-6);
        uint32_t l_131 = 0xC3B0D5B0;
        int32_t l_132 = (-10);
        int32_t l_151 = (-8);
        for (l_96.f5 = 0; (l_96.f5 == (-22)); l_96.f5 -= 4)
        { /* block id: 66 */
            int16_t l_130 = 0x9ABB;
            l_64 = __builtin_bswap64(((0x1493 | (0U > (p_55.f2.f4 <= ((uint32_t)(((((int16_t)((l_129 && (l_98 < p_55.f4)) || l_130) * (int16_t)l_96.f2.f5) || (l_131 > p_55.f4)) | l_129) == l_130) + (uint32_t)l_132)))) || p_55.f3));
            p_55.f2.f2 = ((uint16_t)l_130 * (uint16_t)0xF959);
        }
        p_55.f2.f2 = p_55.f0;
        p_55 = l_96;
        for (l_96.f5 = 0; (l_96.f5 > 11); ++l_96.f5)
        { /* block id: 74 */
            int32_t l_142 = 1;
            int32_t l_193 = 0x166D845A;
            uint32_t l_203 = 0x52EFB72A;
            for (l_92.f0 = 0; (l_92.f0 > 45); l_92.f0 += 1)
            { /* block id: 77 */
                int32_t l_141 = 3;
                struct S0 l_157 = {1U};
                struct S2 l_169 = {0xFF5C,0xC88DF480,{1,3853,4,0,1,47,-709},0U,0xC317C6A2,1};
                for (l_98 = 0; (l_98 <= 24); l_98 += 1)
                { /* block id: 80 */
                    l_142 = l_141;
                }
                if (p_55.f1)
                    break;
                if (((uint16_t)((((int32_t)(p_55.f0 <= l_141) % (int32_t)((int16_t)l_132 % (int16_t)l_142)) >= (((uint16_t)(p_54 | p_55.f5) << (uint16_t)l_151) > ((!(((int16_t)((int16_t)(l_141 < func_88(l_141, l_141, l_157)) >> (int16_t)p_55.f5) % (int16_t)l_142) | p_54)) >= 0x488BB19F))) | l_141) * (uint16_t)0xC148))
                { /* block id: 84 */
                    int16_t l_168 = 0x472F;
                    for (l_151 = 0; (l_151 == (-27)); l_151 -= 2)
                    { /* block id: 87 */
                        uint32_t l_167 = 0U;
                        p_55.f2.f4 = (((-(int32_t)((int16_t)((int32_t)l_141 - (int32_t)0) * (int16_t)p_55.f2.f0)) != p_54) >= func_59(((uint32_t)0xB66546BC % (uint32_t)(func_70(l_167, (p_55.f0 >= l_168), l_96.f3, l_169) ^ 0x6EA0)), l_169, l_96.f2.f5, p_55.f2.f5));
                    }
                }
                else
                { /* block id: 90 */
                    int16_t l_173 = 0x1FFE;
                    int32_t l_177 = 0xD4C9FC46;
                    for (l_169.f0 = (-5); (l_169.f0 != (-14)); l_169.f0 -= 3)
                    { /* block id: 93 */
                        struct S2 l_176 = {0x1B2F,-1,{0,2043,4,0,-0,28,-422},4294967295U,-1,0x6E29E21D};
                        l_172 = (-4);
                        l_177 = func_70(p_55.f2.f5, ((l_173 != ((((((int16_t)(0x2488 > (((5U > l_169.f2.f1) ^ (0xB7091F55 && p_57)) >= (((p_55.f2.f0 || ((p_55.f5 || p_55.f2.f3) == p_55.f3)) < p_55.f2.f6) < 0xA790))) * (int16_t)p_55.f2.f1) == l_142) || l_173) > l_169.f4) == p_55.f2.f4)) | l_169.f3), l_142, l_176);
                    }
                    if (l_142)
                        continue;
                }
                if (l_129)
                { /* block id: 99 */
                    p_55.f2.f6 = l_169.f2.f5;
                }
                else
                { /* block id: 101 */
                    uint16_t l_190 = 0x4B02;
                    struct S0 l_192 = {0U};
                    struct S1 l_194 = {2,1302,7,0,1,352,983};
                    int16_t l_198 = 0x4FDF;
                    l_151 = (4294967295U | 7U);
                    if (((int16_t)(l_142 ^ (func_70(((((((l_96.f5 <= l_132) > p_55.f2.f0) ^ (p_55.f1 != ((((int16_t)((((1U | l_142) ^ l_92.f0) < (((int16_t)((int16_t)0xA50A + (int16_t)p_55.f2.f5) * (int16_t)p_55.f5) > (-10))) < l_132) % (int16_t)p_57) != l_96.f0) > l_142))) & p_57) >= p_55.f2.f1) ^ p_55.f2.f6), p_55.f0, l_142, l_169) >= p_55.f1)) % (int16_t)p_55.f2.f0))
                    { /* block id: 103 */
                        int32_t l_191 = 0xE06A67EA;
                        l_193 = func_88(p_55.f2.f1, (((uint16_t)l_92.f0 << (uint16_t)((uint32_t)l_190 % (uint32_t)__builtin_popcountl(l_169.f2.f5))) ^ l_191), l_192);
                        p_55 = p_55;
                    }
                    else
                    { /* block id: 106 */
                        uint16_t l_199 = 0xEC47;
                        l_194 = p_55.f2;
                        l_203 = (((int32_t)(((!func_70(l_198, p_55.f2.f6, l_199, p_55)) <= __builtin_bswap64(l_169.f2.f3)) >= (!(((uint16_t)l_142 >> (uint16_t)10) && func_70(p_55.f2.f0, l_199, l_141, l_96)))) + (int32_t)p_55.f0) & l_96.f1);
                    }
                }
            }
            if (l_96.f2.f0)
                continue;
            if (l_96.f2.f1)
                continue;
        }
    }
    else
    { /* block id: 115 */
        struct S0 l_204 = {1U};
        if (p_56)
        { /* block id: 116 */
            l_92 = l_204;
            return p_55.f2.f0;
        }
        else
        { /* block id: 119 */
            int32_t l_217 = 2;
            struct S0 l_219 = {0x349B};
            p_55.f2.f4 = l_204.f0;
            p_55.f2.f4 = (((int16_t)((uint32_t)(l_96.f2.f3 ^ 4294967287U) - (uint32_t)(((int16_t)((uint32_t)p_55.f0 % (uint32_t)0x7ADDD033) >> (int16_t)1) == func_70(((int16_t)((uint16_t)0x7D8B - (uint16_t)((p_55.f2.f1 == l_204.f0) >= 4)) % (int16_t)0x76A0), l_217, p_55.f2.f1, l_218))) << (int16_t)p_56) > 0U);
            l_92 = l_219;
        }
    }
    if ((+0x3240))
    { /* block id: 125 */
        struct S0 l_221 = {0x86E4};
        uint16_t l_222 = 0U;
        int32_t l_223 = 0;
        l_92 = l_221;
        l_218.f2.f2 = ((p_55.f2.f6 >= p_56) <= p_55.f2.f3);
        l_223 = l_222;
    }
    else
    { /* block id: 129 */
        int16_t l_224 = 0xA4CF;
        int32_t l_225 = (-1);
        struct S2 l_228 = {-1,9,{3,1333,-42,0,-0,56,-120},0x9A675D47,0,1};
        l_64 = __builtin_ffsll(p_56);
        p_55.f2.f2 = l_224;
        l_225 = ((-1) != (((0x4DCBB3E8 && p_55.f0) == (-10)) ^ l_224));
        for (l_98 = 0; (l_98 == 37); l_98 += 5)
        { /* block id: 135 */
            if ((p_56 != p_57))
            { /* block id: 136 */
                p_55 = l_228;
            }
            else
            { /* block id: 138 */
                p_55.f2.f4 = ((p_55.f2.f0 != 65530U) == 0xB781);
            }
            l_228.f2.f4 = ((int16_t)(l_96.f0 | ((uint16_t)p_55.f2.f6 * (uint16_t)1U)) << (int16_t)4);
            return p_57;
        }
    }
    return p_55.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_59(uint32_t  p_60, struct S2  p_61, uint32_t  p_62, int16_t  p_63)
{ /* block id: 54 */
    uint16_t l_120 = 65531U;
    int32_t l_121 = (-9);
    for (p_61.f5 = 6; (p_61.f5 >= 20); p_61.f5 += 1)
    { /* block id: 57 */
        struct S1 l_122 = {2,2267,-44,0,-1,38,-658};
        l_121 = ((int16_t)__builtin_ffsll(l_120) * (int16_t)l_120);
        p_61.f2 = l_122;
        p_61.f2.f4 = 0xE5F25790;
    }
    return l_121;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_65(int32_t  p_66, int16_t  p_67)
{ /* block id: 49 */
    uint16_t l_99 = 0x8704;
    uint32_t l_114 = 0xAC122870;
    struct S2 l_115 = {0xDD83,0xB06C3112,{0,1457,-24,0,1,148,-429},0U,1,0};
    l_99 = p_66;
    p_66 = 0;
    p_66 = ((int16_t)(__builtin_popcountll(((p_66 == l_99) | (((uint16_t)l_99 + (uint16_t)((((uint16_t)((int16_t)((int16_t)((9U != ((p_67 > (((int16_t)1 * (int16_t)((int32_t)p_67 + (int32_t)((p_67 && (p_66 && 0)) == l_114))) != 0x2C05F70B)) > l_99)) != p_67) - (int16_t)p_66) * (int16_t)p_66) * (uint16_t)l_114) < 0xBBF6D4BD) ^ l_114)) <= (-1)))) && 0x0F6EBCB2) >> (int16_t)l_99);
    return l_115;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_70(int32_t  p_71, uint32_t  p_72, int16_t  p_73, struct S2  p_74)
{ /* block id: 46 */
    int32_t l_97 = 0x8499145A;
    p_74.f2.f4 = p_74.f1;
    return l_97;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_88(int16_t  p_89, int32_t  p_90, struct S0  p_91)
{ /* block id: 41 */
    uint32_t l_93 = 4294967295U;
    struct S0 l_94 = {0x04DD};
    struct S0 l_95 = {0xABB6};
    l_93 = p_90;
    p_91 = l_94;
    l_95 = l_94;
    return l_94.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 60
   depth: 1, occurrence: 20
   depth: 2, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 16
breakdown:
   indirect level: 0, occurrence: 16
XXX full-bitfields structs in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 13
XXX times a bitfields struct on RHS: 25
XXX times a single bitfield on LHS: 19
XXX times a single bitfield on RHS: 52

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 127
   depth: 2, occurrence: 23
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 307
XXX times a non-volatile is write: 76
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 107
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 23
   depth: 2, occurrence: 22
   depth: 3, occurrence: 14
   depth: 4, occurrence: 8
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 25.3
XXX percentage an existing variable is used: 74.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

