/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3134042126
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_33(void);
static int32_t * func_34(int32_t * p_35, int32_t * p_36);
static int32_t * func_37(int32_t * p_38, int32_t * p_39);
static int32_t * func_40(int32_t * p_41, int32_t * p_42, const int32_t  p_43, int16_t  p_44);
static int32_t * func_45(int32_t  p_46, uint8_t  p_47, int32_t * p_48);
static int32_t * func_56(uint32_t  p_57, const uint32_t  p_58);
static uint32_t  func_59(int32_t  p_60, uint32_t  p_61, int32_t ** p_62, const uint32_t  p_63);
static int32_t  func_66(int32_t * p_67);
static int32_t  func_69(int32_t * p_70, uint16_t  p_71, uint8_t  p_72, int32_t * p_73, int32_t  p_74);
static int32_t * func_75(int32_t ** p_76);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_33(void)
{ /* block id: 36 */
    int32_t l_49 = (-5);
    int32_t *l_50 = (void*)0;
    const uint32_t l_200 = 0U;
    int32_t **l_303 = (void*)0;
    int32_t **l_304 = &l_50;
    int32_t l_306 = (-2);
    int32_t *l_305 = &l_306;
    int32_t l_307 = 0x6F183749;
    l_50 = func_34(func_37(func_40(func_45(l_49, l_49, l_50), func_56(l_49, l_49), l_200, l_200), l_50), l_50);
    (*l_304) = l_50;
    (*l_304) = (*l_304);
    (*l_305) = (1 < ((void*)0 == l_305));
    return l_307;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_34(int32_t * p_35, int32_t * p_36)
{ /* block id: 131 */
    int32_t l_221 = 0x4FB8BF2F;
    float l_223 = 0x1.87B176p+61;
    float *l_222 = &l_223;
    int32_t *****l_230 = (void*)0;
    int32_t *l_233 = &l_221;
    int32_t **l_287 = (void*)0;
    int32_t ***l_286 = &l_287;
    int32_t ****l_285 = &l_286;
    int32_t *****l_284 = &l_285;
    uint32_t l_290 = 4294967291U;
    uint8_t l_296 = 255U;
    (*l_222) = (0xA.5245F2p-85 > l_221);
    l_221 = 0x4.2F718Ep+8;
    l_221 = ((safe_sub_func_uint32_t_u_u((((-8) && 0U) == l_221), (l_221 || (safe_rshift_func_int16_t_s_s(l_221, 6))))) & l_221);
    if ((safe_lshift_func_uint16_t_u_u(((0x3852427B == (l_230 != l_230)) == 0x9E171180), __builtin_popcountl((p_36 == p_35)))))
    { /* block id: 135 */
        int32_t *l_231 = &l_221;
        int32_t **l_232 = (void*)0;
        int32_t **l_234 = &l_231;
        int32_t l_247 = (-1);
        int32_t *l_249 = &l_221;
        int32_t *l_277 = &l_247;
        int16_t l_280 = 0x50C0;
        uint32_t l_291 = 4294967289U;
        const int16_t l_299 = 1;
        l_233 = l_231;
        (*l_234) = p_35;
        /* statement id: 137 */
        assert (l_231 == 0);
        for (l_221 = 0; (l_221 == (-23)); l_221 = safe_sub_func_int32_t_s_s(l_221, 9))
        { /* block id: 140 */
            uint8_t l_240 = 0xD0;
            int32_t *l_248 = (void*)0;
        }
    }
    else
    { /* block id: 165 */
        int32_t *l_302 = &l_221;
        l_302 = p_36;
        /* statement id: 166 */
        assert (l_302 == 0);
        (*l_222) = (-0x1.6p-1);
    }
    return p_35;
    /* statement id: 169 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_37(int32_t * p_38, int32_t * p_39)
{ /* block id: 124 */
    int32_t l_218 = 1;
    for (l_218 = 0; (l_218 != (-10)); l_218 = safe_sub_func_int32_t_s_s(l_218, 5))
    { /* block id: 127 */
        return p_38;
        /* statement id: 128 */
        //assert (func_37_rv == 0);
    }
    return p_39;
    /* statement id: 130 */
    //assert (func_37_rv == 0 || func_37_rv == &l_221);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_40(int32_t * p_41, int32_t * p_42, const int32_t  p_43, int16_t  p_44)
{ /* block id: 120 */
    int16_t l_201 = (-1);
    float l_203 = (-0x9.4p+1);
    float *l_202 = &l_203;
    int16_t l_204 = 0;
    int32_t l_211 = 6;
    int32_t l_214 = 0x35CBEA91;
    int32_t *l_213 = &l_214;
    int32_t **l_212 = &l_213;
    int32_t *l_217 = &l_214;
    (*l_202) = l_201;
    (*l_212) = func_45(l_204, (safe_sub_func_int32_t_s_s(l_201, func_59(p_43, ((safe_sub_func_uint32_t_u_u((safe_lshift_func_int16_t_s_u(func_59(l_211, l_211, l_212, ((safe_add_func_int16_t_s_s((*l_213), __builtin_ia32_crc32qi(p_44, ((**l_212) || p_43)))) | (-2))), 14)), (**l_212))) <= (**l_212)), &l_213, (**l_212)))), p_41);
    /* statement id: 122 */
    assert (l_213 == 0);
    return p_41;
    /* statement id: 123 */
    //assert (func_40_rv == 0 || func_40_rv == &l_221 || func_40_rv == &l_247);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_45(int32_t  p_46, uint8_t  p_47, int32_t * p_48)
{ /* block id: 37 */
    int16_t l_52 = 0x88CD;
    int32_t l_54 = 1;
    int32_t *l_53 = &l_54;
    int32_t **l_55 = (void*)0;
    int32_t **l_197 = &l_53;
    (*l_53) = ((0U | ((!p_47) < l_52)) <= l_52);
    p_48 = (void*)0;
    /* statement id: 39 */
    assert (p_48 == 0);
    (*l_197) = func_56(func_59(p_47, ((*l_53) < (((safe_mod_func_int32_t_s_s(func_66(p_48), (*l_53))) && (((safe_add_func_uint32_t_u_u(((((~(-1)) <= ((p_46 || (*l_53)) <= ((safe_rshift_func_int16_t_s_u((*l_53), 0)) & 0x22B2))) >= 0x796D) == 0x18E2BB11), (*l_53))) & p_46) ^ 2U)) <= (-1))), &l_53, p_46), (*l_53));
    /* statement id: 113 */
    assert (l_53 == 0);
    for (p_47 = 9; (p_47 == 24); p_47 = safe_add_func_int16_t_s_s(p_47, 8))
    { /* block id: 116 */
        (*l_197) = (*l_197);
    }
    return p_48;
    /* statement id: 119 */
    //assert (func_45_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_56(uint32_t  p_57, const uint32_t  p_58)
{ /* block id: 69 */
    int32_t **l_115 = (void*)0;
    int32_t ***l_114 = &l_115;
    int32_t ****l_113 = &l_114;
    int32_t *****l_116 = (void*)0;
    int32_t *****l_117 = &l_113;
    int32_t l_119 = 0x5FD73FCF;
    int32_t *l_118 = &l_119;
    int32_t *l_120 = &l_119;
    int32_t ****l_130 = &l_114;
    int32_t *l_185 = &l_119;
    int32_t *l_190 = &l_119;
    int32_t *l_191 = &l_119;
    int32_t *l_192 = &l_119;
    int32_t *l_193 = &l_119;
    int32_t *l_194 = &l_119;
    int32_t *l_195 = &l_119;
    int32_t *l_196 = (void*)0;
    (*l_117) = l_113;
    if (__builtin_parityl(((((0x0CFA8270 & 0xE99EAD79) ^ ((l_118 != l_120) != (&l_119 != &l_119))) <= (safe_lshift_func_int16_t_s_s((0x15C07A26 && p_58), (p_57 & 0xFDE2)))) | (*l_118))))
    { /* block id: 71 */
        int32_t *l_123 = (void*)0;
        l_123 = &l_119;
        /* statement id: 72 */
        assert (l_123 == &l_119);
        (*l_120) = ((safe_add_func_int32_t_s_s(p_58, (*l_123))) != ((~((*l_123) & (~(safe_unary_minus_func_int16_t_s(p_57))))) <= (p_58 <= p_57)));
    }
    else
    { /* block id: 74 */
        int32_t **l_129 = &l_120;
        (*l_129) = func_75(l_129);
    }
    l_130 = (*l_117);
    if ((p_57 < (p_58 <= (safe_mod_func_uint32_t_u_u(p_57, p_58)))))
    { /* block id: 78 */
        int32_t **l_135 = (void*)0;
        const int32_t *l_137 = &l_119;
        int32_t **l_138 = (void*)0;
        const int32_t **l_139 = &l_137;
        int32_t *l_140 = &l_119;
        int32_t ****l_145 = &l_114;
        int32_t *l_148 = &l_119;
        int32_t *l_160 = &l_119;
        int32_t *l_183 = (void*)0;
        (*l_120) = (safe_add_func_int32_t_s_s((l_135 != (void*)0), (safe_unary_minus_func_uint32_t_u(6U))));
        (*l_139) = l_137;
        if (func_69(l_140, ((safe_sub_func_uint16_t_u_u(((safe_mul_func_uint16_t_u_u(((void*)0 != l_145), (p_58 >= (*l_140)))) & (safe_lshift_func_int16_t_s_s(p_58, 11))), (p_57 > (*l_120)))) != (*l_118)), p_58, l_148, (*l_148)))
        { /* block id: 81 */
            uint32_t l_159 = 0x3E2DD196;
            const int32_t *l_161 = &l_119;
            if (__builtin_popcountll(((safe_mod_func_uint32_t_u_u(((safe_lshift_func_uint16_t_u_s((p_57 <= (p_57 ^ (safe_lshift_func_int16_t_s_s(((*l_120) != (((*l_117) == (void*)0) & (safe_sub_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u((((&l_145 != &l_113) | (l_140 != l_148)) && 0x6470), p_57)), p_57)))), p_58)))), l_159)) ^ 0x54E0), 0x05853257)) && p_57)))
            { /* block id: 82 */
                l_120 = l_160;
            }
            else
            { /* block id: 84 */
                uint8_t l_162 = 0xEC;
                int32_t l_169 = 1;
                (*l_139) = l_161;
                (*l_120) = ((p_57 > l_162) | (*l_140));
                for (l_119 = (-6); (l_119 <= (-18)); l_119 = safe_sub_func_int32_t_s_s(l_119, 1))
                { /* block id: 89 */
                    uint8_t l_170 = 3U;
                    for (l_162 = 0; (l_162 == 59); l_162 = safe_add_func_int16_t_s_s(l_162, 1))
                    { /* block id: 92 */
                        float l_167 = 0x3.Ap+1;
                        int32_t l_168 = 6;
                        l_168 = ((3U < l_162) | p_58);
                        l_169 = (p_57 <= l_162);
                        l_170 = (p_58 | p_57);
                    }
                }
            }
        }
        else
        { /* block id: 99 */
            float l_176 = (-0x1.Ep-1);
            float *l_175 = &l_176;
            const int32_t l_177 = 0xCC4F2F6E;
            (*l_175) = (p_58 < (p_57 == ((*l_160) != (0x8.5208E9p-35 <= (p_57 < (0xA.05EB5Dp+34 > (safe_mul_func_float_f_f((p_58 >= ((safe_add_func_float_f_f(p_57, p_58)) >= p_57)), p_58))))))));
            if ((((void*)0 == l_120) > (l_177 | ((((safe_rshift_func_uint16_t_u_s(0x1CDE, p_58)) & (safe_rshift_func_uint16_t_u_s(0x4A0F, 9))) && (((((***l_117) == (**l_145)) || p_58) < 0x2BC7) > p_58)) != p_58))))
            { /* block id: 101 */
                int32_t *l_182 = &l_119;
                return l_183;
                /* statement id: 102 */
                //assert (func_56_rv == 0);
            }
            else
            { /* block id: 103 */
                int32_t *l_186 = &l_119;
                int32_t *l_187 = &l_119;
                (*l_120) = (+((-9) ^ 0U));
                return l_183;
                /* statement id: 105 */
                //assert (func_56_rv == 0);
            }
        }
    }
    else
    { /* block id: 108 */
        const int32_t *l_188 = &l_119;
        int32_t **l_189 = &l_185;
        (*l_189) = l_188;
        (*l_189) = (*l_189);
    }
    return l_196;
    /* statement id: 112 */
    //assert (func_56_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_59(int32_t  p_60, uint32_t  p_61, int32_t ** p_62, const uint32_t  p_63)
{ /* block id: 61 */
    int32_t l_111 = (-9);
    int32_t *l_110 = &l_111;
    int32_t **l_109 = &l_110;
    int32_t ***l_108 = &l_109;
    int32_t ***l_112 = &l_109;
    for (p_61 = 0; (p_61 >= 23); p_61 = safe_add_func_int16_t_s_s(p_61, 1))
    { /* block id: 64 */
        (**l_109) = (l_108 != l_112);
    }
    (*l_110) = (*l_110);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_66(int32_t * p_67)
{ /* block id: 40 */
    int32_t l_68 = 0;
    int32_t *l_78 = (void*)0;
    int32_t **l_77 = &l_78;
    int32_t l_87 = 0xF497C316;
    const uint8_t l_88 = 0xFD;
    int32_t *l_94 = &l_68;
    uint32_t l_95 = 1U;
    float l_97 = 0x0.3p-1;
    float *l_96 = &l_97;
    int32_t l_100 = 0x90294961;
    (*l_94) = (l_68 <= func_69(func_75(l_77), ((void*)0 != &l_78), l_68, (*l_77), (safe_unary_minus_func_int16_t_s((((safe_add_func_int16_t_s_s((!l_68), ((safe_mul_func_int16_t_s_s(l_68, l_87)) < 5U))) != 6) == l_88)))));
    (*l_96) = func_69(p_67, l_95, (&p_67 != (void*)0), p_67, ((*l_94) <= (*l_94)));
    for (l_95 = 0; (l_95 == 11); l_95 = safe_add_func_int32_t_s_s(l_95, 9))
    { /* block id: 56 */
        (*l_77) = func_75(&p_67);
    }
    (*l_94) = (&l_77 == &l_77);
    return l_100;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_69(int32_t * p_70, uint16_t  p_71, uint8_t  p_72, int32_t * p_73, int32_t  p_74)
{ /* block id: 44 */
    int32_t **l_92 = (void*)0;
    int32_t l_93 = 0x26CCE71C;
    for (p_72 = 18; (p_72 < 45); p_72 = safe_add_func_int16_t_s_s(p_72, 1))
    { /* block id: 47 */
        int32_t l_91 = 0x3E67DCAF;
        l_91 = p_72;
    }
    p_70 = p_70;
    return l_93;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_75(int32_t ** p_76)
{ /* block id: 41 */
    int32_t ***l_80 = (void*)0;
    int32_t ****l_79 = &l_80;
    (*l_79) = (void*)0;
    return (*p_76);
    /* statement id: 43 */
    //assert (func_75_rv == 0 || func_75_rv == &l_119 || func_75_rv == &l_221);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 92
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 16
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 93

XXX times a variable address is taken: 76
XXX times a pointer is dereferenced on RHS: 63
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 16
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 38
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 370

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 140
   level: 2, occurrence: 76
   level: 3, occurrence: 22
   level: 4, occurrence: 18
XXX number of pointers point to pointers: 35
XXX number of pointers point to scalars: 58
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 44.1
XXX average alias set size: 1.3

XXX times a non-volatile is read: 360
XXX times a non-volatile is write: 102
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 70
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 38
   depth: 1, occurrence: 18
   depth: 2, occurrence: 3
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
********************* end of statistics **********************/

