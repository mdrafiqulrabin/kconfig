/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2207323546
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   int32_t  f2;
   const int32_t  f3;
   uint32_t  f4;
   signed f5 : 28;
   int16_t  f6;
   uint32_t  f7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const uint32_t  func_31(void);
static int32_t * func_35(int16_t  p_36);
static uint16_t  func_47(uint32_t  p_48, struct S0  p_49, int32_t  p_50, struct S0  p_51);
static uint32_t  func_52(uint32_t  p_53);
static int32_t  func_61(uint32_t  p_62, int16_t  p_63, uint32_t * p_64);
static uint16_t  func_65(uint32_t * p_66, int32_t  p_67, uint32_t * p_68);
static uint32_t * func_69(uint32_t * p_70);
static uint16_t  func_84(const uint16_t  p_85, int32_t  p_86, uint16_t  p_87, struct S0  p_88, int32_t  p_89);
static int32_t * func_95(int32_t * p_96, int32_t * p_97, uint32_t * p_98, int32_t * p_99);
static int32_t * func_101(int32_t * p_102, uint32_t  p_103, uint32_t * p_104, const struct S0  p_105, const uint32_t  p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = (-1);
    uint16_t l_471 = 1U;
    struct S0 l_472 = {4294967292U,0xD299265B,1,-1,4294967295U,11817,1,0x65924FA6};
    const struct S0 l_478 = {0xD6C550F1,0x67C69454,0xAA43C885,9,1U,-7084,-1,0U};
    uint32_t *l_479 = &l_472.f4;
    struct S0 *l_501 = &l_472;
    struct S0 **l_500 = &l_501;
    int16_t *l_504 = &l_472.f6;
    int16_t **l_503 = &l_504;
    int16_t **l_505 = &l_504;
    uint32_t *l_506 = &l_472.f1;
    uint32_t *l_507 = &l_472.f0;
    int32_t l_512 = (-1);
    int32_t *l_511 = &l_512;
    int32_t **l_510 = &l_511;
    uint32_t *l_513 = &l_472.f7;
    int32_t *l_515 = (void*)0;
    int32_t **l_514 = &l_515;
    const uint32_t l_525 = 0x4565DFAA;
    for (l_32 = (-5); (l_32 <= 28); l_32 += 1)
    { /* block id: 39 */
        uint16_t l_37 = 0x58E3;
        int32_t *l_449 = &l_32;
        int32_t **l_448 = &l_449;
        const struct S0 l_470 = {0x5494368E,1U,-6,7,4294967291U,-11160,1,1U};
        const struct S0 l_475 = {0U,0xC7987E04,0,-7,0x98725E79,-1705,-9,0xAD6204C1};
        uint32_t l_477 = 0xE20458B2;
        int32_t *l_482 = &l_472.f2;
        (*l_448) = func_35(l_37);
        for (l_37 = 0; (l_37 <= 59); l_37 += 1)
        { /* block id: 253 */
            uint32_t l_452 = 2U;
            int32_t l_453 = 0xBFEFC73C;
            struct S0 l_473 = {0xD40F7638,0x6B24E4B7,-1,-10,0x7B3AA694,-14897,0xBD10,0xD33CDD11};
            uint32_t *l_474 = (void*)0;
            int16_t ***l_494 = (void*)0;
            if (l_452)
            { /* block id: 254 */
                int16_t l_461 = 0x246B;
                int32_t *l_462 = &l_32;
                uint32_t l_468 = 0x0FEB4505;
                uint32_t *l_467 = &l_468;
                int16_t *l_469 = &l_461;
                uint32_t **l_476 = &l_467;
                l_453 = l_32;
                for (l_452 = 0; (l_452 != 42); l_452 += 3)
                { /* block id: 258 */
                    int32_t l_460 = 4;
                    int32_t *l_459 = &l_460;
                    for (l_453 = 0; (l_453 == 6); l_453 += 7)
                    { /* block id: 261 */
                        int32_t *l_458 = &l_453;
                        l_459 = l_458;
                    }
                    if (l_461)
                        break;
                }
                (*l_448) = (*l_448);
            }
            else
            { /* block id: 270 */
                uint32_t l_480 = 0U;
                int32_t *l_481 = &l_453;
                if (l_472.f2)
                    break;
                (*l_481) = func_52((l_480 = (l_479 != (void*)0)));
                (*l_481) = (l_482 == (void*)0);
            }
            for (l_472.f1 = 0; (l_472.f1 > 60); l_472.f1 += 3)
            { /* block id: 278 */
                int32_t l_487 = 0xC84AFA13;
                uint32_t *l_488 = (void*)0;
                uint32_t **l_489 = &l_488;
                uint32_t **l_490 = &l_474;
                uint16_t *l_492 = (void*)0;
                uint16_t *l_493 = &l_471;
                int16_t ****l_495 = &l_494;
                int16_t ***l_497 = (void*)0;
                int16_t ****l_496 = &l_497;
                (*l_496) = ((*l_495) = ((((int16_t)(l_487 , ((-9) >= ((l_472.f4 , &l_472) != ((((*l_489) = l_488) != ((*l_490) = l_474)) , &l_473)))) << (int16_t)((*l_493) = (~l_453))) != (-6)) , l_494));
                for (l_453 = 14; (l_453 > 9); l_453--)
                { /* block id: 286 */
                    struct S0 ***l_502 = &l_500;
                    (*l_502) = l_500;
                }
            }
        }
    }
    (*l_514) = func_101(&l_32, ((*l_506) = ((l_503 = (void*)0) == l_505)), (l_507 = (void*)0), l_478, ((*l_513) = (((int32_t)0xAA15F02B - (int32_t)0) , ((func_52(l_478.f6) , l_510) == (void*)0))));
    (*l_500) = (*l_500);
    if (((int16_t)0x6EB6 * (int16_t)l_472.f6))
    { /* block id: 298 */
        int32_t *l_518 = &l_472.f2;
        int32_t *l_519 = (void*)0;
        int32_t *l_520 = &l_32;
        int32_t l_522 = (-9);
        int32_t *l_521 = &l_522;
        int32_t l_524 = 1;
        int32_t *l_523 = &l_524;
        (*l_514) = l_518;
        l_472.f5 = ((*l_523) = ((*l_521) = ((*l_520) = (((*l_518) = (**l_514)) != l_472.f0))));
        l_518 = ((*l_514) = (*l_514));
    }
    else
    { /* block id: 307 */
        return l_478.f0;
    }
    return l_525;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_35(int16_t  p_36)
{ /* block id: 40 */
    int32_t l_40 = 0xCE96F8F9;
    int32_t *l_39 = &l_40;
    int32_t *l_41 = &l_40;
    struct S0 l_357 = {4294967291U,0x5B6B0B1A,9,0xCAD0A982,4294967290U,8828,0x1ABC,1U};
    int32_t l_401 = 0x6AB37015;
    int32_t *l_434 = &l_40;
    int32_t l_445 = 0;
    int32_t *l_446 = &l_401;
    int32_t *l_447 = (void*)0;
    if (p_36)
    { /* block id: 41 */
        int32_t *l_38 = (void*)0;
        uint32_t l_46 = 0x1516EA3D;
        uint32_t *l_45 = &l_46;
        int32_t l_359 = 1;
        int32_t *l_358 = &l_359;
        int32_t l_361 = 5;
        int32_t *l_360 = &l_361;
        int32_t l_398 = 0xE5C5AB65;
        struct S0 l_420 = {0x91E20E82,0xD2691AD6,0xF1835D3D,0x60507924,5U,5752,0x81BA,0x723F2FAC};
        uint32_t l_426 = 1U;
        int32_t **l_427 = &l_41;
        l_38 = l_38;
        l_41 = l_39;
        (*l_39) = (!(p_36 = (((((*l_45) = p_36) >= ((func_47(func_52(((uint16_t)((int16_t)((int16_t)(-(int32_t)func_61((((*l_41) & p_36) > func_65(func_69(l_39), ((*l_360) = ((*l_358) = ((uint16_t)((uint32_t)((((((uint16_t)((*l_39) , (*l_41)) * (uint16_t)((l_357 , (*l_39)) > (*l_39))) , (*l_41)) && 0) || (-5)) | p_36) / (uint32_t)p_36) << (uint16_t)p_36))), l_39)), l_398, l_39)) >> (int16_t)10) >> (int16_t)l_401) >> (uint16_t)p_36)), l_420, p_36, l_420) <= p_36) == (*l_39))) , l_426) < p_36)));
        (*l_427) = &l_40;
    }
    else
    { /* block id: 234 */
        int32_t *l_430 = &l_357.f2;
        int32_t *l_433 = &l_40;
        int32_t *l_435 = &l_40;
        int32_t *l_436 = (void*)0;
        for (l_357.f7 = (-9); (l_357.f7 >= 12); l_357.f7 += 1)
        { /* block id: 237 */
            int32_t *l_431 = &l_40;
            int32_t *l_432 = &l_401;
            if (p_36)
                break;
            return l_436;
        }
        for (p_36 = 4; (p_36 > 16); p_36 += 4)
        { /* block id: 243 */
            (*l_434) = ((int16_t)(*l_435) - (int16_t)((uint16_t)p_36 * (uint16_t)((int16_t)(&l_401 == (void*)0) >> (int16_t)(*l_434))));
        }
    }
    (*l_446) = ((*l_434) = l_445);
    return l_447;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_47(uint32_t  p_48, struct S0  p_49, int32_t  p_50, struct S0  p_51)
{ /* block id: 225 */
    struct S0 *l_421 = (void*)0;
    struct S0 **l_422 = &l_421;
    int32_t l_424 = 1;
    int32_t *l_423 = &l_424;
    int32_t **l_425 = &l_423;
    l_421 = l_421;
    (*l_422) = l_421;
    l_423 = l_423;
    (*l_425) = &l_424;
    return p_49.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_52(uint32_t  p_53)
{ /* block id: 222 */
    uint32_t l_414 = 0x67F6B025;
    int16_t ***l_417 = (void*)0;
    int32_t l_419 = 0x5BC3FD21;
    int32_t *l_418 = &l_419;
    (*l_418) = ((uint16_t)(-(int32_t)p_53) * (uint16_t)((int16_t)((uint32_t)4294967295U % (uint32_t)((int16_t)(-(int32_t)p_53) % (int16_t)((int16_t)((l_414 <= 0x29260F8D) | 0) % (int16_t)0x4348))) + (int16_t)(p_53 || ((uint16_t)(((l_414 , l_417) != l_417) <= p_53) % (uint16_t)l_414))));
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_61(uint32_t  p_62, int16_t  p_63, uint32_t * p_64)
{ /* block id: 219 */
    int32_t l_400 = 0;
    int32_t *l_399 = &l_400;
    (*l_399) = p_62;
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_65(uint32_t * p_66, int32_t  p_67, uint32_t * p_68)
{ /* block id: 198 */
    int32_t l_363 = 0;
    int32_t *l_362 = &l_363;
    int32_t **l_364 = &l_362;
    uint16_t l_368 = 0x9286;
    uint16_t *l_367 = &l_368;
    uint16_t l_395 = 0xBE65;
    struct S0 l_396 = {0xBECA5AEE,4294967287U,-4,0x936C932C,0xC59ED45C,-8994,0xEE4B,0x8A41FB5A};
    int32_t l_397 = 0x7AF09F09;
    (*l_364) = l_362;
    if (((int16_t)((-6) ^ (((*l_367) = 0xE338) < ((**l_364) = ((uint32_t)(p_68 == (void*)0) % (uint32_t)0x34D86926)))) >> (int16_t)(!(*p_68))))
    { /* block id: 202 */
        int32_t l_372 = 0x52E5C808;
        int32_t l_373 = 0x7F4A1E99;
        l_373 = l_372;
        for (l_373 = 0; (l_373 < 17); l_373 += 1)
        { /* block id: 206 */
            (*l_364) = &l_372;
        }
        (**l_364) = p_67;
    }
    else
    { /* block id: 210 */
        int32_t l_376 = 6;
        int32_t l_390 = 0xDB70A726;
        uint32_t l_392 = 0x999E632D;
        uint32_t *l_391 = &l_392;
        (*l_362) = (l_376 , ((((*l_362) || ((int32_t)((((((((int16_t)((~(((((uint16_t)(**l_364) << (uint16_t)l_376) && __builtin_popcount((((((uint32_t)(*p_66) + (uint32_t)(((*l_391) = ((int16_t)4 * (int16_t)(l_390 = l_376))) | (*p_66))) != ((((uint16_t)l_395 << (uint16_t)7) , p_67) > 0)) != p_67) < (**l_364)))) , (**l_364)) & 0x430B)) || (*p_68)) - (int16_t)l_376) | 6) , (*l_362)) , (*p_68)) > (**l_364)) > 0x53EA8B32) , (*l_362)) / (int32_t)l_376)) , l_396) , 1));
        (*l_364) = (((0xE8EA8897 <= (0x13C048AF <= ((p_67 && ((*l_391) = (*p_68))) , ((*l_362) , (*p_66))))) | l_397) , &l_390);
    }
    (*l_364) = p_68;
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t * func_69(uint32_t * p_70)
{ /* block id: 45 */
    int32_t l_71 = 1;
    int32_t l_93 = 0x314CD590;
    uint32_t *l_111 = (void*)0;
    const struct S0 l_112 = {0x41B43419,4294967287U,0x83D71515,3,0x9248679C,6864,4,4294967295U};
    const int32_t l_132 = (-1);
    const int32_t *l_131 = &l_132;
    uint16_t l_138 = 65534U;
    uint16_t *l_137 = &l_138;
    struct S0 l_175 = {0x688FF0B4,0x352AAD8D,0xC579967C,0xD34ED2CB,0U,-14548,-1,4294967295U};
    int32_t l_222 = 1;
    int32_t l_254 = 0xFD023D6C;
    uint32_t l_255 = 4294967295U;
    int16_t ***l_260 = (void*)0;
    const uint16_t l_311 = 0x1043;
    int32_t *l_316 = &l_222;
    int32_t **l_315 = &l_316;
lbl_186:
    for (l_71 = 0; (l_71 == (-24)); l_71--)
    { /* block id: 48 */
        uint32_t l_79 = 0x15B38D6A;
        struct S0 l_92 = {0x7FE6D7BF,0x020A73BC,-7,0x0ECE9518,4294967295U,15249,1,0xCAA0E685};
        int32_t *l_117 = &l_92.f2;
        uint16_t l_136 = 0U;
        uint16_t *l_135 = &l_136;
        int32_t **l_141 = &l_117;
        if ((((uint16_t)((0 || (-1)) | ((~((int16_t)l_79 - (int16_t)((uint16_t)((uint16_t)l_79 << (uint16_t)((func_84(l_79, ((l_71 , ((uint16_t)((void*)0 != p_70) - (uint16_t)(l_71 <= l_79))) == l_79), l_79, l_92, l_93) , 1) == 6U)) >> (uint16_t)l_93))) >= 0x9C99C4DB)) << (uint16_t)3) < 65535U))
        { /* block id: 51 */
            int32_t l_94 = 0;
            int32_t *l_100 = &l_71;
            struct S0 l_113 = {0x0685684C,4294967295U,0x35F01DA6,0xD7FDF8BF,0x16A9CAF0,11701,0,0xFDD83981};
            int32_t **l_133 = (void*)0;
            const int32_t **l_134 = &l_131;
            if (l_94)
            { /* block id: 52 */
                const int32_t *l_108 = (void*)0;
                const int32_t **l_107 = &l_108;
                int32_t *l_110 = (void*)0;
                int32_t **l_109 = &l_110;
                l_117 = func_95(l_100, func_101(((*l_109) = ((*l_107) = p_70)), l_71, l_111, l_112, (0xBB4A || func_84(l_92.f6, ((1U <= l_92.f7) != l_112.f5), (*l_100), l_113, l_71))), p_70, p_70);
                for (l_92.f2 = (-23); (l_92.f2 < (-8)); l_92.f2 += 8)
                { /* block id: 63 */
                    uint16_t l_124 = 0xC8F4;
                    uint16_t *l_123 = &l_124;
                    int32_t l_127 = 0xA524B17E;
                    int32_t *l_128 = &l_113.f2;
                    (*l_128) = ((-(int16_t)(*l_100)) != ((uint32_t)__builtin_clzl((*l_117)) + (uint32_t)__builtin_ffsl((func_84(((*l_123) = 0x85A4), l_112.f2, (**l_109), l_113, (((*l_100) | (l_127 = ((uint16_t)(l_127 < 0xB194) << (uint16_t)1))) > (*l_117))) == 0xC97C))));
                }
            }
            else
            { /* block id: 68 */
                const int32_t *l_130 = &l_112.f2;
                const int32_t **l_129 = &l_130;
                l_131 = ((*l_129) = p_70);
            }
            (*l_134) = (void*)0;
            l_133 = &l_117;
        }
        else
        { /* block id: 74 */
            if ((*l_117))
                break;
            return p_70;
        }
        (*l_141) = func_101(p_70, __builtin_clz((l_135 != l_137)), func_95(func_101(p_70, ((int32_t)__builtin_clzll((*l_117)) % (int32_t)(*l_117)), p_70, l_92, (*l_117)), p_70, p_70, p_70), l_112, (*p_70));
    }
    for (l_71 = (-20); (l_71 > (-19)); l_71 += 4)
    { /* block id: 82 */
        const int32_t l_144 = 0;
        uint32_t l_150 = 4294967286U;
        uint32_t *l_149 = &l_150;
        struct S0 l_151 = {0x75E556C3,1U,0xDE9350E5,2,0x537EA6E2,-14478,-8,0xE737D706};
        int16_t *l_152 = &l_151.f6;
        const int32_t **l_153 = (void*)0;
        int32_t *l_154 = &l_151.f2;
        int16_t **l_158 = &l_152;
        int32_t l_163 = 0x4424053B;
        uint32_t l_179 = 0xB5441F78;
        int32_t l_287 = (-1);
        int32_t l_307 = 0;
        int16_t l_342 = 1;
        int16_t l_343 = (-1);
        (*l_154) = ((((l_112.f3 != (l_112.f4 != 0xFE2A)) , ((*l_152) = ((l_112.f2 == __builtin_clz((*p_70))) <= func_84(l_144, l_144, (((int16_t)(((*l_149) = ((((int16_t)0x4138 >> (int16_t)l_112.f3) | (*p_70)) ^ l_144)) | (*p_70)) >> (int16_t)l_144) , 2U), l_151, l_112.f6)))) , (void*)0) == l_153);
        (*l_154) = l_138;
        if ((((int16_t)__builtin_parityl((~(__builtin_popcount((*l_154)) , (((((*l_158) = l_152) != (void*)0) <= ((int16_t)0x05AE * (int16_t)((int16_t)((void*)0 != l_158) >> (int16_t)8))) , (&l_150 != (void*)0))))) << (int16_t)l_112.f3) , l_163))
        { /* block id: 88 */
            int32_t *l_164 = &l_151.f2;
            int32_t **l_165 = (void*)0;
            int32_t **l_166 = &l_164;
            uint16_t l_169 = 0U;
            uint16_t *l_168 = &l_169;
            (*l_166) = l_164;
            (*l_164) = ((~(l_112.f6 ^ ((*l_168) = ((*l_137) = (*l_154))))) > 0x0E2A7017);
        }
        else
        { /* block id: 93 */
            uint32_t l_170 = 0x86663A56;
            struct S0 l_176 = {4294967295U,0x8999B4F4,0x21A526C7,-1,4294967295U,10320,-6,0x25B6B4B3};
            l_170 = (-4);
            (*l_154) = (func_84(((uint16_t)((*l_137) = ((((uint16_t)func_84(l_170, l_170, (((*l_149) = (l_175 , (*p_70))) , ((*l_137) = l_71)), l_176, l_170) * (uint16_t)((int16_t)func_84((l_179 <= l_175.f6), l_176.f2, l_176.f1, l_176, (*l_154)) * (int16_t)(*l_154))) != (*l_154)) == 0x52DE)) >> (uint16_t)l_176.f3), (*l_154), (*l_154), l_176, l_176.f5) , (*l_154));
        }
        for (l_151.f0 = 16; (l_151.f0 < 2); l_151.f0 -= 1)
        { /* block id: 102 */
            uint16_t l_189 = 0xA958;
            struct S0 l_190 = {0x3E820413,4294967295U,0,5,0U,-12290,1,0U};
            int32_t l_199 = 6;
            const uint32_t *l_207 = &l_112.f7;
            const uint32_t **l_206 = &l_207;
            int32_t l_211 = 0xB1311AD5;
            int32_t *l_223 = &l_151.f2;
            int32_t *l_229 = &l_190.f2;
            int32_t *l_232 = &l_222;
            struct S0 l_236 = {4294967291U,0U,0xE12B9D12,0x314CBB3D,0U,7633,-9,1U};
            uint16_t l_344 = 0x2584;
            uint32_t *l_348 = &l_236.f0;
            for (l_175.f1 = 9; (l_175.f1 != 48); l_175.f1 += 1)
            { /* block id: 105 */
                int32_t **l_187 = &l_154;
                uint16_t *l_188 = &l_138;
                for (l_179 = (-9); (l_179 != 35); l_179 += 2)
                { /* block id: 108 */
                    return p_70;
                }
                if (l_163)
                    goto lbl_186;
                (*l_187) = p_70;
                l_175.f5 = func_84((*l_154), (func_84(((*l_188) = (**l_187)), (l_112 , l_189), (*l_154), l_190, ((**l_187) , (((int16_t)(func_84(((int16_t)((((l_199 = ((int32_t)((int32_t)(-4) + (int32_t)(-10)) + (int32_t)(*p_70))) , l_190.f6) & (*l_154)) < 65535U) >> (int16_t)(**l_187)), (**l_187), (*l_154), l_175, l_175.f0) & (*l_154)) << (int16_t)14) <= l_190.f4))) || (*l_154)), l_190.f3, l_175, (**l_187));
            }
        }
    }
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_84(const uint16_t  p_85, int32_t  p_86, uint16_t  p_87, struct S0  p_88, int32_t  p_89)
{ /* block id: 49 */
    return p_88.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_95(int32_t * p_96, int32_t * p_97, uint32_t * p_98, int32_t * p_99)
{ /* block id: 58 */
    return p_96;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_101(int32_t * p_102, uint32_t  p_103, uint32_t * p_104, const struct S0  p_105, const uint32_t  p_106)
{ /* block id: 55 */
    uint32_t l_114 = 1U;
    int32_t l_116 = 0;
    int32_t *l_115 = &l_116;
    (*l_115) = __builtin_parity(l_114);
    return p_104;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 106
   depth: 1, occurrence: 18
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 18
   indirect level: 1, occurrence: 1
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 3
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 40
XXX times a single bitfield on LHS: 5
XXX times a single bitfield on RHS: 4

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 22
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 2
   depth: 37, occurrence: 1

XXX total number of pointers: 125

XXX times a variable address is taken: 116
XXX times a pointer is dereferenced on RHS: 148
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 33
XXX times a pointer is dereferenced on LHS: 102
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 401

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 330
   level: 2, occurrence: 84
   level: 3, occurrence: 0
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 43
XXX number of pointers point to scalars: 80
XXX number of pointers point to structs: 2
XXX percent of pointers has null in alias set: 25.6
XXX average alias set size: 1.24

XXX times a non-volatile is read: 671
XXX times a non-volatile is write: 256
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 88
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 23
   depth: 2, occurrence: 16
   depth: 3, occurrence: 15
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 16.5
XXX percentage an existing variable is used: 83.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

