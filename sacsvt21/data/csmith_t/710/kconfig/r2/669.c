/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1782200824
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint64_t  f0;
   int32_t  f1;
   unsigned f2 : 2;
   unsigned f3 : 30;
   signed f4 : 25;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_1(void);
static int32_t * const  func_10(int32_t * p_11, int32_t  p_12, int8_t  p_13, const int32_t  p_14);
inline static int32_t * func_15(int32_t * p_16, uint16_t  p_17, int32_t * p_18);
static int32_t ** func_28(int32_t ** p_29, uint32_t  p_30, int32_t ** p_31, uint32_t  p_32);
inline static int32_t ** func_33(int32_t ** p_34, int8_t  p_35, uint16_t  p_36, float  p_37);
static uint8_t  func_51(int32_t ** p_52, int32_t ** p_53, uint16_t  p_54);
static struct S0 * func_59(int8_t  p_60, uint16_t  p_61, uint32_t  p_62, int32_t * p_63, int32_t  p_64);
static uint8_t  func_65(int32_t  p_66, struct S0  p_67);
inline static float  func_79(struct S0 * p_80, struct S0  p_81);
static struct S0 * func_82(int8_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 1L;
    int64_t l_5[4][9] = {{4L,0x0011151C3C39BA09LL,0x6A3367F5ED9A924CLL,0x6A3367F5ED9A924CLL,0x0011151C3C39BA09LL,4L,(-4L),0x0FC3A065C2DD78F4LL,0x6A3367F5ED9A924CLL},{(-2L),0x649F6D4A0D461E3FLL,4L,0x6A3367F5ED9A924CLL,1L,(-2L),(-2L),1L,0x6A3367F5ED9A924CLL},{0x8DC5336DE0184DCCLL,0x0011151C3C39BA09LL,0x8DC5336DE0184DCCLL,4L,1L,0x8DC5336DE0184DCCLL,(-4L),0L,4L},{0x8DC5336DE0184DCCLL,1L,4L,0x8DC5336DE0184DCCLL,0x0011151C3C39BA09LL,0x8DC5336DE0184DCCLL,4L,1L,0x8DC5336DE0184DCCLL}};
    int32_t l_9 = 7L;
    int32_t *l_662 = (void*)0;
    struct S0 l_721 = {0x8F36386D3DF8DFA9LL,-3L,1,17265,-1465};
    struct S0 *l_720 = &l_721;
    struct S0 **l_719 = &l_720;
    struct S0 ***l_718 = &l_719;
    struct S0 ****l_717 = &l_718;
    struct S0 *****l_716 = &l_717;
    float l_724 = (-0x7.Ap+1);
    float *l_723 = &l_724;
    float **l_722 = &l_723;
    float l_763 = (-0x4.Ap-1);
    int32_t l_821[5];
    float l_822 = 0x0.Bp+1;
    int32_t **l_825 = &l_662;
    int32_t *** const l_824 = &l_825;
    int32_t ***l_829 = &l_825;
    int8_t l_830 = 0x2EL;
    int i, j;
    for (i = 0; i < 5; i++)
        l_821[i] = (-3L);
lbl_808:
    for (l_2 = (-14); (l_2 > 21); l_2 = safe_add_func_uint32_t_u_u(l_2, 3))
    { /* block id: 3 */
        int32_t l_6 = (-10L);
        int32_t *l_19 = &l_2;
        for (l_6 = 0; (l_6 <= 3); l_6 += 1)
        { /* block id: 6 */
            int32_t l_8 = 0L;
            int32_t *l_7[5][3];
            int i, j;
            for (i = 0; i < 5; i++)
            {
                for (j = 0; j < 3; j++)
                    l_7[i][j] = &l_8;
            }
            l_9 = l_5[l_6][(l_6 + 2)];
        }
        l_662 = func_10(func_15(&l_6, l_9, l_19), (((*l_19) < 0x33CEL) != (*l_19)), (*l_19), l_2);
        /* statement id: 342 */
        assert (l_662 == 0);
    }
    for (l_2 = 0; (l_2 != (-5)); l_2 = safe_sub_func_uint8_t_u_u(l_2, 1))
    { /* block id: 346 */
        int64_t l_675 = 0x0EC064C412ACFF27LL;
        float l_689 = 0x9.DF619Dp+33;
        float *l_688 = &l_689;
        int32_t * const *l_704 = &l_662;
        int32_t * const ** const l_703 = &l_704;
        int32_t l_713 = 5L;
        int32_t *l_712 = &l_713;
        struct S0 *****l_751[10] = {&l_717,(void*)0,&l_717,&l_717,(void*)0,&l_717,&l_717,(void*)0,&l_717,&l_717};
        int32_t l_754[6];
        int64_t l_811[8][3] = {{0L,0L,1L},{0xE04414EFE0838DADLL,0L,0x5CFCC5922FD83702LL},{0L,0L,1L},{0xE04414EFE0838DADLL,0L,0x5CFCC5922FD83702LL},{0L,0L,1L},{0xE04414EFE0838DADLL,0L,0x5CFCC5922FD83702LL},{0L,0L,1L},{0xE04414EFE0838DADLL,0L,0x5CFCC5922FD83702LL}};
        int i, j;
        for (i = 0; i < 6; i++)
            l_754[i] = 0x38197485L;
        for (l_9 = 0; (l_9 <= (-25)); --l_9)
        { /* block id: 349 */
            int32_t l_667 = (-8L);
            struct S0 l_694 = {0UL,1L,0,23469,3323};
            const struct S0 *l_693 = &l_694;
            for (l_667 = 0; (l_667 < 22); l_667++)
            { /* block id: 352 */
                struct S0 l_671 = {0x1A6B27CA392003D5LL,1L,1,20592,-2441};
                struct S0 *l_670 = &l_671;
                struct S0 ***l_697 = (void*)0;
                float *l_702 = &l_689;
                if (((4L <= 0xC538C58EL) < l_667))
                { /* block id: 353 */
                    struct S0 **l_672 = &l_670;
                    (*l_672) = l_670;
                    for (l_671.f1 = 0; (l_671.f1 == (-3)); l_671.f1 = safe_sub_func_int8_t_s_s(l_671.f1, 4))
                    { /* block id: 357 */
                        float *l_676 = (void*)0;
                        float *l_677 = (void*)0;
                        float l_679 = (-0x1.Cp-1);
                        float *l_678 = &l_679;
                        (*l_678) = ((l_675 >= 0xC.C1EC72p+51) <= (-0x1.8p+1));
                        if (l_667)
                            break;
                        return l_671.f4;
                    }
                    for (l_671.f0 = 0; (l_671.f0 <= 34); l_671.f0 = safe_add_func_int16_t_s_s(l_671.f0, 4))
                    { /* block id: 364 */
                        return l_667;
                    }
                    return l_675;
                }
                else
                { /* block id: 368 */
                    float *l_690[4][7][4] = {{{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689}},{{&l_689,(void*)0,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,(void*)0,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689}},{{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689}},{{&l_689,&l_689,&l_689,&l_689},{&l_689,(void*)0,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,(void*)0,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689},{&l_689,&l_689,&l_689,&l_689}}};
                    int32_t l_696 = 5L;
                    int32_t *l_695 = &l_696;
                    uint64_t l_711 = 1UL;
                    struct S0 ****l_715 = &l_697;
                    struct S0 *****l_714 = &l_715;
                    int i, j, k;
                    (*l_695) = (((safe_add_func_uint8_t_u_u(l_675, (safe_sub_func_int32_t_s_s(l_671.f4, (safe_lshift_func_uint8_t_u_u((l_688 != l_690[2][5][3]), (l_667 && (safe_rshift_func_int16_t_s_u((&l_667 != (void*)0), 1))))))))) <= ((void*)0 != l_693)) != 0x576DL);
                    if ((*l_695))
                    { /* block id: 370 */
                        (*l_688) = (0x3.Dp+1 <= (l_697 != (void*)0));
                    }
                    else
                    { /* block id: 372 */
                        float l_709 = 0xE.B3C485p+12;
                        int32_t l_710[10] = {0L,0L,0L,0L,0L,0L,0L,0L,0L,0L};
                        int i;
                        l_694.f4 = ((safe_add_func_float_f_f((safe_div_func_float_f_f((l_675 < 0x0.Cp-1), l_675)), ((void*)0 != l_702))) >= ((l_703 == (void*)0) > (((l_671.f1 >= ((safe_mul_func_float_f_f((safe_div_func_float_f_f(((((l_667 > l_694.f2) <= 0x0.3p-1) >= 0x4.F2B1AFp-25) >= l_671.f4), 0x1.5p-1)), 0x0.0p+1)) > l_709)) <= (*l_695)) != l_710[1])));
                        l_712 = &l_710[1];
                        /* statement id: 374 */
                        assert ((l_712 >= &l_710[0] && l_712 <= &l_710[9]));
                    }
                    l_716 = l_714;
                    /* statement id: 376 */
                    assert (l_716 == &l_715);
                }
                /* facts after branching */
                //assert (l_716 == dangling);
            }
        }
        /* facts after for loop */
        //assert (l_712 == dangling || l_712 == &l_713);
        l_721.f4 = (l_722 == &l_723);
        for (l_9 = (-11); (l_9 < 17); l_9 = safe_add_func_int8_t_s_s(l_9, 3))
        { /* block id: 383 */
            uint16_t l_729 = 0x1228L;
            struct S0 l_737 = {18446744073709551609UL,0xDC0FF4D8L,0,5696,2470};
            int32_t * const *l_741 = (void*)0;
            float *l_742[4];
            uint64_t l_748 = 0UL;
            int32_t **l_758[3];
            int32_t ***l_757 = &l_758[1];
            int32_t **** const l_756 = &l_757;
            int i;
            for (i = 0; i < 4; i++)
                l_742[i] = &l_689;
            for (i = 0; i < 3; i++)
                l_758[i] = &l_662;
            for (l_713 = 0; (l_713 > (-19)); l_713 = safe_sub_func_uint16_t_u_u(l_713, 2))
            { /* block id: 386 */
                int8_t l_734[1];
                struct S0 l_755 = {0UL,0L,0,17326,4025};
                int i;
                for (i = 0; i < 1; i++)
                    l_734[i] = 1L;
                if ((l_729 <= (l_729 && (safe_rshift_func_uint8_t_u_s(((safe_rshift_func_int8_t_s_u(l_734[0], 5)) < (3L == (0xADCE2614L < 0xD376D18AL))), 6)))))
                { /* block id: 387 */
                    int64_t l_738 = 0xA2F01044D0373F30LL;
                    int32_t l_753 = 6L;
                    int32_t *l_752 = &l_753;
                    (*l_723) = (0xE.1E0970p-20 < 0x9.F2BE47p+17);
                    (***l_718) = l_737;
                    (*l_752) = (l_738 != (safe_sub_func_int8_t_s_s((l_741 == l_741), (((void*)0 == l_742[3]) <= (((safe_mod_func_int64_t_s_s(0x5C66CB27CF0D0CCDLL, ((safe_mod_func_uint16_t_u_u((l_734[0] | (((+l_748) >= (safe_mul_func_int8_t_s_s(((void*)0 != l_751[1]), l_734[0]))) && l_734[0])), l_734[0])) && l_734[0]))) > 0x3D831EC1L) <= 0x02L)))));
                }
                else
                { /* block id: 391 */
                    l_754[2] = l_737.f3;
                }
                for (l_675 = 3; (l_675 >= 0); l_675 -= 1)
                { /* block id: 396 */
                    for (l_729 = 0; (l_729 <= 3); l_729 += 1)
                    { /* block id: 399 */
                        int i, j;
                        if (l_5[l_729][(l_729 + 1)])
                            break;
                    }
                    (**l_719) = l_755;
                    for (l_755.f1 = 0; (l_755.f1 >= 0); l_755.f1 -= 1)
                    { /* block id: 405 */
                        int32_t ****l_760 = (void*)0;
                        int32_t *****l_759 = &l_760;
                        (*l_759) = l_756;
                        /* statement id: 406 */
                        assert (l_760 == &l_757);
                        (***l_718) = l_755;
                    }
                }
            }
        }
        for (l_675 = 28; (l_675 != (-16)); l_675 = safe_sub_func_uint32_t_u_u(l_675, 1))
        { /* block id: 414 */
            uint8_t l_764 = 0x8EL;
            uint32_t l_776 = 6UL;
            struct S0 ***l_782 = &l_719;
            uint8_t l_804 = 253UL;
            int32_t **l_823[5] = {&l_712,&l_712,&l_712,&l_712,&l_712};
            int i;
            if (l_754[1])
            { /* block id: 415 */
                int8_t l_768 = 0x77L;
                struct S0 **l_773 = &l_720;
                int32_t **l_800 = &l_662;
                int32_t ***l_799 = &l_800;
                int32_t *** const *l_798 = &l_799;
                int32_t *** const **l_797 = &l_798;
                for (l_721.f1 = 9; (l_721.f1 >= 2); l_721.f1 -= 1)
                { /* block id: 418 */
                    for (l_713 = 5; (l_713 >= 0); l_713 -= 1)
                    { /* block id: 421 */
                        int i;
                        if (l_754[l_713])
                            break;
                        if (l_764)
                            continue;
                        return l_754[l_713];
                    }
                }
                if (((safe_unary_minus_func_int8_t_s(((safe_mod_func_uint8_t_u_u(l_768, (safe_lshift_func_int16_t_s_s(0x8078L, l_768)))) | (((safe_lshift_func_int16_t_s_u((((void*)0 != l_773) & (safe_add_func_int8_t_s_s(l_764, (l_768 >= l_768)))), l_768)) ^ 0x930DL) == l_768)))) < l_776))
                { /* block id: 427 */
                    const int32_t l_786 = 0x8BBEEBA7L;
                    const uint32_t l_792[1] = {0x0C986C89L};
                    struct S0 l_793 = {18446744073709551611UL,0x55B732FFL,0,11026,-3088};
                    int i;
                    for (l_713 = 0; (l_713 < 17); ++l_713)
                    { /* block id: 430 */
                        struct S0 * const *l_784 = &l_720;
                        struct S0 * const **l_783 = &l_784;
                        int32_t l_791 = (-1L);
                        (*l_723) = (safe_div_func_float_f_f(0x4.52B918p+14, (-((-0x7.0p+1) > ((((l_782 != l_783) != ((!l_786) != ((safe_mul_func_float_f_f((l_786 > (((safe_add_func_float_f_f(0xF.AE0702p-24, (-0x4.6p-1))) < l_791) >= l_792[0])), l_791)) < l_764))) > l_791) <= 0x1.0D29B8p-2)))));
                        (***l_783) = l_793;
                    }
                    if (l_793.f1)
                        continue;
                }
                else
                { /* block id: 435 */
                    const struct S0 l_796 = {0UL,0xBD1741CAL,0,14340,-1335};
                    for (l_768 = (-1); (l_768 >= 8); l_768++)
                    { /* block id: 438 */
                        (**l_719) = l_796;
                    }
                }
                (*l_797) = (void*)0;
                /* statement id: 442 */
                assert (l_798 == 0);
                for (l_721.f0 = 26; (l_721.f0 > 43); l_721.f0 = safe_add_func_int32_t_s_s(l_721.f0, 1))
                { /* block id: 445 */
                    float l_803 = (-0x8.1p-1);
                    if (l_804)
                        break;
                }
            }
            else
            { /* block id: 448 */
                int32_t *l_805 = &l_713;
                int32_t **l_806 = (void*)0;
                int32_t **l_807 = &l_662;
                (*l_807) = l_805;
                /* statement id: 449 */
                assert (l_662 == &l_713);
                if (l_713)
                    goto lbl_808;
                //assert (l_662 == dangling);
            }
            /* facts after branching */
            //assert (l_662 == &l_713 || l_662 == &l_2 || l_662 == 0 || l_662 == dangling);
            l_721.f4 = (((safe_mul_func_uint8_t_u_u(l_811[3][2], 0xABL)) && (safe_mod_func_uint16_t_u_u(((l_5[1][0] <= (!((void*)0 != (**l_782)))) >= (safe_mul_func_uint8_t_u_u(((safe_lshift_func_uint16_t_u_u(l_721.f4, 4)) >= ((l_821[4] | (l_782 != (void*)0)) > l_721.f4)), l_9))), (-1L)))) || 0x0BF51782L);
            l_662 = &l_2;
            /* statement id: 453 */
            assert (l_662 == &l_2);
        }
    }
    /* facts after for loop */
    //assert (l_662 == &l_2 || l_662 == 0 || l_662 == dangling);
    for (l_2 = 1; (l_2 <= 4); l_2 += 1)
    { /* block id: 458 */
        int32_t ** const *l_827 = &l_825;
        int32_t ** const **l_826[4];
        int32_t ****l_828 = (void*)0;
        int i;
        for (i = 0; i < 4; i++)
            l_826[i] = &l_827;
        l_829 = l_824;
        return l_821[l_2];
    }
    return l_830;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_10(int32_t * p_11, int32_t  p_12, int8_t  p_13, const int32_t  p_14)
{ /* block id: 339 */
    struct S0 *l_650 = (void*)0;
    struct S0 **l_651[8] = {(void*)0,&l_650,(void*)0,(void*)0,&l_650,(void*)0,(void*)0,&l_650};
    struct S0 l_653 = {1UL,0L,1,31576,5399};
    struct S0 *l_652[7][7] = {{&l_653,&l_653,(void*)0,&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653,&l_653,&l_653,&l_653},{(void*)0,&l_653,&l_653,&l_653,&l_653,&l_653,(void*)0},{&l_653,&l_653,&l_653,&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653,&l_653,&l_653,(void*)0},{&l_653,&l_653,&l_653,&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653,&l_653,(void*)0,(void*)0}};
    int32_t l_655 = 7L;
    int32_t * const l_654 = &l_655;
    int32_t * const l_656 = &l_655;
    int32_t * const l_657 = &l_655;
    int32_t * const l_658[2] = {&l_655,&l_655};
    int32_t * const l_659[5][3][4] = {{{&l_655,&l_655,&l_655,&l_655},{&l_655,&l_655,(void*)0,&l_655},{&l_655,(void*)0,&l_655,(void*)0}},{{&l_655,(void*)0,&l_655,&l_655},{(void*)0,&l_655,&l_655,&l_655},{(void*)0,(void*)0,&l_655,&l_655}},{{&l_655,&l_655,&l_655,&l_655},{&l_655,(void*)0,(void*)0,&l_655},{&l_655,&l_655,&l_655,&l_655}},{{&l_655,&l_655,(void*)0,(void*)0},{&l_655,&l_655,&l_655,(void*)0},{&l_655,&l_655,(void*)0,&l_655}},{{(void*)0,&l_655,(void*)0,&l_655},{&l_655,(void*)0,&l_655,&l_655},{&l_655,&l_655,&l_655,&l_655}}};
    int32_t * const l_660 = &l_655;
    int32_t * const l_661 = (void*)0;
    int i, j, k;
    l_652[2][1] = l_650;
    return l_661;
    /* statement id: 341 */
    //assert (func_10_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_15(int32_t * p_16, uint16_t  p_17, int32_t * p_18)
{ /* block id: 9 */
    struct S0 l_23 = {0xCFDA6C2E3A4C6382LL,-1L,0,12569,-5646};
    struct S0 *l_22 = &l_23;
    uint32_t l_24[8] = {0x7B17B4D2L,0x85F402BEL,0x7B17B4D2L,0x85F402BEL,0x7B17B4D2L,0x85F402BEL,0x7B17B4D2L,0x85F402BEL};
    int32_t *l_56 = (void*)0;
    int32_t **l_55 = &l_56;
    uint32_t l_645[4];
    int i;
    for (i = 0; i < 4; i++)
        l_645[i] = 0xABCC978BL;
    if ((p_17 >= 0x09L))
    { /* block id: 10 */
        int32_t **l_38 = (void*)0;
        int32_t l_58[3][3] = {{(-1L),(-1L),(-1L)},{0x9588DFEFL,0x9588DFEFL,0x9588DFEFL},{(-1L),(-1L),(-1L)}};
        int32_t **l_616 = &l_56;
        int i, j;
        for (p_17 = (-10); (p_17 >= 50); p_17 = safe_add_func_int8_t_s_s(p_17, 4))
        { /* block id: 13 */
            int32_t **l_57 = &l_56;
            const int32_t l_432 = 0x53215303L;
            int32_t ***l_624 = &l_57;
            l_22 = (void*)0;
            /* statement id: 14 */
            assert (l_22 == 0);
            for (l_23.f1 = 6; (l_23.f1 >= 0); l_23.f1 -= 1)
            { /* block id: 17 */
                int32_t l_27[5][4] = {{0x21F997ECL,0x21F997ECL,0x3A21B78CL,0xFBDEDBECL},{0x21F997ECL,(-6L),0x1A932DA3L,0x21F997ECL},{0xFB49A5C1L,0xFBDEDBECL,0xFB49A5C1L,0x1A932DA3L},{0xB1D4416DL,0xFBDEDBECL,0x3A21B78CL,0x21F997ECL},{0xFBDEDBECL,(-6L),(-6L),0xFBDEDBECL}};
                int32_t *l_26[5] = {&l_27[4][0],&l_27[4][0],&l_27[4][0],&l_27[4][0],&l_27[4][0]};
                int32_t **l_25 = &l_26[3];
                int i, j;
                (*l_25) = (void*)0;
                /* statement id: 18 */
                //assert (l_26[0] == 0 || (l_26[0] >= &l_27[0][0] && l_26[0] <= &l_27[4][3]));
            }
            (*l_624) = func_28(func_33(l_38, l_23.f3, ((safe_lshift_func_uint16_t_u_s((safe_div_func_int64_t_s_s((safe_add_func_uint8_t_u_u((l_24[7] | (safe_lshift_func_uint16_t_u_s(p_17, ((safe_add_func_int64_t_s_s((((func_51(l_55, l_57, l_58[2][1]) > 0UL) > p_17) <= p_17), p_17)) ^ 0x94L)))), p_17)), p_17)), 9)) || l_432), p_17), p_17, l_616, p_17);
        }
        /* facts after for loop */
        assert (l_22 == 0 || l_22 == &l_23);
        (*l_55) = p_16;
        /* statement id: 326 */
        //assert (l_56 == &l_6 || (l_56 >= &l_710[0] && l_56 <= &l_710[9]));
    }
    else
    { /* block id: 327 */
        int8_t l_629 = 0L;
        int32_t *l_649 = (void*)0;
        for (l_23.f0 = 29; (l_23.f0 != 5); l_23.f0 = safe_sub_func_int32_t_s_s(l_23.f0, 3))
        { /* block id: 330 */
            float l_644[5];
            struct S0 **l_646 = &l_22;
            int i;
            for (i = 0; i < 5; i++)
                l_644[i] = 0x4.5E60CEp+64;
            (*l_55) = (*l_55);
            (*l_646) = func_59((safe_mul_func_uint16_t_u_u(l_629, 1UL)), (safe_mul_func_int8_t_s_s((((*p_18) < (safe_div_func_int16_t_s_s(p_17, (safe_rshift_func_uint16_t_u_u(p_17, 15))))) > (*p_18)), (safe_rshift_func_uint8_t_u_s((safe_mul_func_uint16_t_u_u((safe_add_func_int8_t_s_s((1L || (9UL >= (p_17 >= 1UL))), p_17)), l_629)), p_17)))), l_645[2], (*l_55), p_17);
            /* statement id: 332 */
            assert (l_22 == 0);
            (*p_16) = (safe_add_func_uint8_t_u_u(p_17, (p_16 != (*l_55))));
        }
        /* facts after for loop */
        assert (l_22 == 0 || l_22 == &l_23);
        return l_649;
        /* statement id: 335 */
        //assert (func_15_rv == 0);
    }
    /* facts after branching */
    assert (l_22 == 0 || l_22 == &l_23);
    //assert (l_56 == &l_6 || (l_56 >= &l_710[0] && l_56 <= &l_710[9]));
    (*l_55) = p_16;
    return p_16;
    /* statement id: 338 */
    //assert (func_15_rv == &l_6 || (func_15_rv >= &l_710[0] && func_15_rv <= &l_710[9]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_28(int32_t ** p_29, uint32_t  p_30, int32_t ** p_31, uint32_t  p_32)
{ /* block id: 320 */
    struct S0 l_617[6][7][3] = {{{{1UL,-7L,1,1139,5584},{1UL,0x600FB382L,0,9608,-4206},{0xA6AC42CAD2FD9D4ALL,-1L,0,6949,-5645}},{{0xBD095FF20CE95772LL,0x4B62A37BL,1,3732,3376},{1UL,0x6692462DL,1,4499,2529},{18446744073709551615UL,-1L,0,21514,-4332}},{{18446744073709551615UL,0x32F2236DL,0,29521,5730},{1UL,0x600FB382L,0,9608,-4206},{18446744073709551615UL,0x32F2236DL,0,29521,5730}},{{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{0xBD095FF20CE95772LL,0x4B62A37BL,1,3732,3376},{0x4D520168DE0973A1LL,9L,0,599,3059}},{{0xF5656533C9541F70LL,-1L,1,9698,3485},{18446744073709551610UL,0x2849392EL,0,15634,3788},{18446744073709551615UL,0x32F2236DL,0,29521,5730}},{{0x4D520168DE0973A1LL,9L,0,599,3059},{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{18446744073709551615UL,-1L,0,21514,-4332}},{{18446744073709551612UL,0xE2448264L,0,5849,2363},{1UL,8L,0,5035,-4850},{0xA6AC42CAD2FD9D4ALL,-1L,0,6949,-5645}}},{{{0x4D520168DE0973A1LL,9L,0,599,3059},{0x4D520168DE0973A1LL,9L,0,599,3059},{18446744073709551615UL,0xB6419F03L,0,8547,-170}},{{0xF5656533C9541F70LL,-1L,1,9698,3485},{0xC5F02047E6ADB7A7LL,5L,1,26691,-3043},{1UL,3L,0,22954,-728}},{{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{0x4D520168DE0973A1LL,9L,0,599,3059},{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692}},{{18446744073709551615UL,0x32F2236DL,0,29521,5730},{1UL,8L,0,5035,-4850},{1UL,-7L,1,1139,5584}},{{0xBD095FF20CE95772LL,0x4B62A37BL,1,3732,3376},{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692}},{{1UL,-7L,1,1139,5584},{18446744073709551610UL,0x2849392EL,0,15634,3788},{1UL,3L,0,22954,-728}},{{1UL,0x6692462DL,1,4499,2529},{0xBD095FF20CE95772LL,0x4B62A37BL,1,3732,3376},{18446744073709551615UL,0xB6419F03L,0,8547,-170}}},{{{1UL,-7L,1,1139,5584},{1UL,0x600FB382L,0,9608,-4206},{0xA6AC42CAD2FD9D4ALL,-1L,0,6949,-5645}},{{0xBD095FF20CE95772LL,0x4B62A37BL,1,3732,3376},{1UL,0x6692462DL,1,4499,2529},{18446744073709551615UL,-1L,0,21514,-4332}},{{18446744073709551615UL,0x32F2236DL,0,29521,5730},{1UL,0x600FB382L,0,9608,-4206},{18446744073709551615UL,0x32F2236DL,0,29521,5730}},{{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{0xBD095FF20CE95772LL,0x4B62A37BL,1,3732,3376},{0x4D520168DE0973A1LL,9L,0,599,3059}},{{0xF5656533C9541F70LL,-1L,1,9698,3485},{18446744073709551610UL,0x2849392EL,0,15634,3788},{18446744073709551615UL,0x32F2236DL,0,29521,5730}},{{0x4D520168DE0973A1LL,9L,0,599,3059},{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{18446744073709551615UL,-1L,0,21514,-4332}},{{18446744073709551612UL,0xE2448264L,0,5849,2363},{1UL,8L,0,5035,-4850},{0xA6AC42CAD2FD9D4ALL,-1L,0,6949,-5645}}},{{{0x4D520168DE0973A1LL,9L,0,599,3059},{0x4D520168DE0973A1LL,9L,0,599,3059},{18446744073709551615UL,0xB6419F03L,0,8547,-170}},{{0xF5656533C9541F70LL,-1L,1,9698,3485},{0xC5F02047E6ADB7A7LL,5L,1,26691,-3043},{0xA6AC42CAD2FD9D4ALL,-1L,0,6949,-5645}},{{1UL,0x6692462DL,1,4499,2529},{0x9807B1A2F894A013LL,0xB08613A9L,1,8580,-3701},{1UL,0x6692462DL,1,4499,2529}},{{18446744073709551612UL,0xE2448264L,0,5849,2363},{18446744073709551610UL,0x2849392EL,0,15634,3788},{18446744073709551612UL,0x126D2577L,0,19556,-3620}},{{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{1UL,0x6692462DL,1,4499,2529},{1UL,0x6692462DL,1,4499,2529}},{{18446744073709551612UL,0x126D2577L,0,19556,-3620},{0xC5F02047E6ADB7A7LL,5L,1,26691,-3043},{0xA6AC42CAD2FD9D4ALL,-1L,0,6949,-5645}},{{18446744073709551615UL,-1L,0,21514,-4332},{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{0x4D520168DE0973A1LL,9L,0,599,3059}}},{{{18446744073709551612UL,0x126D2577L,0,19556,-3620},{0xEB6C1D49DC7950D2LL,1L,1,31673,-579},{1UL,-7L,1,1139,5584}},{{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{18446744073709551615UL,-1L,0,21514,-4332},{18446744073709551615UL,0xB6419F03L,0,8547,-170}},{{18446744073709551612UL,0xE2448264L,0,5849,2363},{0xEB6C1D49DC7950D2LL,1L,1,31673,-579},{18446744073709551612UL,0xE2448264L,0,5849,2363}},{{1UL,0x6692462DL,1,4499,2529},{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{0x9807B1A2F894A013LL,0xB08613A9L,1,8580,-3701}},{{18446744073709551615UL,0x32F2236DL,0,29521,5730},{0xC5F02047E6ADB7A7LL,5L,1,26691,-3043},{18446744073709551612UL,0xE2448264L,0,5849,2363}},{{0x9807B1A2F894A013LL,0xB08613A9L,1,8580,-3701},{1UL,0x6692462DL,1,4499,2529},{18446744073709551615UL,0xB6419F03L,0,8547,-170}},{{1UL,3L,0,22954,-728},{18446744073709551610UL,0x2849392EL,0,15634,3788},{1UL,-7L,1,1139,5584}}},{{{0x9807B1A2F894A013LL,0xB08613A9L,1,8580,-3701},{0x9807B1A2F894A013LL,0xB08613A9L,1,8580,-3701},{0x4D520168DE0973A1LL,9L,0,599,3059}},{{18446744073709551615UL,0x32F2236DL,0,29521,5730},{18446744073709551611UL,0xA3140D22L,0,5204,2301},{0xA6AC42CAD2FD9D4ALL,-1L,0,6949,-5645}},{{1UL,0x6692462DL,1,4499,2529},{0x9807B1A2F894A013LL,0xB08613A9L,1,8580,-3701},{1UL,0x6692462DL,1,4499,2529}},{{18446744073709551612UL,0xE2448264L,0,5849,2363},{18446744073709551610UL,0x2849392EL,0,15634,3788},{18446744073709551612UL,0x126D2577L,0,19556,-3620}},{{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{1UL,0x6692462DL,1,4499,2529},{1UL,0x6692462DL,1,4499,2529}},{{18446744073709551612UL,0x126D2577L,0,19556,-3620},{0xC5F02047E6ADB7A7LL,5L,1,26691,-3043},{0xA6AC42CAD2FD9D4ALL,-1L,0,6949,-5645}},{{18446744073709551615UL,-1L,0,21514,-4332},{0xD8A54C4FB27D3302LL,0x9DCFF2DCL,0,29383,4692},{0x4D520168DE0973A1LL,9L,0,599,3059}}}};
    int32_t l_618 = 9L;
    int32_t *l_619 = &l_618;
    int32_t **l_620 = &l_619;
    int32_t **l_621 = &l_619;
    int32_t **l_622 = &l_619;
    int32_t **l_623 = &l_619;
    int i, j, k;
    for (p_30 = 0; p_30 < 6; p_30 += 1)
    {
        for (p_32 = 0; p_32 < 7; p_32 += 1)
        {
            for (l_618 = 0; l_618 < 3; l_618 += 1)
            {
                struct S0 tmp = {0xABEDC6E114B12DDDLL,8L,0,22507,3601};
                l_617[p_30][p_32][l_618] = tmp;
            }
        }
    }
    l_619 = &l_618;
    return p_31;
    /* statement id: 323 */
    //assert (func_28_rv == &l_56);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_33(int32_t ** p_34, int8_t  p_35, uint16_t  p_36, float  p_37)
{ /* block id: 228 */
    int32_t l_434[10] = {(-1L),(-8L),0x8B10FAFCL,0x8B10FAFCL,(-8L),(-1L),(-8L),0x8B10FAFCL,0x8B10FAFCL,(-8L)};
    int32_t *l_433 = &l_434[4];
    int32_t **l_435 = &l_433;
    uint32_t l_461[5][4][3] = {{{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL},{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL}},{{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL},{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL}},{{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL},{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL}},{{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL},{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL}},{{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL},{0xA86876B8L,1UL,0xA86876B8L},{5UL,0x049E0BF1L,5UL}}};
    const uint32_t l_462[4] = {4294967295UL,4294967295UL,4294967295UL,4294967295UL};
    struct S0 l_463[2][8] = {{{18446744073709551615UL,0x70D12220L,0,23016,1993},{18446744073709551615UL,0x70D12220L,0,23016,1993},{18446744073709551612UL,0x87AC3E4CL,1,23730,57},{18446744073709551615UL,0x70D12220L,0,23016,1993},{18446744073709551615UL,0x70D12220L,0,23016,1993},{18446744073709551612UL,0x87AC3E4CL,1,23730,57},{18446744073709551615UL,0x70D12220L,0,23016,1993},{18446744073709551615UL,0x70D12220L,0,23016,1993}},{{1UL,0x3699D082L,1,2627,-254},{18446744073709551615UL,0x70D12220L,0,23016,1993},{1UL,0x3699D082L,1,2627,-254},{1UL,0x3699D082L,1,2627,-254},{18446744073709551615UL,0x70D12220L,0,23016,1993},{1UL,0x3699D082L,1,2627,-254},{1UL,0x3699D082L,1,2627,-254},{18446744073709551615UL,0x70D12220L,0,23016,1993}}};
    const struct S0 *l_554[2];
    const struct S0 **l_553 = &l_554[0];
    const struct S0 ***l_552 = &l_553;
    const struct S0 ****l_551 = &l_552;
    float l_596 = 0xE.B2ADA4p+2;
    float *l_595 = &l_596;
    float *l_597 = &l_596;
    int i, j, k;
    for (i = 0; i < 2; i++)
        l_554[i] = &l_463[1][7];
    (*l_435) = l_433;
lbl_464:
    (**l_435) = (safe_sub_func_uint64_t_u_u((safe_lshift_func_int16_t_s_u((safe_mul_func_int8_t_s_s((safe_div_func_uint32_t_u_u(p_35, (*l_433))), (safe_add_func_int16_t_s_s((*l_433), (((safe_mod_func_uint64_t_u_u((safe_unary_minus_func_int16_t_s((safe_mod_func_int16_t_s_s(((safe_sub_func_int64_t_s_s((**l_435), 1UL)) || (safe_add_func_uint8_t_u_u((**l_435), ((*l_435) == (void*)0)))), (safe_mul_func_int8_t_s_s((safe_add_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u(0x25L, p_35)), (**l_435))), l_461[3][2][0])))))), l_462[3])) < (*l_433)) | (*l_433)))))), (*l_433))), (**l_435)));
    for (p_35 = 0; (p_35 <= 9); p_35 += 1)
    { /* block id: 233 */
        int8_t l_485 = 0L;
        struct S0 *l_502 = &l_463[1][7];
        struct S0 **l_501[6][3][1] = {{{&l_502},{&l_502},{&l_502}},{{&l_502},{(void*)0},{&l_502}},{{(void*)0},{&l_502},{&l_502}},{{&l_502},{&l_502},{(void*)0}},{{&l_502},{(void*)0},{&l_502}},{{&l_502},{&l_502},{&l_502}}};
        struct S0 ***l_500 = &l_501[3][2][0];
        struct S0 ****l_499 = &l_500;
        int32_t **l_560 = (void*)0;
        const struct S0 *l_589 = &l_463[0][6];
        int i, j, k;
        l_463[0][7] = l_463[0][7];
        for (p_36 = 0; (p_36 <= 2); p_36 += 1)
        { /* block id: 237 */
            float l_484 = 0x3.0C2C49p-9;
            float *l_483[5] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
            struct S0 ****l_503[5][4][8] = {{{&l_500,&l_500,&l_500,&l_500,(void*)0,(void*)0,&l_500,&l_500},{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500},{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0},{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0}},{{(void*)0,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500,&l_500},{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500},{&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500},{&l_500,&l_500,(void*)0,&l_500,(void*)0,&l_500,&l_500,&l_500}},{{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0,&l_500},{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500},{&l_500,(void*)0,&l_500,&l_500,(void*)0,&l_500,&l_500,&l_500},{&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500}},{{&l_500,&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,(void*)0},{&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0},{&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500},{&l_500,&l_500,&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500}},{{&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500,(void*)0},{&l_500,&l_500,&l_500,(void*)0,(void*)0,&l_500,&l_500,&l_500},{&l_500,(void*)0,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500},{&l_500,(void*)0,&l_500,&l_500,&l_500,&l_500,&l_500,&l_500}}};
            int64_t l_544 = 0x739653B0071A631DLL;
            uint32_t l_586 = 0x213D1EC1L;
            struct S0 ****l_603 = &l_500;
            int i, j, k;
            if (p_36)
                goto lbl_464;
        }
    }
    (*l_435) = (*l_435);
    return p_34;
    /* statement id: 319 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_51(int32_t ** p_52, int32_t ** p_53, uint16_t  p_54)
{ /* block id: 20 */
    uint32_t l_68 = 2UL;
    struct S0 l_69 = {18446744073709551607UL,0x795BCD59L,1,6808,-2892};
    int32_t l_416 = 6L;
    int32_t *l_415 = &l_416;
    struct S0 *l_431 = &l_69;
    struct S0 **l_430 = &l_431;
    (*l_430) = func_59((1UL | ((func_65(l_68, l_69) != ((safe_add_func_uint8_t_u_u((safe_mod_func_uint32_t_u_u(((0L != (((safe_div_func_uint16_t_u_u(l_69.f2, (~(l_69.f2 == 18446744073709551615UL)))) | 0x68EF9162L) || 0xC495L)) != l_69.f1), l_69.f0)), p_54)) || l_69.f2)) | 18446744073709551609UL)), p_54, l_69.f0, l_415, (*l_415));
    /* statement id: 226 */
    assert (l_431 == 0);
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_59(int8_t  p_60, uint16_t  p_61, uint32_t  p_62, int32_t * p_63, int32_t  p_64)
{ /* block id: 223 */
    int32_t * const l_417[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    int32_t l_420[3];
    int32_t *l_419 = &l_420[1];
    int32_t **l_418[2];
    int32_t **l_421 = &l_419;
    struct S0 l_423 = {0UL,0xB473A780L,0,28105,3006};
    struct S0 *l_422 = &l_423;
    struct S0 *l_424[7] = {&l_423,&l_423,&l_423,&l_423,&l_423,&l_423,&l_423};
    struct S0 *l_425 = &l_423;
    struct S0 *l_426[7][1][10] = {{{&l_423,(void*)0,&l_423,&l_423,&l_423,(void*)0,&l_423,(void*)0,&l_423,&l_423}},{{(void*)0,&l_423,(void*)0,(void*)0,&l_423,(void*)0,(void*)0,&l_423,(void*)0,(void*)0}},{{&l_423,&l_423,&l_423,&l_423,&l_423,(void*)0,&l_423,&l_423,&l_423,&l_423}},{{&l_423,(void*)0,(void*)0,&l_423,(void*)0,(void*)0,(void*)0,(void*)0,&l_423,(void*)0}},{{&l_423,(void*)0,&l_423,(void*)0,&l_423,(void*)0,&l_423,(void*)0,&l_423,(void*)0}},{{(void*)0,(void*)0,&l_423,(void*)0,(void*)0,&l_423,(void*)0,(void*)0,&l_423,(void*)0}},{{&l_423,(void*)0,&l_423,(void*)0,&l_423,(void*)0,&l_423,(void*)0,&l_423,(void*)0}}};
    struct S0 *l_427 = &l_423;
    struct S0 *l_428 = &l_423;
    struct S0 *l_429 = (void*)0;
    int i, j, k;
    for (i = 0; i < 3; i++)
        l_420[i] = 0L;
    for (i = 0; i < 2; i++)
        l_418[i] = &l_419;
    (*l_421) = l_417[3];
    /* statement id: 224 */
    assert (l_419 == 0);
    return l_429;
    /* statement id: 225 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_65(int32_t  p_66, struct S0  p_67)
{ /* block id: 21 */
    uint64_t l_70[7] = {0x7B934CEB0392260FLL,0UL,0x7B934CEB0392260FLL,0x7B934CEB0392260FLL,0UL,0x7B934CEB0392260FLL,0x7B934CEB0392260FLL};
    float l_72 = 0x1.0p+1;
    float *l_71 = &l_72;
    int32_t l_357[1];
    int32_t *l_356[6][5][1] = {{{&l_357[0]},{&l_357[0]},{&l_357[0]},{(void*)0},{&l_357[0]}},{{&l_357[0]},{&l_357[0]},{(void*)0},{&l_357[0]},{&l_357[0]}},{{&l_357[0]},{(void*)0},{&l_357[0]},{&l_357[0]},{&l_357[0]}},{{(void*)0},{&l_357[0]},{&l_357[0]},{&l_357[0]},{(void*)0}},{{&l_357[0]},{&l_357[0]},{&l_357[0]},{(void*)0},{&l_357[0]}},{{&l_357[0]},{&l_357[0]},{(void*)0},{&l_357[0]},{&l_357[0]}}};
    int64_t l_373 = (-8L);
    struct S0 **l_383 = (void*)0;
    struct S0 ***l_382 = &l_383;
    struct S0 *l_406 = (void*)0;
    struct S0 l_407 = {18446744073709551613UL,0xB167C544L,0,6409,-5294};
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_357[i] = 0x8FE824BAL;
lbl_386:
    (*l_71) = l_70[2];
    for (p_67.f1 = (-28); (p_67.f1 == (-2)); p_67.f1++)
    { /* block id: 25 */
        uint8_t l_84 = 0UL;
        float *l_359 = &l_72;
        if (p_67.f4)
        { /* block id: 26 */
            int32_t l_344 = (-3L);
            struct S0 l_351 = {1UL,0xD487A202L,1,32230,2336};
            float * const l_358[5] = {&l_72,&l_72,&l_72,&l_72,&l_72};
            struct S0 *l_380[10][10] = {{(void*)0,&l_351,(void*)0,&l_351,&l_351,&l_351,(void*)0,&l_351,(void*)0,(void*)0},{&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351},{&l_351,(void*)0,&l_351,&l_351,&l_351,(void*)0,&l_351,(void*)0,(void*)0,&l_351},{(void*)0,&l_351,&l_351,&l_351,&l_351,(void*)0,(void*)0,&l_351,(void*)0,(void*)0},{&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351},{&l_351,(void*)0,(void*)0,&l_351,&l_351,(void*)0,&l_351,(void*)0,&l_351,&l_351},{(void*)0,&l_351,(void*)0,&l_351,&l_351,(void*)0,(void*)0,&l_351,&l_351,(void*)0},{&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351,&l_351},{&l_351,(void*)0,(void*)0,&l_351,&l_351,&l_351,&l_351,(void*)0,(void*)0,&l_351},{(void*)0,&l_351,(void*)0,&l_351,&l_351,&l_351,(void*)0,&l_351,(void*)0,(void*)0}};
            struct S0 **l_379 = &l_380[1][0];
            int32_t l_387 = 0x5F782E1AL;
            int i, j;
            for (p_67.f0 = (-17); (p_67.f0 >= 49); p_67.f0 = safe_add_func_uint64_t_u_u(p_67.f0, 3))
            { /* block id: 29 */
                int8_t l_348 = 0x9FL;
                int32_t *l_370 = &l_357[0];
                struct S0 ***l_396 = (void*)0;
                for (p_66 = 0; (p_66 == 23); ++p_66)
                { /* block id: 32 */
                    int32_t l_345 = 7L;
                    (*l_71) = (func_79(func_82(l_84), p_67) == (0x0.6p-1 > ((safe_add_func_float_f_f(p_67.f4, (((safe_div_func_float_f_f((0x0.D02CC8p-93 <= (l_84 <= (l_344 < 0xC.A7392Bp-61))), l_345)) >= 0x9.1DBEBFp-57) < p_66))) <= p_67.f0)));
                    if ((safe_lshift_func_uint8_t_u_u(255UL, l_348)))
                    { /* block id: 162 */
                        struct S0 l_350[8] = {{18446744073709551615UL,-1L,0,520,2212},{18446744073709551615UL,-1L,0,520,2212},{5UL,0xAA62D46DL,1,22769,5744},{18446744073709551615UL,-1L,0,520,2212},{18446744073709551615UL,-1L,0,520,2212},{5UL,0xAA62D46DL,1,22769,5744},{18446744073709551615UL,-1L,0,520,2212},{18446744073709551615UL,-1L,0,520,2212}};
                        struct S0 *l_349[5];
                        int i;
                        for (i = 0; i < 5; i++)
                            l_349[i] = &l_350[2];
                        l_351 = p_67;
                    }
                    else
                    { /* block id: 164 */
                        if (p_67.f4)
                            break;
                    }
                }
                for (l_351.f0 = 6; (l_351.f0 != 44); l_351.f0 = safe_add_func_int16_t_s_s(l_351.f0, 1))
                { /* block id: 170 */
                    int32_t *l_355 = &l_344;
                    int32_t **l_354 = &l_355;
                    (*l_354) = &l_344;
                    if (p_67.f1)
                    { /* block id: 172 */
                        p_67.f4 = p_67.f3;
                    }
                    else
                    { /* block id: 174 */
                        l_356[3][2][0] = &p_66;
                    }
                    (**l_354) = (((l_358[2] == l_359) && (safe_mul_func_uint16_t_u_u((**l_354), (safe_lshift_func_uint16_t_u_s(((safe_mul_func_int8_t_s_s((safe_mod_func_int64_t_s_s(((p_67.f3 > ((0xB9927379416BD094LL == (0x72L <= ((((safe_add_func_int64_t_s_s((l_370 != &p_66), ((safe_div_func_int32_t_s_s((p_67.f2 != p_67.f4), 0x1DA71A93L)) < p_67.f1))) == p_67.f0) == p_67.f4) != 0x3E96E97BL))) & p_67.f1)) <= p_66), 0x668F69760B0DC34BLL)), 254UL)) | p_67.f4), (**l_354)))))) > p_67.f0);
                }
                if (l_373)
                    continue;
                if ((((~(*l_370)) ^ p_66) < (p_67.f1 & 0xBCC9911B011C773FLL)))
                { /* block id: 180 */
                    int32_t *l_375[8] = {(void*)0,&l_357[0],(void*)0,(void*)0,&l_357[0],(void*)0,(void*)0,(void*)0};
                    int32_t **l_376 = &l_356[3][4][0];
                    struct S0 **l_381[8];
                    int i;
                    for (i = 0; i < 8; i++)
                        l_381[i] = &l_380[1][0];
                    (*l_376) = l_375[0];
                    for (l_344 = 0; (l_344 != (-14)); l_344--)
                    { /* block id: 184 */
                        if (l_84)
                            break;
                        return p_67.f0;
                    }
                    if ((l_379 == l_381[1]))
                    { /* block id: 188 */
                        struct S0 ****l_384 = (void*)0;
                        struct S0 ****l_385 = &l_382;
                        (*l_385) = l_382;
                        if (p_67.f3)
                            goto lbl_386;
                        (*l_385) = &l_383;
                        if (l_387)
                            continue;
                    }
                    else
                    { /* block id: 193 */
                        (*l_376) = &p_66;
                    }
                    for (p_66 = 0; (p_66 <= 20); ++p_66)
                    { /* block id: 198 */
                        int8_t l_390 = 9L;
                        if (l_390)
                            break;
                        if (p_67.f1)
                            continue;
                    }
                }
                else
                { /* block id: 202 */
                    uint8_t l_395 = 0UL;
                    if ((safe_lshift_func_uint8_t_u_s(((void*)0 == &l_382), ((4294967292UL >= l_351.f1) && (((safe_sub_func_uint32_t_u_u(l_395, (l_395 | 8L))) < (((*l_370) & ((l_396 != &l_383) == l_351.f3)) != p_67.f0)) <= l_84)))))
                    { /* block id: 203 */
                        int32_t **l_397 = &l_370;
                        (*l_397) = &p_66;
                        /* statement id: 204 */
                        assert (l_370 == &p_66);
                    }
                    else
                    { /* block id: 205 */
                        (*l_370) = (l_395 || (safe_rshift_func_int8_t_s_s(0x40L, (p_67.f3 < (*l_370)))));
                        p_66 = (l_370 == (void*)0);
                    }
                    /* facts after branching */
                    assert ((l_370 >= &l_357[0] && l_370 <= &l_357[0]) || l_370 == &p_66);
                }
                /* facts after branching */
                assert ((l_370 >= &l_357[0] && l_370 <= &l_357[0]) || l_370 == &p_66);
            }
        }
        else
        { /* block id: 211 */
            float **l_404[6];
            int i;
            for (i = 0; i < 6; i++)
                l_404[i] = &l_359;
            for (l_84 = 0; (l_84 >= 2); l_84 = safe_add_func_uint16_t_u_u(l_84, 6))
            { /* block id: 214 */
                int32_t **l_402 = (void*)0;
                int32_t **l_403 = &l_356[3][4][0];
                float **l_405[2];
                int i;
                for (i = 0; i < 2; i++)
                    l_405[i] = &l_71;
                (*l_403) = &p_66;
                l_405[1] = l_404[0];
                /* statement id: 216 */
                //assert (l_405[0] == &l_359 || l_405[0] == &l_71);
                (*l_403) = l_359;
            }
        }
    }
    l_407 = p_67;
    return p_67.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_79(struct S0 * p_80, struct S0  p_81)
{ /* block id: 155 */
    int32_t *l_323[3];
    uint64_t l_334 = 0xDFC33572A64BF8E8LL;
    int32_t l_335 = 0L;
    float l_337 = 0x0.0p+1;
    float *l_336 = &l_337;
    float *l_338 = &l_337;
    int32_t **l_339 = &l_323[2];
    int i;
    for (i = 0; i < 3; i++)
        l_323[i] = (void*)0;
    p_81.f4 = p_81.f1;
    (*l_336) = (((safe_add_func_float_f_f((safe_mul_func_float_f_f((safe_div_func_float_f_f((0x0.0p+1 > p_81.f0), p_81.f3)), (((p_81.f2 != ((((safe_sub_func_float_f_f(((safe_div_func_float_f_f((p_81.f2 < (l_334 == (p_81.f3 == (0x0.2p-1 < ((void*)0 == l_323[1]))))), p_81.f1)) != p_81.f0), p_81.f4)) > p_81.f2) > p_81.f4) > p_81.f1)) > l_335) <= p_81.f1))), 0xB.37043Cp-94)) == p_81.f3) <= (-0x1.5p+1));
    (*l_338) = ((void*)0 != l_338);
    (*l_339) = &l_335;
    /* statement id: 159 */
    //assert (l_323[0] == &l_335 || l_323[0] == 0);
    return p_81.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_82(int8_t  p_83)
{ /* block id: 33 */
    int32_t l_85 = 0xC8B8AFECL;
    struct S0 l_106 = {0x825D0D3007418113LL,0x39BF9AB2L,1,28540,-2971};
    int32_t *l_204 = &l_85;
    int32_t **l_203 = &l_204;
    uint16_t l_253 = 65529UL;
    struct S0 *l_260 = &l_106;
    struct S0 **l_259 = &l_260;
    struct S0 *l_283[8] = {&l_106,&l_106,&l_106,&l_106,&l_106,&l_106,&l_106,&l_106};
    struct S0 *l_284 = &l_106;
    struct S0 *l_293 = &l_106;
    struct S0 *l_299 = &l_106;
    struct S0 *l_300 = &l_106;
    struct S0 *l_301 = &l_106;
    struct S0 *l_307 = &l_106;
    struct S0 *l_309 = &l_106;
    struct S0 *l_313 = (void*)0;
    struct S0 *l_316 = &l_106;
    struct S0 *l_317 = &l_106;
    struct S0 *l_318[10][9] = {{&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0},{&l_106,&l_106,(void*)0,(void*)0,&l_106,(void*)0,&l_106,(void*)0,(void*)0},{&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0},{&l_106,&l_106,(void*)0,(void*)0,&l_106,(void*)0,&l_106,(void*)0,(void*)0},{&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0},{&l_106,&l_106,(void*)0,(void*)0,&l_106,(void*)0,&l_106,(void*)0,(void*)0},{&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0},{&l_106,&l_106,(void*)0,(void*)0,&l_106,(void*)0,&l_106,(void*)0,(void*)0},{&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0,&l_106,&l_106,(void*)0},{&l_106,&l_106,(void*)0,(void*)0,&l_106,(void*)0,&l_106,(void*)0,(void*)0}};
    struct S0 *l_319 = &l_106;
    struct S0 *l_320 = &l_106;
    struct S0 *l_321 = &l_106;
    struct S0 *l_322[5];
    int i, j;
    for (i = 0; i < 5; i++)
        l_322[i] = (void*)0;
    if ((((18446744073709551613UL < l_85) == 0x0087L) >= l_85))
    { /* block id: 34 */
        uint32_t l_100 = 0x7198F9F0L;
        struct S0 l_104 = {0xDC47558758A71D4FLL,-9L,0,25446,3145};
        struct S0 *l_103 = &l_104;
        int32_t *l_166 = (void*)0;
        for (l_85 = 0; (l_85 == (-29)); l_85 = safe_sub_func_int32_t_s_s(l_85, 3))
        { /* block id: 37 */
            const struct S0 l_105 = {18446744073709551612UL,0L,0,31033,4360};
            int32_t *l_111 = &l_85;
            struct S0 *l_156 = &l_106;
            int32_t * const l_165 = (void*)0;
            int8_t l_192 = 0x67L;
        }
    }
    else
    { /* block id: 112 */
        uint16_t l_261 = 0UL;
        uint64_t l_262 = 0UL;
        int32_t *l_267 = &l_85;
        uint16_t l_270[6];
        struct S0 *l_282 = &l_106;
        struct S0 *l_285 = &l_106;
        struct S0 *l_286 = (void*)0;
        int i;
        for (i = 0; i < 6; i++)
            l_270[i] = 0x7C3EL;
        (**l_203) = (((0x23628DD6L != (safe_rshift_func_uint8_t_u_s((0x6A1B3C1EEC739D5CLL & l_253), ((p_83 | p_83) & (((0x25B5L & (~p_83)) > (((safe_sub_func_uint64_t_u_u(((safe_div_func_uint64_t_u_u(((p_83 >= ((void*)0 != l_259)) | 0x5EL), p_83)) ^ l_261), p_83)) & p_83) != 65531UL)) && l_262))))) & p_83) & 1UL);
        for (l_261 = (-22); (l_261 <= 17); ++l_261)
        { /* block id: 116 */
            int32_t *l_272 = (void*)0;
            for (p_83 = 12; (p_83 == (-26)); p_83 = safe_sub_func_uint32_t_u_u(p_83, 7))
            { /* block id: 119 */
                float l_279 = 0xB.52AAD3p-76;
                struct S0 *l_280 = (void*)0;
                int32_t l_281[10] = {0x529B9CDFL,0x1EAC38EDL,0x529B9CDFL,0x1EAC38EDL,0x529B9CDFL,0x1EAC38EDL,0x529B9CDFL,0x1EAC38EDL,0x529B9CDFL,0x1EAC38EDL};
                int i;
                (*l_203) = l_267;
                /* statement id: 120 */
                assert (l_204 == &l_85);
                for (l_106.f1 = 18; (l_106.f1 != 27); l_106.f1++)
                { /* block id: 123 */
                    int32_t *l_271 = (void*)0;
                    for (l_253 = 0; (l_253 <= 5); l_253 += 1)
                    { /* block id: 126 */
                        (*l_203) = l_271;
                        /* statement id: 127 */
                        assert (l_204 == 0);
                        l_272 = (void*)0;
                    }
                    for (l_262 = (-28); (l_262 > 19); l_262++)
                    { /* block id: 132 */
                        (*l_267) = ((safe_mod_func_int16_t_s_s((-1L), (safe_mul_func_int8_t_s_s(p_83, 0x5CL)))) > (*l_267));
                        return l_280;
                        /* statement id: 134 */
                        //assert (func_82_rv == 0);
                    }
                    for (l_253 = 0; (l_253 <= 5); l_253 += 1)
                    { /* block id: 138 */
                        (*l_203) = l_272;
                        /* statement id: 139 */
                        assert (l_204 == 0);
                    }
                }
                /* facts after for loop */
                assert (l_204 == 0 || l_204 == &l_85);
                if (l_281[2])
                    continue;
                (*l_203) = l_267;
                /* statement id: 143 */
                assert (l_204 == &l_85);
            }
        }
        /* facts after for loop */
        assert (l_204 == 0 || l_204 == &l_85);
        return l_286;
        /* statement id: 146 */
        //assert (func_82_rv == 0);
    }
    if ((safe_div_func_uint64_t_u_u((((p_83 != (65535UL | (safe_lshift_func_int16_t_s_u(p_83, 10)))) | ((((**l_203) ^ p_83) > ((safe_rshift_func_int8_t_s_u(p_83, 1)) == p_83)) | ((0x13L | 0xEBL) > p_83))) == (*l_204)), 0x53D69D35C18B8741LL)))
    { /* block id: 148 */
        struct S0 *l_294 = &l_106;
        struct S0 *l_295 = &l_106;
        struct S0 *l_296 = &l_106;
        struct S0 *l_297[6] = {(void*)0,&l_106,&l_106,(void*)0,&l_106,&l_106};
        struct S0 *l_298[2];
        struct S0 *l_302 = &l_106;
        struct S0 *l_303 = &l_106;
        struct S0 *l_304 = &l_106;
        struct S0 *l_305[4][3][1] = {{{(void*)0},{&l_106},{(void*)0}},{{(void*)0},{&l_106},{(void*)0}},{{&l_106},{(void*)0},{(void*)0}},{{&l_106},{(void*)0},{&l_106}}};
        struct S0 *l_306 = &l_106;
        struct S0 *l_308 = &l_106;
        struct S0 *l_310 = &l_106;
        struct S0 *l_311 = &l_106;
        struct S0 *l_312 = &l_106;
        int i, j, k;
        for (i = 0; i < 2; i++)
            l_298[i] = &l_106;
        return l_313;
        /* statement id: 149 */
        //assert (func_82_rv == 0);
    }
    else
    { /* block id: 150 */
        int32_t *l_314 = &l_85;
        (*l_203) = l_314;
    }
    (**l_203) = (!(**l_203));
    return l_322[3];
    /* statement id: 154 */
    //assert (func_82_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 216
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 89
breakdown:
   indirect level: 0, occurrence: 16
   indirect level: 1, occurrence: 56
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 126
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 28
XXX times a single bitfield on LHS: 10
XXX times a single bitfield on RHS: 38

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 162
   depth: 2, occurrence: 45
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 216

XXX times a variable address is taken: 405
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 38
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 81
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 31
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 834

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 229
   level: 2, occurrence: 68
   level: 3, occurrence: 30
   level: 4, occurrence: 7
XXX number of pointers point to pointers: 95
XXX number of pointers point to scalars: 68
XXX number of pointers point to structs: 53
XXX percent of pointers has null in alias set: 31.9
XXX average alias set size: 1.25

XXX times a non-volatile is read: 669
XXX times a non-volatile is write: 266
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 7

XXX stmts: 161
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 21
   depth: 2, occurrence: 16
   depth: 3, occurrence: 21
   depth: 4, occurrence: 32
   depth: 5, occurrence: 37

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

