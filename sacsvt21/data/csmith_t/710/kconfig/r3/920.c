/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2573502112
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int64_t  f0;
   unsigned f1 : 11;
   uint32_t  f2;
};

union U1 {
   int32_t  f0;
   uint16_t  f1;
   uint8_t  f2;
   const uint32_t  f3;
   uint64_t  f4;
};

union U2 {
   float  f0;
   unsigned f1 : 30;
   int16_t  f2;
   uint32_t  f3;
   uint8_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_30(void);
inline static int32_t * const  func_37(const uint16_t  p_38);
inline static int32_t ** func_39(int16_t  p_40);
inline static float  func_45(uint32_t  p_46, int16_t  p_47, uint32_t  p_48, const int16_t  p_49, struct S0  p_50);
static uint32_t  func_51(uint32_t  p_52, int64_t  p_53, uint8_t  p_54, int32_t  p_55, union U2  p_56);
static uint32_t  func_57(int32_t ** p_58, float  p_59, float  p_60, uint64_t  p_61);
static int32_t ** func_62(int32_t * const  p_63, int32_t * p_64, int32_t  p_65, int32_t ** p_66, uint16_t  p_67);
inline static int32_t * const  func_68(struct S0 * const  p_69);
inline static struct S0 * const  func_70(uint32_t  p_71, struct S0 * p_72, uint64_t  p_73, uint32_t  p_74, uint16_t  p_75);
static struct S0 * func_76(uint8_t  p_77, int32_t ** p_78, union U1  p_79);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 5L;
    int64_t l_34 = (-1L);
    int32_t *l_542 = &l_31;
    int32_t **l_541 = &l_542;
    float l_543 = 0xA.A857ABp+6;
    int16_t l_544 = 1L;
    for (l_31 = 0; (l_31 != (-10)); l_31--)
    { /* block id: 39 */
        int32_t l_36 = (-1L);
        int32_t *l_35 = &l_36;
        (*l_35) = l_34;
    }
    (*l_541) = func_37(l_34);
    /* statement id: 301 */
    assert (l_542 == 0);
    (*l_541) = (*l_541);
    return l_544;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_37(const uint16_t  p_38)
{ /* block id: 42 */
    int32_t *l_540 = (void*)0;
    int32_t **l_539 = &l_540;
    int32_t ***l_538 = &l_539;
    (*l_538) = func_39((1L && 2L));
    /* statement id: 299 */
    assert (l_539 == 0);
    return l_540;
    /* statement id: 300 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_39(int16_t  p_40)
{ /* block id: 43 */
    struct S0 l_41 = {-9L,20,18446744073709551615UL};
    struct S0 *l_42 = &l_41;
    int32_t l_82 = (-9L);
    int32_t *l_81 = &l_82;
    int32_t **l_80 = &l_81;
    union U1 l_83 = {-7L};
    union U2 l_239 = {0xB.070889p+48};
    int32_t **l_534 = &l_81;
    int32_t **l_535 = &l_81;
    int32_t **l_536 = &l_81;
    int32_t **l_537 = (void*)0;
    (*l_42) = l_41;
lbl_506:
    (*l_81) = (((float)func_45(func_51(func_57(func_62(func_68(func_70(l_41.f2, func_76((l_80 != &l_81), &l_81, l_83), p_40, ((+((void*)0 != (*l_80))) == 4294967295UL), p_40)), (*l_80), p_40, &l_81, p_40), p_40, l_41.f1, p_40), p_40, p_40, l_83.f2, l_239), l_239.f3, p_40, p_40, (*l_42)) + (float)0x8.1p-1) < p_40);
    for (p_40 = 0; (p_40 == 12); p_40 += 2)
    { /* block id: 254 */
        struct S0 l_500 = {0x8C0956980EBA00EALL,8,18446744073709551609UL};
        int32_t **l_507 = &l_81;
        int32_t ***l_528 = (void*)0;
        int32_t ****l_527 = &l_528;
        l_500 = (*l_42);
        for (l_41.f0 = (-26); (l_41.f0 == 28); l_41.f0 += 8)
        { /* block id: 258 */
            float l_503 = 0xB.A28A99p-54;
            struct S0 *l_509 = &l_500;
            int32_t **l_524 = &l_81;
            struct S0 l_533 = {0x303D2869FD2BC733LL,1,1UL};
            if (l_500.f2)
            { /* block id: 259 */
                int32_t **l_505 = (void*)0;
                if ((p_40 == (l_81 == (void*)0)))
                { /* block id: 260 */
                    int32_t **l_504 = &l_81;
                    (**l_80) = (((**l_80) || (**l_80)) < p_40);
                    return l_505;
                    /* statement id: 262 */
                    //assert (func_39_rv == 0);
                }
                else
                { /* block id: 263 */
                    if (p_40)
                        goto lbl_506;
                    if (((void*)0 != l_507))
                    { /* block id: 265 */
                        float *l_508 = &l_503;
                        (*l_508) = p_40;
                    }
                    else
                    { /* block id: 267 */
                        struct S0 **l_510 = &l_509;
                        int32_t l_511 = 0x4851CB3AL;
                        (*l_510) = l_509;
                        if (l_511)
                            break;
                    }
                }
                (*l_509) = (*l_42);
            }
            else
            { /* block id: 273 */
                int32_t **l_523 = &l_81;
                for (l_82 = (-6); (l_82 > 21); l_82++)
                { /* block id: 276 */
                    float l_520 = 0x1.6p+1;
                    int32_t **l_525 = (void*)0;
                    float *l_526 = &l_239.f0;
                    int32_t ****l_529 = (void*)0;
                    for (l_500.f0 = 17; (l_500.f0 < (-11)); --l_500.f0)
                    { /* block id: 279 */
                        int32_t *l_521 = (void*)0;
                        int32_t *l_522 = &l_83.f0;
                        (*l_80) = (*l_80);
                        if (p_40)
                            break;
                        (*l_522) = ((uint16_t)((int64_t)0x94970F5AB09884D2LL + (int64_t)0xED3BFB127619C6F2LL) << (uint16_t)(*l_81));
                        return l_525;
                        /* statement id: 283 */
                        //assert (func_39_rv == 0);
                    }
                    (*l_526) = 0x1.E3E17Fp+53;
                    l_529 = l_527;
                    /* statement id: 286 */
                    assert (l_529 == &l_528);
                }
                (*l_80) = (*l_523);
                for (l_500.f2 = 0; (l_500.f2 >= 2); l_500.f2 += 8)
                { /* block id: 291 */
                    struct S0 l_532 = {0x48E914F0B8E9D4F1LL,13,18446744073709551607UL};
                    l_533 = l_532;
                }
            }
        }
        (*l_80) = (*l_507);
    }
    return l_537;
    /* statement id: 298 */
    //assert (func_39_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_45(uint32_t  p_46, int16_t  p_47, uint32_t  p_48, const int16_t  p_49, struct S0  p_50)
{ /* block id: 231 */
    uint8_t l_491 = 4UL;
    uint64_t l_493 = 0xA1E64B3CA6587263LL;
    for (p_46 = 0; (p_46 != 12); p_46 += 2)
    { /* block id: 234 */
        int32_t l_478 = 0xB8BF441BL;
        const int32_t *l_477 = &l_478;
        union U2 **l_494 = (void*)0;
        union U2 l_497 = {0x1.C2F90Ap-70};
        union U2 *l_496 = &l_497;
        union U2 **l_495 = &l_496;
        for (p_48 = 4; (p_48 < 3); p_48--)
        { /* block id: 237 */
            int32_t *l_480 = (void*)0;
            int32_t **l_479 = &l_480;
            float l_484 = 0xF.C7291Dp+20;
            float *l_483 = &l_484;
            union U2 l_492 = {0x2.4B1F40p+22};
            (*l_479) = l_477;
            /* statement id: 238 */
            assert (l_480 == &l_478);
            (*l_483) = ((float)(*l_477) / (float)0x1.Fp-1);
            if (((int16_t)((((**l_479) <= (__builtin_ffsl((**l_479)) ^ (func_51(((int16_t)(18446744073709551615UL <= ((uint16_t)p_48 % (uint16_t)p_49)) / (int16_t)p_47), (l_477 == (void*)0), l_491, (*l_477), l_492) >= 18446744073709551614UL))) >= (*l_477)) || (**l_479)) >> (int16_t)l_493))
            { /* block id: 240 */
                (*l_479) = (void*)0;
                /* statement id: 241 */
                assert (l_480 == 0);
                return p_46;
            }
            else
            { /* block id: 243 */
                (*l_479) = (*l_479);
            }
        }
        (*l_495) = (void*)0;
        /* statement id: 247 */
        assert (l_496 == 0);
        return p_48;
    }
    return l_491;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_51(uint32_t  p_52, int64_t  p_53, uint8_t  p_54, int32_t  p_55, union U2  p_56)
{ /* block id: 110 */
    const uint16_t l_242 = 0x7D84L;
    union U1 l_248 = {-7L};
    const union U1 *l_247 = &l_248;
    int32_t *l_255 = (void*)0;
    int64_t l_285 = (-3L);
    int64_t l_376 = 1L;
    struct S0 l_391 = {0x9E3D29711FA60367LL,23,1UL};
    struct S0 * const l_390 = &l_391;
    union U1 *l_411 = &l_248;
    union U1 **l_410 = &l_411;
    union U1 ***l_409 = &l_410;
    union U1 ****l_408 = &l_409;
    union U2 l_416 = {0x6.0p+1};
    union U2 *l_415 = &l_416;
    union U2 **l_414 = &l_415;
    if ((((uint16_t)l_242 << (uint16_t)((((int64_t)p_53 + (int64_t)((int32_t)l_242 - (int32_t)((p_55 && ((l_242 > ((void*)0 == l_247)) | (((l_248.f2 != ((uint64_t)((((uint64_t)l_242 % (uint64_t)l_248.f2) | 0x73549B09EDA30AC0LL) & p_56.f4) % (uint64_t)l_242)) || l_248.f3) == 3UL))) < 0x4E8CL))) <= 0x09B46BF4L) || p_56.f3)) & l_248.f1))
    { /* block id: 111 */
        struct S0 l_254 = {1L,44,0x09DC6AD9L};
        struct S0 * const l_253 = &l_254;
        l_255 = func_68(l_253);
    }
    else
    { /* block id: 113 */
        int32_t *l_256 = &l_248.f0;
        int32_t l_262 = (-1L);
        int16_t l_286 = 0L;
        struct S0 l_295 = {0x24BE17463E53FBDCLL,11,2UL};
        struct S0 *l_294 = &l_295;
        uint8_t l_300 = 255UL;
        const union U1 ***l_306 = (void*)0;
        float *l_360 = (void*)0;
        float **l_359 = &l_360;
        int32_t *l_412 = &l_248.f0;
        if (((l_255 == l_256) & 0xCB1CL))
        { /* block id: 114 */
            float l_259 = 0xE.D913FAp-55;
            float *l_258 = &l_259;
            struct S0 * const l_260 = (void*)0;
            int32_t **l_261 = &l_255;
            (*l_258) = ((+p_55) == 0x1.DA6F62p-62);
            (*l_256) = p_56.f4;
            (*l_261) = func_68(l_260);
        }
        else
        { /* block id: 118 */
            float l_264 = 0x3.93C261p-87;
            float *l_263 = &l_264;
            int32_t l_275 = 7L;
            uint16_t l_292 = 65533UL;
            struct S0 l_298 = {2L,41,18446744073709551615UL};
            union U1 l_301 = {0x0C96EE17L};
            struct S0 *l_303 = (void*)0;
            uint32_t l_313 = 1UL;
            int32_t **l_320 = &l_255;
            uint16_t l_369 = 0xD187L;
            int32_t *l_399 = &l_275;
            (*l_263) = l_262;
            if (l_248.f2)
                goto lbl_308;
lbl_308:
            if ((((uint64_t)(p_56.f1 == (*l_256)) / (uint64_t)(((int16_t)(-(int32_t)p_56.f4) + (int16_t)(((int16_t)(p_53 < ((((uint16_t)(-(int64_t)p_56.f4) >> (uint16_t)p_56.f1) != p_53) != l_275)) >> (int16_t)((uint64_t)((uint64_t)(*l_256) / (uint64_t)p_53) % (uint64_t)(*l_256))) != l_275)) || p_56.f1)) || l_275))
            { /* block id: 120 */
                int32_t *l_280 = &l_275;
                struct S0 * const l_302 = &l_298;
                if (((0x1639L && func_57(func_62(&l_275, l_280, ((0xDD82FEA0L > __builtin_clz(p_55)) ^ (__builtin_ctz(p_54) > ((uint16_t)((uint16_t)l_275 >> (uint16_t)6) >> (uint16_t)p_54))), &l_255, l_275), p_55, l_285, p_55)) < 0UL))
                { /* block id: 121 */
                    if (__builtin_popcountl(p_56.f1))
                    { /* block id: 122 */
                        return l_286;
                    }
                    else
                    { /* block id: 124 */
                        int32_t **l_287 = &l_255;
                        (*l_287) = (void*)0;
                    }
                }
                else
                { /* block id: 127 */
                    uint32_t l_293 = 18446744073709551615UL;
                    int32_t *l_299 = &l_248.f0;
                    const union U1 **l_305 = &l_247;
                    const union U1 ***l_304 = &l_305;
                    if ((((__builtin_ffsll((*l_280)) > p_56.f1) != 0x0AC7L) <= ((uint16_t)(func_57(&l_280, ((&l_275 != l_256) < ((float)(*l_280) / (float)(*l_280))), p_56.f3, l_292) | l_293) << (uint16_t)3)))
                    { /* block id: 128 */
                        struct S0 **l_296 = &l_294;
                        (*l_296) = l_294;
                    }
                    else
                    { /* block id: 130 */
                        (*l_263) = p_56.f3;
                        if (l_293)
                            goto lbl_297;
lbl_297:
                        (*l_280) = p_56.f4;
                        (*l_294) = l_298;
                    }
                    l_303 = l_302;
                    /* statement id: 136 */
                    assert (l_303 == &l_298);
                    l_306 = l_304;
                    /* statement id: 137 */
                    assert (l_306 == &l_305);
                    return p_56.f2;
                }
            }
            else
            { /* block id: 140 */
                uint8_t l_307 = 1UL;
                return l_307;
            }
            if (((((((int32_t)(((int32_t)0xC6D6B7A5L + (int32_t)l_313) ^ ((((uint16_t)(*l_256) << (uint16_t)8) && (0xDD0621BFL & ((uint16_t)((uint32_t)(p_56.f3 > l_298.f1) - (uint32_t)func_57(l_320, p_56.f0, p_53, p_55)) / (uint16_t)0x1939L))) != 2L)) - (int32_t)(*l_256)) & p_56.f4) >= p_55) != 18446744073709551615UL) == 1L))
            { /* block id: 144 */
                const union U1 **l_326 = &l_247;
                const union U1 ***l_325 = &l_326;
                struct S0 l_331 = {0x2E575A53CB9E1FEDLL,43,0x57FE2178L};
                (*l_256) = ((int16_t)((uint16_t)(l_325 != (void*)0) >> (uint16_t)((p_54 && (((uint32_t)(0x00657D72F3A6FA7ALL || p_53) - (uint32_t)(*l_256)) >= 5UL)) == (((uint16_t)0x6112L >> (uint16_t)(*l_256)) >= 0xE89DL))) << (int16_t)5);
                if (l_313)
                    goto lbl_332;
lbl_332:
                (*l_294) = l_331;
                (*l_256) = p_56.f2;
                for (l_331.f0 = 22; (l_331.f0 != 27); l_331.f0 += 5)
                { /* block id: 151 */
                    union U1 **l_337 = (void*)0;
                    union U1 ***l_336 = &l_337;
                    union U1 ****l_335 = &l_336;
                    union U1 *****l_338 = &l_335;
                    (*l_294) = l_331;
                    (*l_338) = l_335;
                }
            }
            else
            { /* block id: 155 */
                union U1 *l_344 = &l_301;
                union U1 **l_351 = &l_344;
                const int32_t *l_356 = &l_275;
                int32_t **l_392 = &l_255;
                if (((uint64_t)(((p_56.f3 >= l_292) <= ((-10L) ^ ((uint64_t)(!(l_344 != &l_248)) + (uint64_t)(__builtin_clzll(((((int16_t)0x06D2L >> (int16_t)12) != 4294967295UL) > (-5L))) <= 4294967288UL)))) == p_56.f2) + (uint64_t)p_53))
                { /* block id: 156 */
                    for (l_248.f4 = 0; (l_248.f4 != 17); l_248.f4++)
                    { /* block id: 159 */
                        union U1 ** const l_349 = &l_344;
                        union U1 ***l_350 = (void*)0;
                        l_351 = l_349;
                    }
                    /* facts after for loop */
                                        (*l_320) = (*l_320);
                    for (l_295.f2 = (-3); (l_295.f2 < 35); l_295.f2 += 1)
                    { /* block id: 165 */
                        (*l_320) = l_255;
                    }
                    (*l_256) = 0x0A924ABBL;
                    /* statement id: 168 */
                                    }
                else
                { /* block id: 169 */
                    struct S0 *l_355 = &l_298;
                    float **l_358 = (void*)0;
                    if ((1L <= p_53))
                    { /* block id: 170 */
                        struct S0 *l_354 = &l_295;
                        l_355 = l_354;
                        /* statement id: 171 */
                        assert (l_355 == &l_295);
                    }
                    else
                    { /* block id: 172 */
                        int32_t **l_357 = &l_255;
                        (*l_357) = l_356;
                        /* statement id: 173 */
                        assert (l_255 == &l_275);
                        (*l_263) = p_56.f4;
                    }
                    /* facts after branching */
                    assert (l_255 == &l_275 || l_255 == 0);
                    assert (l_355 == &l_298 || l_355 == &l_295);
                    l_359 = l_358;
                    /* statement id: 176 */
                    assert (l_359 == 0);
                }
                /* facts after branching */
                assert (l_255 == &l_275 || l_255 == 0);
                assert (l_359 == 0 || l_359 == &l_360);
                p_56.f0 = ((p_56.f4 >= 0x7.3217EFp+84) >= (((((((float)p_56.f2 / (float)p_56.f4) >= (*l_356)) < ((float)((float)l_248.f2 / (float)((float)((((0x1.2p-1 > ((void*)0 == l_356)) < 0x1.941149p-42) < (-0x2.5p+1)) <= l_369) - (float)p_55)) / (float)p_52)) >= 0x1.6p+1) <= p_55) == p_55));
                if (p_52)
                { /* block id: 179 */
                    int32_t l_385 = 0xAD2E39DCL;
                    int32_t **l_386 = &l_256;
                    for (p_55 = 7; (p_55 <= 26); p_55 += 1)
                    { /* block id: 182 */
                        int32_t ***l_372 = &l_320;
                        struct S0 * const l_373 = &l_295;
                        int32_t **l_374 = (void*)0;
                        int32_t **l_375 = &l_255;
                        (*l_372) = &l_255;
                        (*l_375) = func_68(l_373);
                        /* statement id: 184 */
                        assert (l_255 == 0);
                        l_356 = l_360;
                        /* statement id: 185 */
                        assert (l_356 == 0);
                        return l_376;
                    }
                    if (l_376)
                        goto lbl_387;
lbl_387:
                    (*l_386) = func_68(func_70((*l_356), &l_298, (((uint64_t)(__builtin_parityll((*l_356)) && ((int16_t)func_57(l_320, p_54, ((float)(0x9.2D7D5Ep+57 > ((float)p_56.f3 / (float)p_52)) + (float)l_385), (*l_256)) << (int16_t)p_53)) / (uint64_t)(*l_256)) && 0xDEA7871DL), (*l_356), p_56.f1));
                    /* statement id: 188 */
                    assert (l_256 == 0);
                    (*l_263) = (-0x2.5p-1);
                    (*l_386) = l_256;
                }
                else
                { /* block id: 192 */
                    struct S0 * const l_388 = &l_298;
                    int32_t **l_389 = &l_255;
                    (*l_389) = func_68(l_388);
                    /* statement id: 193 */
                    assert (l_255 == 0);
                }
                /* facts after branching */
                assert (l_256 == &l_248.f0 || l_256 == 0);
                (*l_392) = func_68(l_390);
                /* statement id: 195 */
                assert (l_255 == 0);
            }
            /* facts after branching */
            assert (l_256 == &l_248.f0 || l_256 == 0);
            assert (l_359 == 0 || l_359 == &l_360);
            (*l_399) = (p_54 ^ ((int64_t)(((int16_t)(((p_53 != __builtin_ffs(p_52)) == ((int16_t)((&l_255 == &l_256) >= l_301.f2) % (int16_t)p_52)) < func_57(l_320, p_54, p_52, l_301.f3)) << (int16_t)p_56.f3) > p_56.f1) / (int64_t)p_56.f4));
        }
        /* facts after branching */
        assert (l_256 == &l_248.f0 || l_256 == 0);
        assert (l_359 == 0 || l_359 == &l_360);
        (*l_412) = ((uint16_t)((int16_t)(18446744073709551615UL || (p_56.f3 <= ((int16_t)(l_408 == &l_409) >> (int16_t)3))) << (int16_t)10) >> (uint16_t)11);
    }
    if (__builtin_parityl(p_56.f4))
    { /* block id: 201 */
        uint8_t l_413 = 255UL;
        int32_t l_429 = 0L;
        int32_t * const l_432 = &l_248.f0;
        int32_t **l_433 = &l_255;
        if ((l_413 | ((void*)0 != l_414)))
        { /* block id: 202 */
            (*l_414) = (*l_414);
            return p_56.f4;
        }
        else
        { /* block id: 205 */
            int32_t *l_417 = &l_248.f0;
            l_417 = (void*)0;
            /* statement id: 206 */
            assert (l_417 == 0);
        }
        for (l_248.f4 = 0; (l_248.f4 >= 43); l_248.f4 += 1)
        { /* block id: 210 */
            uint32_t l_420 = 0x07FD64A6L;
            int32_t *l_421 = (void*)0;
            int32_t l_423 = 0L;
            int32_t *l_422 = &l_423;
            struct S0 l_424 = {0xAE2EA2ED9D6BEC82LL,1,3UL};
            (*l_422) = (l_413 >= l_420);
            (*l_390) = l_424;
        }
        /* facts after for loop */
                (*l_432) = ((int64_t)((uint16_t)__builtin_popcountll(l_429) + (uint16_t)((uint16_t)((((p_56.f4 >= func_57(&l_255, p_55, p_56.f4, p_56.f2)) && p_55) >= p_55) == (*l_432)) << (uint16_t)0)) + (int64_t)8L);
        /* statement id: 214 */
            }
    else
    { /* block id: 215 */
        int32_t l_440 = 1L;
        int32_t **l_463 = (void*)0;
        const uint32_t l_469 = 0xACB93F0EL;
        if (p_53)
        { /* block id: 216 */
            int32_t **l_436 = (void*)0;
            const struct S0 l_458 = {0L,15,0xC13D9357L};
            for (l_416.f2 = (-17); (l_416.f2 >= 27); l_416.f2++)
            { /* block id: 219 */
                int32_t *l_446 = &l_248.f0;
                (*l_446) = func_57(l_436, ((float)(!0x8.84D267p-98) - (float)(l_440 != ((!((float)((float)(l_446 != (void*)0) / (float)((float)((float)l_440 / (float)p_56.f0) / (float)((float)(*l_446) / (float)((float)((+((float)p_56.f1 / (float)p_56.f2)) > 0x2.9BEBC3p-84) / (float)0x0.Cp+1)))) + (float)(*l_446))) != p_52))), p_53, p_55);
                (*l_410) = (*l_410);
                (*l_390) = l_458;
            }
            /* facts after for loop */
                    }
        else
        { /* block id: 224 */
            uint32_t l_464 = 0UL;
            int32_t l_470 = 0x5E980E34L;
            float *l_471 = &l_416.f0;
            int32_t l_472 = 1L;
            (*l_414) = &p_56;
            /* statement id: 225 */
            assert (l_415 == &p_56);
            (*l_471) = (((float)((float)func_57(l_463, l_464, ((float)p_52 / (float)((float)(p_56.f2 == (p_56.f4 == l_469)) / (float)p_54)), l_470) / (float)(-0x10.Fp+1)) + (float)0x3.0p-1) < 0x2.0402DFp+66);
            return l_472;
        }
        /* facts after branching */
            }
    /* facts after branching */
        return p_56.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_57(int32_t ** p_58, float  p_59, float  p_60, uint64_t  p_61)
{ /* block id: 104 */
    int32_t l_212 = 0L;
    float l_234 = 0x0.2p-1;
    float *l_233 = &l_234;
    union U1 l_236 = {0xCA15E865L};
    union U1 *l_235 = &l_236;
    const union U1 *l_238 = (void*)0;
    const union U1 **l_237 = &l_238;
    l_212 = (((float)l_212 / (float)(p_59 <= (+(((float)l_212 / (float)p_60) >= ((float)(-0x1.0p+1) / (float)((float)p_60 / (float)(__builtin_bswap32(p_61) <= p_59))))))) != p_61);
    (*l_233) = ((float)(0x0.8D72E1p+29 != (((float)(0x1.Ep+1 < l_212) / (float)p_59) < ((float)l_212 + (float)((float)l_212 + (float)l_212)))) + (float)((float)((((float)p_60 / (float)(+(l_212 != p_60))) != 0xF.27325Ep-95) == p_59) / (float)l_212));
    (*l_237) = l_235;
    /* statement id: 107 */
    assert (l_238 == &l_236);
    l_212 = (0x0F2BL && l_236.f1);
    return l_212;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_62(int32_t * const  p_63, int32_t * p_64, int32_t  p_65, int32_t ** p_66, uint16_t  p_67)
{ /* block id: 100 */
    float l_203 = 0x5.Fp+1;
    float *l_202 = &l_203;
    int32_t l_204 = 0xD9D43CF3L;
    int32_t *l_206 = &l_204;
    int32_t **l_205 = &l_206;
    int32_t **l_207 = &l_206;
    int32_t **l_208 = &l_206;
    int32_t **l_209 = (void*)0;
    (*l_202) = p_67;
    (*p_64) = l_204;
    return l_209;
    /* statement id: 103 */
    //assert (func_62_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_68(struct S0 * const  p_69)
{ /* block id: 94 */
    int32_t l_178 = 9L;
    int32_t l_192 = 0x939AD6F1L;
    int32_t *l_191 = &l_192;
    int32_t l_193 = (-3L);
    union U2 l_195 = {0xE.FFDA28p-78};
    union U2 *l_194 = &l_195;
    union U2 **l_196 = &l_194;
    int32_t * const l_197 = &l_192;
    int32_t * const l_198 = &l_192;
    int32_t * const l_199 = &l_192;
    int32_t * const l_200 = &l_192;
    int32_t * const l_201 = (void*)0;
    (*l_191) = ((-(int64_t)(((int16_t)0L >> (int16_t)6) == (l_178 < l_178))) != ((((-1L) > (l_178 != (((int16_t)(((uint16_t)(l_178 && 0L) >> (uint16_t)((+((uint32_t)l_178 - (uint32_t)((!(((uint16_t)(l_178 ^ 0x844EL) % (uint16_t)l_178) ^ l_178)) >= l_178))) && l_178)) == 3L) << (int16_t)l_178) < l_178))) != l_178) != 0x0EBFL));
    (*l_191) = ((*l_191) < l_193);
    (*l_196) = l_194;
    l_196 = &l_194;
    return l_201;
    /* statement id: 99 */
    //assert (func_68_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * const  func_70(uint32_t  p_71, struct S0 * p_72, uint64_t  p_73, uint32_t  p_74, uint16_t  p_75)
{ /* block id: 48 */
    const uint64_t l_91 = 0x347A64A0F0C0ED6DLL;
    int32_t l_98 = 0xFE378062L;
    int32_t * const l_97 = &l_98;
    int32_t * const *l_96 = &l_97;
    int32_t *l_160 = &l_98;
    union U2 l_165 = {-0x8.Bp+1};
    union U2 *l_164 = &l_165;
    struct S0 * const l_169 = (void*)0;
    if (((int16_t)(l_91 && p_75) << (int16_t)(((int32_t)(-3L) / (int32_t)p_71) != ((((1UL | ((-1L) | ((int32_t)((0xE4446CA3L && ((void*)0 != l_96)) == p_73) + (int32_t)p_73))) != 0x6E03L) > p_74) & (**l_96)))))
    { /* block id: 49 */
        float l_104 = 0x2.3p-1;
        float *l_103 = &l_104;
        (**l_96) = ((int16_t)(**l_96) >> (int16_t)4);
        (*l_103) = ((float)((void*)0 != p_72) + (float)(-0x1.0p+1));
    }
    else
    { /* block id: 52 */
        uint8_t l_109 = 1UL;
        int32_t l_110 = 0L;
        int32_t **l_124 = (void*)0;
        struct S0 l_156 = {0x2B5FF26AE3508C96LL,16,0UL};
        union U2 l_162 = {-0x6.5p-1};
        union U2 *l_161 = &l_162;
        int32_t **l_174 = &l_160;
lbl_136:
        l_110 = ((int16_t)(-1L) + (int16_t)((uint64_t)l_109 + (uint64_t)(-1L)));
lbl_173:
        for (p_74 = (-13); (p_74 >= 10); p_74 += 6)
        { /* block id: 56 */
            uint8_t l_115 = 0UL;
            int32_t *l_130 = (void*)0;
            int32_t **l_172 = &l_160;
            if (l_110)
            { /* block id: 57 */
                uint8_t l_114 = 255UL;
                if (p_73)
                    break;
                l_115 = (p_75 >= (-(float)l_114));
            }
            else
            { /* block id: 60 */
                const uint8_t l_131 = 0xBDL;
                float l_133 = 0x1.Ap-1;
                float *l_132 = &l_133;
                (*l_132) = (((float)(((float)(l_109 <= 0x7.F7CC82p-43) - (float)(__builtin_popcountll(((((uint64_t)((0x29AFL == ((int16_t)p_73 << (int16_t)3)) == (l_124 != l_124)) + (uint64_t)((p_74 && p_71) == ((((uint64_t)(+(((int16_t)((*l_96) != l_130) >> (int16_t)5) > 0x70D6E0D24876030DLL)) / (uint64_t)0x2C54351128280810LL) | p_73) & 0xEB51L))) < l_131) >= l_109)) == l_131)) < p_73) + (float)p_73) != 0x4.Bp+1);
                if (p_71)
                    break;
                if (l_131)
                { /* block id: 63 */
                    const int32_t *l_135 = &l_110;
                    const int32_t **l_134 = &l_135;
                    (*l_134) = l_132;
                    /* statement id: 64 */
                    assert (l_135 == &l_133);
                    if (p_75)
                        goto lbl_173;
                    return p_72;
                    /* statement id: 65 */
                    //assert (func_70_rv == 0 || func_70_rv == &l_298);
                }
                else
                { /* block id: 66 */
                    int32_t **l_141 = &l_130;
                    struct S0 l_154 = {-10L,36,0x51F222DEL};
                    struct S0 *l_155 = (void*)0;
                    if (p_71)
                        goto lbl_136;
                    (**l_96) = 0xDE593F29L;
                    (**l_96) = ((p_71 ^ p_75) < (((((int64_t)((uint64_t)((void*)0 != l_141) % (uint64_t)p_75) % (int64_t)((int16_t)((int16_t)((uint16_t)p_74 << (uint16_t)((uint64_t)(((uint16_t)p_74 / (uint16_t)0xAFA2L) > __builtin_ia32_crc32qi(__builtin_ctzll((((int64_t)p_74 / (int64_t)p_73) && p_75)), (*l_97))) - (uint64_t)p_75)) / (int16_t)1UL) % (int16_t)l_131)) || p_75) & (**l_96)) & l_131));
                    l_156 = l_154;
                }
                (*l_132) = ((void*)0 == l_132);
            }
            for (l_110 = 16; (l_110 == 16); ++l_110)
            { /* block id: 76 */
                int32_t *l_159 = &l_98;
                const union U2 **l_163 = (void*)0;
                l_160 = l_159;
                /* statement id: 77 */
                assert (l_160 == &l_98);
                l_164 = l_161;
                /* statement id: 78 */
                assert (l_164 == &l_162);
                for (l_115 = 17; (l_115 >= 37); l_115++)
                { /* block id: 81 */
                    int32_t *l_168 = &l_98;
                    struct S0 *l_171 = &l_156;
                    struct S0 **l_170 = &l_171;
                    l_159 = l_168;
                    (*l_170) = l_169;
                    /* statement id: 83 */
                    assert (l_171 == 0);
                    return p_72;
                    /* statement id: 84 */
                    //assert (func_70_rv == 0 || func_70_rv == &l_298);
                }
            }
            (*l_172) = l_130;
            /* statement id: 87 */
            assert (l_160 == 0);
        }
        (*l_174) = (*l_96);
        /* statement id: 90 */
        assert (l_160 == &l_98);
        return l_169;
        /* statement id: 91 */
        //assert (func_70_rv == 0);
    }
    return p_72;
    /* statement id: 93 */
    //assert (func_70_rv == 0 || func_70_rv == &l_298);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_76(uint8_t  p_77, int32_t ** p_78, union U1  p_79)
{ /* block id: 45 */
    struct S0 l_85 = {1L,11,3UL};
    struct S0 *l_84 = &l_85;
    struct S0 *l_86 = &l_85;
    struct S0 *l_87 = (void*)0;
    (**p_78) = 0xC5F6B4ABL;
    return l_87;
    /* statement id: 47 */
    //assert (func_76_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 126
   depth: 1, occurrence: 10
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 18
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 20
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 10

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 198
   depth: 2, occurrence: 35
   depth: 3, occurrence: 8
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 152

XXX times a variable address is taken: 127
XXX times a pointer is dereferenced on RHS: 49
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 8
XXX times a pointer is dereferenced on LHS: 75
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 203

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 183
   level: 2, occurrence: 52
   level: 3, occurrence: 2
XXX number of pointers point to pointers: 72
XXX number of pointers point to scalars: 48
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 32.2
XXX average alias set size: 1.2

XXX times a non-volatile is read: 495
XXX times a non-volatile is write: 193
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 5
XXX backward jumps: 2

XXX stmts: 167
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 20
   depth: 2, occurrence: 24
   depth: 3, occurrence: 31
   depth: 4, occurrence: 37
   depth: 5, occurrence: 23

XXX percentage a fresh-made variable is used: 16.9
XXX percentage an existing variable is used: 83.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

