/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      729756192
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   float  f0;
   uint32_t  f1;
   signed f2 : 17;
   float  f3;
   uint32_t  f4;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 27;
   unsigned f1 : 22;
   uint32_t  f2;
   signed f3 : 22;
   const signed f4 : 27;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S2 {
   const signed f0 : 26;
   const signed f1 : 11;
   uint16_t  f2;
   unsigned : 0;
   const signed f3 : 21;
};
#pragma pack(pop)

union U3 {
   uint32_t  f0;
   uint16_t  f1;
};

union U4 {
   signed f0 : 23;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const struct S1  func_33(void);
static int32_t * func_37(float  p_38, int32_t * p_39, union U3  p_40);
static int32_t * func_42(int32_t * p_43, union U4  p_44, float  p_45, int32_t * const  p_46);
inline static int32_t * func_47(const int32_t  p_48, int32_t  p_49, struct S1  p_50);
inline static int32_t ** func_57(int32_t * p_58, uint32_t  p_59, int32_t * const  p_60);
static uint16_t  func_63(const struct S0  p_64, const union U3  p_65, struct S2  p_66);
inline static const union U3  func_68(uint32_t  p_69);
static struct S2  func_75(int32_t * const  p_76);
static int32_t  func_83(const uint32_t  p_84, uint32_t  p_85, union U3  p_86, struct S0 ** p_87, int32_t ** p_88);
inline static uint16_t  func_100(struct S0 ** const  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S1  func_33(void)
{ /* block id: 36 */
    int32_t l_34 = 0xCC7C44D9;
    struct S1 l_51 = {-1440,368,0xF4D0C653,-1405,8328};
    union U4 l_472 = {-1};
    union U3 l_473 = {0xCD50D945};
    struct S0 **l_474 = (void*)0;
    int32_t *l_476 = &l_34;
    int32_t **l_475 = &l_476;
    for (l_34 = 4; (l_34 >= 22); l_34 += 4)
    { /* block id: 39 */
        int32_t *l_41 = &l_34;
        int32_t l_497 = 0xD8C914E6;
        int32_t *l_498 = &l_497;
        struct S0 l_499 = {0x1.3p-1,0xAAD0BF71,359,-0x1.Ap-1,4294967295U};
        (*l_475) = func_37((l_41 != l_41), func_42(func_47((&l_34 != l_41), (*l_41), l_51), l_472, func_83(l_472.f0, (*l_41), l_473, l_474, l_475), (*l_475)), l_473);
        /* statement id: 320 */
        assert (l_476 == 0);
        l_497 = (__builtin_ctz(l_473.f0) | (*l_41));
        (*l_498) = (*l_41);
        l_499 = l_499;
    }
    /* facts after for loop */
    assert (l_476 == 0 || l_476 == &l_34);
    return l_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_37(float  p_38, int32_t * p_39, union U3  p_40)
{ /* block id: 303 */
    union U3 **l_477 = (void*)0;
    int32_t l_478 = 0xE1006443;
    struct S0 l_479 = {0x7.9D9594p+27,5U,202,0x3.D61B4Ep+38,4294967295U};
    int32_t *l_495 = &l_478;
    int32_t **l_494 = &l_495;
    int32_t ***l_493 = &l_494;
    if (((l_477 == l_477) < l_478))
    { /* block id: 304 */
        struct S0 *l_480 = &l_479;
        struct S1 l_488 = {-11367,449,0U,635,5746};
        struct S1 *l_487 = &l_488;
        struct S1 **l_486 = &l_487;
        float *l_496 = &l_479.f0;
        (*l_480) = l_479;
        if (func_100(&l_480))
        { /* block id: 306 */
            float *l_481 = (void*)0;
            float *l_482 = &l_479.f3;
            struct S0 *l_483 = &l_479;
            struct S0 **l_484 = &l_483;
            (*l_482) = __builtin_parity(p_40.f0);
            (*l_484) = l_483;
        }
        else
        { /* block id: 309 */
            struct S0 l_485 = {0x6.340A8Ep-80,1U,37,-0x1.Bp-1,0xB5A17DCD};
            struct S1 **l_489 = &l_487;
            float *l_492 = &l_485.f0;
            (*l_480) = l_485;
            (*l_492) = (p_40.f1 != (l_479.f1 < (((l_486 != l_489) < ((float)l_488.f4 + (float)((void*)0 == p_39))) > (p_40.f1 == 0x9.B4998Ap-0))));
            (*l_492) = l_479.f1;
        }
        (*l_496) = (l_488.f1 < (((l_488.f0 != ((void*)0 != l_493)) != (***l_493)) == ((void*)0 != &l_477)));
    }
    else
    { /* block id: 315 */
        (**l_494) = p_40.f0;
        (**l_493) = (void*)0;
        /* statement id: 317 */
        assert (l_495 == 0);
    }
    /* facts after branching */
    assert (l_495 == 0 || l_495 == &l_478);
    return p_39;
    /* statement id: 319 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_42(int32_t * p_43, union U4  p_44, float  p_45, int32_t * const  p_46)
{ /* block id: 301 */
    return p_43;
    /* statement id: 302 */
    //assert (func_42_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_47(const int32_t  p_48, int32_t  p_49, struct S1  p_50)
{ /* block id: 40 */
    uint32_t l_353 = 4294967295U;
    int32_t l_364 = 0xC8294B83;
    struct S0 l_383 = {0x3.92B0D4p+13,0x65C0EDC9,197,0x9.2p+1,0x8FEC65BD};
    struct S0 **l_396 = (void*)0;
    union U3 l_407 = {4294967295U};
    union U3 *l_406 = &l_407;
    union U3 **l_412 = &l_406;
    union U3 ***l_411 = &l_412;
    union U3 *** const *l_410 = &l_411;
    int32_t *l_419 = &l_364;
    int32_t **l_418 = &l_419;
    const struct S0 **l_427 = (void*)0;
    const struct S0 ***l_426 = &l_427;
    const struct S0 ****l_425 = &l_426;
    const struct S0 *****l_424 = &l_425;
    union U3 ** const *l_444 = (void*)0;
    union U3 ** const **l_443 = &l_444;
    struct S1 l_455 = {-5389,319,2U,-1435,-7622};
    struct S1 *l_454 = &l_455;
    struct S0 l_456 = {0xA.4F0AF4p-30,4294967286U,-211,-0x1.7p-1,0x68A0E271};
    struct S0 *l_457 = &l_456;
    int32_t *l_458 = &l_364;
    int32_t *l_459 = &l_364;
    int32_t *l_460 = &l_364;
    int32_t *l_461 = &l_364;
    int32_t *l_462 = &l_364;
    int32_t *l_463 = &l_364;
    int32_t *l_464 = &l_364;
    int32_t *l_465 = &l_364;
    int32_t *l_466 = &l_364;
    int32_t *l_467 = &l_364;
    int32_t *l_468 = &l_364;
    int32_t *l_469 = &l_364;
    int32_t *l_470 = &l_364;
    int32_t *l_471 = (void*)0;
    if (p_50.f0)
    { /* block id: 41 */
        struct S0 l_262 = {0x0.Fp+1,0x9C3501AD,74,0x1.1p+1,0U};
        struct S0 *l_261 = &l_262;
        struct S1 **l_360 = (void*)0;
        int32_t *l_379 = &l_364;
        int32_t *l_385 = (void*)0;
        union U3 l_395 = {4294967287U};
        const struct S0 ****l_423 = (void*)0;
        const struct S0 ***** const l_422 = &l_423;
        if (p_50.f2)
        { /* block id: 42 */
            int32_t *l_52 = (void*)0;
            struct S1 l_373 = {-7668,122,4294967295U,-619,6996};
            struct S1 *l_372 = &l_373;
            int32_t *l_382 = (void*)0;
            int32_t **l_397 = &l_382;
            float *l_398 = &l_383.f3;
            int32_t l_405 = (-1);
            union U3 *l_408 = &l_395;
            if (((void*)0 == &p_49))
            { /* block id: 43 */
                return l_52;
                /* statement id: 44 */
                //assert (func_47_rv == 0);
            }
            else
            { /* block id: 45 */
                uint32_t l_53 = 6U;
                int32_t l_62 = 0x2FAFECEB;
                int32_t *l_61 = &l_62;
                struct S0 *** const *l_352 = (void*)0;
                struct S0 *** const ** const l_351 = &l_352;
                if (l_53)
                { /* block id: 46 */
                    const struct S0 l_67 = {0x1.8p+1,0x8E7E64BF,-74,0x1.7p-1,0x4A0F0C0E};
                    for (p_50.f2 = 0; (p_50.f2 < 47); p_50.f2++)
                    { /* block id: 49 */
                        int32_t **l_56 = &l_52;
                        int32_t ***l_350 = &l_56;
                        (*l_56) = &p_49;
                        /* statement id: 50 */
                        assert (l_52 == &p_49);
                        (*l_350) = func_57(l_61, (func_63(l_67, func_68(p_50.f0), func_75(&l_62)) == (((void*)0 != l_261) <= (**l_56))), (*l_56));
                        /* statement id: 221 */
                        assert (l_56 == 0);
                        (*l_52) = ((void*)0 == l_351);
                        if (l_353)
                            continue;
                    }
                    /* facts after for loop */
                    assert (l_52 == &p_49 || l_52 == 0);
                }
                else
                { /* block id: 225 */
                    int32_t **l_354 = (void*)0;
                    int32_t *l_355 = &l_62;
                    l_355 = &p_49;
                    /* statement id: 226 */
                    assert (l_355 == &p_49);
                    return l_52;
                    /* statement id: 227 */
                    //assert (func_47_rv == 0);
                }
                /* facts after branching */
                assert (l_52 == &p_49 || l_52 == 0);
                for (l_262.f1 = 0; (l_262.f1 <= 15); l_262.f1++)
                { /* block id: 231 */
                    struct S0 ** const l_368 = &l_261;
                    struct S0 ** const *l_367 = &l_368;
                    struct S1 *l_374 = (void*)0;
                    int32_t l_375 = (-9);
                    int32_t *l_381 = &l_62;
                    for (l_53 = 5; (l_53 == 8); l_53 += 3)
                    { /* block id: 234 */
                        const struct S1 l_363 = {-9468,1010,4294967295U,1413,-5113};
                        const struct S1 *l_362 = &l_363;
                        const struct S1 * const *l_361 = &l_362;
                        l_364 = (l_360 != l_361);
                        if (p_50.f3)
                            break;
                    }
                    if (((int16_t)((void*)0 != l_367) + (int16_t)(p_50.f0 > (&l_261 == (*l_367)))))
                    { /* block id: 238 */
                        int32_t *l_380 = &l_375;
                        (*l_61) = (((int32_t)((!((l_372 != l_374) ^ 8)) && (((l_375 >= (p_50.f4 == (((uint16_t)l_353 << (uint16_t)((+0x530D) != (l_262.f1 || 0))) | p_49))) == (-1)) || l_375)) % (int32_t)(-1)) < 0x8C89F135);
                        return l_382;
                        /* statement id: 240 */
                        //assert (func_47_rv == 0);
                    }
                    else
                    { /* block id: 241 */
                        struct S0 *l_384 = &l_383;
                        l_381 = &l_375;
                        /* statement id: 242 */
                        assert (l_381 == &l_375);
                        (*l_384) = l_383;
                        if ((*l_381))
                            break;
                    }
                    /* facts after branching */
                    assert (l_381 == &l_375);
                    if (p_48)
                        break;
                    return l_385;
                    /* statement id: 247 */
                    //assert (func_47_rv == 0);
                }
            }
            /* facts after branching */
            assert (l_52 == &p_49 || l_52 == 0);
            (*l_398) = (+(p_49 >= (((float)(l_353 != (!__builtin_ia32_crc32qi((((uint32_t)((((((int16_t)((-(uint32_t)(p_50.f2 | 1U)) | p_50.f3) % (int16_t)__builtin_ffsl((func_83(((void*)0 != &l_261), p_50.f4, l_395, l_396, l_397) && 4294967294U))) || (*l_379)) | p_49) > l_383.f4) > p_50.f1) - (uint32_t)4294967291U) ^ p_50.f1), l_383.f1))) - (float)p_50.f3) != l_353)));
            for (l_373.f2 = 0; (l_373.f2 != 59); l_373.f2++)
            { /* block id: 253 */
                if (((int16_t)((int16_t)p_50.f4 >> (int16_t)p_50.f2) << (int16_t)9))
                { /* block id: 254 */
                    if (p_50.f0)
                        break;
                    if (p_48)
                        continue;
                }
                else
                { /* block id: 257 */
                    (*l_261) = (*l_261);
                    l_405 = (p_49 | (0xD898C33F > l_353));
                }
                l_408 = l_406;
                /* statement id: 261 */
                assert (l_408 == &l_407);
            }
            /* facts after for loop */
            assert (l_408 == &l_407 || l_408 == &l_395);
        }
        else
        { /* block id: 263 */
            int32_t l_409 = 0x3133CE66;
            const union U3 *l_413 = &l_407;
            float *l_420 = (void*)0;
            float *l_421 = &l_383.f3;
            (*l_379) = l_409;
            (*l_421) = ((((void*)0 != l_410) < ((void*)0 != l_413)) >= (((__builtin_clzll((func_83(((__builtin_ia32_crc32qi(l_409, (((int32_t)p_48 + (int32_t)(0x4D61 <= p_50.f0)) < ((int16_t)(p_48 | p_50.f1) << (int16_t)2))) < p_50.f1) || p_50.f3), (*l_379), l_395, &l_261, l_418) >= 1U)) <= 0x0.A3B0ECp+36) <= (*l_379)) >= p_50.f1));
            l_424 = l_422;
            /* statement id: 266 */
            assert (l_424 == &l_423);
        }
        /* facts after branching */
        assert (l_424 == &l_423 || l_424 == &l_425);
    }
    else
    { /* block id: 268 */
        struct S2 l_429 = {-2479,27,1U,-1332};
        struct S2 *l_428 = &l_429;
        struct S2 **l_430 = &l_428;
        int32_t *l_431 = &l_364;
        (*l_430) = l_428;
        (*l_418) = l_431;
        for (l_407.f0 = (-5); (l_407.f0 == 56); ++l_407.f0)
        { /* block id: 273 */
            struct S0 l_434 = {-0x9.7p-1,8U,39,0xE.50084Bp-27,0xA4851CB3};
            int32_t *l_435 = &l_364;
            l_434 = l_434;
            l_435 = &p_49;
            /* statement id: 275 */
            assert (l_435 == &p_49);
            if (p_50.f2)
                goto lbl_453;
            if ((*l_419))
                continue;
        }
    }
    /* facts after branching */
    //assert (l_424 == dangling || l_424 == &l_425);
lbl_453:
    for (l_383.f4 = 0; (l_383.f4 >= 49); l_383.f4++)
    { /* block id: 281 */
        struct S0 l_440 = {0x7.3BFB12p+1,6U,78,0xE.274E30p-61,1U};
        for (l_407.f0 = 0; (l_407.f0 < 11); l_407.f0 += 7)
        { /* block id: 284 */
            struct S0 *l_441 = &l_440;
            int32_t ***l_442 = &l_418;
            union U3 *l_445 = (void*)0;
            float *l_446 = &l_383.f0;
            (*l_441) = l_440;
            if (l_440.f2)
                break;
            (*l_446) = ((&l_418 == l_442) > ((***l_442) > ((((void*)0 == l_443) >= (0x8.1777C7p+78 == (**l_418))) == ((void*)0 != l_445))));
        }
        (*l_426) = (*l_426);
        for (l_440.f4 = 25; (l_440.f4 > 58); l_440.f4 += 1)
        { /* block id: 292 */
            struct S0 *l_449 = &l_383;
            struct S0 *l_450 = (void*)0;
            struct S0 l_452 = {-0x8.9p-1,0x44387E8C,41,0x8.746F68p-95,0xC9B1D3D9};
            struct S0 *l_451 = &l_452;
            l_449 = l_449;
            (*l_451) = (*l_449);
        }
    }
    l_454 = &p_50;
    /* statement id: 298 */
    assert (l_454 == &p_50);
    (*l_457) = l_456;
    return l_471;
    /* statement id: 300 */
    //assert (func_47_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_57(int32_t * p_58, uint32_t  p_59, int32_t * const  p_60)
{ /* block id: 168 */
    struct S0 l_275 = {0xD.7A56D6p+25,0x1467E5DD,26,-0x5.8p-1,0U};
    struct S0 *l_274 = &l_275;
    struct S0 ** const l_273 = &l_274;
    const struct S0 l_278 = {-0x10.Ep+1,4294967295U,-133,0x2.3p+1,4294967295U};
    struct S2 l_279 = {-4148,27,65535U,894};
    int32_t l_281 = 0x0E696E2D;
    int32_t *l_280 = &l_281;
    struct S0 **l_344 = &l_274;
    struct S0 ***l_343 = &l_344;
    struct S0 ****l_342 = &l_343;
    struct S0 *****l_341 = &l_342;
    struct S0 *l_345 = (void*)0;
    struct S0 *l_346 = &l_275;
    int32_t **l_347 = &l_280;
    int32_t **l_348 = &l_280;
    int32_t **l_349 = (void*)0;
    if ((((((((int16_t)((0x7E94F4A1 | ((p_59 & ((int16_t)((uint16_t)((uint16_t)__builtin_popcountll(((int32_t)(*p_60) % (int32_t)func_100(l_273))) + (uint16_t)((((uint16_t)0x8AB4 >> (uint16_t)func_63(l_278, func_68((4U >= l_278.f2)), l_279)) && l_279.f1) < p_59)) - (uint16_t)l_278.f4) - (int16_t)p_59)) > 0x610234A5)) < l_278.f2) << (int16_t)l_279.f2) >= (*p_60)) && 1U) & l_279.f2) > p_59) > l_279.f1))
    { /* block id: 169 */
        int32_t **l_282 = &l_280;
        (*l_282) = l_280;
        (*l_282) = &l_281;
    }
    else
    { /* block id: 172 */
        struct S1 l_290 = {-3735,1848,0U,2035,-5396};
        struct S1 *l_289 = &l_290;
        int32_t **l_315 = &l_280;
        union U4 l_336 = {3};
        union U4 *l_335 = &l_336;
        for (l_275.f4 = 19; (l_275.f4 == 21); l_275.f4 += 6)
        { /* block id: 175 */
            int32_t **l_314 = &l_280;
            struct S1 **l_324 = &l_289;
            struct S1 ***l_323 = &l_324;
            float *l_331 = &l_275.f0;
            union U3 ***l_332 = (void*)0;
            for (p_59 = 0; (p_59 != 59); ++p_59)
            { /* block id: 178 */
                float l_305 = 0x5.5p+1;
                union U3 * const l_308 = (void*)0;
                union U3 * const *l_307 = &l_308;
                union U3 * const **l_306 = &l_307;
                union U3 l_313 = {0x39551F97};
                union U3 *l_312 = &l_313;
                union U3 **l_311 = &l_312;
                union U3 ***l_310 = &l_311;
                union U3 ****l_309 = &l_310;
                int32_t **l_316 = (void*)0;
                int32_t l_319 = 1;
                struct S0 *l_320 = (void*)0;
                struct S1 ****l_325 = &l_323;
                if (__builtin_bswap64(p_59))
                { /* block id: 179 */
                    struct S1 l_288 = {-2593,1495,4294967292U,1005,1673};
                    struct S1 *l_287 = &l_288;
                    if ((*p_60))
                    { /* block id: 180 */
                        l_289 = l_287;
                        /* statement id: 181 */
                        assert (l_289 == &l_288);
                    }
                    else
                    { /* block id: 182 */
                        (*p_58) = ((-(uint32_t)((uint16_t)(((!(0x58B7 ^ l_290.f3)) >= __builtin_parityll((l_288.f2 ^ (p_59 && (((int16_t)((int16_t)l_288.f3 + (int16_t)((~(__builtin_popcount((!l_290.f2)) < ((uint16_t)0U % (uint16_t)l_288.f0))) && 0x7EF7)) - (int16_t)65532U) >= (-1)))))) ^ p_59) << (uint16_t)l_288.f2)) < 0x4025E57F);
                    }
                    /* facts after branching */
                    //assert (l_289 == &l_290 || l_289 == dangling || l_289 == &l_288);
                    (*l_273) = (void*)0;
                    /* statement id: 185 */
                    assert (l_274 == 0);
                }
                else
                { /* block id: 186 */
                    (*l_280) = (*p_58);
                }
                (*l_309) = l_306;
                /* statement id: 189 */
                assert (l_310 == &l_307);
                if ((*p_58))
                { /* block id: 190 */
                    return l_316;
                    /* statement id: 191 */
                    //assert (func_57_rv == 0);
                }
                else
                { /* block id: 192 */
                    for (l_275.f1 = 0; (l_275.f1 >= 28); l_275.f1 += 6)
                    { /* block id: 195 */
                        struct S0 l_322 = {0x1.Bp+1,0xE9079731,34,0x4.Bp+1,0xB8AD097F};
                        struct S0 *l_321 = &l_322;
                        (**l_315) = (*l_280);
                        l_319 = (0xBF16BD3A != (*l_280));
                        l_321 = l_320;
                        /* statement id: 198 */
                        assert (l_321 == 0);
                        p_58 = p_58;
                    }
                }
                (*l_325) = l_323;
            }
            (*l_331) = ((float)(((*l_280) > ((float)p_59 + (float)(*l_280))) == p_59) - (float)((+p_59) != 0x9.FE6ADBp+45));
            (**l_314) = (l_332 == (void*)0);
            for (p_59 = 23; (p_59 > 15); p_59--)
            { /* block id: 208 */
                if ((*p_58))
                { /* block id: 209 */
                    union U4 **l_337 = (void*)0;
                    union U4 **l_338 = &l_335;
                    (*l_338) = l_335;
                }
                else
                { /* block id: 211 */
                    struct S1 ***l_339 = &l_324;
                    struct S1 ****l_340 = &l_339;
                    (*l_340) = l_339;
                    if ((*p_60))
                        break;
                }
            }
        }
        /* facts after for loop */
        assert (l_274 == &l_275 || l_274 == 0);
        //assert (l_289 == &l_290 || l_289 == dangling);
        l_341 = (void*)0;
        /* statement id: 217 */
        assert (l_341 == 0);
    }
    /* facts after branching */
    assert (l_274 == &l_275 || l_274 == 0);
    assert (l_341 == 0 || l_341 == &l_342);
    (*l_346) = l_275;
    return l_349;
    /* statement id: 220 */
    //assert (func_57_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_63(const struct S0  p_64, const union U3  p_65, struct S2  p_66)
{ /* block id: 161 */
    int32_t l_238 = 0x92A7757B;
    int32_t *l_237 = &l_238;
    int32_t **l_236 = &l_237;
    int32_t l_247 = 0x0324E9D9;
    struct S0 ** const l_251 = (void*)0;
    struct S1 l_256 = {-747,1005,4294967293U,1592,987};
    const struct S1 *l_255 = &l_256;
    const struct S1 **l_254 = &l_255;
    struct S0 l_259 = {0xA.E7D4AAp+19,4294967291U,320,0x0.Fp+1,4294967295U};
    struct S0 *l_258 = &l_259;
    struct S0 **l_257 = &l_258;
    (*l_236) = (void*)0;
    /* statement id: 162 */
    assert (l_237 == 0);
    if (func_83(p_66.f1, ((int16_t)((p_65.f0 > ((((int16_t)((int16_t)l_247 << (int16_t)5) << (int16_t)5) | ((-(int32_t)(((uint16_t)p_65.f1 >> (uint16_t)((int16_t)__builtin_ia32_crc32qi((l_254 != &l_255), ((void*)0 != (*l_236))) >> (int16_t)p_66.f3)) ^ 0x3FBD)) >= p_66.f3)) >= 0x7A19)) <= p_66.f0) << (int16_t)1), p_65, l_257, &l_237))
    { /* block id: 163 */
        return p_66.f0;
    }
    else
    { /* block id: 165 */
        uint16_t l_260 = 0xE866;
        return l_260;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const union U3  func_68(uint32_t  p_69)
{ /* block id: 51 */
    struct S0 l_71 = {0x1.BDEC7Ep-88,0xC39FA237,-35,-0x1.Ep-1,0xB77C19C5};
    struct S0 * const l_70 = &l_71;
    struct S0 *l_73 = (void*)0;
    struct S0 **l_72 = &l_73;
    const union U3 l_74 = {0xE3BD65BD};
    (*l_72) = l_70;
    /* statement id: 52 */
    assert (l_73 == &l_71);
    return l_74;
    /* statement id: 53 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_75(int32_t * const  p_76)
{ /* block id: 54 */
    uint32_t l_77 = 0x29ADBE56;
    struct S0 l_104 = {0x8.1D51ADp-7,0U,89,0x4.D1F077p+63,0x68641A01};
    struct S0 *l_103 = &l_104;
    struct S0 ** const l_102 = &l_103;
    uint32_t l_112 = 4294967289U;
    union U3 l_117 = {0xDC96F097};
    struct S1 l_183 = {-3554,1494,0U,799,-2569};
    struct S1 *l_182 = &l_183;
    struct S2 l_188 = {3367,7,0x0A0F,746};
    struct S0 * const *l_214 = &l_103;
    union U4 l_233 = {1};
    union U4 *l_232 = &l_233;
    union U4 **l_234 = &l_232;
    float *l_235 = &l_104.f3;
    if (l_77)
    { /* block id: 55 */
        const int32_t l_89 = 0xA36B4E13;
        int32_t *l_120 = (void*)0;
        int32_t **l_119 = &l_120;
        struct S0 *l_139 = &l_104;
        struct S2 l_160 = {8041,8,0U,209};
        int32_t ** const l_168 = (void*)0;
        union U3 l_172 = {4294967288U};
        struct S1 l_181 = {7659,1500,0xC14FE9C1,-1922,8902};
        const struct S1 *l_180 = &l_181;
        int32_t l_204 = 0x75795804;
        for (l_77 = 0; (l_77 <= 5); l_77 += 4)
        { /* block id: 58 */
            struct S2 l_80 = {-4597,10,65533U,-1001};
            return l_80;
        }
        for (l_77 = 0; (l_77 < 21); l_77 += 6)
        { /* block id: 63 */
            int32_t l_92 = 0x7CC82722;
            struct S0 **l_118 = &l_103;
            (*p_76) = (func_83(l_89, ((((((uint16_t)l_92 >> (uint16_t)((uint16_t)(l_77 <= (+((uint16_t)(((int16_t)l_77 << (int16_t)func_100(l_102)) <= (*p_76)) << (uint16_t)1))) >> (uint16_t)7)) < (l_112 || ((((int16_t)((uint16_t)l_92 << (uint16_t)15) - (int16_t)l_77) || l_92) ^ l_89))) ^ l_112) && 7U) || l_89), l_117, l_118, l_119) < (*p_76));
        }
        if ((l_117.f0 < 0U))
        { /* block id: 79 */
            struct S1 * const *l_128 = (void*)0;
            union U3 *l_140 = &l_117;
            int32_t l_155 = (-10);
            int32_t *l_175 = &l_155;
            struct S0 *l_192 = &l_104;
            if (l_104.f4)
            { /* block id: 80 */
                struct S0 *l_133 = &l_104;
                int32_t l_138 = (-6);
                for (l_117.f0 = 0; (l_117.f0 != 23); l_117.f0 += 1)
                { /* block id: 83 */
                    struct S1 l_131 = {-2861,1487,0x311F6BCD,-1036,-11468};
                    struct S1 *l_130 = &l_131;
                    struct S1 **l_129 = &l_130;
                    struct S0 *l_132 = &l_104;
                    (*l_119) = (void*)0;
                    (*p_76) = ((2U != 0x2BD54EFE) ^ ((((l_128 == l_129) & (((l_132 != l_133) == ((((((uint16_t)((int16_t)0xD987 % (int16_t)l_104.f4) << (uint16_t)l_138) == (-1)) != l_131.f4) < 7U) | l_77)) >= 0x865B)) == l_131.f4) < 0x91D68C91));
                    l_139 = l_133;
                }
                (*l_102) = (*l_102);
            }
            else
            { /* block id: 89 */
                int32_t l_147 = (-10);
                struct S1 l_153 = {46,1863,0x7C57241C,1968,-7631};
                struct S1 *l_152 = &l_153;
                uint32_t l_156 = 1U;
                int32_t **l_193 = (void*)0;
                union U3 *l_197 = &l_117;
                struct S2 l_215 = {1407,-43,0xAD97,-504};
                l_140 = l_140;
                for (l_112 = (-22); (l_112 <= 58); ++l_112)
                { /* block id: 93 */
                    int16_t l_154 = 1;
                    float *l_157 = &l_104.f3;
                    (*l_157) = (__builtin_parity(((uint32_t)((((uint16_t)l_147 >> (uint16_t)7) == ((int16_t)((uint16_t)(((void*)0 != l_152) > (*p_76)) << (uint16_t)9) << (int16_t)12)) <= ((l_153.f4 ^ (0 >= l_154)) < 0xBDD5AF53)) % (uint32_t)((l_154 && 0x5FA8) & l_155))) != l_156);
                    (*l_119) = &l_155;
                    /* statement id: 95 */
                    assert (l_120 == &l_155);
                    for (l_147 = 0; (l_147 < (-29)); --l_147)
                    { /* block id: 98 */
                        return l_160;
                    }
                }
                /* facts after for loop */
                assert (l_120 == &l_155 || l_120 == 0);
                if (l_155)
                { /* block id: 102 */
                    const struct S0 l_167 = {-0x8.8p+1,0xC211F742,-302,0x7.E3C26Fp+77,4294967295U};
                    int32_t l_169 = 6;
                    struct S0 **l_173 = &l_139;
                    float *l_174 = &l_104.f3;
                    for (l_104.f4 = 0; (l_104.f4 == 10); ++l_104.f4)
                    { /* block id: 105 */
                        struct S0 l_163 = {0xE.FFDA28p-14,0x20AB37EA,-37,0xE.E15252p-41,4294967287U};
                        struct S0 *l_164 = (void*)0;
                        struct S0 *l_165 = &l_163;
                        int32_t *l_166 = &l_147;
                        (*l_165) = l_163;
                        (*l_119) = (void*)0;
                        /* statement id: 107 */
                        assert (l_120 == 0);
                        (*l_102) = &l_163;
                        /* statement id: 108 */
                        assert (l_103 == &l_163);
                        l_166 = &l_155;
                        /* statement id: 109 */
                        assert (l_166 == &l_155);
                    }
                    /* facts after for loop */
                    //assert (l_103 == dangling || l_103 == &l_104);
                    (*l_139) = l_167;
                    (*p_76) = (l_117.f0 & ((l_168 != &l_120) < l_104.f4));
                    (*l_174) = (((((((l_169 < (l_169 <= l_155)) != l_153.f1) > ((float)l_169 + (float)0x3.0p+1)) >= func_83(l_153.f3, l_153.f3, l_172, l_173, &l_120)) < 0x3.DBB92Bp+41) >= (-0x1.Bp+1)) < 0x0.21460Dp-28);
                }
                else
                { /* block id: 114 */
                    int32_t *l_184 = (void*)0;
                    int32_t **l_189 = &l_120;
lbl_187:
                    l_175 = (void*)0;
                    /* statement id: 115 */
                    assert (l_175 == 0);
                    if (((0xB5F6 || ((uint16_t)l_153.f4 >> (uint16_t)((*p_76) == (((void*)0 == &l_147) & ((uint16_t)(l_180 != l_182) % (uint16_t)(((((l_184 == p_76) >= 0U) >= 4294967295U) <= l_117.f1) || 0x0AFF)))))) ^ l_153.f4))
                    { /* block id: 116 */
                        struct S0 * const **l_186 = (void*)0;
                        struct S0 * const ***l_185 = &l_186;
                        (*l_185) = &l_102;
                        /* statement id: 117 */
                        assert (l_186 == &l_102);
                        if (l_160.f0)
                            goto lbl_187;
                    }
                    else
                    { /* block id: 119 */
                        return l_188;
                    }
                    (*l_189) = p_76;
                    /* statement id: 122 */
                    //assert (l_120 == &l_62);
                }
                /* facts after branching */
                //assert (l_103 == dangling || l_103 == &l_104);
                //assert (l_120 == &l_62 || l_120 == &l_155 || l_120 == 0);
                assert (l_175 == 0 || l_175 == &l_155);
                if (((uint16_t)func_83(l_155, ((void*)0 != l_192), l_172, &l_103, l_193) >> (uint16_t)13))
                { /* block id: 124 */
                    int32_t l_203 = (-1);
                    int32_t l_205 = 0xE1809887;
                    l_205 = ((+((uint16_t)((__builtin_ffsll((((l_197 != (void*)0) == (0x4932 | (-(int32_t)(*p_76)))) < ((int16_t)((int16_t)(l_77 < 0x549B09ED) << (int16_t)l_203) % (int16_t)l_204))) || l_77) | l_183.f3) << (uint16_t)1)) > l_104.f2);
                    (*p_76) = ((int32_t)(*p_76) % (int32_t)0x49393C06);
                    for (l_104.f4 = (-15); (l_104.f4 < 31); ++l_104.f4)
                    { /* block id: 129 */
                        return l_188;
                    }
                    for (l_155 = (-30); (l_155 < (-15)); ++l_155)
                    { /* block id: 134 */
                        int32_t *l_212 = &l_205;
                        union U3 **l_213 = &l_197;
                        (*l_119) = l_212;
                        /* statement id: 135 */
                        assert (l_120 == &l_205);
                        (*l_213) = (void*)0;
                        /* statement id: 136 */
                        assert (l_197 == 0);
                        (*l_120) = (l_214 != &l_139);
                        return l_215;
                    }
                }
                else
                { /* block id: 140 */
                    int32_t l_218 = 1;
                    uint16_t l_228 = 1U;
                    if (((((int16_t)(l_218 | ((void*)0 != &l_175)) >> (int16_t)13) ^ ((int16_t)__builtin_bswap32(l_183.f2) << (int16_t)2)) > (((uint16_t)((l_104.f4 || l_117.f1) || 4294967290U) >> (uint16_t)l_153.f4) | (*p_76))))
                    { /* block id: 141 */
                        (*p_76) = (((uint32_t)(+l_188.f0) - (uint32_t)(*p_76)) != ((void*)0 != &l_214));
                        (*p_76) = (func_83(((uint32_t)((void*)0 == &l_180) + (uint32_t)l_155), l_228, func_68(l_188.f1), &l_192, &l_175) ^ l_153.f3);
                    }
                    else
                    { /* block id: 144 */
                        return l_160;
                    }
                }
            }
            /* facts after branching */
            //assert (l_103 == dangling || l_103 == &l_104);
            //assert (l_120 == &l_62 || l_120 == &l_155 || l_120 == 0);
            assert (l_175 == 0 || l_175 == &l_155);
            return l_160;
        }
        else
        { /* block id: 150 */
            int32_t l_229 = 7;
            float *l_230 = &l_104.f3;
            (*l_230) = l_229;
        }
        (**l_102) = (*l_139);
    }
    else
    { /* block id: 154 */
        float *l_231 = &l_104.f0;
        (*l_231) = l_112;
    }
    (*l_234) = l_232;
    (**l_214) = (**l_214);
    (*l_235) = l_188.f1;
    return l_188;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_83(const uint32_t  p_84, uint32_t  p_85, union U3  p_86, struct S0 ** p_87, int32_t ** p_88)
{ /* block id: 74 */
    struct S1 *l_121 = (void*)0;
    struct S1 **l_122 = &l_121;
    int32_t l_123 = 4;
    (*l_122) = l_121;
    return l_123;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_100(struct S0 ** const  p_101)
{ /* block id: 64 */
    int32_t l_105 = 0x9C5D0792;
    int32_t l_107 = 0x4876030D;
    int32_t *l_106 = &l_107;
    uint32_t l_111 = 3U;
    (**p_101) = (**p_101);
    (*l_106) = l_105;
    for (l_105 = (-22); (l_105 < (-1)); l_105++)
    { /* block id: 69 */
        int32_t **l_110 = &l_106;
        (*l_110) = &l_107;
    }
    (*l_106) = (*l_106);
    return l_111;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 150
   depth: 1, occurrence: 17
XXX total union variables: 6

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 4
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 63
breakdown:
   indirect level: 0, occurrence: 18
   indirect level: 1, occurrence: 22
   indirect level: 2, occurrence: 16
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 0
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 35
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 47
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 49

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 206
   depth: 2, occurrence: 33
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1

XXX total number of pointers: 189

XXX times a variable address is taken: 175
XXX times a pointer is dereferenced on RHS: 44
breakdown:
   depth: 1, occurrence: 38
   depth: 2, occurrence: 4
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 73
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 7
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 329

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 146
   level: 2, occurrence: 39
   level: 3, occurrence: 7
   level: 4, occurrence: 3
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 83
XXX number of pointers point to scalars: 58
XXX number of pointers point to structs: 38
XXX percent of pointers has null in alias set: 25.9
XXX average alias set size: 1.2

XXX times a non-volatile is read: 456
XXX times a non-volatile is write: 197
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 172
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 28
   depth: 2, occurrence: 29
   depth: 3, occurrence: 16
   depth: 4, occurrence: 37
   depth: 5, occurrence: 33

XXX percentage a fresh-made variable is used: 21.4
XXX percentage an existing variable is used: 78.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

