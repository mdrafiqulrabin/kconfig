/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3622017096
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 18;
   unsigned f1 : 31;
   const unsigned f2 : 5;
};

struct S1 {
   float  f0;
   const uint32_t  f1;
   uint64_t  f2;
   int64_t  f3;
   int64_t  f4;
};

union U2 {
   uint64_t  f0;
   int32_t  f1;
};

union U3 {
   struct S1  f0;
};

union U4 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
static int32_t  func_31(int64_t  p_32, int64_t  p_33, uint32_t  p_34);
static uint64_t  func_40(union U4  p_41);
static int16_t  func_55(uint16_t  p_56, uint16_t  p_57, const float * p_58);
static const float * func_60(struct S1  p_61, float  p_62);
inline static struct S1  func_63(const uint64_t  p_64, union U2  p_65, float * p_66);
static struct S0 * func_80(struct S0 * p_81, int32_t * p_82, int32_t ** p_83, float * const  p_84, struct S1  p_85);
inline static struct S0 * func_86(int32_t * const * p_87, union U2  p_88, union U2  p_89);
static int32_t ** func_90(int16_t  p_91);
static union U2  func_98(uint16_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    int64_t l_35 = 0x741311E2DB80EBBDLL;
    union U4 l_42 = {4L};
    uint32_t l_59 = 4294967288UL;
    float l_70 = (-0x1.Ap-1);
    float *l_69 = &l_70;
    union U2 l_73 = {7UL};
    float *l_74 = (void*)0;
    int32_t *l_666 = &l_73.f1;
    float l_670 = 0x8.63FE7Ap-35;
    uint8_t l_671 = 3UL;
    int64_t l_674 = 0xF3B4D27D279B66DCLL;
    int64_t l_683 = 0xDF3A3C741E7EFF91LL;
    (*l_666) = func_31(l_35, ((int16_t)((uint64_t)func_40(l_42) + (uint64_t)((uint64_t)((func_55(l_42.f0, l_59, func_60(func_63(((int16_t)(l_69 == (void*)0) >> (int16_t)((uint16_t)__builtin_clz(l_59) << (uint16_t)0)), l_73, l_74), l_35)) ^ 65528UL) <= l_42.f0) / (uint64_t)l_59)) >> (int16_t)11), l_59);
    /* statement id: 402 */
        (*l_666) = ((*l_666) > (!(((int16_t)(l_671 || ((int64_t)l_674 - (int64_t)(((uint16_t)(((int16_t)(*l_666) << (int16_t)(*l_666)) & ((*l_666) >= ((uint16_t)((uint16_t)func_40(l_42) << (uint16_t)(*l_666)) >> (uint16_t)8))) + (uint16_t)(*l_666)) == (*l_666)))) << (int16_t)9) & (*l_666))));
    return l_683;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(int64_t  p_32, int64_t  p_33, uint32_t  p_34)
{ /* block id: 397 */
    uint8_t l_646 = 0x66L;
    struct S0 l_654 = {281,16411,0};
    struct S0 *l_653 = &l_654;
    struct S0 **l_652 = &l_653;
    float *l_655 = (void*)0;
    float *l_656 = (void*)0;
    float l_658 = (-0x1.Bp+1);
    float *l_657 = &l_658;
    union U3 l_661 = {{0x1.EE5409p+1,18446744073709551607UL,0x6F79BACFFE447C7CLL,0L,-5L}};
    union U3 *l_660 = &l_661;
    union U3 **l_659 = &l_660;
    int32_t l_663 = (-1L);
    int32_t *l_662 = &l_663;
    union U4 l_664 = {0x243F397CL};
    int32_t **l_665 = &l_662;
    (*l_657) = (((float)0x6.9p+1 - (float)((l_646 >= p_32) >= (!l_646))) != (0x1.7371C8p+94 < (((float)(l_646 >= l_646) / (float)l_646) == (((float)(l_652 == &l_653) / (float)p_34) <= p_33))));
    (*l_662) = (l_659 != (void*)0);
    (*l_665) = func_60(l_661.f0, func_40(l_664));
    /* statement id: 400 */
    assert (l_662 == 0);
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_40(union U4  p_41)
{ /* block id: 37 */
    uint64_t l_52 = 0x9C214F1636717B38LL;
    for (p_41.f0 = 0; (p_41.f0 < 9); ++p_41.f0)
    { /* block id: 40 */
        int32_t l_45 = 0x35900B08L;
        for (l_45 = 0; (l_45 != 0); l_45 += 2)
        { /* block id: 43 */
            float *l_48 = (void*)0;
            float l_50 = 0x7.EB0A11p+28;
            float *l_49 = &l_50;
            int32_t l_51 = 0L;
            (*l_49) = 0x9.3p-1;
            return l_51;
        }
    }
    return l_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_55(uint16_t  p_56, uint16_t  p_57, const float * p_58)
{ /* block id: 393 */
    uint32_t l_641 = 0x2FE50AA9L;
    int32_t l_642 = 0x86B1EE37L;
    int32_t *l_643 = &l_642;
    l_642 = l_641;
    l_643 = &l_642;
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float * func_60(struct S1  p_61, float  p_62)
{ /* block id: 52 */
    int32_t l_79 = 0xB252307DL;
    union U2 l_134 = {0xADFEA0260AD585B8LL};
    float l_146 = 0x5.298730p-13;
    float * const l_145 = &l_146;
    struct S0 l_436 = {116,36589,1};
    struct S0 *l_435 = &l_436;
    const float *l_437 = &l_146;
    const float *l_439 = &l_146;
    const float *l_440 = &l_146;
    const float *l_441 = &l_146;
    const float *l_442 = &l_146;
    const float *l_444 = &l_146;
    const float *l_445 = &l_146;
    union U4 l_468 = {1L};
    union U3 **l_483 = (void*)0;
    union U2 *l_491 = &l_134;
    union U2 **l_490 = &l_491;
    union U2 ***l_489 = &l_490;
    union U2 ****l_488 = &l_489;
    union U2 ***** const l_487 = &l_488;
    const struct S0 *l_552 = &l_436;
    const struct S0 **l_551 = &l_552;
    const struct S0 ***l_550 = &l_551;
    const struct S0 ****l_549 = &l_550;
    const float *l_610 = &l_146;
    int16_t l_618 = (-3L);
    struct S1 * const l_619 = (void*)0;
    struct S1 *l_621 = (void*)0;
    int32_t *l_639 = &l_134.f1;
    int32_t **l_638 = &l_639;
    const float *l_640 = (void*)0;
    if (l_79)
    { /* block id: 53 */
        uint32_t l_92 = 0x3D1739C3L;
        int32_t *l_144 = &l_134.f1;
        const float *l_438 = &l_146;
        const float *l_443 = &l_146;
        const float *l_446 = (void*)0;
        l_435 = func_80(func_86(func_90(l_92), func_98(p_61.f3), l_134), l_144, &l_144, l_145, p_61);
        /* statement id: 273 */
                //assert (l_144 == dangling || l_144 == 0 || l_144 == &l_134.f1);
        assert (l_435 == 0);
        return l_446;
        /* statement id: 274 */
        //assert (func_60_rv == 0);
    }
    else
    { /* block id: 275 */
        int32_t l_478 = 0x1FA8646DL;
        union U3 l_504 = {{0x0.F5C3F5p+62,0UL,0xCB65DE4F27F65B8DLL,-9L,3L}};
        union U3 *l_503 = &l_504;
        union U3 **l_502 = &l_503;
        struct S0 *l_533 = (void*)0;
        union U3 ***l_573 = &l_483;
        union U3 *** const *l_572 = &l_573;
        uint32_t l_579 = 0xC131C93AL;
        float * const *l_581 = &l_145;
        union U2 *l_591 = &l_134;
        const float *l_609 = &l_146;
        const float *l_611 = (void*)0;
        struct S1 **l_620 = (void*)0;
        int32_t l_637 = 0xB1516EE5L;
        for (l_79 = (-4); (l_79 <= 9); l_79 += 9)
        { /* block id: 278 */
            int32_t *l_449 = (void*)0;
            int32_t **l_450 = &l_449;
            union U4 l_461 = {0x33B808DDL};
            union U2 *****l_492 = &l_488;
            struct S0 * const *** const l_548 = (void*)0;
            (*l_450) = l_449;
            for (p_61.f2 = (-27); (p_61.f2 <= 22); p_61.f2 += 2)
            { /* block id: 282 */
                const uint16_t l_455 = 65535UL;
                float *l_467 = &l_146;
                float **l_466 = &l_467;
                float ***l_465 = &l_466;
                float ****l_464 = &l_465;
                union U3 l_471 = {{0x7.EAFFF1p-75,18446744073709551615UL,18446744073709551611UL,0xA38CAB490EE6CEDDLL,0x625D81B11DBAA1B3LL}};
                union U3 *l_470 = &l_471;
                union U3 **l_469 = &l_470;
                union U4 l_484 = {0x36D6B827L};
                struct S0 *l_496 = (void*)0;
                union U2 *l_505 = &l_134;
            }
        }
        if (((uint64_t)l_504.f0.f3 % (uint64_t)l_134.f0))
        { /* block id: 326 */
            const int32_t *l_559 = &l_134.f1;
            int32_t *l_560 = (void*)0;
            int32_t *l_561 = (void*)0;
            int32_t *l_562 = &l_468.f0;
            l_559 = l_439;
            /* statement id: 327 */
            assert (l_559 == &l_146);
            (*l_562) = p_61.f1;
        }
        else
        { /* block id: 329 */
            struct S0 **l_567 = &l_435;
            int32_t l_576 = 1L;
            const float *l_607 = &l_504.f0.f0;
            if (((int64_t)((uint64_t)((**l_550) == (void*)0) - (uint64_t)((__builtin_popcount(p_61.f3) & (0x906DD34E7CA7AA63LL < ((void*)0 != l_567))) & (((l_79 == 0xDF1BFF0094E84848LL) && 6UL) == 0xADEB0F8DDCED69E6LL))) % (int64_t)p_61.f3))
            { /* block id: 330 */
                float *l_580 = &l_146;
                for (l_478 = 0; (l_478 == 1); l_478 += 1)
                { /* block id: 333 */
                    uint32_t l_571 = 0xB4DA3A7CL;
                    if (((+__builtin_ffsl(l_571)) | 0x4FE4D903L))
                    { /* block id: 334 */
                        union U3 ****l_575 = &l_573;
                        union U3 *****l_574 = &l_575;
                        int32_t *l_577 = (void*)0;
                        int32_t *l_578 = &l_576;
                        (*l_574) = l_572;
                        (*l_578) = l_576;
                        (*l_578) = l_579;
                        (*l_145) = ((void*)0 == l_580);
                    }
                    else
                    { /* block id: 339 */
                        if (p_61.f2)
                            break;
                    }
                }
            }
            else
            { /* block id: 343 */
                uint32_t l_582 = 0x4F3B51DBL;
                int32_t l_589 = 1L;
                struct S0 ***l_596 = &l_567;
                union U4 l_599 = {0x8F61A761L};
                int32_t *l_617 = (void*)0;
                int32_t **l_616 = &l_617;
lbl_612:
                if ((&l_442 != l_581))
                { /* block id: 344 */
                    int32_t *l_583 = &l_134.f1;
                    (*l_583) = l_582;
                }
                else
                { /* block id: 346 */
                    struct S0 * const *l_598 = &l_533;
                    struct S0 * const **l_597 = &l_598;
                    int32_t *l_600 = &l_134.f1;
                    int32_t **l_601 = &l_600;
                    for (l_576 = (-12); (l_576 < 0); l_576 += 3)
                    { /* block id: 349 */
                        const struct S1 *l_588 = &l_504.f0;
                        const struct S1 **l_587 = &l_588;
                        const struct S1 ***l_586 = &l_587;
                        union U2 *l_590 = &l_134;
                        int32_t *l_592 = &l_468.f0;
                        l_589 = (0x5.F62A61p+14 == (l_586 == &l_587));
                        l_591 = l_590;
                        (*l_592) = p_61.f2;
                    }
                    (*l_145) = (p_61.f3 < (p_62 > ((float)(-(float)(((l_576 > l_436.f0) >= (l_596 == l_597)) >= p_61.f0)) - (float)((func_40(l_599) == l_478) <= l_589))));
                    (*l_601) = l_600;
                }
                for (l_468.f0 = 17; (l_468.f0 > 1); l_468.f0 -= 5)
                { /* block id: 359 */
                    int32_t *l_604 = &l_134.f1;
                    const float *l_608 = &l_504.f0.f0;
                    (*l_604) = 0L;
                    if (p_61.f4)
                    { /* block id: 361 */
                        const int32_t *l_606 = (void*)0;
                        const int32_t **l_605 = &l_606;
                        (*l_605) = l_445;
                        /* statement id: 362 */
                        assert (l_606 == &l_146);
                        return l_611;
                        /* statement id: 363 */
                        //assert (func_60_rv == 0);
                    }
                    else
                    { /* block id: 364 */
                        if (p_61.f3)
                            goto lbl_612;
                        if ((*l_604))
                            break;
                        (***l_549) = (*l_567);
                        if ((*l_604))
                            break;
                    }
                    for (l_599.f0 = 0; (l_599.f0 < 17); ++l_599.f0)
                    { /* block id: 372 */
                        int32_t **l_615 = &l_604;
                    }
                }
                (*l_616) = &l_576;
                /* statement id: 377 */
                assert (l_617 == &l_576);
            }
            /* facts after branching */
                        (**l_581) = ((0x2.39DB50p-66 >= l_618) <= (p_61.f1 < l_579));
        }
        /* facts after branching */
                l_621 = l_619;
        for (l_134.f1 = 4; (l_134.f1 < (-1)); --l_134.f1)
        { /* block id: 384 */
            const int32_t *l_624 = &l_468.f0;
            int32_t *l_626 = &l_468.f0;
            int32_t **l_625 = &l_626;
            float *l_629 = &l_504.f0.f0;
            float **l_628 = &l_629;
            float ** const *l_627 = &l_628;
            const float **l_632 = &l_611;
            const float ***l_631 = &l_632;
            const float ****l_630 = &l_631;
            l_624 = l_440;
            /* statement id: 385 */
            assert (l_624 == &l_146);
            (*l_625) = l_611;
            /* statement id: 386 */
            assert (l_626 == 0);
            (*l_630) = l_627;
            /* statement id: 387 */
            assert (l_631 == &l_628);
            l_637 = (p_61.f2 == ((float)0x6.5743E3p+39 - (float)(-(float)(+__builtin_clz(p_61.f1)))));
        }
    }
    /* facts after branching */
        (*l_638) = l_445;
    /* statement id: 391 */
    assert (l_639 == &l_146);
    return l_640;
    /* statement id: 392 */
    //assert (func_60_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_63(const uint64_t  p_64, union U2  p_65, float * p_66)
{ /* block id: 49 */
    int32_t l_77 = 0xBC642EE1L;
    int32_t *l_76 = &l_77;
    int32_t **l_75 = &l_76;
    struct S1 l_78 = {0x0.0p+1,1UL,0xCAEC2B2A8F302D78LL,0L,-2L};
    (*l_75) = (void*)0;
    /* statement id: 50 */
    assert (l_76 == 0);
    return l_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_80(struct S0 * p_81, int32_t * p_82, int32_t ** p_83, float * const  p_84, struct S1  p_85)
{ /* block id: 67 */
    uint32_t l_147 = 6UL;
    union U2 l_153 = {1UL};
    union U2 *l_152 = &l_153;
    union U2 **l_151 = &l_152;
    union U2 ***l_150 = &l_151;
    union U3 l_164 = {{0x9.E46E99p+55,0xD1021D52L,0xA42F98E8FF6226F7LL,0xE7A5B985A9A92C76LL,0x76FD32FAA63A172FLL}};
    union U3 *l_163 = &l_164;
    struct S1 l_202 = {0x1.1CAE45p-59,0xD9794359L,0x76EEABB79EB048EBLL,0x309C9891BAA6E91FLL,-8L};
    struct S1 *l_201 = &l_202;
    int32_t l_208 = 0L;
    union U4 l_252 = {0L};
    struct S0 l_308 = {482,21046,1};
    struct S0 *l_307 = &l_308;
    int64_t l_403 = 0xDFA2EC370606D169LL;
    if ((l_147 == ((uint16_t)65529UL >> (uint16_t)3)))
    { /* block id: 68 */
        union U2 ****l_154 = (void*)0;
        union U2 ****l_155 = &l_150;
        int32_t l_160 = 0x7AA3FF9CL;
        int32_t l_199 = 0x1DE9004FL;
        struct S1 *l_225 = (void*)0;
        uint32_t l_246 = 0x313960B7L;
        struct S0 l_273 = {468,23695,4};
        struct S0 *l_272 = &l_273;
        (*p_84) = (*p_84);
        (*l_155) = l_150;
        if (((int16_t)0x5814L + (int16_t)(((uint64_t)l_160 - (uint64_t)((int16_t)(p_81 == p_81) >> (int16_t)5)) <= (__builtin_bswap32(l_153.f1) == __builtin_bswap64((p_85.f4 ^ ((l_153.f1 & 0UL) < l_160)))))))
        { /* block id: 71 */
            l_163 = l_163;
        }
        else
        { /* block id: 73 */
            union U4 l_174 = {7L};
            struct S0 l_206 = {322,22142,4};
            struct S0 *l_205 = &l_206;
            union U3 *l_247 = &l_164;
            uint16_t l_248 = 0xEE36L;
            const float *l_294 = &l_164.f0.f0;
            const float **l_293 = &l_294;
            const float ***l_292 = &l_293;
            const float ****l_291 = &l_292;
            for (p_85.f3 = 0; (p_85.f3 == (-27)); p_85.f3--)
            { /* block id: 76 */
                uint32_t l_173 = 0x5522D6D4L;
                union U2 ****l_200 = (void*)0;
                int32_t *l_213 = (void*)0;
                union U4 l_214 = {0L};
                (*p_82) = ((uint16_t)p_85.f2 >> (uint16_t)15);
                for (p_85.f4 = 0; (p_85.f4 != (-6)); p_85.f4 -= 1)
                { /* block id: 80 */
                    (*p_83) = (*p_83);
                }
            }
            /* facts after for loop */
                        for (l_202.f2 = 0; (l_202.f2 > 60); l_202.f2 += 1)
            { /* block id: 122 */
                struct S1 **l_234 = &l_225;
                int32_t * const l_237 = &l_153.f1;
                union U4 l_238 = {0L};
                (*l_234) = l_225;
                for (l_199 = 0; (l_199 < 4); l_199 += 5)
                { /* block id: 126 */
                    union U2 *l_244 = &l_153;
                    int32_t l_245 = (-9L);
                    (*p_83) = l_237;
                    /* statement id: 127 */
                    //assert (l_144 == &l_153.f1);
                    (*p_82) = ((func_40(l_238) != ((l_199 & ((int16_t)0L >> (int16_t)((uint32_t)(~0x802AL) - (uint32_t)(p_85.f4 > (((void*)0 != l_244) != l_245))))) >= 1UL)) || p_85.f3);
                    if ((*p_82))
                        break;
                }
                l_174.f0 = (((*l_237) ^ ((l_246 >= ((l_247 == &l_164) & func_40(l_174))) & l_248)) && (l_206.f0 == (**p_83)));
                (*p_82) = (0xC5A2L > l_174.f0);
            }
            /* facts after for loop */
            //assert (l_144 == &l_153.f1 || l_144 == &l_134.f1);
            if (((uint16_t)(~func_40(l_252)) << (uint16_t)12))
            { /* block id: 134 */
                int64_t l_253 = 0x0E7347551151F3E8LL;
                union U4 l_269 = {-10L};
                if (l_253)
                { /* block id: 135 */
                    float **l_256 = (void*)0;
                    float ***l_255 = &l_256;
                    float ****l_254 = &l_255;
                    float *****l_257 = &l_254;
                    struct S1 **l_275 = &l_225;
                    (*l_257) = l_254;
                    if (((int32_t)(((uint16_t)p_85.f2 - (uint16_t)(((uint16_t)(p_85.f3 < p_85.f2) << (uint16_t)6) == p_85.f2)) < (__builtin_popcountl((-(int16_t)(func_40(l_174) <= 9UL))) <= ((uint16_t)((uint16_t)func_40(l_269) >> (uint16_t)0) << (uint16_t)l_253))) % (int32_t)1UL))
                    { /* block id: 137 */
                        struct S1 **l_270 = &l_225;
                        union U2 ***l_271 = &l_151;
                        (*l_270) = &p_85;
                        /* statement id: 138 */
                        assert (l_225 == &p_85);
                        (***l_155) = (***l_155);
                        (*l_155) = l_271;
                        return p_81;
                        /* statement id: 141 */
                        //assert (l_144 == dangling || l_144 == &l_134.f1);
                        //assert (func_80_rv == 0);
                    }
                    else
                    { /* block id: 142 */
                        struct S1 **l_274 = (void*)0;
                        l_275 = l_274;
                        /* statement id: 143 */
                        assert (l_275 == 0);
                        (*p_84) = 0x0.3p+1;
                    }
                    /* facts after branching */
                    assert (l_275 == 0);
                }
                else
                { /* block id: 146 */
                    const float *l_282 = &l_164.f0.f0;
                    const float **l_281 = &l_282;
                    const float ***l_280 = &l_281;
                    const float ****l_279 = &l_280;
                    const float *****l_278 = &l_279;
                    int32_t l_295 = 0x613173F1L;
                    int32_t *l_296 = &l_174.f0;
                    (*p_84) = ((((((float)(*p_84) - (float)(*p_84)) >= 0x2.25B8A7p+83) < ((void*)0 == l_278)) != 0x9.4p-1) >= ((float)(((float)(((float)(((float)(((void*)0 != l_291) < __builtin_clzll((p_85.f2 && l_295))) / (float)0x5.C9BE5Dp+56) > l_153.f1) - (float)0xE.493D40p-56) <= 0xE.2B18EEp-87) + (float)(*p_84)) <= 0x0.Ep+1) / (float)0xA.7FA01Dp+91));
                    (*l_296) = (*p_82);
                    (*p_83) = (void*)0;
                    /* statement id: 149 */
                    //assert (l_144 == 0);
                    p_81 = p_81;
                }
                /* facts after branching */
                //assert (l_144 == 0 || l_144 == &l_153.f1 || l_144 == &l_134.f1);
            }
            else
            { /* block id: 152 */
                (*p_82) = (8UL || ((int16_t)func_40(l_252) >> (int16_t)0));
                (*p_84) = l_273.f1;
            }
            /* facts after branching */
            //assert (l_144 == 0 || l_144 == &l_153.f1 || l_144 == &l_134.f1);
        }
        /* facts after branching */
                //assert (l_144 == 0 || l_144 == &l_153.f1 || l_144 == &l_134.f1);
    }
    else
    { /* block id: 157 */
        struct S1 * const *l_300 = (void*)0;
        struct S1 * const **l_299 = &l_300;
        int32_t l_306 = (-1L);
        union U3 ***l_322 = (void*)0;
        const union U3 *l_334 = &l_164;
        const union U3 **l_333 = &l_334;
        int32_t * const l_336 = &l_153.f1;
        int32_t * const *l_335 = &l_336;
        union U2 l_337 = {0xC1FECEB42ADA2610LL};
        (*l_299) = &l_201;
        /* statement id: 158 */
        assert (l_300 == &l_201);
        for (l_202.f4 = (-3); (l_202.f4 < (-25)); l_202.f4 -= 8)
        { /* block id: 161 */
            struct S1 **l_303 = &l_201;
            (*l_303) = &l_202;
        }
        for (l_164.f0.f4 = 0; (l_164.f0.f4 != 1); ++l_164.f0.f4)
        { /* block id: 166 */
            const union U3 *l_332 = (void*)0;
            const union U3 **l_331 = &l_332;
            int32_t l_348 = 0xA103EE57L;
            if (l_306)
            { /* block id: 167 */
                return p_81;
                /* statement id: 168 */
                //assert (l_144 == dangling || l_144 == &l_134.f1);
                //assert (func_80_rv == 0);
            }
            else
            { /* block id: 169 */
                int64_t l_315 = (-1L);
                union U2 *l_318 = &l_153;
                int32_t *l_321 = &l_252.f0;
                float *l_326 = &l_164.f0.f0;
                float **l_325 = &l_326;
                float *** const l_324 = &l_325;
                (*p_84) = ((float)((((float)l_306 - (float)((float)(l_315 < 0x0.7317A3p+62) - (float)(func_40(l_252) >= 0xE.284081p-53))) > ((float)l_306 - (float)((*p_84) >= (((*p_84) != 0x0.1p-1) <= 0x6.B29114p+14)))) == (*p_84)) / (float)0x0.4p+1);
                (*l_151) = l_318;
                (*l_321) = ((float)((l_321 != &l_306) < (*p_84)) + (float)__builtin_ffsl((l_322 != l_322)));
                if ((((p_85.f2 || ((p_85.f2 == 3L) >= ((*l_321) < (*p_82)))) ^ (-(uint32_t)1UL)) == 0xE82FL))
                { /* block id: 173 */
                    float ***l_328 = (void*)0;
                    float ****l_327 = &l_328;
                    (*l_327) = l_324;
                    /* statement id: 174 */
                    assert (l_328 == &l_325);
                }
                else
                { /* block id: 175 */
                    (*p_83) = l_326;
                    /* statement id: 176 */
                    //assert (l_144 == &l_164.f0.f0);
                    if ((**p_83))
                        continue;
                }
            }
            for (p_85.f4 = (-6); (p_85.f4 <= (-14)); p_85.f4 -= 6)
            { /* block id: 182 */
                struct S0 **l_338 = (void*)0;
                struct S0 **l_339 = &l_307;
                int32_t l_343 = 0xBE4A16B0L;
                l_333 = l_331;
                /* statement id: 183 */
                assert (l_333 == &l_332);
                (*l_339) = func_86(l_335, l_337, (***l_150));
                /* statement id: 184 */
                assert (l_307 == 0);
                l_343 = ((float)(-(float)0x0.8p-1) + (float)((((*p_84) == (*p_84)) == (**l_335)) != (0x6.480300p-87 < l_343)));
            }
            /* facts after for loop */
            //assert (l_333 == &l_332 || l_333 == dangling || l_333 == &l_334);
            if (((void*)0 == &p_85))
            { /* block id: 187 */
                (**l_335) = (*p_82);
            }
            else
            { /* block id: 189 */
                union U3 **l_345 = &l_163;
                union U3 ***l_344 = &l_345;
                union U3 ** const *l_347 = (void*)0;
                union U3 ** const **l_346 = &l_347;
                (*l_346) = l_344;
                /* statement id: 190 */
                assert (l_347 == &l_345);
                (*p_83) = &l_208;
                /* statement id: 191 */
                //assert (l_144 == &l_208);
                l_348 = (*p_82);
                if ((**p_83))
                { /* block id: 193 */
                    if ((*p_82))
                        break;
                    //assert (l_333 == dangling || l_333 == &l_334);
                }
                else
                { /* block id: 195 */
                    uint64_t l_353 = 18446744073709551615UL;
                    if ((**p_83))
                        break;
                    //assert (l_333 == dangling || l_333 == &l_334);
                    for (l_202.f4 = 0; (l_202.f4 <= (-28)); l_202.f4 -= 1)
                    { /* block id: 199 */
                        float ****l_356 = (void*)0;
                        (**p_83) = ((int64_t)l_353 + (int64_t)(p_85.f1 | (0x350917B79CEA0C12LL ^ ((int16_t)((void*)0 != l_356) - (int16_t)l_353))));
                    }
                }
            }
        }
        /* facts after for loop */
        //assert (l_144 == &l_208 || l_144 == &l_164.f0.f0 || l_144 == &l_134.f1);
                assert (l_307 == 0 || l_307 == &l_308);
        //assert (l_333 == dangling || l_333 == &l_334);
        if ((*p_82))
        { /* block id: 205 */
            int64_t l_363 = 0L;
            struct S0 *l_376 = &l_308;
            float *l_379 = &l_164.f0.f0;
            float **l_378 = &l_379;
            float ***l_377 = &l_378;
            for (l_337.f1 = (-20); (l_337.f1 == (-28)); --l_337.f1)
            { /* block id: 208 */
                const int32_t l_370 = 0xF50FCE14L;
                for (l_252.f0 = 0; (l_252.f0 >= 1); l_252.f0++)
                { /* block id: 211 */
                    const float l_364 = 0xD.15CB5Fp-56;
                    (*p_82) = ((p_85.f2 > p_85.f3) <= (0x57A09A846929B31ELL && (p_85.f3 < p_85.f1)));
                    if ((((*l_151) == (**l_150)) && __builtin_popcountl((((uint16_t)l_363 << (uint16_t)9) != l_164.f0.f1))))
                    { /* block id: 213 */
                        (*p_83) = (*p_83);
                    }
                    else
                    { /* block id: 215 */
                        int32_t *l_365 = &l_252.f0;
                        (*p_83) = l_365;
                        /* statement id: 216 */
                        //assert (l_144 == &l_252.f0);
                        (*p_84) = (*l_365);
                        (*p_83) = (void*)0;
                        /* statement id: 218 */
                        //assert (l_144 == 0);
                        (**l_335) = (0L == ((uint16_t)(*l_365) - (uint16_t)((int64_t)(**l_335) + (int64_t)l_370)));
                    }
                    (**l_335) = l_370;
                }
                (*p_83) = (*p_83);
            }
            /* facts after for loop */
                        //assert (l_144 == 0 || l_144 == &l_208 || l_144 == &l_164.f0.f0 || l_144 == &l_134.f1);
                        (*l_336) = 0L;
            (***l_377) = (((*p_84) >= (-0x7.Cp-1)) <= ((-(float)(*p_84)) == ((float)(((float)((l_376 == (void*)0) == (l_377 == (void*)0)) + (float)(&p_81 != (void*)0)) < 0x9.20FC24p+82) / (float)(-0x7.5p-1))));
        }
        else
        { /* block id: 227 */
            int32_t l_380 = 9L;
            struct S0 **l_381 = &l_307;
            (**l_335) = l_380;
            (*l_381) = p_81;
            /* statement id: 229 */
            assert (l_307 == 0);
            for (l_337.f1 = (-16); (l_337.f1 < (-10)); l_337.f1++)
            { /* block id: 232 */
                (*p_83) = &l_208;
                /* statement id: 233 */
                //assert (l_144 == &l_208);
                (**l_335) = (*p_82);
            }
            /* facts after for loop */
                    }
        /* facts after branching */
                //assert (l_144 == 0 || l_144 == &l_208 || l_144 == &l_164.f0.f0 || l_144 == &l_134.f1);
            }
    /* facts after branching */
        //assert (l_144 == 0 || l_144 == &l_208 || l_144 == &l_164.f0.f0 || l_144 == &l_134.f1 || l_144 == &l_153.f1);
        assert (l_307 == 0 || l_307 == &l_308);
    if (l_252.f0)
    { /* block id: 238 */
        union U3 **l_384 = &l_163;
        int32_t l_389 = (-2L);
        struct S0 *l_409 = &l_308;
        union U2 *l_412 = &l_153;
        union U3 ***l_416 = &l_384;
        union U4 l_434 = {0xE5B989AAL};
        (*l_384) = &l_164;
        (*p_83) = (*p_83);
        for (l_147 = 10; (l_147 == 45); l_147 += 7)
        { /* block id: 243 */
            union U3 *l_390 = &l_164;
            int32_t *l_391 = &l_252.f0;
            union U4 l_408 = {0xB03ECC52L};
            struct S0 *l_411 = &l_308;
            union U3 ***l_415 = &l_384;
            if ((l_164.f0.f1 <= ((p_85.f4 != p_85.f1) || ((int32_t)l_202.f4 / (int32_t)p_85.f1))))
            { /* block id: 244 */
                float l_395 = (-0x1.8p+1);
                (*p_82) = 0x268BF3F1L;
                if (((*p_82) > l_389))
                { /* block id: 246 */
                    (*l_384) = l_390;
                    (*p_83) = l_391;
                    /* statement id: 248 */
                    //assert (l_144 == &l_252.f0);
                    (*p_84) = (+(0x4.5868C0p-50 == ((float)0xF.66DA58p+44 / (float)0x0.5B76E9p+81)));
                }
                else
                { /* block id: 250 */
                    int16_t l_400 = (-1L);
                    struct S0 *l_410 = &l_308;
                    (*p_84) = (((l_395 < ((float)((((float)l_400 / (float)((float)l_400 - (float)__builtin_ffsl(l_164.f0.f3))) >= (l_403 != ((float)((float)((l_389 < (((-0x1.0p-1) > func_40(l_408)) != (-0x2.0p+1))) >= (-0x9.8p-1)) / (float)l_202.f4) / (float)(*p_84)))) >= (*p_84)) + (float)(*p_84))) < 0xF.D448EBp-57) > 0x4.7p-1);
                    (*p_83) = &l_389;
                    /* statement id: 252 */
                    //assert (l_144 == &l_389);
                    return p_81;
                    /* statement id: 253 */
                    //assert (l_144 == dangling);
                    //assert (func_80_rv == 0);
                }
                /* facts after branching */
                //assert (l_144 == &l_252.f0);
            }
            else
            { /* block id: 255 */
                (*p_82) = l_389;
                return p_81;
                /* statement id: 257 */
                //assert (l_144 == dangling || l_144 == 0 || l_144 == &l_134.f1);
                //assert (func_80_rv == 0);
            }
            /* facts after branching */
            //assert (l_144 == &l_252.f0);
            (*l_151) = l_412;
            for (l_208 = (-2); (l_208 != 16); l_208 += 6)
            { /* block id: 262 */
                const uint16_t l_419 = 65535UL;
                l_416 = l_415;
                (*l_391) = (((int16_t)((l_419 & p_85.f3) < ((int16_t)0xB1A3L << (int16_t)((uint16_t)((int16_t)((*l_150) != (void*)0) << (int16_t)8) << (uint16_t)10))) >> (int16_t)p_85.f4) ^ (((uint64_t)p_85.f3 % (uint64_t)p_85.f3) != ((int16_t)((int32_t)(-(uint16_t)(-(uint64_t)func_40(l_252))) / (int32_t)l_389) - (int16_t)0xD67DL)));
            }
            (*l_391) = (func_40(l_434) || l_434.f0);
        }
        /* facts after for loop */
        //assert (l_144 == &l_252.f0 || l_144 == 0 || l_144 == &l_208 || l_144 == &l_164.f0.f0 || l_144 == &l_134.f1 || l_144 == &l_153.f1);
    }
    else
    { /* block id: 268 */
        (*p_82) = l_208;
        return p_81;
        /* statement id: 270 */
        //assert (l_144 == 0 || l_144 == dangling || l_144 == &l_134.f1);
        //assert (func_80_rv == 0);
    }
    /* facts after branching */
    //assert (l_144 == &l_252.f0 || l_144 == 0 || l_144 == &l_208 || l_144 == &l_164.f0.f0 || l_144 == &l_134.f1 || l_144 == &l_153.f1);
    return p_81;
    /* statement id: 272 */
    //assert (l_144 == dangling || l_144 == 0 || l_144 == &l_134.f1);
    //assert (func_80_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_86(int32_t * const * p_87, union U2  p_88, union U2  p_89)
{ /* block id: 64 */
    float l_136 = 0x9.06C792p-90;
    float *l_135 = &l_136;
    struct S0 l_138 = {261,46289,4};
    struct S0 *l_137 = &l_138;
    struct S0 *l_139 = &l_138;
    struct S0 *l_140 = &l_138;
    struct S0 *l_141 = &l_138;
    struct S0 *l_142 = &l_138;
    struct S0 *l_143 = (void*)0;
    (*l_135) = 0x1.BCB137p+37;
    return l_143;
    /* statement id: 66 */
    //assert (func_86_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_90(int16_t  p_91)
{ /* block id: 54 */
    float l_94 = 0x1.Cp-1;
    float *l_93 = &l_94;
    float **l_96 = &l_93;
    float ***l_95 = &l_96;
    int32_t **l_97 = (void*)0;
    (*l_93) = p_91;
    (*l_95) = (void*)0;
    /* statement id: 56 */
    assert (l_96 == 0);
    (*l_93) = p_91;
    return l_97;
    /* statement id: 58 */
    //assert (func_90_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_98(uint16_t  p_99)
{ /* block id: 59 */
    uint8_t l_102 = 0UL;
    float l_118 = 0xD.9BA90Dp-50;
    float *l_117 = &l_118;
    float **l_116 = &l_117;
    int32_t l_119 = 0x77E56D7CL;
    float ***l_125 = &l_116;
    int32_t *l_130 = &l_119;
    union U2 *l_131 = (void*)0;
    union U2 **l_132 = &l_131;
    union U2 l_133 = {4UL};
    l_119 = (((l_102 <= (0x4CD8L >= ((p_99 <= (((int16_t)((uint64_t)(!0xA19D8D7774CA6A66LL) % (uint64_t)((int64_t)0x9E2CD2A1986173B0LL % (int64_t)(((int16_t)((uint16_t)65535UL >> (uint16_t)l_102) >> (int16_t)5) ^ ((l_116 != &l_117) != (-1L))))) << (int16_t)5) == p_99)) | 0L))) && (-10L)) & 0x8B2F9387L);
    (*l_130) = (((-(uint32_t)((uint16_t)((uint64_t)(p_99 <= 0x2609879556C6C4C5LL) / (uint64_t)((l_125 != (void*)0) && (p_99 ^ p_99))) >> (uint16_t)p_99)) && ((uint32_t)((int32_t)p_99 + (int32_t)(((l_119 != l_119) == p_99) >= 0x0A6A08C4L)) % (uint32_t)p_99)) > (-1L));
    (*l_132) = l_131;
    return l_133;
    /* statement id: 63 */
    }




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 191
   depth: 1, occurrence: 1
XXX total union variables: 20

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 17
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 17
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 5

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 214
   depth: 2, occurrence: 30
   depth: 3, occurrence: 6
   depth: 4, occurrence: 6
   depth: 5, occurrence: 2
   depth: 6, occurrence: 4
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 4
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 4
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 22, occurrence: 1

XXX total number of pointers: 229

XXX times a variable address is taken: 192
XXX times a pointer is dereferenced on RHS: 72
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 115
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 11
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 251

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 219
   level: 2, occurrence: 40
   level: 3, occurrence: 9
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 109
XXX number of pointers point to scalars: 75
XXX number of pointers point to structs: 28
XXX percent of pointers has null in alias set: 27.1
XXX average alias set size: 1.12

XXX times a non-volatile is read: 603
XXX times a non-volatile is write: 305
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 174
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 19
   depth: 2, occurrence: 30
   depth: 3, occurrence: 36
   depth: 4, occurrence: 33
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 18.6
XXX percentage an existing variable is used: 81.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

