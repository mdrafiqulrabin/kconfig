/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3029308520
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const uint32_t  f0;
   uint32_t  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_31(void);
static int32_t * func_32(union U0  p_33, int32_t * p_34, int32_t * p_35, int32_t * p_36);
static union U0  func_37(uint32_t  p_38, int32_t * p_39);
static int32_t * func_41(int16_t  p_42, float  p_43, int32_t  p_44, int32_t  p_45, uint32_t  p_46);
inline static int32_t  func_47(uint32_t  p_48, uint32_t  p_49, int32_t * p_50, int32_t * p_51);
inline static int32_t * func_55(union U0  p_56, int32_t  p_57, int32_t * p_58);
inline static uint16_t  func_67(uint32_t  p_68, int32_t  p_69);
inline static uint16_t  func_72(int32_t * p_73);
static uint16_t  func_76(uint32_t  p_77, float  p_78, int32_t * const  p_79, uint16_t  p_80);
static int32_t * func_81(uint32_t  p_82, int32_t  p_83, const uint32_t  p_84, int32_t * p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_40 = (-7);
    int32_t *l_880 = &l_40;
    int32_t **l_879 = &l_880;
    int32_t l_881 = (-2);
    (*l_879) = func_32(func_37(l_40, func_41(l_40, (&l_40 == &l_40), func_47(l_40, (((int16_t)(+((&l_40 != (void*)0) != (l_40 < l_40))) >> (int16_t)l_40) & l_40), &l_40, &l_40), l_40, l_40)), &l_40, &l_40, &l_40);
    return l_881;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_32(union U0  p_33, int32_t * p_34, int32_t * p_35, int32_t * p_36)
{ /* block id: 540 */
    int32_t *l_873 = (void*)0;
    int32_t **l_872 = &l_873;
    int32_t l_876 = 1;
    (*l_872) = (void*)0;
    (*p_34) = ((int32_t)l_876 + (int32_t)(*p_34));
    for (l_876 = 0; (l_876 != (-15)); l_876 -= 5)
    { /* block id: 545 */
        (*l_872) = (*l_872);
        (*l_872) = p_35;
        /* statement id: 547 */
        //assert (l_873 == &l_40);
    }
    /* facts after for loop */
    //assert (l_873 == &l_40 || l_873 == 0);
    return p_34;
    /* statement id: 549 */
    //assert (func_32_rv == &l_40);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_37(uint32_t  p_38, int32_t * p_39)
{ /* block id: 443 */
    uint32_t l_706 = 0xEC02D3E0;
    int32_t l_719 = 0x2107BE99;
    int32_t *l_718 = &l_719;
    union U0 ** const **l_727 = (void*)0;
    union U0 ** const ***l_726 = &l_727;
    uint32_t l_776 = 0x470E4924;
    int32_t * const **l_797 = (void*)0;
    int16_t l_815 = 0x11DE;
    uint32_t l_816 = 4U;
    union U0 l_836 = {0x39076DD5};
    union U0 *l_835 = &l_836;
    union U0 l_871 = {0U};
    if (((int16_t)((+((uint16_t)(!((int32_t)(0x643E9282 <= l_706) - (int32_t)((uint16_t)(((9U <= (l_706 && ((int32_t)(p_38 ^ l_706) - (int32_t)((uint32_t)(((p_38 >= ((l_706 > l_706) ^ p_38)) & l_706) && l_706) % (uint32_t)4294967293U)))) >= 0U) ^ 0xBE03) - (uint16_t)p_38))) << (uint16_t)5)) ^ l_706) << (int16_t)11))
    { /* block id: 444 */
        int32_t l_716 = (-1);
        int32_t *l_715 = &l_716;
        int32_t **l_717 = &l_715;
        float l_721 = (-0x3.6p-1);
        float *l_720 = &l_721;
        (*l_717) = l_715;
        (*l_717) = l_718;
        /* statement id: 446 */
        assert (l_715 == &l_719);
        (*l_720) = p_38;
    }
    else
    { /* block id: 448 */
        int16_t l_725 = 0;
        int32_t **l_759 = (void*)0;
        int32_t ***l_758 = &l_759;
        union U0 l_768 = {4294967295U};
        int32_t ****l_808 = &l_758;
        int32_t *****l_807 = &l_808;
        for (l_706 = 3; (l_706 == 29); l_706 += 7)
        { /* block id: 451 */
            union U0 **l_724 = (void*)0;
            int32_t l_742 = 0x44B0CC6D;
            float l_743 = 0x3.10D532p-74;
            uint32_t l_744 = 0U;
            union U0 ****l_748 = (void*)0;
            int32_t *l_774 = &l_768.f2;
            int32_t *** const *l_802 = &l_758;
            int32_t **l_803 = &l_718;
        }
        (*l_807) = &l_758;
    }
    l_718 = &l_719;
    if (((((__builtin_ffs(p_38) <= (*l_718)) == ((int16_t)((((void*)0 != (*l_726)) <= (*l_718)) < ((int32_t)((p_38 != (((int16_t)p_38 - (int16_t)p_38) != l_815)) | 0) - (int32_t)p_38)) % (int16_t)l_816)) >= 0xE702CEAE) | (*l_718)))
    { /* block id: 501 */
        union U0 l_817 = {0x7C885D63};
        int32_t **l_818 = (void*)0;
        int32_t **l_819 = &l_718;
        (*l_718) = p_38;
        (*l_819) = func_55(l_817, p_38, &l_719);
        (*l_718) = (1U == ((*l_718) > p_38));
    }
    else
    { /* block id: 505 */
        union U0 l_822 = {1U};
        union U0 *l_821 = &l_822;
        union U0 **l_820 = &l_821;
        int32_t * const l_827 = &l_822.f2;
        int32_t *l_869 = &l_836.f2;
        l_820 = l_820;
        if ((__builtin_parityl(((!((!(l_822.f1 | (((int32_t)(*l_718) + (int32_t)__builtin_ffsll(l_822.f2)) && ((func_76(__builtin_popcountll((*l_718)), __builtin_ffs(l_822.f2), l_827, p_38) >= 0x23F2215A) != 0x760B8827)))) > 0)) || p_38)) | p_38))
        { /* block id: 507 */
            union U0 *l_828 = (void*)0;
            int32_t *l_829 = &l_822.f2;
            int32_t **l_830 = (void*)0;
            l_828 = l_828;
            (*l_718) = (*l_718);
            l_829 = l_829;
            if (p_38)
            { /* block id: 511 */
                union U0 l_833 = {0x800C3F16};
                const int16_t l_834 = (-10);
                float l_851 = 0x0.2p+1;
                float *l_850 = &l_851;
                for (l_815 = 0; (l_815 <= 1); l_815 += 6)
                { /* block id: 514 */
                    return l_833;
                    /* statement id: 515 */
                                    }
                if ((p_38 < l_834))
                { /* block id: 517 */
                    (*l_820) = l_835;
                    /* statement id: 518 */
                    assert (l_821 == &l_836);
                }
                else
                { /* block id: 519 */
                    union U0 * const *l_844 = &l_821;
                    if (p_38)
                    { /* block id: 520 */
                        return l_833;
                        /* statement id: 521 */
                                            }
                    else
                    { /* block id: 522 */
                        uint32_t l_841 = 4294967294U;
                        float l_843 = (-0x3.4p-1);
                        float *l_842 = &l_843;
                        union U0 l_845 = {0x8837D9F0};
                        (*l_827) = __builtin_bswap32(p_38);
                        /* statement id: 523 */
                                                (*l_842) = ((+(((float)(-(float)((l_833.f2 != p_38) == l_841)) + (float)(__builtin_ffsl(l_834) != ((l_827 == l_842) < p_38))) < (l_844 == &l_821))) != (*l_827));
                        return l_845;
                        /* statement id: 525 */
                                            }
                }
                /* facts after branching */
                assert (l_821 == &l_836);
                (*l_850) = ((float)(-0x10.3p+1) + (float)((float)((void*)0 != &l_820) + (float)p_38));
                (*l_827) = (func_67(l_833.f1, ((int16_t)(*l_827) >> (int16_t)13)) < p_38);
                /* statement id: 529 */
                            }
            else
            { /* block id: 530 */
                int32_t l_860 = 0;
                const int32_t l_867 = (-3);
                (*l_827) = (func_67(((uint32_t)(((uint16_t)((uint32_t)p_38 % (uint32_t)(*l_827)) >> (uint16_t)6) > (((int16_t)((int32_t)(((((int16_t)l_860 >> (int16_t)5) == l_860) > l_860) == l_867) + (int32_t)p_38) >> (int16_t)(*l_827)) >= 0)) % (uint32_t)(*l_829)), p_38) && 0x32FA);
                /* statement id: 531 */
                            }
            /* facts after branching */
                        assert (l_821 == &l_822 || l_821 == &l_836);
        }
        else
        { /* block id: 533 */
            int32_t *l_868 = &l_719;
            union U0 l_870 = {0xE0997A38};
            l_869 = l_868;
            /* statement id: 534 */
            assert (l_869 == &l_719);
            return l_870;
            /* statement id: 535 */
                    }
        /* facts after branching */
                assert (l_821 == &l_822 || l_821 == &l_836);
        (*l_869) = 0x6.855603p-40;
        /* statement id: 537 */
            }
    return l_871;
    /* statement id: 539 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_41(int16_t  p_42, float  p_43, int32_t  p_44, int32_t  p_45, uint32_t  p_46)
{ /* block id: 440 */
    float l_687 = 0xA.FD4E70p+80;
    int32_t l_688 = 0x7129BBD2;
    int32_t *l_689 = &l_688;
    int32_t *l_690 = &l_688;
    int32_t *l_691 = &l_688;
    int32_t *l_692 = &l_688;
    int32_t *l_693 = &l_688;
    int32_t *l_694 = &l_688;
    int32_t *l_695 = &l_688;
    int32_t *l_696 = &l_688;
    int32_t *l_697 = (void*)0;
    (*l_689) = l_688;
    return l_697;
    /* statement id: 442 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_47(uint32_t  p_48, uint32_t  p_49, int32_t * p_50, int32_t * p_51)
{ /* block id: 37 */
    union U0 l_59 = {1U};
    int32_t *l_663 = &l_59.f2;
    int32_t **l_662 = &l_663;
    int32_t *l_686 = &l_59.f2;
    (*l_662) = func_55(l_59, p_49, p_51);
    /* statement id: 426 */
    //assert (l_663 == &l_40);
    for (p_49 = 0; (p_49 <= 25); p_49++)
    { /* block id: 429 */
        int32_t l_666 = (-1);
        l_666 = (*p_50);
        return l_666;
    }
    for (l_59.f2 = 0; (l_59.f2 != 16); l_59.f2 += 8)
    { /* block id: 435 */
        uint32_t l_671 = 0x7B93BDDC;
        union U0 *l_680 = &l_59;
        union U0 ** const l_679 = &l_680;
        union U0 ** const *l_678 = &l_679;
        union U0 ** const **l_677 = &l_678;
        union U0 ** const ***l_676 = &l_677;
        int32_t l_685 = 1;
        int32_t *l_684 = &l_685;
        (*l_684) = ((int16_t)(p_48 == (l_671 || (((uint16_t)((uint32_t)(*l_663) + (uint32_t)(((void*)0 == l_676) ^ (~p_49))) << (uint16_t)(65528U & (((uint32_t)(p_49 >= p_49) - (uint32_t)0xB908DBCF) != p_49))) && 0x398CA139))) << (int16_t)(**l_662));
    }
    /* facts after for loop */
        (*l_686) = 0x920E7ED8;
    return (*l_663);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_55(union U0  p_56, int32_t  p_57, int32_t * p_58)
{ /* block id: 38 */
    uint16_t l_60 = 0x9F3C;
    int32_t *l_190 = (void*)0;
    int16_t l_248 = 0x4D21;
    int32_t l_250 = 3;
    int32_t **l_264 = &l_190;
    int32_t ***l_263 = &l_264;
    int32_t ****l_262 = &l_263;
    uint16_t l_294 = 65535U;
    int16_t l_526 = 0x68C0;
    uint16_t l_583 = 9U;
    const int32_t l_598 = 0;
    int32_t l_661 = 0xFB36FAE6;
    int32_t *l_660 = &l_661;
    return p_58;
    /* statement id: 425 */
    //assert (func_55_rv == &l_40 || func_55_rv == 0 || func_55_rv == &l_719);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_67(uint32_t  p_68, int32_t  p_69)
{ /* block id: 105 */
    int32_t l_169 = 5;
    int32_t *l_168 = &l_169;
    int32_t **l_167 = &l_168;
    float l_183 = 0x6.2AA811p+67;
    float *l_182 = &l_183;
    uint32_t l_184 = 5U;
    for (p_68 = 0; (p_68 >= 55); p_68 += 6)
    { /* block id: 108 */
        float l_164 = 0x0.0p-1;
        int32_t l_166 = 0;
        int32_t *l_165 = &l_166;
        int32_t ***l_170 = (void*)0;
        for (p_69 = 3; (p_69 > (-27)); --p_69)
        { /* block id: 111 */
            int32_t *l_161 = (void*)0;
            int32_t l_163 = 2;
            int32_t *l_162 = &l_163;
            (*l_162) = 0x9336AE27;
        }
        (*l_165) = p_68;
        l_167 = l_167;
    }
    if ((*l_168))
    { /* block id: 117 */
        const int32_t *l_172 = &l_169;
        const int32_t **l_171 = &l_172;
        int32_t ***l_173 = &l_167;
        (*l_173) = l_171;
        /* statement id: 118 */
        assert (l_167 == &l_172);
        for (p_69 = 0; (p_69 > 18); ++p_69)
        { /* block id: 121 */
            return p_68;
        }
        (***l_173) = p_69;
    }
    else
    { /* block id: 125 */
        int32_t *l_179 = &l_169;
        for (l_169 = (-9); (l_169 == (-23)); l_169 -= 2)
        { /* block id: 128 */
            const int32_t l_178 = 0x96B58146;
            (*l_167) = &p_69;
            /* statement id: 129 */
            assert (l_168 == &p_69);
            (*l_167) = (*l_167);
        }
        /* facts after for loop */
        assert (l_168 == &p_69 || l_168 == &l_169);
    }
    /* facts after branching */
    assert (l_168 == &p_69 || l_168 == &l_169);
    //assert (l_167 == &l_168 || l_167 == dangling);
    (*l_182) = ((float)(&l_168 == (void*)0) - (float)0xE.93DB6Bp+23);
    return l_184;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_72(int32_t * p_73)
{ /* block id: 43 */
    float l_74 = 0x0.Ep-1;
    int32_t l_75 = 1;
    return l_75;
}


/* ------------------------------------------ */
/* 
 * reads : l_40
 * writes:
 */
static uint16_t  func_76(uint32_t  p_77, float  p_78, int32_t * const  p_79, uint16_t  p_80)
{ /* block id: 102 */
    int16_t l_154 = 0x0A37;
    int32_t *l_155 = (void*)0;
    int32_t **l_156 = &l_155;
    (*l_156) = p_79;
    /* statement id: 103 */
    //assert (l_155 == &l_87 || l_155 == &l_40 || l_155 == &l_416 || l_155 == &l_822.f2);
    return (**l_156);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_81(uint32_t  p_82, int32_t  p_83, const uint32_t  p_84, int32_t * p_85)
{ /* block id: 45 */
    int32_t l_88 = (-1);
    int32_t l_89 = 0x19116590;
    int32_t *l_91 = &l_88;
    int32_t **l_90 = &l_91;
    int16_t l_96 = 0;
    int32_t l_150 = 1;
    int32_t *l_151 = &l_150;
    (*p_85) = (l_88 > l_89);
    (*l_90) = p_85;
    /* statement id: 47 */
    //assert (l_91 == &l_87 || l_91 == &l_197 || l_91 == &l_253 || l_91 == &l_325 || l_91 == &l_416 || l_91 == &l_429 || l_91 == &l_742);
    for (l_88 = (-15); (l_88 == 9); ++l_88)
    { /* block id: 50 */
        const int32_t l_102 = 0xE57C1F20;
        const int32_t *l_114 = &l_88;
        int32_t *l_136 = &l_88;
        for (p_82 = (-16); (p_82 == 7); p_82++)
        { /* block id: 53 */
            int32_t l_103 = 1;
            int32_t * const * const l_106 = (void*)0;
            float l_111 = 0x0.3p-1;
            float *l_110 = &l_111;
            if (((*p_85) > l_96))
            { /* block id: 54 */
                const int32_t l_101 = 7;
                l_103 = (((float)(p_84 >= ((float)l_101 + (float)0x5.Ep-1)) + (float)(**l_90)) <= l_102);
            }
            else
            { /* block id: 56 */
                float *l_107 = (void*)0;
                float l_109 = 0x4.Ap-1;
                float *l_108 = &l_109;
                (*l_108) = (func_72(p_85) < ((((float)((((((0xC.3D1739p+9 >= p_84) <= l_103) < (&l_91 != l_106)) == 0x0.D9F5B6p+75) >= (__builtin_bswap32((**l_90)) < (*l_91))) < 0x2.0p-1) - (float)p_83) == 0x1.1p-1) == (**l_90)));
                (*l_91) = (l_110 != l_91);
                (*l_91) = ((float)0x1.657D2Ap-31 - (float)(((void*)0 == l_114) > ((float)(-(float)((&l_91 == (void*)0) >= 0x2.4p-1)) - (float)(*l_91))));
            }
            if ((*l_114))
                break;
        }
        for (l_96 = 0; (l_96 == 7); l_96 += 9)
        { /* block id: 65 */
            int32_t *l_127 = (void*)0;
            union U0 l_134 = {0xFBECF304};
            union U0 *l_133 = &l_134;
            for (p_82 = 25; (p_82 < 35); p_82 += 1)
            { /* block id: 68 */
                uint32_t l_126 = 4294967289U;
                int32_t *l_139 = &l_134.f2;
                int32_t * const l_149 = &l_134.f2;
                for (p_83 = 14; (p_83 != 27); ++p_83)
                { /* block id: 71 */
                    float *l_130 = (void*)0;
                    float l_132 = (-0x1.0p-1);
                    float *l_131 = &l_132;
                    (*l_131) = ((float)((0x1.8916A7p-15 == (0x5.CA85E4p+38 != ((((l_126 != (-0x1.Fp+1)) <= p_83) > (l_126 != ((func_72(l_127) >= ((float)p_83 + (float)0xC.879556p-25)) != p_84))) != 0xF.D0FD02p+77))) > p_83) + (float)0x1.1p+1);
                    (*l_90) = p_85;
                }
            }
            if ((*p_85))
                break;
            if ((*p_85))
                break;
        }
    }
    return p_85;
    /* statement id: 101 */
    //assert (func_81_rv == &l_87 || func_81_rv == &l_197 || func_81_rv == &l_253 || func_81_rv == &l_325 || func_81_rv == &l_416 || func_81_rv == &l_429 || func_81_rv == &l_742);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 240
XXX total union variables: 9

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 20
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 235

XXX times a variable address is taken: 222
XXX times a pointer is dereferenced on RHS: 188
breakdown:
   depth: 1, occurrence: 154
   depth: 2, occurrence: 17
   depth: 3, occurrence: 11
   depth: 4, occurrence: 6
XXX times a pointer is dereferenced on LHS: 138
breakdown:
   depth: 1, occurrence: 113
   depth: 2, occurrence: 14
   depth: 3, occurrence: 10
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 40
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 741

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 489
   level: 2, occurrence: 101
   level: 3, occurrence: 79
   level: 4, occurrence: 42
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 96
XXX number of pointers point to scalars: 129
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.7
XXX average alias set size: 1.27

XXX times a non-volatile is read: 1178
XXX times a non-volatile is write: 390
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 5

XXX stmts: 88
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 25
   depth: 2, occurrence: 15
   depth: 3, occurrence: 10
   depth: 4, occurrence: 5
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 13.5
XXX percentage an existing variable is used: 86.5
********************* end of statistics **********************/

