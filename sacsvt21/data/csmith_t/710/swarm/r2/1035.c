/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2557095160
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 10;
   unsigned f1 : 23;
   signed f2 : 29;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
inline static struct S0 * func_7(uint32_t  p_8, struct S0 * p_9, uint16_t  p_10, uint16_t  p_11, int32_t  p_12);
inline static int16_t  func_25(int32_t  p_26, struct S0  p_27, uint32_t  p_28, struct S0 * p_29);
inline static struct S0  func_30(struct S0  p_31, struct S0 * p_32, struct S0 * p_33, float  p_34);
static struct S0 * func_35(struct S0 * p_36, uint16_t  p_37);
inline static int8_t  func_41(struct S0 * p_42, struct S0 * p_43, struct S0 * p_44, int32_t  p_45, int16_t  p_46);
inline static struct S0 * func_47(int32_t  p_48);
static float  func_53(int64_t  p_54, struct S0 * p_55, struct S0  p_56);
static struct S0 * func_57(struct S0 * p_58, int32_t  p_59, struct S0 * p_60);
static int32_t  func_61(uint64_t  p_62);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x7A7C2039L;
    struct S0 l_18 = {8,911,2294};
    struct S0 *l_17 = &l_18;
    struct S0 **l_361 = &l_17;
    struct S0 ***l_360 = &l_361;
    struct S0 ****l_359 = &l_360;
    struct S0 *****l_358 = &l_359;
    int32_t *l_373 = &l_2;
    int32_t **l_372 = &l_373;
    int8_t l_390 = (-1L);
    uint32_t l_396 = 0x5FDFF8A2L;
    int32_t l_408 = 0x1FA34B62L;
    int32_t l_440 = 1L;
    int32_t l_473 = 0L;
    int32_t *l_541 = &l_2;
    int32_t l_552 = (-8L);
    for (l_2 = 0; (l_2 >= 22); l_2 = safe_add_func_int64_t_s_s(l_2, 8))
    { /* block id: 3 */
        uint32_t l_13 = 4294967293UL;
        int32_t l_395 = 0x9F6DA062L;
        int32_t *l_394 = &l_395;
        struct S0 *l_402 = &l_18;
        struct S0 ***l_404 = &l_361;
        uint32_t l_476 = 4294967295UL;
        int32_t *l_542 = &l_408;
        float l_545 = (-0x10.9p-1);
        float *l_544 = &l_545;
        float **l_543 = &l_544;
        float ***l_546 = &l_543;
    }
    if ((*l_541))
    { /* block id: 194 */
        struct S0 l_547 = {-22,1957,17988};
        (**l_361) = l_547;
    }
    else
    { /* block id: 196 */
        int32_t *l_548 = &l_473;
        (*l_372) = l_548;
    }
    (*****l_358) = func_30(func_30(func_30((***l_360), (*l_361), (****l_358), (safe_add_func_float_f_f(((**l_372) != (&l_372 == &l_372)), (!0xC.1D2ECAp+89)))), (*l_361), (****l_358), (**l_372)), (**l_360), (**l_360), (**l_372));
    return l_552;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_7(uint32_t  p_8, struct S0 * p_9, uint16_t  p_10, uint16_t  p_11, int32_t  p_12)
{ /* block id: 109 */
    struct S0 l_352 = {26,1826,-2755};
    struct S0 *l_351 = &l_352;
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_25(int32_t  p_26, struct S0  p_27, uint32_t  p_28, struct S0 * p_29)
{ /* block id: 5 */
    struct S0 l_40 = {11,854,9039};
    struct S0 *l_39 = &l_40;
    int32_t l_349 = 0L;
    int32_t *l_348 = &l_349;
    int32_t **l_347 = &l_348;
    int64_t l_350 = 0xA84E41F5C7FB6934LL;
    (*l_39) = func_30((*p_29), (p_26 , func_35(((~(l_39 != (func_41(func_47((safe_add_func_uint16_t_u_u((l_40.f0 & 0xCD908FBDEDBEC151LL), ((((safe_sub_func_float_f_f(func_53(p_27.f0, func_57(&l_40, ((func_61(l_40.f0) >= l_40.f2) > p_27.f1), &l_40), (*l_39)), l_40.f2)) , p_27.f0) == l_40.f2) && l_40.f0)))), &l_40, &l_40, l_40.f2, p_28) , &l_40))) , &p_27), l_40.f0)), &l_40, p_27.f1);
    (*l_39) = (*p_29);
    (*l_39) = (*p_29);
    (*l_39) = func_30((*p_29), func_57(func_47((safe_mod_func_int32_t_s_s((((safe_mod_func_uint64_t_u_u((safe_lshift_func_uint16_t_u_u((((l_40.f0 == (((safe_rshift_func_uint16_t_u_s(p_26, 12)) == 0xC9FEL) != (safe_add_func_int16_t_s_s(0xA519L, (safe_add_func_int32_t_s_s((((safe_add_func_uint64_t_u_u((safe_rshift_func_int16_t_s_u((l_347 == (void*)0), ((((((((*l_39) , (*l_39)) , (*l_348)) & l_350) ^ 0xC804988CL) && 1UL) && 0x55E22E59L) ^ p_27.f0))), 0x392BCE6465222BB7LL)) ^ 0xCE8A82D6L) | (**l_347)), (**l_347))))))) || (**l_347)) > p_26), 8)), 0x9FC5A764A5F26233LL)) ^ 0x8D430450L) > (**l_347)), (-1L)))), (**l_347), &l_40), &l_40, (*l_348));
    return p_26;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_30(struct S0  p_31, struct S0 * p_32, struct S0 * p_33, float  p_34)
{ /* block id: 48 */
    uint16_t l_130 = 0x7219L;
    uint64_t l_145 = 18446744073709551606UL;
    uint32_t l_148 = 9UL;
    struct S0 *l_152 = (void*)0;
    struct S0 **l_151 = &l_152;
    struct S0 **l_153 = &l_152;
    float l_155 = 0xD.3813E0p+26;
    float *l_154 = &l_155;
    float *l_158 = &l_155;
    int32_t l_161 = 0xDFBEF98CL;
    struct S0 l_171 = {-8,633,17975};
    struct S0 ***l_177 = &l_153;
    struct S0 ****l_176 = &l_177;
    uint16_t l_178 = 0UL;
    int32_t *l_180 = &l_161;
    int32_t **l_179 = &l_180;
    float *l_182 = &l_155;
    float *l_183 = (void*)0;
    uint32_t l_193 = 18446744073709551615UL;
    float *l_196 = &l_155;
    float *l_197 = (void*)0;
    int16_t l_233 = 1L;
    uint32_t l_240 = 8UL;
    int64_t l_262 = (-8L);
    int32_t *l_296 = (void*)0;
    (*l_154) = (((((safe_sub_func_int32_t_s_s(l_130, l_130)) , (safe_sub_func_int64_t_s_s(l_130, ((safe_add_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((safe_add_func_uint64_t_u_u(l_130, (safe_rshift_func_int16_t_s_u((safe_add_func_uint64_t_u_u((safe_lshift_func_int16_t_s_s(l_145, 5)), (l_130 ^ (((l_145 , ((safe_sub_func_int32_t_s_s(l_148, (safe_sub_func_int32_t_s_s((((l_151 != l_153) ^ l_145) , (-5L)), l_145)))) <= p_31.f1)) , (void*)0) == (void*)0)))), l_145)))), (-3L))), (-7L))) ^ 1UL)))) == p_31.f2) , (-0x1.5p-1)) != 0x6.Fp+1);
    (*l_179) = ((((0xA95DL >= (safe_add_func_int16_t_s_s(((((void*)0 == l_158) , ((safe_sub_func_int64_t_s_s(l_161, 1UL)) > (safe_add_func_int64_t_s_s((safe_lshift_func_int16_t_s_u((safe_sub_func_uint64_t_u_u((~((safe_lshift_func_uint16_t_u_s((((l_171 , 0x71F1E863L) , (safe_lshift_func_uint16_t_u_u(((((((safe_mod_func_int64_t_s_s(((&p_31 == (((void*)0 != l_176) , &p_31)) ^ p_31.f0), p_31.f1)) && l_130) <= l_178) , 0x11236520L) > l_130) < p_31.f0), l_171.f0))) != p_31.f1), 15)) || l_171.f0)), (-5L))), 3)), p_31.f2)))) ^ p_31.f0), 0x9A7CL))) && 0x86610161L) >= l_171.f0) , &l_161);
    (*l_180) = ((+((0xC5D88C5394159496LL ^ (**l_179)) | (p_31.f1 , (l_182 != l_183)))) != (safe_add_func_uint16_t_u_u((safe_add_func_uint64_t_u_u((~(safe_mod_func_int64_t_s_s((**l_179), (safe_sub_func_int32_t_s_s(l_193, p_31.f1))))), (safe_add_func_int32_t_s_s((((*p_33) , l_196) == l_197), 0x67A8BF02L)))), (**l_179))));
    for (l_145 = 0; (l_145 < 47); l_145 = safe_add_func_int32_t_s_s(l_145, 1))
    { /* block id: 54 */
        int32_t *l_200 = &l_161;
        struct S0 l_205 = {-19,32,-1807};
        int32_t l_206 = 0xD63A6EC5L;
        struct S0 *****l_216 = &l_176;
        uint32_t l_232 = 18446744073709551609UL;
        int64_t l_252 = 0L;
        uint16_t l_328 = 65535UL;
        uint64_t l_329 = 1UL;
        (*l_179) = l_200;
        for (l_130 = (-21); (l_130 > 6); l_130 = safe_add_func_uint16_t_u_u(l_130, 5))
        { /* block id: 58 */
            for (l_178 = 0; (l_178 >= 5); l_178++)
            { /* block id: 61 */
                (*p_32) = l_205;
                if (l_206)
                    break;
            }
        }
        if ((safe_unary_minus_func_uint32_t_u((~((safe_mod_func_uint64_t_u_u((((safe_rshift_func_uint16_t_u_s((safe_sub_func_uint16_t_u_u((+((((p_31.f0 >= (l_216 == l_216)) ^ 0xD1A421FDF78E13ECLL) ^ (((0x7.9C6CBEp-50 >= p_34) , (-9L)) , (safe_mod_func_uint16_t_u_u(((((l_200 == l_200) >= (*l_180)) == (*l_200)) && 0x940A6EEA41B15C3DLL), (**l_179))))) && p_31.f1)), 65535UL)), (*l_200))) >= 0x3112E05E15677DB3LL) , p_31.f0), (*l_200))) == (*l_200))))))
        { /* block id: 66 */
            struct S0 l_219 = {2,1599,3310};
            float *l_242 = &l_155;
            uint64_t l_243 = 0xF7C837AE32BB3065LL;
            struct S0 *****l_244 = &l_176;
            uint64_t l_271 = 18446744073709551610UL;
            (*l_179) = &l_206;
            if ((((l_219 , (65535UL ^ ((((((safe_add_func_int64_t_s_s(0L, ((safe_rshift_func_uint16_t_u_s(((safe_add_func_int32_t_s_s(p_31.f2, (safe_sub_func_uint32_t_u_u(p_31.f1, ((safe_lshift_func_int16_t_s_s(((*l_216) == (void*)0), 14)) == (((safe_rshift_func_int16_t_s_s(1L, 10)) != (*l_180)) < p_31.f1)))))) , 0xD8A3L), 11)) != p_31.f0))) > p_31.f0) < p_31.f2) ^ (*l_200)) | p_31.f2) ^ (-1L)))) != l_232) < l_233))
            { /* block id: 68 */
                float *l_241 = &l_155;
                (*l_200) = ((((((+((l_219.f1 | ((((safe_mod_func_uint16_t_u_u(((((*l_200) , ((((*l_180) || ((((((~((0x57983243L != 1L) > (((((safe_rshift_func_int16_t_s_u(0x8F16L, ((p_31.f2 != l_240) < 0xCFDD99D97B6011EDLL))) , l_241) == l_242) > p_31.f1) <= p_31.f1))) , (void*)0) == &p_32) != 0x0F1C8372L) , 0L) , p_31.f0)) ^ l_243) >= p_31.f2)) != (*l_200)) | 0xD219E0C1L), p_31.f2)) ^ p_31.f1) < 7L) != p_31.f2)) && l_243)) > 1L) ^ p_31.f1) >= p_31.f1) && 1L) , p_31.f2);
            }
            else
            { /* block id: 70 */
                (**l_179) = 0x0736A644L;
                (*p_33) = l_219;
                (*l_154) = 0xA.785C46p-36;
            }
            if (p_31.f1)
            { /* block id: 75 */
                l_244 = l_216;
                (*l_216) = &l_177;
            }
            else
            { /* block id: 78 */
                int32_t *l_245 = &l_206;
                (*l_179) = l_245;
            }
            if ((((((((safe_mod_func_uint64_t_u_u((safe_add_func_uint16_t_u_u(((safe_add_func_uint64_t_u_u((((&l_176 != l_244) && (((*p_33) , (**l_216)) == (*l_176))) , p_31.f0), (l_200 == l_242))) < (p_31.f1 , l_219.f0)), p_31.f1)), l_252)) , (*l_180)) <= 0x3E99L) > (**l_179)) , (void*)0) == (void*)0) , (*l_200)))
            { /* block id: 81 */
                int64_t l_267 = 0xCDFA422619962E55LL;
                int32_t *l_269 = &l_161;
                struct S0 *l_270 = &l_219;
                uint32_t l_272 = 18446744073709551615UL;
                for (l_240 = 14; (l_240 == 54); l_240 = safe_add_func_uint64_t_u_u(l_240, 1))
                { /* block id: 84 */
                    int32_t *l_268 = &l_161;
                    struct S0 l_273 = {-20,1586,-10188};
                    (*l_180) = ((((safe_add_func_int32_t_s_s(((((safe_unary_minus_func_uint32_t_u((safe_sub_func_int16_t_s_s((safe_add_func_uint32_t_u_u(p_31.f0, l_262)), ((safe_rshift_func_uint16_t_u_u(((((((*l_180) , 0xD3BCL) ^ (safe_add_func_int32_t_s_s((l_267 , ((l_268 == (l_219.f0 , l_269)) & p_31.f1)), p_31.f1))) , p_31.f0) , l_270) == (void*)0), 12)) >= 0x7BFAL))))) == 18446744073709551611UL) >= 0x26830DA417DDE3D0LL) , 0xA6240548L), p_31.f2)) > l_271) <= (**l_179)) , l_272);
                    (*p_32) = (*p_33);
                    l_268 = (*l_179);
                    return l_273;
                }
            }
            else
            { /* block id: 90 */
                return (*p_33);
            }
        }
        else
        { /* block id: 93 */
            int8_t l_278 = 0L;
            struct S0 ****l_310 = (void*)0;
            if (((((void*)0 == &l_206) , p_31.f1) != (safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s(((*l_180) | ((void*)0 == &l_206)), (((((((l_278 && (((((((safe_mod_func_uint32_t_u_u(p_31.f1, 0x74D8FE96L)) > 2L) && 4294967290UL) == (-3L)) , p_31.f0) , (*l_200)) , 4UL)) <= (**l_179)) ^ p_31.f0) ^ (*l_200)) , (***l_216)) != (void*)0) <= p_31.f0))), 14))))
            { /* block id: 94 */
                uint64_t l_289 = 18446744073709551612UL;
                struct S0 **l_309 = &l_152;
                struct S0 ****l_317 = &l_177;
                (*l_196) = (l_278 >= (((safe_add_func_float_f_f(((safe_mod_func_int16_t_s_s((safe_add_func_int16_t_s_s(l_278, (safe_add_func_uint32_t_u_u(p_31.f0, l_289)))), (safe_add_func_uint64_t_u_u(((((p_31.f2 >= (((-0x1.Dp-1) <= (safe_add_func_float_f_f(l_278, 0xA.76463Cp-69))) , ((safe_mod_func_int16_t_s_s(((*p_32) , l_289), l_278)) & p_31.f1))) <= 0x657F93D7C05EB809LL) , (void*)0) == l_296), (*l_200))))) , p_31.f0), (*l_200))) >= 0x0.Bp+1) >= (*l_200)));
                (*l_180) = (safe_rshift_func_int16_t_s_s(((((*l_200) == (((safe_rshift_func_int16_t_s_s((((safe_lshift_func_int16_t_s_u(l_289, ((((((((p_31.f0 != (((safe_lshift_func_int16_t_s_s((((((((*l_176) != (void*)0) ^ (((safe_add_func_uint32_t_u_u(((&l_176 != ((p_31.f2 | (safe_rshift_func_uint16_t_u_u(l_278, 8))) , &l_176)) != 0x14E27A1FL), (*l_180))) > p_31.f2) && p_31.f0)) , 0L) > 0L) , (void*)0) != l_309), 15)) , (*l_216)) != l_310)) == 0xB535A2EF250DD05DLL) , 4294967290UL) , 0xC105L) > 0xCDBFL) >= p_31.f1) ^ (-6L)) & 0xC90DD8B250B62747LL))) < p_31.f0) <= p_31.f0), p_31.f2)) > p_31.f2) > (**l_179))) && 0xA1E79B97L) >= 0x0F7FBA5C353FD0BALL), p_31.f0));
                (*l_196) = (safe_sub_func_float_f_f((((safe_add_func_float_f_f(((safe_add_func_float_f_f(((void*)0 != l_317), (((0xD.C71321p-83 >= (*l_180)) == (((l_289 <= (((void*)0 == (**l_317)) <= ((-(((safe_add_func_float_f_f((((safe_sub_func_float_f_f(((safe_sub_func_float_f_f((((((p_31.f1 , ((((((+((safe_add_func_float_f_f(p_31.f0, 0x6.CD4180p-3)) != l_328)) > 0xC.570C8Bp+29) <= 0x3.5AF9E5p-2) <= (-0x1.Cp-1)) == l_289) != p_31.f2)) >= 0x6.FB5A1Bp-90) > (*l_200)) < p_34) >= p_31.f0), p_31.f1)) < p_31.f2), l_278)) <= p_31.f2) >= p_31.f1), l_329)) > 0xD.F4A2D3p-89) < (-0x5.Ep-1))) != p_31.f2))) , p_31.f1) <= 0x7.EE52D0p+48)) < (*l_200)))) != p_31.f1), p_34)) >= l_289) > 0x7.5BEFB0p-98), (*l_200)));
            }
            else
            { /* block id: 98 */
                int32_t *l_330 = &l_206;
                (*l_179) = l_330;
            }
        }
    }
    return (*p_32);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_35(struct S0 * p_36, uint16_t  p_37)
{ /* block id: 46 */
    struct S0 l_127 = {19,2487,-4129};
    struct S0 *l_126 = &l_127;
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_41(struct S0 * p_42, struct S0 * p_43, struct S0 * p_44, int32_t  p_45, int16_t  p_46)
{ /* block id: 43 */
    struct S0 *l_123 = (void*)0;
    struct S0 **l_124 = &l_123;
    float l_125 = 0x0.DFF459p+1;
    (*l_124) = l_123;
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_47(int32_t  p_48)
{ /* block id: 39 */
    int32_t l_106 = 0x558EF108L;
    int32_t *l_105 = &l_106;
    int32_t **l_107 = &l_105;
    struct S0 l_111 = {23,1657,12720};
    struct S0 *l_110 = &l_111;
    struct S0 **l_109 = &l_110;
    struct S0 ***l_108 = &l_109;
    struct S0 *l_120 = &l_111;
    struct S0 *l_121 = &l_111;
    struct S0 *l_122 = (void*)0;
    (*l_107) = l_105;
    (**l_107) = (((((((**l_107) , l_108) != &l_109) <= p_48) ^ (safe_add_func_uint64_t_u_u((safe_mod_func_int32_t_s_s(1L, (safe_add_func_int16_t_s_s((*l_105), (**l_107))))), ((safe_rshift_func_int16_t_s_u(0x7558L, 5)) , (p_48 >= p_48))))) == p_48) > (**l_107));
    return l_122;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_53(int64_t  p_54, struct S0 * p_55, struct S0  p_56)
{ /* block id: 14 */
    int32_t l_78 = (-9L);
    int32_t l_79 = 1L;
    struct S0 **l_90 = (void*)0;
    struct S0 ***l_89 = &l_90;
    struct S0 ****l_88 = &l_89;
    int8_t l_104 = 0x1DL;
    for (p_54 = 0; (p_54 == (-20)); p_54--)
    { /* block id: 17 */
        float l_73 = 0x0.Dp+1;
        float *l_72 = &l_73;
        int32_t l_77 = 0x79AB6733L;
        int32_t *l_76 = &l_77;
        (*l_72) = 0x0.4p-1;
        (*l_76) = (safe_lshift_func_uint16_t_u_u(p_54, 5));
    }
    if ((((-7L) > (p_54 < (l_78 == l_78))) && l_79))
    { /* block id: 21 */
        int16_t l_98 = (-1L);
        int32_t *l_99 = &l_79;
        for (l_78 = 0; (l_78 != (-27)); l_78--)
        { /* block id: 24 */
            int32_t *l_83 = &l_79;
            int32_t **l_82 = &l_83;
            struct S0 l_87 = {18,2418,-18351};
            struct S0 *l_86 = &l_87;
            struct S0 **l_85 = &l_86;
            struct S0 ***l_84 = &l_85;
            struct S0 *****l_91 = &l_88;
            (*l_82) = &l_78;
            (*l_84) = (void*)0;
            (*l_91) = l_88;
            for (p_54 = (-26); (p_54 != (-10)); p_54 = safe_add_func_uint64_t_u_u(p_54, 8))
            { /* block id: 30 */
                uint16_t l_100 = 8UL;
                uint32_t l_101 = 0xA7AF0C8BL;
                if (l_79)
                    break;
                l_101 = ((safe_unary_minus_func_int16_t_s((-6L))) && (p_54 , (((!((safe_lshift_func_uint16_t_u_s(p_56.f2, 7)) < l_98)) , p_54) | (((p_56.f0 != ((void*)0 != l_99)) != l_100) > (-10L)))));
            }
        }
    }
    else
    { /* block id: 35 */
        int32_t *l_103 = &l_78;
        int32_t **l_102 = &l_103;
        (*l_102) = &l_78;
    }
    return l_104;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_57(struct S0 * p_58, int32_t  p_59, struct S0 * p_60)
{ /* block id: 9 */
    int32_t l_66 = 0x4ECA6696L;
    int32_t *l_65 = &l_66;
    int32_t **l_67 = &l_65;
    struct S0 l_69 = {19,2514,-420};
    struct S0 *l_68 = &l_69;
    (*l_67) = l_65;
    (*l_67) = (void*)0;
    (*l_67) = (*l_67);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_61(uint64_t  p_62)
{ /* block id: 6 */
    struct S0 l_63 = {10,350,22794};
    struct S0 *l_64 = &l_63;
    (*l_64) = l_63;
    return l_63.f1;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 115
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 40
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 15
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 8
breakdown:
   indirect level: 0, occurrence: 8
XXX times a bitfields struct's address is taken: 27
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 96

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 9
   depth: 5, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 2
   depth: 22, occurrence: 3
   depth: 24, occurrence: 1
   depth: 30, occurrence: 1
   depth: 32, occurrence: 2
   depth: 34, occurrence: 1
   depth: 36, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 110

XXX times a variable address is taken: 116
XXX times a pointer is dereferenced on RHS: 135
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 51
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 64
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 6
   depth: 3, occurrence: 4
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 358

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 264
   level: 2, occurrence: 93
   level: 3, occurrence: 15
   level: 4, occurrence: 3
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 41
XXX number of pointers point to scalars: 39
XXX number of pointers point to structs: 30
XXX percent of pointers has null in alias set: 22.7
XXX average alias set size: 1.17

XXX times a non-volatile is read: 716
XXX times a non-volatile is write: 173
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 70
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 9
   depth: 2, occurrence: 10
   depth: 3, occurrence: 17
   depth: 4, occurrence: 4

XXX percentage a fresh-made variable is used: 16.4
XXX percentage an existing variable is used: 83.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

