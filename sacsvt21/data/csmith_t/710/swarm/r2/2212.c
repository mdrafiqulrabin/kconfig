/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      2944481218
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int16_t  f1;
   uint32_t  f2;
   unsigned f3 : 6;
   int32_t  f4;
   uint32_t  f5;
   int32_t  f6;
   uint32_t  f7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int16_t  func_3(int16_t  p_4, int32_t * p_5);
static struct S0  func_7(int32_t * p_8, int32_t * p_9, int32_t * p_10);
static int32_t * func_13(uint32_t  p_14);
static int32_t * func_18(int32_t  p_19, int32_t * p_20, uint32_t  p_21, int32_t  p_22, int32_t  p_23);
static uint16_t  func_24(int32_t * p_25, int32_t * p_26, int32_t  p_27, int32_t * p_28, int32_t * p_29);
static int32_t * func_30(int32_t * p_31, uint16_t  p_32, int32_t * p_33);
static int32_t * func_34(uint16_t  p_35, int32_t * p_36);
static uint32_t  func_39(uint32_t  p_40, int32_t * p_41, int32_t  p_42);
static int32_t * func_43(int32_t  p_44, int32_t * p_45, int32_t * p_46, int32_t * p_47);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 1;
    int32_t l_6 = 0xE86F8C7B;
    int32_t *l_699 = &l_6;
    int32_t **l_698 = &l_699;
    int32_t ***l_701 = &l_698;
    int32_t ****l_700 = &l_701;
    int32_t ****l_702 = (void*)0;
    uint16_t l_725 = 65535U;
    struct S0 l_728 = {5,-4,4294967295U,1,0x678845A2,0xE135FCC4,0x6415C089,4294967292U};
    struct S0 *l_727 = &l_728;
    struct S0 **l_726 = &l_727;
    struct S0 ***l_729 = &l_726;
    uint16_t l_730 = 0x7C95;
    (*l_698) = ((l_2 == func_3(l_6, &l_6)) , &l_6);
    (**l_701) = ((((l_700 != l_702) , (((int16_t)((((int16_t)(((uint16_t)(+((int16_t)((0xA1E7 != ((***l_701) , (-(int16_t)0x6EAD))) > ((uint32_t)((((uint16_t)(((int16_t)(((int16_t)((int16_t)((int32_t)(((((*l_699) > (((((1U | (**l_698)) , (****l_700)) , (*l_699)) < 0x2652) && (*l_699))) < (*l_699)) , 0x09E272C0) == (****l_700)) + (int32_t)0x300F635E) << (int16_t)2) - (int16_t)(*l_699)) & (****l_700)) * (int16_t)(*l_699)) && (*l_699)) << (uint16_t)(***l_701)) , 0x3DCB) >= (*l_699)) % (uint32_t)0x22E997EF)) * (int16_t)l_725)) >> (uint16_t)(**l_698)) && (**l_698)) >> (int16_t)9) , 7) && 4294967295U) >> (int16_t)4) != (-1))) | 65535U) , (void*)0);
    (*l_729) = l_726;
    (**l_701) = (***l_700);
    return l_730;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_3(int16_t  p_4, int32_t * p_5)
{ /* block id: 1 */
    int32_t l_12 = 0;
    int32_t *l_11 = &l_12;
    struct S0 l_679 = {-4,0x3983,0U,5,-8,1U,-1,4294967295U};
    struct S0 *l_678 = &l_679;
    int32_t **l_692 = &l_11;
    int32_t ***l_691 = &l_692;
    int32_t ****l_690 = &l_691;
    int32_t *****l_689 = &l_690;
    uint32_t l_697 = 4294967295U;
    (*l_678) = func_7(l_11, func_13(((void*)0 != p_5)), p_5);
    (*l_692) = func_34((+((((((uint16_t)((int16_t)((((((int16_t)(((&l_678 != (void*)0) == (0x7B12 & 0x183E)) != (((int16_t)(((void*)0 != l_689) , (((int16_t)(((((p_4 , (*l_689)) != (((int16_t)((((p_4 ^ (*l_11)) == 0x18523AFC) ^ 0x66D3) && (*****l_689)) - (int16_t)p_4) , (*l_689))) >= (*p_5)) != 0) < (****l_690)) << (int16_t)5) & 0x1545A6CF)) + (int16_t)6) , 0xEAB0)) << (int16_t)8) != (****l_690)) > (***l_691)) , (-10)) , (****l_690)) % (int16_t)p_4) - (uint16_t)p_4) && p_4) | (***l_691)) != l_697) || 1U)), (*l_692));
    return p_4;
}


/* ------------------------------------------ */
/* 
 * reads : l_6
 * writes: l_6
 */
static struct S0  func_7(int32_t * p_8, int32_t * p_9, int32_t * p_10)
{ /* block id: 210 */
    int16_t l_606 = 0;
    int32_t l_616 = 9;
    int32_t *l_615 = &l_616;
    int32_t **l_614 = &l_615;
    int32_t ***l_613 = &l_614;
    struct S0 **l_621 = (void*)0;
    int32_t ****l_657 = &l_613;
    int32_t *****l_656 = &l_657;
    struct S0 *****l_667 = (void*)0;
    struct S0 ****l_672 = (void*)0;
    struct S0 l_677 = {0x64106C4D,-5,1U,7,0xC22F00C5,0x84A3AF66,1,0xFD5AA545};
    if (((uint16_t)((l_606 | (0x84617000 == ((int32_t)((int16_t)((uint16_t)0x13EE + (uint16_t)((((l_613 == &l_614) < (**l_614)) , 0U) != ((uint16_t)((int32_t)0x4FED9E7D - (int32_t)(***l_613)) >> (uint16_t)(***l_613)))) + (int16_t)(*l_615)) - (int32_t)0))) <= 1) % (uint16_t)(**l_614)))
    { /* block id: 211 */
lbl_648:
        l_621 = l_621;
    }
    else
    { /* block id: 213 */
        int32_t l_622 = 1;
        struct S0 l_627 = {0x1E24DCD1,0x7BEF,0xEBA2B364,1,0,0xED5E364C,0x0F075044,9U};
        struct S0 ***l_638 = &l_621;
        struct S0 ***l_639 = (void*)0;
        if (l_622)
        { /* block id: 214 */
            int32_t ***l_628 = &l_614;
            struct S0 l_635 = {6,-5,4294967286U,5,0xDC1CC4B8,0x9DB2DB62,0x221DE4C9,0xF87A1B26};
            l_635 = (((((((int16_t)((uint16_t)(l_622 ^ (**l_614)) * (uint16_t)(((4294967291U | (((l_627 , ((l_628 != &l_614) , ((((uint16_t)0x1584 + (uint16_t)(((**l_614) , (((int32_t)((uint16_t)(***l_613) >> (uint16_t)(***l_613)) + (int32_t)8) < (***l_613))) != 0xD9EEE9BB)) | (*l_615)) ^ 65527U))) & 7U) == (*p_8))) >= l_627.f1) , (***l_613))) << (int16_t)6) , 0x1657BC1B) || 0x9130DBBA) & 1) & (***l_628)) , l_635);
        }
        else
        { /* block id: 216 */
            struct S0 l_636 = {0x0A844D71,0xFE25,0x8488AAEE,6,0x57C0B146,0x2A5FCED1,0x6099B5B9,0U};
            l_636 = l_636;
            return l_627;
        }
        (**l_613) = p_10;
        (*p_10) = 0x0C6ECF6A;
        (*p_10) = (+(l_638 != l_639));
    }
    for (l_616 = (-15); (l_616 <= 18); l_616 += 1)
    { /* block id: 226 */
        struct S0 l_645 = {0xCA4000A8,0x6DAC,0x32766264,5,0,1U,0x4AE0E502,0x2AEA2AEA};
        struct S0 *l_644 = &l_645;
        uint16_t l_655 = 0x5CD7;
        for (l_606 = 0; (l_606 <= 22); l_606 += 1)
        { /* block id: 229 */
            struct S0 **l_646 = &l_644;
            (*l_646) = l_644;
            (*p_8) = (+0);
            if (l_616)
                goto lbl_648;
            (**l_613) = (**l_613);
        }
        if ((((((uint16_t)((int16_t)((int16_t)(l_655 || 0xA90F) * (int16_t)((((void*)0 == l_656) | ((*****l_656) > ((uint16_t)(****l_657) << (uint16_t)6))) || 0xEBE1EA08)) << (int16_t)((((*l_614) == (((*****l_656) != (*****l_656)) , p_8)) | 0x966C) < (-1))) * (uint16_t)0x1205) <= 0x6043) ^ l_645.f7) ^ l_645.f4))
        { /* block id: 235 */
            int32_t l_664 = 0xBE6D68A1;
            struct S0 l_675 = {-1,0x8730,4294967294U,4,0x1299352B,3U,0x5F351B24,0x61BD9FEB};
            (*p_10) = ((int32_t)(((((int32_t)(1 & (l_664 , (0x3491 <= ((6U || (0xA13E59E6 < (((uint16_t)(l_667 == l_667) % (uint16_t)((uint16_t)((uint16_t)(l_672 != (((uint16_t)(0x66883669 ^ l_664) << (uint16_t)7) , (void*)0)) - (uint16_t)l_655) - (uint16_t)l_645.f1)) >= l_645.f2))) == 0x1655)))) + (int32_t)1) == 0xECE66188) != l_664) != (**l_614)) + (int32_t)(*p_10));
            return l_675;
        }
        else
        { /* block id: 238 */
            int32_t l_676 = 4;
            l_676 = ((void*)0 != &p_9);
        }
        p_10 = p_10;
    }
    (***l_657) = p_10;
    (*****l_656) = (**l_614);
    return l_677;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_13(uint32_t  p_14)
{ /* block id: 2 */
    int32_t l_16 = (-1);
    int32_t *l_15 = &l_16;
    int32_t *l_17 = (void*)0;
    int32_t **l_595 = &l_15;
    int32_t ***l_597 = &l_595;
    int32_t ****l_596 = &l_597;
    int32_t *****l_598 = &l_596;
    int32_t *l_601 = (void*)0;
    (*l_595) = ((l_15 != l_17) , func_18(p_14, &l_16, (1 | ((func_24(&l_16, func_30(&l_16, p_14, func_34((((int16_t)(func_39(((p_14 <= (-8)) , (*l_15)), &l_16, (*l_15)) ^ p_14) >> (int16_t)p_14) >= p_14), l_15)), p_14, l_15, l_17) > p_14) , (*l_15))), p_14, p_14));
    (*l_598) = l_596;
    l_16 = (-(uint16_t)(~p_14));
    return l_601;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_18(int32_t  p_19, int32_t * p_20, uint32_t  p_21, int32_t  p_22, int32_t  p_23)
{ /* block id: 85 */
    uint16_t l_297 = 0x5419;
    uint16_t l_385 = 65526U;
    int32_t ***l_394 = (void*)0;
    int32_t ****l_393 = &l_394;
    int32_t *****l_392 = &l_393;
    uint32_t l_400 = 0U;
    struct S0 l_446 = {0x1DF950FD,0xE4C7,0x42BB3138,2,0xA2298363,0x95F7AF6C,0x7839F555,3U};
    int32_t *l_525 = &l_446.f0;
    struct S0 *l_554 = (void*)0;
    struct S0 **l_553 = &l_554;
    struct S0 ***l_585 = &l_553;
    struct S0 ****l_584 = &l_585;
    int32_t *l_590 = (void*)0;
    for (p_23 = 0; (p_23 != (-22)); --p_23)
    { /* block id: 88 */
        uint32_t l_296 = 0U;
        struct S0 l_302 = {8,0x7350,0U,3,0x25B64AA4,4294967290U,-1,0x88CFFDCC};
        struct S0 *l_301 = &l_302;
        struct S0 **l_300 = &l_301;
        int32_t *l_349 = (void*)0;
        struct S0 l_412 = {0,0xF0C8,0x8F2EFBFA,4,0,4294967295U,0xAD737972,0xCF76A16C};
        int32_t *l_415 = &l_302.f0;
        uint16_t l_443 = 0x1AA7;
        uint32_t l_444 = 0U;
        int32_t **l_459 = &l_349;
        int32_t ***l_458 = &l_459;
        uint16_t l_473 = 65535U;
        int32_t *****l_514 = &l_393;
    }
    for (l_446.f1 = (-20); (l_446.f1 < 24); l_446.f1 += 7)
    { /* block id: 194 */
        int32_t l_581 = 1;
        if (l_581)
            break;
    }
    for (p_21 = 9; (p_21 > 34); p_21 += 1)
    { /* block id: 199 */
        struct S0 *****l_586 = &l_584;
        struct S0 l_587 = {0x43E9F32E,0x02F6,0U,4,0xF8A1314A,0xECE526F1,0,0x1BD1179D};
        struct S0 *l_588 = (void*)0;
        int32_t *l_589 = &l_446.f0;
        (*l_586) = l_584;
        l_587 = l_587;
        return l_590;
    }
    (*l_525) = ((int16_t)((((uint16_t)(*l_525) * (uint16_t)(((p_21 , &l_393) == (void*)0) , (p_19 >= (((0x646E == (((*p_20) <= (*p_20)) , 4U)) && (*p_20)) ^ 0xCFA1)))) , (*l_553)) == (void*)0) - (int16_t)(*l_525));
    return l_590;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_24(int32_t * p_25, int32_t * p_26, int32_t  p_27, int32_t * p_28, int32_t * p_29)
{ /* block id: 39 */
    uint32_t l_115 = 5U;
    struct S0 l_116 = {-5,0x2906,3U,7,0x2EA2622D,0U,1,0x1B4A57D0};
    int32_t *l_155 = &l_116.f0;
    int32_t **l_154 = &l_155;
    int32_t ***l_153 = &l_154;
    int32_t ****l_152 = &l_153;
    struct S0 *l_182 = &l_116;
    struct S0 **l_181 = &l_182;
    struct S0 ***l_180 = &l_181;
    uint32_t l_186 = 0xEAB87D12;
    uint16_t l_292 = 0x069D;
    int32_t l_293 = 0x1615A0E3;
    for (p_27 = 3; (p_27 >= (-22)); --p_27)
    { /* block id: 42 */
        int16_t l_125 = 0xACB7;
        int32_t *l_131 = (void*)0;
        int16_t l_133 = 0xEE1B;
        uint32_t l_135 = 0xFA604D7D;
        int32_t ***l_156 = &l_154;
        int32_t l_194 = 0xC10FD6D6;
        struct S0 l_210 = {0xF12E359E,0x1609,6U,7,0,0x6BBE48DE,0x3D4CEE25,4294967295U};
        struct S0 l_219 = {0x68A41854,-1,0xA50DD6F6,6,0xB393109E,0U,0x7B9CB57D,1U};
        if (((uint16_t)((uint16_t)l_115 % (uint16_t)((*p_28) & (l_116 , ((int32_t)(((uint16_t)l_116.f4 - (uint16_t)((int32_t)(0xA18BD6C3 > ((uint16_t)(l_125 <= (l_125 >= 0xB94001E8)) >> (uint16_t)((p_27 != p_27) , p_27))) - (int32_t)l_116.f3)) , l_116.f6) + (int32_t)l_116.f7)))) + (uint16_t)1))
        { /* block id: 43 */
            int32_t **l_132 = &l_131;
            (*p_25) = (*p_25);
            for (l_116.f2 = 0; (l_116.f2 == 16); l_116.f2 += 1)
            { /* block id: 47 */
                int32_t *l_129 = &l_116.f0;
                int32_t **l_128 = &l_129;
                l_116.f0 = l_116.f5;
                if ((*p_28))
                    break;
                (*l_128) = func_34(p_27, p_26);
                (*p_28) = ((!65530U) || 0xD8AA);
            }
            (*l_132) = l_131;
        }
        else
        { /* block id: 54 */
            uint32_t l_134 = 2U;
            int32_t ***l_166 = (void*)0;
            struct S0 l_167 = {0x7DB8501E,0xE482,0x5A9511BF,2,6,4294967287U,0xA08780BA,1U};
            struct S0 ***l_189 = (void*)0;
            int32_t l_211 = 0xAF810B9F;
            uint16_t l_214 = 1U;
            int32_t l_254 = 0x9730AFC9;
            int32_t l_273 = 1;
            (*p_25) = ((l_133 , l_134) , l_135);
            if ((((((((uint16_t)((1 == l_116.f0) > l_116.f3) % (uint16_t)((int16_t)((((uint16_t)(((((int16_t)((uint16_t)p_27 - (uint16_t)((((uint16_t)(p_27 < ((int16_t)p_27 << (int16_t)((void*)0 != l_152))) << (uint16_t)10) > ((((l_134 & 0x8F730D72) , l_156) != (void*)0) | p_27)) || (*p_25))) >> (int16_t)p_27) > p_27) > 0) == (*p_28)) * (uint16_t)0xBEE1) , 1) <= p_27) % (int16_t)l_134)) == (***l_156)) & 0x7D6BF538) , &p_29) == (void*)0) > 1))
            { /* block id: 56 */
                int32_t l_165 = 0x71A10681;
                int32_t ***l_168 = (void*)0;
                int32_t l_183 = 0x14AA5802;
                (*p_25) = ((uint16_t)(((((uint16_t)((int32_t)(((int32_t)l_165 % (int32_t)0x6BFB62AB) || (l_166 == l_166)) % (int32_t)(***l_153)) << (uint16_t)2) < l_165) , (*l_152)) == (l_167 , l_168)) * (uint16_t)(**l_154));
                l_186 = (((uint16_t)(((((int16_t)(***l_156) >> (int16_t)((((!((((uint16_t)((((((uint32_t)(((int16_t)p_27 >> (int16_t)15) < ((p_27 & (&l_156 == (void*)0)) >= (l_180 == (void*)0))) - (uint32_t)l_183) < ((uint16_t)0x4435 << (uint16_t)p_27)) <= p_27) || 0xAB6F4D31) < (***l_156)) >> (uint16_t)p_27) , (***l_156)) , 0)) > (***l_156)) < 0xB79EC1F0) , 0xF1CC)) < 8U) >= 0x69D2D949) < (*p_26)) - (uint16_t)0U) > 0x18BE7EDE);
                if (((int16_t)(****l_152) >> (int16_t)15))
                { /* block id: 59 */
                    int32_t ****l_199 = &l_156;
                    struct S0 l_243 = {0x5180EF6E,-1,0U,2,0x921FCF26,0x1F28254A,4,0xE2EE7AB0};
                    uint32_t l_255 = 0xB7011B64;
                    if (((void*)0 == l_189))
                    { /* block id: 60 */
                        int32_t ****l_201 = &l_156;
                        (****l_152) = (-10);
                        (*p_25) = ((((((int16_t)(-1) << (int16_t)(*l_155)) != (((****l_152) ^ ((((*p_28) > ((uint16_t)((***l_153) <= ((p_27 , &p_25) != (*l_153))) * (uint16_t)((((void*)0 == &l_181) != p_27) < p_27))) != (*p_25)) ^ 4294967295U)) , l_194)) && 65535U) >= 0x5ABFE8D4) != p_27);
                        (*p_25) = (((((int16_t)((((int16_t)p_27 << (int16_t)2) , l_199) == ((~(****l_199)) , l_201)) + (int16_t)(((int16_t)(((uint16_t)1U << (uint16_t)5) | 0xDC01900F) << (int16_t)((int32_t)((int32_t)0x3EFAEFD5 - (int32_t)(l_210 , (((*p_26) < 4294967295U) >= (****l_199)))) + (int32_t)(*p_26))) && p_27)) , (*p_26)) >= (***l_156)) < (****l_199));
                        (*p_28) = (p_27 & ((l_211 & ((int32_t)l_214 % (int32_t)((int32_t)((int16_t)((l_219 , l_210) , (****l_201)) % (int16_t)((uint16_t)((uint16_t)(~((p_27 && ((0xF31A84B0 | (*p_25)) ^ p_27)) <= (***l_156))) >> (uint16_t)12) * (uint16_t)0x9658)) - (int32_t)0x796E714B))) | 8));
                    }
                    else
                    { /* block id: 65 */
                        (****l_152) = (0x442BEC65 < (((((int16_t)((uint16_t)((int16_t)p_27 >> (int16_t)1) >> (uint16_t)7) - (int16_t)((uint16_t)((uint32_t)p_27 + (uint32_t)((int32_t)(*p_26) % (int32_t)((uint32_t)(0xA634 <= ((((*p_26) || (****l_199)) == ((uint32_t)0U + (uint32_t)((((int16_t)0 << (int16_t)1) || p_27) != l_167.f1))) && 0x2F2D)) - (uint32_t)p_27))) >> (uint16_t)8)) > p_27) >= 8) >= (*p_26)));
                    }
                    if ((*p_25))
                        break;
                    (*l_182) = l_243;
                    (***l_156) = (l_243 , ((*p_26) <= ((0x5D2E55EC | ((((int16_t)(((((*l_153) == (*l_156)) ^ ((int32_t)((int16_t)((int16_t)((((uint16_t)(***l_153) >> (uint16_t)15) ^ ((l_166 == l_156) || (****l_152))) | p_27) + (int16_t)0x2537) % (int16_t)0xDE48) + (int32_t)(***l_156))) , 4294967286U) <= l_254) >> (int16_t)p_27) , 0x5ED8) & p_27)) || l_255)));
                }
                else
                { /* block id: 71 */
                    struct S0 ***l_272 = &l_181;
                    int32_t l_274 = 0x6647A815;
                    int32_t l_275 = 0x14FACFC0;
                    (***l_152) = func_43((***l_156), (((((uint16_t)(((uint32_t)p_27 - (uint32_t)1U) && ((p_27 , l_167.f4) <= ((***l_156) < 0x04F61015))) + (uint16_t)(((uint16_t)((int32_t)(((uint16_t)((int32_t)((((uint32_t)(0x8B5B6B9B == (l_272 == (void*)0)) - (uint32_t)(*p_25)) , 0x244CA97F) , (*p_28)) - (int32_t)l_273) * (uint16_t)0U) || 0x44E5) + (int32_t)(***l_156)) - (uint16_t)p_27) & l_274)) <= (*p_25)) >= l_275) , &l_254), (***l_152), (***l_152));
                }
            }
            else
            { /* block id: 74 */
                (**l_153) = (**l_156);
            }
            if ((*p_25))
                break;
        }
        l_210.f0 = (((int16_t)p_27 << (int16_t)p_27) > ((uint32_t)((uint16_t)(0xBCBD33C9 && ((((uint16_t)0x9A56 << (uint16_t)(((int32_t)((uint16_t)(((-10) >= ((uint16_t)(((0x648C3C27 <= ((((p_27 < ((((uint32_t)l_292 + (uint32_t)p_27) , p_27) < (-1))) <= p_27) > 1U) < p_27)) != (*p_28)) < p_27) << (uint16_t)p_27)) <= 4294967288U) << (uint16_t)p_27) + (int32_t)(*p_25)) | p_27)) >= 3) != (*p_28))) << (uint16_t)p_27) % (uint32_t)(*p_28)));
        return p_27;
    }
    (*l_181) = (*l_181);
    (*l_154) = (void*)0;
    return l_293;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(int32_t * p_31, uint16_t  p_32, int32_t * p_33)
{ /* block id: 21 */
    struct S0 l_85 = {3,-1,4294967287U,1,1,0xA4CEBEE4,8,4294967286U};
    struct S0 *l_84 = &l_85;
    struct S0 **l_83 = &l_84;
    struct S0 ***l_86 = &l_83;
    int32_t *l_89 = &l_85.f0;
    int32_t **l_88 = &l_89;
    int32_t ***l_87 = &l_88;
    (*l_86) = l_83;
    if ((*p_31))
    { /* block id: 23 */
        int32_t ****l_90 = &l_87;
        (*l_90) = l_87;
    }
    else
    { /* block id: 25 */
        int32_t l_103 = (-2);
        struct S0 l_104 = {0x0B78A110,1,0U,2,1,0x9617CC22,0xCDAAD4FD,0x33FCDF6E};
        (**l_87) = func_34(((int32_t)((int32_t)((int32_t)(~0) - (int32_t)((((uint16_t)((***l_87) , (***l_87)) - (uint16_t)(~(((int16_t)l_103 << (int16_t)(((((l_104 , (***l_87)) , (l_104.f5 <= (&l_104 != &l_104))) & (***l_87)) || 0x15013F2C) , l_104.f0)) != 0x548F))) || 6U) | l_104.f4)) % (int32_t)0x3C673DF2) % (int32_t)(-8)), (*l_88));
    }
    (*l_89) = (((0x26E3 || (*l_89)) , (void*)0) == (((p_31 != (void*)0) >= ((*l_87) == (*l_87))) , (*l_86)));
    for (l_85.f2 = 0; (l_85.f2 != 7); l_85.f2 += 1)
    { /* block id: 31 */
        for (l_85.f1 = 0; (l_85.f1 != 2); l_85.f1 += 1)
        { /* block id: 34 */
            (*l_88) = p_33;
        }
    }
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_16
 */
static int32_t * func_34(uint16_t  p_35, int32_t * p_36)
{ /* block id: 13 */
    int32_t l_71 = 0;
    struct S0 l_75 = {0xC71B5959,3,8U,0,0xABD04657,0U,0,5U};
    struct S0 *l_74 = &l_75;
    uint32_t l_80 = 7U;
    int32_t *l_81 = &l_75.f0;
    int32_t **l_82 = &l_81;
    for (p_35 = 0; (p_35 <= 53); p_35 += 3)
    { /* block id: 16 */
        (*p_36) = (l_71 && ((uint16_t)((void*)0 != l_74) >> (uint16_t)((l_75.f4 >= 0xEE796224) || (((uint32_t)(l_75.f1 && ((0x13CF >= p_35) & ((((uint16_t)((l_80 , 0U) <= p_35) + (uint16_t)l_80) >= 0xC8E5C63B) , l_80))) + (uint32_t)l_75.f7) >= 0x167A))));
    }
    (*l_82) = l_81;
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_39(uint32_t  p_40, int32_t * p_41, int32_t  p_42)
{ /* block id: 3 */
    uint16_t l_48 = 0x2AD1;
    int32_t l_50 = 0x66E66B6C;
    int32_t *l_49 = &l_50;
    int32_t **l_61 = &l_49;
    struct S0 l_68 = {0x02D95C78,0x59B3,0x60EE42AC,1,0xAAE11E54,0x375426BE,8,0x66802143};
    struct S0 *l_67 = &l_68;
    (*l_61) = func_43(l_48, l_49, &l_50, &l_50);
    (*p_41) = ((((&p_41 != ((*p_41) , &p_41)) > ((uint32_t)((*p_41) >= ((p_40 , (((-(uint32_t)((uint16_t)(p_42 , (l_50 , (((void*)0 != l_67) == 0xD081FB71))) * (uint16_t)p_42)) >= 0x47E9E582) & p_40)) && p_40)) + (uint32_t)p_42)) == p_40) & 0U);
    (*l_61) = p_41;
    return (**l_61);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_43(int32_t  p_44, int32_t * p_45, int32_t * p_46, int32_t * p_47)
{ /* block id: 4 */
    struct S0 l_51 = {0x21E52503,0xFFE6,1U,1,1,4294967295U,0x4F8A3D35,0x55D5DF5B};
    struct S0 *l_52 = &l_51;
    int32_t *l_54 = &l_51.f0;
    int32_t **l_53 = &l_54;
    int32_t *l_56 = &l_51.f0;
    int32_t *l_57 = &l_51.f0;
    int32_t *l_58 = &l_51.f0;
    int32_t *l_59 = &l_51.f0;
    int32_t *l_60 = (void*)0;
lbl_55:
    (*l_52) = l_51;
    (*l_53) = &p_44;
    if (l_51.f2)
        goto lbl_55;
    return l_60;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 134
   depth: 1, occurrence: 19
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 43
breakdown:
   indirect level: 0, occurrence: 19
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 9
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 2
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 17
XXX times a bitfields struct on LHS: 4
XXX times a bitfields struct on RHS: 36
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 5

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 111
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 25, occurrence: 4
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 35, occurrence: 2

XXX total number of pointers: 150

XXX times a variable address is taken: 147
XXX times a pointer is dereferenced on RHS: 211
breakdown:
   depth: 1, occurrence: 146
   depth: 2, occurrence: 14
   depth: 3, occurrence: 32
   depth: 4, occurrence: 15
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 76
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 11
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 587

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 278
   level: 2, occurrence: 60
   level: 3, occurrence: 73
   level: 4, occurrence: 58
   level: 5, occurrence: 47
XXX number of pointers point to pointers: 80
XXX number of pointers point to scalars: 56
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 27.3
XXX average alias set size: 1.36

XXX times a non-volatile is read: 1035
XXX times a non-volatile is write: 219
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 96
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 42
   depth: 1, occurrence: 19
   depth: 2, occurrence: 17
   depth: 3, occurrence: 8
   depth: 4, occurrence: 5
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 15.4
XXX percentage an existing variable is used: 84.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

