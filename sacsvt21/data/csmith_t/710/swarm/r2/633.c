/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      4249968686
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 5;
   unsigned f1 : 6;
   signed f2 : 16;
   unsigned f3 : 28;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int16_t  f0;
   uint16_t  f1;
   uint16_t  f2;
   int32_t  f3;
   uint32_t  f4;
   int32_t  f5;
   unsigned f6 : 11;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S2 {
   int32_t  f0;
   int32_t  f1;
};
#pragma pack(pop)

struct S3 {
   uint16_t  f0;
   struct S1  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S3  func_1(void);
static int16_t  func_7(struct S1  p_8);
static int32_t  func_10(int16_t  p_11, int32_t  p_12, uint32_t  p_13, uint32_t  p_14);
static int32_t  func_16(uint16_t  p_17);
static struct S1  func_23(int16_t  p_24, uint32_t  p_25, float  p_26, uint32_t  p_27);
static int32_t  func_28(uint16_t  p_29, uint32_t  p_30, uint32_t  p_31, float  p_32);
static struct S0  func_40(float  p_41);
static struct S3  func_46(int16_t  p_47, uint32_t  p_48);
static int32_t  func_52(struct S3  p_53, uint16_t  p_54, uint16_t  p_55, uint32_t  p_56);
static struct S3  func_57(struct S2  p_58, struct S2  p_59, float  p_60, struct S0  p_61, int32_t  p_62);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S3  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0xFFCF33F2;
    struct S1 l_9 = {0,0x5349,0xABC2,7,0U,-1,33};
    int32_t l_304 = (-1);
    uint16_t l_313 = 0U;
    struct S3 l_348 = {0U,{0xCA19,4U,0x63C7,0xB3874F58,0xBC9BC23B,0x02E2F530,25}};
    uint8_t l_459 = 0x20;
    uint32_t l_467 = 0x29DDE08E;
    for (l_2 = (-28); (l_2 <= 7); l_2 += 6)
    { /* block id: 3 */
        uint32_t l_303 = 0x7E00CCF4;
        int32_t l_427 = (-1);
        uint32_t l_447 = 0xD59AD62F;
        uint32_t l_456 = 0xA18C4B75;
        l_304 &= (((int16_t)func_7(l_9) % (int16_t)l_9.f0) < ((int16_t)l_303 - (int16_t)0x8CBA));
        if (((int32_t)((((1 < ((!((((((!((int32_t)(((l_9.f2 > ((uint16_t)(l_313 && ((int16_t)l_2 >> (int16_t)11)) << (uint16_t)((((l_9.f3 == ((uint16_t)(((((int16_t)(((int16_t)((int16_t)l_9.f4 % (int16_t)(l_303 ^ l_303)) >> (int16_t)11) >= l_9.f2) << (int16_t)l_9.f0) > l_303) ^ l_303) > 0x10920946) + (uint16_t)(-1))) == l_9.f3) != l_2) ^ 0))) || l_303) >= l_303) - (int32_t)0x168314A8)) | 0xEA5D) | l_9.f4) > l_9.f0) | l_303) & l_9.f5)) ^ l_9.f0)) <= l_303) && 0) | 0x08C6F954) + (int32_t)(-1)))
        { /* block id: 93 */
            uint8_t l_332 = 0xA2;
            for (l_9.f5 = (-13); (l_9.f5 == (-23)); l_9.f5 -= 1)
            { /* block id: 96 */
                uint32_t l_331 = 1U;
                for (l_9.f0 = 0; (l_9.f0 > 0); l_9.f0++)
                { /* block id: 99 */
                    int32_t l_328 = 0x98337A89;
                    int32_t l_329 = (-1);
                    if (l_328)
                    { /* block id: 100 */
                        uint16_t l_333 = 0xB253;
                        uint32_t l_346 = 4294967295U;
                        int32_t l_347 = 1;
                        l_329 = (l_9.f2 != l_303);
                        l_347 &= ((~((l_331 || l_331) && ((l_332 > ((((l_333 | ((((int16_t)0x453C >> (int16_t)6) & (((int16_t)((int16_t)((((l_332 == ((((uint32_t)((uint16_t)(0 != (l_329 != ((uint16_t)(l_332 < l_9.f5) >> (uint16_t)l_9.f1))) >> (uint16_t)l_346) % (uint32_t)0xD78A4FEA) ^ 1U) || l_332)) <= l_346) ^ (-1)) & l_331) - (int16_t)l_303) << (int16_t)5) | l_329)) >= l_331)) >= l_332) >= l_303) == l_332)) >= l_328))) <= (-8));
                    }
                    else
                    { /* block id: 103 */
                        l_304 ^= l_303;
                    }
                }
                return l_348;
            }
        }
        else
        { /* block id: 109 */
            uint32_t l_351 = 0xC383BE51;
            float l_363 = 0x0.0p-1;
            int32_t l_368 = 0xFBB84C37;
            uint32_t l_412 = 4294967295U;
            int32_t l_413 = 0x10DA4FAA;
            l_348.f1.f5 ^= ((int16_t)l_351 >> (int16_t)9);
            for (l_348.f1.f3 = 0; (l_348.f1.f3 <= (-14)); l_348.f1.f3 -= 1)
            { /* block id: 113 */
                int32_t l_377 = 0x26395968;
                int32_t l_391 = 0x3595F58C;
                for (l_9.f5 = (-9); (l_9.f5 < 13); l_9.f5 += 1)
                { /* block id: 116 */
                    uint32_t l_356 = 4294967291U;
                    int16_t l_364 = 0xE923;
                    uint32_t l_369 = 0x67DB47F5;
                    int32_t l_370 = (-4);
                    if (l_356)
                    { /* block id: 117 */
                        int32_t l_367 = 0;
                        l_370 |= ((((~(((65535U == ((l_303 ^ (!l_351)) | ((uint32_t)(l_348.f1.f1 && (((((((uint16_t)(l_348.f1.f3 < l_351) << (uint16_t)15) | l_364) | ((((uint16_t)l_304 >> (uint16_t)(((0x00ED ^ l_351) & 0x24227976) != 0x2E0A)) & 0xC98B7927) && l_367)) || 0xB106) == l_351) == 7)) - (uint32_t)l_351))) ^ 1U) || l_368)) < l_369) == 0x9FCA559D) <= l_367);
                    }
                    else
                    { /* block id: 119 */
                        uint8_t l_371 = 0x34;
                        l_371 = l_303;
                        if (l_356)
                            break;
                        if (l_368)
                            continue;
                        l_391 &= ((((((((int16_t)0xB499 >> (int16_t)4) || (~0x54A7E6BF)) != l_369) & (((int16_t)(l_303 == (l_377 == (((int16_t)(((int16_t)l_9.f0 << (int16_t)(((uint32_t)((((uint16_t)(~(((int32_t)((l_371 & ((l_303 >= ((((int32_t)l_377 - (int32_t)l_377) >= (-1)) != 0x1249)) < l_371)) ^ l_303) % (int32_t)0x47356937) > l_356)) - (uint16_t)l_368) ^ l_356) <= l_370) % (uint32_t)l_371) || 4294967295U)) & l_356) % (int16_t)l_377) != l_303))) << (int16_t)7) ^ l_377)) & 0U) | l_371) & l_9.f1);
                    }
                    l_413 ^= (((uint16_t)l_2 >> (uint16_t)8) > ((uint16_t)(~l_370) - (uint16_t)(l_377 <= (((((uint16_t)(((((((((int32_t)(((int32_t)l_356 - (int32_t)l_368) < l_368) - (int32_t)0xE014EA22) & ((int16_t)((-(int32_t)((uint16_t)((l_303 >= ((int32_t)(((int16_t)l_351 + (int16_t)l_303) < l_303) % (int32_t)l_391)) >= 0x45B5) + (uint16_t)l_377)) && l_369) << (int16_t)l_377)) || l_391) != l_303) && l_391) && 0U) | l_9.f4) >= l_412) >> (uint16_t)2) && l_303) < 0) < l_412))));
                }
                l_427 = (0x0.76D62Dp-97 >= (((((float)(0xD.94FF6Ep-96 >= l_413) + (float)((((float)(((float)((((0x2.340275p-91 != ((!((float)(l_368 <= 0x9.FE8A7Ap-81) - (float)((0x1.2p-1 < (((((float)((float)l_412 - (float)l_303) - (float)l_391) >= l_413) >= (-0x4.7p-1)) != 0xE.DCE14Cp-33)) == l_412))) <= l_368)) >= l_303) >= 0x3.A47A92p-91) < l_303) + (float)0x3.B94FB1p-46) != 0x6.Bp+1) - (float)l_351) <= l_412) > 0x7.A0828Fp-32)) != 0xE.EE77EDp-35) > l_391) != l_368));
                l_9.f5 = ((((int16_t)((((int32_t)((int32_t)((((uint32_t)(((int16_t)l_368 >> (int16_t)7) | ((uint32_t)((uint16_t)6U - (uint16_t)(l_303 >= ((l_348.f1.f4 || ((uint32_t)((-(uint32_t)l_351) | l_304) % (uint32_t)((uint16_t)l_447 << (uint16_t)11))) > ((((((((uint16_t)(((((((uint16_t)((int16_t)((int16_t)l_456 << (int16_t)14) >> (int16_t)12) << (uint16_t)2) <= (((int32_t)l_348.f0 % (int32_t)l_391) == l_368)) ^ l_427) <= l_351) == 65532U) == l_413) << (uint16_t)13) >= 0xD697) <= l_348.f1.f1) ^ l_377) <= l_377) != l_459) >= l_377)))) % (uint32_t)l_391)) - (uint32_t)l_303) || 0x75B7) != l_391) - (int32_t)l_348.f1.f0) % (int32_t)0x228E72DA) ^ l_459) >= l_351) + (int16_t)l_456) == l_391) ^ l_412);
            }
        }
        for (l_348.f1.f1 = 0; (l_348.f1.f1 != 8); l_348.f1.f1 += 2)
        { /* block id: 133 */
            for (l_348.f1.f5 = 18; (l_348.f1.f5 == 16); l_348.f1.f5 -= 1)
            { /* block id: 136 */
                int16_t l_464 = 0xF3F9;
                l_427 = (l_464 <= ((float)0x4.Bp+1 + (float)0x0.8p-1));
            }
            return l_348;
        }
        if (l_313)
            break;
    }
    l_467++;
    return l_348;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_7(struct S1  p_8)
{ /* block id: 4 */
    uint32_t l_15 = 0xC4F32B7B;
    struct S1 l_178 = {1,1U,3U,0xD4906CFE,4294967292U,0xC682F6D3,16};
    struct S2 l_180 = {-1,-1};
    uint16_t l_198 = 0U;
    uint16_t l_225 = 0xF105;
    int32_t l_227 = 0x06CAC7D1;
    int32_t l_230 = (-1);
    int32_t l_233 = (-10);
    int32_t l_235 = 0x1E72512A;
    int32_t l_236 = (-4);
    int16_t l_239 = 1;
    int32_t l_243 = 0xB8725458;
    int32_t l_244 = 0;
    int32_t l_248 = (-1);
    int32_t l_249 = 0xBCB859E3;
    int32_t l_252 = 0xF16EFBBE;
    int32_t l_258 = (-2);
    int32_t l_260 = 0x4E503AC0;
    int32_t l_263 = 5;
    int32_t l_299 = (-5);
    p_8.f3 |= func_10(l_15, l_15, l_15, l_15);
    l_178 = func_23(p_8.f1, p_8.f6, p_8.f4, l_15);
    if (l_178.f3)
    { /* block id: 76 */
        struct S2 l_179 = {-8,-4};
        l_180 = l_179;
    }
    else
    { /* block id: 78 */
        float l_181 = 0x2.ED01F5p+96;
        int32_t l_182 = 0x75043125;
        l_182 = l_182;
        l_180.f1 = (((!(((int16_t)(1U < (((uint16_t)((uint16_t)((p_8.f6 == ((uint16_t)((uint16_t)((0x557B76B9 != ((int16_t)p_8.f3 << (int16_t)3)) < (p_8.f0 > ((((int16_t)l_182 - (int16_t)(((0xA1A1 || 1U) & (p_8.f3 >= 0x2DBE5E4B)) || 0U)) & l_182) == l_182))) >> (uint16_t)10) >> (uint16_t)13)) | p_8.f1) >> (uint16_t)l_198) >> (uint16_t)4) >= l_178.f4)) + (int16_t)0xE3D5) | 4294967295U)) && l_178.f5) | l_182);
        p_8.f3 = (((int32_t)((int32_t)(l_182 | (p_8.f4 <= (((uint32_t)p_8.f3 - (uint32_t)p_8.f1) == p_8.f0))) + (int32_t)l_180.f1) + (int32_t)p_8.f1) | (((uint16_t)((uint16_t)l_178.f0 << (uint16_t)p_8.f5) >> (uint16_t)p_8.f1) != p_8.f6));
    }
    for (l_15 = 12; (l_15 != 12); l_15 += 8)
    { /* block id: 85 */
        int32_t l_226 = 0x843842C4;
        int32_t l_228 = 0x45841018;
        int32_t l_229 = (-1);
        int32_t l_231 = 0x93766C54;
        int32_t l_232 = (-1);
        int32_t l_234 = 0x83A89B0C;
        int32_t l_237 = 0xDA9A1731;
        int32_t l_238 = 0x64180A0B;
        int32_t l_240 = (-1);
        int32_t l_241 = 1;
        int32_t l_242 = 0x4F79F7B5;
        int32_t l_245 = 4;
        int32_t l_246 = 7;
        int32_t l_247 = 8;
        int32_t l_250 = 0x79AD05D5;
        int32_t l_251 = 7;
        int32_t l_253 = 0x5A30D52B;
        int32_t l_254 = (-1);
        int32_t l_255 = 0x5598B16B;
        int32_t l_256 = 8;
        int32_t l_257 = (-8);
        int32_t l_259 = (-9);
        int32_t l_261 = 0x215E3060;
        int32_t l_262 = 4;
        uint16_t l_264 = 0x9C70;
        float l_300 = (-0x7.1p-1);
        p_8.f5 ^= ((uint16_t)l_178.f1 + (uint16_t)((int16_t)l_178.f4 % (int16_t)((uint16_t)(p_8.f1 >= (p_8.f3 >= ((int16_t)(((((uint16_t)((p_8.f1 >= (((uint16_t)(1U > (((l_225 > 1U) && 0x904B5586) == 0x2604)) - (uint16_t)p_8.f1) != p_8.f4)) ^ l_198) << (uint16_t)0) >= 0xBE56) || l_226) != l_225) >> (int16_t)p_8.f6))) >> (uint16_t)11)));
        l_264++;
        l_230 = ((float)((((float)((-0x1.6p-1) != (((float)(((((((float)((float)((float)((((-0x2.Dp-1) == ((float)((p_8.f3 >= ((float)(l_260 >= ((float)((float)(p_8.f4 == ((float)((float)(((l_251 < ((float)(((((float)(p_8.f1 < p_8.f1) - (float)((((float)(((float)p_8.f1 - (float)p_8.f2) <= l_299) - (float)l_252) < 0x0.8p+1) <= 0x1.3p+1)) < 0xB.6FD450p-17) <= l_263) < l_248) + (float)p_8.f3)) == l_253) != l_257) - (float)l_300) - (float)l_225)) - (float)0x8.075D6Dp+1) + (float)l_256)) + (float)p_8.f2)) < l_247) + (float)p_8.f4)) != l_255) > 0x6.44536Bp+46) - (float)l_229) - (float)l_261) - (float)0x3.1p+1) > p_8.f2) > p_8.f3) < p_8.f6) < (-0x5.6p+1)) != p_8.f4) + (float)(-0x7.2p+1)) != (-0x4.4p-1))) + (float)l_246) == p_8.f2) > p_8.f2) - (float)0x1.Cp-1);
        if (p_8.f0)
            continue;
    }
    return p_8.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_10(int16_t  p_11, int32_t  p_12, uint32_t  p_13, uint32_t  p_14)
{ /* block id: 5 */
    int32_t l_20 = 0x6FD8C658;
    if (func_16((((int16_t)l_20 >> (int16_t)6) != 0x9070)))
    { /* block id: 8 */
        return l_20;
    }
    else
    { /* block id: 10 */
        int32_t l_22 = 0xCD6A9B03;
        return l_22;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_16(uint16_t  p_17)
{ /* block id: 6 */
    uint16_t l_21 = 0x8FE4;
    return l_21;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_23(int16_t  p_24, uint32_t  p_25, float  p_26, uint32_t  p_27)
{ /* block id: 14 */
    int32_t l_35 = 0xCADCDA6A;
    int32_t l_150 = 8;
    struct S1 l_177 = {0x9AE0,0x01FE,65535U,-1,0U,7,33};
    l_150 = func_28(((int32_t)l_35 % (int32_t)l_35), ((func_16(((uint16_t)(func_16(p_27) & l_35) >> (uint16_t)1)) ^ 2) == 0xECFB861A), p_27, l_35);
    l_150 ^= 0x900747FD;
    l_150 = ((int32_t)((((((uint16_t)((int32_t)5 + (int32_t)(-(uint32_t)(l_150 || (-(int16_t)((((((((int32_t)(((((((uint32_t)((((int16_t)((uint32_t)p_25 % (uint32_t)l_35) >> (int16_t)3) == ((int16_t)0xBF7F - (int16_t)((((int16_t)p_24 << (int16_t)3) & (((uint16_t)(p_27 != ((uint16_t)((int32_t)(((l_150 > l_150) & l_150) | l_35) % (int32_t)p_25) - (uint16_t)l_35)) << (uint16_t)4) && p_27)) != 1))) | l_35) + (uint32_t)p_24) > (-1)) == 0xEED5) >= 1) || 0x3F510E37) > l_150) % (int32_t)p_25) || 0x9A41) >= l_150) <= l_35) < l_35) != 0xA883) <= l_35))))) << (uint16_t)15) > 0xF412) != p_24) == p_27) < 0x9F7B9E17) + (int32_t)0U);
    return l_177;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_28(uint16_t  p_29, uint32_t  p_30, uint32_t  p_31, float  p_32)
{ /* block id: 15 */
    struct S0 l_45 = {3,1,-135,762};
    struct S2 l_63 = {0x662BFFD6,6};
    struct S3 l_139 = {65535U,{0x358F,0x34B3,0xCDCE,0x65EB517B,4294967295U,0x82C3DD90,5}};
    for (p_29 = 0; (p_29 > 23); p_29 += 1)
    { /* block id: 18 */
        l_45 = func_40(p_29);
    }
    l_139 = func_46(l_45.f0, (((int32_t)(-(uint16_t)(((7 != (func_52(func_57(l_63, l_63, l_45.f1, l_45, p_30), p_30, p_30, l_45.f1) <= l_45.f1)) ^ l_45.f2) | 0xB9DDBBE0)) % (int32_t)0x23EC0817) != 0x2A75));
    for (p_30 = 8; (p_30 == 11); p_30 += 1)
    { /* block id: 66 */
        int16_t l_142 = (-1);
        return l_142;
    }
    l_63.f1 = (((l_139.f0 < p_31) != (0xCF958245 && ((0xC009 ^ 0xE995) && (!(((((uint16_t)(((int16_t)l_139.f1.f3 << (int16_t)8) ^ ((int16_t)((l_139.f1.f0 && (4 == l_45.f2)) <= p_30) % (int16_t)l_139.f1.f4)) >> (uint16_t)3) <= 0x80DBD024) == l_45.f0) > l_139.f1.f4))))) > 0xAEAC);
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_40(float  p_41)
{ /* block id: 19 */
    uint8_t l_42 = 252U;
    int32_t l_43 = (-1);
    struct S0 l_44 = {2,3,-239,5853};
    l_43 = (l_42 <= (-0x1.1p+1));
    return l_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S3  func_46(int16_t  p_47, uint32_t  p_48)
{ /* block id: 42 */
    float l_80 = (-0x1.Dp-1);
    uint32_t l_85 = 0x42CED756;
    int32_t l_102 = 1;
    int32_t l_104 = (-5);
    int32_t l_106 = 0x112D8212;
    int32_t l_107 = 0x6AFD1197;
    int32_t l_108 = 0;
    int32_t l_109 = 1;
    uint32_t l_111 = 4294967295U;
    struct S2 l_114 = {5,0xB561CB1B};
    struct S3 l_138 = {0xE074,{0xDC9F,0x8CF5,65535U,8,0U,0x7B0D791C,40}};
    if ((p_47 <= (p_48 && ((int32_t)((uint32_t)(((p_48 != p_47) != (4U == ((int32_t)(((uint32_t)(l_85 && ((uint16_t)(p_48 < l_85) >> (uint16_t)0)) % (uint32_t)p_47) || l_85) % (int32_t)l_85))) <= 0x65848584) % (uint32_t)4294967295U) - (int32_t)p_47))))
    { /* block id: 43 */
        int32_t l_92 = 0x27618441;
        int32_t l_101 = 0x7035F287;
        l_101 ^= (-(int16_t)((-(uint32_t)((uint16_t)l_85 >> (uint16_t)(l_92 >= (p_47 <= (p_47 >= (0xBE9465D9 == (-(int16_t)((-(uint32_t)((((uint32_t)(((((uint16_t)(l_92 > ((uint32_t)0x247421FA - (uint32_t)p_48)) % (uint16_t)l_85) || 0x85F46675) ^ l_92) != p_47) - (uint32_t)l_85) || l_92) & p_48)) >= p_48)))))))) & p_47));
        l_102 = 0x0.8p-1;
    }
    else
    { /* block id: 46 */
        int32_t l_103 = 0x196261E5;
        int32_t l_105 = 7;
        int32_t l_110 = 0xCA9B0E0A;
        l_111++;
        l_114 = l_114;
    }
    for (l_104 = 0; (l_104 <= (-9)); l_104 -= 1)
    { /* block id: 52 */
        float l_117 = 0x1.2p-1;
        l_108 = (l_107 > l_117);
        if (p_47)
            continue;
    }
    l_114 = l_114;
    for (l_102 = 0; (l_102 > 3); l_102 += 9)
    { /* block id: 59 */
        int32_t l_134 = (-9);
        l_104 = ((uint16_t)((uint16_t)((int16_t)((uint16_t)p_47 + (uint16_t)p_47) << (int16_t)((uint32_t)((((6 & (((((int16_t)l_134 + (int16_t)(p_47 != p_47)) > 0x9A3136B1) & (p_48 <= (((uint16_t)((!l_134) | l_107) << (uint16_t)p_47) & p_47))) <= l_114.f0)) || p_47) <= l_85) & 0xD886) - (uint32_t)0x31F22FF8)) + (uint16_t)p_47) + (uint16_t)l_134);
    }
    return l_138;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_52(struct S3  p_53, uint16_t  p_54, uint16_t  p_55, uint32_t  p_56)
{ /* block id: 38 */
    uint16_t l_73 = 0xECDB;
    l_73++;
    p_53.f1.f5 = l_73;
    return p_53.f1.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S3  func_57(struct S2  p_58, struct S2  p_59, float  p_60, struct S0  p_61, int32_t  p_62)
{ /* block id: 24 */
    struct S1 l_71 = {0xC5D2,0x228E,65530U,0,0xA13A23B1,0xC07A264E,21};
    struct S3 l_72 = {0x494C,{0xA1C6,0xAC22,0xC50F,0x5F4D98BC,0xAFCE2876,7,1}};
    p_59.f0 = p_59.f0;
    for (p_62 = (-25); (p_62 == (-11)); p_62++)
    { /* block id: 28 */
        uint32_t l_66 = 7U;
        struct S1 l_70 = {0x5FD7,65530U,1U,0x8F24B120,0xBAF9C35C,0xEDEAE2A0,29};
        p_60 = l_66;
        for (p_59.f0 = (-21); (p_59.f0 == (-17)); p_59.f0 += 1)
        { /* block id: 32 */
            struct S3 l_69 = {65535U,{4,0x84D5,0x4CE3,0x23DE179B,0x9383A24C,0,11}};
            return l_69;
        }
        l_71 = l_70;
    }
    return l_72;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 101
   depth: 1, occurrence: 11
   depth: 2, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 12
breakdown:
   indirect level: 0, occurrence: 12
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 4
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 12

XXX max expression depth: 43
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 19
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 24, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 32, occurrence: 1
   depth: 38, occurrence: 2
   depth: 43, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 359
XXX times a non-volatile is write: 55
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 81
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 26
   depth: 2, occurrence: 6
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 26.4
XXX percentage an existing variable is used: 73.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

