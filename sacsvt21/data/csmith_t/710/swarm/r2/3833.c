/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1680877924
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static float g_7 = 0xF.052061p-81;
static uint32_t g_12 = 0x4C405B40L;
static int32_t g_45 = 0x523DD972L;
static uint32_t g_122 = 4294967289UL;
static uint16_t g_131 = 0xAB22L;
static int32_t *g_136 = &g_45;
static int32_t **g_135 = &g_136;
static int32_t g_156 = 0xDEB2300AL;
static int32_t *g_270 = &g_45;
static int32_t **g_269 = &g_270;
static volatile uint32_t g_387 = 0xDF907BA9L;/* VOLATILE GLOBAL g_387 */
static volatile int32_t ***g_413 = (void*)0;
static volatile int32_t **** const g_412 = &g_413;
static volatile uint32_t g_494 = 18446744073709551615UL;/* VOLATILE GLOBAL g_494 */
static uint32_t g_496 = 0x5E15D290L;


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_34(void);
static int32_t * func_35(int32_t  p_36, int8_t  p_37, float  p_38, uint32_t  p_39);
static int32_t * func_48(int32_t * p_49, int16_t  p_50, int32_t * p_51);
static int16_t  func_53(const uint16_t  p_54, int32_t * p_55, uint32_t  p_56, int32_t ** p_57);
static int16_t  func_61(uint32_t  p_62);
static int32_t  func_69(int32_t  p_70, const float  p_71);
static int32_t  func_83(uint16_t  p_84, int8_t  p_85, uint32_t  p_86);
static int32_t * func_97(int16_t  p_98, float * p_99);
static uint16_t  func_103(int32_t ** const  p_104);
static int32_t ** func_105(int32_t * p_106, const float * const  p_107, int8_t  p_108, int32_t  p_109);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_7 g_135 g_136 g_45 g_122 g_494 g_496 g_269 g_270 g_156 g_387
 * writes: g_45 g_7 g_136 g_496 g_131
 */
static int8_t  func_34(void)
{ /* block id: 36 */
    uint32_t l_40 = 4294967291UL;
    uint32_t l_525 = 0x30B490FEL;
    (*g_135) = func_35(g_12, l_40, g_7, g_12);
    for (g_496 = (-30); (g_496 > 43); ++g_496)
    { /* block id: 311 */
        const int32_t *l_513 = &g_45;
        const int32_t **l_514 = &l_513;
        (*l_514) = l_513;
        for (g_131 = 5; (g_131 != 35); g_131 += 3)
        { /* block id: 315 */
            int32_t ** const l_517 = (void*)0;
            if ((func_103(l_517) == ((int16_t)g_156 << (int16_t)8)))
            { /* block id: 316 */
                uint32_t l_522 = 0x495B4D98L;
                int32_t l_526 = 0x32DF0708L;
                if (l_40)
                    break;
                l_526 = ((uint16_t)((l_522 & ((g_156 | ((uint16_t)0x0864L - (uint16_t)(g_387 == (4294967295UL <= l_525)))) && (-7L))) <= (**l_514)) % (uint16_t)7L);
                (**g_269) = l_40;
            }
            else
            { /* block id: 320 */
                g_7 = (&l_513 != &g_136);
            }
        }
    }
    return g_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_135 g_136 g_45 g_122 g_494 g_12 g_496 g_269 g_270
 * writes: g_45 g_7
 */
static int32_t * func_35(int32_t  p_36, int8_t  p_37, float  p_38, uint32_t  p_39)
{ /* block id: 37 */
    int32_t *l_52 = &g_45;
    const float * const l_390 = &g_7;
    int32_t ***l_411 = &g_135;
    int32_t ****l_410 = &l_411;
    int16_t l_434 = 1L;
    int32_t l_461 = 1L;
    uint32_t l_495 = 0x413887B5L;
    float *l_499 = (void*)0;
    float *l_510 = &g_7;
    for (p_37 = 21; (p_37 < (-21)); p_37 -= 1)
    { /* block id: 40 */
        uint32_t l_43 = 1UL;
        int32_t *l_46 = &g_45;
        int32_t l_60 = 0xF419C2B2L;
        float *l_327 = &g_7;
        int32_t ***l_382 = (void*)0;
        int32_t l_438 = (-9L);
        int32_t l_481 = (-1L);
    }
    (****l_410) = (**g_135);
    (*l_510) = ((float)(((((__builtin_ffs((*l_52)) >= (((float)g_122 - (float)0x6.98A65Ep-50) != (((__builtin_bswap32(((int32_t)((int16_t)g_494 * (int16_t)(((uint16_t)p_39 >> (uint16_t)2) > (g_122 == g_45))) - (int32_t)p_39)) < (-0x1.8p-1)) >= p_37) < (***l_411)))) > g_12) == p_39) >= p_36) == (*l_52)) * (float)p_37);
    p_36 = (1UL != g_496);
    return (*g_269);
}


/* ------------------------------------------ */
/* 
 * reads : g_122 g_12
 * writes:
 */
static int32_t * func_48(int32_t * p_49, int16_t  p_50, int32_t * p_51)
{ /* block id: 179 */
    const uint32_t l_285 = 0x9BE9E0A6L;
    const int32_t l_290 = 0xA146DD52L;
    int32_t l_291 = 0xD2A7965DL;
    l_291 = ((int16_t)func_69(g_122, l_285) << (int16_t)((int16_t)((uint16_t)l_290 + (uint16_t)l_290) >> (int16_t)l_285));
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_156 g_45 g_12 g_136 g_269 g_270
 * writes: g_156 g_45 g_12 g_136 g_7
 */
static int16_t  func_53(const uint16_t  p_54, int32_t * p_55, uint32_t  p_56, int32_t ** p_57)
{ /* block id: 165 */
    int32_t ***l_272 = &g_269;
    int32_t ****l_271 = &l_272;
    (*l_271) = (void*)0;
    for (g_156 = 0; (g_156 != 0); g_156 += 7)
    { /* block id: 169 */
        int32_t ****l_275 = (void*)0;
        int32_t *l_282 = &g_45;
        (*p_55) = (((l_275 == (void*)0) <= (~(0x0119L <= 65531UL))) & (__builtin_clzll(((int32_t)__builtin_ctzll(p_56) % (int32_t)g_45)) && (*p_55)));
        for (g_12 = 0; (g_12 == 22); ++g_12)
        { /* block id: 173 */
            float *l_281 = &g_7;
            (*l_281) = func_103(&p_55);
        }
        l_282 = (*g_269);
    }
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_12 g_135 g_136 g_131 g_7 g_156 g_122
 * writes: g_7 g_122 g_131 g_136 g_156 g_135 g_12
 */
static int16_t  func_61(uint32_t  p_62)
{ /* block id: 50 */
    const int32_t l_77 = 1L;
    int32_t *l_241 = &g_156;
    int8_t l_258 = 5L;
    int32_t l_268 = 0L;
    for (p_62 = (-19); (p_62 == 18); p_62 += 1)
    { /* block id: 53 */
        float *l_76 = &g_7;
        (*l_76) = ((void*)0 != &g_45);
    }
    if ((func_69((l_77 & ((g_45 <= func_69(l_77, g_45)) && l_77)), ((((-(float)0xC.7B6EB5p+49) <= 0xA.31937Dp-8) == (((float)((float)g_12 - (float)0x4.B61364p+58) * (float)g_12) < 0x1.381653p+16)) > p_62)) >= (-1L)))
    { /* block id: 56 */
        int32_t *l_240 = (void*)0;
        int32_t ***l_257 = &g_135;
        int16_t l_261 = 0x8B90L;
        if (func_83(((uint32_t)__builtin_popcountl(l_77) + (uint32_t)((uint16_t)0xB4C0L << (uint16_t)13)), ((uint16_t)p_62 << (uint16_t)2), (-(uint16_t)g_45)))
        { /* block id: 147 */
            int32_t *l_251 = &g_45;
            int32_t **l_252 = &g_136;
            l_241 = l_240;
            g_7 = ((float)g_156 * (float)((((float)p_62 + (float)((-(float)((float)(0x1.Bp+1 < func_103(&l_240)) + (float)((float)p_62 + (float)0x5.724294p-24))) <= g_131)) >= ((void*)0 != &g_135)) > 0xF.ADB20Bp+69));
            (*l_252) = l_251;
        }
        else
        { /* block id: 151 */
            l_258 = ((float)(((float)g_131 * (float)(*l_241)) != (0x7.5p-1 <= ((void*)0 != l_257))) * (float)p_62);
            return g_45;
        }
        for (g_12 = 0; (g_12 != 53); ++g_12)
        { /* block id: 157 */
            float *l_262 = &g_7;
            (*l_262) = (l_261 != 0x9.A4619Cp-46);
        }
    }
    else
    { /* block id: 160 */
        int8_t l_267 = 0x79L;
        (*g_135) = (*g_135);
        (*l_241) = ((float)0xE.09F95Bp-12 * (float)((float)(*l_241) - (float)func_69(l_267, __builtin_ctzl((0x3DABL >= p_62)))));
    }
    return l_268;
}


/* ------------------------------------------ */
/* 
 * reads : g_12
 * writes:
 */
static int32_t  func_69(int32_t  p_70, const float  p_71)
{ /* block id: 47 */
    int32_t *l_73 = &g_45;
    int32_t **l_72 = &l_73;
    (*l_72) = (void*)0;
    return g_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_45 g_135 g_136 g_131 g_7 g_156 g_122
 * writes: g_122 g_131 g_136 g_7 g_156 g_135 g_12
 */
static int32_t  func_83(uint16_t  p_84, int8_t  p_85, uint32_t  p_86)
{ /* block id: 57 */
    const uint16_t l_94 = 0UL;
    const uint32_t l_195 = 0x54279C2BL;
    int32_t **l_196 = &g_136;
    float *l_238 = &g_7;
    int32_t *l_239 = &g_156;
    if ((l_94 ^ p_84))
    { /* block id: 58 */
        float *l_102 = &g_7;
        for (p_86 = 0; (p_86 <= 46); ++p_86)
        { /* block id: 61 */
            const float * const l_110 = (void*)0;
            int32_t l_111 = 6L;
            float *l_139 = &g_7;
            (*g_135) = func_97(((int16_t)((void*)0 != l_102) + (int16_t)func_103(func_105(&g_45, l_110, l_111, ((void*)0 == l_102)))), l_139);
        }
        for (g_131 = 24; (g_131 >= 38); g_131 += 6)
        { /* block id: 99 */
            int8_t l_154 = 1L;
            int32_t *l_155 = &g_156;
            int32_t ***l_157 = (void*)0;
            int32_t ***l_158 = &g_135;
            (*l_155) = l_154;
            (*l_158) = (void*)0;
        }
        return (*g_136);
    }
    else
    { /* block id: 104 */
        const int32_t l_163 = 0x78FF3A18L;
        int8_t l_168 = 0x30L;
        uint32_t l_169 = 0x5F0DE8C2L;
        int32_t *l_170 = (void*)0;
        int32_t *l_171 = &g_156;
        float *l_172 = (void*)0;
        float *l_173 = &g_7;
        (*l_171) = ((int16_t)(0x6E341DA9L & (g_156 >= (((((l_94 < p_86) > ((int16_t)func_69(p_84, l_163) * (int16_t)((int16_t)(((int16_t)l_168 >> (int16_t)g_122) & (*g_136)) << (int16_t)0))) && p_86) && 65527UL) ^ l_163))) * (int16_t)l_169);
        (*l_173) = __builtin_clz(g_45);
        (*l_171) = (65535UL && (((uint16_t)((int16_t)(-(int32_t)(**g_135)) * (int16_t)g_122) * (uint16_t)((uint16_t)65533UL % (uint16_t)((uint16_t)(__builtin_parity(p_84) < (((int16_t)((int16_t)p_86 % (int16_t)((uint16_t)((uint16_t)((int32_t)(((int16_t)(p_84 && g_156) + (int16_t)g_131) <= 0x45B90580L) - (int32_t)(*g_136)) << (uint16_t)g_156) << (uint16_t)9)) << (int16_t)p_85) < 0x2E77L)) >> (uint16_t)0))) < l_195));
        l_196 = (void*)0;
    }
    for (p_85 = 0; (p_85 == (-26)); p_85 -= 1)
    { /* block id: 112 */
        int32_t * const l_199 = &g_156;
        int32_t *l_209 = &g_156;
        if ((__builtin_ffsll(((void*)0 == l_199)) ^ 0x4DF5L))
        { /* block id: 113 */
            float *l_200 = &g_7;
            int32_t *l_201 = &g_156;
            uint16_t l_202 = 0x419FL;
            l_201 = func_97(l_195, l_200);
            return l_202;
        }
        else
        { /* block id: 116 */
            int32_t l_211 = (-4L);
            for (g_12 = (-6); (g_12 == 29); ++g_12)
            { /* block id: 119 */
                int32_t *l_210 = &g_156;
                (*g_135) = (void*)0;
                for (p_86 = 0; (p_86 <= 8); p_86++)
                { /* block id: 123 */
                    float *l_207 = (void*)0;
                    float *l_208 = &g_7;
                    (*l_208) = ((void*)0 != l_207);
                    l_209 = (*g_135);
                }
                l_210 = l_199;
                if (l_211)
                    break;
            }
        }
        if ((((int16_t)(!(((g_12 || ((uint16_t)p_84 << (uint16_t)10)) | __builtin_parity(((int16_t)(p_84 < g_45) >> (int16_t)3))) || ((int16_t)(func_103(l_196) <= (((uint16_t)g_156 * (uint16_t)l_195) & 0xADEF71BAL)) << (int16_t)l_195))) % (int16_t)p_85) && p_85))
        { /* block id: 131 */
            for (g_12 = 20; (g_12 < 26); g_12++)
            { /* block id: 134 */
                return p_85;
            }
        }
        else
        { /* block id: 137 */
            float *l_225 = &g_7;
            int32_t l_230 = 0x0BEEA7B1L;
            (*l_225) = __builtin_clzll(p_84);
            g_7 = (((float)p_85 + (float)func_69(p_86, l_94)) < (((((float)l_230 - (float)0x5.0340A0p-89) >= __builtin_ctzl(((uint32_t)__builtin_parityl(g_45) + (uint32_t)((int16_t)(!(0xA98AF002L | p_84)) >> (int16_t)g_131)))) == g_122) <= p_86));
            return p_86;
        }
        return l_94;
    }
    (*g_135) = (void*)0;
    (*l_239) = (p_85 ^ (((l_195 && ((void*)0 != &l_196)) || (((int32_t)2L - (int32_t)(l_238 != l_238)) <= g_12)) < 0x5930L));
    return p_85;
}


/* ------------------------------------------ */
/* 
 * reads : g_131 g_45 g_12 g_135 g_136
 * writes: g_131 g_136 g_7
 */
static int32_t * func_97(int16_t  p_98, float * p_99)
{ /* block id: 77 */
    int32_t l_142 = 0L;
    int32_t * const l_149 = &g_45;
    for (g_131 = 0; (g_131 <= 12); g_131++)
    { /* block id: 80 */
        int32_t l_145 = 0xDD589E83L;
        int32_t **l_150 = &g_136;
        int32_t *l_151 = &l_145;
        if (func_69(l_142, (((((float)l_142 * (float)(-0x2.9p+1)) != l_145) == g_45) == 0x9.E0BB6Bp-24)))
        { /* block id: 81 */
            const int8_t l_147 = 1L;
            int32_t *l_148 = &l_145;
            (*l_148) = (!l_147);
            (*g_135) = (*g_135);
            (*g_135) = (void*)0;
        }
        else
        { /* block id: 85 */
            (*g_135) = l_149;
        }
        (*l_150) = l_149;
        (*l_151) = (**l_150);
    }
    (*g_135) = (void*)0;
    (*p_99) = 0x0.44D726p+69;
    (*p_99) = 0x0.9p+1;
    return p_99;
}


/* ------------------------------------------ */
/* 
 * reads : g_136 g_45
 * writes: g_136
 */
static uint16_t  func_103(int32_t ** const  p_104)
{ /* block id: 72 */
    int32_t * const l_137 = &g_45;
    int32_t **l_138 = &g_136;
    (*l_138) = l_137;
    (*l_138) = (void*)0;
    (*l_138) = (*l_138);
    return (*l_137);
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_45 g_135
 * writes: g_122 g_131
 */
static int32_t ** func_105(int32_t * p_106, const float * const  p_107, int8_t  p_108, int32_t  p_109)
{ /* block id: 62 */
    int32_t *l_124 = &g_45;
    int32_t **l_123 = &l_124;
    float l_129 = (-0x2.2p-1);
    int32_t **l_134 = &l_124;
    g_122 = (__builtin_parity(((uint16_t)((uint16_t)2UL * (uint16_t)(((int16_t)((uint16_t)((uint16_t)func_69(g_12, (0xB.8EE66Dp-98 != 0xD.9930EDp-3)) * (uint16_t)0x7B0CL) % (uint16_t)p_109) - (int16_t)__builtin_clzll(g_12)) >= (*p_106))) >> (uint16_t)8)) & 0xC4F9L);
    (*l_123) = &g_45;
    if ((g_45 & p_108))
    { /* block id: 65 */
        uint32_t l_130 = 0x88274EA1L;
        g_131 = (((int16_t)((void*)0 != &l_124) >> (int16_t)(((uint16_t)(*l_124) << (uint16_t)l_130) > 0x5AF8L)) && (**l_123));
    }
    else
    { /* block id: 67 */
        const int32_t *l_132 = &g_45;
        const int32_t **l_133 = &l_132;
        (*l_133) = l_132;
        (*l_133) = &g_45;
    }
    return g_135;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_34();
    transparent_crc_bytes (&g_7, sizeof(g_7), "g_7", print_hash_value);
    transparent_crc(g_12, "g_12", print_hash_value);
    transparent_crc(g_45, "g_45", print_hash_value);
    transparent_crc(g_122, "g_122", print_hash_value);
    transparent_crc(g_131, "g_131", print_hash_value);
    transparent_crc(g_156, "g_156", print_hash_value);
    transparent_crc(g_387, "g_387", print_hash_value);
    transparent_crc(g_494, "g_494", print_hash_value);
    transparent_crc(g_496, "g_496", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 123
XXX total union variables: 0

XXX max expression depth: 19
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 24
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 3
   depth: 11, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1

XXX total number of pointers: 99

XXX times a variable address is taken: 106
XXX times a pointer is dereferenced on RHS: 70
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 82
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 3
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 325

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 378
   level: 2, occurrence: 59
   level: 3, occurrence: 16
   level: 4, occurrence: 11
XXX number of pointers point to pointers: 34
XXX number of pointers point to scalars: 65
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 32.3
XXX average alias set size: 1.38

XXX times a non-volatile is read: 534
XXX times a non-volatile is write: 216
XXX times a volatile is read: 7
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 61
XXX percentage of non-volatile access: 99.1

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 95
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 26
   depth: 2, occurrence: 22
   depth: 3, occurrence: 9
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 19.7
XXX percentage an existing variable is used: 80.3
********************* end of statistics **********************/

