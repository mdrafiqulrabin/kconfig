/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3198199756
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
};

struct S1 {
   int32_t  f0;
   uint16_t  f1;
   int32_t  f2;
   uint16_t  f3;
   int32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_31(void);
static int16_t  func_39(struct S0  p_40, int32_t  p_41);
static struct S0  func_42(int32_t  p_43, int32_t  p_44);
static struct S1  func_49(struct S0  p_50, uint32_t  p_51);
static struct S0  func_52(struct S0  p_53, struct S1  p_54, int16_t  p_55);
static uint32_t  func_63(int32_t  p_64, int32_t  p_65, uint32_t  p_66);
static int32_t  func_69(int32_t  p_70);
static uint32_t  func_71(int32_t  p_72, int8_t  p_73);
static struct S0  func_77(uint16_t  p_78, int32_t  p_79, struct S1  p_80, int32_t  p_81);
static int16_t  func_89(int32_t  p_90, uint16_t  p_91, int8_t  p_92, uint16_t  p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_31(void)
{ /* block id: 36 */
    uint32_t l_36 = 0x93BD5DE1;
    struct S0 l_56 = {65535U};
    struct S1 l_57 = {0,0U,0xCECB2EC6,0x0D4A,0};
    uint16_t l_292 = 0x5D6F;
    l_292 = (((int16_t)((int32_t)l_36 % (int32_t)l_36) >> (int16_t)6) || ((int16_t)func_39(func_42(((0x0223DEC9 < ((int32_t)(0x5FBA2522 ^ ((int16_t)l_36 * (int16_t)(func_49(func_52(l_56, l_57, l_57.f1), l_57.f1) , l_56.f0))) + (int32_t)l_57.f2)) && l_57.f4), l_57.f4), l_57.f0) << (int16_t)14));
    return l_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_39(struct S0  p_40, int32_t  p_41)
{ /* block id: 118 */
    int8_t l_267 = 0xB5;
    int32_t l_270 = (-4);
    uint32_t l_271 = 1U;
    struct S1 l_291 = {0x0ECB8524,65529U,1,0x9C2C,0xB88169B9};
    p_41 = (((int16_t)((uint16_t)1U * (uint16_t)((func_89(func_69(p_40.f0), ((uint16_t)(l_267 > (p_41 & (l_267 | l_267))) >> (uint16_t)((l_267 > func_69(((uint32_t)(p_40.f0 < l_270) % (uint32_t)p_40.f0))) && 65535U)), l_270, p_41) != l_270) <= (-1))) >> (int16_t)l_267) ^ l_271);
    p_41 = (p_40.f0 <= p_40.f0);
    l_270 = __builtin_bswap64(p_40.f0);
    p_41 = ((uint16_t)(((((uint16_t)l_270 >> (uint16_t)15) != (__builtin_ffsl(((((int16_t)(~(((uint32_t)((uint16_t)l_267 * (uint16_t)((int16_t)(p_41 | (__builtin_ia32_crc32qi(p_41, l_270) & (func_49(func_77((func_69(l_267) , ((int32_t)((uint16_t)((int16_t)l_267 - (int16_t)0xAC4D) >> (uint16_t)2) - (int32_t)p_41)), l_270, l_291, p_41), p_40.f0) , p_40.f0))) << (int16_t)p_41)) % (uint32_t)0xBC719AC7) , l_291.f1)) << (int16_t)l_267) >= p_40.f0) || l_291.f2)) > l_291.f0)) > l_267) , l_267) - (uint16_t)3);
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_42(int32_t  p_43, int32_t  p_44)
{ /* block id: 108 */
    uint32_t l_252 = 0x6DB04EDA;
    int32_t l_254 = (-1);
    struct S0 l_260 = {65532U};
    p_43 = ((~p_43) ^ 0x19CD);
    for (p_43 = 2; (p_43 > 2); p_43 += 6)
    { /* block id: 112 */
        uint32_t l_253 = 4294967295U;
        uint16_t l_259 = 0x4E2F;
        l_254 = ((int16_t)(l_252 > l_253) >> (int16_t)1);
        l_254 = ((__builtin_ffs(p_43) & ((int32_t)l_253 / (int32_t)(p_44 || __builtin_ctzl(((int16_t)l_253 - (int16_t)((p_44 >= l_252) , l_253)))))) ^ l_259);
    }
    l_260 = l_260;
    return l_260;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_49(struct S0  p_50, uint32_t  p_51)
{ /* block id: 106 */
    struct S1 l_246 = {0x648319B6,0xA9AB,0,0xC3C7,0x25558BBB};
    return l_246;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_52(struct S0  p_53, struct S1  p_54, int16_t  p_55)
{ /* block id: 37 */
    int16_t l_60 = 0xC35C;
    uint32_t l_76 = 4U;
    int16_t l_218 = 0xF9BF;
    int32_t l_243 = 0xF47B7046;
    l_243 = ((int16_t)(l_60 & ((uint32_t)((4294967293U & func_63(l_60, p_55, (((int32_t)func_69((0 ^ ((func_71(((int16_t)(l_76 , 0x69B2) + (int16_t)0x9335), l_76) > l_60) < 0x5D7125C5))) / (int32_t)l_218) < l_218))) , 0x5A487C26) / (uint32_t)l_218)) % (int16_t)0x0952);
    l_243 = ((int16_t)0x466B * (int16_t)p_54.f3);
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_63(int32_t  p_64, int32_t  p_65, uint32_t  p_66)
{ /* block id: 93 */
    uint32_t l_224 = 0x32DCA303;
    int32_t l_225 = 0x5DD20738;
    struct S1 l_226 = {0x88FC330A,0xBB82,5,0x4834,-2};
    struct S0 l_227 = {0x760A};
    for (p_64 = (-4); (p_64 < (-15)); --p_64)
    { /* block id: 96 */
        struct S1 l_223 = {0x960850B4,1U,-2,0x58FD,-8};
        l_227 = ((p_64 < 0x7275) , func_77(((0x968FDB46 & ((uint16_t)((l_223 , l_223.f2) == ((func_69(p_64) || (((l_224 >= (l_224 & l_223.f3)) && (-10)) <= p_65)) == l_224)) - (uint16_t)p_64)) > 0x0CD27CE9), l_225, l_226, l_223.f1));
        l_223.f0 = ((int16_t)((int16_t)((uint32_t)(0x5788D5B5 ^ ((int16_t)((int16_t)0xEB63 % (int16_t)p_65) >> (int16_t)((uint16_t)(((uint32_t)((!l_226.f2) | p_66) % (uint32_t)func_69(p_65)) < p_66) << (uint16_t)p_64))) / (uint32_t)p_65) >> (int16_t)15) << (int16_t)13);
        if (p_64)
            continue;
        l_227 = func_77(l_223.f1, p_64, l_226, p_65);
    }
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_69(int32_t  p_70)
{ /* block id: 89 */
    uint32_t l_204 = 0x65977C52;
    int32_t l_216 = 0xE91F0B04;
    struct S1 l_217 = {0x37715842,0xD5CA,0xCFAA4479,5U,0x370A5D86};
    l_216 = ((int16_t)l_204 * (int16_t)((int16_t)((int16_t)(p_70 <= ((int16_t)(l_204 , (((uint16_t)p_70 * (uint16_t)(((0 < (~((uint16_t)l_204 << (uint16_t)(p_70 > 0)))) || l_204) , 0x276A)) & p_70)) % (int16_t)l_204)) - (int16_t)p_70) + (int16_t)p_70));
    l_217 = l_217;
    return l_217.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_71(int32_t  p_72, int8_t  p_73)
{ /* block id: 38 */
    int32_t l_86 = 0x161DBFA2;
    uint32_t l_98 = 0x41F9F804;
    struct S1 l_172 = {0x87A426AC,0U,1,0xF7C4,0};
    struct S0 l_174 = {0U};
    int16_t l_200 = 0x1C8C;
    l_174 = func_77(p_73, ((uint16_t)((int16_t)l_86 * (int16_t)l_86) / (uint16_t)((int16_t)func_89(p_73, ((int32_t)l_86 % (int32_t)((__builtin_bswap32(__builtin_clzl((((uint16_t)l_98 * (uint16_t)l_86) <= l_98))) >= 65532U) | l_98)), l_98, l_98) / (int16_t)p_72)), l_172, p_72);
    l_172 = l_172;
    if (((int16_t)(0x3DACF38B & (((uint16_t)l_172.f2 * (uint16_t)l_172.f1) , ((int16_t)l_174.f0 - (int16_t)((uint32_t)(p_72 & 7) / (uint32_t)l_172.f1)))) >> (int16_t)3))
    { /* block id: 75 */
        l_172.f0 = (((p_73 & func_89((p_72 && (-(uint16_t)l_172.f3)), ((((0x5EAF73BA && p_72) != p_73) || ((uint32_t)l_172.f4 / (uint32_t)0x5BF8BA2E)) == ((0U && p_72) ^ 0x7BD1)), l_98, l_174.f0)) <= (-1)) , l_172.f1);
    }
    else
    { /* block id: 77 */
        int32_t l_188 = 0x3B5FEB66;
        struct S1 l_192 = {1,0x4E49,0xFCC9BDC8,9U,0x7A7A2773};
        l_172.f0 = ((l_188 == (((int16_t)__builtin_popcountl(p_73) >> (int16_t)func_89(p_72, (p_73 == (-(uint16_t)(((l_86 , 0x39178996) != p_72) | 4294967290U))), l_172.f0, l_188)) < 0x882A)) > 0U);
        l_192 = l_192;
    }
    if (l_172.f1)
    { /* block id: 81 */
        struct S1 l_193 = {-3,0x233E,0xB62B2D3F,1U,2};
        l_172.f0 = p_72;
        l_193 = l_172;
        l_193.f0 = ((__builtin_clzll((l_193 , 0U)) | (((0xE7879B07 != (0xDC3B & p_73)) > ((int16_t)func_89(p_72, ((((int16_t)(((p_73 && ((((((int16_t)(func_89(p_73, p_73, l_172.f2, p_73) & l_193.f3) >> (int16_t)l_174.f0) != 0xC376) < 0x566E7184) || l_174.f0) , 0x69CF)) ^ 5) && l_193.f1) << (int16_t)p_72) ^ l_86) , p_72), p_73, l_193.f0) % (int16_t)l_193.f0)) & l_200)) < 0xE5B3C0A7);
    }
    else
    { /* block id: 85 */
        int32_t l_201 = 1;
        l_172.f0 = (l_86 , (p_73 >= l_201));
    }
    return l_200;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_77(uint16_t  p_78, int32_t  p_79, struct S1  p_80, int32_t  p_81)
{ /* block id: 70 */
    struct S0 l_173 = {1U};
    p_80.f0 = p_80.f1;
    return l_173;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_89(int32_t  p_90, uint16_t  p_91, int8_t  p_92, uint16_t  p_93)
{ /* block id: 39 */
    int16_t l_103 = (-1);
    int32_t l_123 = 0x233ED785;
    int32_t l_124 = (-1);
    struct S1 l_133 = {0x42B88B27,1U,0xD5F2590C,65531U,0xD2C718CA};
    uint32_t l_141 = 0xF35E5FA5;
    if (((uint16_t)((int16_t)l_103 / (int16_t)0x0B1C) >> (uint16_t)((uint16_t)65535U * (uint16_t)(p_90 || l_103))))
    { /* block id: 40 */
        uint32_t l_110 = 0x40F48B4F;
        int32_t l_119 = 4;
        l_119 = ((uint16_t)p_91 << (uint16_t)__builtin_parity(((((uint16_t)((-9) == (l_103 > l_110)) * (uint16_t)(((int16_t)((l_110 <= (((int32_t)(((((uint16_t)p_92 / (uint16_t)p_90) | (((int16_t)l_103 * (int16_t)l_103) < l_110)) <= 5U) , p_90) + (int32_t)0xAC8A3317) & l_103)) && 0x88ECCDF3) % (int16_t)l_110) >= p_91)) , p_90) != l_110)));
        for (p_93 = (-5); (p_93 <= 6); p_93 += 2)
        { /* block id: 44 */
            int32_t l_122 = 5;
            return l_122;
        }
        l_124 = (((p_92 && p_92) > p_93) , l_123);
    }
    else
    { /* block id: 48 */
        uint32_t l_127 = 4294967288U;
        int32_t l_143 = 9;
        if (((int32_t)l_127 + (int32_t)((int16_t)(p_93 >= (65529U && p_93)) - (int16_t)(((uint16_t)(~(65535U | ((3 | (65531U != l_123)) < l_124))) << (uint16_t)l_103) , l_127))))
        { /* block id: 49 */
            struct S1 l_134 = {0x1820E1BC,65535U,0x8C8FF697,0x05BA,0x186717EF};
            l_134 = l_133;
        }
        else
        { /* block id: 51 */
            int16_t l_142 = 0;
            for (l_133.f4 = (-26); (l_133.f4 >= 28); l_133.f4 += 1)
            { /* block id: 54 */
                l_142 = ((int16_t)(p_93 >= p_92) / (int16_t)((int16_t)l_141 << (int16_t)l_133.f1));
            }
            if (p_93)
            { /* block id: 57 */
                int32_t l_157 = 7;
                l_143 = l_127;
                l_157 = (((uint16_t)p_93 >> (uint16_t)15) || __builtin_parityl(((uint16_t)((int16_t)(((+((uint16_t)(p_92 < 1U) - (uint16_t)((0xE99C33BC >= l_157) == (((int32_t)l_142 / (int32_t)(l_143 , l_157)) < (l_143 > 0x7D9254FF))))) >= p_91) > 0) - (int16_t)p_90) >> (uint16_t)15)));
                l_124 = p_90;
            }
            else
            { /* block id: 61 */
                l_143 = l_142;
            }
            l_124 = ((int16_t)l_124 - (int16_t)(l_127 > l_127));
        }
        return p_91;
    }
    l_133.f0 = (p_92 <= (0U < ((uint16_t)((int16_t)((uint32_t)((l_133.f2 < ((l_123 , (__builtin_ctzll(l_141) & 0x7EB2)) >= ((0x77C446C1 && ((uint16_t)(((((uint16_t)0x9C1B / (uint16_t)p_90) & 0x24C0CEF9) , 0U) <= 0U) - (uint16_t)l_133.f4)) != p_93))) && p_90) + (uint32_t)l_103) >> (int16_t)6) - (uint16_t)0x896A)));
    return l_133.f3;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 44
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 8
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 2
   depth: 19, occurrence: 4
   depth: 20, occurrence: 3
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 267
XXX times a non-volatile is write: 40
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 58
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 18
   depth: 2, occurrence: 5
   depth: 3, occurrence: 5

XXX percentage a fresh-made variable is used: 20.1
XXX percentage an existing variable is used: 79.9
********************* end of statistics **********************/

