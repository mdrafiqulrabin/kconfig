/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --float --no-math64 --inline-function --muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      4096684458
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static float  func_29(void);
static float  func_34(int32_t  p_35, int32_t * p_36, const int16_t  p_37);
inline static uint16_t  func_50(const uint32_t  p_51);
static int32_t  func_58(int32_t * p_59, int32_t * const  p_60, uint32_t  p_61);
static int32_t * func_62(int32_t  p_63);
static int16_t  func_66(int32_t * p_67, uint32_t  p_68, int32_t * p_69, uint32_t  p_70, int32_t * p_71);
static uint16_t  func_74(int32_t * p_75, uint32_t  p_76, int32_t * p_77, uint32_t  p_78);
inline static int32_t  func_81(int32_t * p_82, uint16_t  p_83, int32_t  p_84, int32_t * p_85);
inline static int32_t * func_86(int32_t * p_87, int32_t * p_88, int32_t * p_89, int32_t  p_90, int32_t  p_91);
static int32_t  func_92(int32_t * p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_29(void)
{ /* block id: 36 */
    float l_30 = 0x8.Dp+1;
    int32_t l_31 = 0x25D2D915L;
    int32_t *l_32 = &l_31;
    float *l_600 = &l_30;
    int16_t l_601 = 0L;
    (*l_32) = l_31;
    (*l_600) = (-func_34((*l_32), &l_31, (safe_mul_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(0x6284L, 5)), ((((*l_32) , (safe_mod_func_int32_t_s_s((*l_32), (safe_mul_func_int16_t_s_s((*l_32), (((*l_32) , (safe_add_func_uint16_t_u_u(__builtin_parity(((((*l_32) == (safe_mul_func_uint16_t_u_u(func_50((safe_sub_func_int32_t_s_s((((((safe_sub_func_int16_t_s_s((safe_sub_func_int32_t_s_s((func_58(func_62((*l_32)), &l_31, (*l_32)) && (*l_32)), (*l_32))), (*l_32))) & (*l_32)) , (*l_32)) , (*l_32)) , (*l_32)), (*l_32)))), (*l_32)))) && (*l_32)) , 0xF32C1878L)), (*l_32)))) , (*l_32))))))) & 0x58D0L) || 65535UL)))));
    return l_601;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_34(int32_t  p_35, int32_t * p_36, const int16_t  p_37)
{ /* block id: 112 */
    float ***l_269 = (void*)0;
    int32_t l_275 = 0L;
    int32_t l_457 = 0L;
    int32_t *l_492 = &l_457;
    int32_t **l_491 = &l_492;
    float l_529 = 0x5.B017B5p-37;
    float *l_528 = &l_529;
    float **l_527 = &l_528;
    int32_t *l_599 = &l_275;
    p_36 = p_36;
    if ((safe_div_func_uint16_t_u_u((safe_add_func_int16_t_s_s(__builtin_ffs((safe_mul_func_uint16_t_u_u(((func_92(p_36) != ((safe_add_func_int32_t_s_s((safe_sub_func_int32_t_s_s((safe_sub_func_uint16_t_u_u(((l_269 == (((void*)0 != p_36) , l_269)) , (safe_div_func_uint16_t_u_u((safe_unary_minus_func_int32_t_s(((safe_mul_func_int16_t_s_s(((p_35 >= (((l_275 | ((safe_add_func_uint16_t_u_u(((*p_36) >= l_275), p_35)) < (*p_36))) < l_275) >= l_275)) || l_275), p_35)) > l_275))), p_37))), (-1L))), l_275)), (-3L))) < l_275)) == l_275), 65531UL))), 0x1DAEL)), l_275)))
    { /* block id: 114 */
        uint32_t l_285 = 4294967288UL;
        int32_t *l_286 = (void*)0;
        (*p_36) = (safe_rshift_func_int16_t_s_s((((!p_35) <= func_50((safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((l_285 , ((p_35 , func_86(l_286, func_62(((safe_add_func_uint16_t_u_u(((~(((p_35 , (safe_mul_func_int16_t_s_s(((safe_div_func_int32_t_s_s((((safe_mod_func_int16_t_s_s(l_275, p_37)) , (safe_lshift_func_uint16_t_u_s(((safe_mod_func_uint16_t_u_u(l_275, (((p_35 , (void*)0) != (void*)0) | l_285))) || l_275), p_35))) & 0x06586DAFL), p_37)) , l_275), l_275))) <= (-9L)) < 1L)) <= p_35), l_275)) , p_37)), &l_275, p_37, p_37)) != (void*)0)) , 0x75DEL), 9)), 0x91CBL)))) > 0x1957L), p_35));
    }
    else
    { /* block id: 116 */
        int32_t *l_300 = &l_275;
        int32_t **l_303 = &l_300;
        uint32_t l_325 = 0xD9368896L;
        float l_352 = 0x1.Dp-1;
        float * const l_351 = &l_352;
        float * const *l_350 = &l_351;
        uint16_t l_367 = 0xD59AL;
        int32_t *l_370 = &l_275;
        float *l_385 = &l_352;
        float ****l_510 = &l_269;
        float *****l_509 = &l_510;
        uint32_t l_572 = 0x27D9AA1CL;
        p_36 = func_86(&l_275, func_86(p_36, p_36, l_300, (*l_300), (func_58(p_36, &l_275, (safe_sub_func_int16_t_s_s((*l_300), (*l_300)))) & p_35)), p_36, p_35, (*l_300));
        (*l_303) = &l_275;
        if (__builtin_ia32_crc32qi(p_35, p_35))
        { /* block id: 119 */
            int32_t * const l_331 = &l_275;
            int32_t l_333 = 8L;
            int32_t *l_332 = &l_333;
            float ****l_346 = &l_269;
            const float *l_358 = (void*)0;
            const float ** const l_357 = &l_358;
            for (l_275 = 2; (l_275 <= (-24)); l_275 = safe_sub_func_int32_t_s_s(l_275, 1))
            { /* block id: 122 */
                int32_t *l_317 = &l_275;
                int32_t *l_345 = &l_333;
                float *l_356 = &l_352;
                float **l_355 = &l_356;
            }
            for (l_275 = 0; (l_275 > (-18)); l_275 = safe_sub_func_int16_t_s_s(l_275, 3))
            { /* block id: 155 */
                uint32_t l_373 = 0xA3A9C7EAL;
                float *l_375 = (void*)0;
                float **l_374 = &l_375;
                (*l_303) = l_370;
                if (l_275)
                    continue;
                (*l_351) = (safe_div_func_float_f_f((func_50((((((__builtin_parityll(l_373) , __builtin_popcountll(((__builtin_parityll(p_37) == (l_374 != &l_375)) > func_92(p_36)))) >= l_373) > 0x1D0DC95DL) , &l_374) == l_269)) == (-0x3.Ep-1)), p_37));
            }
            for (l_367 = 0; (l_367 <= 30); l_367 = safe_add_func_int32_t_s_s(l_367, 1))
            { /* block id: 162 */
                uint16_t l_379 = 65530UL;
                int32_t *l_427 = &l_333;
                float **l_440 = &l_385;
                int32_t * const l_496 = (void*)0;
            }
        }
        else
        { /* block id: 221 */
            uint16_t l_520 = 65535UL;
            float *l_541 = &l_529;
            (*l_492) = (safe_mod_func_uint16_t_u_u(p_35, 0x4ACAL));
            (*l_385) = (*l_300);
            (*l_303) = p_36;
            if (((func_81((((safe_mul_func_int16_t_s_s((l_520 == 0xB77EL), ((((safe_div_func_int32_t_s_s((safe_mod_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_u((((void*)0 != l_527) != 4UL), (**l_491))) , p_37), l_520)), (safe_rshift_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u(p_35, (**l_303))) || 5UL), l_520)))) , p_35) != (**l_303)) , 0xAA28L))) | (*l_300)) , p_36), p_35, l_520, p_36) , (-5L)) != 1L))
            { /* block id: 225 */
                int32_t *l_534 = &l_275;
                (*l_303) = (func_66(l_534, (__builtin_parity((**l_491)) < 0xAF83L), p_36, (safe_rshift_func_int16_t_s_u(p_35, 15)), func_86(func_62((((((1UL > (safe_mod_func_uint32_t_u_u(0x29BD0EFDL, ((((safe_sub_func_int32_t_s_s(1L, 0x52D2AC3BL)) ^ (*p_36)) > l_520) , 0x34CA72E6L)))) != (**l_303)) , p_36) != p_36) , (-7L))), (*l_303), (*l_491), (*l_300), (*l_370))) , (void*)0);
                (*l_534) = (((*l_534) == (*l_492)) < (l_534 != l_541));
            }
            else
            { /* block id: 228 */
                int8_t l_546 = 1L;
                int32_t **l_574 = (void*)0;
                for (l_457 = 0; (l_457 == (-1)); l_457 = safe_sub_func_uint16_t_u_u(l_457, 3))
                { /* block id: 231 */
                    (*l_370) = (0x97BD82C9L | p_35);
                    for (l_520 = 23; (l_520 != 52); l_520 = safe_add_func_int16_t_s_s(l_520, 1))
                    { /* block id: 235 */
                        (*p_36) = (l_546 , (((safe_unary_minus_func_uint32_t_u(l_520)) , 0xF563A9C1L) < (__builtin_ctz((*l_492)) <= __builtin_ctzl(l_546))));
                        (*l_491) = p_36;
                    }
                }
                for (l_325 = 0; (l_325 <= 43); ++l_325)
                { /* block id: 242 */
                    int32_t *l_573 = &l_275;
                    for (p_35 = 0; (p_35 > (-6)); p_35 = safe_sub_func_uint16_t_u_u(p_35, 1))
                    { /* block id: 245 */
                        uint32_t l_560 = 0UL;
                        (**l_491) = (((p_35 & (safe_sub_func_int32_t_s_s(1L, p_37))) , ((safe_lshift_func_uint16_t_u_u((safe_div_func_int16_t_s_s(l_546, p_37)), 9)) , (safe_add_func_uint32_t_u_u((((l_560 , __builtin_ffs((*p_36))) , 1UL) != 0x9D78L), (*p_36))))) <= p_37);
                        (*l_300) = (safe_add_func_uint32_t_u_u((((p_35 != p_35) ^ (safe_div_func_int16_t_s_s(func_81(((p_37 == 6UL) , (*l_303)), ((safe_div_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u(l_520, l_560)), (safe_lshift_func_int16_t_s_s(p_35, 10)))) == (+(func_74(func_62(l_572), l_520, l_573, l_560) , l_520))), l_560, p_36), 65535UL))) & p_35), (*l_573)));
                        if ((*l_573))
                            continue;
                    }
                    (*l_492) = (-6L);
                    l_574 = &l_492;
                    (**l_350) = p_37;
                }
            }
        }
    }
    (*p_36) = (safe_add_func_uint16_t_u_u(((((8L && (safe_div_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((((**l_491) || ((safe_div_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((**l_491) , (safe_mul_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((((safe_lshift_func_uint16_t_u_u(0xA370L, (**l_491))) || 0x9453A865L) == (safe_div_func_uint32_t_u_u(((safe_add_func_float_f_f(func_50((safe_div_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(0xA4B4L, 12)) , ((*l_492) && ((*p_36) & (*l_492)))), 0x692EL))), 0xD.4465E9p+33)) , 0xF5E95EBBL), (*l_492)))), 7)), 0x4B41L))), p_37)), (*l_492))) && p_37)) ^ (**l_491)), p_37)), (**l_491)))) , 65534UL) < 0UL) < (**l_491)), (**l_491)));
    l_599 = (*l_491);
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_50(const uint32_t  p_51)
{ /* block id: 106 */
    uint32_t l_248 = 0xC8AFE7F4L;
    float **l_250 = (void*)0;
    float ***l_249 = &l_250;
    uint32_t l_251 = 0UL;
    int32_t l_254 = 0xA0D4A109L;
    int32_t *l_256 = &l_254;
    int32_t **l_255 = &l_256;
    l_254 = ((safe_add_func_int16_t_s_s(__builtin_ctzll(l_248), ((void*)0 != l_249))) , ((l_251 >= p_51) > (((safe_div_func_float_f_f(((p_51 , (p_51 >= p_51)) > p_51), p_51)) >= l_248) != p_51)));
    (*l_255) = func_86(func_62(l_254), &l_254, &l_254, (func_66(&l_254, l_251, (__builtin_parityl(p_51) , &l_254), l_248, &l_254) , l_254), p_51);
    (*l_256) = p_51;
    (*l_256) = p_51;
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads : l_31
 * writes:
 */
static int32_t  func_58(int32_t * p_59, int32_t * const  p_60, uint32_t  p_61)
{ /* block id: 95 */
    float l_200 = 0xB.E35FF2p+93;
    int32_t l_207 = 0x1AD3E3C3L;
    uint32_t l_242 = 0xA70242F9L;
    float *l_244 = (void*)0;
    float **l_243 = &l_244;
    float *l_245 = &l_200;
    for (p_61 = 0; (p_61 != 47); ++p_61)
    { /* block id: 98 */
        float *l_188 = (void*)0;
        float l_190 = 0x6.18C22Cp+93;
        float *l_189 = &l_190;
        int32_t l_193 = 8L;
        (*l_189) = p_61;
        (*l_189) = (p_61 == (safe_mul_func_float_f_f(l_193, ((safe_mul_func_float_f_f((p_61 <= ((safe_div_func_float_f_f(((safe_add_func_float_f_f(0xB.FDC62Dp-18, l_200)) >= __builtin_ctzl((__builtin_ia32_crc32qi(((safe_add_func_int16_t_s_s(((safe_lshift_func_int16_t_s_s((safe_mod_func_int32_t_s_s(l_207, (safe_lshift_func_int16_t_s_u(l_207, 10)))), ((+((l_207 < (safe_add_func_uint16_t_u_u(((*p_60) >= p_61), (-8L)))) , l_207)) > p_61))) != l_207), l_193)) > l_193), p_61) | p_61))), p_61)) > 0x7.0CB0D7p-96)), p_61)) <= l_207))));
        l_193 = l_207;
    }
    l_207 = (safe_sub_func_float_f_f(((safe_mul_func_float_f_f(l_207, p_61)) == (safe_sub_func_float_f_f((!l_207), 0xB.496DE4p+61))), (safe_div_func_float_f_f((safe_add_func_float_f_f((p_61 == ((safe_div_func_float_f_f(p_61, (safe_div_func_float_f_f(0x5.703F93p-69, (((safe_mul_func_float_f_f((((void*)0 != &p_60) , (-0x8.8p-1)), (-0x1.Cp+1))) <= l_207) != 0x1.0C768Cp-31))))) != l_207)), (-0x10.Fp+1))), p_61))));
    (*l_245) = ((((safe_mul_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_s((safe_mul_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(0x1DA8L, func_81(&l_207, (((safe_add_func_int32_t_s_s((l_207 > (l_207 , (-1L))), ((l_207 >= 0xEE9C46A3L) != l_242))) , l_243) == &l_244), l_207, p_59))), 0UL)), 13)) || 0x4D58820EL) & p_61), l_242)) <= p_61) , 0x0.3p+1) < l_207);
    return l_207;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_62(int32_t  p_63)
{ /* block id: 38 */
    int32_t l_64 = 0x45DB0FF8L;
    int32_t l_73 = 0x256CD219L;
    int32_t *l_72 = &l_73;
    uint32_t l_99 = 0xE61175C8L;
    int32_t l_139 = 6L;
    int32_t *l_140 = &l_73;
    int32_t **l_141 = &l_72;
    int32_t l_146 = 0xC5E7E41FL;
    float l_149 = 0x0.0p+1;
    float *l_170 = &l_149;
    float **l_169 = &l_170;
    int32_t *l_183 = &l_73;
    int32_t *l_184 = &l_146;
    int32_t *l_185 = (void*)0;
    if ((l_64 <= (+(func_66(l_72, (func_74(&l_73, (safe_div_func_int32_t_s_s(func_81(func_86((((((p_63 , p_63) , (((__builtin_parityll((*l_72)) < func_92(&l_73)) >= (*l_72)) != l_99)) != p_63) >= (-1L)) , &l_73), &l_73, &l_73, p_63, p_63), (*l_72), p_63, &l_73), p_63)), &l_73, (*l_72)) , p_63), &l_73, (*l_72), &l_73) != (*l_72)))))
    { /* block id: 54 */
        float l_111 = 0x7.55298Ap-58;
        float * const l_110 = &l_111;
        float * const *l_109 = &l_110;
        float *l_114 = &l_111;
        float **l_113 = &l_114;
        float ***l_112 = &l_113;
        int32_t l_115 = 0xF2F470B9L;
        int32_t *l_117 = &l_73;
        int32_t *l_118 = &l_115;
        int32_t *l_119 = &l_73;
        int32_t *l_120 = (void*)0;
        int32_t **l_131 = &l_72;
        (*l_112) = l_109;
        if (l_115)
        { /* block id: 56 */
            (*l_72) = ((void*)0 == &l_72);
        }
        else
        { /* block id: 58 */
            int32_t *l_116 = &l_115;
            return l_120;
        }
        (*l_131) = func_86(func_86(&l_115, ((((safe_mod_func_int16_t_s_s((((*l_72) , ((safe_lshift_func_uint16_t_u_s(p_63, 14)) | (*l_118))) && ((safe_mod_func_int16_t_s_s((safe_mul_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((*l_119), (((*l_72) , p_63) , (0xE0CFL || p_63)))), (*l_117))), p_63)) , (*l_72))), (*l_72))) ^ 0xD78952EBL) , 3UL) , &l_115), &l_73, (*l_117), (*l_72)), &l_115, &l_73, p_63, p_63);
    }
    else
    { /* block id: 62 */
        uint32_t l_132 = 0UL;
        l_132 = (*l_72);
    }
    (*l_141) = func_86(func_86(&l_73, func_86(&l_73, func_86(((safe_rshift_func_int16_t_s_s(p_63, (safe_add_func_int32_t_s_s(((0x0BE9L == (*l_72)) , ((safe_mod_func_int16_t_s_s((p_63 ^ l_139), (*l_72))) , (*l_72))), (*l_72))))) , l_140), &l_73, &l_73, p_63, (*l_140)), &l_73, p_63, (*l_140)), &l_73, (*l_72), p_63), &l_73, &l_73, (*l_140), (*l_72));
    (**l_141) = (safe_mul_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(p_63, 12)) || (*l_140)), l_146));
    if (((safe_rshift_func_uint16_t_u_s((*l_140), 3)) == (*l_72)))
    { /* block id: 67 */
        (*l_140) = 4L;
    }
    else
    { /* block id: 69 */
        int32_t *l_167 = (void*)0;
        uint32_t l_180 = 0x5B865CE0L;
        int16_t l_181 = 8L;
        for (l_146 = 22; (l_146 >= (-1)); l_146 = safe_sub_func_uint32_t_u_u(l_146, 6))
        { /* block id: 72 */
            float *l_154 = (void*)0;
            int32_t l_157 = 0xC98C3E2EL;
            int32_t **l_158 = (void*)0;
            float **l_171 = &l_154;
            for (l_139 = (-1); (l_139 >= 28); l_139 = safe_add_func_uint16_t_u_u(l_139, 1))
            { /* block id: 75 */
                int32_t ** const l_159 = &l_72;
                float *l_164 = &l_149;
                if ((l_154 == (void*)0))
                { /* block id: 76 */
                    int32_t l_155 = 0xF773013AL;
                    float *l_156 = &l_149;
                    l_155 = p_63;
                    (*l_141) = l_154;
                    (*l_156) = (0x8.0E7A36p+83 != 0x5.EC5ABBp-97);
                    (*l_156) = ((((__builtin_ctzll(p_63) | ((l_157 , l_158) == l_159)) , (safe_mul_func_uint16_t_u_u(((safe_sub_func_uint16_t_u_u(((void*)0 != l_164), (safe_add_func_uint32_t_u_u(p_63, p_63)))) > p_63), p_63))) >= p_63) , p_63);
                }
                else
                { /* block id: 81 */
                    int32_t *l_168 = &l_146;
                    (*l_159) = (*l_141);
                    (*l_141) = func_86((*l_141), l_167, l_168, p_63, ((void*)0 != &l_154));
                }
            }
            l_171 = l_169;
        }
        for (l_139 = 0; (l_139 != (-15)); l_139 = safe_sub_func_uint16_t_u_u(l_139, 5))
        { /* block id: 90 */
            int32_t *l_174 = &l_146;
            int32_t l_182 = 0xB0EF2B8EL;
            (*l_174) = func_66(l_174, (*l_174), func_86(((safe_mul_func_uint16_t_u_u(((((__builtin_popcount(__builtin_clzl(p_63)) && p_63) || p_63) ^ (*l_174)) >= ((safe_sub_func_uint32_t_u_u(((~(((((p_63 & 6L) >= p_63) || l_180) > p_63) < p_63)) == l_181), 0x3CC3ECA6L)) && l_182)), (*l_174))) , &l_182), &l_182, l_167, (*l_174), p_63), (*l_140), (*l_141));
        }
    }
    return l_185;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_66(int32_t * p_67, uint32_t  p_68, int32_t * p_69, uint32_t  p_70, int32_t * p_71)
{ /* block id: 51 */
    int32_t l_108 = 0L;
    int32_t *l_107 = &l_108;
    int32_t **l_106 = &l_107;
    (*l_106) = (void*)0;
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_74(int32_t * p_75, uint32_t  p_76, int32_t * p_77, uint32_t  p_78)
{ /* block id: 48 */
    const float l_103 = (-0x10.9p+1);
    float l_105 = 0x0.0p+1;
    float *l_104 = &l_105;
    (*l_104) = l_103;
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads : l_31
 * writes:
 */
inline static int32_t  func_81(int32_t * p_82, uint16_t  p_83, int32_t  p_84, int32_t * p_85)
{ /* block id: 46 */
    return (*p_82);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_86(int32_t * p_87, int32_t * p_88, int32_t * p_89, int32_t  p_90, int32_t  p_91)
{ /* block id: 43 */
    int32_t l_101 = 0x57AFC499L;
    int32_t *l_100 = &l_101;
    int32_t **l_102 = &l_100;
    (*l_102) = l_100;
    return p_89;
}


/* ------------------------------------------ */
/* 
 * reads : l_31
 * writes:
 */
static int32_t  func_92(int32_t * p_93)
{ /* block id: 39 */
    float l_94 = (-0x4.Ep+1);
    float *l_95 = (void*)0;
    float *l_96 = &l_94;
    int32_t l_98 = 0L;
    int32_t *l_97 = &l_98;
    (*l_96) = l_94;
    l_97 = p_93;
    return (*p_93);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 115
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 16
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 7, occurrence: 2
   depth: 13, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 2
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 107

XXX times a variable address is taken: 141
XXX times a pointer is dereferenced on RHS: 178
breakdown:
   depth: 1, occurrence: 157
   depth: 2, occurrence: 21
XXX times a pointer is dereferenced on LHS: 68
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 394

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 343
   level: 2, occurrence: 37
   level: 3, occurrence: 2
   level: 4, occurrence: 4
XXX number of pointers point to pointers: 37
XXX number of pointers point to scalars: 70
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.2
XXX average alias set size: 1.6

XXX times a non-volatile is read: 856
XXX times a non-volatile is write: 175
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 83
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 14
   depth: 2, occurrence: 12
   depth: 3, occurrence: 8
   depth: 4, occurrence: 12
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 12.7
XXX percentage an existing variable is used: 87.3
********************* end of statistics **********************/

