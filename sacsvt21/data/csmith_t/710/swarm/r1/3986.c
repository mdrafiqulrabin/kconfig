/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1286543716
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 3;
   signed f1 : 30;
   signed f2 : 2;
   unsigned f3 : 15;
   signed f4 : 13;
   unsigned f5 : 2;
   signed f6 : 6;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_28(void);
static uint16_t  func_34(struct S0  p_35);
static int32_t  func_37(int32_t  p_38, int16_t  p_39, struct S0  p_40, int32_t  p_41);
static int16_t  func_43(struct S0  p_44, int32_t  p_45);
static struct S0  func_46(struct S0  p_47);
static int32_t * func_48(uint32_t  p_49, struct S0  p_50, float  p_51);
static int16_t  func_64(int32_t * p_65, uint32_t  p_66, uint32_t  p_67);
static int32_t  func_73(int32_t  p_74, float  p_75);
static int32_t * func_81(uint32_t  p_82, int32_t * p_83, int32_t * p_84);
static int32_t  func_89(int32_t * p_90, uint32_t  p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = 0xBA8B35EDL;
    struct S0 l_351 = {0,8761,1,171,31,0,-3};
    struct S0 *l_352 = &l_351;
    float l_354 = 0xF.F70A99p+10;
    float *l_353 = &l_354;
    for (l_29 = 23; (l_29 > 24); ++l_29)
    { /* block id: 39 */
        float l_32 = 0x1.Dp-1;
        int32_t l_33 = (-4L);
        struct S0 l_36 = {1,23947,1,73,-85,1,-1};
        if (((l_33 ^ func_34(l_36)) <= ((uint32_t)((l_36.f4 , 1UL) , l_29) - (uint32_t)l_36.f2)))
        { /* block id: 188 */
            int32_t *l_348 = &l_29;
            int32_t **l_349 = &l_348;
            (*l_349) = l_348;
        }
        else
        { /* block id: 190 */
            float *l_350 = &l_32;
            (*l_350) = 0x0.Fp-1;
            return l_36.f3;
        }
    }
    (*l_352) = l_351;
    (*l_353) = l_29;
    return l_29;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_34(struct S0  p_35)
{ /* block id: 40 */
    uint32_t l_42 = 0x2FA5D872L;
    int32_t l_289 = 0x30398711L;
    int32_t *l_288 = &l_289;
    struct S0 l_297 = {1,-16977,-1,145,77,0,-5};
    uint32_t l_331 = 4294967293UL;
    int32_t *l_335 = (void*)0;
    int32_t *l_336 = (void*)0;
    int32_t *l_337 = &l_289;
    int32_t **l_345 = &l_336;
    if (func_37(l_42, (__builtin_popcountll(p_35.f2) , func_43(func_46(p_35), (((int16_t)(((int32_t)0x6DD6E431L + (int32_t)(((func_64(l_288, ((0x92EE9E64L | ((int16_t)(0L || (*l_288)) * (int16_t)(*l_288))) , 7UL), (*l_288)) >= (*l_288)) || p_35.f5) <= p_35.f5)) & (*l_288)) * (int16_t)(*l_288)) , (*l_288)))), l_297, p_35.f1))
    { /* block id: 177 */
        int32_t **l_301 = &l_288;
        float l_307 = 0x1.91F784p-71;
        float *l_306 = &l_307;
        (*l_301) = func_48(p_35.f5, p_35, p_35.f6);
        (*l_306) = ((float)0x1.Cp-1 * (float)((float)p_35.f1 / (float)p_35.f2));
    }
    else
    { /* block id: 180 */
        struct S0 *l_308 = (void*)0;
        struct S0 l_309 = {1,-27667,-1,55,-61,0,5};
        float l_330 = 0x2.88E5A8p-18;
        float *l_329 = &l_330;
        int32_t **l_334 = &l_288;
        l_309 = p_35;
        (*l_288) = ((((+__builtin_ffs(l_309.f6)) , (((int32_t)((((__builtin_popcountll(((int16_t)((uint16_t)(((uint16_t)((uint32_t)0x05B0D0C2L % (uint32_t)l_309.f1) % (uint16_t)((uint16_t)func_89(&l_289, p_35.f1) / (uint16_t)((int16_t)((((((float)((1UL | ((uint16_t)(l_329 == l_288) << (uint16_t)l_309.f6)) , p_35.f5) / (float)p_35.f1) , (void*)0) == (void*)0) >= 0x1.Ep-1) , (-8L)) << (int16_t)4))) > (-7L)) * (uint16_t)p_35.f3) - (int16_t)p_35.f3)) < l_331) != l_309.f6) || l_309.f6) ^ p_35.f2) - (int32_t)(*l_288)) , 0x6.661E02p+98)) >= l_309.f6) , l_309.f4);
        (*l_334) = (((*l_288) >= func_73((*l_288), (*l_288))) , func_48((*l_288), p_35, ((((uint16_t)0x0C61L / (uint16_t)0xD738L) , ((p_35.f2 ^ 4294967295UL) <= (*l_288))) , p_35.f4)));
    }
    (*l_337) = 0x5FC2B05FL;
    (*l_345) = func_81((4294967295UL || ((uint16_t)(!((uint16_t)((int16_t)(&l_335 == &l_337) >> (int16_t)0) * (uint16_t)p_35.f3)) / (uint16_t)0xA21AL)), &l_289, &l_289);
    return p_35.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_37(int32_t  p_38, int16_t  p_39, struct S0  p_40, int32_t  p_41)
{ /* block id: 174 */
    int32_t l_300 = 0x99B1E4FEL;
    int32_t *l_299 = &l_300;
    int32_t **l_298 = &l_299;
    (*l_298) = &p_41;
    return p_40.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_43(struct S0  p_44, int32_t  p_45)
{ /* block id: 170 */
    struct S0 l_293 = {1,-11470,0,84,47,1,3};
    struct S0 *l_292 = &l_293;
    int32_t l_295 = (-1L);
    int32_t *l_294 = &l_295;
    int32_t **l_296 = &l_294;
    (*l_292) = p_44;
    (*l_296) = l_294;
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_46(struct S0  p_47)
{ /* block id: 41 */
    int32_t l_52 = (-1L);
    struct S0 l_53 = {1,-28579,-0,14,3,1,5};
    int32_t *l_281 = &l_52;
    float l_283 = 0x3.923DBFp+56;
    float *l_282 = &l_283;
    l_281 = func_48(l_52, l_53, p_47.f1);
    (*l_282) = 0xB.B943A5p+78;
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_48(uint32_t  p_49, struct S0  p_50, float  p_51)
{ /* block id: 42 */
    int32_t *l_68 = (void*)0;
    struct S0 l_159 = {1,30155,0,171,10,0,5};
    struct S0 l_190 = {0,12606,0,167,-45,0,-4};
    for (p_49 = 0; (p_49 < 47); ++p_49)
    { /* block id: 45 */
        int32_t l_56 = 0xCE724D25L;
        struct S0 *l_161 = &l_159;
        int16_t l_167 = 1L;
        float l_273 = 0xC.A248FCp+77;
        float *l_272 = &l_273;
        float **l_271 = &l_272;
        for (l_56 = (-12); (l_56 > 17); l_56 += 5)
        { /* block id: 48 */
            int32_t l_59 = 0L;
            int16_t l_171 = 0xB1F2L;
            int16_t l_200 = 0x04E7L;
            struct S0 **l_258 = &l_161;
            int32_t l_262 = (-8L);
            for (l_59 = 0; (l_59 < (-26)); l_59 -= 1)
            { /* block id: 51 */
                uint32_t l_78 = 0xE690D922L;
                int32_t **l_158 = &l_68;
                struct S0 **l_234 = &l_161;
                struct S0 *l_239 = (void*)0;
                (*l_158) = (((int16_t)func_64(l_68, p_50.f3, (__builtin_ctz(l_56) > ((int16_t)p_50.f3 + (int16_t)(((uint16_t)l_56 >> (uint16_t)11) >= (func_73((l_56 | (p_50.f4 <= ((int32_t)(0xCD98C7BEL <= l_56) + (int32_t)l_78))), p_50.f6) < 0xB34A7E5EL))))) >> (int16_t)0) , (void*)0);
                if (l_59)
                { /* block id: 109 */
                    if (p_50.f4)
                        break;
                }
                else
                { /* block id: 111 */
                    struct S0 *l_160 = &l_159;
                    (*l_160) = l_159;
                }
                if (((l_161 == ((((uint32_t)((+((uint16_t)l_167 * (uint16_t)(((int16_t)((!__builtin_ia32_crc32qi((p_50.f2 < p_50.f1), (((p_50.f0 != l_167) , ((0x8F5FB703L <= l_59) < p_50.f0)) , l_78))) == p_49) >> (int16_t)6) <= p_50.f1))) < p_50.f2) % (uint32_t)l_167) > l_171) , (void*)0)) >= (-1L)))
                { /* block id: 114 */
                    (*l_158) = func_81(l_167, l_68, l_68);
                }
                else
                { /* block id: 116 */
                    int32_t l_176 = 0L;
                    float l_181 = 0x9.9p-1;
                    struct S0 l_199 = {0,-10596,1,148,-3,0,2};
                    (*l_158) = func_81(((uint16_t)func_64(&l_56, p_50.f3, (((uint16_t)l_176 << (uint16_t)1) > ((int16_t)((uint16_t)__builtin_ctzl(l_176) >> (uint16_t)(__builtin_parityl(p_50.f3) == l_176)) * (int16_t)(((p_50.f0 || 1UL) , (-9L)) > p_50.f1)))) << (uint16_t)p_50.f2), (*l_158), l_68);
                    if (l_176)
                        continue;
                    if (((uint16_t)((l_59 , (((uint32_t)2UL - (uint32_t)p_50.f2) > ((uint16_t)(p_50.f6 || p_50.f5) * (uint16_t)p_50.f2))) , l_167) + (uint16_t)((uint16_t)p_50.f6 * (uint16_t)p_50.f0)))
                    { /* block id: 119 */
                        p_50 = l_190;
                    }
                    else
                    { /* block id: 121 */
                        uint32_t l_191 = 0xA2E44315L;
                        (*l_158) = l_68;
                        if (l_191)
                            break;
                    }
                    p_51 = (((((float)((float)(((~p_50.f4) , ((float)p_49 * (float)(__builtin_bswap64((l_199 , (l_200 ^ ((0x68CCL == ((p_50.f1 > (((((uint16_t)l_199.f3 + (uint16_t)((&l_161 != &l_161) < p_50.f2)) ^ 1L) || 0L) & p_50.f0)) && l_59)) , 0xEBD4F263L)))) != l_199.f6))) < p_50.f4) - (float)0x1.1p-1) - (float)p_50.f6) <= p_50.f3) >= 0x6.A79449p+60) != l_59);
                }
                if (p_50.f1)
                { /* block id: 127 */
                    uint16_t l_213 = 5UL;
                    int32_t *l_245 = (void*)0;
                    if ((((int16_t)(-1L) - (int16_t)(((__builtin_ffsll(((uint32_t)((int32_t)0L - (int32_t)0x3F684F3EL) / (uint32_t)p_49)) && ((uint16_t)((uint16_t)p_50.f1 + (uint16_t)p_50.f1) + (uint16_t)(1UL != ((p_50.f6 & p_50.f1) < l_167)))) != p_49) == l_213)) != p_50.f5))
                    { /* block id: 128 */
                        uint32_t l_224 = 0xA7965D11L;
                        int32_t l_235 = 0x7D2B290DL;
                        l_235 = ((int16_t)l_167 + (int16_t)(((((((0xCC8346BCL != ((int16_t)p_50.f2 << (int16_t)((int16_t)(-6L) << (int16_t)((uint32_t)((int32_t)((l_171 != l_224) != ((uint32_t)((((uint16_t)(((((((float)(+((l_224 , (p_49 , ((int32_t)l_224 - (int32_t)0L))) , 0x1.3p-1)) / (float)p_50.f1) < (-0x1.Cp+1)) , l_213) , l_56) == p_50.f0) ^ 5L) - (uint16_t)0x424AL) , (void*)0) != (void*)0) + (uint32_t)4294967295UL)) / (int32_t)p_50.f2) / (uint32_t)l_224)))) && 65526UL) <= 0x38A5L) , 0x2.9p-1) , l_234) != (void*)0) != 0x4F094863L));
                        (*l_158) = &l_235;
                    }
                    else
                    { /* block id: 131 */
                        uint16_t l_236 = 0x2C65L;
                        float *l_242 = (void*)0;
                        float l_244 = 0x6.FDB1ADp+26;
                        float *l_243 = &l_244;
                        p_50.f6 = (l_236 , ((int16_t)(&p_50 == l_239) % (int16_t)(((&p_50 != (p_50 , &p_50)) && (0x23561A8AL < ((uint32_t)4294967293UL % (uint32_t)(func_73((((void*)0 == &l_161) <= l_171), p_51) , p_50.f6)))) || l_171)));
                        (*l_243) = ((l_236 < l_167) <= (-0x4.2p-1));
                        (*l_161) = p_50;
                        if (p_49)
                            break;
                    }
                    return l_245;
                }
                else
                { /* block id: 138 */
                    float l_255 = (-0x9.6p-1);
                    float *l_254 = &l_255;
                    float **l_253 = &l_254;
                    int32_t l_270 = 0x87685B39L;
                    for (l_78 = 0; (l_78 > 45); ++l_78)
                    { /* block id: 141 */
                        int32_t l_249 = 0x572D6567L;
                        int32_t *l_248 = &l_249;
                        float l_252 = (-0x1.4p+1);
                        float *l_251 = &l_252;
                        float **l_250 = &l_251;
                        (*l_248) = 0L;
                        l_253 = l_250;
                    }
                    (*l_158) = l_68;
                    (*l_158) = (*l_158);
                    if (p_50.f1)
                    { /* block id: 147 */
                        int32_t l_261 = 0xF2BC7403L;
                        int32_t *l_260 = &l_261;
                        (*l_260) = ((((p_49 || p_50.f2) != p_50.f2) >= ((&l_161 != (((int32_t)l_167 + (int32_t)l_167) , l_258)) , p_50.f2)) , (+(p_49 == l_56)));
                        if (p_50.f0)
                            continue;
                        if (p_50.f6)
                            continue;
                        (*l_260) = 0x96FE7B0AL;
                    }
                    else
                    { /* block id: 152 */
                        uint16_t l_265 = 65527UL;
                        (*l_161) = (((((l_262 & ((0x85B44177L & ((((int16_t)((p_50.f2 , p_49) || (l_171 != l_265)) / (int16_t)((uint16_t)l_265 >> (uint16_t)(((int16_t)(__builtin_popcountl((p_50.f0 , l_167)) && (-1L)) * (int16_t)5L) , 0x2188L))) < l_167) , 0UL)) && p_50.f0)) >= l_270) , l_271) != (void*)0) , p_50);
                    }
                }
            }
        }
        return l_68;
    }
    for (p_49 = 0; (p_49 < 3); p_49++)
    { /* block id: 162 */
        struct S0 *l_276 = &l_159;
        int32_t l_278 = (-2L);
        int32_t **l_280 = &l_68;
        (*l_276) = p_50;
    }
    return l_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_64(int32_t * p_65, uint32_t  p_66, uint32_t  p_67)
{ /* block id: 98 */
    int32_t l_150 = (-9L);
    int32_t *l_149 = &l_150;
    struct S0 l_157 = {1,31292,0,52,79,1,0};
    struct S0 *l_156 = &l_157;
    struct S0 **l_155 = &l_156;
    for (p_67 = (-5); (p_67 <= 52); ++p_67)
    { /* block id: 101 */
        int32_t **l_151 = &l_149;
        struct S0 l_154 = {1,22148,1,160,9,0,7};
        struct S0 *l_153 = &l_154;
        struct S0 **l_152 = &l_153;
        (*l_151) = l_149;
        (*l_151) = (*l_151);
        l_155 = l_152;
        p_65 = p_65;
    }
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_73(int32_t  p_74, float  p_75)
{ /* block id: 52 */
    struct S0 l_92 = {0,-22792,-1,139,50,0,-6};
    int32_t l_105 = 0L;
    int32_t *l_104 = &l_105;
    uint32_t l_125 = 0x9CD7CB0FL;
    for (p_74 = 0; (p_74 != (-2)); p_74 -= 2)
    { /* block id: 55 */
        int32_t l_99 = (-1L);
        int32_t **l_112 = &l_104;
        struct S0 l_122 = {0,-32496,-1,131,1,1,-7};
        int32_t *l_124 = &l_99;
        (*l_112) = func_81((p_74 != ((((uint16_t)((((uint32_t)((((func_89((((l_92 , (void*)0) != (((float)((float)((float)p_75 / (float)l_99) / (float)(((void*)0 != &p_74) >= (((((float)((float)p_74 / (float)l_92.f1) * (float)l_99) != l_92.f4) < p_75) > p_75))) + (float)p_75) , l_104)) , &l_105), p_74) || 0x43529ADFL) > l_99) && l_99) ^ (*l_104)) % (uint32_t)p_74) == 0x96E7F8E4L) || p_74) / (uint16_t)l_99) , &p_74) == &p_74)), &l_99, &l_105);
        if ((((int16_t)p_74 - (int16_t)((((((float)(*l_104) - (float)((*l_104) , ((**l_112) , ((p_74 == ((((**l_112) , p_75) >= ((float)((p_74 != ((((-(int32_t)(-10L)) >= (*l_104)) , p_75) >= 0x2.Dp+1)) < p_74) - (float)(*l_104))) <= p_75)) < p_75)))) >= (**l_112)) < p_75) , p_74) || 0x52CEL)) && (*l_104)))
        { /* block id: 63 */
            int16_t l_120 = 1L;
            if (l_120)
                break;
            (*l_104) = (&p_74 != (*l_112));
        }
        else
        { /* block id: 66 */
            int32_t *l_123 = &l_99;
            (*l_124) = (l_92 , func_89(func_81((-(int32_t)p_74), (l_122 , ((p_74 , (&l_105 == &p_74)) , l_123)), l_124), p_74));
        }
    }
    if (l_125)
    { /* block id: 70 */
        struct S0 *l_127 = &l_92;
        struct S0 **l_126 = &l_127;
        float l_129 = 0x4.C16660p-92;
        float *l_128 = &l_129;
        (*l_126) = &l_92;
        (*l_128) = 0x7.E38979p+58;
    }
    else
    { /* block id: 73 */
        int32_t **l_130 = &l_104;
        struct S0 *l_135 = &l_92;
        struct S0 **l_143 = &l_135;
        int32_t *l_146 = &l_105;
        (*l_130) = &p_74;
        for (l_125 = 0; (l_125 > 37); l_125 += 7)
        { /* block id: 77 */
            uint32_t l_142 = 0xBA6DCB14L;
            for (l_105 = 14; (l_105 > (-29)); l_105 -= 7)
            { /* block id: 80 */
                struct S0 **l_136 = &l_135;
                (*l_136) = l_135;
                for (p_74 = 0; (p_74 == (-8)); p_74 -= 9)
                { /* block id: 84 */
                    int32_t l_139 = 1L;
                    for (l_139 = 0; (l_139 != (-7)); l_139 -= 1)
                    { /* block id: 87 */
                        return l_142;
                    }
                    if (p_74)
                        continue;
                }
            }
        }
        (*l_143) = &l_92;
        (*l_130) = func_81((0x4ECE64C3L ^ ((uint16_t)p_74 << (uint16_t)p_74)), l_146, (*l_130));
    }
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_81(uint32_t  p_82, int32_t * p_83, int32_t * p_84)
{ /* block id: 58 */
    int32_t l_109 = (-8L);
    int32_t *l_108 = &l_109;
    int32_t **l_107 = &l_108;
    float l_111 = 0x1.9p-1;
    float *l_110 = &l_111;
    (*l_107) = p_84;
    (*l_110) = 0x6.Dp+1;
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_89(int32_t * p_90, uint32_t  p_91)
{ /* block id: 56 */
    uint32_t l_106 = 0xE582B275L;
    return l_106;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 55
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 4
XXX full-bitfields structs in the program: 10
breakdown:
   indirect level: 0, occurrence: 10
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 83

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 109
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 68

XXX times a variable address is taken: 86
XXX times a pointer is dereferenced on RHS: 27
breakdown:
   depth: 1, occurrence: 24
   depth: 2, occurrence: 3
XXX times a pointer is dereferenced on LHS: 43
breakdown:
   depth: 1, occurrence: 43
XXX times a pointer is compared with null: 3
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 84

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 101
   level: 2, occurrence: 17
XXX number of pointers point to pointers: 22
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 22.1
XXX average alias set size: 1.46

XXX times a non-volatile is read: 359
XXX times a non-volatile is write: 107
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 95
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 21
   depth: 2, occurrence: 8
   depth: 3, occurrence: 6
   depth: 4, occurrence: 15
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 17.4
XXX percentage an existing variable is used: 82.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

