/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1268020268
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   volatile int32_t  f0;
   int16_t  f1;
   const volatile uint16_t  f2;
   uint32_t  f3;
   const volatile int16_t  f4;
};

struct S1 {
   volatile int32_t  f0;
   uint16_t  f1;
   const volatile int32_t  f2;
   int32_t  f3;
   const volatile int32_t  f4;
   uint32_t  f5;
   const struct S0  f6;
   int32_t  f7;
   uint32_t  f8;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_6 = 0xB4BCL;
static const uint16_t g_21 = 65533UL;
static uint16_t g_43 = 1UL;
static int32_t g_71 = 0xD3FD9053L;
static int32_t g_75 = (-2L);
static uint32_t *g_80 = (void*)0;
static volatile uint32_t g_83 = 4UL;/* VOLATILE GLOBAL g_83 */
static volatile uint32_t *g_82 = &g_83;
static uint32_t g_93 = 0x6394AE98L;
static int16_t g_95 = (-8L);
static int16_t *g_119 = &g_95;
static int16_t g_130 = 0xA172L;
static int32_t g_132 = (-1L);
static int32_t *g_131 = &g_132;
static struct S1 g_161 = {0x4A8A8F1CL,65534UL,0x19F0035EL,-1L,5L,0x827A6358L,{0x857EB286L,0L,65531UL,1UL,0x3B37L},0xFB2C377CL,0x46C13A8AL};/* VOLATILE GLOBAL g_161 */
static int16_t g_196 = 0x0D3EL;
static volatile uint32_t * const *g_228 = &g_82;
static volatile uint32_t * const ** const g_227 = &g_228;
static int32_t **g_286 = &g_131;
static int32_t ***g_285 = &g_286;
static int32_t ****g_284 = &g_285;
static int32_t ****g_287 = (void*)0;
static struct S1 *g_310 = (void*)0;
static volatile struct S0 g_348 = {-1L,-5L,0x2B8DL,18446744073709551615UL,0xFBAAL};/* VOLATILE GLOBAL g_348 */
static volatile struct S0 *g_347 = &g_348;
static int32_t *g_354 = &g_161.f7;
static uint32_t g_430 = 0x9CD658C9L;
static uint16_t *g_491 = &g_161.f1;
static uint16_t **g_490 = &g_491;
static volatile uint16_t ***** const g_503 = (void*)0;
static uint32_t g_506 = 0xA049B235L;
static int64_t g_548 = 0x1C195E6E49509F36LL;
static uint32_t *****g_579 = (void*)0;
static struct S1 **g_613 = &g_310;
static struct S1 ***g_612 = &g_613;
static int16_t g_619 = 0L;
static volatile int32_t g_630 = 0x3EB93BDEL;/* VOLATILE GLOBAL g_630 */
static uint16_t g_639 = 65533UL;
static uint32_t g_668 = 0x838BA98DL;
static int16_t g_678 = 0x4D85L;
static int32_t g_700 = 0L;
static struct S1 g_709 = {0L,0x6669L,0L,1L,0xCA3F6194L,8UL,{5L,1L,65535UL,18446744073709551606UL,0x4628L},0x19C0927DL,0x42935A71L};/* VOLATILE GLOBAL g_709 */
static struct S1 g_722 = {0x22386F98L,65531UL,1L,-1L,0xD7F635DCL,0xDA064A77L,{0L,0x51FCL,0xFC05L,18446744073709551609UL,-8L},3L,0x90B76FB6L};/* VOLATILE GLOBAL g_722 */
static struct S0 g_731 = {5L,0xD6C4L,0xFCDEL,0xFE012456L,-7L};/* VOLATILE GLOBAL g_731 */
static struct S0 g_733 = {0L,1L,0x5BF4L,18446744073709551613UL,0x511CL};/* VOLATILE GLOBAL g_733 */
static struct S0 *g_732 = &g_733;
static int32_t *****g_839 = &g_287;
static volatile struct S1 *g_864 = (void*)0;
static volatile struct S1 **g_863 = &g_864;
static volatile struct S1 ***g_862 = &g_863;
static volatile struct S1 ****g_861 = &g_862;
static volatile struct S1 *****g_860 = &g_861;
static int32_t * const **g_893 = (void*)0;
static uint32_t g_1011 = 1UL;
static uint32_t **g_1014 = &g_80;
static uint32_t ** const *g_1013 = &g_1014;
static uint16_t ***g_1020 = (void*)0;
static uint16_t ****g_1019 = &g_1020;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_30(void);
static uint16_t  func_36(uint32_t  p_37);
static uint32_t  func_38(uint16_t  p_39, int32_t  p_40);
static int16_t  func_44(int16_t  p_45, int32_t  p_46);
static int16_t  func_47(int32_t  p_48, uint16_t  p_49, uint32_t  p_50, uint32_t  p_51);
static int32_t  func_52(uint32_t  p_53, uint32_t  p_54, int32_t  p_55, int16_t  p_56, int16_t  p_57);
static uint32_t  func_58(uint32_t  p_59);
static uint16_t  func_61(uint32_t  p_62, int32_t  p_63, int32_t  p_64);
static uint32_t  func_65(uint32_t  p_66);
static uint32_t  func_67(int32_t  p_68, uint16_t  p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6
 * writes: g_6 g_1019
 */
static int32_t  func_30(void)
{ /* block id: 36 */
    int16_t l_35 = 0L;
    int32_t l_1012 = 0x48731303L;
    uint16_t ***l_1018 = (void*)0;
    uint16_t ****l_1017 = &l_1018;
    struct S0 **l_1021 = &g_732;
    for (g_6 = 0; (g_6 <= 23); g_6 += 7)
    { /* block id: 39 */
        uint16_t l_41 = 0x7626L;
        uint32_t ** const **l_1015 = &g_1013;
        int16_t l_1016 = 5L;
    }
    g_1019 = l_1017;
    /* statement id: 725 */
    assert (g_1019 == &l_1018);
    l_1017 = &l_1018;
    l_1012 |= ((void*)0 != l_1021);
    return l_35;
    /* statement id: 728 */
    //assert (g_1019 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_132 g_490 g_491 g_227 g_228 g_82 g_83 g_43 g_21 g_161.f1 g_119 g_6 g_95 g_506 g_161.f7 g_709.f3 g_860 g_861 g_862 g_863 g_864 g_722.f3 g_612 g_613 g_722.f5
 * writes: g_132 g_161.f1 g_709.f1 g_43 g_506 g_161.f7 g_95 g_722.f3 g_310 g_709.f7
 */
static uint16_t  func_36(uint32_t  p_37)
{ /* block id: 649 */
    uint16_t l_925 = 5UL;
    int32_t *l_926 = &g_132;
    uint32_t l_936 = 0x109E7783L;
    int32_t l_937 = 0x66C46A63L;
    int32_t l_942 = (-4L);
    (*l_926) ^= ((int16_t)l_925 + (int16_t)l_925);
    if (((int16_t)(*l_926) + (int16_t)(-1L)))
    { /* block id: 651 */
        uint32_t l_933 = 0xEF083F46L;
        l_942 |= ((uint16_t)((uint16_t)l_933 >> (uint16_t)(g_709.f1 = ((**g_490) = ((int16_t)(((*l_926) |= l_936) | p_37) << (int16_t)11)))) * (uint16_t)((l_937 = p_37) < ((uint32_t)(l_933 >= ((uint16_t)(p_37 || l_933) << (uint16_t)9)) % (uint32_t)__builtin_clz((***g_227)))));
    }
    else
    { /* block id: 657 */
        const int32_t *l_955 = &g_709.f3;
        const int32_t **l_954 = &l_955;
        const int32_t ***l_953 = &l_954;
        const int32_t ****l_952 = &l_953;
        const int32_t **** const *l_951 = &l_952;
        int32_t **** const l_957 = (void*)0;
        int32_t **** const *l_956 = &l_957;
        struct S1 ****l_973 = &g_612;
        for (g_43 = 9; (g_43 <= 42); g_43 += 1)
        { /* block id: 660 */
            int32_t *l_947 = &g_75;
            int32_t l_948 = 0xF7E6A187L;
            l_948 ^= ((uint16_t)((void*)0 != l_947) >> (uint16_t)10);
        }
        if (((int16_t)(-1L) + (int16_t)(l_951 == (l_956 = &g_284))))
        { /* block id: 664 */
            (**l_953) = (**l_953);
            (*l_926) = __builtin_bswap64((!(((*l_926) = (-8L)) >= p_37)));
        }
        else
        { /* block id: 668 */
            uint32_t **l_965 = &g_80;
            uint32_t ***l_964 = &l_965;
            uint32_t ****l_963 = &l_964;
            uint32_t *****l_966 = &l_963;
            uint32_t ****l_968 = (void*)0;
            uint32_t *****l_967 = &l_968;
            struct S1 *l_994 = &g_709;
            int32_t l_996 = (-9L);
            (*l_926) = (((uint16_t)0x1D45L * (uint16_t)((int16_t)(((*l_966) = l_963) != ((*l_967) = (void*)0)) >> (int16_t)6)) && ((*g_491) = (*l_926)));
            if ((!(**g_490)))
            { /* block id: 673 */
                int32_t *l_970 = &l_942;
                struct S1 *** const *l_974 = &g_612;
                struct S1 *** const **l_975 = &l_974;
                l_970 = (void*)0;
                /* statement id: 674 */
                assert (l_970 == 0);
                (*l_926) &= ((uint16_t)(l_973 == ((*l_975) = l_974)) * (uint16_t)(*g_119));
            }
            else
            { /* block id: 677 */
                int16_t l_995 = 0xC2D8L;
                int32_t *l_1002 = (void*)0;
                for (g_506 = 0; (g_506 != 25); g_506 += 1)
                { /* block id: 680 */
                    int32_t l_983 = 0xE80FC676L;
                    for (g_161.f7 = 0; (g_161.f7 != (-22)); g_161.f7 -= 1)
                    { /* block id: 683 */
                        uint32_t *l_982 = &g_709.f8;
                        int16_t *l_984 = &g_95;
                        int32_t l_987 = 1L;
                        l_987 &= (((((uint16_t)(**g_490) * (uint16_t)((-8L) || 9L)) ^ (((*l_984) &= (((l_982 = l_926) != (void*)0) ^ (l_983 > (*g_82)))) >= ((int16_t)(((****l_952) | l_983) ^ p_37) << (int16_t)11))) <= (**g_490)) >= l_983);
                        /* statement id: 686 */
                        assert (l_982 == &g_132);
                        if (p_37)
                            continue;
                    }
                    (****l_951) = (***l_952);
                }
                (*l_926) = 0x3978B64FL;
                if (((g_506 &= p_37) == (((*l_926) ^ 1UL) < (*g_491))))
                { /* block id: 693 */
                    int32_t l_989 = 0xE7799D52L;
                    if ((p_37 > (*l_926)))
                    { /* block id: 694 */
                        int16_t l_988 = (-1L);
                        l_989 ^= (l_988 |= 0xBDFE09B9L);
                        (*l_926) = (((8L != p_37) && (p_37 >= ((int16_t)p_37 * (int16_t)(p_37 >= ((*g_860) == (void*)0))))) & ((int16_t)(((****g_860) == l_994) < (*g_491)) >> (int16_t)4));
                    }
                    else
                    { /* block id: 698 */
                        return p_37;
                    }
                }
                else
                { /* block id: 701 */
                    (*l_926) = (*l_926);
                    l_996 = l_995;
                }
                for (g_722.f3 = 0; (g_722.f3 > (-11)); g_722.f3 -= 1)
                { /* block id: 707 */
                    struct S1 *l_999 = (void*)0;
                    int32_t **l_1003 = (void*)0;
                    int32_t **l_1004 = &g_354;
                    int32_t **l_1005 = (void*)0;
                    int32_t *l_1006 = (void*)0;
                    int16_t *l_1007 = &g_95;
                    int32_t *l_1010 = &g_709.f7;
                    (**g_612) = l_999;
                    /* statement id: 708 */
                    assert (g_310 == 0);
                    (*l_1010) = ((*l_926) = ((((((p_37 && 0L) ^ (**l_954)) | ((int16_t)((g_506 = (l_1002 != (l_1006 = &l_996))) || 0x26C4F837L) - (int16_t)0x3C8BL)) | ((*l_1007) = 0x3885L)) || (((uint32_t)(**g_228) + (uint32_t)1L) | g_722.f5)) > p_37));
                    /* statement id: 713 */
                    assert (l_1006 == &l_996);
                }
            }
        }
        /* facts after branching */
        assert (l_956 == &g_284);
    }
    return (*l_926);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_80 g_82 g_43 g_71 g_21 g_95 g_83 g_119 g_131 g_132 g_161.f3 g_161.f8 g_161.f7 g_93 g_161.f5 g_348.f0 g_430 g_285 g_286 g_130 g_354 g_227 g_228 g_284 g_619 g_161.f6.f1 g_678 g_75 g_491 g_700 g_548 g_709.f1 g_490 g_161.f1 g_613 g_722.f7 g_722.f5 g_639 g_161.f0 g_709.f8 g_709.f7 g_860 g_893 g_722.f3
 * writes: g_43 g_71 g_80 g_95 g_119 g_130 g_131 g_93 g_132 g_161.f3 g_161.f1 g_161.f8 g_196 g_161.f7 g_161.f5 g_430 g_678 g_75 g_700 g_709.f1 g_354 g_490 g_732 g_284 g_310 g_722.f7 g_722.f5 g_639 g_619 g_709.f8 g_839 g_731.f1 g_709.f7 g_893
 */
static uint32_t  func_38(uint16_t  p_39, int32_t  p_40)
{ /* block id: 40 */
    int32_t l_42 = 1L;
    int16_t l_60 = 0x6986L;
    uint16_t l_679 = 0xA1EAL;
    uint32_t l_703 = 18446744073709551613UL;
    int32_t ***l_892 = &g_286;
    uint32_t * const *l_904 = &g_80;
    uint32_t l_921 = 0x00AC51E5L;
    l_42 = (-7L);
    g_43 = __builtin_popcountl(l_42);
    if (l_42)
    { /* block id: 43 */
        int16_t *l_677 = &g_678;
        int32_t l_704 = 0x2401AC01L;
        l_704 = (func_44(((*l_677) = func_47(((func_52(func_58(l_60), g_619, g_161.f6.f1, ((*l_677) |= (p_40 & l_42)), l_679) == ((uint16_t)65530UL << (uint16_t)l_703)) ^ g_548), l_704, l_704, p_39)), p_39) <= 0x9EEEL);
        /* statement id: 623 */
        assert (g_119 == &g_6 || g_119 == &g_95);
        //assert (g_131 == dangling || g_131 == 0);
        assert (g_310 == &g_722 || g_310 == 0 || g_310 == &g_161);
        //assert (g_354 == dangling || g_354 == &g_161.f7);
        assert (g_732 == &g_731 || g_732 == &g_733);
    }
    else
    { /* block id: 624 */
        uint16_t l_901 = 0x2E97L;
        uint32_t l_922 = 18446744073709551615UL;
        (*g_131) = __builtin_popcountll(g_21);
        if (func_65((__builtin_parityll(p_40) ^ func_65(p_39))))
        { /* block id: 626 */
            int32_t *l_883 = &g_709.f7;
            (*g_354) &= (p_40 & (**g_490));
            (***g_284) = l_883;
            /* statement id: 628 */
            assert (g_131 == &g_709.f7);
        }
        else
        { /* block id: 629 */
            int32_t * const ***l_894 = (void*)0;
            int32_t * const ***l_895 = &g_893;
            uint32_t ***l_900 = (void*)0;
            uint32_t **** const l_899 = &l_900;
            uint32_t **** const *l_898 = &l_899;
            l_901 = ((((uint16_t)((uint32_t)((uint16_t)(((__builtin_ctzl(l_679) || p_40) & ((int32_t)(l_892 != ((*l_895) = g_893)) - (int32_t)0x9EC6AE3AL)) & func_52(g_722.f3, ((((uint16_t)(((0xF759D491L ^ ((void*)0 != l_898)) < 0x7237L) >= 65535UL) >> (uint16_t)1) && 1L) == (***g_227)), g_722.f7, p_40, p_39)) - (uint16_t)p_40) % (uint32_t)0xC594C3FCL) << (uint16_t)p_40) != p_39) || (*g_491));
            (*g_354) &= __builtin_ia32_crc32qi((((0xB851967BL >= l_901) < 0x0959A3D6L) || (((uint16_t)(**g_490) + (uint16_t)0x22AEL) <= ((0x2EB1L && 65534UL) || ((*g_491) & ((*g_119) = p_39))))), p_39);
            if (p_40)
            { /* block id: 634 */
                return g_71;
            }
            else
            { /* block id: 636 */
                uint32_t * const **l_905 = (void*)0;
                uint32_t * const **l_906 = &l_904;
                (*l_906) = l_904;
                return p_40;
            }
        }
        /* facts after branching */
        assert (g_131 == &g_709.f7);
        (*g_354) = (l_922 |= ((uint16_t)((*g_491) = (0xB24FC268L ^ (((uint16_t)((int16_t)((***l_892) = (l_901 == p_39)) << (int16_t)((uint16_t)(*g_491) >> (uint16_t)15)) >> (uint16_t)((*g_491) == (+l_901))) ^ p_40))) * (uint16_t)((~((((uint32_t)p_39 + (uint32_t)((int32_t)(((p_40 | 0x2F1382BFL) ^ p_39) == (-1L)) - (int32_t)l_921)) > p_40) >= l_901)) == p_39)));
        (*g_354) = ((**g_286) = p_40);
    }
    /* facts after branching */
    assert (g_119 == &g_6 || g_119 == &g_95);
    //assert (g_131 == &g_709.f7 || g_131 == dangling || g_131 == 0);
    assert (g_310 == &g_722 || g_310 == 0 || g_310 == &g_161);
    //assert (g_354 == dangling || g_354 == &g_161.f7);
    assert (g_732 == &g_731 || g_732 == &g_733);
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_709.f1 g_161.f3 g_490 g_491 g_161.f1 g_227 g_228 g_82 g_83 g_613 g_119 g_6 g_95 g_722.f7 g_285 g_286 g_284 g_131 g_722.f5 g_639 g_161.f0 g_161.f8 g_43 g_161.f7 g_93 g_619 g_709.f8 g_709.f7 g_161.f5 g_860
 * writes: g_490 g_709.f1 g_161.f3 g_95 g_43 g_732 g_284 g_310 g_161.f1 g_722.f7 g_131 g_722.f5 g_639 g_161.f8 g_130 g_196 g_93 g_161.f7 g_619 g_709.f8 g_839 g_731.f1 g_709.f7 g_161.f5
 */
static int16_t  func_44(int16_t  p_45, int32_t  p_46)
{ /* block id: 507 */
    uint16_t **l_713 = &g_491;
    uint16_t ***l_714 = &g_490;
    const struct S0 *l_718 = &g_161.f6;
    const int32_t *l_727 = (void*)0;
    struct S0 *l_730 = &g_731;
    struct S1 *l_750 = &g_161;
    int32_t l_753 = (-1L);
    const uint32_t **l_785 = (void*)0;
    const uint32_t ***l_784 = &l_785;
    const uint32_t **** const l_783 = &l_784;
    int32_t l_795 = 0xFFAEF2D4L;
    int32_t *****l_838 = &g_287;
    uint16_t **l_844 = (void*)0;
    (*l_714) = l_713;
    for (g_709.f1 = 23; (g_709.f1 <= 5); g_709.f1 -= 9)
    { /* block id: 511 */
        uint32_t l_717 = 1UL;
        const int32_t *l_726 = (void*)0;
        int32_t l_748 = (-1L);
        uint32_t **l_766 = &g_80;
        int16_t *l_794 = &g_731.f1;
        struct S1 *l_798 = &g_722;
        uint16_t ***l_814 = &g_490;
        const struct S1 *l_854 = (void*)0;
        struct S1 ***l_865 = &g_613;
        uint32_t l_867 = 0xE4BD8D1DL;
        const int32_t **l_882 = &l_726;
        const int32_t ***l_881 = &l_882;
        const int32_t ****l_880 = &l_881;
        const int32_t **** const *l_879 = &l_880;
        if (l_717)
        { /* block id: 512 */
            const struct S0 **l_719 = (void*)0;
            const struct S0 **l_720 = &l_718;
            struct S1 *l_721 = &g_722;
            int32_t *l_723 = &g_161.f3;
            (*l_720) = l_718;
            l_721 = (void*)0;
            /* statement id: 514 */
            assert (l_721 == 0);
            (*l_723) ^= p_46;
            if (l_717)
                break;
        }
        else
        { /* block id: 517 */
            int32_t *****l_751 = &g_287;
            int32_t *l_779 = (void*)0;
            int32_t *l_780 = &g_722.f7;
            int32_t ** const *l_792 = (void*)0;
            int32_t ** const **l_791 = &l_792;
            uint32_t *l_793 = &g_506;
            const uint16_t *l_819 = &g_21;
            const uint16_t **l_818 = &l_819;
            for (g_95 = 17; (g_95 > 17); g_95 += 1)
            { /* block id: 520 */
                int16_t l_739 = 0xC743L;
                int32_t *****l_752 = &g_284;
                p_46 |= (-1L);
                l_727 = l_726;
                if (p_45)
                { /* block id: 523 */
                    for (g_43 = 0; (g_43 >= 51); g_43 += 1)
                    { /* block id: 526 */
                        struct S0 **l_734 = &l_730;
                        int32_t l_742 = 6L;
                        uint16_t l_747 = 65535UL;
                        int32_t *****l_749 = &g_284;
                        (*l_734) = (g_732 = l_730);
                        /* statement id: 528 */
                        assert (g_732 == &g_731);
                        l_748 = ((int32_t)((uint16_t)(l_739 &= (**g_490)) - (uint16_t)(p_46 < ((int16_t)((0x0E8AL > l_742) >= ((uint32_t)(***g_227) - (uint32_t)((int16_t)0x762FL * (int16_t)6L))) << (int16_t)(**g_490)))) - (int32_t)l_747);
                        (*l_749) = &g_285;
                    }
                    (*g_613) = l_750;
                    /* statement id: 533 */
                    assert (g_310 == &g_161);
                    l_752 = l_751;
                    /* statement id: 534 */
                    assert (l_752 == &g_287);
                }
                else
                { /* block id: 535 */
                    uint32_t l_764 = 7UL;
                    uint32_t **l_765 = (void*)0;
                    uint32_t *l_769 = &l_717;
                    int32_t l_774 = 0x4D2F85AEL;
                    p_46 |= (((l_726 == l_727) && (l_753 &= (*g_82))) > ((int16_t)(-6L) * (int16_t)((((uint16_t)((*g_491) = ((uint32_t)((int16_t)((int16_t)(p_45 && ((l_764 && (l_765 != l_766)) == ((uint16_t)(*g_491) << (uint16_t)3))) >> (int16_t)(*g_119)) % (int16_t)(*g_119)) - (uint32_t)0x7D5356A8L)) << (uint16_t)l_764) != 0L) && 1L)));
                    l_748 ^= (((*g_491) ^ p_45) < (((*l_769) &= 0xB1D82DBEL) && (p_46 >= ((((int32_t)l_764 + (int32_t)((uint32_t)(***g_227) - (uint32_t)l_774)) < ((int16_t)((uint16_t)(**g_490) >> (uint16_t)(p_46 != (*g_119))) + (int16_t)0xCF60L)) ^ l_764))));
                }
                /* facts after branching */
                assert (l_752 == &g_284 || l_752 == &g_287);
                if (p_45)
                    continue;
            }
            if (((*l_780) &= 0xA1D3AFF6L))
            { /* block id: 545 */
                uint32_t *l_782 = &g_722.f8;
                l_748 ^= (~((*g_491) | ((void*)0 != l_782)));
            }
            else
            { /* block id: 547 */
                const uint32_t *****l_786 = (void*)0;
                const uint32_t ****l_788 = &l_784;
                const uint32_t *****l_787 = &l_788;
                (*l_780) = 1L;
                (*l_787) = l_783;
                (**g_285) = &p_46;
                /* statement id: 550 */
                assert (g_131 == &p_46);
                (****g_284) = p_46;
            }
            if ((((p_46 | p_45) <= p_46) ^ ((0UL != 0x524EAA50L) > p_45)))
            { /* block id: 558 */
                int32_t l_805 = 1L;
                uint16_t ***l_815 = &l_713;
                for (g_722.f5 = 6; (g_722.f5 != 31); g_722.f5 += 1)
                { /* block id: 561 */
                    if (p_46)
                        break;
                    (*g_613) = l_798;
                    /* statement id: 563 */
                    assert (g_310 == &g_722);
                    return p_45;
                    /* statement id: 564 */
                    //assert (g_131 == dangling || g_131 == 0);
                }
                for (g_639 = 6; (g_639 != 44); g_639 += 1)
                { /* block id: 568 */
                    const uint16_t *l_817 = &g_709.f1;
                    const uint16_t **l_816 = &l_817;
                    int32_t l_826 = 0xBEFA6CD6L;
                    if (func_65(g_161.f0))
                    { /* block id: 569 */
                        (*l_780) |= p_45;
                        if (p_46)
                            continue;
                    }
                    else
                    { /* block id: 572 */
                        uint32_t l_813 = 0UL;
                        l_748 &= (p_46 = ((int16_t)(((uint16_t)p_45 * (uint16_t)(*l_780)) & 0x0F9DL) * (int16_t)p_46));
                        l_795 &= ((int16_t)((uint32_t)l_813 % (uint32_t)__builtin_parityl((((((&l_713 != (l_815 = l_814)) < (((l_818 = l_816) == (void*)0) >= ((uint16_t)p_46 >> (uint16_t)((uint32_t)((uint16_t)0xFDE7L % (uint16_t)0x8E56L) % (uint32_t)p_46)))) < 0xE840L) || p_45) && p_46))) % (int16_t)0x0E0DL);
                        /* statement id: 578 */
                        assert (l_815 == &g_490);
                        assert (l_818 == &l_817);
                        if (l_826)
                            continue;
                        //assert (l_818 == dangling);
                        (*l_780) ^= 0xF97B7E1DL;
                    }
                    /* facts after branching */
                    assert (g_131 == 0);
                    //assert (l_818 == &l_817 || l_818 == dangling || l_818 == &l_819);
                }
                /* facts after for loop */
                assert (l_815 == &g_490 || l_815 == &l_713);
                //assert (l_818 == dangling || l_818 == &l_819);
            }
            else
            { /* block id: 583 */
                int32_t l_836 = 0x4C2B4BDAL;
                for (g_619 = 0; (g_619 < (-26)); g_619 -= 1)
                { /* block id: 586 */
                    uint16_t l_837 = 1UL;
                    for (g_709.f8 = 0; (g_709.f8 <= 27); g_709.f8 += 1)
                    { /* block id: 589 */
                        int16_t ** const l_831 = &g_119;
                        struct S1 ****l_833 = &g_612;
                        struct S1 *****l_832 = &l_833;
                        p_46 = ((*g_82) & (l_831 != (void*)0));
                        (*l_832) = &g_612;
                    }
                    l_837 = ((uint32_t)0xD3B9253CL % (uint32_t)l_836);
                    (**g_285) = &p_46;
                    /* statement id: 594 */
                    assert (g_131 == &p_46);
                }
                if (p_45)
                    continue;
            }
            /* facts after branching */
            //assert (l_818 == dangling || l_818 == &l_819);
        }
        g_839 = l_838;
        if ((!0x8BCFL))
        { /* block id: 600 */
            int16_t l_843 = 0xE79AL;
            l_843 &= ((int16_t)(-4L) * (int16_t)(*g_119));
            if (p_45)
                break;
            if (p_46)
                break;
            l_726 = &l_748;
            /* statement id: 604 */
            assert (l_726 == &l_748);
        }
        else
        { /* block id: 605 */
            uint32_t l_852 = 0xB2981FC4L;
            int16_t l_853 = (-9L);
            const struct S1 **l_855 = &l_854;
            uint16_t l_856 = 0xA108L;
            int32_t *l_857 = &g_709.f7;
            struct S0 **l_877 = (void*)0;
            struct S0 **l_878 = &g_732;
            (*l_857) |= ((((void*)0 == l_844) && (l_856 = (((int32_t)((int16_t)((uint16_t)(!((*l_794) = ((func_65(__builtin_parityl(g_161.f3)) != l_852) != p_45))) >> (uint16_t)7) >> (int16_t)4) - (int32_t)l_853) == (((*l_855) = l_854) != (void*)0)))) && 0xF4463366L);
            for (g_161.f5 = (-9); (g_161.f5 < 12); g_161.f5 += 5)
            { /* block id: 612 */
                struct S1 ****l_866 = &l_865;
                int32_t l_868 = 0xCF09A673L;
                (*l_857) |= (l_868 = (((void*)0 == g_860) && (l_868 | ((uint32_t)4294967294UL - (uint32_t)((uint16_t)((int16_t)((uint16_t)(*g_491) * (uint16_t)(*g_119)) >> (int16_t)3) >> (uint16_t)p_45)))));
            }
            (*l_878) = &g_733;
            /* statement id: 617 */
            assert (g_732 == &g_733);
        }
        /* facts after branching */
        assert (l_726 == 0 || l_726 == &l_748);
        l_753 = ((void*)0 == l_879);
    }
    /* facts after for loop */
    //assert (g_131 == &p_46 || g_131 == dangling || g_131 == 0);
    assert (g_310 == 0 || g_310 == &g_161);
    assert (g_732 == &g_731 || g_732 == &g_733);
    l_718 = &g_731;
    /* statement id: 621 */
    assert (l_718 == &g_731);
    return p_46;
    /* statement id: 622 */
    //assert (g_131 == dangling || g_131 == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_700 g_286
 * writes: g_700 g_709.f1 g_131 g_354
 */
static int16_t  func_47(int32_t  p_48, uint16_t  p_49, uint32_t  p_50, uint32_t  p_51)
{ /* block id: 492 */
    struct S1 *l_707 = &g_161;
    int32_t l_710 = 0L;
    for (g_700 = (-19); (g_700 < 22); g_700 += 7)
    { /* block id: 495 */
        struct S1 *l_708 = &g_709;
        l_708 = l_707;
        /* statement id: 496 */
        assert (l_708 == &g_161);
        l_710 &= p_51;
        for (g_709.f1 = 0; (g_709.f1 > 45); g_709.f1 += 6)
        { /* block id: 500 */
            g_354 = ((*g_286) = &p_48);
            /* statement id: 502 */
            assert (g_131 == &p_48);
            assert (g_354 == &p_48);
        }
    }
    /* facts after for loop */
    assert (g_131 == &p_48 || g_131 == 0);
    assert (g_354 == &p_48 || g_354 == &g_161.f7);
    return p_48;
    /* statement id: 505 */
    //assert (g_131 == dangling || g_131 == 0);
    //assert (g_354 == dangling || g_354 == &g_161.f7);
}


/* ------------------------------------------ */
/* 
 * reads : g_161.f3 g_75 g_354 g_348.f0 g_430 g_43 g_21 g_285 g_286 g_131 g_82 g_83 g_93 g_119 g_6 g_95 g_130 g_161.f8 g_161.f7 g_227 g_228 g_284 g_491 g_700
 * writes: g_161.f3 g_75 g_161.f7 g_161.f5 g_430 g_132 g_131 g_93 g_130 g_196 g_161.f8 g_161.f1 g_700
 */
static int32_t  func_52(uint32_t  p_53, uint32_t  p_54, int32_t  p_55, int16_t  p_56, int16_t  p_57)
{ /* block id: 478 */
    uint32_t l_685 = 18446744073709551609UL;
    int16_t **l_690 = (void*)0;
    int16_t ***l_689 = &l_690;
    const int32_t l_697 = 0L;
    int32_t *l_698 = (void*)0;
    int32_t *l_699 = &g_700;
    for (g_161.f3 = 25; (g_161.f3 >= (-23)); g_161.f3 -= 1)
    { /* block id: 481 */
        for (g_75 = (-23); (g_75 >= 6); g_75 += 1)
        { /* block id: 484 */
            uint32_t l_684 = 18446744073709551607UL;
            l_684 = p_55;
        }
    }
    (*l_699) ^= (((((((*g_491) = func_61(l_685, p_55, ((*g_354) = (0x0E664A99L != ((+((uint16_t)(l_689 == (void*)0) * (uint16_t)((int16_t)((uint16_t)0x5E9AL + (uint16_t)(p_54 >= l_685)) * (int16_t)((uint16_t)(((0x8B54L > p_55) & l_697) ^ l_685) * (uint16_t)8UL)))) < 0x1D19A62FL))))) != 0x6D08L) >= l_685) > 0L) & g_21) != 0L);
    return (*g_354);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_80 g_82 g_43 g_71 g_21 g_95 g_83 g_119 g_131 g_132 g_161.f3 g_161.f8 g_161.f7 g_93 g_161.f5 g_348.f0 g_430 g_285 g_286 g_130 g_354 g_227 g_228 g_284
 * writes: g_71 g_80 g_95 g_119 g_43 g_130 g_131 g_93 g_132 g_161.f3 g_161.f1 g_161.f8 g_196 g_161.f7 g_161.f5 g_430
 */
static uint32_t  func_58(uint32_t  p_59)
{ /* block id: 44 */
    int32_t *l_70 = &g_71;
    int32_t * const l_74 = &g_75;
    uint32_t *l_76 = (void*)0;
    int32_t l_77 = 4L;
    int32_t l_414 = (-1L);
    struct S0 *l_486 = (void*)0;
    struct S0 **l_485 = &l_486;
    volatile uint16_t ****l_505 = (void*)0;
    volatile uint16_t *****l_504 = &l_505;
    const struct S1 *l_538 = &g_161;
    const struct S1 **l_537 = &l_538;
    int16_t **l_598 = &g_119;
    int32_t l_661 = 0L;
    int32_t l_672 = 0xE5E615C4L;
    (*g_354) = (((0x1067L != func_61(func_65((func_67(((*l_70) = g_6), ((l_77 = (p_59 >= (l_74 != (void*)0))) >= ((void*)0 == l_74))) || ((int32_t)(((uint16_t)p_59 * (uint16_t)l_77) <= (*g_119)) + (int32_t)0x237EC01DL))), p_59, l_414)) | l_414) >= l_414);
    /* statement id: 358 */
    assert (g_119 == &g_6 || g_119 == &g_95);
    assert (g_131 == 0);
    for (g_161.f5 = 0; (g_161.f5 != 43); g_161.f5 += 1)
    { /* block id: 361 */
        struct S0 **l_487 = (void*)0;
        int32_t l_500 = 8L;
        uint16_t ***l_501 = (void*)0;
        uint32_t ***l_582 = (void*)0;
        uint32_t ****l_581 = &l_582;
        uint32_t *****l_580 = &l_581;
        uint16_t * const l_638 = &g_639;
        uint16_t * const *l_637 = &l_638;
        uint16_t * const **l_636 = &l_637;
    }
    l_77 = (l_414 ^= (*g_354));
    (**g_285) = (*g_286);
    return l_414;
}


/* ------------------------------------------ */
/* 
 * reads : g_161.f7 g_161.f5 g_348.f0 g_430 g_43 g_21 g_132 g_285 g_286 g_131 g_82 g_83 g_93 g_119 g_6 g_95 g_130 g_161.f8 g_354 g_161.f3 g_227 g_228 g_284
 * writes: g_161.f7 g_161.f5 g_430 g_132 g_131 g_93 g_130 g_196 g_161.f8 g_161.f3 g_161.f1
 */
static uint16_t  func_61(uint32_t  p_62, int32_t  p_63, int32_t  p_64)
{ /* block id: 315 */
    int32_t *l_415 = &g_161.f7;
    uint32_t ***l_440 = (void*)0;
    int32_t l_475 = 1L;
    l_415 = &p_63;
    /* statement id: 316 */
    assert (l_415 == &p_63);
    for (g_161.f7 = 0; (g_161.f7 == 16); g_161.f7 += 1)
    { /* block id: 319 */
        uint16_t l_438 = 4UL;
        int32_t l_439 = 0xB4CB6625L;
        uint32_t **l_442 = &g_80;
        uint32_t ***l_441 = &l_442;
        int32_t l_468 = (-9L);
        uint16_t l_473 = 65535UL;
        uint16_t *l_474 = &g_161.f1;
        int32_t *l_482 = &g_161.f3;
        for (g_161.f5 = (-2); (g_161.f5 == 52); g_161.f5 += 6)
        { /* block id: 322 */
            int32_t l_424 = 0x620D7AD1L;
            uint32_t *l_429 = &g_430;
            l_439 = ((int16_t)((uint32_t)l_424 % (uint32_t)((int16_t)1L << (int16_t)((int32_t)l_424 - (int32_t)__builtin_ctzl(((*l_429) &= g_348.f0))))) >> (int16_t)((g_43 || ((uint32_t)p_63 % (uint32_t)(~(((uint16_t)g_21 << (uint16_t)((int16_t)l_438 >> (int16_t)(*l_415))) | p_62)))) && 1L));
            l_439 &= ((l_441 = l_440) != (void*)0);
            /* statement id: 326 */
            assert (l_441 == 0);
        }
        /* facts after for loop */
        assert (l_441 == 0 || l_441 == &l_442);
        for (g_132 = 0; (g_132 >= (-24)); g_132 -= 8)
        { /* block id: 330 */
            int32_t * const l_445 = &l_439;
            int32_t l_446 = 0x7147C9C7L;
            volatile struct S0 *l_449 = (void*)0;
            uint32_t ***l_454 = &l_442;
            l_446 |= (p_64 = (((*l_415) = l_438) | (l_415 != l_445)));
            (*l_445) = ((uint32_t)0x143FD5F5L - (uint32_t)1UL);
            l_449 = &g_348;
            /* statement id: 335 */
            assert (l_449 == &g_348);
            for (l_438 = 25; (l_438 > 55); l_438 += 5)
            { /* block id: 338 */
                uint32_t l_464 = 0UL;
                int16_t *l_465 = &g_130;
                int16_t *l_466 = &g_196;
                uint32_t *l_467 = &g_161.f8;
                uint32_t l_469 = 0xA6749FE2L;
                (*g_286) = (**g_285);
                (*l_445) = (l_446 &= (((uint32_t)(g_93 &= (*g_82)) + (uint32_t)(&g_228 != l_454)) & ((-(uint32_t)(*l_415)) < (g_161.f3 ^= ((((p_62 = (((uint16_t)((uint16_t)(((uint32_t)(l_439 <= ((((p_62 >= (l_468 = ((int16_t)(((*l_467) &= (((*g_119) >= ((*l_415) == ((*l_466) = ((*l_465) &= l_464)))) != (-5L))) & l_438) << (int16_t)15))) & p_64) ^ (*g_354)) & 4294967287UL)) - (uint32_t)0xA678C517L) > p_62) << (uint16_t)4) * (uint16_t)(*l_445)) == l_464)) < p_63) || l_469) || 0xAE9CL)))));
                if ((*l_415))
                    continue;
            }
        }
        p_64 = (((-(uint16_t)p_64) <= (((uint16_t)l_473 % (uint16_t)((*l_474) = g_6)) & ((((*l_415) |= l_475) > (__builtin_bswap64((((*l_482) = ((***g_227) != (((uint32_t)((uint16_t)(((uint16_t)65534UL << (uint16_t)((***g_284) == (void*)0)) == 1L) + (uint16_t)65535UL) + (uint32_t)p_64) || l_468))) < l_475)) <= (*g_354))) < 0x68B3L))) && p_62);
    }
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads : g_161.f8 g_43 g_82 g_83 g_161.f7 g_93 g_161.f3
 * writes: g_161.f3 g_161.f1 g_161.f8 g_43 g_130 g_95 g_196 g_93 g_131 g_161.f7
 */
static uint32_t  func_65(uint32_t  p_66)
{ /* block id: 119 */
    struct S1 *l_173 = &g_161;
    struct S1 **l_174 = &l_173;
    int32_t **l_181 = &g_131;
    int32_t ***l_182 = &l_181;
    uint32_t l_185 = 0xAEA5EAF7L;
    int32_t *l_186 = &g_161.f3;
    uint16_t *l_187 = &g_161.f1;
    uint32_t *l_188 = &g_161.f8;
    uint16_t *l_189 = &g_43;
    int16_t *l_190 = &g_130;
    int16_t *l_191 = (void*)0;
    int16_t *l_192 = &g_95;
    int16_t *l_195 = &g_196;
    uint32_t *l_197 = &g_93;
    int32_t *l_222 = &g_161.f7;
    const uint32_t **l_258 = (void*)0;
    uint32_t l_291 = 0UL;
    uint32_t ***l_299 = (void*)0;
    int32_t *****l_340 = &g_284;
    uint32_t l_355 = 0xA3BECF33L;
    struct S0 ** const l_401 = (void*)0;
    const int32_t l_402 = 0xDB0BF49BL;
    (*l_174) = l_173;
    if (((int16_t)(((*l_192) = ((uint16_t)((*l_189) &= ((int32_t)(((*l_182) = l_181) != &g_131) % (int32_t)((*l_188) ^= ((int16_t)p_66 + (int16_t)((*l_187) = ((((*l_186) = l_185) && 0x0A49417EL) < p_66)))))) + (uint16_t)((*l_190) = p_66))) & (((int16_t)((*l_195) = p_66) - (int16_t)(((*l_197) = (*g_82)) || p_66)) != p_66)) >> (int16_t)4))
    { /* block id: 130 */
        int32_t *l_198 = (void*)0;
        (**l_182) = l_198;
        /* statement id: 131 */
        assert (g_131 == 0);
        (*l_186) = (((*l_189) |= ((int16_t)((*l_192) = p_66) >> (int16_t)11)) > ((int32_t)p_66 + (int32_t)(l_197 == (void*)0)));
    }
    else
    { /* block id: 135 */
        uint32_t l_207 = 0x0FBAA509L;
        int32_t *l_216 = &g_161.f7;
        int32_t *l_221 = &g_75;
        (*l_186) = ((uint32_t)((int16_t)p_66 - (int16_t)((l_207 == ((*l_197) ^= ((uint32_t)((((((uint32_t)p_66 % (uint32_t)((uint32_t)((uint32_t)(*g_82) % (uint32_t)p_66) - (uint32_t)g_161.f7)) >= 0xE6288759L) && 0x22F150D1L) == (-1L)) > 0x9C145D4FL) - (uint32_t)0xE0D53B31L))) ^ p_66)) + (uint32_t)(-6L));
        (*l_216) |= (-3L);
        (*l_181) = (void*)0;
        /* statement id: 141 */
        assert (g_131 == 0);
    }
    /* facts after branching */
    assert (g_131 == 0);
    (*l_222) = ((*l_186) = p_66);
    for (g_161.f3 = (-18); (g_161.f3 >= (-30)); g_161.f3 -= 1)
    { /* block id: 147 */
        uint16_t *l_229 = &g_161.f1;
        uint16_t **l_230 = &l_189;
        int32_t l_231 = 0xE8A5D0D5L;
        int32_t l_263 = 1L;
        int32_t *l_304 = &l_231;
        int16_t **l_334 = &l_191;
        int32_t * const l_358 = &l_231;
        uint16_t l_366 = 65534UL;
        uint16_t l_413 = 65528UL;
    }
    return (*g_82);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_80 g_82 g_43 g_71 g_21 g_95 g_83 g_119 g_131 g_132 g_161.f3
 * writes: g_80 g_95 g_119 g_43 g_130 g_131 g_93 g_132
 */
static uint32_t  func_67(int32_t  p_68, uint16_t  p_69)
{ /* block id: 47 */
    uint32_t **l_81 = &g_80;
    int32_t l_96 = (-1L);
    int16_t *l_116 = &g_6;
    int16_t *l_118 = &g_6;
    int32_t *l_122 = &l_96;
    uint16_t l_165 = 0x3B69L;
    int32_t l_168 = 0x1AA685BEL;
    if (((int16_t)(g_6 | (((*l_81) = g_80) == g_82)) >> (int16_t)p_69))
    { /* block id: 49 */
        uint32_t *l_92 = &g_93;
        int16_t *l_94 = &g_95;
        l_96 &= (((uint16_t)(p_68 & ((int16_t)0x4792L << (int16_t)8)) % (uint16_t)g_43) <= (0xDBFAL || ((g_71 & (g_6 > ((int16_t)3L % (int16_t)((*l_94) |= ((uint16_t)g_21 << (uint16_t)(l_92 == (void*)0)))))) > 0x0BF2L)));
    }
    else
    { /* block id: 52 */
        uint32_t l_113 = 0x212F019DL;
        int16_t **l_117 = &l_116;
        uint16_t *l_120 = &g_43;
        int32_t *l_121 = &l_96;
        int32_t **l_123 = (void*)0;
        int32_t **l_124 = (void*)0;
        int32_t **l_125 = &l_122;
        uint32_t **l_154 = &g_80;
        (*l_121) = ((uint32_t)__builtin_ffsll(((int16_t)(g_95 = ((uint16_t)((*l_120) ^= ((uint32_t)((uint32_t)((!g_83) == g_21) - (uint32_t)((-(int32_t)(((int16_t)(((uint16_t)l_113 % (uint16_t)l_113) < p_69) >> (int16_t)(0xA741179DL >= (((int16_t)(4294967295UL == __builtin_popcount((((*l_117) = l_116) != (g_119 = l_118)))) * (int16_t)g_6) & 65527UL))) > 4294967291UL)) ^ l_113)) % (uint32_t)p_69)) << (uint16_t)l_113)) * (int16_t)g_6)) - (uint32_t)l_96);
        /* statement id: 57 */
        assert (g_119 == &g_6);
        (*l_125) = l_122;
        (*l_125) = (void*)0;
        /* statement id: 59 */
        assert (l_122 == 0);
        if (((*l_121) = (-2L)))
        { /* block id: 61 */
            int32_t ***l_126 = &l_123;
            uint32_t **l_127 = &g_80;
            int16_t *l_128 = &g_95;
            int16_t *l_129 = &g_130;
            const uint32_t l_145 = 0x3596026DL;
            (*l_126) = (void*)0;
            (*l_121) = ((-2L) & (((l_127 != l_127) && ((*l_129) = ((*l_128) |= (*g_119)))) <= (g_93 = ((g_131 = &l_96) != ((*l_125) = &g_132)))));
            /* statement id: 68 */
            assert (l_122 == &g_132);
            assert (g_131 == &l_96);
            for (g_43 = 23; (g_43 <= 50); g_43 += 6)
            { /* block id: 71 */
                int32_t l_150 = 0L;
                uint32_t *l_152 = &g_93;
                uint32_t **l_153 = &l_152;
            }
        }
        else
        { /* block id: 103 */
            int32_t *l_162 = (void*)0;
            for (l_96 = 0; (l_96 > 10); l_96 += 8)
            { /* block id: 106 */
                int32_t l_158 = 4L;
                struct S1 *l_160 = &g_161;
                struct S1 **l_159 = &l_160;
                (*g_131) &= l_158;
                if ((*g_131))
                    break;
                (*l_159) = (void*)0;
                /* statement id: 109 */
                assert (l_160 == 0);
                if ((*g_131))
                    break;
            }
            (*l_125) = l_162;
        }
        /* facts after branching */
        assert (l_122 == 0 || l_122 == &g_132);
        assert (g_131 == &g_132 || g_131 == &l_96);
    }
    /* facts after branching */
    assert (g_119 == &g_6 || g_119 == &g_95);
    assert (l_122 == 0 || l_122 == &g_132 || l_122 == &l_96);
    assert (g_131 == &g_132 || g_131 == &l_96);
    l_168 ^= ((uint32_t)(g_93 = l_165) - (uint32_t)((*g_131) ^= ((uint16_t)g_161.f3 << (uint16_t)3)));
    return (*g_82);
    /* statement id: 118 */
    //assert (g_131 == &g_132 || g_131 == dangling);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_21, "g_21", print_hash_value);
    transparent_crc(g_43, "g_43", print_hash_value);
    transparent_crc(g_71, "g_71", print_hash_value);
    transparent_crc(g_75, "g_75", print_hash_value);
    transparent_crc(g_83, "g_83", print_hash_value);
    transparent_crc(g_93, "g_93", print_hash_value);
    transparent_crc(g_95, "g_95", print_hash_value);
    transparent_crc(g_130, "g_130", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_161.f0, "g_161.f0", print_hash_value);
    transparent_crc(g_161.f1, "g_161.f1", print_hash_value);
    transparent_crc(g_161.f2, "g_161.f2", print_hash_value);
    transparent_crc(g_161.f3, "g_161.f3", print_hash_value);
    transparent_crc(g_161.f4, "g_161.f4", print_hash_value);
    transparent_crc(g_161.f5, "g_161.f5", print_hash_value);
    transparent_crc(g_161.f6.f0, "g_161.f6.f0", print_hash_value);
    transparent_crc(g_161.f6.f1, "g_161.f6.f1", print_hash_value);
    transparent_crc(g_161.f6.f2, "g_161.f6.f2", print_hash_value);
    transparent_crc(g_161.f6.f3, "g_161.f6.f3", print_hash_value);
    transparent_crc(g_161.f6.f4, "g_161.f6.f4", print_hash_value);
    transparent_crc(g_161.f7, "g_161.f7", print_hash_value);
    transparent_crc(g_161.f8, "g_161.f8", print_hash_value);
    transparent_crc(g_196, "g_196", print_hash_value);
    transparent_crc(g_348.f0, "g_348.f0", print_hash_value);
    transparent_crc(g_348.f1, "g_348.f1", print_hash_value);
    transparent_crc(g_348.f2, "g_348.f2", print_hash_value);
    transparent_crc(g_348.f3, "g_348.f3", print_hash_value);
    transparent_crc(g_348.f4, "g_348.f4", print_hash_value);
    transparent_crc(g_430, "g_430", print_hash_value);
    transparent_crc(g_506, "g_506", print_hash_value);
    transparent_crc(g_548, "g_548", print_hash_value);
    transparent_crc(g_619, "g_619", print_hash_value);
    transparent_crc(g_630, "g_630", print_hash_value);
    transparent_crc(g_639, "g_639", print_hash_value);
    transparent_crc(g_668, "g_668", print_hash_value);
    transparent_crc(g_678, "g_678", print_hash_value);
    transparent_crc(g_700, "g_700", print_hash_value);
    transparent_crc(g_709.f0, "g_709.f0", print_hash_value);
    transparent_crc(g_709.f1, "g_709.f1", print_hash_value);
    transparent_crc(g_709.f2, "g_709.f2", print_hash_value);
    transparent_crc(g_709.f3, "g_709.f3", print_hash_value);
    transparent_crc(g_709.f4, "g_709.f4", print_hash_value);
    transparent_crc(g_709.f5, "g_709.f5", print_hash_value);
    transparent_crc(g_709.f6.f0, "g_709.f6.f0", print_hash_value);
    transparent_crc(g_709.f6.f1, "g_709.f6.f1", print_hash_value);
    transparent_crc(g_709.f6.f2, "g_709.f6.f2", print_hash_value);
    transparent_crc(g_709.f6.f3, "g_709.f6.f3", print_hash_value);
    transparent_crc(g_709.f6.f4, "g_709.f6.f4", print_hash_value);
    transparent_crc(g_709.f7, "g_709.f7", print_hash_value);
    transparent_crc(g_709.f8, "g_709.f8", print_hash_value);
    transparent_crc(g_722.f0, "g_722.f0", print_hash_value);
    transparent_crc(g_722.f1, "g_722.f1", print_hash_value);
    transparent_crc(g_722.f2, "g_722.f2", print_hash_value);
    transparent_crc(g_722.f3, "g_722.f3", print_hash_value);
    transparent_crc(g_722.f4, "g_722.f4", print_hash_value);
    transparent_crc(g_722.f5, "g_722.f5", print_hash_value);
    transparent_crc(g_722.f6.f0, "g_722.f6.f0", print_hash_value);
    transparent_crc(g_722.f6.f1, "g_722.f6.f1", print_hash_value);
    transparent_crc(g_722.f6.f2, "g_722.f6.f2", print_hash_value);
    transparent_crc(g_722.f6.f3, "g_722.f6.f3", print_hash_value);
    transparent_crc(g_722.f6.f4, "g_722.f6.f4", print_hash_value);
    transparent_crc(g_722.f7, "g_722.f7", print_hash_value);
    transparent_crc(g_722.f8, "g_722.f8", print_hash_value);
    transparent_crc(g_731.f0, "g_731.f0", print_hash_value);
    transparent_crc(g_731.f1, "g_731.f1", print_hash_value);
    transparent_crc(g_731.f2, "g_731.f2", print_hash_value);
    transparent_crc(g_731.f3, "g_731.f3", print_hash_value);
    transparent_crc(g_731.f4, "g_731.f4", print_hash_value);
    transparent_crc(g_733.f0, "g_733.f0", print_hash_value);
    transparent_crc(g_733.f1, "g_733.f1", print_hash_value);
    transparent_crc(g_733.f2, "g_733.f2", print_hash_value);
    transparent_crc(g_733.f3, "g_733.f3", print_hash_value);
    transparent_crc(g_733.f4, "g_733.f4", print_hash_value);
    transparent_crc(g_1011, "g_1011", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 255
XXX total union variables: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 183
   depth: 2, occurrence: 45
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 6
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 18, occurrence: 1
   depth: 20, occurrence: 4
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 271

XXX times a variable address is taken: 268
XXX times a pointer is dereferenced on RHS: 142
breakdown:
   depth: 1, occurrence: 97
   depth: 2, occurrence: 27
   depth: 3, occurrence: 16
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 239
breakdown:
   depth: 1, occurrence: 214
   depth: 2, occurrence: 18
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 1296

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1127
   level: 2, occurrence: 188
   level: 3, occurrence: 144
   level: 4, occurrence: 84
   level: 5, occurrence: 47
XXX number of pointers point to pointers: 165
XXX number of pointers point to scalars: 85
XXX number of pointers point to structs: 21
XXX percent of pointers has null in alias set: 25.8
XXX average alias set size: 1.17

XXX times a non-volatile is read: 941
XXX times a non-volatile is write: 681
XXX times a volatile is read: 36
XXX    times read thru a pointer: 24
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 629
XXX percentage of non-volatile access: 97.8

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 168
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 29
   depth: 2, occurrence: 37
   depth: 3, occurrence: 30
   depth: 4, occurrence: 19
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 21.7
XXX percentage an existing variable is used: 78.3
********************* end of statistics **********************/

