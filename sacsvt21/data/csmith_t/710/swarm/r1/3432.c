/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      2904611512
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint16_t g_3 = 4UL;
static int32_t g_26[9] = {(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)};
static int32_t g_45 = 1L;
static int32_t g_114 = 0x3EB33379L;
static int32_t *g_122[2] = {&g_114,&g_114};
static int32_t g_126 = 0L;
static int32_t *g_125 = &g_126;
static int32_t ** volatile g_130 = (void*)0;/* VOLATILE GLOBAL g_130 */
static int32_t ** volatile g_131 = (void*)0;/* VOLATILE GLOBAL g_131 */
static volatile int32_t g_142 = 0L;/* VOLATILE GLOBAL g_142 */
static volatile int32_t *g_141 = &g_142;
static volatile int32_t **g_140 = &g_141;
static float g_148 = 0x6.Dp+1;
static float * volatile g_196 = &g_148;/* VOLATILE GLOBAL g_196 */
static float *g_202 = &g_148;
static float **g_201 = &g_202;
static float *** volatile g_200 = &g_201;/* VOLATILE GLOBAL g_200 */
static int32_t ** volatile g_232 = &g_122[0];/* VOLATILE GLOBAL g_232 */
static int32_t ** volatile g_234 = &g_122[0];/* VOLATILE GLOBAL g_234 */
static int32_t **g_240[8] = {&g_122[1],&g_122[1],&g_122[1],&g_122[1],&g_122[1],&g_122[1],&g_122[1],&g_122[1]};
static int32_t ***g_239 = &g_240[5];
static int32_t ****g_238 = &g_239;
static float *** volatile g_242 = &g_201;/* VOLATILE GLOBAL g_242 */
static int32_t *g_247 = (void*)0;
static int32_t ***** volatile g_280 = &g_238;/* VOLATILE GLOBAL g_280 */
static volatile int16_t g_300 = (-7L);/* VOLATILE GLOBAL g_300 */
static int32_t ** volatile g_361 = &g_122[0];/* VOLATILE GLOBAL g_361 */
static int32_t *g_386 = (void*)0;
static uint32_t g_507 = 0UL;
static volatile float *g_578 = (void*)0;
static volatile float **g_577 = &g_578;
static volatile float ** volatile *g_576 = &g_577;
static volatile float ** volatile ** volatile g_575[8][2] = {{&g_576,&g_576},{&g_576,(void*)0},{&g_576,&g_576},{(void*)0,&g_576},{&g_576,&g_576},{(void*)0,&g_576},{&g_576,(void*)0},{&g_576,&g_576}};
static volatile float ** volatile ** volatile * volatile g_574 = &g_575[3][0];/* VOLATILE GLOBAL g_574 */
static int32_t ** volatile g_637 = &g_247;/* VOLATILE GLOBAL g_637 */
static volatile int32_t *g_642 = &g_142;
static int32_t ** volatile g_649 = (void*)0;/* VOLATILE GLOBAL g_649 */
static int32_t ** volatile g_650 = &g_122[0];/* VOLATILE GLOBAL g_650 */
static int32_t g_704 = (-1L);
static float ** volatile *g_717 = (void*)0;
static float ** volatile ** volatile g_716 = &g_717;/* VOLATILE GLOBAL g_716 */
static int32_t ** volatile g_747 = &g_122[0];/* VOLATILE GLOBAL g_747 */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_25(void);
inline static int32_t * func_27(int32_t  p_28, uint32_t  p_29);
static uint16_t  func_34(uint32_t  p_35);
static uint16_t  func_57(uint32_t  p_58, uint16_t  p_59, uint32_t  p_60, int32_t  p_61, uint16_t  p_62);
inline static uint32_t  func_63(int32_t * p_64, int32_t * p_65);
inline static int32_t * func_66(int16_t  p_67, int32_t * p_68);
inline static int16_t  func_69(uint16_t  p_70, uint32_t  p_71, uint32_t  p_72, int32_t * p_73);
inline static uint32_t  func_76(int32_t * p_77, int32_t  p_78, uint32_t  p_79);
inline static int32_t * func_85(int32_t * p_86, float  p_87, float  p_88, float  p_89);
static int32_t * func_90(int32_t * p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes: g_3
 */
inline static int32_t  func_25(void)
{ /* block id: 36 */
    int32_t *l_44[6][4][9] = {{{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45},{&g_45,(void*)0,&g_45,&g_45,&g_45,(void*)0,&g_45,&g_45,&g_45},{&g_45,&g_45,&g_45,(void*)0,(void*)0,&g_45,&g_45,&g_45,&g_45},{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45}},{{&g_45,&g_45,&g_45,(void*)0,(void*)0,&g_45,&g_45,&g_45,&g_45},{(void*)0,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45},{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,(void*)0},{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45}},{{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45},{&g_45,&g_45,&g_45,(void*)0,&g_45,&g_45,&g_45,&g_45,(void*)0},{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45},{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,(void*)0}},{{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,(void*)0,&g_45,&g_45},{(void*)0,&g_45,(void*)0,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45},{&g_45,&g_45,(void*)0,(void*)0,&g_45,(void*)0,&g_45,&g_45,(void*)0},{&g_45,&g_45,&g_45,&g_45,(void*)0,&g_45,&g_45,&g_45,&g_45}},{{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,(void*)0,&g_45,&g_45},{&g_45,&g_45,&g_45,&g_45,(void*)0,&g_45,&g_45,&g_45,&g_45},{&g_45,&g_45,&g_45,&g_45,&g_45,(void*)0,&g_45,&g_45,&g_45},{&g_45,&g_45,&g_45,(void*)0,(void*)0,&g_45,&g_45,&g_45,&g_45}},{{&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45},{&g_45,&g_45,&g_45,(void*)0,(void*)0,&g_45,&g_45,&g_45,&g_45},{(void*)0,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45,&g_45},{&g_45,(void*)0,&g_45,&g_45,&g_45,(void*)0,&g_45,&g_45,&g_45}}};
    int i, j, k;
    for (g_3 = 2; (g_3 <= 8); g_3 += 1)
    { /* block id: 39 */
        int i;
    }
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_637 g_247
 * writes:
 */
inline static int32_t * func_27(int32_t  p_28, uint32_t  p_29)
{ /* block id: 467 */
    int32_t *l_745 = &g_126;
    int32_t **l_746 = &l_745;
    (*l_746) = l_745;
    (*l_746) = (*l_746);
    return (*g_637);
    /* statement id: 470 */
    //assert (func_27_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_45 g_26 g_114 g_125 g_126 g_140 g_141 g_142 g_234 g_200 g_201 g_202 g_148 g_242 g_361 g_122 g_238 g_232 g_239 g_196 g_300 g_507
 * writes: g_45 g_114 g_122 g_126 g_148 g_141 g_142 g_386 g_239 g_507
 */
static uint16_t  func_34(uint32_t  p_35)
{ /* block id: 40 */
    int32_t *l_50[5] = {&g_45,&g_45,&g_45,&g_45,&g_45};
    int32_t l_510 = 0xB6EA5EBCL;
    int16_t l_521 = 0xDFC5L;
    int32_t ****l_523 = &g_239;
    int32_t *l_631[9];
    float ***l_633[2][9] = {{&g_201,&g_201,&g_201,&g_201,&g_201,&g_201,&g_201,&g_201,&g_201},{&g_201,&g_201,&g_201,&g_201,&g_201,&g_201,&g_201,&g_201,&g_201}};
    uint32_t l_726 = 0x1E92D158L;
    int32_t ***l_744[2][1];
    int i, j;
    for (i = 0; i < 9; i = i + 1)
        l_631[i] = (void*)0;
    for (i = 0; i < 2; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
            l_744[i][j] = (void*)0;
    }
    l_50[1] = &g_45;
    (*g_125) = (((uint16_t)((((uint16_t)p_35 / (uint16_t)((uint16_t)func_57(func_63(&g_45, func_66(func_69(g_3, (&g_45 != l_50[1]), ((uint32_t)func_76(((((0L == 0x7DDC4EA3L) , 0x199EL) , (((int16_t)p_35 + (int16_t)0xF242L) || 0L)) , l_50[2]), g_3, p_35) / (uint32_t)g_3), l_50[1]), g_125)), p_35, p_35, g_26[8], p_35) >> (uint16_t)g_507)) >= g_26[8]) > l_510) * (uint16_t)p_35) < g_507);
    /* statement id: 326 */
    //assert (g_122[0] == &g_126 || g_122[0] == &g_45 || g_122[0] == &g_114 || g_122[0] == 0);
    assert (g_141 == 0 || g_141 == &g_142);
    assert (g_386 == &g_45 || g_386 == &g_114 || g_386 == 0);
    for (g_507 = 0; (g_507 <= 7); g_507 += 1)
    { /* block id: 329 */
        float ***l_513 = &g_201;
        float ****l_512[4] = {&l_513,&l_513,&l_513,&l_513};
        float *****l_511 = &l_512[2];
        int32_t *l_527 = &g_114;
        int32_t *l_528 = &g_45;
        int32_t l_583 = (-5L);
        int32_t *****l_648 = &l_523;
        int32_t *l_664 = (void*)0;
        float *****l_688 = &l_512[2];
        int i;
        l_511 = l_511;
        (**g_201) = ((float)((-0x1.3p-1) == ((!((func_69(((0xD8A2L || ((int16_t)(p_35 && ((uint16_t)func_63(l_528, l_528) << (uint16_t)6)) * (int16_t)65535UL)) == p_35), (*l_528), p_35, l_50[1]) , p_35) < 0L)) , p_35)) * (float)g_507);
    }
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_3 g_114 g_200 g_201 g_202 g_148 g_196 g_126 g_125 g_300 g_232 g_122 g_234 g_238 g_239 g_26 g_140 g_141 g_142 g_361 g_507
 * writes: g_148 g_114 g_142 g_126 g_141
 */
static uint16_t  func_57(uint32_t  p_58, uint16_t  p_59, uint32_t  p_60, int32_t  p_61, uint16_t  p_62)
{ /* block id: 274 */
    int32_t l_441 = 0xA5A3F1FCL;
    int32_t ****l_442 = &g_239;
    float l_451 = 0x9.55D4B4p-82;
    uint32_t l_452 = 0UL;
    int32_t l_466 = 0L;
    uint16_t l_469 = 1UL;
    float *** volatile *l_509 = &g_200;
    float *** volatile **l_508 = &l_509;
    (*g_202) = (0x4.D021F3p-93 != ((float)((float)(l_441 >= (l_442 == (((((uint16_t)((uint32_t)((0xBA86L || ((__builtin_popcountl(g_45) , ((g_114 && p_60) < (((int32_t)p_59 - (int32_t)l_441) >= g_114))) <= p_62)) , p_59) % (uint32_t)0x99982131L) << (uint16_t)l_452) , 0L) & (-1L)) , (void*)0))) + (float)(***g_200)) + (float)p_59));
    if (((int16_t)p_62 * (int16_t)((uint32_t)p_61 + (uint32_t)((l_452 >= ((0x1.Cp+1 <= (*g_196)) == (**g_201))) , ((((((float)p_60 - (float)((float)((float)((*g_202) < (p_60 , (*g_202))) + (float)p_62) * (float)p_58)) != (-0x1.Bp+1)) <= (***g_200)) < p_61) , 0x97ACBCCFL)))))
    { /* block id: 276 */
        uint16_t l_463 = 0UL;
        (**g_201) = (l_463 , __builtin_popcountll(((uint16_t)(((**g_201) , l_466) , ((uint32_t)(l_469 && __builtin_clzll(p_62)) - (uint32_t)((((uint16_t)((-(int32_t)__builtin_clzl(l_463)) | 0UL) << (uint16_t)p_62) , p_60) == g_126))) >> (uint16_t)p_62)));
    }
    else
    { /* block id: 278 */
        int32_t l_477 = 0x8DF442A4L;
        if (((*g_125) < (g_114 <= ((p_61 , ((int16_t)g_300 % (int16_t)l_477)) != ((void*)0 == &g_202)))))
        { /* block id: 279 */
            for (l_469 = 0; (l_469 > 11); l_469 += 1)
            { /* block id: 282 */
                return p_60;
            }
            for (p_62 = 0; (p_62 != 15); p_62 += 1)
            { /* block id: 287 */
                int32_t *l_482[5] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                int i;
                l_482[0] = (*g_232);
                /* statement id: 288 */
                //assert (l_482[0] == &g_126 || l_482[0] == &g_45 || l_482[0] == &g_114 || l_482[0] == 0 || l_482[0] == &l_441);
                for (g_114 = 14; (g_114 <= 9); --g_114)
                { /* block id: 291 */
                    int16_t l_494 = (-1L);
                    for (l_441 = (-17); (l_441 > 7); l_441 += 1)
                    { /* block id: 294 */
                        int32_t *l_487 = &l_477;
                        l_487 = (*g_234);
                        /* statement id: 295 */
                        assert (l_487 == &g_126 || l_487 == &g_45 || l_487 == &g_114 || l_487 == 0);
                        l_477 = ((int16_t)((*g_238) == (__builtin_clzll(((((((uint32_t)0x7866A51FL - (uint32_t)p_62) , ((uint16_t)0x3163L << (uint16_t)11)) && func_76(l_482[2], g_3, l_494)) == (p_62 || p_59)) == g_26[6])) , (void*)0)) << (int16_t)2);
                        (**g_140) = 0x86F4E648L;
                    }
                }
                return g_45;
            }
        }
        else
        { /* block id: 302 */
            for (l_469 = 0; (l_469 < 58); l_469 += 1)
            { /* block id: 305 */
                uint32_t l_499 = 0xC2F0F649L;
                for (l_477 = 0; (l_477 != 15); ++l_477)
                { /* block id: 308 */
                    int32_t l_500 = 0x8602A066L;
                    int32_t *l_506 = &g_114;
                    for (p_58 = 0; (p_58 <= 1); p_58 += 1)
                    { /* block id: 311 */
                        int i;
                        if (l_477)
                            break;
                        return g_142;
                    }
                    l_506 = (*g_361);
                    /* statement id: 315 */
                    assert (l_506 == &g_126 || l_506 == &g_45 || l_506 == &g_114 || l_506 == 0);
                    return l_499;
                }
            }
            (*g_125) = g_507;
            return g_126;
        }
        (*g_140) = (void*)0;
        /* statement id: 322 */
        assert (g_141 == 0);
    }
    /* facts after branching */
    assert (g_141 == 0 || g_141 == &g_142);
    (*l_508) = &g_200;
    return g_300;
}


/* ------------------------------------------ */
/* 
 * reads : g_232 g_114 g_242 g_201 g_202
 * writes: g_122 g_114 g_148
 */
inline static uint32_t  func_63(int32_t * p_64, int32_t * p_65)
{ /* block id: 264 */
    int32_t *l_431[3][5] = {{&g_114,&g_114,&g_114,&g_114,&g_114},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&g_114,&g_114,&g_114,&g_114,&g_114}};
    int32_t l_432 = 1L;
    int32_t *l_435 = &g_114;
    int i, j;
    (*g_232) = p_64;
    /* statement id: 265 */
    //assert (g_122[0] == &g_126 || g_122[0] == &g_45 || g_122[0] == &g_114 || g_122[0] == 0 || g_122[0] == &l_544 || g_122[0] == dangling);
    p_64 = p_65;
    /* statement id: 266 */
    //assert (p_64 == &g_45 || p_64 == &g_114 || p_64 == 0 || p_64 == &g_126 || p_64 == &l_544);
    for (g_114 = 9; (g_114 < (-20)); --g_114)
    { /* block id: 269 */
        int32_t **l_436 = &l_435;
        (*l_436) = l_435;
    }
    (***g_242) = 0x0.Dp-1;
    return (*l_435);
}


/* ------------------------------------------ */
/* 
 * reads : g_126 g_114 g_45 g_140 g_141 g_142 g_26 g_3 g_125 g_234 g_200 g_201 g_202 g_148 g_242 g_361 g_122 g_238 g_232 g_239
 * writes: g_114 g_122 g_45 g_126 g_148 g_141 g_142 g_386 g_239
 */
inline static int32_t * func_66(int16_t  p_67, int32_t * p_68)
{ /* block id: 67 */
    int32_t *l_129[5][6][6] = {{{&g_114,&g_126,&g_45,&g_126,&g_114,&g_45},{&g_114,&g_45,&g_45,(void*)0,&g_45,&g_126},{&g_114,&g_126,(void*)0,&g_126,(void*)0,&g_126},{&g_45,&g_114,&g_45,&g_45,&g_114,&g_114},{&g_45,(void*)0,(void*)0,&g_45,&g_126,&g_126},{&g_126,&g_126,&g_45,&g_126,&g_126,(void*)0}},{{&g_45,(void*)0,&g_45,&g_45,&g_126,&g_45},{(void*)0,&g_126,&g_126,&g_126,&g_126,&g_126},{&g_114,(void*)0,&g_45,&g_45,&g_114,&g_126},{&g_45,&g_114,&g_45,&g_126,(void*)0,&g_126},{&g_114,&g_126,&g_114,&g_45,&g_45,&g_45},{&g_45,&g_45,(void*)0,&g_114,&g_114,(void*)0}},{{&g_126,&g_126,(void*)0,&g_114,&g_126,&g_45},{&g_45,&g_126,&g_45,&g_45,(void*)0,&g_45},{&g_114,&g_126,&g_114,&g_126,&g_126,&g_45},{&g_45,&g_45,(void*)0,&g_45,&g_45,(void*)0},{&g_114,&g_114,&g_45,&g_126,&g_45,(void*)0},{(void*)0,&g_126,&g_45,&g_45,&g_45,&g_45}},{{&g_45,(void*)0,&g_45,&g_126,&g_114,(void*)0},{&g_126,&g_126,&g_45,&g_45,&g_126,(void*)0},{&g_45,&g_126,(void*)0,&g_45,&g_126,&g_45},{&g_45,&g_45,&g_114,(void*)0,&g_114,(void*)0},{&g_114,(void*)0,&g_45,&g_126,&g_114,&g_45},{&g_45,&g_114,&g_126,(void*)0,&g_126,&g_45}},{{&g_126,&g_114,&g_126,(void*)0,&g_114,&g_126},{&g_45,(void*)0,&g_126,&g_114,&g_114,&g_45},{&g_45,(void*)0,&g_45,&g_45,(void*)0,&g_45},{&g_114,&g_126,&g_45,&g_45,&g_126,&g_114},{&g_126,&g_114,(void*)0,(void*)0,&g_45,(void*)0},{&g_114,&g_126,&g_45,&g_126,&g_114,(void*)0}}};
    uint32_t l_209 = 0x12C72D12L;
    int32_t ***l_312 = &g_240[7];
    float l_353 = 0x4.BF955Fp+26;
    float l_359 = 0x7.Cp+1;
    uint32_t l_376 = 0x790758B9L;
    int32_t *****l_385[9][2][3] = {{{&g_238,&g_238,&g_238},{(void*)0,&g_238,&g_238}},{{&g_238,&g_238,&g_238},{&g_238,(void*)0,&g_238}},{{(void*)0,&g_238,&g_238},{&g_238,&g_238,&g_238}},{{&g_238,(void*)0,&g_238},{&g_238,&g_238,&g_238}},{{(void*)0,&g_238,&g_238},{&g_238,&g_238,&g_238}},{{&g_238,(void*)0,&g_238},{(void*)0,&g_238,&g_238}},{{&g_238,&g_238,&g_238},{&g_238,(void*)0,&g_238}},{{&g_238,&g_238,&g_238},{(void*)0,&g_238,&g_238}},{{&g_238,&g_238,&g_238},{&g_238,(void*)0,&g_238}}};
    int i, j, k;
    if ((*p_68))
    { /* block id: 68 */
        uint32_t l_133 = 1UL;
        int32_t l_152 = 7L;
        volatile int32_t *l_174 = &g_142;
        float *l_199 = (void*)0;
        float **l_198 = &l_199;
        int32_t **l_237 = &g_122[0];
        int32_t ***l_236[8];
        int32_t ****l_235 = &l_236[1];
        uint32_t l_298 = 0xF8AAB923L;
        int i;
        for (i = 0; i < 8; i = i + 1)
            l_236[i] = &l_237;
        for (g_114 = (-14); (g_114 >= 24); g_114 += 8)
        { /* block id: 71 */
            int32_t **l_132 = &g_122[0];
            (*l_132) = l_129[0][0][4];
            if (l_133)
                continue;
            for (g_45 = 0; (g_45 < 6); ++g_45)
            { /* block id: 76 */
                float l_177 = (-0x1.Bp+1);
                if (((int32_t)(-6L) + (int32_t)((~((*p_68) && ((-(uint32_t)((void*)0 == &g_122[0])) && (((&g_122[1] == g_140) == (**g_140)) & (((uint32_t)__builtin_ffsll(g_26[1]) / (uint32_t)(*p_68)) , 0UL))))) ^ (-1L))))
                { /* block id: 77 */
                    for (g_126 = 0; (g_126 > (-27)); g_126--)
                    { /* block id: 80 */
                        float *l_147 = &g_148;
                        (*l_147) = 0x3.31B53Ep+79;
                    }
                    if ((!0xBF92L))
                    { /* block id: 83 */
                        (*l_132) = (void*)0;
                    }
                    else
                    { /* block id: 85 */
                        (*l_132) = p_68;
                        (*g_140) = (*g_140);
                    }
                    for (p_67 = (-28); (p_67 > 9); ++p_67)
                    { /* block id: 91 */
                        return p_68;
                        /* statement id: 92 */
                        //assert (func_66_rv == &g_126);
                    }
                }
                else
                { /* block id: 94 */
                    int32_t l_173[8];
                    int i;
                    for (i = 0; i < 8; i = i + 1)
                        l_173[i] = (-1L);
                    l_152 = (*p_68);
                    if ((((int16_t)(((uint16_t)((((-1L) > (*p_68)) , l_133) <= (((int16_t)p_67 % (int16_t)((int16_t)p_67 << (int16_t)(((uint16_t)l_152 >> (uint16_t)((uint16_t)((((void*)0 != &g_125) && ((uint32_t)4294967295UL + (uint32_t)p_67)) ^ 1L) * (uint16_t)p_67)) & g_114))) == p_67)) * (uint16_t)0xC67FL) || 6UL) * (int16_t)g_114) & g_114))
                    { /* block id: 96 */
                        (*g_141) = ((uint32_t)p_67 % (uint32_t)(~(g_114 == g_142)));
                        if (l_152)
                            continue;
                    }
                    else
                    { /* block id: 99 */
                        (*g_125) = (((&l_129[0][0][4] != &g_122[0]) , (((uint32_t)p_67 - (uint32_t)(__builtin_parity(g_114) > ((!((65535UL || (-1L)) ^ l_133)) , ((g_126 , l_173[4]) < 1UL)))) , (void*)0)) == (void*)0);
                        if ((*p_68))
                            continue;
                    }
                }
                l_174 = (*g_140);
                (*p_68) = ((p_67 && ((uint16_t)p_67 >> (uint16_t)__builtin_bswap64(g_126))) == (((int16_t)((int16_t)func_76(p_68, ((((*g_140) != p_68) , &l_132) != (g_26[3] , (void*)0)), p_67) - (int16_t)p_67) / (int16_t)0x322EL) <= 0x7F41L));
            }
        }
        /* facts after for loop */
        //assert (g_122[0] == &g_126 || g_122[0] == &g_45 || g_122[0] == &g_114 || g_122[0] == 0);
        (*p_68) = ((void*)0 != &l_174);
        for (p_67 = 14; (p_67 <= (-30)); p_67 -= 7)
        { /* block id: 111 */
            int16_t l_197[6][3];
            int32_t *l_231 = &l_152;
            float **l_241 = &l_199;
            int i, j;
            for (i = 0; i < 6; i = i + 1)
            {
                for (j = 0; j < 3; j = j + 1)
                    l_197[i][j] = 0x72FAL;
            }
            for (g_45 = 0; (g_45 >= (-13)); --g_45)
            { /* block id: 114 */
                int16_t l_186 = 0x52D8L;
                int32_t *l_233 = &l_152;
            }
        }
        (*l_237) = l_129[0][0][4];
    }
    else
    { /* block id: 184 */
        uint32_t l_306 = 0x77892577L;
        int32_t *l_325 = &g_114;
        int32_t *****l_380 = &g_238;
        for (g_114 = 0; (g_114 > (-30)); g_114 -= 2)
        { /* block id: 187 */
            int32_t *l_303 = &g_45;
            int32_t ***l_336 = &g_240[5];
            (*g_234) = l_303;
            for (p_67 = (-17); (p_67 >= (-6)); p_67 += 6)
            { /* block id: 191 */
                int32_t *l_311 = &g_45;
            }
        }
        /* facts after for loop */
        //assert (g_122[0] == &g_45 || g_122[0] == &g_114);
        p_68 = (void*)0;
        /* statement id: 227 */
        assert (p_68 == 0);
        p_68 = p_68;
        if (((int32_t)(*l_325) + (int32_t)((uint16_t)((uint16_t)(-(int16_t)(((((uint16_t)p_67 + (uint16_t)(__builtin_clzll((((float)(-0x9.3p+1) + (float)(0xF.D58738p-7 == (***g_200))) , g_45)) , (-(int16_t)(((int16_t)l_376 << (int16_t)(((int16_t)(-(uint32_t)(((((func_76(p_68, (*l_325), p_67) , 6L) , l_380) == (void*)0) || p_67) , 4294967287UL)) + (int16_t)0L) == p_67)) == 0xDA71A939L)))) <= g_45) , (**g_242)) == (*g_201))) << (uint16_t)3) << (uint16_t)9)))
        { /* block id: 229 */
            int32_t *****l_384 = &g_238;
            for (p_67 = 0; (p_67 < (-24)); p_67 -= 8)
            { /* block id: 232 */
                uint16_t l_391 = 0x4776L;
                if ((**g_361))
                    break;
                g_386 = ((((-(int16_t)g_26[1]) < (l_384 != l_385[6][0][1])) >= g_26[8]) , (*g_361));
                /* statement id: 234 */
                assert (g_386 == &g_45 || g_386 == &g_114);
                (*g_202) = ((float)(func_69(((int32_t)(**g_361) - (int32_t)l_391), ((uint16_t)g_114 / (uint16_t)g_126), p_67, l_325) == p_67) + (float)((float)(*g_202) + (float)(**g_201)));
                (*g_125) = 0L;
            }
            /* facts after for loop */
            assert (g_386 == &g_45 || g_386 == &g_114 || g_386 == 0);
            for (l_209 = (-25); (l_209 <= 29); l_209 += 9)
            { /* block id: 240 */
                uint32_t l_406 = 0x93B63C9BL;
                if (p_67)
                    break;
                if (p_67)
                    continue;
                (*l_325) = ((g_3 && (g_142 | (((((uint16_t)p_67 + (uint16_t)((void*)0 == (*l_384))) != (*l_325)) >= (0xC06BD83FL == (((int16_t)g_26[1] >> (int16_t)7) > (((((uint16_t)p_67 - (uint16_t)1L) , 0x23C1866EL) , (void*)0) != (void*)0)))) , l_406))) , p_67);
            }
            (*g_202) = (((float)(-(float)p_67) * (float)(p_67 >= (*g_202))) >= ((float)0x7.F1CC40p-61 * (float)(-0x2.4p-1)));
        }
        else
        { /* block id: 246 */
            int16_t l_414 = 0x1DC3L;
            uint32_t l_415 = 0xB167C544L;
            int32_t ***l_422[2];
            int i;
            for (i = 0; i < 2; i = i + 1)
                l_422[i] = &g_240[5];
            (*g_232) = func_85((*g_232), p_67, (*g_202), (((int16_t)(p_68 != (l_414 , p_68)) >> (int16_t)((void*)0 != (*g_238))) , __builtin_ffs(l_415)));
            if (((int32_t)((uint32_t)(__builtin_bswap64(l_415) >= (l_415 , (*l_325))) % (uint32_t)0xD3BD019DL) + (int32_t)(-(int32_t)__builtin_ctzl(g_45))))
            { /* block id: 248 */
                return p_68;
                /* statement id: 249 */
                //assert (func_66_rv == 0);
            }
            else
            { /* block id: 250 */
                int32_t *l_421 = &g_114;
                (*g_234) = l_421;
                (*g_238) = l_422[1];
                (*l_421) = ((((**g_234) ^ 4294967288UL) == ((func_76(l_421, p_67, g_26[1]) , p_68) != p_68)) <= ((uint16_t)(-(int16_t)(~((uint16_t)(((*g_125) <= g_45) || 0x27224D03L) >> (uint16_t)15))) * (uint16_t)p_67));
            }
            for (l_376 = 0; (l_376 > 53); l_376 += 1)
            { /* block id: 257 */
                return (*g_232);
                /* statement id: 258 */
                //assert (func_66_rv == &g_45 || func_66_rv == &g_114);
            }
            (**g_140) = (g_126 | g_114);
        }
        /* facts after branching */
        assert (g_386 == &g_45 || g_386 == &g_114 || g_386 == 0);
    }
    /* facts after branching */
    //assert (g_122[0] == &g_126 || g_122[0] == &g_45 || g_122[0] == &g_114 || g_122[0] == 0);
    assert (p_68 == 0 || p_68 == &g_126);
    assert (g_386 == &g_45 || g_386 == &g_114 || g_386 == 0);
    return p_68;
    /* statement id: 263 */
    //assert (func_66_rv == 0 || func_66_rv == &g_126);
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_3 g_26 g_114
 * writes: g_45 g_114 g_122
 */
inline static int16_t  func_69(uint16_t  p_70, uint32_t  p_71, uint32_t  p_72, int32_t * p_73)
{ /* block id: 49 */
    uint32_t l_115[10] = {0UL,0UL,0UL,0UL,0UL,0UL,0UL,0UL,0UL,0UL};
    int32_t **l_124 = &g_122[0];
    int32_t ***l_123 = &l_124;
    int i;
    g_122[0] = func_85(func_90(&g_45), p_71, g_26[2], l_115[3]);
    (*l_123) = (void*)0;
    /* statement id: 65 */
    assert (l_124 == 0);
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_45
 * writes:
 */
inline static uint32_t  func_76(int32_t * p_77, int32_t  p_78, uint32_t  p_79)
{ /* block id: 42 */
    uint16_t l_84 = 0x4D44L;
    for (p_78 = 0; (p_78 >= 12); p_78 += 4)
    { /* block id: 45 */
        return l_84;
    }
    return g_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_114
 * writes: g_45 g_114
 */
inline static int32_t * func_85(int32_t * p_86, float  p_87, float  p_88, float  p_89)
{ /* block id: 59 */
    uint32_t l_118 = 18446744073709551615UL;
    int32_t *l_119[3][1][1];
    int32_t *l_120 = &g_45;
    int32_t *l_121 = &g_114;
    int i, j, k;
    for (i = 0; i < 3; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
        {
            for (k = 0; k < 1; k = k + 1)
                l_119[i][j][k] = &g_45;
        }
    }
    (*l_120) = (((int16_t)l_118 - (int16_t)(p_86 == l_119[1][0][0])) | ((((g_3 < g_3) == g_114) , l_119[0][0][0]) == l_120));
    p_86 = p_86;
    (*p_86) = g_114;
    return l_121;
    /* statement id: 63 */
    //assert (func_85_rv == &g_114);
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_3
 * writes: g_45 g_114
 */
static int32_t * func_90(int32_t * p_91)
{ /* block id: 50 */
    float l_94 = 0x7.E3979Dp-98;
    int32_t l_98 = 0x92260F14L;
    int32_t l_112 = 0xDDE4E4C4L;
    for (g_45 = 8; (g_45 == 22); g_45 += 4)
    { /* block id: 53 */
        int32_t *l_99 = &g_45;
        int32_t *l_102[1];
        int16_t l_109 = 0xACDCL;
        int32_t l_113 = 1L;
        int i;
        for (i = 0; i < 1; i = i + 1)
            l_102[i] = (void*)0;
        l_98 = (g_3 <= ((g_3 ^ g_45) , func_76(p_91, ((uint16_t)(((!(l_98 <= ((p_91 != (((g_45 , l_99) == (((uint16_t)((*l_99) , (*l_99)) + (uint16_t)3UL) , p_91)) , p_91)) > g_3))) != l_98) > 0xE839L) / (uint16_t)l_98), (*l_99))));
        g_114 = ((((int16_t)(((uint16_t)((((g_45 || l_98) & (((((uint32_t)g_3 - (uint32_t)__builtin_ctz(l_109)) > 0xF6DEL) | l_98) , ((int16_t)l_98 - (int16_t)0UL))) < l_98) > l_98) % (uint16_t)g_45) > 0xC92AC9E0L) << (int16_t)l_112) < l_112) != l_113);
        return &g_114;
        /* statement id: 56 */
        //assert (func_90_rv == &g_114);
    }
    return p_91;
    /* statement id: 58 */
    //assert (func_90_rv == &g_45 || func_90_rv == &g_126 || func_90_rv == &g_114 || func_90_rv == 0 || func_90_rv == &l_477 || func_90_rv == &l_544);
}




/* ---------------------------------------- */
int main (void)
{
    int i, j;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_3, "g_3", print_hash_value);
    for (i = 0; i < 9; i = i + 1)
    {
        transparent_crc(g_26[i], "g_26[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_45, "g_45", print_hash_value);
    transparent_crc(g_114, "g_114", print_hash_value);
    transparent_crc(g_126, "g_126", print_hash_value);
    transparent_crc(g_142, "g_142", print_hash_value);
    transparent_crc_bytes (&g_148, sizeof(g_148), "g_148", print_hash_value);
    transparent_crc(g_300, "g_300", print_hash_value);
    transparent_crc(g_507, "g_507", print_hash_value);
    transparent_crc(g_704, "g_704", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 152
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 113
   depth: 2, occurrence: 25
   depth: 3, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 25, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 130

XXX times a variable address is taken: 282
XXX times a pointer is dereferenced on RHS: 163
breakdown:
   depth: 1, occurrence: 129
   depth: 2, occurrence: 23
   depth: 3, occurrence: 11
XXX times a pointer is dereferenced on LHS: 96
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 988

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 408
   level: 2, occurrence: 137
   level: 3, occurrence: 98
   level: 4, occurrence: 54
   level: 5, occurrence: 17
XXX number of pointers point to pointers: 67
XXX number of pointers point to scalars: 63
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 35.4
XXX average alias set size: 1.76

XXX times a non-volatile is read: 922
XXX times a non-volatile is write: 274
XXX times a volatile is read: 68
XXX    times read thru a pointer: 8
XXX times a volatile is write: 27
XXX    times written thru a pointer: 8
XXX times a volatile is available for access: 399
XXX percentage of non-volatile access: 92.6

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 110
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 18
   depth: 2, occurrence: 18
   depth: 3, occurrence: 20
   depth: 4, occurrence: 9
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 13.5
XXX percentage an existing variable is used: 86.5
********************* end of statistics **********************/

