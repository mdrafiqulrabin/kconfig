/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --math64 --no-inline-function --muls --safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      2155621668
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int16_t g_3 = 0x3046L;
static int32_t g_32 = 0x45C1D102L;
static int32_t g_75 = (-1L);
static float g_103 = (-0x7.1p+1);
static int32_t **g_142 = (void*)0;
static int32_t *g_160 = &g_75;
static int32_t g_178 = 0L;
static float *g_235 = (void*)0;
static float **g_234 = &g_235;
static const int32_t *g_240 = &g_32;
static const int32_t **g_239 = &g_240;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static int32_t * func_33(int32_t * p_34, int32_t  p_35, uint32_t  p_36, uint32_t  p_37);
static const uint32_t  func_38(uint8_t  p_39, int32_t * p_40, const int32_t ** p_41);
static uint8_t  func_42(int64_t  p_43, int32_t  p_44);
static int16_t  func_45(int32_t  p_46, uint8_t  p_47, int64_t  p_48, uint64_t  p_49);
static uint16_t  func_54(int16_t  p_55, int32_t * p_56, uint64_t  p_57, uint32_t  p_58, uint64_t  p_59);
static int32_t * func_63(int32_t ** p_64, int32_t  p_65);
static int32_t  func_69(int32_t ** const  p_70);
static int32_t ** const  func_71(float  p_72);
static int32_t  func_78(uint8_t  p_79, int32_t ** p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_32 g_3 g_75 g_160 g_178 g_234 g_239 g_235 g_240
 * writes: g_75 g_103 g_160 g_178 g_234 g_240
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    int32_t *l_31 = &g_32;
    int32_t **l_30 = &l_31;
    int32_t l_60 = (-3L);
    int32_t *l_248 = (void*)0;
    (*l_30) = (void*)0;
    /* statement id: 37 */
    assert (l_31 == 0);
    (*l_30) = func_33((*l_30), (func_38(func_42(g_32, ((func_45(g_32, g_32, (safe_add_func_int16_t_s_s(((((safe_lshift_func_int16_t_s_u((g_3 | func_54(l_60, &g_32, (safe_mul_func_int16_t_s_s(g_32, l_60)), g_32, g_3)), l_60)) && 0xF2632C09L) & 0xEDFB2153L) ^ g_3), g_3)), l_60) >= 8L) == g_32)), (*l_30), g_239) != g_32), g_32, g_32);
    /* statement id: 178 */
    assert (l_31 == &g_178);
    assert (g_240 == &g_178);
    (*g_239) = l_248;
    /* statement id: 179 */
    assert (g_240 == 0);
    (*g_239) = (*g_239);
    return g_75;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_234 g_235 g_178 g_75 g_160
 * writes: g_75
 */
static int32_t * func_33(int32_t * p_34, int32_t  p_35, uint32_t  p_36, uint32_t  p_37)
{ /* block id: 175 */
    float *** const l_246 = &g_234;
    int32_t *l_247 = &g_178;
    (*g_160) = ((safe_add_func_uint64_t_u_u((((safe_rshift_func_int16_t_s_s((-7L), 5)) < g_3) || 0x0104BDE1L), (1UL | ((l_246 != l_246) | (((void*)0 != (**l_246)) < __builtin_ia32_crc32qi(g_178, g_75)))))) >= 1UL);
    return l_247;
    /* statement id: 177 */
    //assert (func_33_rv == &g_178);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_240 g_178
 */
static const uint32_t  func_38(uint8_t  p_39, int32_t * p_40, const int32_t ** p_41)
{ /* block id: 171 */
    int32_t *l_241 = &g_178;
    (*p_41) = l_241;
    /* statement id: 172 */
    assert (g_240 == &g_178);
    (*l_241) = 0x84F3E036L;
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_32
 * writes:
 */
static uint8_t  func_42(int64_t  p_43, int32_t  p_44)
{ /* block id: 169 */
    return g_32;
}


/* ------------------------------------------ */
/* 
 * reads : g_160
 * writes: g_75
 */
static int16_t  func_45(int32_t  p_46, uint8_t  p_47, int64_t  p_48, uint64_t  p_49)
{ /* block id: 166 */
    int32_t l_238 = 0xEA11651AL;
    (*g_160) = 0x5F63DAB8L;
    return l_238;
}


/* ------------------------------------------ */
/* 
 * reads : g_32 g_75 g_3 g_160 g_178 g_234
 * writes: g_75 g_103 g_160 g_178 g_234
 */
static uint16_t  func_54(int16_t  p_55, int32_t * p_56, uint64_t  p_57, uint32_t  p_58, uint64_t  p_59)
{ /* block id: 38 */
    int32_t *l_67 = &g_32;
    int32_t **l_66 = &l_67;
    (*l_66) = func_63(l_66, g_32);
    /* statement id: 164 */
    assert (l_67 == &g_178);
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads : g_32 g_75 g_3 g_160 g_178 g_234
 * writes: g_75 g_103 g_160 g_178 g_234
 */
static int32_t * func_63(int32_t ** p_64, int32_t  p_65)
{ /* block id: 39 */
    int32_t *l_68 = &g_32;
    (*p_64) = (*p_64);
    (*p_64) = l_68;
    p_65 = func_69(func_71((*l_68)));
    return &g_178;
    /* statement id: 163 */
    //assert (func_63_rv == &g_178);
}


/* ------------------------------------------ */
/* 
 * reads : g_234
 * writes: g_234
 */
static int32_t  func_69(int32_t ** const  p_70)
{ /* block id: 159 */
    float ***l_236 = &g_234;
    int32_t l_237 = 0xC28B900DL;
    (*l_236) = g_234;
    return l_237;
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_3 g_32 g_160 g_178
 * writes: g_75 g_103 g_160 g_178
 */
static int32_t ** const  func_71(float  p_72)
{ /* block id: 42 */
    uint64_t l_73 = 0xF18B01197BA27438LL;
    int32_t *l_74 = &g_75;
    int32_t **l_233 = &g_160;
    (*l_74) = l_73;
    (*l_74) = ((*l_74) != (*l_74));
    if ((safe_add_func_int32_t_s_s(0x62E26A8AL, 0xD1F6657EL)))
    { /* block id: 45 */
        uint64_t l_89 = 18446744073709551606UL;
        int32_t *l_94 = &g_75;
        const float l_101 = 0x5.5p-1;
        int32_t l_139 = 8L;
        int32_t **l_164 = &g_160;
        if (func_78(((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((*l_74), ((safe_rshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_s((18446744073709551615UL == l_89), 14)), 4)) == (((safe_mod_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(l_89, ((l_94 != l_74) > ((void*)0 != &l_94)))), g_75)) > (*l_74)) == 0x32AFL)))), 0xDA61EB61L)) < 0x44CAD706L), &l_94))
        { /* block id: 49 */
            int32_t **l_95 = &l_94;
            int32_t ***l_96 = &l_95;
            float *l_102 = &g_103;
            (*l_96) = l_95;
            (*l_102) = (safe_add_func_float_f_f(p_72, (safe_sub_func_float_f_f(l_101, p_72))));
        }
        else
        { /* block id: 52 */
            int32_t *l_146 = &g_32;
            int32_t **l_163 = &g_160;
            for (l_89 = 0; (l_89 <= 30); l_89 = safe_add_func_uint16_t_u_u(l_89, 1))
            { /* block id: 55 */
                int32_t **l_132 = &l_74;
                float *l_145 = &g_103;
                for (g_75 = (-11); (g_75 >= (-3)); g_75 = safe_add_func_int64_t_s_s(g_75, 2))
                { /* block id: 58 */
                    float *l_108 = &g_103;
                    int32_t l_123 = 0xB86846FFL;
                    int32_t *l_136 = &l_123;
                    (*l_108) = 0x9.3FD1FAp+73;
                }
            }
            for (l_89 = (-22); (l_89 > 45); ++l_89)
            { /* block id: 84 */
                int32_t *l_159 = &g_75;
                float *l_162 = &g_103;
                for (l_73 = (-26); (l_73 == 59); l_73 = safe_add_func_int32_t_s_s(l_73, 1))
                { /* block id: 87 */
                    uint32_t l_153 = 0x52087D55L;
                    float *l_156 = &g_103;
                    (*l_94) = l_153;
                    for (g_75 = 0; (g_75 <= 7); g_75++)
                    { /* block id: 91 */
                        int32_t *l_157 = &l_139;
                        int32_t * const l_158 = &g_32;
                        (*l_156) = (l_156 == l_146);
                        (*l_157) = (l_157 == l_158);
                    }
                    g_160 = l_159;
                }
                if ((*l_94))
                    break;
                (*l_162) = ((func_78((~((*l_74) > g_32)), &g_160) > 0x4.6p-1) == p_72);
                (*l_94) = 0x1.5p-1;
            }
            (*l_163) = (void*)0;
            /* statement id: 101 */
            assert (g_160 == 0);
        }
        /* facts after branching */
        assert (g_160 == 0 || g_160 == &g_75);
        (*l_164) = &g_75;
        /* statement id: 103 */
        assert (g_160 == &g_75);
        (*l_164) = l_74;
    }
    else
    { /* block id: 105 */
        int32_t *l_167 = &g_32;
        uint64_t l_174 = 1UL;
        int16_t l_198 = 1L;
        const uint16_t l_231 = 0xAF1FL;
        if ((safe_lshift_func_uint16_t_u_s(((&g_75 != l_167) == ((safe_rshift_func_uint16_t_u_s((g_32 < (safe_sub_func_uint32_t_u_u((safe_mod_func_uint16_t_u_u(g_75, (*l_167))), g_32))), ((*l_74) ^ ((*l_167) == l_174)))) && 0x594DL)), (*l_167))))
        { /* block id: 106 */
            int32_t *l_177 = &g_178;
            for (g_75 = 0; (g_75 < (-14)); g_75 = safe_sub_func_int16_t_s_s(g_75, 1))
            { /* block id: 109 */
            }
            for (g_178 = (-30); (g_178 == 4); g_178 = safe_add_func_uint16_t_u_u(g_178, 1))
            { /* block id: 127 */
                float l_188 = 0xF.DE66CDp-42;
                int32_t l_197 = 0x722A3428L;
            }
            for (g_178 = 0; (g_178 == 28); g_178 = safe_add_func_uint64_t_u_u(g_178, 1))
            { /* block id: 150 */
                uint8_t l_212 = 0xFFL;
                (*g_160) = __builtin_ia32_crc32qi((safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((((safe_rshift_func_uint16_t_u_u(l_212, (safe_add_func_uint64_t_u_u(0xCE86B1698A3390C0LL, (safe_add_func_int16_t_s_s(__builtin_popcount((*l_167)), (safe_mod_func_uint16_t_u_u((!(*l_167)), (*l_74))))))))) >= ((l_212 & 0x4AC1L) > (safe_mul_func_int16_t_s_s(l_212, 0xD069L)))) > 7UL), 0)), 0x5BA6L)), g_75);
            }
        }
        else
        { /* block id: 153 */
            uint32_t l_224 = 4294967293UL;
            int32_t l_232 = (-1L);
            l_232 = (safe_mod_func_int16_t_s_s(l_224, (safe_mod_func_uint64_t_u_u((18446744073709551610UL ^ (0x550C22E8L || (((((*l_167) & (safe_lshift_func_int16_t_s_u(0L, (&l_167 != (void*)0)))) ^ (safe_rshift_func_uint16_t_u_u((__builtin_bswap64(g_32) == g_178), l_224))) <= l_231) == 0x0E50715622FD341ELL))), 8L))));
        }
    }
    (*l_233) = l_74;
    return &g_160;
    /* statement id: 158 */
    //assert (func_71_rv == &g_160);
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_3 g_160
 * writes: g_75
 */
static int32_t  func_78(uint8_t  p_79, int32_t ** p_80)
{ /* block id: 46 */
    (**p_80) = (**p_80);
    return g_3;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_32, "g_32", print_hash_value);
    transparent_crc(g_75, "g_75", print_hash_value);
    transparent_crc_bytes (&g_103, sizeof(g_103), "g_103", print_hash_value);
    transparent_crc(g_178, "g_178", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 54
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
   depth: 6, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 53

XXX times a variable address is taken: 56
XXX times a pointer is dereferenced on RHS: 34
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 3
XXX times a pointer is dereferenced on LHS: 43
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 124

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 91
   level: 2, occurrence: 22
XXX number of pointers point to pointers: 21
XXX number of pointers point to scalars: 32
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.6
XXX average alias set size: 1.3

XXX times a non-volatile is read: 222
XXX times a non-volatile is write: 108
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 53
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 4
   depth: 2, occurrence: 9
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
********************* end of statistics **********************/

