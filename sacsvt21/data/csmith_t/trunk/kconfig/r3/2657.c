/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1148095704
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   uint16_t  f1;
   int32_t  f2;
};

union U1 {
   unsigned f0 : 9;
   int16_t  f1;
   int32_t  f2;
   const float  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_32(void);
inline static float  func_34(const uint16_t  p_35, union U0  p_36, union U0  p_37, float  p_38);
static int16_t  func_41(union U1  p_42, float  p_43, union U0  p_44, uint32_t  p_45);
inline static uint32_t  func_59(int32_t  p_60, int16_t  p_61);
static const union U1 *** func_91(uint16_t  p_92, const union U1 * const  p_93, int32_t  p_94);
inline static int32_t  func_99(union U1 *** p_100, union U1 * const * const  p_101);
inline static union U1 ** func_105(int32_t * p_106);
inline static int32_t * func_120(union U0  p_121, int32_t  p_122, float  p_123, union U1  p_124);
inline static uint16_t  func_134(float  p_135, uint32_t  p_136, int32_t  p_137, uint32_t  p_138, union U1  p_139);
static float  func_140(union U1 * const * p_141, int32_t  p_142, float  p_143, const uint32_t  p_144, int32_t  p_145);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_32(void)
{ /* block id: 36 */
    uint32_t l_33 = 1U;
    union U1 l_46 = {0xBBE26B5C};
    union U0 l_55 = {2};
    union U0 l_523 = {0x3E56EBD7};
    union U0 * const * const l_532 = (void*)0;
    union U1 *l_549 = &l_46;
    union U1 * const *l_548 = &l_549;
    float ** const l_585 = (void*)0;
    int32_t *l_595 = &l_46.f2;
    union U1 **l_641 = &l_549;
    union U1 ***l_640 = &l_641;
    union U1 ****l_639 = &l_640;
    int32_t l_664 = 0xC49B44A5;
    l_46.f2 = ((l_33 >= (-0x1.Cp-1)) > (l_33 == (__builtin_bswap32(l_33) < func_34(((((uint16_t)((func_41(l_46, ((float)(+(0xC.EF8169p+49 > (((-(float)(l_46.f0 == ((float)((float)l_33 + (float)l_33) - (float)l_33))) > l_46.f0) < 0x4.57B17Bp-83))) + (float)l_33), l_55, l_55.f2) != 6U) > l_46.f0) >> (uint16_t)1) && l_55.f2) | 0x71B7), l_55, l_523, l_55.f0))));
    /* statement id: 335 */
        if (((void*)0 != l_532))
    { /* block id: 336 */
        float *l_533 = (void*)0;
        float l_535 = 0x4.9p+1;
        float *l_534 = &l_535;
        union U1 *****l_536 = (void*)0;
        int32_t l_537 = (-6);
        union U1 *l_545 = &l_46;
        union U1 **l_544 = &l_545;
        int32_t *l_568 = &l_46.f2;
        int32_t **l_567 = &l_568;
        int32_t ***l_566 = &l_567;
        int32_t ****l_565 = &l_566;
        union U0 *l_575 = &l_523;
        uint32_t l_619 = 0xDB7756A1;
        uint32_t l_630 = 0x9A96BA77;
        (*l_534) = (l_523.f1 == l_55.f0);
        (*l_534) = (l_536 != l_536);
        if ((l_46.f0 | l_537))
        { /* block id: 339 */
            union U1 *l_543 = &l_46;
            union U1 **l_542 = &l_543;
            uint32_t l_554 = 0x57937788;
            int32_t *l_555 = &l_46.f2;
            union U0 *l_556 = &l_55;
            union U0 **l_557 = &l_556;
            (*l_555) = (((uint16_t)__builtin_ctz(l_537) << (uint16_t)((int32_t)((l_542 != l_544) && ((int16_t)func_134(((-0x1.Dp-1) > ((l_548 == (void*)0) <= l_46.f2)), ((uint16_t)((uint16_t)(l_537 || l_554) << (uint16_t)12) << (uint16_t)l_537), l_55.f2, l_537, (*l_549)) >> (int16_t)8)) - (int32_t)l_554)) & l_537);
            (*l_557) = l_556;
        }
        else
        { /* block id: 342 */
            const int32_t ***l_564 = (void*)0;
            const int32_t ****l_563 = &l_564;
            union U0 **l_576 = &l_575;
            union U1 ***l_581 = &l_544;
            int32_t l_582 = 1;
            (*l_534) = (((float)(+((float)(l_563 == l_565) + (float)((****l_565) == ((float)((float)0x9.C0AB17p+21 - (float)((float)(l_523.f1 >= ((0x8.4DF094p-81 != l_55.f0) <= (__builtin_clzll((**l_567)) > 0xE.11B9BFp-94))) + (float)l_55.f1)) - (float)l_46.f0)))) - (float)(***l_566)) >= (-0x7.Bp+1));
            (*l_576) = l_575;
            (*l_568) = (((uint16_t)((int32_t)l_523.f2 % (int32_t)4294967289U) >> (uint16_t)2) & (((func_99(l_581, (*l_581)) ^ (l_582 < ((uint32_t)(((l_585 == &l_533) | ((void*)0 == &l_534)) ^ l_523.f1) - (uint32_t)0x7B913B07))) >= l_55.f2) > (**l_567)));
        }
        if ((-(uint16_t)((l_575 != (void*)0) == 0x93FC86E0)))
        { /* block id: 347 */
            int32_t l_598 = 0;
            union U0 **l_599 = &l_575;
            int32_t l_604 = (-1);
            (***l_566) = (((uint32_t)((void*)0 == (*l_566)) + (uint32_t)((int16_t)0 % (int16_t)((int16_t)(((uint16_t)((void*)0 == l_595) + (uint16_t)((((int16_t)(*l_568) % (int16_t)(*l_595)) & 0U) <= ((**l_567) <= 0xAEBA))) == l_598) << (int16_t)(*l_595)))) != 9);
            (*l_599) = (void*)0;
            /* statement id: 349 */
            assert (l_575 == 0);
            l_604 = (!(!((int16_t)(*l_568) % (int16_t)(*l_568))));
        }
        else
        { /* block id: 351 */
            int32_t ***l_620 = &l_567;
            union U1 *l_629 = &l_46;
            int32_t *l_632 = &l_46.f2;
            for (l_55.f1 = 0; (l_55.f1 == 22); l_55.f1 += 6)
            { /* block id: 354 */
                union U1 *l_607 = &l_46;
                uint16_t l_608 = 3U;
                int32_t l_609 = 0xC3D2FF1B;
                union U0 l_631 = {0x1F47291F};
                (***l_565) = (*l_567);
                if ((l_607 != (*l_544)))
                { /* block id: 356 */
                    l_609 = l_608;
                }
                else
                { /* block id: 358 */
                    int32_t l_612 = 0xC539D9E6;
                    (*l_534) = ((((((float)((l_612 <= l_612) != (((((float)(((0x6.602DE4p+78 < ((float)l_612 + (float)(((float)l_612 + (float)(0x4.3p-1 > (*l_595))) != l_619))) > ((l_620 != (void*)0) <= l_612)) < l_608) + (float)0xB.D6205Bp+43) == 0x3.6p-1) <= (-0x3.0p+1)) >= (***l_620))) + (float)(***l_620)) <= (****l_565)) < (*l_595)) <= (***l_620)) <= 0x1.Ap-1);
                    (**l_567) = ((***l_620) > (+(((int32_t)(((l_609 && ((uint32_t)((*l_595) && ((void*)0 == &l_575)) + (uint32_t)1U)) != ((-8) != (+((int16_t)((*l_548) == l_629) - (int16_t)(*l_595))))) || l_630) % (int32_t)l_612) > l_612)));
                }
                l_632 = func_120(l_631, l_609, l_608, (*l_629));
                /* statement id: 362 */
                assert (l_632 == 0);
            }
            /* facts after for loop */
                        assert (l_632 == 0 || l_632 == &l_46.f2);
        }
        /* facts after branching */
                assert (l_575 == &l_523 || l_575 == 0);
    }
    else
    { /* block id: 365 */
        int32_t l_633 = 0xEB05B6C1;
        int32_t l_634 = 0x579C3070;
        int32_t **l_635 = &l_595;
        l_634 = l_633;
        (*l_635) = l_595;
        (**l_635) = (-1);
    }
    /* facts after branching */
        if ((*l_595))
    { /* block id: 370 */
        union U1 **l_638 = &l_549;
        union U1 ** const *l_637 = &l_638;
        union U1 ** const **l_636 = &l_637;
        union U0 *l_643 = &l_55;
        union U0 l_648 = {-1};
        int16_t l_649 = (-4);
        float l_651 = 0x1.CA0AADp+48;
        float *l_650 = &l_651;
        int32_t **l_662 = &l_595;
        (*l_595) = (l_636 != l_639);
        if ((*l_595))
        { /* block id: 372 */
            uint16_t l_642 = 0x136F;
            int32_t l_644 = 0x067BEC60;
            l_644 = (l_642 < ((void*)0 != l_643));
        }
        else
        { /* block id: 374 */
            union U0 **l_645 = &l_643;
            int32_t l_657 = 0x4B1F418C;
            union U1 *****l_660 = &l_639;
            int32_t l_661 = 0xFBCA8D5A;
            (*l_645) = &l_55;
            for (l_33 = 3; (l_33 < 23); ++l_33)
            { /* block id: 378 */
                int32_t **l_652 = &l_595;
            }
            (**l_640) = (*l_638);
            (*l_595) = ((uint32_t)(((int16_t)l_648.f2 >> (int16_t)(l_657 & ((((0xCF57A329 & (((uint32_t)1U + (uint32_t)(l_649 && ((((void*)0 == l_660) | ((*l_595) <= (((*l_595) > l_657) | l_648.f0))) || (*l_595)))) || l_648.f1)) | l_657) <= l_661) && 0x543076A0))) || l_661) + (uint32_t)0xFDC18966);
        }
        (*l_662) = l_650;
        /* statement id: 384 */
        assert (l_595 == &l_651);
    }
    else
    { /* block id: 385 */
        int32_t l_663 = (-4);
        (*l_595) = l_663;
        (*l_595) = l_663;
    }
    /* facts after branching */
    //assert (l_595 == &l_46.f2 || l_595 == dangling);
    return l_664;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_34(const uint16_t  p_35, union U0  p_36, union U0  p_37, float  p_38)
{ /* block id: 331 */
    const int32_t l_525 = 0xF3E70D12;
    const int32_t *l_524 = &l_525;
    int32_t l_528 = 0;
    int32_t *l_527 = &l_528;
    int32_t **l_526 = &l_527;
    int32_t *l_529 = (void*)0;
    int32_t *l_530 = &l_528;
    float l_531 = 0x4.9p-1;
    (*l_526) = l_524;
    /* statement id: 332 */
    assert (l_527 == &l_525);
    (*l_530) = (p_36.f0 | p_37.f2);
    return l_531;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_41(union U1  p_42, float  p_43, union U0  p_44, uint32_t  p_45)
{ /* block id: 37 */
    uint32_t l_58 = 0U;
    int16_t l_75 = 0;
    union U1 *l_104 = (void*)0;
    union U1 **l_103 = &l_104;
    union U1 ***l_102 = &l_103;
    const union U1 l_417 = {0xAE048480};
    const union U1 *l_416 = &l_417;
    const union U1 **l_415 = &l_416;
    const union U1 ***l_414 = &l_415;
    int32_t l_435 = (-1);
    int32_t * const l_434 = &l_435;
    int32_t *l_484 = &l_435;
    int32_t **l_483 = &l_484;
    int32_t ***l_482 = &l_483;
    int32_t ****l_481 = &l_482;
    float l_522 = (-0x8.Bp+1);
    float *l_521 = &l_522;
    if ((((int16_t)l_58 >> (int16_t)(l_58 > (func_59(((uint16_t)((int32_t)(((((~((int16_t)((((int16_t)(65534U != p_42.f0) % (int16_t)((uint32_t)(((p_44.f2 > 0x2E882408) == p_42.f0) == l_58) + (uint32_t)((int16_t)0xED18 << (int16_t)0))) != p_44.f0) & l_58) >> (int16_t)5)) && 1) <= l_58) && l_75) | l_58) % (int32_t)0xEFCF3958) % (uint16_t)l_58), l_75) >= p_45))) | p_45))
    { /* block id: 42 */
        int32_t l_86 = 0x8CD8B12A;
        int32_t *l_85 = &l_86;
        int32_t ***l_446 = (void*)0;
        union U0 l_490 = {0x193C588D};
        union U1 l_494 = {4294967295U};
        (*l_85) = 9;
        for (p_42.f2 = 11; (p_42.f2 >= 0); --p_42.f2)
        { /* block id: 46 */
            float l_395 = 0xE.927A84p-97;
            union U1 l_397 = {0x082DA739};
            const union U1 * const l_396 = &l_397;
            int32_t *l_457 = (void*)0;
            uint32_t l_462 = 4294967295U;
            for (p_45 = 0; (p_45 >= 23); p_45++)
            { /* block id: 49 */
                int32_t *l_107 = &l_86;
                int32_t l_424 = 0xE038DF95;
            }
        }
        /* facts after for loop */
                for (p_42.f2 = 0; (p_42.f2 <= (-3)); p_42.f2 -= 1)
        { /* block id: 310 */
            (**l_482) = func_120(p_44, (p_42.f1 == (p_42.f1 || p_44.f0)), p_44.f1, p_42);
            /* statement id: 311 */
            assert (l_484 == 0);
            for (l_490.f0 = 5; (l_490.f0 < (-22)); l_490.f0 -= 2)
            { /* block id: 314 */
                int32_t *l_511 = &l_435;
                float *l_512 = (void*)0;
                float l_514 = 0x2.9AA064p-28;
                float *l_513 = &l_514;
                (**l_482) = l_511;
                /* statement id: 315 */
                assert (l_484 == &l_435);
                (*l_513) = 0x3.Cp+1;
            }
            /* facts after for loop */
            assert (l_484 == &l_435 || l_484 == 0);
        }
        /* facts after for loop */
        assert (l_484 == &l_435 || l_484 == 0);
    }
    else
    { /* block id: 319 */
        float *l_515 = (void*)0;
        union U1 ****l_519 = &l_102;
        p_43 = p_44.f2;
        for (p_42.f2 = 23; (p_42.f2 == 20); --p_42.f2)
        { /* block id: 323 */
            int32_t *l_518 = &l_435;
            union U1 *****l_520 = &l_519;
            (*l_483) = l_518;
            (*l_520) = l_519;
        }
        /* facts after for loop */
            }
    /* facts after branching */
        assert (l_484 == &l_435 || l_484 == 0);
    (*l_434) = (-1);
    (*l_521) = p_44.f1;
    return p_42.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_59(int32_t  p_60, int16_t  p_61)
{ /* block id: 38 */
    union U1 l_78 = {0x1147C038};
    union U1 *l_77 = &l_78;
    union U1 **l_76 = &l_77;
    int32_t l_81 = 0xB6EF3BB5;
    int32_t *l_84 = &l_78.f2;
    (*l_76) = (void*)0;
    /* statement id: 39 */
    assert (l_77 == 0);
    (*l_84) = ((int32_t)l_81 + (int32_t)((uint16_t)0U + (uint16_t)(__builtin_ffsll(l_81) || (&l_77 == (void*)0))));
    /* statement id: 40 */
        return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const union U1 *** func_91(uint16_t  p_92, const union U1 * const  p_93, int32_t  p_94)
{ /* block id: 195 */
    const union U1 **l_411 = (void*)0;
    const union U1 ***l_410 = &l_411;
    const union U1 ***l_412 = &l_411;
    const union U1 ***l_413 = (void*)0;
    for (p_94 = 0; (p_94 > (-8)); p_94 -= 9)
    { /* block id: 198 */
        uint16_t l_400 = 0U;
        union U0 l_405 = {0x920DFC0D};
        int32_t l_409 = 1;
        int32_t *l_408 = &l_409;
        int32_t **l_407 = &l_408;
        l_400 = p_94;
        for (l_400 = 0; (l_400 > 41); ++l_400)
        { /* block id: 202 */
            int32_t l_404 = 0xA5F26233;
            int32_t *l_403 = &l_404;
            (*l_403) = l_400;
        }
        (*l_407) = func_120(l_405, p_94, (+0x1.Ap-1), (*p_93));
        /* statement id: 205 */
        assert (l_408 == 0);
    }
    return l_413;
    /* statement id: 207 */
    //assert (func_91_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_99(union U1 *** p_100, union U1 * const * const  p_101)
{ /* block id: 52 */
    union U0 l_125 = {0xDC21833D};
    union U1 l_126 = {0U};
    int32_t *l_393 = &l_126.f2;
    int32_t l_394 = 1;
    l_393 = func_120(l_125, l_125.f0, l_125.f2, l_126);
    /* statement id: 193 */
    assert (l_393 == 0);
    return l_394;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1 ** func_105(int32_t * p_106)
{ /* block id: 50 */
    union U1 l_110 = {0xDFF402E8};
    union U1 *l_109 = &l_110;
    union U1 **l_108 = &l_109;
    union U1 **l_111 = &l_109;
    union U1 **l_112 = &l_109;
    union U1 **l_113 = &l_109;
    union U1 **l_114 = &l_109;
    union U1 **l_115 = &l_109;
    union U1 **l_116 = &l_109;
    union U1 **l_117 = &l_109;
    union U1 **l_118 = &l_109;
    union U1 **l_119 = (void*)0;
    return l_119;
    /* statement id: 51 */
    //assert (func_105_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_120(union U0  p_121, int32_t  p_122, float  p_123, union U1  p_124)
{ /* block id: 53 */
    union U1 l_133 = {0x2804CE6F};
    union U1 *l_132 = &l_133;
    union U1 **l_131 = &l_132;
    int32_t l_156 = 0x7054D2AC;
    uint32_t l_157 = 0x0BACEAEE;
    uint32_t l_158 = 0x63885E37;
    int16_t l_159 = 0xA0A7;
    int32_t l_177 = 0xAA6A4DFB;
    int32_t *l_176 = &l_177;
    int16_t l_237 = 0x2FA3;
    int32_t *l_250 = &l_177;
    int32_t *l_262 = &l_177;
    int32_t *l_265 = &l_177;
    int32_t *l_267 = &l_177;
    int32_t *l_268 = &l_177;
    int32_t *l_273 = &l_177;
    int32_t *l_274 = &l_177;
    int32_t *l_276 = &l_177;
    int32_t *l_278 = &l_177;
    int32_t *l_280 = &l_177;
    int32_t *l_281 = &l_177;
    int32_t *l_327 = &l_177;
    int32_t l_346 = 0x49D43D75;
    int32_t l_376 = 0xA255B75E;
    float l_390 = 0x1.5p+1;
    float *l_389 = &l_390;
    float **l_388 = &l_389;
    float ***l_387 = &l_388;
    union U1 l_391 = {4294967295U};
    int32_t *l_392 = (void*)0;
    if ((0 > ((int32_t)__builtin_bswap64(((l_131 == (void*)0) & (((func_134((((((func_140(&l_132, ((int32_t)p_121.f2 + (int32_t)__builtin_ia32_crc32qi(((int16_t)((uint16_t)(0x402E7910 & ((int16_t)(((uint16_t)(l_156 > 0x27D8) >> (uint16_t)l_133.f0) || p_121.f0) << (int16_t)l_156)) >> (uint16_t)l_157) << (int16_t)p_121.f0), p_121.f1)), l_158, p_124.f0, p_121.f0) <= 0xE.E2023Ap-89) != p_123) > p_121.f0) < l_159) == 0x6.EB808Ap-18), l_157, p_121.f0, l_157, p_124) && p_124.f0) > 0x14DF77CB) >= l_159))) - (int32_t)p_121.f1)))
    { /* block id: 61 */
        uint32_t l_168 = 0x5DB76206;
        int32_t *l_178 = &l_177;
        int32_t l_186 = 0x92BD2967;
        int32_t l_206 = 1;
        union U1 **l_242 = &l_132;
        int32_t *l_248 = &l_177;
        int32_t *l_266 = &l_186;
        int32_t *l_269 = &l_177;
        int32_t *l_270 = &l_186;
        int32_t *l_272 = &l_177;
        int32_t *l_282 = &l_186;
        union U1 * const *l_342 = &l_132;
        union U1 * const **l_341 = &l_342;
        union U1 * const ***l_340 = &l_341;
        if ((l_159 > ((uint16_t)l_168 + (uint16_t)0x5F2B)))
        { /* block id: 62 */
            int32_t l_171 = 0xBD83D76C;
            const union U1 *l_172 = (void*)0;
            int32_t *l_179 = &l_177;
            int32_t *l_181 = (void*)0;
            if (((int16_t)(l_171 || 0x111D5598) >> (int16_t)(((void*)0 != l_172) != (-(uint16_t)0xFECF))))
            { /* block id: 63 */
                int32_t *l_180 = &l_177;
                for (l_171 = 16; (l_171 == (-27)); l_171--)
                { /* block id: 66 */
                    return l_181;
                    /* statement id: 67 */
                    //assert (func_120_rv == 0);
                }
                return l_181;
                /* statement id: 69 */
                //assert (func_120_rv == 0);
            }
            else
            { /* block id: 70 */
                const uint16_t l_191 = 0x94EF;
                (*l_179) = ((0x2840ACBB & (((uint16_t)((uint16_t)l_186 - (uint16_t)p_121.f0) << (uint16_t)((uint32_t)((uint32_t)l_191 - (uint32_t)(*l_178)) % (uint32_t)(*l_178))) && (&l_132 != &l_172))) == ((int16_t)((*l_176) == 0x5BB4) % (int16_t)6U));
            }
            return l_181;
            /* statement id: 73 */
            //assert (func_120_rv == 0);
        }
        else
        { /* block id: 74 */
            uint32_t l_218 = 0x019322E6;
            union U1 ***l_222 = &l_131;
            union U1 *** const * const l_221 = &l_222;
            int32_t *l_247 = &l_186;
            int32_t *l_251 = (void*)0;
            for (p_121.f1 = 0; (p_121.f1 <= 24); p_121.f1 += 3)
            { /* block id: 77 */
                const int32_t l_217 = 0x55464F81;
                union U1 *** const *l_223 = &l_222;
                int32_t *l_243 = &l_177;
                int32_t *l_245 = &l_177;
                int32_t *l_249 = &l_177;
                int32_t **l_252 = &l_248;
                for (l_186 = 0; (l_186 <= 27); l_186 += 4)
                { /* block id: 80 */
                    if ((*l_178))
                        break;
                }
                if (func_134(((float)((float)(*l_178) + (float)p_122) - (float)((float)(*l_176) - (float)((((float)((l_206 != ((float)(((*l_178) > 0x8.8B9561p+75) <= ((float)p_122 - (float)((float)(__builtin_ffs(((uint16_t)(((uint16_t)p_121.f1 << (uint16_t)1) <= l_217) + (uint16_t)(*l_176))) == p_122) + (float)0x8.2A3AB4p-87))) + (float)(-0x1.Bp-1))) < 0x4.26CD91p+44) + (float)l_217) != 0xF.E66233p-35) >= l_218))), l_217, l_217, (*l_178), p_124))
                { /* block id: 83 */
                    int32_t l_236 = 0xC0E6D3FF;
                    for (l_218 = (-4); (l_218 <= 39); ++l_218)
                    { /* block id: 86 */
                        int32_t **l_224 = (void*)0;
                        int32_t **l_225 = &l_176;
                        l_223 = l_221;
                        (*l_225) = &p_122;
                        /* statement id: 88 */
                        assert (l_176 == &p_122);
                    }
                    if (((((+((uint16_t)0U >> (uint16_t)8)) >= p_124.f0) > ((func_134(l_217, p_124.f0, p_122, ((~((int32_t)(l_218 & ((((int16_t)((uint16_t)(*l_176) >> (uint16_t)(*l_176)) << (int16_t)8) & ((void*)0 == &l_176)) == p_121.f1)) - (int32_t)l_217)) > p_121.f1), p_124) | l_236) >= p_121.f1)) >= l_237))
                    { /* block id: 90 */
                        (*l_176) = p_124.f0;
                        (*l_176) = (0U && ((-(uint32_t)9U) || 0x78E13ECE));
                        if (p_124.f0)
                            break;
                        (*l_176) = (*l_176);
                    }
                    else
                    { /* block id: 95 */
                        float *l_239 = (void*)0;
                        float l_241 = (-0x1.Cp-1);
                        float *l_240 = &l_241;
                        (*l_176) = l_217;
                        (*l_240) = 0x9.5D40A5p-27;
                        (*l_240) = (p_123 >= p_122);
                    }
                }
                else
                { /* block id: 100 */
                    int32_t *l_244 = &l_177;
                    int32_t *l_246 = &l_186;
                    (*l_178) = (l_242 == (**l_221));
                    return l_251;
                    /* statement id: 102 */
                    //assert (func_120_rv == 0);
                }
                (*l_178) = ((*l_178) & ((1U < (-1)) || (l_223 != l_223)));
                (*l_252) = l_247;
                /* statement id: 105 */
                assert (l_248 == &l_186);
            }
            /* facts after for loop */
                        assert (l_176 == &p_122 || l_176 == &l_177);
            assert (l_248 == &l_186 || l_248 == &l_177);
        }
        /* facts after branching */
                assert (l_176 == &p_122 || l_176 == &l_177);
        assert (l_248 == &l_186 || l_248 == &l_177);
        if ((((*l_176) & (*l_178)) && (-(int32_t)((uint16_t)(*l_248) >> (uint16_t)11))))
        { /* block id: 108 */
            int32_t *l_259 = &l_177;
            int32_t *l_260 = &l_177;
            int32_t *l_263 = &l_177;
            int32_t *l_264 = &l_177;
            int32_t *l_275 = &l_186;
            int32_t *l_277 = &l_177;
            int32_t *l_279 = &l_186;
            int32_t *l_283 = (void*)0;
            for (l_206 = (-8); (l_206 != (-16)); l_206 -= 2)
            { /* block id: 111 */
                int32_t *l_258 = &l_177;
                int32_t *l_261 = &l_177;
                int32_t *l_271 = &l_177;
                return l_283;
                /* statement id: 112 */
                //assert (func_120_rv == 0);
            }
        }
        else
        { /* block id: 114 */
            uint32_t l_284 = 0x4B1641BD;
            union U1 l_286 = {0x82927361};
            (*l_250) = func_134(l_284, p_122, p_124.f0, ((0x4226 >= 0x962E) != (!p_121.f1)), l_286);
            (*l_269) = ((!((int32_t)((7 != 0x699C2ED7) && l_284) - (int32_t)l_284)) != func_59(p_122, (*l_272)));
        }
        for (l_156 = 0; (l_156 == (-6)); l_156 -= 8)
        { /* block id: 120 */
            int32_t *l_302 = &l_177;
            float *l_320 = (void*)0;
            float ** const l_319 = &l_320;
            int32_t **l_358 = &l_327;
            for (l_237 = 0; (l_237 >= (-15)); l_237 -= 8)
            { /* block id: 123 */
                uint32_t l_301 = 0xECD59115;
                int32_t *l_325 = &l_177;
                for (l_186 = (-19); (l_186 <= (-25)); l_186 -= 5)
                { /* block id: 126 */
                    int16_t l_296 = 5;
                    union U1 ***l_303 = &l_131;
                    int32_t **l_304 = &l_265;
                    p_123 = func_134(l_296, (*l_248), ((int16_t)__builtin_clzl(p_124.f0) >> (int16_t)5), (((0x9337 | ((int16_t)l_296 << (int16_t)__builtin_ffs((*l_270)))) & (p_121.f1 != l_301)) && p_121.f1), p_124);
                    (*l_303) = func_105(l_302);
                    /* statement id: 128 */
                    assert (l_131 == 0);
                    (*l_304) = l_302;
                    if (((0x2DDE > func_59((*l_178), ((int16_t)((uint16_t)(((int16_t)((0xAED3 > (p_124.f0 > (p_121.f1 & ((int16_t)p_122 << (int16_t)((int32_t)((uint16_t)(p_124.f0 | p_124.f0) - (uint16_t)p_122) + (int32_t)3))))) | (*l_302)) >> (int16_t)p_121.f1) == (*l_266)) + (uint16_t)p_124.f0) - (int16_t)p_122))) <= l_301))
                    { /* block id: 130 */
                        (*l_304) = l_302;
                        (*l_304) = (*l_304);
                    }
                    else
                    { /* block id: 133 */
                        float l_318 = 0x1.Ap-1;
                        float *l_317 = &l_318;
                        float **l_322 = &l_317;
                        float ***l_321 = &l_322;
                        if ((*l_269))
                            break;
                        (*l_317) = p_123;
                        if (p_121.f1)
                            continue;
                        (*l_321) = l_319;
                        /* statement id: 137 */
                        assert (l_322 == &l_320);
                    }
                }
                for (l_157 = (-11); (l_157 != 43); l_157 += 9)
                { /* block id: 142 */
                    int32_t *l_326 = &l_186;
                    if ((*l_302))
                    { /* block id: 143 */
                        int32_t *l_328 = (void*)0;
                        return l_328;
                        /* statement id: 144 */
                        //assert (func_120_rv == 0);
                    }
                    else
                    { /* block id: 145 */
                        int32_t **l_329 = &l_176;
                        (*l_273) = p_124.f0;
                        (*l_329) = (void*)0;
                        /* statement id: 147 */
                        assert (l_176 == 0);
                        return l_320;
                        /* statement id: 148 */
                        //assert (func_120_rv == 0);
                    }
                }
            }
            (*l_281) = p_122;
            if (func_134((*l_250), p_121.f1, (*l_302), p_121.f1, p_124))
            { /* block id: 153 */
                union U1 * const l_330 = &l_133;
                int32_t l_337 = 0;
                uint32_t l_345 = 0U;
                (*l_242) = l_330;
                if ((+((uint16_t)p_124.f0 - (uint16_t)(((*l_270) != 0x24D1BB4D) != (*l_270)))))
                { /* block id: 155 */
                    float l_336 = 0x2.6AF59Bp+42;
                    int32_t *l_347 = (void*)0;
                    (*l_302) = ((p_122 <= 0xF91F) > (((uint32_t)l_337 + (uint32_t)((p_124.f0 && ((uint32_t)(p_121.f1 & (((void*)0 != l_340) ^ (((uint16_t)l_345 - (uint16_t)(p_121.f1 > (*l_178))) <= p_122))) + (uint32_t)0U)) > 0x5D671C78)) >= l_346));
                    return l_347;
                    /* statement id: 157 */
                    //assert (func_120_rv == 0);
                }
                else
                { /* block id: 158 */
                    (*l_248) = p_121.f1;
                }
            }
            else
            { /* block id: 161 */
                int32_t **l_348 = &l_248;
                int32_t *l_357 = &l_177;
                (*l_348) = &p_122;
                /* statement id: 162 */
                assert (l_248 == &p_122);
                p_123 = (((__builtin_popcount(p_121.f1) != (*l_270)) > (p_121.f1 > (((float)(__builtin_parity((*l_272)) == ((float)(*l_270) + (float)0x1.Fp-1)) - (float)((float)((float)(**l_348) - (float)p_124.f0) - (float)0x7.D1EA1Bp-58)) != (*l_276)))) >= 0x6.9p-1);
                return l_320;
                /* statement id: 164 */
                //assert (func_120_rv == 0);
            }
            (*l_358) = &p_122;
            /* statement id: 166 */
            assert (l_327 == &p_122);
        }
        /* facts after for loop */
        assert (l_131 == 0 || l_131 == &l_132);
        assert (l_327 == &p_122 || l_327 == &l_177);
    }
    else
    { /* block id: 168 */
        int16_t l_363 = 0x881E;
        for (p_122 = 21; (p_122 >= 9); p_122 -= 9)
        { /* block id: 171 */
            int32_t *l_366 = (void*)0;
            int32_t **l_380 = &l_176;
            for (p_124.f1 = 0; (p_124.f1 != 26); p_124.f1++)
            { /* block id: 174 */
                union U1 l_377 = {0U};
                l_363 = p_121.f2;
                for (l_156 = 10; (l_156 < (-30)); l_156 -= 4)
                { /* block id: 178 */
                    uint32_t l_369 = 4294967295U;
                    union U1 *l_373 = (void*)0;
                    if (l_363)
                    { /* block id: 179 */
                        return l_366;
                        /* statement id: 180 */
                        //assert (func_120_rv == 0);
                    }
                    else
                    { /* block id: 181 */
                        int32_t l_375 = 0x980F06ED;
                        float l_379 = (-0x6.8p+1);
                        float *l_378 = &l_379;
                        (*l_378) = ((float)(l_369 >= l_369) - (float)__builtin_bswap32((((int16_t)p_121.f2 - (int16_t)(func_134(p_121.f2, l_369, (!(p_121.f2 || 4U)), l_376, l_377) ^ p_121.f1)) & 3U)));
                    }
                }
                return l_366;
                /* statement id: 185 */
                //assert (func_120_rv == 0);
            }
            /* facts after for loop */
                        (*l_380) = &p_122;
            /* statement id: 187 */
            assert (l_176 == &p_122);
        }
        /* facts after for loop */
                assert (l_176 == &p_122 || l_176 == &l_177);
    }
    /* facts after branching */
            assert (l_131 == 0 || l_131 == &l_132);
    assert (l_176 == &p_122 || l_176 == &l_177);
    assert (l_327 == &p_122 || l_327 == &l_177);
    (*l_267) = func_134((*l_327), p_122, p_122, ((((int16_t)((int16_t)0 >> (int16_t)9) >> (int16_t)1) > (((uint32_t)(__builtin_ctz((*l_268)) <= 0x49FBC8AC) - (uint32_t)__builtin_clzl(((void*)0 == l_387))) & p_121.f1)) > 0), l_391);
    (*l_327) = (*l_250);
    return l_392;
    /* statement id: 192 */
    //assert (func_120_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_134(float  p_135, uint32_t  p_136, int32_t  p_137, uint32_t  p_138, union U1  p_139)
{ /* block id: 56 */
    uint32_t l_160 = 0x954321B6;
    int32_t l_162 = (-1);
    int32_t *l_161 = &l_162;
    int32_t **l_165 = &l_161;
    (*l_161) = func_59(l_160, ((((0xD2F3 | func_59(p_136, ((void*)0 != l_161))) != ((*l_161) ^ (((int16_t)(*l_161) << (int16_t)p_138) == 0x552C))) && p_137) >= (*l_161)));
    (*l_165) = &l_162;
    (*l_165) = (void*)0;
    /* statement id: 59 */
    assert (l_161 == 0);
    return p_139.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_140(union U1 * const * p_141, int32_t  p_142, float  p_143, const uint32_t  p_144, int32_t  p_145)
{ /* block id: 54 */
    return p_142;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 204
XXX total union variables: 13

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 47
breakdown:
   indirect level: 0, occurrence: 6
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 17
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 8
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 13
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 19
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 29

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 160
   depth: 2, occurrence: 32
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 5
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 5
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 199

XXX times a variable address is taken: 198
XXX times a pointer is dereferenced on RHS: 98
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 7
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 94
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 280

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 688
   level: 2, occurrence: 33
   level: 3, occurrence: 14
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 87
XXX number of pointers point to scalars: 93
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.6
XXX average alias set size: 1.13

XXX times a non-volatile is read: 677
XXX times a non-volatile is write: 249
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 146
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 24
   depth: 2, occurrence: 32
   depth: 3, occurrence: 23
   depth: 4, occurrence: 18
   depth: 5, occurrence: 21

XXX percentage a fresh-made variable is used: 14
XXX percentage an existing variable is used: 86
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

