/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      4005251020
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 20;
   signed f1 : 25;
   signed f2 : 23;
};

union U1 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_29(void);
inline static int32_t  func_30(union U1  p_31, uint32_t  p_32, uint32_t  p_33, union U1  p_34, int32_t  p_35);
inline static union U1  func_37(int32_t  p_38, union U1  p_39);
inline static union U1  func_40(uint16_t  p_41, int32_t  p_42, uint32_t  p_43, union U1  p_44, int32_t  p_45);
inline static union U1  func_46(uint32_t  p_47, uint32_t  p_48);
inline static struct S0  func_49(struct S0  p_50, uint32_t  p_51, int32_t  p_52, int32_t  p_53, int32_t  p_54);
inline static struct S0  func_55(int16_t  p_56, uint32_t  p_57, int16_t  p_58, int32_t  p_59, uint32_t  p_60);
static uint16_t  func_63(union U1  p_64, struct S0  p_65, int16_t  p_66);
inline static union U1  func_67(int16_t  p_68, uint32_t  p_69, int16_t  p_70);
inline static uint32_t  func_78(uint32_t  p_79, union U1  p_80, struct S0  p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_29(void)
{ /* block id: 36 */
    int32_t l_36 = 0x7E3B6F9B;
    int32_t l_71 = 1;
    struct S0 l_401 = {-368,-2177,-250};
    uint16_t l_425 = 6U;
    union U1 l_426 = {0};
    union U1 l_460 = {0x76134B4C};
    int32_t l_462 = 0xECD7F034;
    l_462 &= func_30((l_36 , func_37(l_36, func_40((func_46(((func_49(func_55(l_36, ((uint16_t)l_36 * (uint16_t)func_63(func_67((l_71 = l_36), l_36, l_36), l_401, l_401.f1)), l_401.f0, l_36, l_401.f0), l_401.f0, l_401.f1, l_401.f1, l_401.f0) , 0x9C755FA3) ^ l_36), l_401.f2) , l_401.f2), l_425, l_401.f0, l_426, l_36))), l_426.f0, l_425, l_460, l_426.f0);
    return l_401.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_30(union U1  p_31, uint32_t  p_32, uint32_t  p_33, union U1  p_34, int32_t  p_35)
{ /* block id: 264 */
    uint16_t l_461 = 0xA0CB;
    l_461 = 0x4CC2BFB4;
    return l_461;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_37(int32_t  p_38, union U1  p_39)
{ /* block id: 258 */
    uint32_t l_445 = 4294967295U;
    int32_t l_446 = 6;
    int32_t l_457 = 1;
    struct S0 l_458 = {-444,793,1854};
    union U1 l_459 = {0x32574745};
    l_446 ^= (l_445 > 0);
    l_458 = func_55((((uint32_t)(l_445 | (l_446 = (p_38 > __builtin_popcount(p_39.f0)))) - (uint32_t)(((int16_t)p_38 >> (int16_t)15) , p_38)) & l_445), (l_457 = ((int32_t)p_38 - (int32_t)(((int16_t)((int16_t)p_39.f0 * (int16_t)p_38) << (int16_t)15) ^ 0U))), l_445, p_38, p_39.f0);
    return l_459;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_40(uint16_t  p_41, int32_t  p_42, uint32_t  p_43, union U1  p_44, int32_t  p_45)
{ /* block id: 244 */
    int32_t l_441 = 6;
    struct S0 l_443 = {-788,4302,-1923};
    union U1 l_444 = {0};
    for (p_43 = 0; (p_43 > 16); p_43 += 1)
    { /* block id: 247 */
        union U1 l_431 = {0x77335672};
        int32_t l_439 = 0x26FF939F;
        int32_t l_440 = 9;
        for (p_45 = 0; (p_45 >= 26); p_45 += 6)
        { /* block id: 250 */
            uint32_t l_434 = 0x0FE2D9C7;
            struct S0 l_442 = {764,1897,-1909};
            l_440 = (l_431 , ((uint16_t)l_434 << (uint16_t)((uint32_t)p_43 + (uint32_t)(l_439 = (l_431.f0 < ((int16_t)p_45 * (int16_t)0x6277))))));
            if (l_441)
                continue;
            l_443 = l_442;
        }
    }
    return l_444;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_46(uint32_t  p_47, uint32_t  p_48)
{ /* block id: 239 */
    struct S0 l_422 = {-24,3424,427};
    uint16_t l_423 = 0xAD74;
    union U1 l_424 = {0xCFD5DAD6};
    l_422 = l_422;
    l_422.f1 &= (l_423 = 0x1BC9D2EC);
    return l_424;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_49(struct S0  p_50, uint32_t  p_51, int32_t  p_52, int32_t  p_53, int32_t  p_54)
{ /* block id: 225 */
    uint32_t l_406 = 4294967295U;
    int32_t l_407 = 0xC9193143;
    union U1 l_418 = {-1};
    int32_t l_420 = 0x00247E36;
    struct S0 l_421 = {800,-4050,-408};
    l_407 = (1U & (l_406 >= l_406));
    for (p_51 = (-6); (p_51 <= 32); p_51 += 9)
    { /* block id: 229 */
        union U1 l_414 = {0xB6625C39};
        int32_t l_419 = 0x785AC9E4;
        for (p_54 = (-10); (p_54 != 1); p_54 += 1)
        { /* block id: 232 */
            uint16_t l_417 = 0xC7A7;
            l_420 = (((uint16_t)p_50.f0 << (uint16_t)p_50.f0) > (p_54 | (l_419 = (8 <= (__builtin_ffsll(p_51) < (l_414 , (func_78(((uint16_t)l_407 - (uint16_t)(((l_417 > p_54) , l_414.f0) <= p_52)), l_418, p_50) || p_50.f2)))))));
            if (l_417)
                break;
        }
    }
    return l_421;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_55(int16_t  p_56, uint32_t  p_57, int16_t  p_58, int32_t  p_59, uint32_t  p_60)
{ /* block id: 222 */
    struct S0 l_405 = {560,-486,-2112};
    l_405 = l_405;
    return l_405;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_63(union U1  p_64, struct S0  p_65, int16_t  p_66)
{ /* block id: 219 */
    int16_t l_404 = (-1);
    p_65.f2 = (((int32_t)l_404 + (int32_t)l_404) , l_404);
    return l_404;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_67(int16_t  p_68, uint32_t  p_69, int16_t  p_70)
{ /* block id: 38 */
    struct S0 l_72 = {494,-548,1302};
    uint32_t l_95 = 0x90942075;
    union U1 l_96 = {6};
    struct S0 l_97 = {-229,4953,421};
    l_72 = l_72;
    l_97.f1 = (-(uint16_t)((l_72.f2 ^= ((int16_t)9 << (int16_t)((uint32_t)(l_97.f0 = (p_68 == (func_78(((uint16_t)((uint32_t)((__builtin_ctz(p_69) == (p_68 >= (l_72.f0 <= ((uint16_t)(((int16_t)((l_72.f0 > (!((uint16_t)(l_72.f1 = p_68) % (uint16_t)p_68))) == 1U) << (int16_t)p_68) < l_95) - (uint16_t)0xB1EC)))) || p_68) - (uint32_t)p_68) * (uint16_t)0x52FA), l_96, l_97) & p_68))) - (uint32_t)0xC3E5849B))) >= 0));
    return l_96;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_78(uint32_t  p_79, union U1  p_80, struct S0  p_81)
{ /* block id: 41 */
    uint32_t l_101 = 5U;
    int32_t l_103 = 0x44E93343;
    struct S0 l_136 = {732,-22,-413};
    uint32_t l_197 = 4294967288U;
    int32_t l_260 = 0x431AA5C5;
    uint16_t l_268 = 1U;
    int16_t l_319 = (-3);
    uint32_t l_335 = 9U;
    int32_t l_354 = (-1);
    uint32_t l_400 = 4U;
    for (p_79 = 0; (p_79 == 55); p_79 += 1)
    { /* block id: 44 */
        uint16_t l_100 = 0x8884;
        int32_t l_102 = 0xFD6FFBBA;
        l_103 = (l_100 <= (l_102 = (l_100 && l_101)));
        p_81.f1 &= (l_100 >= __builtin_parityl(((uint16_t)l_100 * (uint16_t)(4294967287U | (p_81.f0 = l_102)))));
        l_103 = l_100;
    }
    if ((l_103 = l_103))
    { /* block id: 52 */
        struct S0 l_106 = {977,1407,2689};
        struct S0 l_107 = {-408,3543,-1031};
        int32_t l_139 = 0xEFFEB3B2;
        int32_t l_183 = (-1);
        l_107 = (l_106 = p_81);
        for (p_80.f0 = 0; (p_80.f0 != 10); p_80.f0 += 1)
        { /* block id: 57 */
            struct S0 l_110 = {95,1559,2020};
            p_81.f1 = p_81.f1;
            p_81 = l_110;
        }
        for (p_80.f0 = 0; (p_80.f0 == 10); p_80.f0 += 1)
        { /* block id: 63 */
            int32_t l_117 = (-1);
            int16_t l_135 = 0x1715;
            int32_t l_171 = 0;
            struct S0 l_196 = {846,-3674,587};
            int16_t l_231 = 0xF537;
            p_81.f1 &= p_81.f2;
            l_106.f2 |= 0xE5145DB5;
            for (l_103 = 0; (l_103 > (-13)); l_103 -= 3)
            { /* block id: 68 */
                uint16_t l_149 = 0xC936;
                struct S0 l_151 = {-531,-4263,-1269};
                if (((!__builtin_ffsll(p_81.f2)) == (((l_101 | (~((-1) ^ l_117))) | p_81.f0) , (l_106.f2 >= l_107.f1))))
                { /* block id: 69 */
                    uint32_t l_132 = 1U;
                    for (p_79 = 24; (p_79 != 16); p_79 -= 1)
                    { /* block id: 72 */
                        int32_t l_133 = (-1);
                        uint16_t l_134 = 0xDAAC;
                        l_135 = ((int16_t)((int32_t)(p_80 , 0xED7856BC) * (int32_t)((uint16_t)l_117 * (uint16_t)((int32_t)(((uint16_t)(p_81.f0 < ((l_132 = ((int16_t)l_107.f1 * (int16_t)l_117)) , ((l_101 & (l_101 != l_133)) <= l_133))) - (uint16_t)l_134) >= 4U) % (int32_t)1))) % (int16_t)p_81.f0);
                        p_81 = l_136;
                    }
                    l_136.f0 = p_81.f0;
                }
                else
                { /* block id: 78 */
                    struct S0 l_150 = {60,5441,-2873};
                    p_81 = (l_136.f1 , p_81);
                    for (p_79 = 0; (p_79 < 49); p_79 += 1)
                    { /* block id: 82 */
                        uint32_t l_142 = 1U;
                        int32_t l_143 = 2;
                        if (l_139)
                            break;
                        l_151 = (p_81 = (((((uint16_t)(p_80.f0 || l_103) << (uint16_t)((l_142 , (((0x124A7691 >= (l_143 = l_106.f1)) | p_80.f0) , ((int16_t)(l_143 = l_143) % (int16_t)(l_106.f1 &= (p_80.f0 == ((l_149 = ((int32_t)((-(int16_t)p_79) <= p_79) + (int32_t)p_81.f2)) != l_136.f2)))))) | 0xF805AAA4)) , l_149) < l_142) , l_150));
                        l_151.f1 = 0x4DD9E31D;
                        l_136.f0 = __builtin_popcount(p_81.f2);
                    }
                }
                for (l_135 = 0; (l_135 < (-21)); l_135 -= 3)
                { /* block id: 96 */
                    uint32_t l_170 = 1U;
                    int32_t l_184 = 8;
                    p_81.f2 ^= p_80.f0;
                    l_136.f1 |= (((int16_t)(((int32_t)(p_81.f1 = ((uint16_t)(((int16_t)(l_171 |= ((uint16_t)(((uint16_t)((((p_80.f0 < 0x9D24) & l_151.f0) < __builtin_parityll(((int32_t)p_81.f2 % (int32_t)(((int16_t)(__builtin_ffsll(p_80.f0) , 0x286D) - (int16_t)0xDF18) , (l_170 && p_81.f1))))) ^ p_81.f0) * (uint16_t)0xFC3C) > l_170) << (uint16_t)1)) << (int16_t)8) <= l_135) << (uint16_t)1)) + (int32_t)l_117) ^ p_81.f0) % (int16_t)p_80.f0) , 1);
                    if ((!((((((uint16_t)(((((uint16_t)(((((int16_t)(l_107.f2 != (p_81 , (((int32_t)((uint16_t)p_81.f2 >> (uint16_t)(p_80 , ((l_184 = (l_183 |= 65535U)) > l_135))) + (int32_t)((p_81.f0 = ((uint16_t)((uint16_t)((int16_t)(-5) * (int16_t)(((int16_t)(~p_81.f0) * (int16_t)((uint32_t)((l_196 = l_136) , p_81.f0) - (uint32_t)0x7BD1CFCE)) > p_81.f1)) << (uint16_t)15) >> (uint16_t)1)) && l_101)) || l_170))) >> (int16_t)10) && l_151.f2) > l_197) ^ 3U) * (uint16_t)l_135) ^ l_151.f0) | p_80.f0) | p_80.f0) >> (uint16_t)10) || p_81.f2) < l_136.f0) && (-1)) && p_79)))
                    { /* block id: 105 */
                        l_106 = l_151;
                        p_81 = p_81;
                    }
                    else
                    { /* block id: 108 */
                        uint16_t l_202 = 0x0C7C;
                        struct S0 l_203 = {12,2039,1165};
                        l_151.f0 = (__builtin_popcountl(((0xB03959C9 & (((int16_t)((l_149 , p_79) | p_81.f1) * (int16_t)1) || p_81.f2)) , ((((uint32_t)(l_202 = (p_79 = l_170)) - (uint32_t)(((((p_81.f1 , l_203) , 1) == p_81.f1) > 0xA575A083) || l_203.f2)) < p_81.f1) >= l_184))) < 0x286E7879);
                        p_81.f2 = (((uint16_t)((int16_t)l_151.f1 << (int16_t)2) >> (uint16_t)1) < ((uint16_t)l_106.f1 % (uint16_t)(((l_203.f2 |= ((((p_80 , p_80.f0) , l_117) == (p_79 = ((0x0B68 < l_136.f2) != (__builtin_clz(((int32_t)(l_136.f0 = 0x3EF624C3) - (int32_t)(p_79 && 0U))) == 6U)))) , p_81.f1)) , p_79) & l_202)));
                    }
                    p_81 = (((uint16_t)(~((int16_t)0x9350 >> (int16_t)((((l_106.f0 |= l_139) > l_151.f1) , (l_196.f1 = (((int16_t)p_81.f0 << (int16_t)13) | (l_151.f2 = (0x9F21 && (l_196.f2 = ((int16_t)((uint16_t)(p_80.f0 , ((int16_t)(p_80 , l_184) - (int16_t)(((uint32_t)((((int32_t)((uint32_t)(((l_196.f2 > 0xC837247A) <= l_103) >= p_81.f1) - (uint32_t)p_81.f2) % (int32_t)l_170) > 0xC4174CEC) ^ l_170) + (uint32_t)l_139) , p_81.f2))) * (uint16_t)1) * (int16_t)p_80.f0))))))) ^ l_231))) * (uint16_t)p_81.f2) , p_81);
                }
            }
        }
    }
    else
    { /* block id: 125 */
        int16_t l_240 = 0x3497;
        int32_t l_241 = (-4);
        int32_t l_242 = 0xEF48D875;
        int32_t l_247 = (-1);
        struct S0 l_254 = {-580,5467,198};
        int32_t l_259 = 1;
        union U1 l_269 = {0xA487C263};
        l_136.f2 |= ((uint32_t)((int16_t)0x63CB << (int16_t)(((uint16_t)__builtin_ffsll((l_247 = ((int16_t)(l_241 = ((l_240 != l_240) | l_136.f0)) << (int16_t)(p_79 < ((l_242 = 0x58A11968) ^ (((int16_t)((uint32_t)p_81.f0 + (uint32_t)(p_81.f1 = l_240)) * (int16_t)0) , p_81.f2)))))) % (uint16_t)p_81.f0) ^ p_81.f0)) + (uint32_t)(-9));
        if (((int16_t)((uint16_t)(((uint16_t)(p_81.f0 , ((p_81 , (l_254 , p_81.f0)) & (p_81.f1 <= ((l_101 != (0xCC039EE5 >= p_79)) > (l_242 = ((int16_t)(l_136.f2 = ((uint16_t)0xA7F0 << (uint16_t)14)) + (int16_t)l_247)))))) * (uint16_t)p_81.f1) > l_259) << (uint16_t)l_136.f1) * (int16_t)l_260))
        { /* block id: 133 */
            int32_t l_263 = (-1);
            int32_t l_272 = 1;
            uint16_t l_299 = 4U;
            int32_t l_314 = 1;
            struct S0 l_348 = {241,-2400,855};
            for (l_241 = 0; (l_241 >= (-25)); l_241 -= 1)
            { /* block id: 136 */
                uint16_t l_264 = 65535U;
                int32_t l_297 = 0;
                int32_t l_306 = 0xA28751E7;
                struct S0 l_313 = {-758,3820,-780};
                if ((l_242 = (-1)))
                { /* block id: 138 */
                    return p_81.f0;
                }
                else
                { /* block id: 140 */
                    uint32_t l_298 = 0xDF0B75FE;
                    int32_t l_302 = 0xD3039A17;
                    struct S0 l_318 = {-392,-2211,-1941};
                    p_81.f1 |= __builtin_parity((p_81.f2 , (((l_263 >= ((p_81.f0 = l_264) && l_263)) != (p_79 != ((int32_t)((p_81.f2 , ((!l_268) > (l_269 , ((l_272 ^= ((uint32_t)((65535U <= 1U) >= l_264) - (uint32_t)p_79)) > l_263)))) == 0x7F25558B) + (int32_t)0xB66C8A74))) == l_254.f1)));
                    if ((0x503D ^ 0U))
                    { /* block id: 144 */
                        struct S0 l_283 = {-476,5388,-1293};
                        p_81.f1 |= ((int16_t)(p_81.f2 , p_79) * (int16_t)__builtin_bswap64(p_81.f0));
                        p_81.f0 |= (((int32_t)l_263 + (int32_t)(l_242 = (1U >= ((uint16_t)p_80.f0 * (uint16_t)((uint32_t)p_80.f0 - (uint32_t)((uint16_t)0x7146 << (uint16_t)4)))))) > p_80.f0);
                        l_283 = p_81;
                        l_263 = ((((int16_t)((uint16_t)6U + (uint16_t)((l_298 = (1U ^ ((uint32_t)(((l_283.f2 , 0U) != (((l_136.f2 ^ p_79) ^ ((uint16_t)((int16_t)(p_80 , (-(int16_t)(p_81.f1 >= ((l_297 = (((uint16_t)p_81.f1 << (uint16_t)l_283.f1) > p_81.f2)) > p_81.f1)))) - (int16_t)0x965C) << (uint16_t)p_81.f2)) , p_79)) != 0) + (uint32_t)2))) & l_299)) >> (int16_t)13) >= l_283.f2) ^ 65533U);
                    }
                    else
                    { /* block id: 152 */
                        uint32_t l_305 = 0xC5BC5EB1;
                        l_302 = ((uint32_t)0xBEAF90EE - (uint32_t)p_81.f2);
                        if (p_79)
                            continue;
                        p_81.f0 = (((0x7024 > ((l_297 = ((p_81.f2 & p_81.f0) , p_81.f1)) || ((uint16_t)2U - (uint16_t)(((l_259 != p_79) ^ ((l_305 = l_136.f2) | p_81.f2)) >= p_81.f2)))) < p_80.f0) || l_306);
                    }
                    l_302 &= ((uint16_t)65533U + (uint16_t)((((__builtin_ffs(p_81.f0) < (((-9) | 0xDB39) == ((((uint16_t)(l_272 <= ((l_314 ^= (((((int16_t)p_81.f1 >> (int16_t)((p_80 , (((((((l_313 = p_81) , 8) | l_242) , l_263) , l_263) , 0xFF71) ^ 0xE0B0)) , 7U)) && l_136.f2) && p_81.f2) , p_80.f0)) != p_81.f0)) - (uint16_t)l_263) , 0x4DDF) == 0x832A))) == 0U) & l_268) , l_313.f2));
                    for (l_259 = 3; (l_259 < (-20)); l_259 -= 3)
                    { /* block id: 164 */
                        struct S0 l_317 = {950,47,2126};
                        l_318 = l_317;
                        l_319 = l_264;
                    }
                }
                p_81.f1 ^= l_241;
                l_335 = ((uint16_t)(((uint16_t)p_79 - (uint16_t)(!(__builtin_popcountll((0x66711149 != (((l_254.f1 = __builtin_popcountll(l_306)) & (l_313.f1 = (l_272 <= ((~((p_81.f1 >= p_79) < (-(uint32_t)(((int16_t)((uint16_t)(((uint16_t)__builtin_ctzl(((((uint16_t)l_313.f1 >> (uint16_t)(((((__builtin_ctzl(p_79) < 0x05E57BF4) < p_81.f2) == p_79) == 0) ^ p_79)) || l_299) , l_313.f2)) * (uint16_t)0xC7BE) || p_81.f2) * (uint16_t)l_313.f1) % (int16_t)6U) || 0)))) , l_314)))) != l_264))) != l_299))) , 65530U) * (uint16_t)1);
            }
            l_348 = ((((((int16_t)__builtin_ctzl(((0x1AFC | ((p_81.f1 > (l_136.f0 = l_299)) , l_268)) > (((0x6F49 > __builtin_bswap32(((l_241 = ((int32_t)((l_263 < ((int32_t)((uint16_t)((int32_t)l_103 + (int32_t)((uint16_t)p_81.f2 - (uint16_t)p_81.f0)) * (uint16_t)p_81.f1) - (int32_t)1)) ^ 0xE467) - (int32_t)4294967295U)) <= l_299))) | 0xF036) , l_240))) + (int16_t)p_80.f0) < p_81.f0) , l_314) >= p_81.f0) , p_81);
        }
        else
        { /* block id: 177 */
            l_136.f1 |= (p_81.f0 = l_254.f2);
        }
        l_254 = l_136;
    }
    p_81.f1 = (((uint16_t)((l_260 = (l_136.f1 = 0x7829)) | ((((((uint16_t)(l_136.f2 |= ((((0xE0E3 && p_81.f0) >= ((l_136.f0 = (!p_81.f1)) >= (l_103 = l_354))) | p_81.f0) > ((int16_t)p_79 + (int16_t)p_79))) + (uint16_t)(((p_79 == 0xC25E) , 0xE7E8) > l_319)) <= 0x4906) | p_81.f2) == l_354) > 0x5A6F)) << (uint16_t)3) > 7U);
    if (p_79)
    { /* block id: 189 */
        uint16_t l_363 = 65529U;
        int16_t l_379 = 0x7729;
        int32_t l_384 = 4;
        for (l_268 = 0; (l_268 < 57); l_268 += 2)
        { /* block id: 192 */
            uint32_t l_380 = 2U;
            int32_t l_381 = 0x36B85FAB;
            l_103 |= (p_81.f0 || ((int16_t)((p_81.f2 <= p_79) , (((int16_t)l_363 >> (int16_t)(((int16_t)__builtin_parityl(((uint32_t)(-(int32_t)(((((uint16_t)((int16_t)p_81.f1 * (int16_t)(l_381 = ((((uint32_t)(__builtin_parityl(l_136.f0) < ((l_363 & ((uint16_t)(((uint16_t)65532U >> (uint16_t)p_79) , l_379) >> (uint16_t)10)) > l_379)) + (uint32_t)l_380) || 0xBDC9EAAF) < 0x72D3))) >> (uint16_t)8) > l_379) | 0x149F6062) < l_363)) % (uint32_t)l_268)) >> (int16_t)0) != 0xCE19)) <= l_379)) >> (int16_t)14));
        }
        p_81.f0 ^= ((int16_t)p_81.f1 - (int16_t)l_363);
        p_81.f2 ^= (p_81.f0 |= 0x33B59288);
        l_384 = (-1);
    }
    else
    { /* block id: 200 */
        struct S0 l_385 = {-272,-4408,1739};
        struct S0 l_391 = {-651,-4179,2866};
        l_385 = p_81;
        l_136 = p_81;
        if (((int32_t)0xD0F0CD6C - (int32_t)3))
        { /* block id: 203 */
            uint16_t l_392 = 1U;
            int32_t l_393 = 1;
            struct S0 l_397 = {252,130,2687};
            l_103 |= __builtin_bswap64(((!((int16_t)l_385.f0 * (int16_t)(l_393 = (((p_80 , (l_391 = p_81)) , (l_392 = p_81.f1)) & 65535U)))) , 3U));
            l_400 = (-(int32_t)((l_136.f2 = (0x27DF && ((int32_t)l_268 - (int32_t)(l_397 , ((uint16_t)p_79 >> (uint16_t)9))))) , p_81.f0));
        }
        else
        { /* block id: 210 */
            return p_80.f0;
        }
    }
    return p_81.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 87
   depth: 1, occurrence: 26
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 26
breakdown:
   indirect level: 0, occurrence: 26
XXX full-bitfields structs in the program: 26
breakdown:
   indirect level: 0, occurrence: 26
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 24
XXX times a bitfields struct on RHS: 31
XXX times a single bitfield on LHS: 49
XXX times a single bitfield on RHS: 126

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 27
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 406
XXX times a non-volatile is write: 141
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 99
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 18
   depth: 2, occurrence: 17
   depth: 3, occurrence: 5
   depth: 4, occurrence: 13
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 21.8
XXX percentage an existing variable is used: 78.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

