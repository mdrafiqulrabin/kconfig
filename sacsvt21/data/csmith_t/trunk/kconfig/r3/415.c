/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3988890329
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_32(void);
static float  func_33(uint32_t  p_34, uint16_t  p_35, uint16_t  p_36);
static uint32_t  func_37(int32_t  p_38, int32_t  p_39, int16_t  p_40, int32_t  p_41);
inline static int16_t  func_49(int16_t  p_50, int16_t  p_51, uint32_t  p_52);
static uint32_t  func_53(float  p_54, float  p_55);
inline static int16_t  func_63(uint32_t  p_64);
static uint32_t  func_65(int32_t  p_66);
static int32_t *** func_77(int32_t  p_78);
inline static uint32_t  func_81(int32_t ** p_82, uint32_t  p_83);
inline static int32_t * func_84(int32_t  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_32(void)
{ /* block id: 36 */
    uint16_t l_42 = 0UL;
    uint32_t l_56 = 0xC78EF8A6L;
    uint16_t l_59 = 65535UL;
    float l_376 = 0x0.Ap+1;
    float *l_375 = &l_376;
    uint32_t l_379 = 18446744073709551615UL;
    int32_t ***l_382 = (void*)0;
    int16_t l_385 = 0L;
    int32_t l_388 = 1L;
    int32_t *l_387 = &l_388;
    int32_t **l_386 = &l_387;
    (*l_375) = func_33(func_37(l_42, ((uint16_t)(((uint16_t)((uint32_t)(((l_42 & (func_49(l_42, l_42, func_53(l_42, ((l_56 >= __builtin_popcountl(l_56)) > ((float)((((0x2.0F4D4Ep+24 != l_59) != l_42) > l_42) >= l_42) + (float)l_42)))) >= l_56)) <= l_59) >= l_42) % (uint32_t)l_42) << (uint16_t)l_56) ^ 1UL) << (uint16_t)l_42), l_59, l_56), l_59, l_42);
    (*l_386) = func_84(func_53((((l_56 != l_42) < ((float)0x9.30EDACp-39 + (float)l_379)) >= l_379), ((float)func_37(l_56, func_53(((void*)0 == l_382), ((float)(l_59 >= l_42) + (float)l_385)), l_56, l_385) - (float)l_42)));
    return l_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_33(uint32_t  p_34, uint16_t  p_35, uint16_t  p_36)
{ /* block id: 246 */
    int32_t l_348 = 1L;
    float *l_353 = (void*)0;
    float **l_352 = &l_353;
    float ***l_351 = &l_352;
    float l_358 = 0x0.6p+1;
    float *l_357 = &l_358;
    int32_t *l_360 = &l_348;
    int32_t **l_359 = &l_360;
    int32_t l_369 = 1L;
    int32_t *l_370 = &l_348;
    (*l_357) = (((float)l_348 + (float)0xE.3EEB7Ep-73) < (func_53((l_348 == (((float)__builtin_clzll(((void*)0 == l_351)) + (float)(!(l_348 < (((float)0x1.7p-1 - (float)(p_34 < 0x6.3p+1)) != 0x0.7p+1)))) <= 0xA.36901Cp-90)), p_36) <= p_36));
    (*l_359) = func_84(l_348);
    (*l_370) = ((int16_t)((p_35 < __builtin_clzll(p_36)) >= (&l_360 == &l_360)) + (int16_t)(((uint16_t)(((p_36 | __builtin_bswap32(((p_35 && (((int16_t)((l_348 >= p_36) == 0x7799F0F0L) << (int16_t)5) && l_369)) >= p_34))) == p_35) || 0xB5C2FCE0L) << (uint16_t)p_35) < l_348));
    if ((*l_370))
    { /* block id: 250 */
        return p_36;
    }
    else
    { /* block id: 252 */
        float l_373 = 0x0.3p-1;
        int32_t l_374 = (-5L);
        for (l_348 = 0; (l_348 > (-25)); l_348 -= 1)
        { /* block id: 255 */
            return p_34;
        }
        (*l_359) = (*l_359);
        (*l_370) = l_374;
    }
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_37(int32_t  p_38, int32_t  p_39, int16_t  p_40, int32_t  p_41)
{ /* block id: 213 */
    int32_t l_301 = 0xBB9C0675L;
    int32_t *l_300 = &l_301;
    int16_t l_317 = 0x83B3L;
    uint32_t l_322 = 4294967286UL;
    float **l_332 = (void*)0;
    float ***l_331 = &l_332;
    float ***l_333 = &l_332;
    int32_t **l_341 = &l_300;
    int32_t ***l_340 = &l_341;
    int32_t *l_342 = (void*)0;
    int32_t *l_343 = (void*)0;
    int32_t *l_344 = (void*)0;
    int32_t *l_345 = &l_301;
    (*l_300) = 0x6564C8A0L;
    if ((((((int16_t)__builtin_ffsl((&l_300 != &l_300)) >> (int16_t)(*l_300)) >= p_38) | ((*l_300) <= (*l_300))) == (p_40 & p_40)))
    { /* block id: 215 */
        int32_t **l_304 = &l_300;
        (*l_304) = &l_301;
        for (l_301 = 0; (l_301 < (-12)); l_301 -= 2)
        { /* block id: 219 */
            (*l_304) = &p_39;
        }
    }
    else
    { /* block id: 222 */
        float l_307 = 0x6.56F549p-86;
        int32_t l_308 = 0x44F47581L;
        int32_t **l_314 = &l_300;
        int32_t ***l_313 = &l_314;
        int32_t ****l_312 = &l_313;
        int32_t *****l_311 = &l_312;
        (*l_300) = ((*l_300) ^ p_38);
        l_308 = (*l_300);
        if (((p_38 & p_41) || (l_311 != (void*)0)))
        { /* block id: 225 */
            (***l_313) = __builtin_popcountl(((uint16_t)7UL >> (uint16_t)12));
            if (l_317)
            { /* block id: 227 */
                float *l_318 = (void*)0;
                float *l_319 = &l_307;
                (*l_319) = p_40;
            }
            else
            { /* block id: 229 */
                (***l_312) = (void*)0;
            }
            p_41 = ((uint16_t)l_322 - (uint16_t)(p_41 < p_39));
        }
        else
        { /* block id: 233 */
            float l_323 = (-0x1.Dp-1);
            return p_38;
        }
        for (l_317 = 0; (l_317 < (-3)); l_317 -= 1)
        { /* block id: 238 */
            int32_t *l_326 = (void*)0;
            int32_t *l_327 = (void*)0;
            int32_t *l_328 = &l_308;
            float *l_334 = (void*)0;
            float *l_335 = &l_307;
            (*l_328) = p_40;
            (*l_335) = (((float)func_63(p_40) - (float)p_40) != (l_331 == l_333));
        }
    }
    (*l_345) = (l_322 || (((l_317 ^ (((int32_t)(((uint16_t)(p_41 && (&l_332 == (void*)0)) >> (uint16_t)7) >= (l_340 != (void*)0)) % (int32_t)(p_41 & 0xEF64L)) & p_38)) <= p_40) <= (-2L)));
    (*l_341) = (**l_340);
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_49(int16_t  p_50, int16_t  p_51, uint32_t  p_52)
{ /* block id: 39 */
    int32_t l_289 = 0x3A9D2924L;
    int32_t *l_288 = &l_289;
    int32_t **l_287 = &l_288;
    int32_t ***l_286 = &l_287;
    int32_t ****l_285 = &l_286;
    int32_t *****l_284 = &l_285;
    if (((int16_t)func_63((func_65(p_52) > p_51)) << (int16_t)13))
    { /* block id: 204 */
        l_284 = (void*)0;
    }
    else
    { /* block id: 206 */
        float l_293 = 0x7.2p+1;
        float *l_294 = (void*)0;
        float *l_295 = &l_293;
        int32_t l_298 = 1L;
        uint16_t l_299 = 0x11B7L;
        (*l_295) = ((float)func_65((-(uint16_t)p_52)) - (float)(l_293 == p_51));
        (**l_287) = ((int32_t)(l_298 != func_63((((*****l_284) != 0xC8FAAC2AL) || l_298))) + (int32_t)func_53(l_299, p_52));
        (*l_295) = (0xF.D22A38p+0 > p_52);
    }
    (*l_287) = (***l_285);
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_53(float  p_54, float  p_55)
{ /* block id: 37 */
    uint32_t l_60 = 0x3631AF66L;
    return l_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_63(uint32_t  p_64)
{ /* block id: 196 */
    int32_t l_283 = 0x9BDA0E25L;
    int32_t *l_282 = &l_283;
    for (p_64 = 0; (p_64 >= 45); p_64 += 1)
    { /* block id: 199 */
        float l_281 = 0x0.Dp-1;
        float *l_280 = &l_281;
        (*l_280) = p_64;
    }
    l_282 = l_282;
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_65(int32_t  p_66)
{ /* block id: 40 */
    int32_t l_68 = 0x27A4EF21L;
    int32_t *l_67 = &l_68;
    int32_t **l_69 = &l_67;
    int32_t *l_72 = &l_68;
    float l_194 = 0x0.2p+1;
    uint32_t l_202 = 0UL;
    int32_t ***l_222 = &l_69;
    float *l_267 = &l_194;
    float **l_266 = &l_267;
    (*l_69) = l_67;
    if (((uint32_t)p_66 % (uint32_t)0xD757520CL))
    { /* block id: 42 */
        float l_76 = 0xA.10320Bp+34;
        float *l_75 = &l_76;
        (*l_69) = l_72;
        for (p_66 = 0; (p_66 < 18); p_66 += 1)
        { /* block id: 46 */
            return p_66;
        }
        (*l_75) = p_66;
    }
    else
    { /* block id: 50 */
        int32_t ***l_134 = &l_69;
        int32_t ****l_133 = &l_134;
        (*l_133) = func_77(((uint16_t)(func_81(&l_72, p_66) <= p_66) - (uint16_t)0x24E9L));
    }
    (*l_69) = (*l_69);
    if ((p_66 || 0xC83560E5L))
    { /* block id: 77 */
        int32_t *l_135 = (void*)0;
        int32_t *l_136 = &l_68;
        float l_138 = 0xD.7AB573p+52;
        float *l_137 = &l_138;
        int32_t *l_150 = &l_68;
        (*l_69) = l_135;
        (*l_136) = (p_66 || (p_66 >= p_66));
        (*l_137) = p_66;
        for (l_68 = (-12); (l_68 < 23); l_68 += 9)
        { /* block id: 83 */
            int32_t **l_141 = (void*)0;
            int32_t l_149 = 3L;
            int32_t *l_148 = &l_149;
            int32_t **l_151 = &l_72;
            l_69 = l_141;
            (*l_148) = ((0x5DA63383L <= ((uint32_t)(0xB8E4L > (p_66 >= ((uint16_t)(((0x92DBL > p_66) == p_66) && ((void*)0 == l_141)) >> (uint16_t)13))) - (uint32_t)(-1L))) ^ 0UL);
            (*l_151) = l_150;
            (*l_137) = p_66;
        }
    }
    else
    { /* block id: 89 */
        int32_t l_160 = (-3L);
        int32_t *l_169 = &l_68;
        int32_t l_190 = 0x110A1B7EL;
        int32_t ***l_251 = &l_69;
        (*l_69) = func_84((**l_69));
        if (((int16_t)0x6505L >> (int16_t)(((((uint16_t)p_66 << (uint16_t)0) | func_81(&l_67, (p_66 <= p_66))) ^ 0L) == ((int16_t)l_160 - (int16_t)0xC8C0L))))
        { /* block id: 91 */
            int32_t *l_179 = &l_68;
            for (l_68 = 0; (l_68 > (-23)); l_68 -= 1)
            { /* block id: 94 */
                float l_164 = 0x7.Ep+1;
                float *l_163 = &l_164;
                (*l_163) = 0x1.FD4834p-84;
            }
            if (l_160)
            { /* block id: 97 */
                int32_t *l_178 = &l_68;
                int32_t *l_191 = &l_68;
                for (l_160 = 0; (l_160 < 10); l_160 += 4)
                { /* block id: 100 */
                    int32_t *l_170 = &l_68;
                    for (l_68 = 0; (l_68 <= (-6)); l_68 -= 2)
                    { /* block id: 103 */
                        uint16_t l_171 = 7UL;
                        (*l_69) = l_169;
                        (*l_69) = l_170;
                        if (p_66)
                            continue;
                        l_171 = p_66;
                    }
                    if (p_66)
                        break;
                }
                (*l_69) = func_84(p_66);
                if ((((int16_t)((*l_169) < ((uint32_t)(l_178 != l_179) + (uint32_t)p_66)) + (int16_t)((uint16_t)((uint16_t)((p_66 && (((int32_t)(*l_178) + (int32_t)((void*)0 == &l_179)) & (((uint16_t)((int32_t)0L % (int32_t)4294967295UL) - (uint16_t)0xF930L) != 0x9EFAAE2EL))) != (*l_178)) >> (uint16_t)l_190) << (uint16_t)(*l_169))) > 0L))
                { /* block id: 112 */
                    l_191 = func_84(p_66);
                }
                else
                { /* block id: 114 */
                    float l_193 = 0x7.7p-1;
                    float *l_192 = &l_193;
                    int32_t l_199 = 1L;
                    (*l_192) = (-0x1.4p+1);
                    (*l_192) = (((-0x5.6p+1) != 0x0.2p-1) != ((-0x4.Cp-1) != ((0x0.CAC60Cp+74 <= 0xF.988BF1p+16) != ((((l_194 >= p_66) != (((p_66 > ((float)((float)(0x2.50C07Bp+19 == l_199) - (float)l_199) + (float)0x1.6p+1)) <= 0xE.686DD1p+73) < (*l_178))) == p_66) >= 0x0.3p+1))));
                    return p_66;
                }
                (*l_69) = l_191;
            }
            else
            { /* block id: 120 */
                (*l_179) = ((int32_t)(&l_190 == (*l_69)) - (int32_t)4294967295UL);
            }
        }
        else
        { /* block id: 123 */
            int16_t l_203 = 0x8CC6L;
            (*l_169) = l_202;
            l_203 = __builtin_ffsl((&l_169 != &l_169));
        }
        if ((*l_169))
        { /* block id: 127 */
            float l_206 = 0x4.4A2723p-70;
            int32_t l_214 = (-5L);
            for (l_190 = 0; (l_190 < (-24)); l_190 -= 1)
            { /* block id: 130 */
                int32_t ***l_223 = &l_69;
                int32_t *l_242 = &l_190;
                if (p_66)
                { /* block id: 131 */
                    float l_213 = 0x0.4p+1;
                    int32_t l_234 = 1L;
                    int32_t ****l_243 = (void*)0;
                    int32_t ****l_244 = &l_222;
                    if ((1UL == (p_66 ^ ((int16_t)((int32_t)((uint16_t)l_214 >> (uint16_t)12) * (int32_t)(((int16_t)0xFA8EL + (int16_t)(*l_169)) < ((int16_t)(((uint16_t)1UL >> (uint16_t)p_66) || (!(l_222 != l_223))) << (int16_t)13))) % (int16_t)0x5C8EL))))
                    { /* block id: 132 */
                        int32_t *l_224 = &l_68;
                        l_224 = &l_214;
                        if (l_214)
                            break;
                        (*l_169) = ((*l_169) == (*l_169));
                    }
                    else
                    { /* block id: 136 */
                        uint32_t l_237 = 0x7480F3EFL;
                        l_214 = (((int16_t)((int32_t)((uint16_t)(-(int32_t)p_66) - (uint16_t)0x8352L) - (int32_t)((uint16_t)l_234 + (uint16_t)((uint16_t)0UL - (uint16_t)(l_237 >= l_214)))) << (int16_t)__builtin_parity(l_237)) ^ (*l_169));
                        (**l_223) = (void*)0;
                    }
                    for (l_202 = 0; (l_202 > 25); l_202 += 1)
                    { /* block id: 142 */
                        int32_t ****l_241 = &l_223;
                        int32_t *****l_240 = &l_241;
                        (**l_223) = &l_190;
                        (*l_240) = &l_222;
                        (**l_223) = l_242;
                    }
                    (*l_244) = (void*)0;
                    (*l_69) = (*l_69);
                }
                else
                { /* block id: 149 */
                    (*l_169) = p_66;
                    (*l_169) = (0x0C0BL <= func_53(p_66, (*l_169)));
                }
                (*l_169) = ((uint16_t)((int32_t)((*l_242) <= ((uint16_t)((void*)0 != l_251) >> (uint16_t)15)) - (int32_t)0UL) >> (uint16_t)6);
                for (l_214 = 0; (l_214 == (-18)); l_214 -= 2)
                { /* block id: 156 */
                    if (p_66)
                        break;
                }
            }
        }
        else
        { /* block id: 160 */
            int32_t l_254 = 0x06FF82CCL;
            int32_t *l_255 = &l_68;
            float **l_268 = &l_267;
            if ((((l_254 < (l_254 <= 0L)) || p_66) <= p_66))
            { /* block id: 161 */
                (**l_251) = l_255;
            }
            else
            { /* block id: 163 */
                int32_t ****l_256 = &l_251;
                int32_t l_260 = 0xA905D2FDL;
                (*l_255) = 0x4F8E9901L;
                if ((l_256 == &l_222))
                { /* block id: 165 */
                    float l_257 = 0x6.8p+1;
                    int32_t l_261 = 4L;
                    (*l_255) = ((func_53(l_257, ((0x1.B0F379p+67 <= ((float)(((l_260 > (l_261 < 0x3.0p-1)) <= 0x1.12AEBCp+68) < (((((float)p_66 + (float)(l_251 == (void*)0)) == p_66) > 0xC.E36C2Dp-20) != p_66)) + (float)p_66)) != p_66)) || (-1L)) <= 0xB25185A7L);
                    (*l_256) = func_77((p_66 | ((uint16_t)65535UL << (uint16_t)p_66)));
                    (*l_69) = func_84((l_266 != (void*)0));
                    (*l_69) = l_255;
                }
                else
                { /* block id: 170 */
                    float ***l_269 = &l_266;
                    (*l_169) = p_66;
                    (*l_269) = l_268;
                }
                for (l_190 = 0; (l_190 <= 24); l_190 += 3)
                { /* block id: 176 */
                    return p_66;
                }
                (*l_69) = l_255;
            }
            for (l_254 = (-9); (l_254 >= 14); l_254 += 1)
            { /* block id: 183 */
                if (p_66)
                    break;
                if (p_66)
                    continue;
                for (l_160 = 0; (l_160 < 22); l_160 += 6)
                { /* block id: 188 */
                    int32_t ****l_277 = &l_251;
                    int32_t *****l_276 = &l_277;
                    (*l_276) = &l_222;
                }
                (**l_266) = p_66;
            }
        }
    }
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_77(int32_t  p_78)
{ /* block id: 61 */
    int32_t l_114 = 0x40B9FCDBL;
    int32_t l_124 = 0x13CC227AL;
    int32_t *l_123 = &l_124;
    int32_t **l_122 = &l_123;
    int32_t ***l_121 = &l_122;
    int32_t ***l_125 = &l_122;
    int32_t ***l_126 = &l_122;
    int32_t ***l_127 = &l_122;
    int32_t ***l_128 = &l_122;
    int32_t ***l_129 = &l_122;
    int32_t ***l_130 = &l_122;
    int32_t ***l_131 = &l_122;
    int32_t ***l_132 = (void*)0;
    for (p_78 = 0; (p_78 <= (-25)); p_78 -= 1)
    { /* block id: 64 */
        int32_t l_111 = 0x633072FEL;
        for (l_111 = 0; (l_111 != 10); l_111 += 5)
        { /* block id: 67 */
            float l_116 = 0xE.89CE68p+18;
            float *l_115 = &l_116;
            float **l_118 = (void*)0;
            float ***l_117 = &l_118;
            int32_t *l_120 = &l_111;
            int32_t **l_119 = &l_120;
            (*l_115) = l_114;
            (*l_117) = &l_115;
            (*l_119) = &l_111;
        }
    }
    return l_132;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_81(int32_t ** p_82, uint32_t  p_83)
{ /* block id: 51 */
    int16_t l_97 = 0x39D3L;
    int32_t *l_98 = (void*)0;
    int32_t **l_106 = &l_98;
    int32_t ***l_105 = &l_106;
    int32_t l_107 = 0xC53ECDF3L;
    int32_t *l_108 = &l_107;
    (*p_82) = func_84((-(uint16_t)p_83));
    (*p_82) = func_84((__builtin_popcount(l_97) < ((void*)0 == l_98)));
    (*l_108) = (__builtin_popcount(p_83) || ((p_83 < ((int16_t)((uint16_t)(((-3L) >= ((int32_t)((l_105 != &p_82) > (-1L)) % (int32_t)func_53(l_97, p_83))) && p_83) >> (uint16_t)11) >> (int16_t)l_107)) != p_83));
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_84(int32_t  p_85)
{ /* block id: 52 */
    int32_t l_88 = 0x18F7F2F1L;
    int32_t *l_87 = &l_88;
    int32_t **l_89 = &l_87;
    uint32_t l_90 = 8UL;
    float l_92 = 0x2.Ep+1;
    float *l_91 = &l_92;
    int32_t *l_93 = &l_88;
    int32_t *l_94 = &l_88;
    int32_t *l_95 = &l_88;
    int32_t *l_96 = (void*)0;
    (*l_89) = l_87;
    (*l_91) = (((p_85 <= (p_85 <= p_85)) <= ((__builtin_clz((*l_87)) < (-0x1.3p-1)) >= ((func_53(l_90, p_85) < (-0x1.Ap-1)) != (**l_89)))) < (**l_89));
    (*l_89) = &p_85;
    return l_96;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 93
XXX total union variables: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 162
   depth: 2, occurrence: 28
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 29, occurrence: 1

XXX total number of pointers: 109

XXX times a variable address is taken: 110
XXX times a pointer is dereferenced on RHS: 29
breakdown:
   depth: 1, occurrence: 23
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 74
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 282

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 109
   level: 2, occurrence: 42
   level: 3, occurrence: 26
   level: 4, occurrence: 5
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 55
XXX number of pointers point to scalars: 54
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 28.4
XXX average alias set size: 1.16

XXX times a non-volatile is read: 352
XXX times a non-volatile is write: 185
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 138
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 27
   depth: 2, occurrence: 23
   depth: 3, occurrence: 20
   depth: 4, occurrence: 21
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 16.1
XXX percentage an existing variable is used: 83.9
********************* end of statistics **********************/

