/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      275266251
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int32_t  f0;
   uint32_t  f1;
   int32_t  f2;
};

union U1 {
   const uint32_t  f0;
   uint16_t  f1;
   const uint32_t  f2;
};

union U2 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_32(void);
inline static float  func_36(int16_t  p_37, int32_t * p_38, const int32_t  p_39, int32_t ** p_40);
inline static uint32_t  func_43(int32_t ** p_44, union U0  p_45);
inline static int32_t ** func_46(union U1  p_47, int32_t ** p_48);
static int32_t ** func_50(int32_t ** p_51, const union U0  p_52, union U0  p_53, int32_t ** p_54);
inline static int32_t ** func_55(uint16_t  p_56);
inline static float  func_64(uint32_t  p_65, int32_t ** p_66, union U1  p_67, int32_t ** p_68, int32_t ** p_69);
static const uint16_t  func_72(uint16_t  p_73, uint32_t  p_74, const int16_t  p_75, int32_t  p_76, float  p_77);
inline static uint32_t  func_78(float  p_79, uint32_t  p_80, int32_t ** p_81, int32_t * p_82);
inline static float  func_87(union U2  p_88, int32_t * p_89, int32_t * p_90, int32_t  p_91, int32_t  p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_32(void)
{ /* block id: 36 */
    const int32_t l_34 = 0xC9D73DF2;
    const int32_t *l_33 = &l_34;
    const int32_t **l_35 = &l_33;
    union U1 l_49 = {4294967295U};
    const union U0 l_308 = {-2};
    int32_t *l_355 = (void*)0;
    float l_479 = 0x7.1F22C5p-37;
    float *l_478 = &l_479;
    int32_t l_480 = 1;
    (*l_35) = l_33;
    (*l_478) = (func_36((((int32_t)(func_43(func_46(l_49, func_50(func_55(((*l_33) != 0U)), l_308, l_308, func_55((!(**l_35))))), l_308) >= (*l_33)) + (int32_t)(**l_35)) >= (**l_35)), l_355, (**l_35), &l_355) != 0x0.Dp-1);
    return l_480;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_36(int16_t  p_37, int32_t * p_38, const int32_t  p_39, int32_t ** p_40)
{ /* block id: 229 */
    uint32_t l_359 = 5U;
    const union U1 **l_362 = (void*)0;
    const union U1 ***l_361 = &l_362;
    const union U1 ****l_360 = &l_361;
    uint16_t l_363 = 9U;
    int32_t l_367 = (-1);
    int32_t * const l_366 = &l_367;
    union U0 l_371 = {7};
    union U0 *l_370 = &l_371;
    int32_t l_451 = 0x96D0341D;
    union U2 l_459 = {0xB725B331};
    union U2 * const l_458 = &l_459;
    union U2 * const * const l_457 = &l_458;
    union U1 l_463 = {4294967290U};
    union U1 *l_462 = &l_463;
    int32_t ***l_469 = (void*)0;
    int32_t *** const *l_468 = &l_469;
lbl_454:
    if (((uint16_t)((((~__builtin_bswap64(l_359)) && (l_360 != (void*)0)) != l_359) >= (l_359 > __builtin_ffsll(l_363))) - (uint16_t)((int16_t)1 - (int16_t)p_39)))
    { /* block id: 230 */
        int32_t *l_369 = &l_367;
        int32_t **l_368 = &l_369;
        union U0 *l_372 = &l_371;
        int32_t l_373 = 0xFAD1FED2;
        (*l_368) = l_366;
        (*l_368) = (*p_40);
        /* statement id: 232 */
        assert (l_369 == 0);
        (*l_366) = ((l_370 != l_372) | (l_373 && (((int32_t)((*l_366) > (4294967295U != ((int16_t)(((uint16_t)((((int16_t)p_39 >> (int16_t)7) <= p_39) ^ 0xE718) << (uint16_t)10) ^ p_39) >> (int16_t)12))) + (int32_t)(*l_366)) ^ 0x5E68)));
        (*l_368) = (*l_368);
    }
    else
    { /* block id: 235 */
        (*p_40) = (*p_40);
    }
    if ((*l_366))
    { /* block id: 238 */
        float l_383 = (-0x9.Ap+1);
        (*l_366) = (~p_37);
    }
    else
    { /* block id: 240 */
        int32_t *l_387 = &l_367;
        int32_t **l_386 = &l_387;
        int32_t ***l_385 = &l_386;
        int32_t ****l_384 = &l_385;
        union U1 l_405 = {4294967295U};
        union U1 * const l_404 = &l_405;
        union U1 * const *l_403 = &l_404;
        union U1 * const **l_402 = &l_403;
        union U1 l_428 = {0xD8D233E5};
        union U1 *l_427 = &l_428;
        union U0 *l_444 = (void*)0;
        union U2 *l_461 = &l_459;
        union U2 * const *l_460 = &l_461;
        if ((((__builtin_ffsll((*l_366)) > ((void*)0 == l_384)) < ((uint16_t)65535U + (uint16_t)(*l_366))) || (*l_366)))
        { /* block id: 241 */
            float l_396 = 0x7.F29AA2p-56;
            int32_t l_397 = 0xF72A8431;
            union U1 **l_399 = (void*)0;
            union U1 ***l_398 = &l_399;
            float *l_400 = (void*)0;
            float *l_401 = &l_396;
            const union U0 *l_411 = (void*)0;
            const union U0 **l_410 = &l_411;
            const union U0 ** const * const l_409 = &l_410;
            union U2 l_441 = {0U};
            union U2 *l_440 = &l_441;
            int32_t **l_449 = &l_387;
            (*l_401) = ((((((float)(*l_387) + (float)0x4.9EFFBCp+39) > (((float)((__builtin_clzll(((int16_t)(*l_366) << (int16_t)(l_397 & p_39))) > (l_398 != (*l_360))) == p_39) + (float)p_37) >= l_397)) != (*l_366)) <= p_39) >= (***l_385));
            if ((p_39 & (l_402 != (*l_360))))
            { /* block id: 243 */
                uint32_t l_408 = 0x56947012;
                int32_t l_419 = 0x83E85DAE;
                union U1 *l_425 = &l_405;
                const union U1 ***l_429 = &l_362;
                int32_t **l_432 = &l_387;
                int32_t l_438 = 0x2009CEDE;
                (*l_366) = l_397;
                for (l_371.f2 = 0; (l_371.f2 <= (-21)); l_371.f2 -= 9)
                { /* block id: 247 */
                    union U0 **l_414 = &l_370;
                    union U0 ***l_413 = &l_414;
                    union U0 ****l_412 = &l_413;
                    int32_t l_420 = (-4);
                    (*l_387) = l_408;
                    if ((*l_366))
                        continue;
                    (*l_412) = l_409;
                    /* statement id: 250 */
                    assert (l_413 == &l_410);
                    for (l_367 = 23; (l_367 != 28); l_367++)
                    { /* block id: 253 */
                        (*l_401) = (((float)(p_39 <= p_39) - (float)l_419) > l_420);
                    }
                }
                /* facts after for loop */
                                for (l_405.f1 = (-1); (l_405.f1 <= 36); l_405.f1++)
                { /* block id: 259 */
                    union U2 **l_442 = (void*)0;
                    union U2 **l_443 = &l_440;
                    for (l_408 = (-22); (l_408 != 21); ++l_408)
                    { /* block id: 262 */
                        union U1 *l_426 = (void*)0;
                        l_426 = l_425;
                        /* statement id: 263 */
                        assert (l_426 == &l_405);
                    }
                    l_427 = (*l_403);
                    /* statement id: 265 */
                    assert (l_427 == &l_405);
                }
                /* facts after for loop */
                                assert (l_427 == &l_405 || l_427 == &l_428);
                (***l_384) = &l_367;
            }
            else
            { /* block id: 279 */
                int32_t **l_450 = &l_387;
                (**l_409) = l_444;
                (*l_410) = (*l_410);
                if (l_371.f2)
                    goto lbl_445;
lbl_445:
                (**l_385) = (void*)0;
                /* statement id: 282 */
                assert (l_387 == 0);
                (*l_401) = (-(float)(p_39 >= (l_451 == 0xF.63B8ECp-20)));
            }
            /* facts after branching */
                        assert (l_387 == 0 || l_387 == &l_367);
                        assert (l_427 == &l_405 || l_427 == &l_428);
        }
        else
        { /* block id: 286 */
            for (l_371.f1 = (-23); (l_371.f1 != 9); l_371.f1++)
            { /* block id: 289 */
                float l_456 = (-0x8.Bp+1);
                float *l_455 = &l_456;
                if (l_371.f1)
                    goto lbl_454;
                (*l_455) = (-0x1.3p-1);
            }
            /* facts after for loop */
                        l_460 = l_457;
            /* statement id: 293 */
            assert (l_460 == &l_458);
        }
        /* facts after branching */
                assert (l_387 == 0 || l_387 == &l_367);
                assert (l_427 == &l_405 || l_427 == &l_428);
        assert (l_460 == &l_458 || l_460 == &l_461);
        return p_39;
    }
    if (((void*)0 != l_462))
    { /* block id: 297 */
        int32_t *l_467 = (void*)0;
        int32_t **l_466 = &l_467;
        int32_t ***l_465 = &l_466;
        int32_t ****l_464 = &l_465;
        (*l_366) = (l_464 != l_468);
        (***l_464) = (*p_40);
    }
    else
    { /* block id: 300 */
        const uint16_t l_473 = 65529U;
        float l_477 = (-0x1.0p-1);
        float *l_476 = &l_477;
        float **l_475 = &l_476;
        float ***l_474 = &l_475;
        (***l_474) = (-(float)((*l_366) < (((float)l_473 + (float)0x7.7p+1) > ((l_474 == &l_475) <= 0x1.093B7Ap-26))));
    }
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_43(int32_t ** p_44, union U0  p_45)
{ /* block id: 226 */
    union U2 l_353 = {0U};
    union U2 *l_352 = &l_353;
    union U2 **l_354 = &l_352;
    (*l_354) = l_352;
    return l_353.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_46(union U1  p_47, int32_t ** p_48)
{ /* block id: 201 */
    int32_t *l_324 = (void*)0;
    uint32_t l_330 = 0x9D22561A;
    const union U1 l_346 = {0U};
    const union U1 *l_345 = &l_346;
    const union U1 **l_344 = &l_345;
    const union U1 ***l_343 = &l_344;
    const union U1 ****l_342 = &l_343;
    const union U1 *****l_341 = &l_342;
    float l_349 = 0xB.79CF3Ap+64;
    float *l_350 = &l_349;
    for (p_47.f1 = (-11); (p_47.f1 == 36); p_47.f1 += 4)
    { /* block id: 204 */
        int32_t l_321 = 0xBB4101EE;
    }
    /* facts after for loop */
        if (p_47.f1)
        goto lbl_351;
lbl_351:
    (*l_350) = (((float)(((float)__builtin_bswap64(((((func_72(((int16_t)(((l_330 | ((int32_t)(p_47.f1 | p_47.f1) + (int32_t)p_47.f1)) > p_47.f1) > (l_341 == (void*)0)) << (int16_t)8), l_346.f2, ((int16_t)(__builtin_bswap32(l_346.f0) | l_330) << (int16_t)13), l_346.f0, p_47.f1) && p_47.f1) < 0) != 0x089B) > p_47.f1)) - (float)p_47.f1) == 0x8.2E5B33p-73) - (float)0xD.E842E0p-62) == p_47.f1);
    l_324 = l_324;
    return p_48;
    /* statement id: 225 */
    //assert (func_46_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_50(int32_t ** p_51, const union U0  p_52, union U0  p_53, int32_t ** p_54)
{ /* block id: 190 */
    float l_310 = 0x1.9p-1;
    int32_t l_311 = 3;
    union U2 l_315 = {0x01516D38};
    float *l_316 = &l_310;
    int32_t *l_318 = &l_311;
    int32_t **l_317 = &l_318;
    if (l_311)
    { /* block id: 191 */
        int32_t *l_312 = &l_311;
        int32_t **l_313 = &l_312;
        (*l_313) = l_312;
        (*l_313) = &l_311;
    }
    else
    { /* block id: 194 */
        uint32_t l_314 = 1U;
        l_314 = p_53.f1;
    }
    l_311 = func_87(l_315, &l_311, &l_311, l_315.f0, l_315.f0);
    (*l_316) = 0x0.Dp+1;
    (*l_317) = &l_311;
    return p_51;
    /* statement id: 200 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_55(uint16_t  p_56)
{ /* block id: 38 */
    int32_t l_57 = 2;
    int32_t *l_63 = &l_57;
    int32_t **l_62 = &l_63;
    union U1 l_70 = {0xA4182467};
    float l_197 = 0x0.4p+1;
    float *l_196 = &l_197;
    union U1 **l_198 = (void*)0;
    union U1 l_200 = {0U};
    union U1 *l_199 = &l_200;
    float ** const l_204 = &l_196;
    float ** const *l_203 = &l_204;
    union U0 l_250 = {1};
    union U0 *l_249 = &l_250;
    int32_t ****l_265 = (void*)0;
    int16_t l_290 = 0x1829;
    int16_t l_299 = 0x02EC;
    int32_t **l_306 = &l_63;
    int32_t **l_307 = (void*)0;
    (*l_196) = ((l_57 < ((float)0x0.090D79p-61 + (float)((float)l_57 + (float)(((l_62 == &l_63) == __builtin_clzll((*l_63))) > func_64((*l_63), &l_63, l_70, &l_63, &l_63))))) > (**l_62));
    (*l_63) = ((p_56 != __builtin_clz(p_56)) < __builtin_ctzll(((&l_62 != (void*)0) & (-4))));
    l_199 = &l_70;
    /* statement id: 113 */
    assert (l_199 == &l_70);
    if (((uint16_t)(**l_62) << (uint16_t)(func_72((**l_62), (l_203 != &l_204), (**l_62), (*l_63), (&l_198 == &l_198)) ^ 4294967288U)))
    { /* block id: 114 */
        union U0 l_206 = {0xFE794198};
        union U0 *l_205 = &l_206;
        union U1 *l_207 = &l_200;
        (*l_63) = (l_205 == (void*)0);
        (***l_203) = (l_207 == (void*)0);
    }
    else
    { /* block id: 117 */
        int32_t l_213 = 0x9DD186F0;
        const int32_t ***l_224 = (void*)0;
        const int32_t ****l_223 = &l_224;
        union U2 l_229 = {4294967295U};
        union U2 *l_228 = &l_229;
        int32_t **l_237 = &l_63;
        int32_t **l_242 = (void*)0;
        int32_t **l_248 = &l_63;
        union U0 **l_282 = &l_249;
        union U1 *l_300 = &l_200;
lbl_305:
        for (p_56 = 0; (p_56 < 56); p_56 += 4)
        { /* block id: 120 */
            uint32_t l_212 = 2U;
            int32_t **l_238 = &l_63;
            int32_t ***l_255 = &l_237;
            union U0 *l_279 = &l_250;
        }
        for (p_56 = 0; (p_56 == 46); p_56 += 8)
        { /* block id: 175 */
            union U1 l_302 = {4294967292U};
            union U1 *l_301 = &l_302;
            if (l_299)
            { /* block id: 176 */
                int32_t *l_303 = &l_57;
                union U2 **l_304 = &l_228;
                (***l_203) = (p_56 >= p_56);
                l_301 = l_300;
                /* statement id: 178 */
                assert (l_301 == &l_200);
                (*l_248) = l_303;
                l_304 = l_304;
            }
            else
            { /* block id: 181 */
                (*l_237) = (*l_237);
                if ((**l_62))
                    continue;
            }
            /* facts after branching */
            assert (l_301 == &l_302 || l_301 == &l_200);
            (*l_237) = (*l_62);
        }
        if (p_56)
            goto lbl_305;
    }
    return l_307;
    /* statement id: 189 */
    //assert (func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_64(uint32_t  p_65, int32_t ** p_66, union U1  p_67, int32_t ** p_68, int32_t ** p_69)
{ /* block id: 39 */
    uint32_t l_71 = 3U;
    int32_t l_86 = 0x12551AD0;
    int32_t *l_85 = &l_86;
    union U2 l_93 = {9U};
    int32_t l_94 = 0;
    int32_t l_138 = 1;
    (*l_85) = (l_71 == (func_72(((((func_78(((((float)(l_85 == &l_86) + (float)(*l_85)) > (&l_85 == (void*)0)) <= (func_87(l_93, (*p_66), (*p_68), (*l_85), l_94) > l_138)), p_67.f0, p_69, &l_86) ^ (**p_68)) | p_65) ^ l_93.f0) < 0xDD41), p_67.f0, p_67.f0, (**p_68), p_67.f0) || 65534U));
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_72(uint16_t  p_73, uint32_t  p_74, const int16_t  p_75, int32_t  p_76, float  p_77)
{ /* block id: 87 */
    const uint32_t l_167 = 0xFB73433C;
    union U0 l_180 = {0x892AB80D};
    union U0 *l_179 = &l_180;
    int16_t l_184 = 0x3006;
    for (p_76 = 0; (p_76 < (-22)); --p_76)
    { /* block id: 90 */
        float l_164 = (-0x1.2p-1);
        int32_t l_165 = 0xF681533B;
        int32_t *l_166 = &l_165;
        union U0 **l_181 = (void*)0;
        union U1 l_194 = {0xD1672963};
        union U1 *l_193 = &l_194;
        union U1 **l_192 = &l_193;
        union U1 ***l_191 = &l_192;
        union U1 **** const l_190 = &l_191;
        union U1 **** const *l_189 = &l_190;
        (*l_166) = (l_165 > __builtin_ffsl(p_75));
        if (p_76)
        { /* block id: 92 */
            return l_167;
        }
        else
        { /* block id: 94 */
            float *l_168 = (void*)0;
            float *l_169 = &l_164;
            union U2 l_170 = {0x9527C193};
            (*l_169) = p_76;
            (*l_169) = func_87(l_170, &l_165, &p_76, p_76, ((-(uint32_t)(__builtin_popcountl(((uint32_t)(*l_166) - (uint32_t)((((int16_t)p_74 % (int16_t)((int16_t)p_76 % (int16_t)l_167)) && ((((((!((l_167 || p_74) && 1)) & l_167) <= p_75) ^ p_75) < (*l_166)) & (-10))) == 1U))) != p_76)) || (*l_166)));
        }
        l_179 = l_179;
        for (p_73 = 11; (p_73 > 9); p_73--)
        { /* block id: 101 */
            uint16_t l_187 = 65535U;
            int32_t **l_188 = &l_166;
            union U1 **** const *l_195 = (void*)0;
            l_187 = (((l_184 >= p_76) == ((float)p_76 - (float)0x1.B199FBp+73)) <= p_74);
            (*l_166) = p_75;
            (*l_188) = &l_165;
            l_195 = l_189;
            /* statement id: 105 */
            assert (l_195 == &l_190);
        }
    }
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads : l_63
 * writes:
 */
inline static uint32_t  func_78(float  p_79, uint32_t  p_80, int32_t ** p_81, int32_t * p_82)
{ /* block id: 69 */
    int32_t ** const **l_148 = (void*)0;
    union U2 l_150 = {0x547ECB7B};
    union U2 *l_149 = &l_150;
    int32_t l_155 = 9;
    int32_t *l_154 = &l_155;
    uint16_t l_156 = 1U;
    union U1 **l_159 = (void*)0;
    union U1 ** const *l_158 = &l_159;
    union U1 ** const **l_157 = &l_158;
    float l_161 = (-0x3.Ep-1);
    float *l_160 = &l_161;
    if ((*p_82))
    { /* block id: 70 */
        union U1 ***l_139 = (void*)0;
        union U1 ****l_140 = (void*)0;
        union U1 ****l_141 = &l_139;
        float **l_142 = (void*)0;
        float * const *l_144 = (void*)0;
        float * const **l_143 = &l_144;
        union U2 **l_151 = &l_149;
        (*l_141) = l_139;
        (*l_143) = l_142;
        for (p_80 = 0; (p_80 < 34); p_80 += 1)
        { /* block id: 75 */
            uint16_t l_147 = 0xF04F;
            if (l_147)
                break;
            l_148 = l_148;
            (*p_82) = l_147;
        }
        (*l_151) = l_149;
    }
    else
    { /* block id: 81 */
        return p_80;
    }
    (*l_154) = ((0x4.45CBE7p+92 <= (((float)((p_79 <= p_80) >= ((void*)0 == &p_82)) + (float)(p_79 <= (func_87((*l_149), l_154, (*p_81), (*p_82), (*l_154)) >= 0x3.B43B7Ap+6))) <= 0x5.56077Ep+42)) == l_156);
    (*l_160) = ((-0x10.Ep-1) >= (((l_157 != &l_158) > ((*l_154) > ((-0x4.4p-1) != (p_80 > ((*l_154) >= (&p_82 == &p_82)))))) == (*l_154)));
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_87(union U2  p_88, int32_t * p_89, int32_t * p_90, int32_t  p_91, int32_t  p_92)
{ /* block id: 40 */
    int32_t ***l_95 = (void*)0;
    int32_t ****l_96 = &l_95;
    uint32_t l_104 = 0x8D8D3B62;
    int32_t l_111 = 0x52F54C42;
    int32_t *l_110 = &l_111;
    union U1 l_136 = {4294967295U};
    union U1 *l_135 = &l_136;
    (*l_96) = l_95;
    for (p_92 = 0; (p_92 <= 19); p_92 += 4)
    { /* block id: 44 */
        float l_103 = 0xE.80B09Dp+38;
        const int32_t l_106 = 0;
        int32_t *** const l_107 = (void*)0;
        float *l_134 = &l_103;
        union U1 **l_137 = &l_135;
        if (((int16_t)((uint32_t)p_92 - (uint32_t)((p_88.f0 != (p_92 >= (l_104 & (!l_106)))) == (l_107 != (void*)0))) >> (int16_t)(((uint16_t)p_92 + (uint16_t)p_92) > l_106)))
        { /* block id: 45 */
            int32_t **l_112 = &l_110;
            int32_t ***l_117 = &l_112;
            (*l_112) = l_110;
            (*l_110) = ((int16_t)(((&p_91 == &p_91) >= __builtin_bswap64((p_88.f0 && __builtin_clzl(p_91)))) == 65530U) << (int16_t)4);
            for (l_104 = 0; (l_104 > 22); ++l_104)
            { /* block id: 50 */
                (*l_112) = &p_91;
                /* statement id: 51 */
                assert (l_110 == &p_91);
                return p_91;
            }
            (*l_117) = &p_89;
            /* statement id: 54 */
            assert (l_112 == &p_89);
        }
        else
        { /* block id: 55 */
            int32_t *l_122 = &l_111;
            for (p_91 = 0; (p_91 > (-16)); p_91--)
            { /* block id: 58 */
                int32_t l_123 = (-1);
                float *l_132 = (void*)0;
                float *l_133 = &l_103;
                (*l_122) = (((__builtin_parity((((int16_t)((void*)0 == l_122) << (int16_t)l_123) ^ ((0 < ((uint16_t)(*l_122) - (uint16_t)__builtin_ffsll(p_92))) < p_92))) | (*l_122)) != p_91) >= 4294967295U);
                (*l_133) = (((!(((void*)0 == &p_91) <= 0x7.E736DEp+14)) > ((float)(__builtin_ffsll((__builtin_bswap64(p_91) ^ (-(uint32_t)(*l_122)))) <= ((float)__builtin_ctzll(p_91) + (float)p_92)) - (float)l_123)) == p_92);
                if (l_123)
                    break;
            }
            if (l_106)
                continue;
        }
        (*l_134) = (p_92 > (0xC.E0E570p+99 != p_88.f0));
        (*l_137) = l_135;
    }
    return p_91;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 143
XXX total union variables: 6

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 144
   depth: 2, occurrence: 19
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 4
   depth: 12, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 180

XXX times a variable address is taken: 168
XXX times a pointer is dereferenced on RHS: 99
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 28
   depth: 3, occurrence: 9
XXX times a pointer is dereferenced on LHS: 83
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 6
   depth: 3, occurrence: 10
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 314

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 240
   level: 2, occurrence: 58
   level: 3, occurrence: 27
   level: 4, occurrence: 9
XXX number of pointers point to pointers: 111
XXX number of pointers point to scalars: 38
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.6
XXX average alias set size: 1.14

XXX times a non-volatile is read: 603
XXX times a non-volatile is write: 231
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 4

XXX stmts: 118
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 31
   depth: 2, occurrence: 22
   depth: 3, occurrence: 22
   depth: 4, occurrence: 6
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 24.1
XXX percentage an existing variable is used: 75.9
********************* end of statistics **********************/

