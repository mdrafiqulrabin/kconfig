/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      4155116440
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 26;
   unsigned f1 : 7;
   signed f2 : 13;
   unsigned f3 : 5;
   signed : 0;
};

struct S1 {
   const unsigned f0 : 3;
   signed f1 : 16;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   unsigned f0 : 10;
   unsigned f1 : 14;
   const signed f2 : 20;
   signed f3 : 26;
   signed f4 : 3;
   unsigned f5 : 5;
   signed f6 : 9;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S3 {
   signed f0 : 1;
   const signed f1 : 28;
   unsigned f2 : 16;
   const unsigned f3 : 23;
   signed f4 : 26;
   signed f5 : 5;
   const struct S1  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_1(void);
inline static int16_t  func_9(uint16_t  p_10, uint16_t  p_11, const int32_t  p_12, struct S0 * p_13);
inline static int16_t  func_21(struct S3  p_22);
inline static struct S3  func_23(uint32_t  p_24, uint16_t  p_25, const uint32_t  p_26);
inline static int16_t  func_28(struct S0 * p_29, const uint32_t  p_30, int32_t  p_31);
inline static struct S0 * func_32(const uint32_t  p_33);
static uint32_t  func_38(int32_t * p_39);
inline static int32_t * func_40(uint8_t  p_41, int16_t  p_42, int32_t * p_43);
inline static int32_t  func_44(uint32_t  p_45, const uint16_t  p_46, int32_t  p_47);
inline static struct S0  func_49(int32_t * p_50, struct S0 * p_51);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0;
    struct S0 *l_903 = (void*)0;
    int32_t *l_914 = (void*)0;
    int32_t **l_913 = &l_914;
    struct S0 l_915 = {1434,0,-65,2};
    for (l_2 = 0; (l_2 > 17); l_2 = safe_add_func_int16_t_s_s(l_2, 1))
    { /* block id: 3 */
        struct S0 l_5 = {5771,10,78,0};
        struct S0 *l_6 = (void*)0;
        int16_t l_27 = 0x55BB;
        int32_t l_912 = 0;
        int32_t *l_911 = &l_912;
        l_5 = l_5;
        (*l_911) = (1 | ((safe_div_func_int32_t_s_s((func_9((0x813C27F3 || (safe_rshift_func_uint8_t_u_s(l_5.f3, l_2))), (l_5.f0 > (~(safe_add_func_uint8_t_u_u((safe_mod_func_int16_t_s_s(func_21(func_23((l_27 > l_2), (l_5.f1 == func_28(func_32(l_5.f2), l_2, l_2)), l_27)), (-10))), l_5.f3)))), l_5.f3, l_903) < 0x4A19), l_5.f0)) || 4U));
        return l_5;
    }
    (*l_913) = &l_2;
    /* statement id: 419 */
    assert (l_914 == &l_2);
    return l_915;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_9(uint16_t  p_10, uint16_t  p_11, const int32_t  p_12, struct S0 * p_13)
{ /* block id: 412 */
    struct S3 l_907 = {0,-16380,167,1265,7968,-2,{1,22}};
    struct S3 *l_906 = &l_907;
    struct S3 **l_905 = &l_906;
    struct S3 ***l_904 = &l_905;
    struct S0 l_909 = {4118,3,-52,2};
    struct S0 *l_908 = &l_909;
    struct S0 **l_910 = &l_908;
    (*l_904) = (void*)0;
    /* statement id: 413 */
    assert (l_905 == 0);
    (*l_910) = l_908;
    return l_907.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_21(struct S3  p_22)
{ /* block id: 409 */
    int32_t l_901 = 1;
    int32_t *l_900 = &l_901;
    int32_t **l_902 = &l_900;
    (*l_902) = l_900;
    return p_22.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S3  func_23(uint32_t  p_24, uint16_t  p_25, const uint32_t  p_26)
{ /* block id: 381 */
    int32_t l_869 = (-1);
    struct S2 l_883 = {28,6,-313,-6272,1,0,5};
    struct S2 *l_882 = &l_883;
    struct S1 l_891 = {0,-255};
    struct S1 *l_890 = &l_891;
    struct S1 **l_889 = &l_890;
    struct S1 ***l_888 = &l_889;
    int8_t l_895 = 0;
    int32_t *l_896 = &l_869;
    struct S0 l_897 = {7909,5,-16,0};
    struct S0 *l_898 = &l_897;
    struct S3 l_899 = {0,-11607,192,807,-8156,3,{1,217}};
    for (p_25 = 0; (p_25 > 30); p_25 = safe_add_func_uint8_t_u_u(p_25, 1))
    { /* block id: 384 */
        uint8_t l_849 = 0xFA;
        struct S0 l_879 = {433,1,-28,0};
        if (l_849)
        { /* block id: 385 */
            int32_t l_851 = 0x418248DF;
            int32_t *l_850 = &l_851;
            int32_t **l_852 = (void*)0;
            int32_t **l_853 = &l_850;
            (*l_853) = l_850;
        }
        else
        { /* block id: 387 */
            uint32_t l_859 = 0x509EA1D8;
            struct S0 l_872 = {95,3,-30,2};
            struct S0 *l_871 = &l_872;
            for (p_24 = (-9); (p_24 != 40); p_24 = safe_add_func_uint16_t_u_u(p_24, 1))
            { /* block id: 390 */
                uint16_t l_864 = 1U;
                int32_t *l_870 = &l_869;
                (*l_870) = ((-2) >= (safe_lshift_func_uint16_t_u_s(0xE2DC, (~(l_859 ^ (safe_add_func_int8_t_s_s((safe_div_func_uint8_t_u_u((p_24 < l_859), l_864)), (safe_rshift_func_uint8_t_u_u(l_859, ((8 == (~(safe_unary_minus_func_uint8_t_u(((l_869 == p_26) <= l_864))))) <= p_25))))))))));
            }
            (*l_871) = func_49(&l_869, l_871);
            for (l_849 = (-27); (l_849 > 29); l_849 = safe_add_func_uint16_t_u_u(l_849, 5))
            { /* block id: 396 */
                for (l_859 = 25; (l_859 > 24); l_859 = safe_sub_func_uint8_t_u_u(l_859, 7))
                { /* block id: 399 */
                    int32_t *l_877 = &l_869;
                    struct S0 *l_878 = (void*)0;
                    struct S2 l_881 = {17,39,682,-6033,-0,3,-12};
                    struct S2 *l_880 = &l_881;
                    l_879 = func_49(l_877, l_878);
                    l_882 = l_880;
                    /* statement id: 401 */
                    assert (l_882 == &l_881);
                }
            }
        }
    }
    /* facts after for loop */
    //assert (l_882 == dangling || l_882 == &l_883);
    (*l_896) = (safe_mod_func_int32_t_s_s((safe_rshift_func_uint8_t_u_s(l_883.f2, (l_888 == &l_889))), (safe_unary_minus_func_uint8_t_u((safe_sub_func_int32_t_s_s(l_883.f0, l_895))))));
    (*l_898) = l_897;
    return l_899;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_28(struct S0 * p_29, const uint32_t  p_30, int32_t  p_31)
{ /* block id: 363 */
    uint8_t l_840 = 253U;
    int32_t l_846 = 0xE4C064EB;
    for (p_31 = (-20); (p_31 > (-9)); ++p_31)
    { /* block id: 366 */
        int32_t l_818 = 0;
        int32_t l_827 = (-4);
        for (l_818 = 0; (l_818 <= (-3)); l_818 = safe_sub_func_uint32_t_u_u(l_818, 1))
        { /* block id: 369 */
            int32_t l_839 = (-1);
            int32_t *l_841 = &l_839;
            (*l_841) = ((safe_rshift_func_int16_t_s_u(0x119B, ((p_31 || (safe_lshift_func_int8_t_s_u((((((safe_mod_func_int16_t_s_s(l_827, (safe_lshift_func_uint8_t_u_s((0x05 ^ p_30), (p_31 <= 0x8F8E1867))))) && (safe_add_func_int32_t_s_s((safe_rshift_func_uint16_t_u_u(p_30, 9)), (safe_rshift_func_int8_t_s_s((safe_lshift_func_int16_t_s_u(((~p_30) && l_839), 15)), p_30))))) || 0x62A6) & 0x86735836) < p_31), l_840))) <= l_839))) <= 7);
            return l_840;
        }
    }
    for (p_31 = 0; (p_31 != 0); p_31 = safe_add_func_uint8_t_u_u(p_31, 7))
    { /* block id: 376 */
        int32_t l_845 = 0x06DEE129;
        int32_t *l_844 = &l_845;
        (*l_844) = p_30;
    }
    l_846 = l_840;
    return l_846;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_32(const uint32_t  p_33)
{ /* block id: 5 */
    int32_t l_35 = 0x505D01CD;
    int32_t *l_34 = &l_35;
    uint8_t l_48 = 255U;
    struct S2 ***l_589 = (void*)0;
    int32_t *l_808 = (void*)0;
    int32_t *l_809 = &l_35;
    struct S0 l_811 = {7323,3,-8,2};
    struct S0 *l_810 = &l_811;
    struct S0 *l_812 = &l_811;
    struct S0 *l_813 = &l_811;
    struct S0 *l_814 = &l_811;
    struct S0 *l_815 = (void*)0;
    l_34 = (void*)0;
    /* statement id: 6 */
    assert (l_34 == 0);
    (*l_809) = (safe_sub_func_uint32_t_u_u(func_38(func_40(((func_44(l_48, l_35, p_33) | ((safe_add_func_uint16_t_u_u(((0x0EB540D9 < (~p_33)) < (((void*)0 != l_589) < (!(2 > 5U)))), p_33)) <= l_35)) | p_33), p_33, &l_35)), p_33));
    return l_815;
    /* statement id: 362 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_38(int32_t * p_39)
{ /* block id: 285 */
    int32_t l_614 = 0x320501DB;
    struct S1 l_620 = {0,25};
    struct S1 *l_619 = &l_620;
    uint32_t l_631 = 0x29DB3400;
    const struct S2 *l_649 = (void*)0;
    const struct S2 **l_648 = &l_649;
    struct S2 * const ****l_662 = (void*)0;
    struct S1 l_719 = {0,-64};
    struct S1 *l_718 = &l_719;
    struct S3 l_738 = {0,13028,217,1221,2768,-2,{1,89}};
    struct S3 *l_737 = &l_738;
    int32_t * const l_776 = &l_614;
    int32_t * const *l_775 = &l_776;
    int32_t *l_777 = &l_614;
    struct S2 l_791 = {11,43,-257,4516,0,4,2};
    struct S2 *l_790 = &l_791;
    struct S2 **l_789 = &l_790;
    struct S2 ***l_788 = &l_789;
    struct S2 ****l_787 = &l_788;
    struct S0 l_804 = {6875,9,89,2};
    struct S0 *l_803 = &l_804;
    struct S0 **l_802 = &l_803;
    struct S0 *** const l_801 = &l_802;
    int16_t l_805 = (-1);
    int32_t **l_806 = &l_777;
    int32_t l_807 = 0x0EC064C4;
lbl_699:
    for (l_614 = 0; (l_614 < 6); ++l_614)
    { /* block id: 288 */
        struct S1 *l_621 = &l_620;
        int32_t ***l_624 = (void*)0;
        int32_t l_630 = 1;
        int32_t *l_637 = &l_614;
        int32_t **l_636 = &l_637;
        uint16_t l_663 = 0x293F;
        (*p_39) = ((safe_mod_func_int8_t_s_s(((((l_619 == l_621) || (((l_624 == l_624) != ((safe_sub_func_int8_t_s_s(0x05, l_614)) <= (0xAFDC1896 | (safe_div_func_uint8_t_u_u((!0xDB523160), l_630))))) > l_614)) && l_620.f0) >= l_631), l_620.f1)) || 0x2E);
        (*l_636) = func_40((safe_mod_func_int8_t_s_s((-1), (safe_lshift_func_uint16_t_u_s(l_620.f0, ((0x95 == 0xB1) != 0U))))), (p_39 != p_39), p_39);
        /* statement id: 290 */
        //assert (l_637 == &l_35);
        (*p_39) = (safe_add_func_int32_t_s_s((*p_39), (((l_614 | (safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_s((safe_add_func_int32_t_s_s((safe_add_func_int8_t_s_s((((void*)0 == l_648) ^ (safe_sub_func_int32_t_s_s((*p_39), (((safe_sub_func_int32_t_s_s(((**l_636) <= (((safe_lshift_func_uint8_t_u_u(0xEF, (safe_div_func_int8_t_s_s(l_614, (~(safe_add_func_int32_t_s_s((!((l_662 == l_662) ^ (-1))), (**l_636)))))))) >= l_620.f0) < l_620.f1)), 0xA8812CF3)) || 0) ^ 0x38)))), l_620.f1)), 4294967292U)), l_663)), 5))) || 6) != (**l_636))));
    }
    for (l_631 = (-8); (l_631 < 34); l_631 = safe_add_func_int16_t_s_s(l_631, 8))
    { /* block id: 295 */
        struct S0 l_677 = {7655,7,45,1};
        struct S2 *l_714 = (void*)0;
        struct S2 **l_713 = &l_714;
        struct S2 ***l_712 = &l_713;
        struct S3 *l_739 = &l_738;
        struct S1 **l_756 = &l_619;
        struct S1 ***l_755 = &l_756;
        struct S0 *l_768 = &l_677;
        struct S0 **l_767 = &l_768;
        struct S0 ***l_766 = &l_767;
        uint16_t l_772 = 0x3FE5;
        if ((*p_39))
        { /* block id: 296 */
            struct S0 ***l_666 = (void*)0;
            struct S0 ****l_667 = &l_666;
            int32_t *l_670 = &l_614;
            (*l_667) = l_666;
            if ((l_614 & (safe_mod_func_uint8_t_u_u(((l_670 != (void*)0) || l_631), l_620.f1))))
            { /* block id: 298 */
                struct S0 *l_678 = &l_677;
                const struct S3 l_680 = {0,15957,221,2160,5210,-3,{1,-218}};
                const struct S3 *l_679 = &l_680;
                struct S3 *l_682 = (void*)0;
                struct S3 **l_681 = &l_682;
                for (l_614 = 0; (l_614 > (-13)); l_614 = safe_sub_func_int16_t_s_s(l_614, 8))
                { /* block id: 301 */
                    struct S0 l_674 = {1512,0,-10,4};
                    const struct S0 *l_673 = &l_674;
                    struct S0 *l_676 = &l_674;
                    struct S0 **l_675 = &l_676;
                    (*l_675) = l_673;
                    return l_674.f3;
                }
                (*l_678) = l_677;
                (*l_681) = l_679;
                /* statement id: 306 */
                assert (l_682 == &l_680);
            }
            else
            { /* block id: 307 */
                uint32_t l_685 = 0U;
                struct S0 *l_686 = &l_677;
                for (l_614 = 0; (l_614 >= (-11)); l_614 = safe_sub_func_int8_t_s_s(l_614, 1))
                { /* block id: 310 */
                    int32_t l_694 = 0x7BCF869D;
                    (*p_39) = (l_685 >= ((((void*)0 != l_686) || ((safe_mod_func_uint8_t_u_u((!((safe_div_func_int32_t_s_s(((safe_lshift_func_uint16_t_u_s(l_677.f0, l_620.f0)) != l_677.f3), l_694)) <= ((l_620.f1 > (((safe_rshift_func_uint16_t_u_s(l_694, 9)) == l_694) <= l_620.f1)) ^ l_694))), l_694)) < 1)) || l_677.f2));
                }
                (*p_39) = 8;
                if ((*p_39))
                    continue;
                for (l_614 = (-3); (l_614 != 29); l_614 = safe_add_func_uint8_t_u_u(l_614, 1))
                { /* block id: 317 */
                    struct S3 *l_707 = (void*)0;
                    if (l_614)
                        goto lbl_699;
                    (*p_39) = ((safe_unary_minus_func_int16_t_s(((safe_add_func_uint8_t_u_u(((safe_sub_func_int32_t_s_s((0x8C && 0xA2), (*p_39))) & (((safe_mod_func_int32_t_s_s((l_707 != (void*)0), (((*p_39) < l_677.f2) ^ (safe_sub_func_int16_t_s_s((safe_lshift_func_uint8_t_u_u(255U, (((void*)0 != l_712) & 0xFF))), 0xEC47))))) > 1U) > l_685)), (*l_670))) <= l_685))) != l_685);
                    for (l_685 = 4; (l_685 <= 57); l_685 = safe_add_func_uint32_t_u_u(l_685, 2))
                    { /* block id: 322 */
                        if (l_685)
                            break;
                    }
                    if (l_677.f1)
                        continue;
                }
            }
        }
        else
        { /* block id: 328 */
            struct S1 *l_717 = (void*)0;
            l_718 = l_717;
            /* statement id: 329 */
            assert (l_718 == 0);
        }
        if ((safe_mod_func_int32_t_s_s(((safe_lshift_func_int8_t_s_s(((safe_rshift_func_int8_t_s_s((safe_rshift_func_int8_t_s_u(((-1) >= l_677.f3), 3)), 3)) ^ (safe_add_func_uint16_t_u_u(((l_614 < ((void*)0 == (*l_712))) == ((~l_677.f3) <= (safe_sub_func_uint32_t_u_u((l_737 == l_739), 0x205DFD9B)))), l_677.f1))), l_677.f3)) || l_677.f0), l_738.f6.f0)))
        { /* block id: 331 */
            uint8_t l_742 = 0x0E;
            uint32_t l_757 = 0xD009DE20;
            for (l_614 = 1; (l_614 == (-18)); l_614 = safe_sub_func_int8_t_s_s(l_614, 6))
            { /* block id: 334 */
                int32_t *l_744 = (void*)0;
                int32_t **l_743 = &l_744;
                (*l_743) = func_40(l_742, l_738.f5, p_39);
                /* statement id: 335 */
                //assert (l_744 == &l_35);
                if (((((safe_add_func_uint16_t_u_u((**l_743), (**l_743))) > l_738.f4) || ((safe_div_func_int16_t_s_s((((safe_add_func_int16_t_s_s((l_677.f2 && (safe_mod_func_uint16_t_u_u(((l_738.f6.f0 ^ ((*l_744) <= ((((safe_rshift_func_uint16_t_u_u(l_742, 4)) ^ ((l_755 != (void*)0) == (*l_744))) ^ (-10)) && 4294967290U))) > l_677.f3), l_677.f2))), 0x9BBF)) == (**l_743)) && l_677.f1), (-1))) <= l_631)) == l_677.f1))
                { /* block id: 336 */
                    struct S3 *l_758 = &l_738;
                    struct S3 **l_759 = &l_739;
                    if (l_757)
                        break;
                    (*l_759) = l_758;
                    for (l_757 = (-29); (l_757 != 11); l_757 = safe_add_func_int32_t_s_s(l_757, 1))
                    { /* block id: 341 */
                        (*l_743) = p_39;
                    }
                }
                else
                { /* block id: 344 */
                    (**l_743) = 0xBF3DD166;
                }
            }
            (*p_39) = l_742;
            l_777 = func_40(l_742, ((l_738.f2 >= (safe_rshift_func_uint16_t_u_u(l_719.f1, (((safe_add_func_uint32_t_u_u((l_766 == (void*)0), (!(l_742 != (((safe_lshift_func_uint8_t_u_u((l_772 && l_757), 5)) >= ((safe_div_func_uint16_t_u_u(((l_775 != (void*)0) || 0x1C), l_757)) <= l_757)) < (*p_39)))))) < l_677.f0) && 4)))) & 0x2EC6), p_39);
            /* statement id: 349 */
            //assert (l_777 == &l_35);
        }
        else
        { /* block id: 350 */
            if ((*p_39))
                break;
            for (l_614 = 24; (l_614 < 1); l_614 = safe_sub_func_int8_t_s_s(l_614, 1))
            { /* block id: 354 */
                uint8_t l_780 = 0x94;
                return l_780;
            }
        }
    }
    (*l_806) = func_40((safe_mod_func_uint8_t_u_u((0x1251 | (**l_775)), (*l_776))), (safe_add_func_int16_t_s_s(((((*p_39) == (safe_rshift_func_int8_t_s_s(((void*)0 == l_787), 0))) >= (safe_lshift_func_uint8_t_u_u((safe_unary_minus_func_uint32_t_u(((((safe_lshift_func_int16_t_s_u(0xC32F, ((safe_div_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u((l_801 == (void*)0), (*l_776))), (*l_776))) >= l_805))) | (*l_777)) & (-1)) <= (**l_775)))), (**l_775)))) && 0x6FE12CF4), (*l_776))), p_39);
    /* statement id: 359 */
    //assert (l_777 == &l_35);
    return l_807;
}


/* ------------------------------------------ */
/* 
 * reads : l_35
 * writes: l_35
 */
inline static int32_t * func_40(uint8_t  p_41, int16_t  p_42, int32_t * p_43)
{ /* block id: 279 */
    int16_t l_597 = 0;
    struct S2 ****l_599 = (void*)0;
    struct S2 *****l_598 = &l_599;
    struct S2 l_604 = {14,122,833,951,1,3,21};
    struct S2 *l_603 = &l_604;
    int32_t l_612 = 0x3B31FDA1;
    int32_t *l_611 = &l_612;
    int32_t **l_613 = &l_611;
    (*p_43) = (safe_lshift_func_int16_t_s_u(((safe_rshift_func_int8_t_s_s(p_42, (((safe_sub_func_uint32_t_u_u((l_597 < ((l_598 != (void*)0) <= (safe_mod_func_int8_t_s_s(((!((void*)0 != l_603)) < l_604.f3), ((safe_mod_func_uint16_t_u_u(l_597, ((((safe_mod_func_int8_t_s_s((safe_lshift_func_int8_t_s_s((-6), l_604.f6)), l_604.f3)) & 0xD7E1A42C) < 0x0D0315C2) || (-8)))) && (-3)))))), l_604.f1)) != p_42) > 0x41))) && p_42), p_41));
    l_611 = l_611;
    (*l_613) = p_43;
    /* statement id: 282 */
    //assert (l_611 == &l_35);
    (*p_43) = (**l_613);
    return p_43;
    /* statement id: 284 */
    //assert (func_40_rv == &l_35);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_44(uint32_t  p_45, const uint16_t  p_46, int32_t  p_47)
{ /* block id: 7 */
    int32_t l_53 = 0x3C9199ED;
    int32_t *l_52 = &l_53;
    struct S0 *l_54 = (void*)0;
    struct S0 *l_280 = (void*)0;
    struct S0 l_282 = {4104,6,-47,4};
    struct S0 *l_281 = &l_282;
    const struct S3 l_288 = {-0,15631,249,509,6244,-0,{1,45}};
    const struct S3 *l_287 = &l_288;
    struct S2 l_313 = {13,0,698,-4929,1,1,0};
    struct S2 *l_312 = &l_313;
    struct S2 **l_311 = &l_312;
    struct S2 ***l_310 = &l_311;
    struct S2 ****l_309 = &l_310;
    struct S1 *l_318 = (void*)0;
    struct S1 **l_317 = &l_318;
    int32_t ***l_328 = (void*)0;
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_49(int32_t * p_50, struct S0 * p_51)
{ /* block id: 8 */
    struct S2 l_56 = {8,2,212,-5519,-0,2,12};
    struct S2 *l_55 = &l_56;
    struct S2 **l_57 = &l_55;
    int32_t l_58 = 0xB70486D4;
    uint32_t l_70 = 0xABB00F61;
    struct S2 ** const *l_77 = &l_57;
    struct S0 l_78 = {3540,3,-22,2};
    struct S3 l_133 = {-0,-716,123,47,-8148,-0,{1,-170}};
    struct S3 *l_132 = &l_133;
    struct S3 **l_131 = &l_132;
    int32_t *l_135 = &l_58;
    struct S0 *l_177 = &l_78;
    struct S0 **l_176 = &l_177;
    int32_t **l_228 = &l_135;
    int32_t ***l_227 = &l_228;
    struct S0 l_279 = {8174,10,-58,0};
lbl_81:
    (*l_57) = l_55;
    for (l_58 = 0; (l_58 == (-30)); l_58 = safe_sub_func_uint8_t_u_u(l_58, 9))
    { /* block id: 12 */
        struct S2 *l_61 = &l_56;
        int32_t l_69 = 0xB7466640;
        struct S0 l_80 = {5887,10,24,2};
        struct S2 ***l_87 = &l_57;
        int8_t l_96 = 5;
        struct S3 l_98 = {0,-5079,25,2696,-546,3,{1,207}};
        struct S3 *l_97 = &l_98;
        struct S2 * const *l_141 = &l_55;
        struct S2 * const **l_140 = &l_141;
        int32_t ***l_194 = (void*)0;
        int16_t l_219 = 0x6A89;
        struct S3 *l_258 = &l_133;
        struct S2 *** const *l_278 = &l_87;
        struct S2 *** const **l_277 = &l_278;
        (*l_57) = l_61;
        if (((safe_sub_func_int8_t_s_s((65527U ^ (((l_56.f5 & (!(safe_sub_func_uint32_t_u_u(((&l_61 == &l_61) > ((l_61 == (*l_57)) < (0xB2FE0738 < (-3)))), ((((safe_sub_func_uint32_t_u_u(l_69, l_70)) <= l_69) != 0x8D6F) <= (-10)))))) & l_69) | 0xE2)), l_70)) & l_56.f5))
        { /* block id: 14 */
            struct S2 **l_73 = (void*)0;
            int32_t *l_75 = &l_69;
            int32_t **l_74 = &l_75;
            struct S0 l_136 = {4688,2,76,1};
            (*p_50) = (safe_mod_func_int32_t_s_s((l_73 != &l_55), ((&l_58 != p_50) || l_56.f3)));
            (*l_74) = (void*)0;
            /* statement id: 16 */
            assert (l_75 == 0);
            if ((*p_50))
            { /* block id: 17 */
                struct S2 ** const *l_76 = &l_57;
                struct S0 *l_79 = &l_78;
                l_77 = l_76;
                (*l_79) = l_78;
                return l_80;
            }
            else
            { /* block id: 21 */
                (*l_74) = (void*)0;
                if (l_56.f3)
                    goto lbl_81;
            }
            if (((l_78.f1 | 0x5B50) < (((safe_lshift_func_int8_t_s_u(((((safe_add_func_int32_t_s_s((l_80.f2 && (~(l_87 == l_87))), ((l_80.f3 == l_80.f1) == (65535U > l_78.f3)))) <= 0) >= l_69) & l_58), l_80.f0)) >= (*p_50)) > l_80.f1)))
            { /* block id: 25 */
                for (l_69 = 0; (l_69 != 18); l_69 = safe_add_func_uint32_t_u_u(l_69, 6))
                { /* block id: 28 */
                    (*p_50) = (*p_50);
                }
            }
            else
            { /* block id: 31 */
                int32_t l_103 = 3;
                const struct S2 *l_129 = &l_56;
                struct S0 l_138 = {2074,5,72,1};
                struct S2 ****l_142 = &l_87;
                if ((((((safe_lshift_func_int16_t_s_s((((*l_87) == l_73) | l_78.f3), 0)) == (0x39BF == ((((-3) >= (*p_50)) != (safe_rshift_func_int8_t_s_u((safe_rshift_func_uint8_t_u_u(l_96, 4)), (0U > ((&l_78 == p_51) > l_56.f2))))) == 4294967295U))) >= l_78.f0) >= 0xD248) <= 2U))
                { /* block id: 32 */
                    struct S3 **l_99 = &l_97;
                    int32_t l_102 = 0xB6B7D2F2;
                    (*p_50) = (l_96 > (-5));
                    (*l_99) = l_97;
                    (*p_50) = (0xAF1C4852 > ((safe_add_func_int32_t_s_s(0, (((((l_102 > l_103) & (((((safe_rshift_func_uint16_t_u_s((~((void*)0 == p_50)), 13)) <= l_78.f2) && 1) ^ (safe_rshift_func_uint16_t_u_u((((safe_mod_func_int8_t_s_s(((void*)0 == (**l_77)), l_103)) <= l_102) || 0x600665BE), 7))) > l_78.f3)) >= l_102) & l_80.f0) > 0x9878E731))) | l_103));
                }
                else
                { /* block id: 36 */
                    uint32_t l_134 = 0xE1EA8031;
                    struct S0 *l_139 = &l_78;
                    if ((safe_unary_minus_func_int32_t_s(0xA22099EB)))
                    { /* block id: 37 */
                        uint32_t l_128 = 4294967294U;
                        struct S2 *l_130 = &l_56;
                        struct S0 *l_137 = &l_80;
                        (*p_50) = (((safe_mod_func_int16_t_s_s((safe_sub_func_int32_t_s_s((((safe_sub_func_uint8_t_u_u((((0xA2CA & (((safe_sub_func_int16_t_s_s((safe_sub_func_int32_t_s_s((safe_sub_func_int32_t_s_s(l_98.f1, (*p_50))), (safe_add_func_uint8_t_u_u(l_128, (l_129 != l_130))))), ((l_131 == (void*)0) > (l_98.f4 >= 0x996BB96E)))) && l_103) != l_134)) ^ 0) == l_134), 5)) ^ l_133.f4) ^ l_56.f6), l_134)), 0x57B7)) != (-1)) == l_134);
                        l_135 = l_135;
                        (*l_137) = l_136;
                        (*l_137) = (*l_137);
                    }
                    else
                    { /* block id: 42 */
                        (*l_74) = &l_58;
                        /* statement id: 43 */
                        assert (l_75 == &l_58);
                    }
                    /* facts after branching */
                    assert (l_75 == &l_58 || l_75 == 0);
                    (*l_139) = l_138;
                    return l_138;
                }
                (*l_142) = l_140;
                /* statement id: 48 */
                assert (l_87 == &l_141);
                return l_78;
            }
        }
        else
        { /* block id: 51 */
            struct S0 *l_149 = (void*)0;
            int32_t *l_152 = &l_69;
            int32_t **l_170 = &l_135;
            int32_t ***l_169 = &l_170;
            struct S2 *l_218 = &l_56;
            struct S1 l_257 = {0,158};
            struct S1 * const l_256 = &l_257;
            if ((safe_lshift_func_int8_t_s_u(((safe_add_func_int32_t_s_s((safe_rshift_func_int16_t_s_s((((void*)0 == &l_57) > 2), 5)), (((void*)0 != l_149) <= ((safe_mod_func_uint32_t_u_u(((l_152 == &l_69) ^ 1U), (safe_unary_minus_func_int32_t_s((-9))))) == (*l_135))))) > l_98.f5), (*l_135))))
            { /* block id: 52 */
                int16_t l_164 = (-4);
                int32_t *l_193 = &l_69;
                struct S2 *l_217 = &l_56;
                struct S0 l_229 = {757,2,-77,3};
                if ((l_80.f2 <= l_80.f2))
                { /* block id: 53 */
                    int32_t l_188 = (-1);
                    if ((*p_50))
                    { /* block id: 54 */
                        int32_t **l_167 = (void*)0;
                        int32_t **l_168 = &l_152;
                        (*p_50) = (safe_sub_func_uint16_t_u_u(((((1U == (safe_add_func_uint16_t_u_u((((0x49C4 <= (*l_135)) || ((((safe_add_func_uint16_t_u_u((*l_152), ((safe_mod_func_uint32_t_u_u(0xDE8A0DB8, (((safe_div_func_uint8_t_u_u(l_164, 0xDA)) < (safe_rshift_func_uint8_t_u_s(((*l_135) || ((((void*)0 == (**l_77)) == 5) != l_164)), 2))) | l_164))) != l_98.f3))) & 253U) & l_164) < (*l_152))) >= (-1)), 0x25B3))) <= l_164) >= 0x557E69CC) < l_98.f6.f1), (*l_152)));
                        (*l_168) = p_50;
                        /* statement id: 56 */
                        //assert (l_152 == &l_53 || l_152 == &p_47 || l_152 == &l_869);
                        (*l_168) = p_50;
                    }
                    else
                    { /* block id: 58 */
                        const int32_t *l_174 = &l_69;
                        const int32_t **l_173 = &l_174;
                        const int32_t ***l_172 = &l_173;
                        const int32_t ****l_171 = &l_172;
                        struct S0 **l_175 = &l_149;
                        (*l_171) = l_169;
                        /* statement id: 59 */
                        assert (l_172 == &l_170);
                        (*l_175) = l_149;
                        (*l_170) = p_50;
                        /* statement id: 61 */
                        //assert (l_135 == &l_53 || l_135 == &p_47 || l_135 == &l_869);
                    }
                    /* facts after branching */
                    //assert (l_135 == &l_53 || l_135 == &l_58 || l_135 == &p_47 || l_135 == &l_869);
                    //assert (l_152 == &l_69 || l_152 == &l_53 || l_152 == &p_47 || l_152 == &l_869);
                    if (((((*l_152) < ((((((void*)0 == p_50) == (l_98.f2 > 9)) || (&p_51 == l_176)) | (safe_add_func_uint32_t_u_u((((safe_rshift_func_int16_t_s_s((safe_div_func_uint16_t_u_u(((l_98.f1 || (safe_mod_func_uint32_t_u_u((safe_lshift_func_uint8_t_u_s(0xE6, 0)), 0x3C3F1057))) || l_188), l_69)), 15)) == 0x13514C0A) || l_164), 0x0CA6FDA0))) < (*l_135))) != 0xDAD4C544) || (*l_135)))
                    { /* block id: 63 */
                        (*l_152) = ((l_69 & 0x5799) <= (*l_135));
                        if ((*p_50))
                            break;
                    }
                    else
                    { /* block id: 66 */
                        struct S2 **l_195 = (void*)0;
                        (*p_50) = (safe_add_func_uint16_t_u_u(((safe_sub_func_uint8_t_u_u(((l_164 && ((l_193 != p_50) >= ((l_188 && (((0U != (l_194 == &l_170)) || (l_195 == (void*)0)) | l_188)) & 1))) == (*l_135)), 7U)) <= (*p_50)), (*l_193)));
                    }
                }
                else
                { /* block id: 69 */
                    int32_t * const *l_200 = &l_193;
                    int32_t * const **l_199 = &l_200;
                    int32_t * const ***l_198 = &l_199;
                    int32_t ****l_202 = &l_169;
                    int32_t *****l_201 = &l_202;
                    for (l_96 = 5; (l_96 >= 29); l_96 = safe_add_func_uint32_t_u_u(l_96, 4))
                    { /* block id: 72 */
                        if (l_164)
                            goto lbl_81;
                        (*l_170) = (**l_169);
                        (*l_176) = p_51;
                        /* statement id: 75 */
                        //assert (l_177 == 0 || l_177 == &l_282 || l_177 == &l_872);
                    }
                    (*l_201) = l_198;
                    /* statement id: 77 */
                    assert (l_202 == &l_199);
                    (***l_199) = (0x5B | ((!(((safe_lshift_func_int8_t_s_s((safe_sub_func_uint16_t_u_u((safe_unary_minus_func_uint16_t_u((((((safe_sub_func_uint32_t_u_u(((*l_193) <= ((safe_mod_func_uint8_t_u_u(0xC8, (safe_add_func_int8_t_s_s((&p_50 == (void*)0), (safe_lshift_func_uint8_t_u_s(0U, (l_217 == l_218))))))) ^ (***l_169))), (*l_135))) == 0) && 0xD6A1B3C1) >= (**l_170)) != 9U))), 0xA644)), (*l_135))) | (**l_170)) < (*l_135))) > l_219));
                }
                /* facts after branching */
                //assert (l_135 == &l_53 || l_135 == &l_58 || l_135 == &p_47 || l_135 == &l_869);
                //assert (l_152 == &l_69 || l_152 == &l_53 || l_152 == &p_47 || l_152 == &l_869);
                (*l_152) = (safe_add_func_uint16_t_u_u((((-8) && 0xA7) | (4294967295U > ((((*l_152) != (((***l_169) <= (!((((1U != (safe_div_func_int16_t_s_s(((safe_add_func_uint16_t_u_u(((*l_193) ^ (*l_135)), (l_227 == (void*)0))) != (**l_170)), 0xF2DE))) == 1U) && (*l_193)) || 0xE99366D9))) < (**l_228))) < (*l_193)) > 0x4E))), (*l_193)));
                if ((*l_152))
                    break;
                return l_229;
            }
            else
            { /* block id: 83 */
                int32_t l_234 = 0x072D0B3D;
                struct S1 l_250 = {0,-122};
                struct S1 *l_249 = &l_250;
                if ((safe_div_func_int16_t_s_s(((*l_57) == (void*)0), (((safe_rshift_func_uint16_t_u_u((*l_152), 11)) <= (l_234 | (((**l_170) == (safe_rshift_func_int16_t_s_u(((~(safe_sub_func_int32_t_s_s((safe_sub_func_int16_t_s_s(0x5438, (***l_169))), (((((l_234 > ((**l_228) || 0x1A36)) != l_234) < (***l_169)) ^ (***l_169)) | (*l_152))))) || 0xCCA6), 4))) ^ (*l_135)))) & (*l_135)))))
                { /* block id: 84 */
                    struct S1 **l_248 = (void*)0;
                    for (l_219 = (-22); (l_219 != 28); l_219 = safe_add_func_int16_t_s_s(l_219, 1))
                    { /* block id: 87 */
                        int16_t l_247 = 0x8033;
                        if ((*p_50))
                            break;
                        (*p_50) = (safe_unary_minus_func_int32_t_s(((safe_mod_func_uint16_t_u_u((***l_169), l_247)) & l_247)));
                    }
                    if (l_78.f0)
                        goto lbl_81;
                    l_249 = (void*)0;
                    /* statement id: 92 */
                    assert (l_249 == 0);
                    p_50 = p_50;
                }
                else
                { /* block id: 94 */
                    int32_t ** const *l_252 = &l_228;
                    int32_t ** const **l_251 = &l_252;
                    (*l_251) = &l_228;
                }
                /* facts after branching */
                assert (l_249 == &l_250 || l_249 == 0);
                if ((**l_228))
                    break;
                for (l_234 = 21; (l_234 <= 9); l_234 = safe_sub_func_int32_t_s_s(l_234, 2))
                { /* block id: 100 */
                    const struct S1 *l_255 = &l_98.f6;
                    struct S0 l_259 = {1165,7,2,2};
                    (**l_77) = l_218;
                    (*p_50) = (-1);
                }
            }
            if (l_98.f1)
                goto lbl_81;
        }
        l_80 = l_80;
        (*l_277) = &l_140;
        /* statement id: 118 */
        assert (l_278 == &l_140);
    }
    /* facts after for loop */
    //assert (l_135 == &l_53 || l_135 == &l_58 || l_135 == &p_47 || l_135 == &l_869);
    return l_279;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 159
   depth: 1, occurrence: 15
   depth: 2, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 20
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 4
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 91
breakdown:
   indirect level: 0, occurrence: 16
   indirect level: 1, occurrence: 47
   indirect level: 2, occurrence: 10
   indirect level: 3, occurrence: 13
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 15
breakdown:
   indirect level: 0, occurrence: 15
XXX times a bitfields struct's address is taken: 58
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 51
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 81

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 169
   depth: 2, occurrence: 24
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 4
   depth: 20, occurrence: 4
   depth: 21, occurrence: 3
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2

XXX total number of pointers: 219

XXX times a variable address is taken: 206
XXX times a pointer is dereferenced on RHS: 134
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 24
   depth: 3, occurrence: 14
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 114
breakdown:
   depth: 1, occurrence: 106
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 17
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 385

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1026
   level: 2, occurrence: 153
   level: 3, occurrence: 77
   level: 4, occurrence: 6
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 111
XXX number of pointers point to scalars: 36
XXX number of pointers point to structs: 72
XXX percent of pointers has null in alias set: 24.2
XXX average alias set size: 1.18

XXX times a non-volatile is read: 926
XXX times a non-volatile is write: 295
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 7

XXX stmts: 148
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 15
   depth: 2, occurrence: 20
   depth: 3, occurrence: 28
   depth: 4, occurrence: 32
   depth: 5, occurrence: 21

XXX percentage a fresh-made variable is used: 19.8
XXX percentage an existing variable is used: 80.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

