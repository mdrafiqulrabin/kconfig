/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      837528809
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int8_t  f0;
   uint16_t  f1;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_26(void);
inline static int32_t  func_32(int32_t  p_33, int32_t  p_34, struct S0  p_35, uint32_t  p_36);
static struct S0  func_37(uint32_t  p_38);
static uint32_t  func_39(struct S0  p_40, int32_t  p_41);
inline static struct S0  func_42(struct S0  p_43, uint32_t  p_44, struct S0  p_45, struct S0  p_46, int32_t  p_47);
inline static uint32_t  func_49(uint32_t  p_50, int16_t  p_51);
inline static struct S0  func_72(int32_t  p_73, struct S0  p_74);
static int16_t  func_88(int32_t  p_89, int8_t  p_90, uint32_t  p_91);
static int32_t  func_94(uint16_t  p_95);
static int16_t  func_98(uint32_t  p_99, uint16_t  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_26(void)
{ /* block id: 36 */
    int32_t l_27 = 1;
    int32_t l_425 = 0x4E5CBC59;
    int32_t l_446 = 0x5D1EFB1E;
    int32_t l_447 = 0x4770F5A5;
    int32_t l_448 = 0;
    struct S0 l_456 = {6,65535U};
    int32_t l_468 = 8;
    uint32_t l_473 = 1U;
    int32_t l_500 = 8;
    struct S0 l_507 = {0xC3,0x98D5};
    uint32_t l_528 = 0x8323D87D;
    struct S0 l_553 = {0,0x91D0};
    int32_t l_614 = 0x67B3FC34;
    uint32_t l_624 = 4294967291U;
    uint32_t l_625 = 0x7BA222C0;
    for (l_27 = 0; (l_27 < 25); l_27 += 1)
    { /* block id: 39 */
        struct S0 l_48 = {5,1U};
        int32_t l_58 = 1;
        int32_t l_59 = 1;
        int32_t l_426 = 0x03F601E3;
        int32_t l_445 = 9;
        int8_t l_515 = 0xF5;
        int8_t l_538 = 0x82;
        int32_t l_539 = 0x613EF298;
        struct S0 l_554 = {0x88,0x62C6};
        uint32_t l_591 = 0x38E9425D;
        int32_t l_600 = 1;
        l_426 = (l_425 = (((uint16_t)(func_32((l_27 > (-6)), l_27, func_37((func_39(func_42(l_48, (l_59 ^= ((((0xDA37B187 & (l_58 = func_49((-(uint32_t)((uint16_t)(((int16_t)l_27 * (int16_t)l_27) > l_48.f1) >> (uint16_t)l_27)), l_48.f0))) & l_27) >= l_27) == 0xEF407293)), l_48, l_48, l_48.f1), l_27) < 1)), l_48.f1) , l_59) - (uint16_t)65535U) || 0x886A3D9C));
        if (l_58)
            continue;
        l_448 = (l_447 = ((l_446 = ((uint16_t)(l_48.f0 == l_426) << (uint16_t)((((int32_t)((int16_t)(l_27 , ((l_425 = ((uint32_t)(l_59 = 0U) % (uint32_t)((uint16_t)((func_94((l_445 = ((int16_t)l_425 * (int16_t)(((l_58 = ((int32_t)(l_48.f0 != (7 || l_48.f1)) + (int32_t)((int16_t)((int16_t)(l_48 , (-1)) << (int16_t)l_48.f0) << (int16_t)15))) == 0xD370320F) || l_426)))) , 1U) , l_426) * (uint16_t)l_27))) == 0xCB0DAA4B)) * (int16_t)0) - (int32_t)l_48.f1) > l_426) , 0))) & l_426));
        if (((uint16_t)(((((int16_t)(l_447 = (3 && (l_425 = (((int32_t)(((~(((func_39(l_456, ((int16_t)(l_48.f0 == (l_58 = l_445)) + (int16_t)l_446)) == (((int16_t)(l_448 = (0U ^ __builtin_parityll(((int32_t)l_48.f1 % (int32_t)((int16_t)(!__builtin_ffsll(((uint16_t)l_468 % (uint16_t)0x6B7F))) * (int16_t)l_426))))) >> (int16_t)8) > 65533U)) ^ l_59) || l_445)) <= 0x5A2E) == l_59) - (int32_t)l_445) , l_456.f1)))) * (int16_t)0x6C79) , l_456.f0) , l_456.f0) , l_456.f1) * (uint16_t)l_456.f1))
        { /* block id: 275 */
            struct S0 l_469 = {0x7E,65535U};
            struct S0 l_472 = {0xE0,0x9658};
            uint32_t l_516 = 0xF9B0AED3;
            int16_t l_518 = 0x55CD;
            int32_t l_524 = (-1);
            l_456 = func_42(l_48, __builtin_bswap64(l_58), l_48, (l_468 , l_469), (l_59 = (((((uint16_t)65532U << (uint16_t)(3U ^ (l_472 , l_48.f0))) == l_473) == l_468) >= l_469.f0)));
            if (l_426)
            { /* block id: 278 */
                uint16_t l_497 = 7U;
                int32_t l_501 = 3;
                int32_t l_502 = 0;
                for (l_468 = 19; (l_468 <= 16); l_468 -= 2)
                { /* block id: 281 */
                    int8_t l_485 = 0xC4;
                    int32_t l_486 = 0x06796A9C;
                    l_502 &= (((uint16_t)((uint16_t)((int32_t)((l_425 |= 0xDADC4BB3) != l_58) % (int32_t)((int32_t)(-(int16_t)__builtin_popcountl(((l_486 = l_485) >= ((uint16_t)(((uint16_t)l_485 >> (uint16_t)((int32_t)((uint32_t)(l_501 = (((l_448 |= (((l_445 > ((int16_t)(l_497 , ((l_58 ^ 5U) == ((uint16_t)l_500 << (uint16_t)7))) - (int16_t)l_497)) <= l_497) ^ l_59)) , l_497) == l_48.f0)) - (uint32_t)l_48.f1) + (int32_t)l_59)) , l_456.f0) >> (uint16_t)l_469.f1)))) + (int32_t)l_468)) % (uint16_t)l_446) >> (uint16_t)l_48.f1) , l_426);
                    l_502 ^= 1;
                }
                l_448 = __builtin_parity((l_472.f1 != l_447));
                l_501 = l_469.f0;
            }
            else
            { /* block id: 291 */
                int32_t l_509 = 0x19029A49;
                uint32_t l_514 = 1U;
                struct S0 l_517 = {-8,65535U};
                int32_t l_520 = (-1);
                struct S0 l_525 = {0,0xABFE};
                for (l_456.f1 = 0; (l_456.f1 < 32); l_456.f1 += 1)
                { /* block id: 294 */
                    uint32_t l_508 = 4294967290U;
                    struct S0 l_519 = {0x1C,0xB1D8};
                    l_520 &= ((0xF4D9 != l_472.f1) , ((uint16_t)((0x141677A4 | __builtin_parityl(((l_507 = l_456) , (l_508 | l_509)))) ^ ((uint16_t)func_32(func_32(((uint32_t)((func_88(l_508, (l_59 = func_98(((l_469.f1 , l_514) , l_514), l_515)), l_469.f0) , l_472.f1) != l_516) % (uint32_t)l_445), l_509, l_517, l_508), l_518, l_519, l_516) + (uint16_t)l_519.f1)) << (uint16_t)l_508));
                    if (l_519.f0)
                        continue;
                }
                if (l_472.f0)
                { /* block id: 300 */
                    uint16_t l_521 = 0xF571;
                    l_521 ^= l_516;
                }
                else
                { /* block id: 302 */
                    for (l_48.f1 = 0; (l_48.f1 == 27); l_48.f1 += 1)
                    { /* block id: 305 */
                        l_524 = 0xA5DD3484;
                    }
                }
                l_525 = (l_456 = l_517);
            }
        }
        else
        { /* block id: 312 */
            int16_t l_537 = 0x560C;
            int32_t l_552 = 1;
            struct S0 l_556 = {0x60,0xD07A};
            int32_t l_573 = 0x441CF829;
            l_59 = ((uint16_t)(l_538 &= ((l_58 = l_528) || (((int16_t)((int16_t)((-7) || l_456.f0) * (int16_t)(l_59 , __builtin_bswap32(l_445))) >> (int16_t)9) , ((((l_58 ^ (l_447 != (~((uint32_t)(!(((l_447 < l_473) | l_537) && l_537)) + (uint32_t)0U)))) || l_456.f1) & l_507.f0) != l_59)))) * (uint16_t)l_456.f1);
            if ((l_539 > ((int16_t)(((l_445 |= l_48.f1) | func_32(l_468, l_537, l_48, (l_59 = ((((int16_t)(((uint32_t)((l_537 < (((int16_t)(l_425 != ((uint32_t)(func_94(func_98(l_473, (l_552 = ((int16_t)l_48.f0 * (int16_t)65530U)))) < l_500) - (uint32_t)0)) << (int16_t)9) , l_58)) | 4294967292U) % (uint32_t)0x98855015) == 0xD6A7) * (int16_t)l_537) == l_537) , l_507.f0)))) >= l_537) * (int16_t)l_500)))
            { /* block id: 319 */
                int16_t l_555 = 0;
                struct S0 l_557 = {-9,0x1BA6};
                struct S0 l_558 = {0x80,0x4D41};
                struct S0 l_559 = {2,0U};
                l_554 = (l_48 , func_42(func_42(l_553, l_537, l_554, l_507, l_553.f1), ((l_48 = (l_558 = (l_557 = (l_555 , l_556)))) , l_537), l_559, l_554, l_539));
                if (l_447)
                    continue;
                l_447 = l_552;
            }
            else
            { /* block id: 326 */
                int32_t l_563 = (-9);
                int32_t l_603 = (-2);
                uint32_t l_609 = 8U;
                for (l_539 = 0; (l_539 <= 14); l_539 += 9)
                { /* block id: 329 */
                    uint16_t l_568 = 1U;
                    int32_t l_599 = 0x75833DC3;
                    if ((!(l_573 = ((l_563 && ((int32_t)(l_556.f1 < l_447) % (int32_t)((int16_t)(__builtin_ctzll(l_456.f0) ^ ((l_568 && (!(((uint32_t)l_568 + (uint32_t)0x13BC2A8D) , (!l_426)))) >= l_556.f1)) >> (int16_t)l_552))) != 0U))))
                    { /* block id: 331 */
                        int32_t l_577 = 0x1C7C1C80;
                        int8_t l_589 = 0xA3;
                        int32_t l_590 = 0x43E61D54;
                        l_447 = __builtin_ffsl((((l_591 = (l_568 , (l_59 = (((int16_t)((l_577 = ((!l_577) < ((l_468 && l_552) ^ (l_448 > ((int16_t)(((int16_t)(l_573 = (-(int32_t)(l_590 = (((int32_t)((((int16_t)(l_568 & l_573) % (int16_t)((int16_t)0xE68C * (int16_t)__builtin_popcountll(l_500))) && l_58) || (-1)) - (int32_t)l_589) >= l_568)))) % (int16_t)l_563) && l_573) - (int16_t)l_515))))) & l_568) - (int16_t)0xA7EB) , l_556.f0)))) | l_563) , (-4)));
                        l_573 = ((!func_98(l_515, l_573)) ^ ((int16_t)l_58 >> (int16_t)((l_556 , ((uint16_t)(((((uint32_t)(l_599 ^= (((l_554 , l_446) > ((l_447 ^= (l_577 = l_589)) | ((func_37(l_445) , l_591) || l_563))) ^ (-1))) + (uint32_t)l_563) == l_426) | 0x218C) > l_568) * (uint16_t)l_528)) , l_456.f0)));
                    }
                    else
                    { /* block id: 342 */
                        if (l_537)
                            break;
                    }
                }
                l_554 = func_42(l_556, ((((func_32((l_600 , l_556.f1), ((uint16_t)l_554.f0 << (uint16_t)(l_573 = (__builtin_parityll(l_447) && (l_603 ^= 0x9730)))), l_48, ((~(__builtin_clzll(((uint16_t)((uint16_t)l_563 << (uint16_t)l_609) * (uint16_t)l_425)) & (-4))) && 0x9A68)) ^ l_58) > l_425) & l_58) | l_537), l_554, l_556, l_539);
            }
        }
    }
    l_425 &= ((((uint16_t)((((l_507.f1 && (((int16_t)l_500 >> (int16_t)13) & l_614)) | ((uint16_t)0x324C << (uint16_t)((int32_t)l_447 + (int32_t)(-(int16_t)(l_448 & ((l_507.f1 != l_553.f0) < ((uint16_t)(l_625 ^= ((int16_t)l_624 * (int16_t)l_447)) * (uint16_t)l_27))))))) , (-10)) & l_500) - (uint16_t)l_507.f0) > l_446) >= l_456.f0);
    return l_553;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_32(int32_t  p_33, int32_t  p_34, struct S0  p_35, uint32_t  p_36)
{ /* block id: 175 */
    uint32_t l_294 = 1U;
    int32_t l_301 = 9;
    struct S0 l_343 = {0x6A,65527U};
    int32_t l_355 = 1;
    struct S0 l_424 = {0x55,1U};
    if ((func_49(l_294, func_94((((uint16_t)((uint16_t)((uint32_t)((l_301 = p_35.f0) < (func_98(l_294, p_35.f0) <= (p_36 = 0xE68FA146))) + (uint32_t)((int16_t)(0x1E9DDE0F && ((p_33 = (p_35.f1 > p_34)) ^ l_294)) % (int16_t)p_35.f1)) << (uint16_t)l_294) - (uint16_t)l_294) ^ 4294967293U))) || p_35.f0))
    { /* block id: 179 */
        int32_t l_312 = 1;
        int32_t l_335 = (-1);
        struct S0 l_336 = {0xF0,1U};
        int32_t l_341 = (-2);
        int32_t l_354 = 0x9524366A;
        int32_t l_369 = 2;
        p_33 ^= l_294;
        for (p_35.f1 = 13; (p_35.f1 < 1); p_35.f1 -= 7)
        { /* block id: 183 */
            int32_t l_334 = 0xF051BE4F;
            for (p_34 = 0; (p_34 > (-13)); p_34 -= 1)
            { /* block id: 186 */
                int8_t l_311 = 3;
                int32_t l_325 = 1;
                for (l_294 = 1; (l_294 > 20); l_294 += 1)
                { /* block id: 189 */
                    uint32_t l_310 = 0xC7B452A9;
                    int32_t l_326 = 0x2567EC09;
                    int32_t l_327 = 0x44213E9D;
                    l_327 = (l_310 & ((l_326 &= ((__builtin_ctz(l_311) , (l_312 = l_311)) == ((int32_t)((uint16_t)(((int32_t)p_34 % (int32_t)p_35.f1) < (l_325 = ((uint16_t)(((int16_t)(-1) << (int16_t)2) , p_35.f0) >> (uint16_t)((uint32_t)0xFF39B088 % (uint32_t)p_33)))) * (uint16_t)7U) % (int32_t)(-2)))) <= p_33));
                }
                l_335 = ((uint16_t)((((((uint16_t)l_312 * (uint16_t)(func_39(p_35, ((p_36 = func_94(l_325)) | l_311)) <= (l_312 , (((uint32_t)l_334 + (uint32_t)(p_33 = (65532U || 0x9731))) , l_334)))) != l_311) ^ p_34) > p_35.f0) || l_294) >> (uint16_t)p_35.f0);
            }
        }
        l_336 = func_42(func_72(p_36, l_336), (l_312 >= (l_335 | ((((0x7BCEBDF1 || __builtin_parityll((l_301 ^= (((int16_t)7 << (int16_t)5) <= ((int16_t)l_312 - (int16_t)((((0xBC08 <= 0xD5FB) | p_33) , l_341) , p_34)))))) , l_312) ^ 0x584E) || l_301))), l_336, p_35, p_35.f0);
        if ((p_33 = ((-(uint16_t)func_39(l_343, p_34)) & ((((((int32_t)1 + (int32_t)l_336.f0) > p_35.f1) <= (((((l_301 = (((((((l_336.f0 ^ (l_335 & ((uint32_t)((int16_t)(-(int16_t)((l_341 = p_33) && 0x4077CB0A)) << (int16_t)15) % (uint32_t)p_35.f1))) && 0x7C11C388) > p_34) ^ l_336.f0) , 0x864EF0DA) ^ p_35.f0) > 0U)) == l_312) || l_294) || (-2)) > l_343.f0)) != l_343.f1) , l_336.f1))))
        { /* block id: 205 */
            int32_t l_351 = 0;
            int32_t l_364 = 6;
            l_351 = (p_33 = l_335);
            p_35 = func_37((l_369 &= (l_354 == ((l_355 & ((uint16_t)(p_35.f1 = l_354) >> (uint16_t)13)) >= ((int16_t)p_33 - (int16_t)(((int16_t)(l_351 > ((((uint16_t)((l_335 = p_33) && ((l_364 = l_336.f1) || (((func_49((((int16_t)(3U <= (((uint16_t)(__builtin_ffsll(l_364) && l_355) >> (uint16_t)p_34) <= p_34)) - (int16_t)1) <= 1U), l_312) | l_341) || l_364) == 65535U))) % (uint16_t)l_336.f1) >= p_36) | 0xE361)) - (int16_t)p_35.f0) & p_36))))));
            return p_33;
        }
        else
        { /* block id: 214 */
            p_35 = p_35;
            return p_36;
        }
    }
    else
    { /* block id: 218 */
        uint16_t l_378 = 7U;
        int32_t l_380 = (-1);
        uint16_t l_405 = 0x3593;
        struct S0 l_415 = {8,1U};
        int32_t l_423 = (-1);
        for (l_355 = 0; (l_355 < 23); l_355 += 1)
        { /* block id: 221 */
            struct S0 l_379 = {0x2D,0xE98F};
            int32_t l_387 = 1;
            if (((l_355 , (((uint32_t)(((int16_t)((int16_t)(l_380 = (l_378 , func_39(l_379, (p_35.f1 & l_379.f0)))) >> (int16_t)6) - (int16_t)func_49(((((((uint16_t)(p_35.f1 <= (p_35.f0 & p_36)) >> (uint16_t)3) , p_35.f1) > p_34) > 8U) < l_343.f1), p_35.f0)) , 0x532B37C9) - (uint32_t)0xDFC8C10D) || (-2))) , l_380))
            { /* block id: 223 */
                uint32_t l_383 = 0U;
                int32_t l_396 = 0x33B617C2;
                int32_t l_414 = (-4);
                struct S0 l_416 = {0xED,1U};
                if ((l_379.f0 == l_383))
                { /* block id: 224 */
                    uint16_t l_386 = 0xCE0E;
                    int32_t l_395 = 0x51AA0ECB;
                    l_396 = (p_33 = (p_35.f1 ^ ((int16_t)(((l_387 = ((p_35.f1 ^ l_386) ^ l_386)) ^ (((~((int16_t)p_34 >> (int16_t)2)) , l_378) , l_386)) | (func_72(((int16_t)((l_301 &= (((uint32_t)p_33 % (uint32_t)((l_395 = (p_33 <= p_34)) , 0xA2B23383)) && l_395)) == l_386) >> (int16_t)p_35.f1), p_35) , l_294)) - (int16_t)l_343.f1)));
                }
                else
                { /* block id: 230 */
                    uint16_t l_402 = 0x01F2;
                    int32_t l_404 = 0x40C70856;
                    for (l_383 = 0; (l_383 >= 38); l_383 += 1)
                    { /* block id: 233 */
                        uint32_t l_403 = 0U;
                        p_33 = (-7);
                        l_403 |= (((!0U) > (l_387 = ((uint16_t)l_402 * (uint16_t)(__builtin_ctz(l_343.f0) || (5U < (l_387 >= func_88(__builtin_bswap32(p_35.f0), l_379.f1, p_34))))))) && p_36);
                        if (p_36)
                            break;
                        l_404 ^= 0x63A1735C;
                    }
                    if (l_396)
                        break;
                    p_35 = func_72(((l_343.f1 != (l_405 || ((uint16_t)(p_34 == ((uint32_t)(-(uint32_t)l_355) - (uint32_t)((uint32_t)(l_343.f0 | (-(uint16_t)(l_380 = (l_414 >= l_343.f0)))) - (uint32_t)1))) * (uint16_t)(((((l_301 = (l_404 |= ((l_402 | l_378) && p_34))) ^ l_379.f1) & 8U) , l_405) == p_36)))) && p_36), l_379);
                    p_35 = p_35;
                }
                p_35 = l_415;
                l_416 = p_35;
                p_33 = (l_387 = ((int16_t)(__builtin_ia32_crc32qi(l_387, func_88(((p_35.f1 |= ((((int16_t)p_34 << (int16_t)((uint16_t)p_35.f0 + (uint16_t)(-9))) && 0xD1B0B395) || 0U)) | p_34), l_423, (p_36 ^= p_35.f0))) , 0x2015) << (int16_t)l_415.f0));
            }
            else
            { /* block id: 253 */
                l_387 ^= l_415.f1;
                l_343 = p_35;
            }
        }
        l_424 = p_35;
    }
    return l_343.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_37(uint32_t  p_38)
{ /* block id: 173 */
    struct S0 l_293 = {0x30,0x602D};
    return l_293;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_39(struct S0  p_40, int32_t  p_41)
{ /* block id: 160 */
    int8_t l_285 = (-4);
    int32_t l_286 = 0xCBF020C0;
    int32_t l_287 = 0x29996229;
    int32_t l_290 = 0x2E67D206;
    l_286 |= (p_41 |= ((uint16_t)l_285 - (uint16_t)1));
    l_290 &= (((p_40.f0 ^ (((l_286 = l_285) & (l_287 = l_285)) | p_40.f1)) , ((int16_t)l_287 >> (int16_t)l_287)) >= 0x8F24E667);
    for (l_290 = (-4); (l_290 <= 24); l_290 += 1)
    { /* block id: 168 */
        l_286 = p_40.f0;
    }
    l_287 = p_41;
    return l_287;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_42(struct S0  p_43, uint32_t  p_44, struct S0  p_45, struct S0  p_46, int32_t  p_47)
{ /* block id: 44 */
    int8_t l_62 = 1;
    struct S0 l_76 = {0xFE,0x1DAB};
    int32_t l_190 = 0xF45F4F03;
    int32_t l_191 = 0x3CA2B8C2;
    struct S0 l_209 = {0x36,0x0D05};
    int32_t l_231 = 0;
    int32_t l_276 = (-10);
    if (((int16_t)(l_62 > p_45.f1) >> (int16_t)(!p_46.f0)))
    { /* block id: 45 */
        int32_t l_71 = 6;
        uint16_t l_75 = 65534U;
        struct S0 l_83 = {0,65527U};
        int32_t l_198 = 8;
        int32_t l_199 = 0x6648E8C8;
        int32_t l_210 = 8;
        int32_t l_211 = (-4);
        for (l_62 = (-28); (l_62 < (-30)); l_62 -= 1)
        { /* block id: 48 */
            int32_t l_68 = (-2);
            struct S0 l_82 = {0x50,0xF573};
            int32_t l_148 = 8;
            int8_t l_149 = (-8);
            l_71 |= ((int16_t)(p_43.f0 == (p_43.f1 = (l_62 != ((((l_68 |= __builtin_ctzll(l_62)) > 0) >= ((int32_t)(l_62 , p_46.f0) + (int32_t)2U)) , 0U)))) << (int16_t)3);
            l_83 = (l_82 = (p_46 = func_72(l_75, l_76)));
            l_191 = (l_190 ^= ((((0x6993 > ((int32_t)((uint32_t)p_46.f1 - (uint32_t)((-5) ^ (func_88(((uint32_t)0U % (uint32_t)__builtin_clz(l_71)), p_46.f0, (((((l_148 &= func_94(func_49((p_45.f1 , 3U), l_82.f1))) >= l_149) & 2U) > p_43.f0) , 0x5A479C51)) | l_83.f0))) % (int32_t)l_71)) & l_83.f0) & 0x734C) , p_46.f1));
            if (l_190)
            { /* block id: 113 */
                l_190 |= p_47;
                l_191 = (!0x47ABF92C);
                l_148 ^= p_45.f0;
            }
            else
            { /* block id: 117 */
                int32_t l_195 = 0x5631F006;
                l_198 = ((l_190 = ((p_46.f1 & l_83.f0) == ((uint32_t)l_75 % (uint32_t)__builtin_ctzl((l_195 == (l_149 | l_191)))))) && (((int32_t)(-4) - (int32_t)(l_191 = p_45.f1)) == l_195));
            }
        }
        l_199 = __builtin_popcount((p_46.f1 , (l_198 &= func_49(p_46.f1, l_83.f0))));
        l_211 ^= func_88((func_94((((int32_t)(((int16_t)l_190 * (int16_t)p_45.f0) , (l_62 , (l_210 ^= ((l_198 || ((int16_t)((((uint16_t)(l_191 = (p_43.f0 <= (l_199 = (p_47 , (!(l_209 , 1U)))))) >> (uint16_t)__builtin_parityll(__builtin_clzl(((l_190 = p_46.f1) & 0xBDE70362)))) ^ l_75) & 0xD1AE7548) + (int16_t)0xCB3E)) , p_46.f0)))) - (int32_t)l_209.f0) , l_75)) <= 0x4C05), p_43.f1, p_46.f1);
        l_190 = 4;
    }
    else
    { /* block id: 131 */
        int16_t l_214 = 1;
        int32_t l_232 = 6;
        int32_t l_272 = 0xE4475012;
        int32_t l_273 = 0x85CD5396;
        int32_t l_274 = 0x6F920074;
        int32_t l_275 = (-1);
        for (l_190 = 0; (l_190 == 15); l_190 += 4)
        { /* block id: 134 */
            int16_t l_230 = 0xB7F5;
            int32_t l_233 = (-10);
            l_191 = (-2);
            l_233 ^= (((__builtin_ctzll(l_214) >= (((((l_191 &= ((uint16_t)(!((__builtin_popcount(p_44) < func_94((l_214 >= (((uint16_t)p_43.f1 >> (uint16_t)(((uint16_t)p_47 % (uint16_t)(((int16_t)(((int16_t)((int16_t)(((uint16_t)(l_232 = ((2U == (p_45.f1 = __builtin_bswap64((l_231 = (l_230 | l_214))))) >= 0x8245084B)) >> (uint16_t)l_230) & 0xD047) % (int16_t)l_214) >> (int16_t)14) > 0xBBAF) * (int16_t)l_214) & l_214)) < p_43.f1)) , p_46.f1)))) | l_214)) >> (uint16_t)14)) >= l_190) ^ l_214) || 0xCBA9) != 4294967295U)) <= l_230) != p_45.f0);
            l_233 = ((((((p_47 = ((int16_t)p_44 >> (int16_t)((l_191 = (((((int16_t)p_46.f1 % (int16_t)((!__builtin_ffsl(p_45.f0)) , l_209.f1)) < (((int32_t)((int32_t)((uint16_t)((p_43.f1 , ((uint16_t)(((((int16_t)(((uint16_t)((uint32_t)(l_232 && ((l_232 = 0x3232) & 0x826F)) - (uint32_t)l_214) >> (uint16_t)4) , l_230) * (int16_t)p_44) <= l_233) >= l_76.f0) >= 1U) << (uint16_t)10)) | 0x2315) % (uint16_t)p_43.f0) + (int32_t)l_214) - (int32_t)p_47) && l_214)) && p_46.f0) >= l_214)) ^ 0xF5735543))) , l_209.f1) < l_230) ^ 0x5E07166B) && 0x0E2BE1C1) , 0x10D71351);
        }
        l_276 ^= (~((uint16_t)(p_45.f1 = ((uint16_t)(((l_191 = func_94(p_47)) < (((p_43.f1 = 0x8E81) < ((int32_t)l_232 - (int32_t)((uint16_t)65535U * (uint16_t)((int16_t)((l_275 = (((~(l_274 = (!(((p_44 = ((uint16_t)((int16_t)((l_214 <= (((int16_t)(l_190 ^= p_43.f0) << (int16_t)((l_273 = (l_272 = p_46.f1)) , (l_273 || l_272))) ^ l_76.f0)) | l_76.f1) << (int16_t)p_44) >> (uint16_t)1)) <= 0xF08DB160) , 0xDA3869AD)))) | l_62) && 0x449ACB2F)) == 0xB768) >> (int16_t)6)))) || p_46.f0)) == 0xA01E1D9C) % (uint16_t)p_45.f1)) >> (uint16_t)3));
    }
    l_190 = (4U ^ func_98(((int32_t)((uint32_t)p_44 + (uint32_t)p_43.f1) + (int32_t)((int32_t)(p_47 < (l_276 = l_76.f0)) % (int32_t)0x9A834AAA)), l_209.f0));
    return l_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_49(uint32_t  p_50, int16_t  p_51)
{ /* block id: 40 */
    uint32_t l_57 = 0xEED050B7;
    return l_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_72(int32_t  p_73, struct S0  p_74)
{ /* block id: 52 */
    int16_t l_77 = 6;
    int32_t l_78 = 0x0931BC1F;
    struct S0 l_79 = {-1,0x1BD0};
    struct S0 l_80 = {0,1U};
    struct S0 l_81 = {0x27,65535U};
    l_78 |= l_77;
    l_79 = (l_80 = l_79);
    return l_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_88(int32_t  p_89, int8_t  p_90, uint32_t  p_91)
{ /* block id: 82 */
    int32_t l_154 = 0xC4191E15;
    int32_t l_156 = 0x421A5172;
    int32_t l_162 = (-1);
    int32_t l_163 = 0x0F790E20;
    int32_t l_164 = 0xD8A3620C;
    struct S0 l_187 = {0,0xA227};
    l_163 = ((int16_t)((l_162 = ((l_156 = ((int16_t)(l_154 = p_89) * (int16_t)(-(int16_t)p_90))) && ((int16_t)(p_90 & 0) - (int16_t)(((uint16_t)p_90 << (uint16_t)7) || (l_156 = (~p_89)))))) != ((l_163 | (l_164 = p_91)) , l_163)) >> (int16_t)l_163);
    if ((((int16_t)p_91 - (int16_t)((-(int32_t)p_89) != (((uint16_t)((int16_t)(-(uint32_t)p_90) * (int16_t)(!(l_154 = ((uint16_t)(p_89 , (p_89 && l_163)) << (uint16_t)10)))) >> (uint16_t)13) ^ ((p_89 <= l_164) , ((uint16_t)((int16_t)l_164 << (int16_t)12) << (uint16_t)12))))) > 65529U))
    { /* block id: 90 */
        uint32_t l_180 = 6U;
        int32_t l_181 = 0;
        struct S0 l_188 = {0x6C,0x88A1};
        if ((l_180 = (l_154 |= p_91)))
        { /* block id: 93 */
            l_181 = p_91;
        }
        else
        { /* block id: 95 */
            int32_t l_182 = 2;
            l_182 = 0xADDF3CDB;
            for (l_156 = 0; (l_156 == (-6)); l_156 -= 9)
            { /* block id: 99 */
                uint16_t l_185 = 0x9C6F;
                l_185 &= (-7);
                l_164 = (~__builtin_ctzl(__builtin_ctzll(p_91)));
                l_182 = l_156;
            }
            l_188 = l_187;
        }
    }
    else
    { /* block id: 106 */
        struct S0 l_189 = {-5,0xAA0F};
        l_187 = l_189;
    }
    l_156 ^= p_91;
    return p_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_94(uint16_t  p_95)
{ /* block id: 60 */
    uint32_t l_111 = 4294967288U;
    int32_t l_123 = 0x8317453A;
    int32_t l_124 = 0x7097499C;
    int32_t l_125 = 0x6DB868C9;
    int32_t l_126 = 0x9B44AAF2;
    uint32_t l_127 = 0x4DF11966;
    int32_t l_128 = 1;
    int32_t l_147 = 0;
    l_147 = ((int16_t)func_98(p_95, (((int16_t)(l_128 = (((uint16_t)p_95 % (uint16_t)((int16_t)((int16_t)p_95 + (int16_t)((((uint32_t)(l_111 > (l_111 & ((int16_t)(((int32_t)((uint32_t)(((uint32_t)(l_126 &= ((p_95 < (l_111 , (((int16_t)((l_125 = (l_111 , (l_124 = (((l_123 = (~l_111)) | p_95) == 0xE063)))) & l_111) * (int16_t)0x1F8E) , l_111))) < p_95)) - (uint32_t)0x62928133) < l_127) + (uint32_t)(-7)) % (int32_t)4294967293U) & 1) % (int16_t)l_127))) - (uint32_t)0xFA353696) , l_124) || p_95)) * (int16_t)p_95)) || p_95)) * (int16_t)l_127) , p_95)) << (int16_t)p_95);
    l_128 ^= l_125;
    return l_128;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_98(uint32_t  p_99, uint16_t  p_100)
{ /* block id: 66 */
    struct S0 l_129 = {-1,9U};
    int32_t l_141 = (-8);
    if (p_100)
    { /* block id: 67 */
        uint32_t l_145 = 4294967295U;
        int32_t l_146 = 0;
        l_129 = l_129;
        l_146 ^= ((((((uint16_t)65533U * (uint16_t)((uint32_t)l_129.f1 + (uint32_t)0xA690E31D)) == (p_100 = ((uint32_t)1U - (uint32_t)((uint16_t)((uint32_t)(~(l_141 = p_99)) % (uint32_t)(1 & __builtin_ctz(p_99))) << (uint16_t)3)))) != ((!(((uint16_t)(p_99 > 0x335D) + (uint16_t)65529U) != l_145)) || 0)) == 8) > l_145);
        l_141 = (l_129.f0 , l_129.f0);
        return l_129.f0;
    }
    else
    { /* block id: 74 */
        l_141 ^= 0x704B5258;
        return p_99;
    }
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 130
   depth: 1, occurrence: 32
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 129
   depth: 2, occurrence: 19
   depth: 3, occurrence: 5
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 2
   depth: 28, occurrence: 3
   depth: 30, occurrence: 4
   depth: 31, occurrence: 1
   depth: 33, occurrence: 2
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 589
XXX times a non-volatile is write: 206
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 120
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 25
   depth: 2, occurrence: 22
   depth: 3, occurrence: 26
   depth: 4, occurrence: 13
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 20.8
XXX percentage an existing variable is used: 79.2
********************* end of statistics **********************/

