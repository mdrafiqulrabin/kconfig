/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      4000289290
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   int32_t  f1;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_30(void);
inline static int32_t * func_31(int32_t * p_32, int16_t  p_33, float  p_34, const int32_t  p_35, int32_t  p_36);
inline static struct S0 * func_53(uint16_t  p_54, int32_t * p_55, struct S0 * p_56, struct S0 * const  p_57, uint16_t  p_58);
static uint32_t  func_59(const int32_t * p_60, int32_t * p_61, struct S0 * p_62, uint32_t  p_63);
inline static int32_t  func_68(int32_t * p_69, struct S0  p_70, float  p_71, int32_t  p_72, uint32_t  p_73);
static struct S0  func_77(int32_t * p_78, float  p_79, struct S0  p_80, struct S0 * p_81);
inline static uint32_t  func_91(const struct S0 * p_92, struct S0 * p_93, const struct S0  p_94);
static int32_t  func_99(const int32_t * p_100, int32_t  p_101, uint32_t  p_102, int32_t * p_103);
inline static int16_t  func_120(int16_t  p_121, int32_t * p_122, const struct S0 * p_123);
inline static const struct S0 * func_126(float  p_127, uint32_t  p_128, uint16_t  p_129);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_30(void)
{ /* block id: 36 */
    int32_t *l_37 = (void*)0;
    int32_t l_38 = 0;
    int32_t l_40 = 0x0016488A;
    struct S0 l_570 = {0x419B1AD9,0xCC62D627};
    l_37 = func_31(l_37, l_38, (+(((l_38 >= l_40) != ((float)__builtin_clzll(l_40) - (float)(((float)(-0x1.8p-1) + (float)0x0.8p-1) <= 0x1.2p-1))) >= 0x4.5DBC2Ap+89)), l_40, l_40);
    return l_570;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_31(int32_t * p_32, int16_t  p_33, float  p_34, const int32_t  p_35, int32_t  p_36)
{ /* block id: 37 */
    uint32_t l_45 = 0xBEAC3EFC;
    int16_t l_51 = 4;
    int32_t l_52 = 0x14A12652;
    struct S0 l_74 = {0x1B3FE78D,1};
    struct S0 *l_377 = &l_74;
    int32_t *l_380 = &l_74.f1;
    int32_t *l_381 = &l_52;
    int32_t *l_385 = &l_52;
    int32_t *l_387 = (void*)0;
    float l_394 = 0xB.94DFDEp-39;
    float * const l_393 = &l_394;
    float * const *l_392 = &l_393;
    struct S0 l_437 = {0x3D41CA14,0x5DA535EA};
    int32_t l_458 = 1;
    float *****l_461 = (void*)0;
    int32_t *l_545 = &l_52;
    float l_559 = (-0x5.Dp+1);
    int32_t *l_560 = &l_52;
    int32_t *l_561 = &l_52;
    int32_t *l_562 = &l_437.f1;
    int32_t *l_563 = &l_74.f1;
    int32_t *l_564 = &l_437.f1;
    int32_t *l_565 = &l_437.f1;
    int32_t *l_566 = &l_74.f1;
    int32_t *l_567 = &l_74.f1;
    int32_t *l_568 = &l_52;
    int32_t *l_569 = (void*)0;
    if (l_45)
    { /* block id: 38 */
        int32_t l_46 = (-1);
        const int32_t *l_64 = &l_52;
        int32_t *l_65 = &l_52;
        struct S0 l_67 = {4294967288U,1};
        struct S0 *l_66 = &l_67;
        l_52 = (((__builtin_clzll(l_46) ^ __builtin_ctzl(((int16_t)(-1) + (int16_t)p_36))) <= (65535U <= p_33)) | (0 == ((((((uint16_t)p_36 + (uint16_t)p_33) != l_45) != l_51) & 4294967295U) >= p_33)));
        l_377 = func_53((func_59(l_64, l_65, l_66, (__builtin_clzll(__builtin_bswap64(l_51)) & func_68(&l_52, l_74, ((float)((((0x2.7p+1 >= p_33) == 0x6.C49993p+39) >= p_35) == l_74.f1) + (float)(-0x1.Fp+1)), (*l_65), l_74.f0))) & 0xCC0CA2B1), &l_52, &l_74, &l_67, p_33);
    }
    else
    { /* block id: 218 */
        struct S0 l_378 = {0x98BA18F7,0x100EF0E0};
        int32_t *l_379 = &l_52;
        int32_t *l_382 = &l_378.f1;
        int32_t *l_383 = &l_378.f1;
        int32_t *l_384 = &l_74.f1;
        int32_t *l_386 = &l_74.f1;
        l_378 = (*l_377);
        return l_387;
        /* statement id: 220 */
        //assert (func_31_rv == 0);
    }
    if (p_35)
    { /* block id: 222 */
        float l_391 = 0x2.A4E1F7p+95;
        float *l_390 = &l_391;
        float **l_389 = &l_390;
        float ***l_398 = &l_389;
        float ****l_397 = &l_398;
        int32_t l_399 = 0x6E561EA1;
        const struct S0 *l_411 = &l_74;
        struct S0 *l_418 = (void*)0;
        uint32_t l_423 = 0U;
        int32_t **l_468 = &l_380;
        const int32_t ****l_485 = (void*)0;
        int32_t *l_547 = &l_399;
        int32_t *l_548 = &l_399;
        int32_t *l_550 = &l_52;
        int32_t *l_552 = &l_437.f1;
        int32_t *l_553 = &l_74.f1;
        (*l_390) = (+(l_389 == l_392));
    }
    else
    { /* block id: 313 */
        struct S0 l_556 = {4294967289U,0};
        (*l_377) = l_556;
        (*l_377) = (*l_377);
    }
    p_32 = &p_36;
    /* statement id: 317 */
    assert (p_32 == &p_36);
    (*l_393) = ((p_34 <= ((*l_545) > p_36)) < ((float)__builtin_popcountl(func_91(&l_437, func_53((((-1) == __builtin_popcount(p_35)) < p_33), &l_52, &l_437, &l_74, p_36), (*l_377))) + (float)(*l_385)));
    return l_569;
    /* statement id: 319 */
    //assert (func_31_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_53(uint16_t  p_54, int32_t * p_55, struct S0 * p_56, struct S0 * const  p_57, uint16_t  p_58)
{ /* block id: 210 */
    struct S0 l_376 = {0U,0x1A656AFC};
    struct S0 *l_375 = &l_376;
    for (p_54 = (-23); (p_54 < 52); p_54 += 5)
    { /* block id: 213 */
        return p_56;
        /* statement id: 214 */
        //assert (func_53_rv == &l_74 || func_53_rv == 0 || func_53_rv == &l_437);
    }
    return p_56;
    /* statement id: 216 */
    //assert (func_53_rv == &l_74 || func_53_rv == 0 || func_53_rv == &l_437);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_59(const int32_t * p_60, int32_t * p_61, struct S0 * p_62, uint32_t  p_63)
{ /* block id: 141 */
    int32_t *l_279 = (void*)0;
    int32_t **l_278 = &l_279;
    float **l_314 = (void*)0;
    float ***l_313 = &l_314;
    int32_t l_342 = (-8);
    int32_t * const l_366 = &l_342;
    struct S0 l_372 = {0x449FA879,0xB5DBAF20};
    struct S0 *l_371 = &l_372;
    (*l_278) = (void*)0;
    for (p_63 = (-7); (p_63 != 17); p_63 += 6)
    { /* block id: 145 */
        const int16_t l_288 = 0x5A55;
        int32_t *l_308 = (void*)0;
        int32_t l_317 = 0x6FD7EBAF;
        const int32_t *l_336 = &l_317;
    }
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_68(int32_t * p_69, struct S0  p_70, float  p_71, int32_t  p_72, uint32_t  p_73)
{ /* block id: 40 */
    int32_t l_83 = 0x686461D9;
    int32_t *l_82 = &l_83;
    const struct S0 l_96 = {4294967295U,0};
    const struct S0 *l_95 = &l_96;
    struct S0 l_98 = {4294967295U,-4};
    struct S0 *l_97 = &l_98;
    (*l_97) = func_77(l_82, ((float)(p_73 <= ((0x1.7p+1 >= (!__builtin_ffsl(((int32_t)(&p_72 == &p_72) + (int32_t)(((uint32_t)((void*)0 != &p_70) % (uint32_t)func_91(l_95, l_97, (*l_97))) & p_72))))) != (*l_82))) - (float)p_70.f1), (*l_95), l_97);
    return (*p_69);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_77(int32_t * p_78, float  p_79, struct S0  p_80, struct S0 * p_81)
{ /* block id: 136 */
    float l_275 = 0x2.B43686p-55;
    float *l_276 = &l_275;
    struct S0 l_277 = {4294967286U,1};
    (*l_276) = ((float)l_275 - (float)0xC.DE4584p+21);
    return l_277;
}


/* ------------------------------------------ */
/* 
 * reads : l_67
 * writes: l_67
 */
inline static uint32_t  func_91(const struct S0 * p_92, struct S0 * p_93, const struct S0  p_94)
{ /* block id: 41 */
    const int32_t l_105 = (-1);
    const int32_t *l_104 = &l_105;
    int32_t l_110 = 0xC93CBC91;
    int32_t *l_109 = &l_110;
    uint32_t l_204 = 6U;
    int32_t l_224 = 8;
    const int16_t l_269 = 9;
    struct S0 l_271 = {4294967295U,1};
    if (func_99(l_104, (*l_104), (-(uint32_t)((uint16_t)((-1) < (-10)) << (uint16_t)0)), l_109))
    { /* block id: 78 */
        int32_t l_215 = 1;
        struct S0 l_241 = {0U,0x4D47DAE8};
        const struct S0 *l_240 = &l_241;
        if (((*l_104) < l_204))
        { /* block id: 79 */
            const struct S0 *l_214 = (void*)0;
            int32_t l_223 = (-6);
            int32_t *l_237 = &l_215;
lbl_209:
            (*p_93) = (*p_92);
            for (l_204 = (-16); (l_204 <= 21); l_204++)
            { /* block id: 83 */
                int32_t *l_207 = (void*)0;
                int32_t **l_208 = &l_207;
                (*l_208) = l_207;
                if ((*l_109))
                    continue;
                if (p_94.f1)
                    break;
                if (p_94.f1)
                    goto lbl_209;
            }
            if (p_94.f0)
            { /* block id: 89 */
                struct S0 l_212 = {0x2FDDFC4C,0xE220DBA6};
                struct S0 *l_211 = &l_212;
                struct S0 ** const l_210 = &l_211;
                int32_t *l_213 = (void*)0;
                (*l_109) = (((l_210 != &p_93) > (__builtin_parityll(func_120(p_94.f0, l_213, l_214)) | (((p_94.f1 || ((void*)0 != l_213)) != p_94.f1) >= 0xE9FA))) <= p_94.f0);
            }
            else
            { /* block id: 91 */
                uint16_t l_226 = 0xDAE4;
                int32_t l_227 = (-2);
                int32_t *l_233 = &l_227;
                const struct S0 *l_242 = &l_241;
                uint32_t l_267 = 0x445193B0;
                (*l_109) = (-1);
                (*l_109) = l_215;
                for (l_204 = 0; (l_204 < 37); ++l_204)
                { /* block id: 96 */
                    int32_t l_222 = 0x2DB5C162;
                    int32_t **l_234 = &l_233;
                    for (l_110 = 18; (l_110 > 29); l_110 += 5)
                    { /* block id: 99 */
                        l_224 = ((int32_t)l_222 - (int32_t)(0xFF2B4294 >= l_223));
                    }
                }
                for (l_224 = 0; (l_224 > (-20)); l_224 -= 9)
                { /* block id: 116 */
                    float l_243 = 0xF.9ED955p+21;
                    int32_t *l_250 = &l_241.f1;
                    l_237 = &l_227;
                    /* statement id: 117 */
                    assert (l_237 == &l_227);
                    if ((((int16_t)(func_120((*l_233), &l_215, l_240) && (((p_94.f0 | 0xE3CF7B5A) && 0x1E9D) && 2)) + (int16_t)func_120(func_99(&l_227, (*l_237), p_94.f0, &l_110), &l_227, l_242)) == (*l_237)))
                    { /* block id: 118 */
                        float *l_244 = &l_243;
                        (*l_244) = p_94.f0;
                    }
                    else
                    { /* block id: 120 */
                        int32_t * const *l_246 = &l_237;
                        int32_t * const **l_245 = &l_246;
                        struct S0 **l_247 = (void*)0;
                        struct S0 *l_249 = (void*)0;
                        struct S0 **l_248 = &l_249;
                        const int32_t **l_251 = (void*)0;
                        int32_t **l_252 = &l_233;
                        int32_t l_266 = 0x551DDD8C;
                        int32_t l_268 = 0x2030A444;
                        l_245 = l_245;
                        (*l_248) = func_126(p_94.f0, (***l_245), (**l_246));
                        (*l_252) = l_250;
                        /* statement id: 123 */
                        assert (l_233 == &l_241.f1);
                        (*l_109) = __builtin_popcountll((p_94.f1 == (((((((((uint16_t)((int16_t)(((int16_t)(((*l_109) != (((int16_t)((*l_104) != ((((uint16_t)((uint16_t)(0U && (*l_104)) >> (uint16_t)5) >> (uint16_t)(+l_266)) == ((l_267 <= ((&l_241 != &p_94) <= p_94.f1)) | (*l_109))) || (*l_104))) - (int16_t)(*l_237)) < (*l_237))) <= (*l_233)) + (int16_t)l_241.f0) && l_268) << (int16_t)10) % (uint16_t)1U) < p_94.f0) > l_269) < 0x2153) != p_94.f1) < p_94.f0) >= (**l_246)) == p_94.f0)));
                    }
                }
                /* facts after for loop */
                assert (l_233 == &l_241.f1 || l_233 == &l_227);
                assert (l_237 == &l_227 || l_237 == &l_215);
            }
            /* facts after branching */
            //assert (l_237 == dangling || l_237 == &l_215);
        }
        else
        { /* block id: 128 */
            const int32_t **l_270 = &l_104;
            (*l_270) = &l_224;
            /* statement id: 129 */
            assert (l_104 == &l_224);
            (*p_93) = l_271;
        }
        /* facts after branching */
        assert (l_104 == &l_224 || l_104 == &l_105);
        return p_94.f0;
    }
    else
    { /* block id: 133 */
        float l_272 = (-0x5.4p-1);
        return p_94.f1;
    }
}


/* ------------------------------------------ */
/* 
 * reads : l_52
 * writes: l_52
 */
static int32_t  func_99(const int32_t * p_100, int32_t  p_101, uint32_t  p_102, int32_t * p_103)
{ /* block id: 42 */
    int32_t l_125 = (-1);
    int32_t *l_124 = &l_125;
    float l_190 = 0x1.5p+1;
    struct S0 l_201 = {4294967291U,0x865CE0FB};
    struct S0 *l_200 = &l_201;
    struct S0 **l_199 = &l_200;
    float *l_202 = (void*)0;
    float *l_203 = &l_190;
    (*p_103) = ((uint16_t)(((int16_t)((((int32_t)((~(((int16_t)func_120(p_101, l_124, func_126(p_102, ((int16_t)(&l_125 != (void*)0) << (int16_t)((int32_t)((*l_124) != p_101) - (int32_t)0x50A9706E)), p_101)) + (int16_t)(*l_124)) || p_102)) >= (*l_124)) + (int32_t)(*p_100)) || 0xA4C7F9B1) >= p_102) << (int16_t)8) <= p_101) << (uint16_t)p_101);
    (*l_203) = ((float)((float)p_102 - (float)(0xF.FA26FBp+49 < p_101)) - (float)(((float)(((p_101 <= p_101) < (*l_124)) != (*l_124)) + (float)(p_101 == (((float)((void*)0 == l_199) + (float)(*l_124)) > (*l_124)))) >= (*l_124)));
    return (*p_100);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_120(int16_t  p_121, int32_t * p_122, const struct S0 * p_123)
{ /* block id: 72 */
    int32_t **l_186 = (void*)0;
    int32_t l_189 = 1;
    int32_t *l_188 = &l_189;
    int32_t **l_187 = &l_188;
    (*l_187) = p_122;
    /* statement id: 73 */
    //assert (l_188 == &l_125 || l_188 == 0 || l_188 == &l_215 || l_188 == &l_227 || l_188 == &p_36);
    return p_121;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S0 * func_126(float  p_127, uint32_t  p_128, uint16_t  p_129)
{ /* block id: 43 */
    int32_t l_148 = 0xE92B0D2C;
    int32_t *l_147 = &l_148;
    int32_t **l_146 = &l_147;
    struct S0 l_161 = {0xF8DE9EF3,0x4FBCE554};
    const struct S0 *l_160 = &l_161;
    const struct S0 *l_164 = &l_161;
    const struct S0 *l_185 = (void*)0;
    if (p_128)
    { /* block id: 44 */
        int32_t l_149 = 0x407C5320;
        int32_t **l_156 = &l_147;
        const struct S0 *l_162 = &l_161;
        const struct S0 *l_163 = &l_161;
        const struct S0 *l_165 = &l_161;
        const struct S0 *l_166 = &l_161;
        const struct S0 *l_167 = &l_161;
        const struct S0 *l_168 = (void*)0;
        for (p_128 = 0; (p_128 < 57); ++p_128)
        { /* block id: 47 */
            const struct S0 *l_159 = (void*)0;
            for (p_129 = (-7); (p_129 < 52); p_129 += 8)
            { /* block id: 50 */
                const int32_t l_140 = (-10);
                const int32_t *l_139 = &l_140;
                const int32_t **l_138 = &l_139;
                (*l_138) = (void*)0;
                /* statement id: 51 */
                assert (l_139 == 0);
                if (p_129)
                    continue;
                if (((uint16_t)((int32_t)p_128 % (int32_t)p_128) + (uint16_t)(~__builtin_popcount((((void*)0 == l_146) && l_149)))))
                { /* block id: 53 */
                    float l_158 = 0xA.011814p+18;
                    float *l_157 = &l_158;
                    (*l_138) = (*l_138);
                    (*l_138) = (void*)0;
                    (*l_157) = ((float)(0xF.7A37A7p-86 == ((float)(**l_146) + (float)l_149)) - (float)(((float)((&l_147 == l_156) > ((p_129 > p_127) != p_128)) + (float)p_129) < p_128));
                    (**l_156) = p_129;
                }
                else
                { /* block id: 58 */
                    if (p_128)
                        break;
                }
            }
            return l_159;
            /* statement id: 62 */
            //assert (func_126_rv == 0);
        }
        return l_168;
        /* statement id: 64 */
        //assert (func_126_rv == 0);
    }
    else
    { /* block id: 65 */
        const int32_t *l_169 = &l_161.f1;
        int32_t **l_170 = &l_147;
        float *l_180 = (void*)0;
        float l_182 = 0x0.6p+1;
        float *l_181 = &l_182;
        struct S0 *l_184 = &l_161;
        struct S0 **l_183 = &l_184;
        (*l_170) = l_169;
        /* statement id: 66 */
        assert (l_147 == &l_161.f1);
        (*l_181) = ((float)((float)0xD.B71361p+30 + (float)(((float)(+(-0x6.4p-1)) + (float)(((float)(l_147 != l_147) + (float)(p_129 <= p_128)) < __builtin_ffsl(p_128))) > (**l_146))) - (float)0xF.BF6EB6p-27);
        (*l_183) = &l_161;
    }
    /* facts after branching */
    assert (l_147 == &l_161.f1);
    p_127 = 0x6.4p+1;
    return l_185;
    /* statement id: 71 */
    //assert (func_126_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 163
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 187

XXX times a variable address is taken: 192
XXX times a pointer is dereferenced on RHS: 117
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 81
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 6
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 364

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 936
   level: 2, occurrence: 66
   level: 3, occurrence: 28
XXX number of pointers point to pointers: 57
XXX number of pointers point to scalars: 89
XXX number of pointers point to structs: 41
XXX percent of pointers has null in alias set: 28.3
XXX average alias set size: 1.42

XXX times a non-volatile is read: 632
XXX times a non-volatile is write: 207
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 74
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 16
   depth: 2, occurrence: 7
   depth: 3, occurrence: 12
   depth: 4, occurrence: 8
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 13
XXX percentage an existing variable is used: 87
********************* end of statistics **********************/

