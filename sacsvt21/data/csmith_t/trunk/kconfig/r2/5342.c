/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1674984626
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 7;
   signed : 0;
   unsigned f1 : 2;
   unsigned f2 : 6;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int64_t  func_28(void);
inline static int32_t * const  func_29(float  p_30, const int64_t  p_31, int32_t * p_32, int64_t  p_33, float  p_34);
inline static int32_t * func_36(int32_t  p_37, uint16_t  p_38, int64_t  p_39, uint16_t  p_40);
inline static uint16_t  func_41(int32_t  p_42, int32_t  p_43);
static const int32_t * func_44(float  p_45, uint8_t  p_46, int32_t  p_47, const int32_t * p_48, int32_t * const  p_49);
inline static float  func_57(struct S0  p_58, uint64_t  p_59, int32_t * p_60, int32_t * p_61);
static struct S0  func_62(uint32_t  p_63);
static int32_t ** func_65(int32_t ** const  p_66);
static int32_t * func_74(int32_t  p_75, int32_t * p_76, struct S0 * p_77, uint32_t  p_78);
static int32_t * func_79(int32_t * p_80, int32_t ** p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_28(void)
{ /* block id: 36 */
    uint8_t l_35 = 0x6CL;
    uint64_t l_771 = 3UL;
    int32_t **l_785 = (void*)0;
    int32_t **l_786 = (void*)0;
    int32_t l_789 = (-8L);
    int32_t *l_788 = &l_789;
    int32_t **l_787 = &l_788;
    uint64_t l_790 = 0x113D3151A9C891C0LL;
    (*l_787) = func_29(l_35, l_35, func_36(l_35, func_41(l_35, l_35), l_35, l_771), l_771, l_771);
    /* statement id: 703 */
    assert (l_788 == 0);
    return l_790;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_29(float  p_30, const int64_t  p_31, int32_t * p_32, int64_t  p_33, float  p_34)
{ /* block id: 700 */
    int32_t l_782 = 0x645BE5F9L;
    int32_t *l_781 = &l_782;
    int32_t **l_783 = (void*)0;
    int32_t **l_784 = &l_781;
    (*l_784) = l_781;
    return p_32;
    /* statement id: 702 */
    //assert (func_29_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_36(int32_t  p_37, uint16_t  p_38, int64_t  p_39, uint16_t  p_40)
{ /* block id: 697 */
    struct S0 l_774 = {6,0,7};
    struct S0 *l_773 = &l_774;
    struct S0 **l_772 = &l_773;
    int32_t l_776 = 0xBEAC6DC5L;
    int32_t *l_775 = &l_776;
    int32_t *l_777 = &l_776;
    int32_t *l_778 = &l_776;
    int32_t *l_779 = &l_776;
    int32_t *l_780 = (void*)0;
    (*l_775) = (l_772 != (void*)0);
    return l_780;
    /* statement id: 699 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_41(int32_t  p_42, int32_t  p_43)
{ /* block id: 37 */
    int64_t l_52 = 0xF9A4D91F06E85FCBLL;
    int32_t l_231 = 1L;
    int32_t *l_230 = &l_231;
    const int32_t *l_767 = &l_231;
    l_767 = func_44(((float)(l_52 >= ((float)((float)func_57(func_62(p_43), (l_52 == (l_52 <= l_52)), l_230, &l_231) - (float)0xD.D5F52Ep+26) / (float)p_42)) + (float)l_52), l_52, p_42, l_230, l_230);
    /* statement id: 689 */
    assert (l_767 == 0);
    for (l_231 = (-4); (l_231 <= (-7)); --l_231)
    { /* block id: 692 */
        int32_t **l_770 = &l_230;
        (*l_770) = &l_231;
        return p_43;
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_44(float  p_45, uint8_t  p_46, int32_t  p_47, const int32_t * p_48, int32_t * const  p_49)
{ /* block id: 685 */
    float l_760 = 0x7.Cp-1;
    float *l_759 = &l_760;
    int32_t l_763 = 0L;
    int32_t *l_762 = &l_763;
    int32_t **l_761 = &l_762;
    const int32_t *l_764 = &l_763;
    const int32_t *l_765 = &l_763;
    const int32_t *l_766 = (void*)0;
    (*l_759) = p_47;
    (*l_761) = (void*)0;
    /* statement id: 687 */
    assert (l_762 == 0);
    return l_766;
    /* statement id: 688 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_57(struct S0  p_58, uint64_t  p_59, int32_t * p_60, int32_t * p_61)
{ /* block id: 148 */
    int32_t l_237 = (-1L);
    int32_t *l_236 = &l_237;
    int32_t **l_235 = &l_236;
    int32_t ***l_234 = &l_235;
    struct S0 l_252 = {9,1,0};
    struct S0 *l_251 = &l_252;
    struct S0 **l_250 = &l_251;
    uint16_t l_278 = 65531UL;
    uint32_t l_295 = 0xD5AEE717L;
    float **l_332 = (void*)0;
    float ***l_331 = &l_332;
    float ** const *l_346 = &l_332;
    float ** const **l_345 = &l_346;
    float ** const ***l_344 = &l_345;
    int32_t l_370 = 1L;
    uint8_t l_379 = 0xADL;
    int16_t l_454 = (-1L);
    int32_t l_538 = 0x4F6269C1L;
    int64_t l_642 = 0x328BAF5F59F8796BLL;
    const int32_t l_651 = 0xE075C8E1L;
    const int32_t l_681 = 4L;
    struct S0 *l_733 = &l_252;
    uint64_t l_758 = 0x16F5BABD9F51E27FLL;
    if ((((uint64_t)(((void*)0 != l_234) || (((int64_t)(*l_236) - (int64_t)((int16_t)((uint64_t)(**l_235) % (uint64_t)((uint16_t)((uint16_t)(***l_234) - (uint16_t)(***l_234)) << (uint16_t)6)) >> (int16_t)13)) != (*l_236))) - (uint64_t)((uint32_t)(l_250 != (void*)0) / (uint32_t)0x1DF46D5BL)) & (***l_234)))
    { /* block id: 149 */
        int32_t *l_269 = &l_237;
        struct S0 *l_279 = &l_252;
        int32_t ***l_285 = &l_235;
        const int32_t l_311 = (-9L);
        int32_t ****l_359 = &l_285;
        int32_t *****l_358 = &l_359;
        uint32_t l_413 = 0x91F25ED7L;
        struct S0 *l_464 = &l_252;
    }
    else
    { /* block id: 333 */
        uint32_t l_466 = 0x16C64053L;
        int32_t l_496 = 0xAB82B68CL;
        int32_t *** const l_504 = &l_235;
lbl_497:
        (***l_234) = (**l_235);
        if ((***l_234))
        { /* block id: 335 */
            int32_t l_474 = 0x6C7A0417L;
            int32_t *l_482 = &l_370;
            float *l_508 = (void*)0;
            float **l_507 = &l_508;
            l_466 = (*p_60);
            if ((***l_234))
            { /* block id: 337 */
                float l_479 = 0x1.Ap-1;
                for (l_454 = 0; (l_454 == (-3)); --l_454)
                { /* block id: 340 */
                    int16_t l_471 = 0x31B3L;
                    struct S0 *l_483 = (void*)0;
                    (**l_234) = p_61;
                    /* statement id: 341 */
                    //assert (l_236 == &l_231);
                    if ((*l_236))
                        break;
                    (*l_235) = func_74((l_466 < ((int16_t)(((p_58.f0 < l_471) < ((int16_t)l_474 - (int16_t)((uint16_t)6UL / (uint16_t)((((p_59 ^ l_471) < (((uint64_t)p_58.f0 + (uint64_t)(*l_236)) <= 0xBD93B574L)) >= 4294967293UL) || l_471)))) && (*l_236)) % (int16_t)p_58.f0)), l_482, l_483, l_471);
                    /* statement id: 343 */
                    assert (l_236 == &l_370);
                }
            }
            else
            { /* block id: 345 */
                struct S0 l_484 = {2,0,1};
                l_484 = func_62((**l_235));
            }
            (*l_236) = p_58.f2;
            if ((p_58.f2 < (*l_482)))
            { /* block id: 349 */
                const struct S0 l_485 = {3,1,6};
                int32_t *l_489 = &l_237;
lbl_488:
                (*l_251) = l_485;
                for (l_466 = (-8); (l_466 == 22); l_466 += 9)
                { /* block id: 353 */
                    if (l_466)
                        goto lbl_488;
                    (**l_234) = l_489;
                    /* statement id: 355 */
                    assert (l_236 == &l_237);
                    for (l_454 = (-24); (l_454 > (-16)); ++l_454)
                    { /* block id: 358 */
                        return p_58.f0;
                    }
                    for (l_278 = (-4); (l_278 != 52); l_278 += 4)
                    { /* block id: 363 */
                        return p_58.f0;
                    }
                }
                (***l_234) = (*p_60);
                for (l_379 = 0; (l_379 == 47); l_379 += 7)
                { /* block id: 370 */
                    if ((*l_489))
                    { /* block id: 371 */
                        (*l_331) = (*l_346);
                    }
                    else
                    { /* block id: 373 */
                        (**l_250) = p_58;
                        (*l_482) = l_466;
                    }
                    if ((*p_60))
                        break;
                    l_496 = p_59;
                    if (l_474)
                        goto lbl_497;
                }
            }
            else
            { /* block id: 381 */
                int32_t l_500 = 0xA34BAC0EL;
                int32_t l_506 = 0x04724DE4L;
                (*l_482) = ((((int16_t)(-5L) << (int16_t)(0L | l_466)) | l_500) < p_58.f1);
                if (((***l_234) != l_496))
                { /* block id: 383 */
                    const int32_t *l_503 = &l_370;
                    const int32_t ** const l_502 = &l_503;
                    const int32_t ** const *l_501 = &l_502;
                    struct S0 l_505 = {3,0,5};
                    if ((__builtin_popcountll(p_58.f0) && (l_501 == l_504)))
                    { /* block id: 384 */
                        (**l_250) = l_505;
                    }
                    else
                    { /* block id: 386 */
                        (***l_234) = (*p_61);
                        (*l_251) = p_58;
                        l_506 = p_59;
                        (*l_502) = (void*)0;
                        /* statement id: 390 */
                        assert (l_503 == 0);
                    }
                    /* facts after branching */
                    assert (l_503 == 0 || l_503 == &l_370);
                    (*l_331) = l_507;
                    /* statement id: 392 */
                    assert (l_332 == &l_508);
                    (*l_482) = 0x033A2BE1L;
                }
                else
                { /* block id: 394 */
lbl_513:
                    (*l_331) = &l_508;
                    /* statement id: 395 */
                    assert (l_332 == &l_508);
                }
                /* facts after branching */
                assert (l_332 == &l_508);
                if (((uint16_t)0xF1A8L >> (uint16_t)2))
                { /* block id: 397 */
                    return p_58.f0;
                }
                else
                { /* block id: 399 */
                    for (l_237 = (-27); (l_237 >= (-14)); l_237 += 3)
                    { /* block id: 402 */
                        (*p_61) = (*p_60);
                        (**l_250) = p_58;
                    }
                }
                if (l_466)
                    goto lbl_513;
            }
            /* facts after branching */
            assert (l_332 == &l_508 || l_332 == 0);
        }
        else
        { /* block id: 409 */
            uint64_t l_516 = 0xFBEB689C319CCB7DLL;
            (***l_234) = (l_516 && ((((((uint16_t)p_59 >> (uint16_t)((***l_234) == l_516)) ^ (***l_504)) == (p_58.f0 == 0x1C34D0A55AF744EFLL)) < (-(int32_t)((int64_t)((((*p_61) != p_59) <= 0xF7015397L) & (*p_60)) - (int64_t)(*l_236)))) != 0UL));
            if ((*l_236))
            { /* block id: 411 */
                int32_t l_522 = 0x96E72EE3L;
                (*l_236) = (*p_60);
                return l_522;
            }
            else
            { /* block id: 414 */
                (**l_344) = (void*)0;
                /* statement id: 415 */
                assert (l_346 == 0);
            }
            /* facts after branching */
            assert (l_346 == 0);
            (***l_234) = (2L >= ((int64_t)(!((int16_t)(p_58.f2 ^ p_58.f1) << (int16_t)4)) - (int64_t)(((int32_t)((uint16_t)(l_516 && ((int16_t)((void*)0 != &l_504) << (int16_t)8)) << (uint16_t)3) / (int32_t)(~0xC9B0EAF6L)) <= p_59)));
            (**l_235) = (*p_61);
        }
        /* facts after branching */
        //assert (l_332 == dangling || l_332 == 0);
        assert (l_346 == 0 || l_346 == &l_332);
    }
    /* facts after branching */
    //assert (l_236 == &l_231 || l_236 == &l_370 || l_236 == &l_237);
    //assert (l_332 == dangling || l_332 == 0);
    assert (l_346 == 0 || l_346 == &l_332);
    (*p_61) = 9L;
    if ((*p_60))
    { /* block id: 422 */
        int32_t *l_535 = (void*)0;
        float l_540 = 0x8.1E5884p-86;
        float *l_539 = &l_540;
        struct S0 ****l_542 = (void*)0;
        struct S0 *****l_541 = &l_542;
        (*l_235) = (**l_234);
        (*l_539) = __builtin_ia32_crc32qi(((int64_t)l_538 % (int64_t)2L), p_58.f2);
        (*l_541) = (void*)0;
        (*l_235) = l_539;
        /* statement id: 426 */
        assert (l_236 == &l_540);
    }
    else
    { /* block id: 427 */
        int32_t *l_543 = &l_370;
        float l_584 = 0x2.4C886Dp+79;
        float *l_583 = &l_584;
        float **l_582 = &l_583;
        struct S0 *l_585 = &l_252;
        struct S0 *l_618 = &l_252;
        const uint16_t l_652 = 0xD747L;
        int32_t ****l_688 = (void*)0;
        int32_t *****l_687 = &l_688;
        const float *****l_702 = (void*)0;
        const struct S0 *l_710 = &l_252;
        const struct S0 **l_709 = &l_710;
        const struct S0 ***l_708 = &l_709;
        const struct S0 ****l_707 = &l_708;
        int32_t *l_738 = &l_237;
        int32_t *l_757 = &l_237;
        (**l_234) = l_543;
        /* statement id: 428 */
        assert (l_236 == &l_370);
        if ((*p_61))
        { /* block id: 429 */
            int64_t l_565 = 0x2D40B24835735E19LL;
            int32_t *l_571 = &l_370;
            struct S0 *l_589 = &l_252;
            int64_t l_616 = 0xB19405C3C7A0B05DLL;
            if ((*p_61))
            { /* block id: 430 */
                uint16_t l_561 = 0x91B3L;
                int32_t l_562 = 1L;
                int32_t **l_566 = &l_543;
                for (l_237 = 0; (l_237 != (-9)); l_237 -= 9)
                { /* block id: 433 */
                    float l_556 = 0x3.46AF86p-55;
                    int32_t l_568 = 5L;
                    for (p_59 = 0; (p_59 > 19); ++p_59)
                    { /* block id: 436 */
                        l_562 = (7UL == (((int32_t)(*p_60) - (int32_t)(__builtin_ctzll(((((int64_t)(((((uint16_t)((int16_t)(&l_345 != (void*)0) - (int16_t)p_58.f2) << (uint16_t)12) == p_58.f0) < ((***l_234) & ((((int16_t)((~(+p_58.f1)) < p_58.f2) % (int16_t)p_58.f2) > p_58.f2) > 1L))) > 0x16B4FDA9L) - (int64_t)(-4L)) ^ 4294967295UL) ^ l_561)) >= 0xBEA343ECL)) <= 0xC95AL));
                        (**l_235) = (*l_543);
                    }
                    for (l_278 = 0; (l_278 <= 29); l_278++)
                    { /* block id: 442 */
                        (*p_60) = l_565;
                    }
                    return l_568;
                }
                for (p_59 = 21; (p_59 < 44); ++p_59)
                { /* block id: 452 */
                    (**l_234) = l_571;
                    (*l_543) = __builtin_parityl(p_59);
                    for (l_538 = 0; (l_538 == 7); l_538++)
                    { /* block id: 457 */
                        return p_58.f0;
                    }
                }
            }
            else
            { /* block id: 461 */
                const uint16_t l_578 = 1UL;
                struct S0 *l_579 = &l_252;
                int32_t * const l_580 = &l_370;
                int32_t **l_581 = &l_236;
                (**l_234) = func_74(((p_59 != (*l_543)) < ((int32_t)(*p_61) - (int32_t)((*l_571) != ((uint16_t)l_578 << (uint16_t)p_58.f1)))), p_60, l_579, p_58.f0);
                /* statement id: 462 */
                //assert (l_236 == &l_231);
                (*l_581) = l_580;
                /* statement id: 463 */
                assert (l_236 == &l_370);
                if ((l_582 == &l_583))
                { /* block id: 464 */
                    (*l_581) = p_60;
                    /* statement id: 465 */
                    //assert (l_236 == &l_231);
                    (*l_250) = l_585;
                    (*l_580) = (*l_571);
                }
                else
                { /* block id: 468 */
                    uint64_t l_588 = 0x7DBF13F1C3035D42LL;
                    struct S0 *l_596 = &l_252;
                    (**l_250) = (*l_579);
                    if (((int16_t)((**l_235) < ((*l_543) ^ (**l_235))) + (int16_t)(l_588 < l_588)))
                    { /* block id: 470 */
                        uint32_t l_592 = 0x82501026L;
                        int32_t **l_594 = &l_571;
                        (**l_234) = func_74((p_59 < (-6L)), (**l_234), l_589, ((int32_t)l_592 - (int32_t)(+(l_594 == (void*)0))));
                    }
                    else
                    { /* block id: 472 */
                        int32_t *l_595 = &l_370;
                        p_58 = p_58;
                        (**l_234) = (**l_234);
                        p_60 = func_74((((p_59 <= (p_58.f2 ^ p_58.f0)) >= ((**l_235) || (*l_543))) > (*l_571)), l_595, l_596, (*l_595));
                        /* statement id: 475 */
                        assert (p_60 == &l_370);
                    }
                    /* facts after branching */
                    //assert (p_60 == &l_370 || p_60 == &l_231);
                    return l_588;
                }
                /* facts after branching */
                //assert (l_236 == &l_231);
            }
            /* facts after branching */
            //assert (l_236 == &l_231 || l_236 == &l_370);
            (*l_585) = (*l_585);
            if (((*l_582) != p_60))
            { /* block id: 481 */
                uint32_t l_599 = 0xB8406B6DL;
                struct S0 ***l_600 = &l_250;
                if ((((uint32_t)l_599 + (uint32_t)(((*l_543) && 1UL) | ((**l_235) || (*l_236)))) == __builtin_ctz(l_599)))
                { /* block id: 482 */
                    if ((*p_61))
                    { /* block id: 483 */
                        (**l_235) = (p_58.f1 == p_58.f2);
                    }
                    else
                    { /* block id: 485 */
                        return l_599;
                    }
                    (*l_251) = func_62(p_58.f1);
                    return p_58.f2;
                }
                else
                { /* block id: 490 */
                    struct S0 ****l_601 = &l_600;
                    int32_t l_602 = 0xD6E719C7L;
                    if ((**l_235))
                    { /* block id: 491 */
                        (**l_235) = ((**l_235) < (*l_543));
                        (*l_235) = func_79(p_60, &l_571);
                        /* statement id: 493 */
                        assert (l_236 == &l_370 || l_236 == 0);
                        //assert (l_571 == dangling || l_571 == 0 || l_571 == &l_370);
                    }
                    else
                    { /* block id: 494 */
                        (*l_585) = p_58;
                    }
                    /* facts after branching */
                    //assert (l_236 == &l_231 || l_236 == &l_370 || l_236 == 0);
                    //assert (l_571 == dangling || l_571 == 0 || l_571 == &l_370);
                    (*l_601) = l_600;
                    (**l_582) = __builtin_clz(l_602);
                }
                /* facts after branching */
                //assert (l_236 == &l_231 || l_236 == &l_370 || l_236 == 0);
                //assert (l_571 == dangling || l_571 == 0 || l_571 == &l_370);
                (**l_234) = func_74((*l_543), p_60, &p_58, p_58.f2);
                /* statement id: 500 */
                //assert (l_236 == &l_231);
                (*l_585) = func_62((~p_58.f1));
                (*l_589) = (*l_585);
            }
            else
            { /* block id: 503 */
                (**l_582) = __builtin_popcountll(((p_58.f2 != (((int32_t)((((-1L) > ((int64_t)(__builtin_ctzl((&l_583 == (void*)0)) <= ((uint16_t)(((int32_t)((int16_t)((uint16_t)(*l_571) << (uint16_t)1) + (int16_t)p_58.f1) - (int32_t)p_58.f1) == (*l_571)) + (uint16_t)l_616)) + (int64_t)(**l_235))) < p_59) && 4294967295UL) % (int32_t)p_59) & (*l_571))) || p_58.f0));
                (*l_250) = (*l_250);
            }
            /* facts after branching */
            //assert (l_571 == dangling || l_571 == 0 || l_571 == &l_370);
        }
        else
        { /* block id: 507 */
            int32_t **l_617 = &l_543;
            struct S0 **l_624 = &l_251;
            if ((l_617 == &p_61))
            { /* block id: 508 */
                (*l_250) = l_618;
                (*p_60) = (*p_61);
                return p_58.f2;
            }
            else
            { /* block id: 512 */
                uint32_t l_635 = 0UL;
                for (p_59 = (-21); (p_59 > 10); p_59 += 4)
                { /* block id: 515 */
                    const int32_t l_621 = (-7L);
                    if (l_621)
                        break;
                    (**l_250) = func_62(p_59);
                }
                for (l_237 = (-20); (l_237 != (-20)); l_237 += 6)
                { /* block id: 521 */
                    uint64_t l_634 = 0xB4957681923A35FBLL;
                    (**l_235) = (l_624 != (void*)0);
                    if ((p_60 != (void*)0))
                    { /* block id: 523 */
                        (*l_585) = (*l_618);
                        (***l_234) = ((float)((float)p_59 / (float)0x0.Cp+1) - (float)(((((+((float)((**l_617) > ((float)((0x4.1311D0p-97 <= ((*l_543) == ((**l_617) == (-0x7.Dp+1)))) == 0x1.Ep+1) / (float)(-0x8.7p+1))) + (float)l_634)) != 0xE.B57360p-46) != p_59) != 0x2.Bp+1) != l_635));
                    }
                    else
                    { /* block id: 526 */
                        return p_59;
                    }
                    for (l_454 = 0; (l_454 < (-13)); l_454 -= 1)
                    { /* block id: 531 */
                        if ((*p_60))
                            break;
                        (**l_624) = (**l_250);
                    }
                    if ((**l_235))
                        break;
                }
            }
            return p_58.f2;
        }
        /* facts after branching */
        //assert (l_236 == &l_231 || l_236 == &l_370);
        if (((int16_t)(((int64_t)0x75BA367D935B7661LL - (int64_t)(*l_543)) <= ((l_642 | ((int32_t)(p_58.f0 >= p_58.f2) / (int32_t)((uint16_t)65535UL - (uint16_t)(((int16_t)(((uint32_t)__builtin_bswap64((l_651 || (*l_543))) % (uint32_t)0x56DA2C7DL) == (*l_543)) << (int16_t)l_652) > 65533UL)))) < p_58.f1)) << (int16_t)p_58.f2))
        { /* block id: 540 */
            uint64_t l_655 = 18446744073709551612UL;
            (**l_234) = l_583;
            /* statement id: 541 */
            assert (l_236 == &l_584);
            for (l_538 = 0; (l_538 < 21); l_538++)
            { /* block id: 544 */
                if (l_655)
                    break;
            }
            for (l_370 = 0; (l_370 < 12); l_370++)
            { /* block id: 549 */
                (*l_235) = (void*)0;
                /* statement id: 550 */
                assert (l_236 == 0);
                return l_655;
            }
        }
        else
        { /* block id: 553 */
            uint64_t l_661 = 18446744073709551615UL;
            int32_t l_679 = 0xA9FB29B4L;
            struct S0 *l_696 = &l_252;
            float ****l_711 = &l_331;
            int32_t *****l_743 = &l_688;
            struct S0 l_746 = {10,1,5};
            int16_t l_747 = 2L;
        }
        /* facts after branching */
        //assert (l_236 == &l_231 || l_236 == &l_370 || l_236 == &l_584);
        (**l_234) = l_757;
        /* statement id: 681 */
        assert (l_236 == &l_237);
    }
    /* facts after branching */
    //assert (l_236 == &l_237 || l_236 == dangling);
    (*l_251) = p_58;
    return l_758;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_62(uint32_t  p_63)
{ /* block id: 38 */
    struct S0 *l_64 = (void*)0;
    int32_t ** const l_67 = (void*)0;
    int32_t *l_184 = (void*)0;
    int32_t **l_183 = &l_184;
    int32_t ***l_182 = &l_183;
    struct S0 l_191 = {4,0,6};
    int32_t l_206 = 0x7D394C19L;
    int32_t *l_205 = &l_206;
    float l_226 = 0x1.Cp+1;
    int32_t **l_229 = &l_205;
    l_64 = (void*)0;
    (*l_182) = func_65(l_67);
    /* statement id: 116 */
    assert (l_183 == 0);
    if (p_63)
    { /* block id: 117 */
        int32_t l_190 = 0x017E6F66L;
        int32_t *l_189 = &l_190;
        for (p_63 = (-1); (p_63 > 51); p_63 += 9)
        { /* block id: 120 */
            int32_t l_188 = 0x488B34D0L;
            int32_t *l_187 = &l_188;
            l_189 = l_187;
            /* statement id: 121 */
            assert (l_189 == &l_188);
            return l_191;
        }
    }
    else
    { /* block id: 124 */
        int32_t *l_208 = &l_206;
        struct S0 *l_227 = (void*)0;
        if (p_63)
        { /* block id: 125 */
            const struct S0 l_192 = {9,0,6};
            struct S0 *l_193 = &l_191;
            float l_196 = 0x3.E8C5F5p+94;
            float *l_195 = &l_196;
            float **l_194 = &l_195;
            float ***l_197 = &l_194;
            int32_t **l_209 = &l_184;
            (*l_193) = l_192;
            (*l_197) = l_194;
            for (p_63 = (-20); (p_63 >= 19); p_63 += 9)
            { /* block id: 130 */
                uint32_t l_200 = 4294967293UL;
                int32_t l_202 = 0x54331F87L;
                int32_t *l_201 = &l_202;
                (*l_201) = l_200;
                for (l_200 = 0; (l_200 < 12); l_200 += 7)
                { /* block id: 134 */
                    int32_t **l_207 = &l_201;
                    (***l_197) = 0xE.AE4559p-68;
                    (*l_207) = l_205;
                    /* statement id: 136 */
                    assert (l_201 == &l_206);
                }
                /* facts after for loop */
                assert (l_201 == &l_206 || l_201 == &l_202);
            }
        }
        else
        { /* block id: 141 */
            uint32_t l_228 = 0x818B1E2CL;
            (*l_208) = l_228;
            l_191 = l_191;
        }
    }
    (*l_229) = &l_206;
    return l_191;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_65(int32_t ** const  p_66)
{ /* block id: 40 */
    int32_t l_68 = 0x83DE7690L;
    int32_t l_73 = (-3L);
    int32_t *l_72 = &l_73;
    struct S0 *l_153 = (void*)0;
    int32_t **l_176 = &l_72;
    int32_t **l_177 = &l_72;
    int32_t **l_178 = &l_72;
    int32_t **l_179 = &l_72;
    int32_t **l_180 = &l_72;
    int32_t **l_181 = (void*)0;
    for (l_68 = (-5); (l_68 == (-28)); l_68 -= 1)
    { /* block id: 43 */
        int32_t *l_71 = (void*)0;
        l_72 = l_71;
        /* statement id: 44 */
        assert (l_72 == 0);
    }
    /* facts after for loop */
    assert (l_72 == 0 || l_72 == &l_73);
    (*l_176) = func_74(l_73, func_79(&l_73, &l_72), l_153, l_68);
    (*l_176) = (*l_176);
    (*l_176) = (*l_176);
    return l_181;
    /* statement id: 115 */
    //assert (func_65_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_74(int32_t  p_75, int32_t * p_76, struct S0 * p_77, uint32_t  p_78)
{ /* block id: 103 */
    int32_t l_159 = 0xFFA34A9EL;
    int32_t *l_158 = &l_159;
    float l_169 = (-0x1.Ap+1);
    float *l_168 = &l_169;
    int32_t **l_171 = &l_158;
    int32_t ***l_170 = &l_171;
    const int32_t *l_175 = &l_159;
    const int32_t **l_174 = &l_175;
    const int32_t ** const *l_173 = &l_174;
    const int32_t ** const **l_172 = &l_173;
    for (p_78 = 0; (p_78 < 24); p_78 += 7)
    { /* block id: 106 */
        int32_t l_157 = 0xFA6F56A4L;
        int32_t *l_156 = &l_157;
        return p_76;
        /* statement id: 107 */
        //assert (func_74_rv == 0 || func_74_rv == &l_73 || func_74_rv == &l_231 || func_74_rv == &l_237 || func_74_rv == &l_395 || func_74_rv == &l_370 || func_74_rv == &l_311 || func_74_rv == &l_584 || func_74_rv == &l_679);
    }
    (*l_168) = ((float)((float)((*l_158) <= p_75) + (float)((float)(p_78 <= ((*l_158) > ((0x2.Cp+1 >= (((p_75 > ((float)(*l_158) - (float)p_75)) != p_75) < p_78)) > p_75))) - (float)p_75)) / (float)(*l_158));
    (*l_172) = l_170;
    /* statement id: 110 */
    assert (l_173 == &l_171);
    return p_76;
    /* statement id: 111 */
    //assert (func_74_rv == 0 || func_74_rv == &l_73 || func_74_rv == &l_231 || func_74_rv == &l_237 || func_74_rv == &l_395 || func_74_rv == &l_370 || func_74_rv == &l_311 || func_74_rv == &l_584 || func_74_rv == &l_679);
}


/* ------------------------------------------ */
/* 
 * reads : l_231
 * writes:
 */
static int32_t * func_79(int32_t * p_80, int32_t ** p_81)
{ /* block id: 46 */
    int16_t l_82 = 7L;
    uint32_t l_85 = 0x70783DB4L;
    int32_t l_138 = 0L;
    int32_t *l_137 = &l_138;
    int32_t *l_141 = &l_138;
    int32_t *l_142 = &l_138;
    int32_t *l_143 = &l_138;
    int32_t *l_144 = &l_138;
    int32_t *l_145 = &l_138;
    int32_t *l_146 = &l_138;
    int32_t *l_147 = &l_138;
    int32_t *l_148 = &l_138;
    int32_t *l_149 = &l_138;
    int32_t *l_150 = &l_138;
    int32_t *l_151 = &l_138;
    int32_t *l_152 = (void*)0;
    if (l_82)
    { /* block id: 47 */
        struct S0 l_89 = {6,1,5};
        struct S0 *l_88 = &l_89;
        int64_t l_132 = 0x97B072C46366C436LL;
        int32_t l_136 = 0L;
        int32_t *l_135 = &l_136;
        int32_t *l_139 = &l_138;
        l_85 = (0x0.28BC13p+5 != ((float)l_82 - (float)(((void*)0 != &p_80) > 0x3.FB38A8p+22)));
        for (l_85 = (-14); (l_85 == 35); ++l_85)
        { /* block id: 51 */
            struct S0 l_90 = {2,0,5};
            int32_t l_100 = 0x43638B4FL;
            int32_t *l_99 = &l_100;
            struct S0 *l_106 = (void*)0;
            int32_t *l_140 = (void*)0;
            if ((l_88 == (void*)0))
            { /* block id: 52 */
                (*l_88) = l_90;
            }
            else
            { /* block id: 54 */
                int32_t *l_97 = (void*)0;
                struct S0 *l_104 = &l_89;
                int32_t l_122 = 0x6586BC1AL;
                if (((int16_t)(__builtin_ctzl((((uint16_t)1UL << (uint16_t)((void*)0 == (*p_81))) != ((uint16_t)l_90.f2 - (uint16_t)((void*)0 != l_97)))) ^ ((l_90.f1 <= (l_85 && l_90.f0)) < l_82)) >> (int16_t)l_89.f1))
                { /* block id: 55 */
                    int32_t *l_98 = (void*)0;
                    int32_t *l_107 = &l_100;
                    if (l_90.f2)
                    { /* block id: 56 */
                        (*p_81) = l_98;
                        /* statement id: 57 */
                        //assert (l_72 == 0);
                        if ((*p_80))
                            break;
                        (*p_81) = l_99;
                        /* statement id: 59 */
                        //assert (l_72 == &l_100);
                    }
                    else
                    { /* block id: 60 */
                        (*p_81) = (*p_81);
                    }
                    /* facts after branching */
                    //assert (l_72 == 0 || l_72 == &l_73 || l_72 == &l_100);
                    for (l_100 = 0; (l_100 < (-18)); l_100 -= 5)
                    { /* block id: 65 */
                        uint64_t l_103 = 3UL;
                        struct S0 **l_105 = (void*)0;
                        l_103 = ((*l_99) > l_89.f2);
                        (*p_81) = (void*)0;
                        /* statement id: 67 */
                        //assert (l_72 == 0);
                        if ((*p_80))
                            continue;
                        l_106 = l_104;
                        /* statement id: 69 */
                        assert (l_106 == &l_89);
                    }
                    /* facts after for loop */
                    assert (l_106 == &l_89 || l_106 == 0);
                    l_99 = l_107;
                    return l_97;
                    /* statement id: 72 */
                    //assert (l_72 == 0 || l_72 == &l_73 || l_72 == dangling);
                    //assert (func_79_rv == 0);
                }
                else
                { /* block id: 73 */
                    struct S0 **l_111 = &l_88;
                    struct S0 ***l_110 = &l_111;
                    int32_t l_114 = 0xD1CE175EL;
                    for (l_82 = 0; (l_82 >= (-21)); l_82 -= 6)
                    { /* block id: 76 */
                        if ((*p_80))
                            break;
                        (*p_81) = (*p_81);
                    }
                    (*l_110) = &l_88;
                    if ((((uint64_t)18446744073709551615UL / (uint64_t)__builtin_parityll(((l_114 && l_114) & (*l_99)))) & (!((int64_t)l_89.f1 - (int64_t)l_89.f2))))
                    { /* block id: 81 */
                        int32_t l_131 = 0x068BD6B8L;
                        (*l_99) = (*p_80);
                        if ((*p_80))
                            break;
                        l_132 = (+((~(&l_88 != (void*)0)) & (((*l_99) && ((int16_t)(l_122 <= ((uint16_t)((*p_80) == l_122) << (uint16_t)4)) >> (int16_t)((int32_t)l_114 - (int32_t)((uint64_t)((((*p_80) != ((uint16_t)l_114 << (uint16_t)12)) != l_131) != 4294967293UL) / (uint64_t)(*l_99))))) & 5UL)));
                    }
                    else
                    { /* block id: 85 */
                        (*l_110) = &l_104;
                        /* statement id: 86 */
                        assert (l_111 == &l_104);
                    }
                    /* facts after branching */
                    assert (l_111 == &l_104 || l_111 == &l_88);
                    for (l_82 = (-19); (l_82 == 1); ++l_82)
                    { /* block id: 90 */
                        if ((*l_99))
                            break;
                        return (*p_81);
                        /* statement id: 92 */
                        //assert (func_79_rv == 0 || func_79_rv == &l_73 || func_79_rv == &l_237 || func_79_rv == &l_231 || func_79_rv == &l_370);
                    }
                }
                (*p_81) = l_135;
                /* statement id: 95 */
                //assert (l_72 == &l_136);
                return l_140;
                /* statement id: 96 */
                //assert (l_72 == dangling);
                //assert (func_79_rv == 0);
            }
        }
    }
    else
    { /* block id: 99 */
        (*p_81) = &l_138;
        /* statement id: 100 */
        //assert (l_72 == &l_138);
    }
    /* facts after branching */
    //assert (l_72 == &l_138 || l_72 == 0 || l_72 == &l_73);
    return l_152;
    /* statement id: 102 */
    //assert (l_72 == dangling || l_72 == 0 || l_72 == &l_73);
    //assert (func_79_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 218
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 40
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 23
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 1
XXX full-bitfields structs in the program: 10
breakdown:
   indirect level: 0, occurrence: 10
XXX times a bitfields struct's address is taken: 29
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 30
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 118

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 253
   depth: 2, occurrence: 46
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1

XXX total number of pointers: 203

XXX times a variable address is taken: 202
XXX times a pointer is dereferenced on RHS: 187
breakdown:
   depth: 1, occurrence: 145
   depth: 2, occurrence: 26
   depth: 3, occurrence: 14
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 182
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 49
   depth: 3, occurrence: 12
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 23
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 752

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 949
   level: 2, occurrence: 124
   level: 3, occurrence: 61
   level: 4, occurrence: 19
   level: 5, occurrence: 16
XXX number of pointers point to pointers: 92
XXX number of pointers point to scalars: 85
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 28.1
XXX average alias set size: 1.42

XXX times a non-volatile is read: 1028
XXX times a non-volatile is write: 532
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 14

XXX stmts: 211
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 19
   depth: 2, occurrence: 24
   depth: 3, occurrence: 38
   depth: 4, occurrence: 51
   depth: 5, occurrence: 46

XXX percentage a fresh-made variable is used: 16.7
XXX percentage an existing variable is used: 83.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

