/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      4075731683
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static uint32_t  func_3(struct S0  p_4, int16_t  p_5);
static struct S0  func_8(int16_t  p_9, int32_t  p_10, uint8_t  p_11, uint32_t  p_12);
static uint16_t  func_22(int16_t  p_23, int32_t  p_24, uint32_t  p_25);
static int16_t  func_27(int16_t  p_28, uint32_t  p_29, uint32_t  p_30, uint16_t  p_31);
static uint32_t  func_34(int32_t  p_35, uint32_t  p_36, uint32_t  p_37);
static uint16_t  func_41(uint16_t  p_42, int32_t  p_43, int16_t  p_44, uint8_t  p_45);
static uint16_t  func_46(int16_t  p_47, int32_t  p_48, uint8_t  p_49);
static int32_t  func_61(struct S0  p_62);
static uint16_t  func_67(uint32_t  p_68, int16_t  p_69, int16_t  p_70);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    struct S0 l_2 = {4294967292U};
    int32_t l_394 = 0x27B8E15B;
    l_2 = l_2;
    l_394 = ((l_2.f0 >= func_3(l_2, l_2.f0)) | (-(uint16_t)(((((int32_t)((int16_t)((uint32_t)l_2.f0 + (uint32_t)l_2.f0) - (int16_t)((int16_t)l_2.f0 << (int16_t)14)) - (int32_t)((uint16_t)(-(uint16_t)l_2.f0) - (uint16_t)l_2.f0)) != l_2.f0) != l_2.f0) > 65531U)));
    return l_2.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_3(struct S0  p_4, int16_t  p_5)
{ /* block id: 2 */
    int16_t l_6 = 0xD8F6;
    int32_t l_7 = 0xA4D63A88;
    uint16_t l_13 = 1U;
    struct S0 l_379 = {4294967293U};
    l_7 = l_6;
    p_4 = func_8(p_4.f0, (p_4.f0 == (4294967295U <= (p_5 == (l_6 < l_6)))), l_13, l_6);
    p_4 = l_379;
    for (l_379.f0 = 0; (l_379.f0 != 32); l_379.f0 += 8)
    { /* block id: 118 */
        if (l_379.f0)
            break;
        p_4 = l_379;
    }
    return p_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_8(int16_t  p_9, int32_t  p_10, uint8_t  p_11, uint32_t  p_12)
{ /* block id: 4 */
    int32_t l_40 = 0x5CB51404;
    uint32_t l_376 = 1U;
    int32_t l_377 = 1;
    struct S0 l_378 = {0x04A75030};
    l_377 = (((int16_t)((uint16_t)(((int16_t)((int32_t)((func_22((((~func_27(((int16_t)(func_34(p_11, p_11, ((((uint16_t)l_40 << (uint16_t)12) > func_41(func_46(l_40, (-(int32_t)l_40), ((int16_t)((6 || ((uint32_t)p_11 - (uint32_t)((uint16_t)l_40 << (uint16_t)10))) < ((int16_t)((l_40 >= (-1)) ^ l_40) >> (int16_t)l_40)) + (int16_t)p_12)), p_10, p_12, l_40)) > l_40)) && l_40) % (int16_t)0x7632), l_40, p_10, p_12)) > 1U) >= 1U), p_12, p_9) <= 0U) <= l_40) + (int32_t)1U) >> (int16_t)l_376) > p_11) + (uint16_t)65535U) - (int16_t)0x5FA3) == (-1));
    return l_378;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_22(int16_t  p_23, int32_t  p_24, uint32_t  p_25)
{ /* block id: 108 */
    int32_t l_374 = 1;
    int32_t l_375 = (-7);
    l_375 = (((uint16_t)p_23 + (uint16_t)p_23) & l_374);
    l_375 = (p_24 && l_374);
    return l_375;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_27(int16_t  p_28, uint32_t  p_29, uint32_t  p_30, uint16_t  p_31)
{ /* block id: 64 */
    int16_t l_259 = 0x0B90;
    uint16_t l_273 = 0x4EE4;
    struct S0 l_278 = {4294967295U};
    int32_t l_313 = 1;
    l_259 = 0xFD8B41AC;
    for (p_29 = 0; (p_29 != 24); p_29 += 1)
    { /* block id: 68 */
        int32_t l_276 = 9;
        int32_t l_277 = 0xF579459B;
        struct S0 l_279 = {0x570C3BFC};
        int32_t l_314 = (-1);
        l_277 = ((int16_t)l_259 - (int16_t)(~(p_30 != (((int16_t)0xBB90 >> (int16_t)11) && (((((int32_t)(l_259 ^ ((((uint16_t)((uint32_t)(l_273 >= (0xF9D53550 || p_31)) + (uint32_t)((int16_t)(p_30 || p_28) + (int16_t)l_276)) << (uint16_t)3) != 0xB23A) || p_31)) % (int32_t)p_30) ^ p_30) >= 0x7A62) ^ p_31)))));
        l_279 = l_278;
        if (((l_277 & (((!(0x7C2BC513 ^ ((int16_t)((uint16_t)(((int32_t)((uint16_t)(0x5F8E < l_278.f0) >> (uint16_t)8) % (int32_t)(p_30 && (-5))) != ((((((int16_t)((~((((uint32_t)((int16_t)((uint16_t)(((p_31 <= (l_277 || (~0x1156))) ^ p_31) <= l_279.f0) % (uint16_t)p_28) + (int16_t)0x9F0D) + (uint32_t)l_279.f0) >= l_276) == 0x4F81FE05)) == 0x4001) - (int16_t)l_259) || 0) || l_278.f0) == p_29) || l_276)) + (uint16_t)l_259) % (int16_t)l_259))) > l_273) != 0x5A15)) | 1))
        { /* block id: 71 */
            int32_t l_303 = 0xF1A146EB;
            l_313 = (((int32_t)((uint16_t)(4294967295U >= l_303) >> (uint16_t)((int16_t)(p_30 == 0xD9B8) - (int16_t)p_31)) + (int32_t)(-1)) <= (((uint16_t)(((((uint32_t)((((uint16_t)p_28 << (uint16_t)1) == (!p_29)) != (l_273 & l_303)) % (uint32_t)p_29) || p_31) == l_303) ^ 0x22FD) >> (uint16_t)l_277) == 0xF826));
        }
        else
        { /* block id: 73 */
            uint32_t l_316 = 4294967289U;
            struct S0 l_321 = {0x97EC47D4};
            int32_t l_340 = 0x80F069B4;
            int32_t l_341 = 2;
            uint32_t l_371 = 4294967295U;
            if (((-5) || l_314))
            { /* block id: 74 */
                struct S0 l_315 = {4294967295U};
                l_278 = l_315;
                l_316 = 0xCDF26903;
            }
            else
            { /* block id: 77 */
                int16_t l_329 = 0x779E;
                int32_t l_334 = 0xDD1DF32B;
                int16_t l_370 = 1;
                if (((uint16_t)6U >> (uint16_t)p_30))
                { /* block id: 78 */
                    struct S0 l_322 = {0x4C10A020};
                    uint8_t l_339 = 0xCD;
                    if ((0xEFF8 ^ ((uint16_t)65533U >> (uint16_t)4)))
                    { /* block id: 79 */
                        uint16_t l_336 = 0xFCAB;
                        int32_t l_337 = 0x27AFAB58;
                        l_279 = l_279;
                        l_322 = l_321;
                        l_334 = ((uint16_t)(p_28 > ((((uint16_t)65535U % (uint16_t)((int32_t)p_29 - (int32_t)l_329)) < ((0x54DA && ((uint16_t)(((uint32_t)(l_273 != l_329) - (uint32_t)0x20CAB86E) ^ 0xE325C52A) % (uint16_t)p_28)) > p_29)) < 65535U)) >> (uint16_t)l_277);
                        l_337 = ((l_273 ^ (!p_28)) && l_336);
                    }
                    else
                    { /* block id: 84 */
                        struct S0 l_338 = {4294967292U};
                        l_338 = l_278;
                        l_339 = 0xFF4D61BF;
                    }
                    l_277 = 0xAC941AE3;
                }
                else
                { /* block id: 89 */
                    l_277 = p_31;
                    l_341 = l_340;
                    l_334 = (4294967295U | (p_29 | (0xA1CF02BA == ((uint16_t)((int32_t)((int16_t)((uint16_t)p_30 << (uint16_t)p_30) - (int16_t)((int16_t)(((l_321.f0 == (l_259 || ((int16_t)l_278.f0 << (int16_t)13))) & (0xC9E9ED23 && l_273)) <= l_273) % (int16_t)p_29)) + (int32_t)0U) - (uint16_t)l_334))));
                }
                for (p_30 = 0; (p_30 != 39); p_30 += 1)
                { /* block id: 96 */
                    int32_t l_358 = 0x0DDB56AA;
                    l_371 = ((uint32_t)(l_358 >= (((((uint16_t)((uint16_t)3U + (uint16_t)0U) % (uint16_t)p_28) >= (p_31 ^ ((p_28 || ((int16_t)(l_341 >= (((int32_t)(l_358 == ((((~((uint16_t)l_370 << (uint16_t)l_341)) == 1) ^ 0xECCE) == 3)) % (int32_t)p_29) > 1)) << (int16_t)l_273)) == 0x50EF))) && p_28) ^ p_31)) % (uint32_t)0xE0F8220F);
                    return l_277;
                }
                if (p_30)
                    continue;
                l_334 = 0x9A203BC8;
            }
            l_278 = l_321;
            return l_316;
        }
    }
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_34(int32_t  p_35, uint32_t  p_36, uint32_t  p_37)
{ /* block id: 57 */
    int32_t l_237 = (-1);
    for (p_35 = 0; (p_35 <= 29); p_35 += 5)
    { /* block id: 60 */
        uint32_t l_252 = 4294967295U;
        l_237 = ((((uint16_t)l_237 + (uint16_t)((((((int32_t)((uint16_t)p_35 >> (uint16_t)((uint16_t)p_37 << (uint16_t)((int16_t)0 << (int16_t)10))) - (int32_t)((((0xA167C121 > ((int16_t)(((((uint16_t)((int16_t)l_252 + (int16_t)((int32_t)((int32_t)((int16_t)0x5527 >> (int16_t)9) - (int32_t)((p_36 < l_237) > l_237)) + (int32_t)l_237)) - (uint16_t)l_252) <= 0x51E3) < p_35) <= l_237) + (int16_t)l_252)) || p_37) & p_37) && p_36)) != l_237) >= (-1)) && p_35) || l_252)) < p_37) <= p_36);
    }
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_41(uint16_t  p_42, int32_t  p_43, int16_t  p_44, uint8_t  p_45)
{ /* block id: 28 */
    uint16_t l_126 = 0x9B89;
    uint32_t l_137 = 0xA7E67F48;
    uint32_t l_138 = 4294967287U;
    int32_t l_139 = 0x421CF99D;
    struct S0 l_232 = {4294967293U};
    l_139 = (p_42 | ((l_126 || ((int32_t)l_126 - (int32_t)((int16_t)0xE2D0 - (int16_t)(((0xF719 > (1 > ((((uint16_t)(((uint16_t)((((uint16_t)(((p_42 ^ (0x801D == ((p_44 ^ (-1)) != p_44))) > l_137) <= p_42) << (uint16_t)l_137) & p_45) != l_137) << (uint16_t)p_43) == 0x1EE9) - (uint16_t)l_137) && l_137) > p_44))) >= l_137) <= 65527U)))) < l_138));
    for (p_42 = 2; (p_42 < 13); p_42 += 1)
    { /* block id: 32 */
        uint32_t l_169 = 0xA68DE422;
        uint16_t l_186 = 0xE2F3;
        for (l_138 = 0; (l_138 <= 2); l_138 += 1)
        { /* block id: 35 */
            uint32_t l_168 = 0xB7A0ED4F;
            l_139 = ((((-1) >= ((uint32_t)((int16_t)((!((uint32_t)1U % (uint32_t)((int16_t)l_137 << (int16_t)1))) || (0x808E4DAE == (((uint16_t)((int16_t)((0xF28033D0 ^ l_138) < (!((((~(((((-(int32_t)((uint16_t)(((((((p_43 < (8 != ((uint32_t)(((int16_t)((((int16_t)(0x1447C33E != (-3)) >> (int16_t)7) || p_42) & p_44) << (int16_t)12) == p_45) % (uint32_t)(-1)))) && 0) >= 0xC35E) && 65535U) & l_168) | l_169) && l_169) >> (uint16_t)l_169)) == 0xCA36) || 1) && l_169) & l_169)) >= 1U) == (-4)) ^ p_45))) - (int16_t)2U) - (uint16_t)l_168) ^ (-8)))) << (int16_t)9) - (uint32_t)0x53124D0B)) ^ l_168) || l_137);
            l_139 = ((int16_t)((uint16_t)((0x3CEA > l_168) < (l_138 && 0xF591)) + (uint16_t)((uint16_t)((int32_t)0x350D549E + (int32_t)((int16_t)((int32_t)((((int16_t)l_169 << (int16_t)15) ^ ((int16_t)((0xE6B69ECC & (p_45 && ((((l_126 & p_42) > 0x6913) == p_44) & 65535U))) | l_137) << (int16_t)l_186)) && 2U) % (int32_t)0x44FEC2E3) << (int16_t)7)) % (uint16_t)p_45)) << (int16_t)8);
            l_139 = ((!(((uint16_t)(p_43 > 0xD5C6) >> (uint16_t)((uint16_t)((-(int16_t)((uint32_t)((p_44 | ((uint16_t)((l_186 <= (l_139 ^ ((((int16_t)(6 >= (!(~((((uint16_t)l_168 - (uint16_t)l_169) == (((1U > l_186) != (-1)) != l_169)) >= l_126)))) >> (int16_t)12) && p_42) ^ 0x10810DBF))) ^ l_126) % (uint16_t)1U)) > l_168) + (uint32_t)l_139)) <= 1U) % (uint16_t)65535U)) == 4)) == l_126);
        }
        return p_42;
    }
    for (p_44 = (-27); (p_44 != 2); p_44 += 1)
    { /* block id: 44 */
        uint16_t l_215 = 7U;
        int32_t l_231 = 0x445221C5;
        for (p_42 = 0; (p_42 == 24); p_42 += 1)
        { /* block id: 47 */
            uint32_t l_207 = 0x26DB9416;
            if (p_43)
                break;
            l_139 = (l_207 == 0);
        }
        l_231 = ((int32_t)(!(l_138 > ((int16_t)p_42 << (int16_t)6))) % (int32_t)((((((int16_t)p_43 >> (int16_t)13) >= (l_215 >= ((int16_t)(((uint16_t)l_138 % (uint16_t)(-(int32_t)((((uint16_t)p_42 - (uint16_t)((uint16_t)((uint16_t)l_138 << (uint16_t)5) % (uint16_t)((int16_t)0x1267 >> (int16_t)10))) != (((int16_t)(p_43 ^ p_42) >> (int16_t)8) ^ p_44)) | p_42))) != p_45) << (int16_t)10))) < l_215) < l_215) && 0x5B7E));
        l_232 = l_232;
        l_232 = l_232;
    }
    l_232 = l_232;
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_46(int16_t  p_47, int32_t  p_48, uint8_t  p_49)
{ /* block id: 5 */
    struct S0 l_63 = {0x9E5E26C5};
    uint16_t l_111 = 1U;
    int32_t l_125 = 0;
    if (((int32_t)(func_61(l_63) && l_63.f0) + (int32_t)0x0E7A75E4))
    { /* block id: 16 */
        struct S0 l_100 = {0x9C3C7D9A};
        l_100 = l_63;
        if ((((((int32_t)((4U || (((((((l_63.f0 != (l_100.f0 < (l_100.f0 | l_100.f0))) >= 8) != ((int16_t)((uint16_t)p_48 << (uint16_t)11) >> (int16_t)13)) && ((((((uint16_t)((uint16_t)((((0x00093999 >= (l_111 < l_63.f0)) || 0x942F0248) >= p_49) ^ 4294967295U) % (uint16_t)l_100.f0) - (uint16_t)l_111) < p_47) || l_100.f0) && p_49) > 0x30483F31)) > 0x4665) == l_100.f0) == l_100.f0)) & p_48) % (int32_t)1U) == p_49) || l_100.f0) || l_100.f0))
        { /* block id: 18 */
            l_63 = l_63;
        }
        else
        { /* block id: 20 */
            return l_111;
        }
    }
    else
    { /* block id: 23 */
        uint32_t l_112 = 0x3853DC63;
        return l_112;
    }
    l_125 = (((((~p_49) ^ (!p_48)) || ((((uint32_t)((uint32_t)0x377D1C13 % (uint32_t)((int32_t)((uint32_t)l_63.f0 + (uint32_t)(((((((uint32_t)l_111 + (uint32_t)(p_48 ^ l_63.f0)) || (p_47 <= 0xF603)) >= l_63.f0) != 0xFD65E783) ^ l_125) | (-10))) - (int32_t)0xF736FA54)) % (uint32_t)(-9)) < p_47) != 0x26FEE090)) || l_63.f0) <= p_47);
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_61(struct S0  p_62)
{ /* block id: 6 */
    uint32_t l_66 = 0U;
    int32_t l_97 = 0x0F9CC38D;
    l_97 = ((int16_t)(l_66 && (p_62.f0 < ((((0x8731485A < (func_67(l_66, l_66, l_66) ^ (((uint16_t)p_62.f0 >> (uint16_t)1) | ((uint16_t)65530U % (uint16_t)p_62.f0)))) & l_66) <= l_66) ^ p_62.f0))) >> (int16_t)12);
    p_62 = p_62;
    l_97 = ((7 || (!l_97)) && ((!p_62.f0) || p_62.f0));
    return p_62.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_67(uint32_t  p_68, int16_t  p_69, int16_t  p_70)
{ /* block id: 7 */
    struct S0 l_71 = {0x3265C9E2};
    int32_t l_72 = (-2);
    l_71 = l_71;
    l_72 = l_71.f0;
    l_72 = (((int16_t)((int16_t)((p_69 < (!((uint16_t)p_70 - (uint16_t)l_72))) == ((uint32_t)((uint16_t)0U >> (uint16_t)((uint32_t)l_72 % (uint32_t)((int32_t)p_70 + (int32_t)(((int16_t)(((0x2848AA25 & (~((((int32_t)(((l_71.f0 != l_71.f0) == 0x080E253E) | p_68) % (int32_t)0x083F7A53) <= 0x8D27) & p_70))) <= p_70) > l_72) >> (int16_t)15) && l_72)))) - (uint32_t)l_72)) << (int16_t)5) % (int16_t)(-1)) < p_69);
    return l_72;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 45
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 9, occurrence: 1
   depth: 13, occurrence: 2
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 24, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 38, occurrence: 1
   depth: 41, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 319
XXX times a non-volatile is write: 55
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 79
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 15
   depth: 2, occurrence: 11
   depth: 3, occurrence: 6
   depth: 4, occurrence: 7
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 16.2
XXX percentage an existing variable is used: 83.8
********************* end of statistics **********************/

