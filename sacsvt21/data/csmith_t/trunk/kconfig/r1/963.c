/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      4178808541
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint32_t  f1;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 6;
   unsigned : 0;
   unsigned f1 : 3;
};
#pragma pack(pop)

union U2 {
   unsigned f0 : 2;
   int32_t  f1;
   struct S0  f2;
};

union U3 {
   uint16_t  f0;
   int16_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_3 = 1;
static uint16_t g_33 = 1U;
static union U3 g_36 = {0xA0B5};
static int32_t g_125 = 0x285BF189;
static struct S0 g_136 = {0x5A861DE5,1U};
static struct S1 g_168 = {6,0};
static struct S1 g_283 = {4,1};
static int32_t g_291 = 0xDE925552;
static int16_t g_339 = (-9);
static uint16_t g_354 = 65535U;
static int16_t g_378 = 0;
static union U2 g_396 = {0x06B84C78};
static int32_t g_421 = 7;
static uint16_t g_566 = 0x6DAA;


/* --- FORWARD DECLARATIONS --- */
static union U2  func_25(void);
static struct S0  func_26(struct S0  p_27, union U2  p_28);
static struct S0  func_29(int32_t  p_30);
static struct S1  func_34(union U3  p_35);
static int16_t  func_59(uint32_t  p_60);
static int32_t  func_69(int32_t  p_70, uint32_t  p_71, int16_t  p_72);
static int16_t  func_76(union U2  p_77);
static uint32_t  func_86(int32_t  p_87, struct S1  p_88, uint32_t  p_89);
static uint16_t  func_94(uint32_t  p_95, int32_t  p_96, union U3  p_97);
static int16_t  func_103(int32_t  p_104, union U3  p_105, struct S1  p_106, struct S1  p_107, int16_t  p_108);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_36 g_36.f0 g_36.f1 g_33 g_125 g_136 g_168 g_283 g_291 g_339 g_354 g_378 g_396 g_396.f2.f1 g_421 g_396.f0 g_566
 * writes: g_3 g_33 g_36.f1 g_125 g_136 g_168.f0 g_168 g_283.f0 g_339 g_291 g_283 g_396.f1 g_396.f2.f1 g_36.f0 g_396.f2
 */
static union U2  func_25(void)
{ /* block id: 36 */
    union U2 l_567 = {1U};
    l_567.f2 = func_26(func_29(g_3), l_567);
    return l_567;
}


/* ------------------------------------------ */
/* 
 * reads : g_168 g_36.f0
 * writes: g_283
 */
static struct S0  func_26(struct S0  p_27, union U2  p_28)
{ /* block id: 342 */
    union U3 l_568 = {0U};
    int32_t l_569 = 0xF7A7FC50;
    g_283 = g_168;
    p_28.f1 = g_36.f0;
    l_569 = l_568.f1;
    return p_27;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_36 g_36.f0 g_36.f1 g_33 g_125 g_136 g_168 g_283 g_291 g_339 g_354 g_378 g_396 g_396.f2.f1 g_421 g_396.f0 g_566
 * writes: g_3 g_33 g_36.f1 g_125 g_136 g_168.f0 g_168 g_283.f0 g_339 g_291 g_283 g_396.f1 g_396.f2.f1 g_36.f0 g_396.f2
 */
static struct S0  func_29(int32_t  p_30)
{ /* block id: 37 */
    struct S1 l_559 = {-5,1};
    struct S0 l_560 = {0x4DFE439C,0x7784B617};
    struct S0 l_561 = {2,0U};
    for (g_3 = 0; (g_3 > 18); g_3 += 1)
    { /* block id: 40 */
        g_33 = p_30;
    }
    l_559 = func_34(g_36);
    l_561 = l_560;
    if ((p_30 | 0U))
    { /* block id: 335 */
        p_30 = g_378;
        g_168 = g_168;
    }
    else
    { /* block id: 338 */
        uint16_t l_564 = 4U;
        l_559.f0 = ((uint16_t)((l_564 && func_69((l_564 >= p_30), (!l_560.f1), p_30)) != g_566) >> (uint16_t)3);
    }
    return l_561;
}


/* ------------------------------------------ */
/* 
 * reads : g_36.f0 g_36.f1 g_3 g_33 g_125 g_136 g_168 g_36 g_283 g_291 g_339 g_354 g_378 g_396 g_396.f2.f1 g_421 g_396.f0
 * writes: g_36.f1 g_125 g_136 g_33 g_168.f0 g_168 g_283.f0 g_339 g_291 g_283 g_396.f1 g_396.f2.f1 g_36.f0 g_396.f2
 */
static struct S1  func_34(union U3  p_35)
{ /* block id: 43 */
    uint16_t l_46 = 65535U;
    int16_t l_53 = 0xE1F1;
    uint32_t l_54 = 4294967295U;
    int32_t l_547 = 0xFFD91954;
    struct S1 l_558 = {-0,0};
    if ((0x1E6E <= ((int32_t)(g_36.f0 != (((int16_t)((((int16_t)(__builtin_ia32_crc32qi(g_36.f1, ((~((((((int32_t)(-5) % (int32_t)__builtin_ffsll(p_35.f0)) && l_46) || ((((uint16_t)((((uint16_t)((uint16_t)p_35.f1 >> (uint16_t)0) - (uint16_t)g_3) <= l_46) ^ p_35.f1) << (uint16_t)g_36.f1) ^ 0xD69FDB81) <= l_53)) ^ 0x7C264F89) < 0x4628AEA3)) > l_54)) > 0x31E3) + (int16_t)0x983A) != p_35.f0) != 0xCEB8A064) >> (int16_t)g_33) != p_35.f1)) + (int32_t)g_33)))
    { /* block id: 44 */
        int32_t l_552 = 0;
        l_552 = (p_35.f1 <= (((int16_t)((uint16_t)(func_59(g_36.f1) <= l_547) << (uint16_t)((uint16_t)1U << (uint16_t)1)) - (int16_t)((int32_t)l_552 * (int32_t)(g_3 < l_53))) || g_136.f0));
    }
    else
    { /* block id: 327 */
        struct S1 l_557 = {5,0};
        g_168.f0 = ((uint16_t)((uint16_t)g_378 + (uint16_t)g_396.f0) + (uint16_t)l_547);
        l_557 = l_557;
    }
    g_283 = l_558;
    return l_558;
}


/* ------------------------------------------ */
/* 
 * reads : g_36.f0 g_36.f1 g_3 g_33 g_125 g_136 g_168 g_36 g_283 g_291 g_339 g_354 g_378 g_396 g_396.f2.f1 g_421 g_396.f0
 * writes: g_36.f1 g_125 g_136 g_33 g_168.f0 g_168 g_283.f0 g_339 g_291 g_283 g_396.f1 g_396.f2.f1 g_36.f0 g_396.f2
 */
static int16_t  func_59(uint32_t  p_60)
{ /* block id: 45 */
    uint32_t l_73 = 9U;
    struct S0 l_360 = {-1,0xD3D2653F};
    struct S1 l_380 = {-5,0};
    union U3 l_383 = {0xE20A};
    uint32_t l_384 = 1U;
    int16_t l_448 = (-1);
    if (((int32_t)((int16_t)(0U < ((0x9EDE >= ((((uint16_t)p_60 >> (uint16_t)((p_60 == ((int16_t)(-5) >> (int16_t)1)) | 8U)) > (0xF9D99D06 || func_69(l_73, g_36.f0, l_73))) || p_60)) != g_3)) - (int16_t)l_73) + (int32_t)p_60))
    { /* block id: 180 */
        struct S1 l_348 = {0,0};
        struct S0 l_361 = {1,4294967295U};
        for (g_291 = 0; (g_291 == (-28)); g_291 -= 1)
        { /* block id: 183 */
            uint32_t l_353 = 2U;
            g_283 = l_348;
            l_348.f0 = (g_291 != ((int16_t)g_339 >> (int16_t)((__builtin_bswap32(((((uint32_t)((l_353 && p_60) & g_354) % (uint32_t)(((!(((uint16_t)((p_60 & l_73) < (((uint32_t)(0xDA7950DB || l_73) + (uint32_t)p_60) != 0xD7274880)) >> (uint16_t)l_353) > p_60)) & p_60) | p_60)) ^ (-1)) ^ g_168.f0)) <= l_73) || p_60)));
        }
        l_361 = l_360;
    }
    else
    { /* block id: 188 */
        uint16_t l_368 = 0x3EE7;
        union U3 l_379 = {65535U};
        int32_t l_385 = 0x269AAF84;
        struct S1 l_386 = {-4,1};
        uint32_t l_449 = 0xB7366D6A;
        struct S0 l_482 = {0,0U};
        l_380.f0 = (((((int32_t)(((uint16_t)(((uint16_t)l_73 << (uint16_t)9) & (g_136.f0 == 65532U)) << (uint16_t)l_368) >= (((int16_t)((int32_t)__builtin_ctzl(l_368) - (int32_t)((int16_t)((func_103((((int16_t)l_368 - (int16_t)((~((0xDAD0 >= p_60) >= 0)) && 4294967289U)) | g_378), l_379, l_380, g_168, l_368) <= l_368) == p_60) - (int16_t)65535U)) >> (int16_t)l_379.f0) <= p_60)) % (int32_t)l_379.f1) | l_368) != g_283.f1) == 0x003BAD87);
        l_385 = ((g_36.f1 <= (g_283.f0 >= (((uint16_t)func_94(g_339, g_283.f0, l_383) - (uint16_t)((0x30EE | l_384) < g_354)) > 0x3054))) <= p_60);
        l_386 = l_380;
        if ((((((uint16_t)func_103(l_386.f0, l_383, g_168, l_380, g_283.f1) << (uint16_t)l_386.f1) > (((uint16_t)(((((__builtin_ffs(((int16_t)g_168.f1 - (int16_t)(((uint16_t)(~g_136.f0) - (uint16_t)p_60) < p_60))) <= g_36.f1) == 0U) && 0x219D6A0E) && (-1)) == g_36.f0) - (uint16_t)0x3682) != 2U)) || l_380.f1) ^ l_384))
        { /* block id: 192 */
            uint32_t l_410 = 0U;
            if (func_76(g_396))
            { /* block id: 193 */
                g_396.f1 = (l_73 ^ 0x9B7D);
            }
            else
            { /* block id: 195 */
                struct S0 l_415 = {-4,0x8D11DA5C};
                for (l_384 = (-3); (l_384 < 60); l_384 += 1)
                { /* block id: 198 */
                    struct S0 l_401 = {0x500268C0,1U};
                    int16_t l_411 = 0xB645;
                    uint32_t l_412 = 0xD8367E70;
                    for (g_339 = (-7); (g_339 < 18); g_339 += 1)
                    { /* block id: 201 */
                        l_401 = g_136;
                        l_380.f0 = 7;
                    }
                    l_412 = ((int16_t)(g_136.f0 | ((uint16_t)(((((((uint16_t)((uint16_t)l_385 + (uint16_t)((g_136.f1 >= l_410) != l_383.f1)) << (uint16_t)(l_385 & ((65535U == g_3) && 0x0D34948E))) | 1) <= 1U) && g_283.f1) | l_379.f0) >= l_385) << (uint16_t)l_410)) << (int16_t)l_411);
                }
                for (g_136.f0 = 0; (g_136.f0 < (-20)); g_136.f0 -= 6)
                { /* block id: 209 */
                    struct S0 l_416 = {1,4294967295U};
                    l_416 = l_415;
                    g_168.f0 = l_368;
                }
                for (l_415.f1 = 8; (l_415.f1 == 8); l_415.f1 += 1)
                { /* block id: 215 */
                    return l_410;
                }
            }
            for (g_396.f2.f1 = 0; (g_396.f2.f1 > 12); g_396.f2.f1 += 1)
            { /* block id: 221 */
                int32_t l_423 = 0xB60DAF1F;
                l_360 = g_136;
                g_283.f0 = (((p_60 >= (__builtin_popcountl(g_421) & __builtin_parityl(((__builtin_parityll((0xDA43FE47 ^ (!(p_60 >= l_386.f1)))) ^ l_383.f1) > (g_396.f0 && 0x33EA5773))))) >= g_283.f0) || 4U);
                g_125 = l_423;
            }
        }
        else
        { /* block id: 226 */
            int32_t l_426 = 0xD0F99BAB;
            int32_t l_432 = 2;
            struct S1 l_446 = {-7,1};
            g_396.f1 = (((0xF4BD7D84 > l_379.f0) || 0x2450) >= (l_368 != ((int16_t)((-1) && g_291) << (int16_t)5)));
            l_426 = (g_136.f0 | ((p_60 != (l_360.f0 && l_384)) != (p_60 != l_426)));
            if (p_60)
            { /* block id: 229 */
                int32_t l_431 = 7;
                union U3 l_442 = {0x5ED1};
                struct S1 l_474 = {-4,0};
                if ((((uint16_t)1U << (uint16_t)((int32_t)g_283.f0 + (int32_t)l_431)) == ((l_432 | (__builtin_clzll(p_60) > l_385)) || ((int16_t)(l_431 == p_60) << (int16_t)13))))
                { /* block id: 230 */
                    int32_t l_437 = 0x0AF53869;
                    uint32_t l_447 = 0x5DDE7BFC;
                    for (l_379.f0 = 0; (l_379.f0 < 53); l_379.f0 += 1)
                    { /* block id: 233 */
                        return l_437;
                    }
                    if (((l_380.f0 || 0xD9C2) || __builtin_ffs(((g_421 != ((g_36.f0 != func_94(g_396.f0, ((uint16_t)l_432 >> (uint16_t)((uint32_t)4294967290U - (uint32_t)l_73)), l_442)) > g_36.f1)) > g_421))))
                    { /* block id: 236 */
                        struct S1 l_443 = {-1,0};
                        l_443 = l_386;
                        g_396.f1 = __builtin_ffsl(__builtin_clzll((l_443.f0 ^ __builtin_clz(func_103(((int16_t)func_86(l_437, l_386, g_36.f1) >> (int16_t)p_60), l_383, g_283, l_446, l_447)))));
                    }
                    else
                    { /* block id: 239 */
                        l_431 = p_60;
                        l_386 = g_168;
                    }
                }
                else
                { /* block id: 243 */
                    g_136 = g_136;
                }
                g_125 = (p_60 != (p_60 ^ l_426));
                l_449 = (l_448 ^ 3);
                if (l_426)
                { /* block id: 248 */
                    struct S1 l_450 = {3,0};
                    l_450 = l_450;
                    l_450.f0 = ((int16_t)(p_60 ^ (1U && ((uint16_t)(((uint16_t)(l_450.f1 > g_421) >> (uint16_t)6) || p_60) << (uint16_t)__builtin_clzll(p_60)))) >> (int16_t)12);
                }
                else
                { /* block id: 251 */
                    uint32_t l_478 = 0x8DF74B69;
                    l_380 = g_283;
                    for (l_426 = (-26); (l_426 == 19); l_426 += 8)
                    { /* block id: 255 */
                        uint16_t l_463 = 1U;
                        uint16_t l_464 = 0xB342;
                        l_380.f0 = func_69(l_446.f0, __builtin_ctzl(((int16_t)(((uint16_t)g_36.f0 >> (uint16_t)((l_463 & l_386.f1) == l_384)) || __builtin_bswap32((((p_60 >= 0x9901) >= ((0 | func_86(g_421, g_283, g_168.f0)) <= l_463)) < l_464))) << (int16_t)1)), l_380.f1);
                        if (l_360.f0)
                            break;
                        return p_60;
                    }
                    for (l_383.f1 = 0; (l_383.f1 <= 20); l_383.f1 += 1)
                    { /* block id: 262 */
                        l_380.f0 = ((((uint16_t)((uint16_t)((((uint16_t)(p_60 ^ g_421) + (uint16_t)__builtin_ffsll(func_86((p_60 & (-(uint32_t)l_426)), l_474, p_60))) ^ (((!((((int32_t)p_60 + (int32_t)l_442.f1) || 1) && g_36.f0)) >= l_478) > l_360.f1)) || g_283.f1) % (uint16_t)1U) >> (uint16_t)g_3) & l_442.f1) != p_60);
                    }
                    for (g_36.f0 = 0; (g_36.f0 > 9); g_36.f0 += 8)
                    { /* block id: 267 */
                        return p_60;
                    }
                }
            }
            else
            { /* block id: 271 */
                int16_t l_481 = 0x8BD7;
                l_481 = 2;
                l_386.f0 = l_449;
                g_396.f2 = l_482;
                return g_339;
            }
        }
    }
    if (((__builtin_clz(((int32_t)func_94(g_168.f0, ((0x88E4 & ((0xE1C11DC4 <= ((int16_t)(p_60 > (g_36.f1 <= p_60)) - (int16_t)((l_360.f1 || (4294967295U && g_168.f1)) && l_383.f1))) != 0x078473D5)) | g_396.f0), l_383) + (int32_t)0xA36CC25D)) & (-1)) != 0x308D))
    { /* block id: 279 */
        uint32_t l_492 = 0xF2D9F185;
        union U3 l_497 = {0U};
        struct S1 l_499 = {7,0};
        for (l_384 = 0; (l_384 > 59); l_384 += 2)
        { /* block id: 282 */
            union U3 l_491 = {2U};
            struct S0 l_494 = {1,0x4E20B056};
            struct S1 l_500 = {-0,0};
            if ((func_94((func_103(g_33, l_491, g_283, g_168, l_491.f0) ^ (-7)), l_492, l_383) ^ 0xBC58088B))
            { /* block id: 283 */
                struct S0 l_493 = {-1,1U};
                l_494 = l_493;
                g_396.f1 = func_94((((l_493.f0 ^ l_493.f1) != p_60) == 0x509B1685), ((int16_t)p_60 << (int16_t)g_421), l_497);
            }
            else
            { /* block id: 286 */
                int32_t l_498 = (-4);
                l_498 = g_125;
                l_380 = g_168;
            }
            if (g_125)
                continue;
            l_500 = l_499;
        }
        l_380.f0 = ((uint32_t)p_60 - (uint32_t)(g_168.f1 || ((l_383.f1 || g_36.f1) <= ((uint32_t)((int16_t)p_60 >> (int16_t)8) + (uint32_t)g_125))));
        return g_36.f1;
    }
    else
    { /* block id: 295 */
        struct S1 l_519 = {-4,1};
        struct S0 l_521 = {-3,0xC4CF8342};
        g_283.f0 = 0xFABF0C10;
        g_396.f1 = ((((uint16_t)2U >> (uint16_t)(g_36.f0 && 4U)) != ((uint16_t)((((uint16_t)p_60 + (uint16_t)g_136.f0) > __builtin_ctzl(((uint16_t)((0U == p_60) || (1U >= ((-(int32_t)(0xE35040A4 & p_60)) >= 65534U))) << (uint16_t)6))) >= p_60) >> (uint16_t)p_60)) < g_168.f1);
        if (g_36.f1)
        { /* block id: 298 */
            for (l_448 = 0; (l_448 >= 18); l_448 += 1)
            { /* block id: 301 */
                struct S1 l_518 = {-2,1};
                l_519 = l_518;
                return p_60;
            }
        }
        else
        { /* block id: 305 */
            uint16_t l_520 = 1U;
            g_168 = l_380;
            l_520 = (-1);
            l_519 = g_283;
            g_396.f2 = l_521;
        }
        if ((((l_519.f1 >= (-(uint16_t)((int16_t)((int32_t)(((int32_t)g_291 % (int32_t)(((uint32_t)((int16_t)p_60 - (int16_t)0x4661) - (uint32_t)(0x3B9A < g_354)) & ((uint16_t)(0xE6BE != ((l_384 && (p_60 | g_36.f0)) | 0xDA36B9FD)) - (uint16_t)l_519.f0))) <= g_283.f0) - (int32_t)p_60) - (int16_t)1))) < 3U) >= p_60))
        { /* block id: 311 */
            l_521 = g_136;
            for (l_448 = 0; (l_448 != (-28)); l_448 -= 1)
            { /* block id: 315 */
                int32_t l_542 = (-2);
                g_283.f0 = ((p_60 > (func_86(((((0xB3BB | ((-(int32_t)((int16_t)(-1) + (int16_t)p_60)) ^ 0)) >= (0x827A88AF && ((uint16_t)g_354 + (uint16_t)(p_60 >= g_378)))) < p_60) > l_542), l_519, p_60) <= g_421)) <= 0xBFF6);
                return g_36.f1;
            }
            l_519.f0 = g_36.f0;
        }
        else
        { /* block id: 320 */
            g_283.f0 = ((uint16_t)((int16_t)g_3 << (int16_t)p_60) >> (uint16_t)g_291);
            return g_168.f1;
        }
    }
    return l_383.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_36.f1 g_3 g_36.f0 g_33 g_125 g_136 g_168 g_36 g_283 g_291
 * writes: g_36.f1 g_125 g_136 g_33 g_168.f0 g_168 g_283.f0 g_339
 */
static int32_t  func_69(int32_t  p_70, uint32_t  p_71, int16_t  p_72)
{ /* block id: 46 */
    union U2 l_78 = {4294967295U};
    int32_t l_342 = 0xCC0BFC06;
    struct S0 l_344 = {0x146581DE,0x3E263C94};
    int32_t l_345 = 1;
    if ((((((int16_t)func_76(l_78) % (int16_t)p_72) & p_71) < (((((uint16_t)((((int32_t)((((int16_t)l_78.f0 >> (int16_t)((int16_t)(((uint16_t)0x3AD5 + (uint16_t)(((0 || (((0xBDBB9429 & (l_78.f0 & (-1))) & 1U) >= l_78.f0)) && g_3) != 0x56F0)) != 0U) - (int16_t)p_70)) & g_283.f1) < 4294967295U) + (int32_t)l_78.f0) > g_291) != 0) + (uint16_t)0x5287) > 0) <= g_3) != p_71)) >= l_78.f0))
    { /* block id: 170 */
        return g_125;
    }
    else
    { /* block id: 172 */
        uint32_t l_334 = 2U;
        struct S1 l_335 = {1,0};
        int16_t l_343 = 0xB48F;
        l_334 = (p_71 & ((l_78.f0 != 1U) <= l_78.f0));
        g_339 = func_103(p_71, g_36, l_335, l_335, (~(((p_72 | (((int16_t)(p_71 ^ (((l_334 == func_86(g_36.f0, l_335, g_125)) || 0xFB42) & 1)) << (int16_t)3) || g_125)) && l_335.f0) <= p_72)));
        g_283.f0 = (((g_3 >= ((p_70 >= p_70) == ((int16_t)g_136.f0 - (int16_t)g_36.f0))) == l_342) <= l_343);
    }
    l_78.f2 = l_344;
    l_345 = p_72;
    return l_345;
}


/* ------------------------------------------ */
/* 
 * reads : g_36.f1 g_3 g_36.f0 g_33 g_125 g_136 g_168 g_36 g_283 g_291
 * writes: g_36.f1 g_125 g_136 g_33 g_168.f0 g_168 g_283.f0
 */
static int16_t  func_76(union U2  p_77)
{ /* block id: 47 */
    union U3 l_109 = {0U};
    struct S1 l_110 = {-7,0};
    uint32_t l_127 = 0U;
    int32_t l_320 = 0x4A936E5E;
    for (p_77.f2.f0 = (-20); (p_77.f2.f0 >= 7); p_77.f2.f0 += 1)
    { /* block id: 50 */
        int16_t l_83 = 0x0E8B;
        for (g_36.f1 = 11; (g_36.f1 >= 24); g_36.f1 += 1)
        { /* block id: 53 */
            uint32_t l_102 = 4294967295U;
            struct S1 l_111 = {-4,0};
            int32_t l_126 = 0xEDC45779;
            l_83 = (-1);
            g_283.f0 = ((uint32_t)((func_86(((uint32_t)((int16_t)g_3 + (int16_t)func_94(((((uint16_t)(((((((int16_t)l_102 % (int16_t)func_103(g_36.f0, l_109, l_110, l_111, (((uint16_t)1U + (uint16_t)(__builtin_popcountll(l_83) | (-1))) <= 4294967291U))) != p_77.f0) && l_83) == p_77.f0) <= g_33) || l_126) >> (uint16_t)g_36.f0) < g_36.f1) < l_111.f1), l_127, l_109)) - (uint32_t)l_102), g_283, p_77.f0) & 0x334FE16F) && l_83) - (uint32_t)g_36.f0);
        }
        if (l_320)
            break;
        for (g_36.f1 = 0; (g_36.f1 > (-26)); g_36.f1 -= 1)
        { /* block id: 163 */
            int32_t l_323 = 0x097B45DC;
            l_323 = 0;
            return g_3;
        }
        l_110.f0 = p_77.f0;
    }
    return g_168.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_168 g_283.f1 g_33 g_291 g_36.f1 g_125 g_136.f0 g_36.f0 g_136 g_3 g_36 g_283.f0
 * writes: g_125 g_136 g_33 g_168.f0 g_168
 */
static uint32_t  func_86(int32_t  p_87, struct S1  p_88, uint32_t  p_89)
{ /* block id: 131 */
    int16_t l_286 = (-1);
    union U3 l_287 = {65528U};
    struct S1 l_288 = {4,1};
    if (((uint16_t)func_103(l_286, l_287, g_168, l_288, (((__builtin_popcount(g_168.f1) <= ((int16_t)(g_283.f1 >= 0U) % (int16_t)(g_33 | g_291))) == g_283.f1) <= p_87)) >> (uint16_t)g_136.f0))
    { /* block id: 132 */
        uint16_t l_294 = 0U;
        int32_t l_295 = (-5);
        struct S1 l_309 = {3,0};
        p_88.f0 = ((int16_t)(func_94(l_294, l_295, l_287) < p_87) << (int16_t)4);
        if (__builtin_clz((((int16_t)((int32_t)(func_94(((int16_t)((int16_t)g_136.f0 % (int16_t)g_36.f1) << (int16_t)3), l_294, g_36) && g_168.f0) % (int32_t)((((~p_88.f0) <= (((int16_t)0x2D44 - (int16_t)__builtin_ffsll(p_88.f0)) < 7)) | p_88.f0) || l_294)) << (int16_t)15) != p_87)))
        { /* block id: 134 */
            uint32_t l_307 = 0xE0B1E6EC;
            p_88.f0 = l_307;
        }
        else
        { /* block id: 136 */
            struct S1 l_308 = {-5,0};
            g_168.f0 = ((0xDDD5 < p_88.f0) || p_87);
            g_168 = l_308;
            if (g_33)
            { /* block id: 139 */
                p_88 = l_309;
            }
            else
            { /* block id: 141 */
                struct S0 l_310 = {-4,0x96E4B58B};
                p_88.f0 = p_89;
                l_310 = g_136;
                p_88.f0 = g_283.f1;
                l_295 = (g_33 | (g_283.f1 && ((__builtin_ffs(__builtin_bswap64(l_294)) >= g_136.f1) <= (((int16_t)l_310.f0 % (int16_t)((__builtin_ffsll(g_36.f1) <= l_294) && 65535U)) | 65535U))));
            }
        }
        for (g_33 = 18; (g_33 != 27); g_33 += 9)
        { /* block id: 150 */
            return l_309.f1;
        }
        g_125 = __builtin_bswap64(g_168.f1);
    }
    else
    { /* block id: 154 */
        int16_t l_319 = 0xE32C;
        p_88.f0 = ((((int32_t)func_103(g_283.f0, g_36, g_168, p_88, l_287.f1) % (int32_t)1U) && p_89) & (((int32_t)((l_288.f0 != l_319) < 0x6C4F1D60) + (int32_t)l_288.f0) < l_319));
    }
    return g_291;
}


/* ------------------------------------------ */
/* 
 * reads : g_36.f1 g_125 g_33 g_36.f0 g_136 g_168 g_3 g_36
 * writes: g_125 g_136 g_33 g_168.f0
 */
static uint16_t  func_94(uint32_t  p_95, int32_t  p_96, union U3  p_97)
{ /* block id: 63 */
    struct S1 l_140 = {-7,0};
    int32_t l_185 = 0x8A3E14BF;
    int16_t l_202 = 0xAE91;
    uint16_t l_227 = 65535U;
    if (g_36.f1)
    { /* block id: 64 */
        int16_t l_130 = 0xCB8C;
        g_125 = 0x6C854655;
        for (p_97.f0 = 15; (p_97.f0 >= 28); p_97.f0 += 1)
        { /* block id: 68 */
            return g_125;
        }
        l_130 = (p_97.f0 != g_33);
    }
    else
    { /* block id: 72 */
        int16_t l_134 = (-10);
        struct S0 l_135 = {8,0x0F4D7AA0};
        struct S1 l_141 = {-6,0};
        l_134 = (!((-8) && ((int16_t)g_36.f0 << (int16_t)1)));
        g_136 = l_135;
        l_135 = g_136;
        for (p_96 = 2; (p_96 > 12); p_96 += 1)
        { /* block id: 78 */
            union U3 l_139 = {65526U};
            l_140.f0 = func_103(g_136.f0, l_139, l_140, l_141, p_96);
            return g_125;
        }
    }
    for (g_33 = 13; (g_33 == 34); g_33 += 9)
    { /* block id: 85 */
        uint16_t l_144 = 0xBE42;
        union U3 l_151 = {0x0C28};
        struct S1 l_152 = {-1,0};
        uint16_t l_205 = 0x1E43;
        if (((__builtin_popcountll(l_144) > ((uint16_t)l_144 << (uint16_t)14)) == ((int16_t)g_136.f1 - (int16_t)((int16_t)(func_103(l_140.f1, l_151, l_152, l_140, g_136.f1) ^ p_95) >> (int16_t)p_97.f0))))
        { /* block id: 86 */
            int32_t l_153 = 0xA62F8029;
            union U3 l_175 = {1U};
            int16_t l_267 = 0x7434;
            l_153 = l_140.f0;
            if (((uint16_t)1U << (uint16_t)(9U || g_33)))
            { /* block id: 88 */
                for (l_151.f0 = 0; (l_151.f0 < 20); l_151.f0 += 1)
                { /* block id: 91 */
                    uint16_t l_158 = 65535U;
                    int32_t l_159 = 1;
                    l_159 = l_158;
                    l_140 = l_152;
                }
                g_125 = (0x68B9 >= (((g_36.f1 <= (-(uint32_t)p_95)) >= 2) <= (-(int32_t)(l_152.f0 && l_153))));
                l_140.f0 = (((((uint32_t)l_152.f1 % (uint32_t)((int32_t)func_103((((uint32_t)__builtin_ctzll(func_103(g_33, l_151, g_168, l_140, ((uint16_t)((int16_t)(p_97.f0 > ((p_95 == (p_97.f0 & ((int16_t)((l_151.f1 <= 0x4CA11B3A) < 0x108C9EE7) - (int16_t)l_153))) == 1U)) >> (int16_t)g_33) << (uint16_t)8))) - (uint32_t)g_168.f0) & 0x96F1), l_175, l_152, g_168, l_175.f0) - (int32_t)0x4C3530B4)) != p_97.f0) & 4294967291U) && g_33);
                if (l_153)
                    continue;
            }
            else
            { /* block id: 98 */
                int32_t l_206 = 1;
                int32_t l_254 = 0x61A9E103;
                for (g_125 = 18; (g_125 > 24); g_125 += 1)
                { /* block id: 101 */
                    uint32_t l_182 = 4294967294U;
                    if (((uint32_t)((int16_t)l_182 >> (int16_t)l_182) + (uint32_t)((int16_t)((((0x0BD7AEA9 > p_96) | ((((p_96 != g_168.f0) >= (-1)) <= g_136.f1) > (l_185 <= 0xF756))) && 0xFBB5) < 0xA8A6AB53) << (int16_t)l_175.f1)))
                    { /* block id: 102 */
                        uint16_t l_199 = 0U;
                        int32_t l_203 = 0xCE6FA717;
                        l_203 = ((((uint32_t)__builtin_parityll(p_96) - (uint32_t)((uint16_t)(!((int16_t)((int16_t)g_3 >> (int16_t)((uint16_t)((((uint16_t)((g_136.f1 && 0xD0226C0D) || g_168.f1) % (uint16_t)0x2FD4) == (l_199 ^ (((uint16_t)((g_125 | p_97.f1) & (-10)) - (uint16_t)l_153) & g_168.f0))) > p_95) << (uint16_t)g_33)) + (int16_t)g_3)) << (uint16_t)p_97.f0)) != l_202) | 0xBC813BED);
                    }
                    else
                    { /* block id: 104 */
                        g_168.f0 = (-(int16_t)(l_182 & p_97.f0));
                        return l_205;
                    }
                    if ((p_97.f1 == l_206))
                    { /* block id: 108 */
                        uint16_t l_216 = 0x2C7D;
                        g_168.f0 = (!((uint16_t)((l_175.f0 || g_168.f1) != ((((int16_t)(g_36.f1 | (g_3 && (((int32_t)((uint16_t)l_216 << (uint16_t)(p_96 <= (((uint16_t)((uint32_t)(~l_182) - (uint32_t)p_96) >> (uint16_t)4) <= ((__builtin_ia32_crc32qi(g_36.f1, p_96) != l_151.f0) <= p_96)))) % (int32_t)l_175.f1) | g_3))) - (int16_t)g_33) >= (-1)) <= 65534U)) << (uint16_t)g_168.f1));
                    }
                    else
                    { /* block id: 110 */
                        int16_t l_230 = 0x11BC;
                        g_168.f0 = (p_95 >= l_175.f0);
                        l_230 = ((((int16_t)(g_3 && 8) >> (int16_t)9) || ((int32_t)(g_125 && (-(int32_t)0xE4E45EC4)) + (int32_t)l_227)) | __builtin_ctzll((p_95 >= (((int16_t)g_36.f0 << (int16_t)(0x5C3B || p_96)) && l_153))));
                        g_168.f0 = ((uint32_t)((-(int16_t)((((int16_t)l_175.f0 >> (int16_t)l_206) & ((uint32_t)p_95 % (uint32_t)((uint32_t)(((int32_t)(((uint16_t)p_97.f0 - (uint16_t)l_202) | l_230) % (int32_t)((~g_168.f0) | 0x39658010)) <= ((uint32_t)((((-(uint16_t)(p_95 ^ l_182)) & 4) >= l_206) || 0x4CFA) % (uint32_t)l_206)) + (uint32_t)4U))) >= l_230)) ^ (-4)) % (uint32_t)l_230);
                        l_152.f0 = ((((int16_t)((0x2845 | 5U) && ((uint32_t)__builtin_ctzl((((uint16_t)(l_254 < ((int16_t)((l_175.f1 ^ ((!(((int16_t)(((int16_t)(l_182 == (p_95 != p_96)) << (int16_t)((uint16_t)p_95 << (uint16_t)9)) ^ 0xAAF875AC) + (int16_t)0x4C64) != g_136.f0)) | 4294967289U)) | 0) + (int16_t)0x4FAC)) << (uint16_t)8) ^ 0xA6F0)) - (uint32_t)0xABBA4A27)) << (int16_t)12) > g_168.f1) > p_97.f1);
                    }
                }
            }
            g_168.f0 = ((!(func_103(__builtin_clzll((l_267 == (p_95 & ((uint16_t)(l_151.f1 | g_168.f0) - (uint16_t)((uint16_t)((g_36.f1 == g_3) > (__builtin_popcountll(l_267) && ((int16_t)l_185 << (int16_t)13))) << (uint16_t)g_168.f1))))), p_97, l_140, g_168, g_168.f1) == 0x9D68)) || p_96);
        }
        else
        { /* block id: 119 */
            struct S1 l_280 = {-1,1};
            l_140.f0 = ((uint16_t)((((g_168.f0 && p_97.f1) < g_3) != ((0x7B68 > p_97.f1) < ((((int32_t)((uint16_t)func_103(l_144, g_36, l_140, l_280, l_202) << (uint16_t)p_95) + (int32_t)l_280.f1) & 0xF38200EB) != p_97.f1))) ^ 1U) >> (uint16_t)l_202);
        }
        l_140.f0 = l_140.f0;
        for (g_136.f1 = 0; (g_136.f1 > 31); g_136.f1 += 6)
        { /* block id: 125 */
            if (l_151.f1)
                break;
        }
    }
    l_140.f0 = g_136.f1;
    return p_95;
}


/* ------------------------------------------ */
/* 
 * reads : g_33 g_36.f1 g_125
 * writes: g_125
 */
static int16_t  func_103(int32_t  p_104, union U3  p_105, struct S1  p_106, struct S1  p_107, int16_t  p_108)
{ /* block id: 55 */
    uint32_t l_116 = 0U;
    for (p_108 = 4; (p_108 != (-13)); p_108 -= 1)
    { /* block id: 58 */
        l_116 = p_104;
    }
    g_125 = (((((uint16_t)((((p_107.f1 | ((((uint32_t)(g_33 >= ((int16_t)((((int16_t)(0x21480219 ^ 0U) + (int16_t)0x63C4) && l_116) != 0xF5ED) + (int16_t)(65533U == l_116))) % (uint32_t)l_116) > 65526U) ^ 0xBEC191E6)) && (-6)) | l_116) < 0x1FDD) << (uint16_t)p_105.f1) > g_36.f1) && g_125) < 2U);
    return p_106.f0;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_33, "g_33", print_hash_value);
    transparent_crc(g_36.f0, "g_36.f0", print_hash_value);
    transparent_crc(g_36.f1, "g_36.f1", print_hash_value);
    transparent_crc(g_125, "g_125", print_hash_value);
    transparent_crc(g_136.f0, "g_136.f0", print_hash_value);
    transparent_crc(g_136.f1, "g_136.f1", print_hash_value);
    transparent_crc(g_168.f0, "g_168.f0", print_hash_value);
    transparent_crc(g_168.f1, "g_168.f1", print_hash_value);
    transparent_crc(g_283.f0, "g_283.f0", print_hash_value);
    transparent_crc(g_283.f1, "g_283.f1", print_hash_value);
    transparent_crc(g_291, "g_291", print_hash_value);
    transparent_crc(g_339, "g_339", print_hash_value);
    transparent_crc(g_354, "g_354", print_hash_value);
    transparent_crc(g_378, "g_378", print_hash_value);
    transparent_crc(g_421, "g_421", print_hash_value);
    transparent_crc(g_566, "g_566", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 93
   depth: 1, occurrence: 41
XXX total union variables: 15

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 29
breakdown:
   indirect level: 0, occurrence: 29
XXX full-bitfields structs in the program: 26
breakdown:
   indirect level: 0, occurrence: 26
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 19
XXX times a bitfields struct on RHS: 57
XXX times a single bitfield on LHS: 36
XXX times a single bitfield on RHS: 83

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 201
   depth: 2, occurrence: 35
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 6, occurrence: 4
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 5
   depth: 14, occurrence: 2
   depth: 16, occurrence: 4
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 19, occurrence: 5
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 636
XXX times a non-volatile is write: 132
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 184
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 44
   depth: 2, occurrence: 37
   depth: 3, occurrence: 33
   depth: 4, occurrence: 18
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 18.6
XXX percentage an existing variable is used: 81.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

