/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      415842159
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_9(uint32_t  p_10, int16_t  p_11, int16_t  p_12, uint32_t  p_13, uint32_t  p_14);
static int16_t  func_17(int32_t  p_18, int8_t  p_19, int32_t  p_20, int32_t ** p_21);
static int16_t  func_27(int32_t  p_28, int32_t  p_29, uint16_t  p_30, uint16_t  p_31);
static int32_t * func_57(int32_t * p_58, int32_t  p_59, int32_t  p_60, int16_t  p_61);
static uint32_t  func_62(int32_t * p_63);
static int16_t  func_67(int32_t ** p_68);
static int32_t ** func_69(int32_t ** p_70, int32_t * p_71, uint16_t  p_72);
static int32_t * func_76(int32_t * const  p_77, int32_t  p_78, int32_t  p_79, uint32_t  p_80, uint32_t  p_81);
static uint16_t  func_84(int32_t ** p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    const int32_t l_3 = 1L;
    const int32_t *l_2 = &l_3;
    int32_t *l_5 = (void*)0;
    int32_t **l_4 = &l_5;
    int32_t l_6 = 9L;
    int32_t **l_23 = &l_5;
    int16_t l_47 = 5L;
    int32_t ****l_632 = (void*)0;
    int32_t ***l_634 = &l_23;
    int32_t ****l_633 = &l_634;
    int32_t l_641 = (-1L);
    int32_t l_642 = 0x717B869FL;
    (*l_4) = l_2;
    /* statement id: 1 */
    assert (l_5 == &l_3);
    for (l_6 = 0; (l_6 < (-14)); l_6 = safe_sub_func_int32_t_s_s(l_6, 6))
    { /* block id: 4 */
        int32_t l_22 = 5L;
        int32_t **l_34 = &l_5;
    }
    if (l_6)
        goto lbl_635;
lbl_635:
    (*l_633) = &l_4;
    /* statement id: 242 */
    assert (l_634 == &l_4);
    (**l_634) = func_9((****l_633), (((****l_633) ^ (((((**l_4) != (!(safe_mod_func_int32_t_s_s(((void*)0 != (*l_23)), 0x6054291CL)))) <= ((**l_633) == (void*)0)) != (***l_634)) != 4L)) | 0x8E4B9EBCL), l_641, (*l_5), (**l_23));
    /* statement id: 244 */
    assert (l_5 == 0);
    return l_642;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_9(uint32_t  p_10, int16_t  p_11, int16_t  p_12, uint32_t  p_13, uint32_t  p_14)
{ /* block id: 156 */
    int32_t l_423 = 0xE8802A9FL;
    int32_t *l_422 = &l_423;
    int32_t **l_424 = &l_422;
    const int32_t ***l_430 = (void*)0;
    const int32_t **** const l_429 = &l_430;
    int32_t l_445 = 0L;
    int32_t *l_503 = &l_423;
    int32_t *l_508 = &l_445;
    int32_t *l_509 = &l_445;
    int32_t *l_517 = (void*)0;
    int32_t l_628 = 0x35B44324L;
    uint16_t l_629 = 8UL;
    int32_t *l_630 = &l_628;
    int32_t *l_631 = (void*)0;
    (*l_424) = l_422;
    for (l_423 = 0; (l_423 <= 22); l_423 = safe_add_func_uint32_t_u_u(l_423, 8))
    { /* block id: 160 */
        int32_t l_428 = 0x35532F40L;
        int32_t *l_427 = &l_428;
        int32_t ***l_433 = &l_424;
        int32_t *l_500 = &l_445;
        int32_t *l_504 = &l_423;
        int32_t ** const *l_609 = &l_424;
    }
    (*l_509) = ((((((safe_sub_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_s(((!((((safe_add_func_uint16_t_u_u(1UL, ((((safe_rshift_func_uint16_t_u_s((((safe_rshift_func_uint16_t_u_u(((*l_429) != (*l_429)), ((((void*)0 == &l_430) && p_14) == ((safe_add_func_uint32_t_u_u((p_13 || (((p_11 && (safe_add_func_uint32_t_u_u(((p_14 < p_11) | (*l_503)), 5UL))) < l_628) > p_10)), 1L)) > p_14)))) >= p_11) != p_11), 12)) <= 0x3093L) && (-5L)) < p_14))) < p_14) <= p_11) ^ p_10)) < p_13), 14)) && 0x456BA58EL), 0x23EA2842L)) < (*l_422)) | l_629) != (*l_422)) != 0x4713L) > 5UL);
    return l_631;
    /* statement id: 239 */
    //assert (func_9_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_17(int32_t  p_18, int8_t  p_19, int32_t  p_20, int32_t ** p_21)
{ /* block id: 6 */
    uint32_t l_24 = 0xAF0488F4L;
    int32_t l_26 = 0L;
    int32_t *l_25 = &l_26;
    (*l_25) = (l_24 || p_20);
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_27(int32_t  p_28, int32_t  p_29, uint16_t  p_30, uint16_t  p_31)
{ /* block id: 9 */
    int32_t l_55 = (-5L);
    int32_t *l_54 = &l_55;
    int32_t ***l_402 = (void*)0;
    int32_t l_405 = 0xC8B08591L;
    for (p_30 = 0; (p_30 <= 27); p_30 = safe_add_func_int32_t_s_s(p_30, 1))
    { /* block id: 12 */
        int32_t l_53 = 0x769E8A28L;
        int32_t *l_52 = &l_53;
        int32_t **l_404 = (void*)0;
        int32_t ***l_403 = &l_404;
        int32_t **l_408 = &l_52;
        for (p_29 = 0; (p_29 != (-7)); p_29 = safe_sub_func_int32_t_s_s(p_29, 1))
        { /* block id: 15 */
            uint16_t l_56 = 0xBAC6L;
            l_54 = l_52;
            /* statement id: 16 */
            assert (l_54 == &l_53);
            return l_56;
        }
        (*l_408) = func_57(&l_53, (func_62(&l_55) ^ ((~(safe_add_func_uint16_t_u_u(0x77AAL, ((safe_rshift_func_uint16_t_u_u((((((*l_52) | (safe_unary_minus_func_uint32_t_u((*l_52)))) <= (safe_sub_func_uint32_t_u_u((0x680DL >= (((((safe_add_func_int16_t_s_s((l_402 != l_403), 0x6B98L)) >= p_28) && (*l_52)) != (*l_52)) && l_405)), p_30))) != 1L) == p_29), 1)) <= p_29)))) & 0xDFBEL)), p_31, p_30);
        (*l_54) = (0L || p_31);
        (**l_408) = ((safe_rshift_func_uint16_t_u_u((0x814597CFL | 0x5EA877ABL), (((safe_mod_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((safe_add_func_int16_t_s_s(((void*)0 == &l_402), p_30)) > (safe_rshift_func_int16_t_s_u((*l_54), ((~p_31) >= (safe_sub_func_uint32_t_u_u(((void*)0 == &l_405), (*l_54))))))), p_28)), (*l_54))) >= 0x382AD20DL) >= 0x6D43L))) != (**l_408));
    }
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_57(int32_t * p_58, int32_t  p_59, int32_t  p_60, int16_t  p_61)
{ /* block id: 148 */
    int32_t l_407 = 0xFD125DACL;
    int32_t *l_406 = &l_407;
    (*p_58) = (-1L);
    return p_58;
    /* statement id: 150 */
    //assert (func_57_rv == &l_53 || func_57_rv == &l_428);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_62(int32_t * p_63)
{ /* block id: 19 */
    uint32_t l_64 = 4294967295UL;
    int32_t l_75 = 0L;
    int32_t *l_74 = &l_75;
    int32_t **l_73 = &l_74;
    int32_t l_159 = (-7L);
    int32_t * const *l_172 = &l_74;
    uint32_t l_189 = 0x1418936BL;
    int32_t ***l_258 = &l_73;
    int8_t l_289 = 0x31L;
    uint32_t l_334 = 18446744073709551610UL;
    int32_t *l_350 = (void*)0;
    int8_t l_379 = 1L;
    int16_t l_391 = 0x9281L;
    (*p_63) = (l_64 < l_64);
    for (l_64 = 0; (l_64 > 26); l_64 = safe_add_func_int32_t_s_s(l_64, 4))
    { /* block id: 23 */
        const int16_t l_152 = 0xF4CFL;
        int32_t *l_156 = &l_75;
        int16_t l_179 = 0L;
    }
    if ((safe_lshift_func_uint16_t_u_s((!(safe_add_func_uint32_t_u_u((((1UL != (((!(**l_73)) && (safe_rshift_func_int16_t_s_u((0x05CAL < (safe_unary_minus_func_int16_t_s((-1L)))), 5))) != ((safe_mod_func_uint32_t_u_u(((**l_172) > (safe_unary_minus_func_int16_t_s((((((*l_74) >= ((*l_73) != (*l_172))) && (*l_74)) >= 0xB7FEDFDEL) || 0L)))), (*p_63))) == (*l_74)))) >= 0x1F5B0405L) > 0x7C67L), (*l_74)))), 6)))
    { /* block id: 64 */
        int32_t l_216 = 0L;
        int16_t l_247 = 7L;
        int32_t ***l_257 = &l_73;
    }
    else
    { /* block id: 116 */
        int32_t l_343 = 0x69B819D6L;
        int32_t ***l_347 = &l_73;
        for (l_75 = 11; (l_75 <= (-9)); l_75 = safe_sub_func_uint32_t_u_u(l_75, 1))
        { /* block id: 119 */
            int16_t l_341 = 0x14E5L;
            int32_t l_358 = 0x0D9EC731L;
            int32_t *l_360 = &l_343;
            int32_t * const **l_377 = &l_172;
            int32_t * const ***l_376 = &l_377;
            int32_t **l_382 = (void*)0;
            int32_t **l_383 = (void*)0;
            const int32_t **l_384 = (void*)0;
        }
        (*p_63) = (safe_sub_func_int32_t_s_s((*p_63), ((***l_347) <= (**l_73))));
    }
    for (l_189 = (-2); (l_189 > 17); ++l_189)
    { /* block id: 144 */
        int32_t **l_389 = (void*)0;
        int32_t **l_390 = &l_74;
        (*l_390) = (*l_172);
    }
    return l_391;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_67(int32_t ** p_68)
{ /* block id: 41 */
    uint32_t l_147 = 0xA420BE38L;
    int32_t l_149 = (-1L);
    int32_t *l_148 = &l_149;
    int32_t **l_150 = &l_148;
    uint16_t l_151 = 65527UL;
    (*l_148) = l_147;
    (*l_150) = &l_149;
    (*l_150) = (*l_150);
    return l_151;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_69(int32_t ** p_70, int32_t * p_71, uint16_t  p_72)
{ /* block id: 37 */
    uint16_t l_120 = 0x7B55L;
    uint16_t l_135 = 0x252AL;
    int32_t l_138 = 0x650D96A5L;
    int32_t *l_137 = &l_138;
    int32_t **l_136 = &l_137;
    int32_t **l_139 = &l_137;
    int32_t **l_140 = &l_137;
    int32_t **l_141 = &l_137;
    int32_t **l_142 = &l_137;
    int32_t **l_143 = &l_137;
    int32_t **l_144 = &l_137;
    int32_t **l_145 = &l_137;
    int32_t **l_146 = (void*)0;
    (**p_70) = (p_72 & ((safe_lshift_func_int16_t_s_u((l_120 != (safe_unary_minus_func_int32_t_s(l_120))), ((((safe_sub_func_int32_t_s_s(((safe_mod_func_int16_t_s_s((((p_72 <= (((safe_unary_minus_func_int16_t_s(p_72)) & ((safe_add_func_int16_t_s_s(((((safe_rshift_func_uint16_t_u_u((safe_add_func_uint16_t_u_u((l_120 != (l_120 & ((((((safe_sub_func_int16_t_s_s(((**p_70) > (l_135 & 0x93C24CE6L)), p_72)) | p_72) == l_135) == (**p_70)) == l_135) || l_120))), l_135)), 9)) == l_120) <= 0xB5BCL) <= p_72), l_120)) <= l_120)) && l_135)) == 7UL) | 0xAD18L), p_72)) <= (**p_70)), (**p_70))) | (**p_70)) ^ l_135) & p_72))) || p_72));
    (*p_70) = (void*)0;
    /* statement id: 39 */
    //assert (l_74 == 0);
    return l_146;
    /* statement id: 40 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_55
 * writes:
 */
static int32_t * func_76(int32_t * const  p_77, int32_t  p_78, int32_t  p_79, uint32_t  p_80, uint32_t  p_81)
{ /* block id: 28 */
    int8_t l_100 = 0xBEL;
    int32_t l_102 = 0x983B7C1FL;
    int32_t *l_101 = &l_102;
    int32_t *l_108 = &l_102;
    int32_t *l_110 = &l_102;
    int32_t *l_113 = &l_102;
    int32_t *l_114 = &l_102;
    int32_t *l_115 = &l_102;
    int32_t *l_116 = &l_102;
    int32_t *l_117 = (void*)0;
    for (p_80 = 3; (p_80 < 30); p_80 = safe_add_func_int32_t_s_s(p_80, 1))
    { /* block id: 31 */
        uint32_t l_92 = 0x62BCA918L;
        int32_t *l_105 = (void*)0;
        int32_t **l_106 = (void*)0;
        int32_t **l_107 = &l_105;
        int32_t *l_109 = &l_102;
        int32_t *l_111 = &l_102;
        int32_t *l_112 = (void*)0;
        (*l_101) = (l_92 != ((safe_sub_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_s(((p_78 > 0UL) != ((!0xE2E8L) == (safe_rshift_func_int16_t_s_s((l_100 == l_100), (((l_101 == (void*)0) > (((((safe_lshift_func_int16_t_s_u(0xD59AL, p_79)) ^ (*l_101)) && 0xB26C3A74L) > (*l_101)) >= 0x7B3892EBL)) & (*p_77)))))), 6)) < p_79), l_92)) | (*p_77)));
        (*l_107) = l_105;
        return l_112;
        /* statement id: 34 */
        //assert (func_76_rv == 0);
    }
    return l_117;
    /* statement id: 36 */
    //assert (func_76_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_84(int32_t ** p_85)
{ /* block id: 24 */
    int32_t l_88 = 0x84BAFC8DL;
    int32_t *l_89 = &l_88;
    l_88 = (safe_mod_func_int32_t_s_s(l_88, (l_88 ^ ((*p_85) == &l_88))));
    l_89 = (*p_85);
    /* statement id: 26 */
    //assert (l_89 == &l_75);
    return (*l_89);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 145
XXX total union variables: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 15, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 23, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 124

XXX times a variable address is taken: 118
XXX times a pointer is dereferenced on RHS: 211
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 58
   depth: 3, occurrence: 30
   depth: 4, occurrence: 21
XXX times a pointer is dereferenced on LHS: 68
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 16
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 34
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 814

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 183
   level: 2, occurrence: 112
   level: 3, occurrence: 53
   level: 4, occurrence: 31
XXX number of pointers point to pointers: 66
XXX number of pointers point to scalars: 58
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29
XXX average alias set size: 1.19

XXX times a non-volatile is read: 953
XXX times a non-volatile is write: 200
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 45
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 10
   depth: 2, occurrence: 2

XXX percentage a fresh-made variable is used: 10.4
XXX percentage an existing variable is used: 89.6
********************* end of statistics **********************/

