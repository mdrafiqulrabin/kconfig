/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2793025169
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   const uint32_t  f1;
   uint16_t  f2;
   int16_t  f3;
   uint32_t  f4;
   signed f5 : 5;
   uint32_t  f6;
   uint16_t  f7;
};

union U1 {
   int16_t  f0;
   const uint16_t  f1;
   float  f2;
   float  f3;
   int32_t  f4;
};

union U2 {
   uint32_t  f0;
   signed f1 : 8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_32(void);
inline static int32_t * func_33(const int32_t  p_34, struct S0  p_35);
static struct S0  func_37(union U1  p_38);
inline static int16_t  func_40(const int32_t * p_41, const uint32_t  p_42, int32_t  p_43);
inline static int32_t * func_44(union U2  p_45, union U2  p_46, const int16_t  p_47);
static union U2  func_48(const int32_t * p_49, uint16_t  p_50, int16_t  p_51, uint16_t  p_52);
inline static int16_t  func_80(int32_t  p_81, float  p_82, uint16_t  p_83, int16_t  p_84, int32_t * p_85);
inline static float ** func_93(const int32_t * p_94);
inline static union U2  func_95(int32_t * p_96, struct S0  p_97, union U2  p_98);
inline static int32_t * func_99(float * p_100, int32_t  p_101, uint16_t  p_102, const int32_t * p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_32(void)
{ /* block id: 36 */
    uint32_t l_36 = 8U;
    union U1 l_39 = {0x3E32};
    int32_t *l_943 = &l_39.f4;
    l_943 = func_33((l_36 | 4294967289U), func_37(l_39));
    /* statement id: 527 */
    assert (l_943 == 0);
    return l_39;
    /* statement id: 528 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_33(const int32_t  p_34, struct S0  p_35)
{ /* block id: 372 */
    int16_t l_696 = 0xB23B;
    float l_712 = 0xD.384494p+88;
    float *l_711 = &l_712;
    struct S0 l_721 = {0x009324F8,4294967286U,0U,0,0x5A8A51BE,-4,0xC0A4F6E1,65535U};
    struct S0 *l_720 = &l_721;
    float *****l_733 = (void*)0;
    union U1 l_755 = {0xBBA3};
    union U1 *l_754 = &l_755;
    int32_t l_761 = (-1);
    struct S0 **l_768 = (void*)0;
    struct S0 ***l_767 = &l_768;
    union U2 l_807 = {1U};
    int32_t *l_809 = &l_721.f0;
    int32_t **l_812 = &l_809;
    int32_t *l_830 = &l_721.f0;
    int32_t ***l_881 = &l_812;
    int32_t ****l_880 = &l_881;
    int32_t *****l_879 = &l_880;
    int32_t *l_927 = &l_721.f0;
    int32_t *l_928 = &l_721.f0;
    int32_t *l_929 = &l_721.f0;
    int32_t *l_930 = &l_721.f0;
    int32_t *l_932 = &l_721.f0;
    int32_t *l_933 = &l_721.f0;
    int32_t *l_934 = (void*)0;
    int32_t *l_941 = &l_721.f0;
    int32_t *l_942 = (void*)0;
    if (l_696)
    { /* block id: 373 */
        int32_t l_701 = 0xBCCE20BB;
        struct S0 l_719 = {1,0x5BBF1EC9,1U,0x9F2A,4294967294U,3,0U,65535U};
        struct S0 *l_718 = &l_719;
        union U2 l_737 = {0xC3E0866E};
        union U2 *l_736 = &l_737;
        union U1 l_750 = {0xA474};
        union U1 *l_749 = &l_750;
        struct S0 **l_766 = &l_720;
        struct S0 ***l_765 = &l_766;
        float *l_769 = &l_712;
        int32_t **l_800 = (void*)0;
        int32_t *l_802 = &l_719.f0;
        int32_t **l_801 = &l_802;
        float l_808 = 0x5.3p-1;
        for (p_35.f2 = 19; (p_35.f2 >= 10); p_35.f2 -= 7)
        { /* block id: 376 */
            const int32_t l_715 = (-2);
            const int32_t *l_788 = &l_715;
            for (p_35.f0 = 0; (p_35.f0 > 24); p_35.f0++)
            { /* block id: 379 */
                int32_t *l_702 = &l_701;
                (*l_702) = l_701;
            }
            if ((((int16_t)(((((uint16_t)(p_35.f3 > l_701) - (uint16_t)(((uint32_t)(((uint16_t)(0x5C39 | (p_35.f6 >= p_35.f0)) >> (uint16_t)11) != ((void*)0 != l_711)) - (uint32_t)0x46671369) | ((((((int32_t)(0xC938 > p_35.f6) % (int32_t)l_696) == 4294967287U) <= l_715) || 0x59713CEF) && 0x1300BDF2))) ^ l_715) == l_701) <= l_715) << (int16_t)p_35.f2) || p_35.f6))
            { /* block id: 382 */
                const int32_t *l_722 = (void*)0;
                float **l_732 = &l_711;
                float ***l_731 = &l_732;
                float ****l_730 = &l_731;
                float *****l_729 = &l_730;
                int32_t *l_734 = &l_721.f0;
                int32_t **l_735 = &l_734;
                for (p_35.f7 = 0; (p_35.f7 != 14); p_35.f7 += 7)
                { /* block id: 385 */
                    int32_t *l_724 = &l_701;
                    int32_t **l_723 = &l_724;
                    l_720 = l_718;
                    /* statement id: 386 */
                    assert (l_720 == &l_719);
                    (*l_723) = l_722;
                    /* statement id: 387 */
                    assert (l_724 == 0);
                    if (l_719.f2)
                    { /* block id: 388 */
                        struct S0 **l_725 = (void*)0;
                        struct S0 **l_726 = &l_720;
                        (*l_726) = &p_35;
                        /* statement id: 389 */
                        assert (l_720 == &p_35);
                        (*l_723) = &l_701;
                        /* statement id: 390 */
                        assert (l_724 == &l_701);
                        (*l_724) = p_35.f0;
                    }
                    else
                    { /* block id: 392 */
                        int32_t *l_727 = (void*)0;
                        int32_t *l_728 = &l_701;
                        (*l_728) = p_35.f1;
                        if (l_719.f0)
                            continue;
                    }
                    /* facts after branching */
                    assert (l_720 == &l_719 || l_720 == &p_35);
                    assert (l_724 == 0 || l_724 == &l_701);
                    if (l_719.f2)
                        break;
                }
                (*l_734) = (l_729 == l_733);
                (*l_735) = &l_715;
                /* statement id: 399 */
                assert (l_734 == &l_715);
                l_736 = l_736;
            }
            else
            { /* block id: 401 */
                float *l_744 = &l_712;
                int32_t *l_748 = &l_719.f0;
                int32_t **l_747 = &l_748;
                int32_t ***l_746 = &l_747;
                int32_t ****l_745 = &l_746;
                for (l_696 = 0; (l_696 <= 18); l_696++)
                { /* block id: 404 */
                    const union U1 **l_741 = (void*)0;
                    int32_t *l_742 = &l_701;
                    union U2 **l_764 = (void*)0;
                    if ((l_715 <= ((-(int16_t)p_35.f3) ^ ((void*)0 != l_741))))
                    { /* block id: 405 */
                        int32_t **l_743 = &l_742;
                        union U1 **l_751 = (void*)0;
                        union U1 **l_752 = (void*)0;
                        union U1 **l_753 = (void*)0;
                        (*l_743) = l_742;
                        l_742 = func_99(l_744, p_35.f2, (((void*)0 != l_745) | p_35.f7), &l_701);
                        /* statement id: 407 */
                        assert (l_742 == 0);
                        l_754 = l_749;
                        /* statement id: 408 */
                        assert (l_754 == &l_750);
                    }
                    else
                    { /* block id: 409 */
                        int16_t l_758 = 0xA872;
                        (*l_744) = ((float)0xB.E8F890p-5 + (float)((l_758 > ((float)l_761 - (float)(0x6.A014E1p+51 == 0x9.BBBDE9p+14))) >= ((float)0x9.2p+1 - (float)(l_764 != &l_736))));
                        if (p_35.f3)
                            break;
                        if (p_35.f6)
                            break;
                    }
                    /* facts after branching */
                    assert (l_742 == &l_701 || l_742 == 0);
                }
                if (p_34)
                    continue;
                (*l_711) = (p_34 < ((0x8.63641Dp-77 <= p_35.f6) > (l_737.f1 <= (l_765 != l_767))));
                (***l_745) = l_711;
                /* statement id: 417 */
                assert (l_748 == &l_712);
            }
            if (((l_737.f1 >= l_755.f1) ^ (l_715 && p_35.f2)))
            { /* block id: 419 */
                uint16_t l_787 = 0U;
                int32_t *l_789 = &l_719.f0;
                l_789 = func_99(l_769, (((int32_t)(p_35.f4 || ((uint16_t)((int16_t)(!(((int16_t)l_719.f4 << (int16_t)p_34) == ((uint16_t)__builtin_popcountl(p_35.f4) >> (uint16_t)14))) >> (int16_t)13) - (uint16_t)((uint16_t)((int16_t)((uint16_t)((l_719.f6 != ((((l_787 <= l_721.f6) && l_719.f4) | l_787) != l_787)) <= l_719.f2) >> (uint16_t)l_715) >> (int16_t)6) + (uint16_t)0U))) % (int32_t)l_787) == p_35.f1), p_35.f1, l_788);
                /* statement id: 420 */
                assert (l_789 == 0);
                l_755.f4 = p_35.f7;
                /* statement id: 421 */
                                if (p_35.f2)
                    break;
            }
            else
            { /* block id: 423 */
                const union U1 *l_791 = &l_755;
                const union U1 **l_790 = &l_791;
                int32_t *l_799 = (void*)0;
                int32_t **l_798 = &l_799;
                (*l_790) = (void*)0;
                /* statement id: 424 */
                assert (l_791 == 0);
                for (l_719.f7 = 0; (l_719.f7 >= 18); ++l_719.f7)
                { /* block id: 427 */
                    uint32_t l_794 = 8U;
                    int32_t *l_795 = (void*)0;
                    int32_t *l_796 = (void*)0;
                    int32_t l_797 = (-1);
                    l_797 = (((*l_788) < p_35.f2) | (l_794 <= l_721.f0));
                    p_35.f0 = (l_798 == &l_795);
                }
            }
        }
        /* facts after for loop */
        assert (l_720 == &l_719 || l_720 == &p_35 || l_720 == &l_721);
        assert (l_754 == &l_755 || l_754 == &l_750);
        l_721.f5 = (l_719.f0 > 0x1.Cp+1);
        (*l_801) = &l_701;
        /* statement id: 434 */
        assert (l_802 == &l_701);
        if ((!(**l_801)))
        { /* block id: 435 */
            float l_806 = 0x1.3p-1;
            (*l_711) = ((float)l_806 + (float)l_721.f5);
        }
        else
        { /* block id: 437 */
            l_809 = func_44(l_807, l_807, (7 && p_34));
            /* statement id: 438 */
            assert (l_809 == 0);
            (*l_711) = 0x2.D4E48Cp+66;
        }
        /* facts after branching */
        assert (l_809 == 0 || l_809 == &l_721.f0);
    }
    else
    { /* block id: 441 */
        uint16_t l_818 = 0x8E9E;
        int32_t *l_827 = &l_721.f0;
        int32_t *l_831 = &l_721.f0;
        int32_t *l_832 = &l_721.f0;
        int32_t *l_834 = &l_721.f0;
        float ****l_843 = (void*)0;
        union U2 l_853 = {0xD7F09968};
        const int32_t *l_860 = &l_721.f0;
        struct S0 *l_887 = &l_721;
        union U2 **l_925 = (void*)0;
        union U2 ***l_924 = &l_925;
        int32_t *l_931 = &l_721.f0;
        for (l_721.f4 = (-4); (l_721.f4 != 18); l_721.f4++)
        { /* block id: 444 */
            union U2 *l_826 = (void*)0;
            union U2 **l_825 = &l_826;
            union U2 *** const l_824 = &l_825;
            int32_t *l_828 = &l_721.f0;
            int32_t *l_829 = &l_721.f0;
            int32_t *l_833 = &l_721.f0;
            int32_t *l_835 = (void*)0;
            int32_t ***l_878 = &l_812;
            int32_t ****l_877 = &l_878;
            int32_t *****l_876 = &l_877;
            float l_906 = 0xA.CEF07Cp-56;
            int32_t *l_926 = &l_721.f0;
            l_812 = &l_809;
        }
        l_887 = &p_35;
        /* statement id: 516 */
        assert (l_887 == &p_35);
        (****l_879) = (void*)0;
        /* statement id: 517 */
        assert (l_809 == 0);
        return l_934;
        /* statement id: 518 */
        //assert (func_33_rv == 0);
    }
    /* facts after branching */
    //assert (l_720 == dangling || l_720 == &p_35 || l_720 == &l_721);
    //assert (l_754 == &l_755 || l_754 == dangling);
    assert (l_809 == 0 || l_809 == &l_721.f0);
    for (l_807.f0 = 0; (l_807.f0 >= 49); l_807.f0 += 1)
    { /* block id: 522 */
        struct S0 * const *l_940 = (void*)0;
        struct S0 * const **l_939 = &l_940;
        struct S0 * const ***l_938 = &l_939;
        struct S0 * const ****l_937 = &l_938;
        (*l_711) = 0x4.852A13p+73;
        (*l_937) = &l_767;
        /* statement id: 524 */
        assert (l_938 == &l_767);
    }
    return l_942;
    /* statement id: 526 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_37(union U1  p_38)
{ /* block id: 37 */
    int32_t l_54 = (-1);
    const int32_t *l_53 = &l_54;
    union U2 l_62 = {0U};
    uint32_t l_585 = 1U;
    union U2 ****l_606 = (void*)0;
    float **l_607 = (void*)0;
    union U2 *l_620 = &l_62;
    union U2 **l_619 = &l_620;
    float *l_630 = (void*)0;
    const union U2 *l_677 = &l_62;
    const union U2 **l_676 = &l_677;
    const union U2 *** const l_675 = &l_676;
    const union U2 *** const *l_674 = &l_675;
    const union U2 *** const **l_673 = &l_674;
    struct S0 l_695 = {3,0xD1453F94,0x8F07,1,1U,2,0x6DEDC025,0x0606};
    if (((p_38.f0 > func_40(func_44(func_48(l_53, __builtin_bswap64(p_38.f1), __builtin_ctzl(p_38.f1), p_38.f1), l_62, (*l_53)), (*l_53), p_38.f1)) > 0x7F41))
    { /* block id: 47 */
        union U2 l_73 = {4294967290U};
        int32_t *l_75 = &l_54;
        int32_t l_92 = 0xCA43862D;
        uint32_t l_586 = 0x4AB9A405;
        const int32_t **l_587 = &l_53;
        struct S0 l_610 = {0x206A8179,0x64828640,0xA72A,1,1U,3,0xBB2FA915,0x9356};
        union U2 l_612 = {0x1C088964};
        (*l_587) = func_44(l_73, l_73, __builtin_parityl(__builtin_bswap32(((((!((void*)0 == l_75)) > (((int32_t)(-7) + (int32_t)(((((((int16_t)func_80(((int16_t)p_38.f1 << (int16_t)((uint32_t)((*l_53) < ((int16_t)((((&l_54 != &l_54) >= 0xFDD8C90C) >= p_38.f1) & 6) << (int16_t)1)) + (uint32_t)p_38.f0)), p_38.f0, p_38.f1, l_92, &l_92) << (int16_t)15) <= p_38.f1) | l_585) & (*l_75)) == p_38.f0) & p_38.f1)) < l_586)) >= 0x22A5) ^ p_38.f0))));
        /* statement id: 303 */
        assert (l_53 == 0);
        for (l_73.f0 = 0; (l_73.f0 >= 38); l_73.f0++)
        { /* block id: 306 */
            int32_t *l_590 = &l_92;
            union U1 l_595 = {0x0599};
            union U1 *l_594 = &l_595;
            struct S0 l_611 = {0xAA52B89B,0U,0x0630,0x20F8,8U,0,1U,0xEB73};
            (*l_587) = l_590;
            /* statement id: 307 */
            assert (l_53 == &l_92);
            for (l_586 = 29; (l_586 > 37); l_586++)
            { /* block id: 310 */
                const float l_593 = 0x4.4p-1;
                if (p_38.f0)
                    break;
                (*l_587) = &l_54;
                /* statement id: 312 */
                assert (l_53 == &l_54);
            }
            /* facts after for loop */
            assert (l_53 == &l_54 || l_53 == &l_92);
            if (func_40((*l_587), ((**l_587) != p_38.f1), (**l_587)))
            { /* block id: 314 */
                const uint16_t l_598 = 0xC34B;
                l_594 = (void*)0;
                /* statement id: 315 */
                assert (l_594 == 0);
                for (l_62.f0 = 16; (l_62.f0 >= 5); l_62.f0 -= 8)
                { /* block id: 318 */
                    float *l_599 = &l_595.f3;
                    union U2 *l_605 = &l_62;
                    union U2 **l_604 = &l_605;
                    union U2 ***l_603 = &l_604;
                    union U2 *** const *l_602 = &l_603;
                    (*l_599) = l_598;
                    /* statement id: 319 */
                                        if (p_38.f1)
                        continue;
                    (*l_75) = ((int32_t)((l_602 != l_606) || (l_607 != (void*)0)) + (int32_t)(*l_53));
                    for (l_595.f0 = 0; (l_595.f0 > 24); l_595.f0 += 8)
                    { /* block id: 324 */
                        p_38.f2 = __builtin_bswap32((p_38.f1 > (*l_53)));
                        /* statement id: 325 */
                                                return l_610;
                    }
                    /* facts after for loop */
                                    }
                return l_611;
            }
            else
            { /* block id: 330 */
                (*l_590) = (*l_53);
            }
            (*l_587) = &l_54;
            /* statement id: 333 */
            assert (l_53 == &l_54);
        }
        /* facts after for loop */
        assert (l_53 == &l_54 || l_53 == 0);
        l_53 = &l_54;
        /* statement id: 335 */
        assert (l_53 == &l_54);
        (*l_587) = func_44(l_612, l_73, p_38.f1);
        /* statement id: 336 */
        assert (l_53 == 0);
    }
    else
    { /* block id: 337 */
        const int32_t *l_624 = &l_54;
        float *l_625 = (void*)0;
        float l_627 = (-0x5.Ep+1);
        float *l_626 = &l_627;
        float *l_631 = &l_627;
        union U1 l_652 = {0};
        union U1 *l_651 = &l_652;
        union U2 * const l_654 = &l_62;
        float ***l_666 = &l_607;
        float ****l_665 = &l_666;
        float *****l_664 = &l_665;
        struct S0 l_669 = {0x6DF89949,0xEF2F5C43,0xC3F7,1,4294967295U,0,4294967294U,0xCBC1};
        union U2 l_690 = {0x94C7BD57};
    }
    /* facts after branching */
    assert (l_53 == &l_54 || l_53 == 0);
    return l_695;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_40(const int32_t * p_41, const uint32_t  p_42, int32_t  p_43)
{ /* block id: 44 */
    float l_71 = 0x0.Cp+1;
    float *l_70 = &l_71;
    int32_t l_72 = 1;
    (*l_70) = p_43;
    return l_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_44(union U2  p_45, union U2  p_46, const int16_t  p_47)
{ /* block id: 41 */
    int32_t l_64 = 0xADCFEC76;
    int32_t *l_63 = &l_64;
    int32_t *l_65 = &l_64;
    int32_t *l_66 = &l_64;
    int32_t *l_67 = &l_64;
    int32_t *l_68 = &l_64;
    int32_t *l_69 = (void*)0;
    (*l_63) = (__builtin_parityll(((l_63 == &l_64) <= __builtin_clzll(p_46.f1))) != 0x84E2BBA6);
    return l_69;
    /* statement id: 43 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_92 l_54 l_721.f0
 * writes:
 */
static union U2  func_48(const int32_t * p_49, uint16_t  p_50, int16_t  p_51, uint16_t  p_52)
{ /* block id: 38 */
    int16_t l_57 = 0x20BA;
    int32_t l_60 = 0x17D239F9;
    int32_t *l_59 = &l_60;
    union U2 l_61 = {6U};
    (*l_59) = ((uint16_t)p_50 >> (uint16_t)(__builtin_parityll(l_57) >= __builtin_ffs((-(int32_t)(*p_49)))));
    return l_61;
    /* statement id: 40 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_80(int32_t  p_81, float  p_82, uint16_t  p_83, int16_t  p_84, int32_t * p_85)
{ /* block id: 48 */
    union U2 l_104 = {0x0D489CA1};
    int32_t l_106 = 1;
    int32_t *l_105 = &l_106;
    struct S0 l_167 = {-3,0xD5A05CCE,65533U,0x6AEA,2U,-2,0xD8D5C70F,0x1DEE};
    float *l_543 = (void*)0;
    float **l_542 = &l_543;
    int32_t **l_575 = &l_105;
    int32_t ***l_574 = &l_575;
    int32_t ****l_573 = &l_574;
    uint32_t l_576 = 0xACBC9FF6;
    int16_t l_577 = 0x79E9;
    int32_t l_584 = 8;
lbl_546:
    l_542 = func_93(func_44(func_95(func_99(func_44(l_104, l_104, (*l_105)), (*l_105), (*l_105), &l_106), l_167, l_104), l_104, (*l_105)));
    /* statement id: 286 */
    assert (l_542 == 0);
    for (l_106 = 7; (l_106 >= (-10)); --l_106)
    { /* block id: 289 */
        uint32_t l_547 = 0x6DE8D5FA;
        const union U2 * const l_551 = &l_104;
        const union U2 *l_552 = &l_104;
        if (l_167.f7)
            goto lbl_546;
        if ((l_547 > ((*p_85) && (*l_105))))
        { /* block id: 291 */
            uint32_t l_550 = 8U;
            l_550 = ((float)p_83 - (float)(*l_105));
            if (l_167.f1)
                goto lbl_546;
            l_552 = l_551;
        }
        else
        { /* block id: 295 */
            float *l_553 = (void*)0;
            float l_555 = 0x2.C15E10p-79;
            float *l_554 = &l_555;
            int32_t l_562 = 0xF4CF7399;
            (*l_554) = (__builtin_ffsll(p_83) < (*l_105));
            (*l_554) = ((((float)((*l_105) < (((float)((float)l_562 + (float)0x0.2E4D05p-5) - (float)((0x1.0B24FDp-81 == ((float)p_84 - (float)(__builtin_ia32_crc32qi((((int32_t)((int16_t)((int32_t)((*l_105) >= ((*p_85) >= (l_573 != &l_574))) + (int32_t)l_547) % (int16_t)0x7283) - (int32_t)0x662D2B78) & (****l_573)), l_576) >= (-0x1.6p+1)))) != p_84)) > 0x1.6p-1)) - (float)p_81) == 0xE.BEE710p+93) <= l_577);
            (***l_573) = func_44(func_48(p_85, p_81, (((uint16_t)__builtin_ctz(l_562) >> (uint16_t)13) != ((int16_t)0x6F44 << (int16_t)((int16_t)p_81 >> (int16_t)6))), p_84), l_104, l_547);
            /* statement id: 298 */
            assert (l_105 == 0);
        }
        /* facts after branching */
        assert (l_105 == 0 || l_105 == &l_106);
        return l_584;
    }
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float ** func_93(const int32_t * p_94)
{ /* block id: 277 */
    int32_t l_524 = 0xCEC235C9;
    struct S0 **l_531 = (void*)0;
    struct S0 ***l_530 = &l_531;
    float l_537 = 0x3.Ep+1;
    float *l_536 = &l_537;
    float **l_535 = &l_536;
    float **l_538 = &l_536;
    float **l_539 = &l_536;
    float **l_540 = &l_536;
    float **l_541 = (void*)0;
    for (l_524 = 0; (l_524 <= (-13)); l_524 -= 9)
    { /* block id: 280 */
        float l_529 = (-0x1.0p+1);
        float *l_532 = &l_529;
        const int32_t l_533 = 0xA7911EC5;
        const float l_534 = 0x3.24F3BAp-49;
        (*l_532) = (((l_524 >= l_524) >= ((l_524 < ((float)l_529 - (float)l_524)) != ((void*)0 == l_530))) <= l_524);
        (*l_532) = (func_40(p_94, l_533, l_533) > (l_533 == l_534));
        if (l_524)
            break;
    }
    return l_541;
    /* statement id: 285 */
    //assert (func_93_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_95(int32_t * p_96, struct S0  p_97, union U2  p_98)
{ /* block id: 73 */
    uint32_t l_170 = 1U;
    int32_t l_172 = 0xFC066829;
    int32_t *l_171 = &l_172;
    float *l_176 = (void*)0;
    float **l_175 = &l_176;
    int32_t **l_235 = &l_171;
    union U2 l_245 = {0U};
    union U2 *l_244 = &l_245;
    const int32_t *l_298 = (void*)0;
    union U2 **l_339 = (void*)0;
    union U2 *** const l_338 = &l_339;
    int32_t *l_345 = &l_172;
    int32_t ** const *l_368 = &l_235;
    int32_t ** const **l_367 = &l_368;
    float l_422 = 0x0.2p-1;
    union U1 l_443 = {4};
    const union U1 *l_442 = &l_443;
    union U2 ***l_461 = &l_339;
    union U2 ****l_460 = &l_461;
    union U2 *****l_459 = &l_460;
    struct S0 l_502 = {-7,0U,0xAF48,7,8U,0,0U,0xB971};
    struct S0 *l_501 = &l_502;
    struct S0 **l_500 = &l_501;
    (*l_171) = ((uint32_t)l_170 + (uint32_t)l_170);
    return p_98;
    /* statement id: 276 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_99(float * p_100, int32_t  p_101, uint16_t  p_102, const int32_t * p_103)
{ /* block id: 49 */
    int32_t l_111 = 0x6F1E831F;
    int32_t l_124 = 0xE8C007EE;
    int32_t *l_123 = &l_124;
    int32_t **l_160 = &l_123;
    int32_t *l_161 = &l_124;
    int32_t *l_162 = &l_124;
    int32_t *l_163 = &l_124;
    int32_t *l_164 = &l_124;
    int32_t *l_165 = &l_124;
    int32_t *l_166 = (void*)0;
    for (p_101 = 0; (p_101 <= 27); p_101 += 6)
    { /* block id: 52 */
        int32_t * const *l_110 = (void*)0;
        int32_t * const **l_109 = &l_110;
        int32_t l_122 = 0xD0AB3BAA;
        int32_t *l_121 = &l_122;
        (*l_109) = &p_103;
        /* statement id: 53 */
        assert (l_110 == &p_103);
    }
    if (((-(uint32_t)((*l_123) == __builtin_parityl((*l_123)))) > (((((((int16_t)((uint16_t)__builtin_ffs((((uint16_t)(((((uint32_t)((-(uint16_t)((-(int16_t)(*l_123)) != ((int32_t)(*p_103) + (int32_t)p_101))) != (-1)) + (uint32_t)4294967287U) ^ ((*l_123) == (*p_103))) && p_101) || 0x8DB6) >> (uint16_t)p_101) & p_102)) >> (uint16_t)(*l_123)) >> (int16_t)11) | 0x26EC4865) || (-1)) <= (*l_123)) >= 65535U) && (*l_123))))
    { /* block id: 67 */
        const int32_t *l_140 = &l_124;
        p_101 = func_40(l_140, (*l_123), (*l_140));
    }
    else
    { /* block id: 69 */
        uint16_t l_151 = 1U;
        (*l_123) = ((uint16_t)((int16_t)((uint16_t)((uint32_t)((uint16_t)(((l_151 & (*l_123)) & 0U) || ((uint16_t)((0xCB49 < (((int16_t)l_151 % (int16_t)(((int16_t)((void*)0 == &p_101) << (int16_t)10) | (*p_103))) & ((uint16_t)(l_160 == (void*)0) + (uint16_t)65535U))) && (*l_123)) >> (uint16_t)p_101)) << (uint16_t)15) + (uint32_t)0x64999BD3) << (uint16_t)10) + (int16_t)65530U) << (uint16_t)1);
    }
    return l_166;
    /* statement id: 72 */
    //assert (func_99_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 269
   depth: 1, occurrence: 7
XXX total union variables: 18

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 60
breakdown:
   indirect level: 0, occurrence: 23
   indirect level: 1, occurrence: 15
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 10
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 27
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 61
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 24

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 117
   depth: 2, occurrence: 20
   depth: 3, occurrence: 3
   depth: 4, occurrence: 5
   depth: 5, occurrence: 5
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 302

XXX times a variable address is taken: 274
XXX times a pointer is dereferenced on RHS: 122
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 7
   depth: 3, occurrence: 8
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 129
breakdown:
   depth: 1, occurrence: 112
   depth: 2, occurrence: 9
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 653

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 487
   level: 2, occurrence: 41
   level: 3, occurrence: 39
   level: 4, occurrence: 24
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 151
XXX number of pointers point to scalars: 118
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 26.5
XXX average alias set size: 1.22

XXX times a non-volatile is read: 1026
XXX times a non-volatile is write: 372
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 8

XXX stmts: 107
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 23
   depth: 1, occurrence: 23
   depth: 2, occurrence: 17
   depth: 3, occurrence: 20
   depth: 4, occurrence: 11
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 17
XXX percentage an existing variable is used: 83
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

