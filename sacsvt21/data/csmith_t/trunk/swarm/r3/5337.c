/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2492461559
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   int32_t  f1;
   int32_t  f2;
   float  f3;
   float  f4;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0x885C6F1BL;
static int32_t g_5 = 0x6DD8D130L;
static volatile float g_93 = 0x1.Cp-1;/* VOLATILE GLOBAL g_93 */
static volatile uint16_t g_102 = 0x0BBFL;/* VOLATILE GLOBAL g_102 */
static float g_141 = 0x0.2p-1;
static volatile union U0 g_191 = {18446744073709551615UL};/* VOLATILE GLOBAL g_191 */
static volatile union U0 *g_190 = &g_191;
static volatile union U0 **g_189 = &g_190;
static volatile int32_t g_197 = 0x79715980L;/* VOLATILE GLOBAL g_197 */
static volatile int32_t *g_196 = &g_197;
static volatile int32_t **g_195 = &g_196;
static int32_t g_262 = 0L;
static union U0 g_280 = {0x0C2F07F0L};
static int32_t *g_355 = (void*)0;
static volatile int32_t ***g_407 = &g_195;
static volatile int32_t ****g_406 = &g_407;
static volatile uint32_t g_418 = 1UL;/* VOLATILE GLOBAL g_418 */
static int32_t **g_420 = &g_355;
static volatile union U0 *****g_678 = (void*)0;
static int32_t g_706 = 0x526AD30FL;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static union U0  func_8(uint32_t  p_9);
static int16_t  func_12(uint16_t  p_13, uint16_t  p_14, uint32_t  p_15);
static uint16_t  func_17(uint16_t  p_18, int32_t  p_19, uint32_t  p_20);
static int16_t  func_21(int16_t  p_22, union U0  p_23, int32_t  p_24, union U0  p_25);
static uint32_t  func_26(int16_t  p_27);
static uint32_t  func_33(float  p_34, uint32_t  p_35, uint16_t  p_36);
static uint32_t  func_37(uint32_t  p_38, int16_t  p_39, union U0  p_40);
static int16_t  func_50(uint32_t  p_51, uint16_t  p_52, uint32_t  p_53, uint32_t  p_54);
static uint32_t  func_55(int16_t  p_56, uint32_t  p_57, int32_t  p_58, uint32_t  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_5 g_407 g_195 g_196 g_197 g_406 g_706
 * writes: g_2 g_5
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_273 = 0UL;
    float *l_608 = &g_141;
    int32_t l_612 = 0xDBA571DFL;
    union U0 *l_700 = &g_280;
    for (g_2 = 0; (g_2 < (-21)); g_2 -= 8)
    { /* block id: 3 */
        float l_16 = 0x4.9B1AB4p+68;
        int32_t l_276 = 0x4108AC6AL;
        union U0 l_281 = {0x40A0E336L};
        union U0 *l_639 = &g_280;
        union U0 **l_638 = &l_639;
        float l_641 = 0xB.D7DE35p-99;
        float l_644 = 0xB.B9211Bp+50;
        for (g_5 = 14; (g_5 > (-17)); g_5 -= 1)
        { /* block id: 6 */
            uint32_t l_279 = 4294967295UL;
            int32_t *l_578 = &g_262;
            union U0 *l_611 = &g_280;
            union U0 **l_610 = &l_611;
            union U0 ***l_609 = &l_610;
            int32_t **l_623 = &g_355;
        }
        (*l_638) = (*l_638);
    }
    l_612 = (((int16_t)((uint32_t)((l_612 <= l_612) <= 65533UL) + (uint32_t)(l_273 , ((int16_t)((((-(int32_t)(((uint16_t)((uint16_t)((***g_407) == (l_700 == l_700)) << (uint16_t)0) / (uint16_t)((-(uint32_t)1UL) , ((int16_t)((uint32_t)((((g_2 ^ l_273) || l_612) ^ 0x112B45B9L) & 8UL) % (uint32_t)l_273) >> (int16_t)5))) && (****g_406))) | 0x1DCDB2F4L) || g_2) <= g_2) >> (int16_t)8))) * (int16_t)g_706) || 0x9244L);
    return l_273;
}


/* ------------------------------------------ */
/* 
 * reads : g_189 g_190 g_280.f2 g_406 g_407 g_195 g_196 g_197 g_5 g_280.f0 g_2 g_280.f1 g_280 g_191.f0 g_280.f4 g_262 g_420
 * writes: g_355 g_197 g_141 g_196 g_280.f3
 */
static union U0  func_8(uint32_t  p_9)
{ /* block id: 186 */
    int32_t **l_515 = &g_355;
    union U0 *l_516 = &g_280;
    uint16_t l_521 = 3UL;
    int32_t *l_558 = &g_5;
    if ((((int16_t)(1UL | (((int32_t)0x7BF902DEL + (int32_t)(l_515 != (void*)0)) <= p_9)) + (int16_t)(l_516 != (p_9 , (*g_189)))) > ((void*)0 == l_516)))
    { /* block id: 187 */
        int32_t *l_519 = &g_280.f2;
        union U0 **l_528 = &l_516;
        float *l_529 = &g_141;
        for (p_9 = 0; (p_9 < 47); p_9 += 1)
        { /* block id: 190 */
            (*l_515) = l_519;
            /* statement id: 191 */
            assert (g_355 == &g_280.f2);
        }
        /* facts after for loop */
        //assert (g_355 == &g_280.f2 || g_355 == 0 || g_355 == dangling);
        (****g_406) = (*l_519);
        (*l_529) = ((-(float)((((***g_406) == (((l_521 , (void*)0) == l_516) , l_519)) <= (((float)((((float)(((float)((((-3L) & (l_528 != (void*)0)) & ((g_197 < 0xEFF77A4FL) != g_5)) , p_9) - (float)g_280.f0) < p_9) + (float)(*l_519)) < p_9) == p_9) + (float)g_2) == p_9)) <= g_280.f1)) != g_280.f2);
        (*g_195) = (***g_406);
    }
    else
    { /* block id: 196 */
        uint32_t l_546 = 0x4B9D06EDL;
        float *l_552 = &g_280.f3;
        int32_t ***l_557 = &g_420;
        (****g_406) = ((l_521 ^ (((int16_t)((*l_516) , ((uint16_t)((void*)0 == (*g_189)) * (uint16_t)(((int16_t)(((((((int32_t)(((((uint16_t)((uint32_t)((uint16_t)g_280.f0 * (uint16_t)65535UL) - (uint32_t)(l_546 && ((((((((((float)0x3.2p-1 - (float)(-(float)((float)(p_9 < l_546) + (float)0xB.08E9AEp-81))) < p_9) >= g_191.f0) != g_280.f4) , (void*)0) != (void*)0) <= p_9) , (***g_407)) ^ p_9))) << (uint16_t)6) | p_9) < 0x7B81L) ^ p_9) % (int32_t)l_521) && l_521) <= 0UL) , g_262) != 0x933F47DFL) && g_5) << (int16_t)5) & 0xD59CB7FDL))) * (int16_t)(-10L)) , 0xF7A0L)) & 1UL);
        (*l_552) = p_9;
        /* statement id: 198 */
                (***g_407) = ((int16_t)((int16_t)g_2 << (int16_t)1) * (int16_t)(l_557 != &l_515));
    }
    /* facts after branching */
    //assert (g_355 == &g_280.f2 || g_355 == 0 || g_355 == dangling);
    (***g_406) = (*g_195);
    (*g_420) = l_558;
    /* statement id: 202 */
    assert (g_355 == &g_5);
    (**g_407) = (*g_195);
    return (*l_516);
    /* statement id: 204 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_420 g_280.f2 g_189 g_407 g_195 g_196 g_406 g_418
 * writes: g_355 g_280.f2 g_190 g_196 g_191.f4
 */
static int16_t  func_12(uint16_t  p_13, uint16_t  p_14, uint32_t  p_15)
{ /* block id: 175 */
    int32_t l_505 = 1L;
    union U0 l_509 = {0xDF52CC46L};
    (*g_420) = (l_505 , &l_505);
    /* statement id: 176 */
    assert (g_355 == &l_505);
    for (g_280.f2 = 22; (g_280.f2 >= 1); g_280.f2 -= 2)
    { /* block id: 179 */
        int32_t *l_508 = (void*)0;
        volatile float *l_510 = &g_191.f4;
        (*g_189) = (void*)0;
        /* statement id: 180 */
        assert (g_190 == 0);
        (***g_406) = (**g_407);
        (*g_420) = l_508;
        /* statement id: 182 */
        assert (g_355 == 0);
        (*l_510) = (l_509 , g_418);
        /* statement id: 183 */
    }
    /* facts after for loop */
    assert (g_190 == 0 || g_190 == &g_191);
    assert (g_355 == 0 || g_355 == &l_505);
    return p_14;
    /* statement id: 185 */
    //assert (g_355 == 0 || g_355 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_406 g_418 g_407 g_195 g_196 g_262 g_420 g_280.f0 g_197 g_280.f2 g_141 g_191.f4 g_2 g_5 g_191.f0 g_189 g_190 g_191 g_102
 * writes: g_197
 */
static uint16_t  func_17(uint16_t  p_18, int32_t  p_19, uint32_t  p_20)
{ /* block id: 153 */
    int32_t **l_421 = &g_355;
    uint16_t l_450 = 65535UL;
    union U0 *l_452 = (void*)0;
    union U0 **l_451 = &l_452;
    float *l_455 = (void*)0;
    for (p_20 = 0; (p_20 >= 32); p_20 += 1)
    { /* block id: 156 */
        uint32_t l_419 = 1UL;
        int16_t l_434 = (-1L);
        union U0 **l_453 = &l_452;
        int32_t l_454 = 0x53AC29C5L;
        float *l_456 = &g_280.f4;
        uint16_t l_482 = 0x66C7L;
        union U0 ***l_483 = &l_453;
        int32_t **l_495 = &g_355;
        if (((int16_t)((int16_t)((g_406 == (void*)0) == ((((uint16_t)(+(((((-1L) != (((-1L) ^ ((-4L) <= p_18)) || (+0xCC55L))) != (((int16_t)((((int16_t)(p_19 & ((((int32_t)((g_418 , (***g_406)) == (void*)0) % (int32_t)l_419) != g_262) || 0L)) >> (int16_t)4) , g_420) != l_421) * (int16_t)g_280.f0) || (****g_406))) != g_262) <= 3UL)) - (uint16_t)p_19) <= p_18) , g_280.f2)) % (int16_t)65531UL) >> (int16_t)4))
        { /* block id: 157 */
            int16_t l_441 = 0xFAF5L;
            int32_t ***l_449 = &g_420;
            int32_t ****l_448 = &l_449;
            uint32_t l_477 = 0x35E505DBL;
            if ((((p_19 == ((((((l_419 & ((((int16_t)(p_19 & ((((((uint32_t)(0x0B75L || (((((((((-(float)(((+p_20) < ((float)((float)((((float)(l_434 >= ((float)((float)(((float)(g_280.f2 == (l_441 > ((float)((float)((float)((&g_407 == l_448) < g_141) * (float)g_191.f4) * (float)g_2) * (float)p_19))) / (float)g_280.f2) >= g_262) + (float)p_19) * (float)l_434)) + (float)g_280.f2) >= p_19) == 0xE.7E2544p-85) + (float)p_20) - (float)p_18)) != l_450)) , l_451) == l_453) & p_20) && p_20) < g_5) >= 1L) , p_20) == 0x0A0CL)) + (uint32_t)g_280.f0) >= 65535UL) | g_2) == 65535UL) >= g_280.f0)) - (int16_t)l_454) || g_191.f0) ^ 0x306EL)) < l_450) != l_434) >= p_19) , l_455) == l_456)) , 65535UL) >= p_18))
            { /* block id: 158 */
                union U0 **l_458 = &l_452;
                int32_t l_484 = (-7L);
                (****g_406) = ((-(uint16_t)(l_458 == (((uint16_t)p_19 << (uint16_t)2) , ((((((((int16_t)((uint32_t)((uint16_t)((p_20 != ((uint32_t)p_20 + (uint32_t)(((((g_197 , ((int16_t)((int16_t)(((int32_t)(((int16_t)l_477 * (int16_t)((int32_t)((**g_189) , p_19) + (int32_t)((int16_t)0x2199L << (int16_t)p_18))) , l_419) / (int32_t)0xFE649DB0L) ^ 0L) % (int16_t)(-8L)) * (int16_t)l_482)) , g_197) != (-0x4.Cp+1)) , &l_453) != l_483))) & 0x52D1D082L) % (uint16_t)0xCF4CL) + (uint32_t)0x51296F2BL) >> (int16_t)13) && (**g_195)) && 0L) == p_19) & l_484) || g_5) , (*l_483))))) == g_262);
                for (l_454 = 0; (l_454 > 0); l_454 += 1)
                { /* block id: 162 */
                    (****g_406) = (~p_19);
                }
                return p_18;
            }
            else
            { /* block id: 166 */
                int32_t l_488 = 0L;
                return l_488;
            }
        }
        else
        { /* block id: 169 */
            int32_t l_502 = 0x31C7AFC4L;
            int32_t ***l_504 = &l_495;
            int32_t ****l_503 = &l_504;
            (****g_406) = ((uint16_t)((void*)0 == l_455) * (uint16_t)((int16_t)p_18 * (int16_t)((int32_t)((l_495 != l_495) | 2UL) - (int32_t)(((uint16_t)p_18 * (uint16_t)((uint16_t)((uint16_t)g_102 % (uint16_t)l_502) + (uint16_t)g_262)) > p_20))));
            (*l_503) = &l_421;
            /* statement id: 171 */
            assert (l_504 == &l_421);
        }
    }
    return g_280.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_195 g_196 g_197 g_262 g_2 g_280.f2 g_141 g_280.f3 g_102 g_189 g_190 g_191.f2 g_280.f0 g_280.f4 g_191 g_93 g_191.f1
 * writes: g_196 g_262 g_141 g_197 g_355 g_191.f2
 */
static int16_t  func_21(int16_t  p_22, union U0  p_23, int32_t  p_24, union U0  p_25)
{ /* block id: 92 */
    int16_t l_283 = (-10L);
    int32_t **l_285 = (void*)0;
    int32_t ***l_284 = &l_285;
    volatile int32_t *l_287 = &g_191.f2;
    uint32_t l_317 = 0UL;
    union U0 *l_329 = &g_280;
    int32_t *l_398 = &g_262;
    int32_t **l_399 = &g_355;
    (*g_195) = (*g_195);
    if ((+l_283))
    { /* block id: 94 */
        int32_t ****l_286 = &l_284;
        (*l_286) = l_284;
    }
    else
    { /* block id: 96 */
        int16_t l_315 = (-8L);
        int32_t *l_341 = (void*)0;
        union U0 l_342 = {0x76B26CEFL};
        if ((**g_195))
        { /* block id: 97 */
            int32_t *l_290 = &g_280.f2;
            int32_t l_316 = 0xA6FD5E33L;
            uint16_t l_318 = 1UL;
            l_287 = (*g_195);
            /* statement id: 98 */
            assert (l_287 == &g_197);
            for (g_262 = 0; (g_262 != (-4)); --g_262)
            { /* block id: 101 */
                int32_t **l_291 = &l_290;
                float *l_319 = &g_141;
                (*l_291) = l_290;
                (*l_319) = ((float)((float)(-0x1.9p-1) / (float)((+(+((float)p_23.f1 + (float)(-(float)(((((((float)0x9.4p+1 + (float)((((float)(g_2 , ((0x0.4p+1 < ((((float)((float)p_23.f3 - (float)(((((float)((-0x8.Dp+1) != ((float)(((float)0x1.7B670Fp+73 / (float)(*l_290)) >= l_315) + (float)0x1.Bp-1)) + (float)g_141) > l_316) > 0x8.6993AFp-1) == 0x0.Ap-1)) / (float)0x1.BA9572p-77) <= p_23.f3) < (**l_291))) < 0x9.C7A0F8p-69)) - (float)0x4.57FDADp-88) >= (*l_287)) != g_280.f3)) >= g_280.f3) == p_22) >= l_317) < 0x5.9C13FFp+52) != (**l_291)))))) > l_318)) - (float)0x6.E54F6Ep+32);
                for (p_22 = 0; (p_22 == (-2)); --p_22)
                { /* block id: 106 */
                    (*l_291) = (*l_291);
                }
                (*g_195) = (*g_195);
            }
        }
        else
        { /* block id: 111 */
            int32_t *l_322 = &g_280.f2;
            int32_t **l_323 = &l_322;
            union U0 **l_338 = (void*)0;
            union U0 ***l_337 = &l_338;
            float l_356 = 0x2.02BF3Dp-77;
            (*l_323) = l_322;
            if (l_315)
            { /* block id: 113 */
                float *l_324 = &g_141;
                int32_t l_353 = 0x3D82C601L;
                (*l_324) = (l_315 < 0x2.421487p+29);
                (*l_324) = g_102;
                if ((p_25.f1 ^ l_315))
                { /* block id: 116 */
                    int32_t *l_343 = &g_5;
                    int32_t l_354 = 0xE1D119A2L;
                    uint32_t l_357 = 0x89FFF078L;
                    if (((+(((int16_t)((~((void*)0 == l_329)) , p_25.f1) << (int16_t)(((int16_t)0L % (int16_t)g_2) != (!((uint16_t)(((int32_t)p_23.f2 + (int32_t)(l_337 == &g_189)) || (**g_195)) << (uint16_t)13)))) < 1L)) > (**l_323)))
                    { /* block id: 117 */
                        uint16_t l_344 = 0x9D93L;
                        (*g_195) = (*g_195);
                        (**g_195) = ((uint16_t)(((void*)0 != (*g_189)) | (l_341 != (l_342 , l_343))) >> (uint16_t)(l_344 ^ ((uint16_t)((p_23.f1 && ((uint16_t)((((int16_t)(p_24 | ((int16_t)g_191.f2 / (int16_t)g_262)) % (int16_t)l_353) == 0UL) ^ l_354) << (uint16_t)(**l_323))) <= g_262) + (uint16_t)p_22)));
                    }
                    else
                    { /* block id: 120 */
                        g_355 = l_341;
                    }
                    return l_357;
                }
                else
                { /* block id: 124 */
                    float l_370 = 0x0.832DA5p-52;
                    (*l_324) = ((float)((float)(((((uint16_t)((int16_t)(((((((int16_t)(((*l_322) , (p_23.f1 & g_280.f2)) || p_25.f1) + (int16_t)p_23.f2) > (0xF2C5EE9AL ^ (**l_323))) != (p_23.f0 , ((*l_322) || g_262))) >= 0UL) > g_280.f2) < g_280.f0) + (int16_t)0x2156L) + (uint16_t)p_23.f1) == 0x273CL) , 0x315FL) , g_280.f3) * (float)g_280.f0) * (float)g_280.f4);
                    p_23.f4 = (((float)(((p_23.f0 > (((((((0x7776L > ((**g_189) , ((g_2 , &l_285) != (void*)0))) ^ (p_25.f2 < ((p_22 , (l_353 <= 0xF327L)) > l_315))) , 0xA234F56AL) <= p_25.f1) || p_25.f0) , p_23.f1) , g_93)) == 0x0.C26C5Ap+22) > 0xC.767CC5p+96) - (float)0xF.6F4FCCp+96) , g_191.f1);
                    /* statement id: 126 */
                                    }
                /* facts after branching */
                                for (p_24 = (-9); (p_24 > (-7)); p_24 += 1)
                { /* block id: 130 */
                    int32_t *l_375 = &l_353;
                    l_375 = &l_353;
                }
            }
            else
            { /* block id: 133 */
                float l_394 = 0x0.14E303p+76;
                int32_t l_395 = 9L;
                for (p_23.f1 = (-5); (p_23.f1 >= 13); p_23.f1 += 1)
                { /* block id: 136 */
                    int32_t l_393 = (-10L);
                }
                /* facts after for loop */
                                (*l_323) = (*l_323);
                for (l_342.f1 = 5; (l_342.f1 >= 26); l_342.f1 += 2)
                { /* block id: 144 */
                    (*g_196) = (*g_196);
                }
                /* facts after for loop */
                                (*l_287) = (*g_196);
                /* statement id: 147 */
                            }
            /* facts after branching */
                    }
        /* facts after branching */
        assert (l_287 == &g_191.f2 || l_287 == &g_197);
    }
    /* facts after branching */
    assert (l_287 == &g_191.f2 || l_287 == &g_197);
    (*l_399) = l_398;
    /* statement id: 151 */
    assert (g_355 == &g_262);
    return p_22;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_5 g_102 g_189 g_195 g_196 g_197 g_93 g_141 g_191.f0 g_190 g_191 g_262
 * writes: g_102 g_196 g_191.f4 g_197 g_189
 */
static uint32_t  func_26(int16_t  p_27)
{ /* block id: 7 */
    uint16_t l_32 = 0xBD55L;
    int16_t l_41 = (-8L);
    union U0 l_223 = {0x360EF7B9L};
    int32_t *l_246 = &l_223.f2;
    uint16_t l_261 = 0x0DCDL;
    for (p_27 = 0; (p_27 > (-14)); p_27 -= 3)
    { /* block id: 10 */
        if (p_27)
            break;
    }
    (*l_246) = ((((int16_t)((l_32 , func_33((l_32 , (func_37(l_41, ((((uint32_t)((uint32_t)((int16_t)p_27 - (int16_t)(g_2 <= (g_2 && p_27))) + (uint32_t)(((uint32_t)((g_5 >= func_50(p_27, g_2, l_32, l_32)) != l_32) + (uint32_t)p_27) == p_27)) - (uint32_t)l_41) >= l_41) != 0x2104L), l_223) , 0x0.Ep-1)), p_27, g_2)) , 7L) % (int16_t)0xC118L) >= l_223.f0) >= p_27);
    /* statement id: 86 */
        if ((((((uint16_t)((uint32_t)((int16_t)(((int32_t)((uint16_t)(((((((((float)g_141 * (float)(*l_246)) , (0L != ((((*g_196) , (p_27 >= ((p_27 >= ((((int16_t)(((g_2 <= ((*l_246) | ((**g_189) , p_27))) == (*l_246)) >= 0x12BAL) - (int16_t)0x9DD0L) > (*l_246)) < p_27)) == (*l_246)))) <= (*l_246)) || l_261))) > g_5) | (*l_246)) , (*l_246)) >= g_262) <= 0x3DC0L) != p_27) * (uint16_t)p_27) / (int32_t)g_262) , 0xB2F5L) >> (int16_t)5) - (uint32_t)(*l_246)) << (uint16_t)(*l_246)) <= 0xEB3C58A0L) , (*l_246)) && g_5))
    { /* block id: 87 */
        int32_t l_263 = 0x6E9BF4C0L;
        return l_263;
    }
    else
    { /* block id: 89 */
        int16_t l_264 = (-1L);
        return l_264;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_102
 * writes:
 */
static uint32_t  func_33(float  p_34, uint32_t  p_35, uint16_t  p_36)
{ /* block id: 78 */
    int32_t *l_244 = &g_5;
    int32_t **l_245 = &l_244;
    for (p_35 = (-12); (p_35 > 55); p_35 += 1)
    { /* block id: 81 */
        union U0 *l_242 = (void*)0;
        union U0 **l_243 = &l_242;
        (*l_243) = l_242;
    }
    (*l_245) = l_244;
    return g_102;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_191.f0 g_2 g_196
 * writes: g_197
 */
static uint32_t  func_37(uint32_t  p_38, int16_t  p_39, union U0  p_40)
{ /* block id: 75 */
    int32_t *l_232 = &g_5;
    int32_t **l_231 = &l_232;
    uint32_t l_233 = 0xBD924968L;
    int16_t l_238 = 1L;
    float l_239 = (-0x1.1p+1);
    (*g_196) = ((!(((uint32_t)((0x60F9L & ((4294967295UL >= (((p_40.f2 ^ ((((int32_t)(((((uint16_t)p_38 + (uint16_t)(l_231 == &l_232)) == (((l_233 , ((((uint16_t)((int16_t)((void*)0 == l_232) >> (int16_t)5) << (uint16_t)6) && (*l_232)) >= (*l_232))) , 0x8BBAL) <= l_238)) , (**l_231)) < 0x6699L) / (int32_t)0x6E18EC0DL) != 1L) < 0x5BE5L)) , 0x8FECL) >= g_191.f0)) , p_38)) || g_2) / (uint32_t)0xF28CA528L) <= 1UL)) & p_40.f2);
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_2 g_102 g_189 g_195 g_196 g_197 g_93 g_141
 * writes: g_102 g_196 g_191.f4 g_197 g_189
 */
static int16_t  func_50(uint32_t  p_51, uint16_t  p_52, uint32_t  p_53, uint32_t  p_54)
{ /* block id: 13 */
    int32_t l_76 = 0x64BBCDFAL;
    int32_t *l_201 = &l_76;
    float *l_206 = (void*)0;
    union U0 l_210 = {0x3A28AA74L};
    union U0 *l_222 = &l_210;
    union U0 **l_221 = &l_222;
    (*l_201) = (p_53 || func_55((((int16_t)((0L == ((uint16_t)(4294967294UL && ((int16_t)((int16_t)(0xC535L >= (((uint16_t)((int16_t)(((((int16_t)((0UL <= p_51) ^ 0x6691L) * (int16_t)((uint16_t)(0UL & ((-10L) != p_51)) * (uint16_t)p_52)) >= 0x29D3EAFCL) > 0xB6322A57L) >= p_51) - (int16_t)l_76) * (uint16_t)l_76) != 0xC3CEL)) >> (int16_t)9) % (int16_t)0x8FE3L)) << (uint16_t)12)) <= g_5) + (int16_t)l_76) != g_5), p_53, g_5, l_76));
    (*l_201) = ((float)0x7.5D55B7p-69 * (float)((((float)p_53 - (float)((l_206 == l_206) <= (*l_201))) == (((((*l_201) > 0x6F42BAF6L) , ((float)(-(float)((g_93 < g_141) == g_2)) + (float)(-0x9.Ap+1))) <= (*l_201)) <= (*l_201))) == 0x0.6p+1));
    (*l_201) = ((l_210 , ((int16_t)((p_51 , ((*l_201) == ((uint16_t)((((uint16_t)(((void*)0 != &l_201) | p_54) + (uint16_t)((int16_t)((uint32_t)(l_201 != l_201) % (uint32_t)((*l_201) & 2L)) * (int16_t)(-5L))) , p_53) , (*l_201)) >> (uint16_t)15))) || p_51) * (int16_t)0x9482L)) | p_53);
    (*l_221) = &l_210;
    return g_102;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_5 g_102 g_189 g_195 g_196 g_197
 * writes: g_102 g_196 g_191.f4 g_197 g_189
 */
static uint32_t  func_55(int16_t  p_56, uint32_t  p_57, int32_t  p_58, uint32_t  p_59)
{ /* block id: 14 */
    float l_82 = 0xF.3E233Dp+39;
    int32_t l_83 = 0xED5C0EB7L;
    int32_t *l_94 = &l_83;
    float l_130 = 0xD.A02901p+61;
    uint16_t l_158 = 4UL;
lbl_101:
    (*l_94) = ((g_2 <= ((+((int16_t)((int16_t)(-8L) * (int16_t)l_83) - (int16_t)((int16_t)((((g_2 & ((int16_t)((int16_t)(+((int16_t)((0xDAD0L <= (l_83 || l_83)) != 0x5F77L) / (int16_t)g_2)) / (int16_t)g_2) + (int16_t)0UL)) == 0x053AAA0CL) < l_83) & l_83) / (int16_t)g_5))) || 7UL)) && g_5);
    for (p_57 = 21; (p_57 < 31); p_57 += 4)
    { /* block id: 18 */
        int32_t *l_103 = &g_5;
        int32_t **l_104 = &l_94;
        for (l_83 = 0; (l_83 <= 17); l_83 += 1)
        { /* block id: 21 */
            int32_t **l_100 = &l_94;
            int32_t ***l_99 = &l_100;
            (*l_99) = &l_94;
            if (g_5)
                goto lbl_101;
            g_102 = 0x34BCD012L;
        }
        (*l_104) = l_103;
        /* statement id: 26 */
        assert (l_94 == &g_5);
        return p_57;
    }
    if (((int16_t)(((uint16_t)p_56 >> (uint16_t)15) , (((uint16_t)((int16_t)(*l_94) * (int16_t)0x0062L) * (uint16_t)(g_5 , (+0xF0E3L))) , (-10L))) << (int16_t)3))
    { /* block id: 29 */
        int32_t **l_114 = &l_94;
        (*l_114) = &g_5;
        /* statement id: 30 */
        assert (l_94 == &g_5);
    }
    else
    { /* block id: 31 */
        int32_t **l_115 = &l_94;
        (*l_115) = &g_2;
        /* statement id: 32 */
        assert (l_94 == &g_2);
    }
    /* facts after branching */
    assert (l_94 == &g_2 || l_94 == &g_5);
    for (p_58 = 0; (p_58 != 16); p_58 += 4)
    { /* block id: 36 */
        uint32_t l_123 = 0xA7B59292L;
        union U0 l_139 = {0x23687E89L};
        uint32_t l_140 = 18446744073709551615UL;
        int32_t **l_166 = &l_94;
        int16_t l_168 = 0xCB78L;
        volatile union U0 ***l_200 = &g_189;
        for (p_56 = 12; (p_56 > 24); p_56 += 1)
        { /* block id: 39 */
            int32_t **l_120 = &l_94;
            (*l_120) = &l_83;
            /* statement id: 40 */
            assert (l_94 == &l_83);
            (*l_94) = (((uint32_t)g_2 % (uint32_t)g_5) & l_123);
            if (g_2)
                continue;
        }
        /* facts after for loop */
        assert (l_94 == &l_83 || l_94 == &g_2 || l_94 == &g_5);
        if (l_123)
        { /* block id: 44 */
            int32_t *l_133 = &g_5;
            int32_t *l_134 = (void*)0;
            l_139.f2 = ((int16_t)((uint16_t)(((uint16_t)((p_58 <= (((uint16_t)(g_5 > (l_133 != l_134)) * (uint16_t)((uint16_t)g_2 % (uint16_t)p_57)) == g_5)) > (((int16_t)(l_139 , g_2) - (int16_t)g_102) >= l_140)) << (uint16_t)p_56) || 4294967295UL) - (uint16_t)p_56) / (int16_t)3UL);
            /* statement id: 45 */
                    }
        else
        { /* block id: 46 */
            uint32_t l_161 = 0xDC29D91FL;
            float l_167 = (-0x1.1p+1);
            int32_t **l_194 = &l_94;
            if (((int16_t)((uint16_t)9UL * (uint16_t)(((int16_t)(((uint32_t)((uint16_t)l_140 - (uint16_t)(((((int16_t)(((uint16_t)(1UL <= (((float)(l_139 , l_158) * (float)((float)g_102 + (float)l_161)) , (((uint16_t)(((uint16_t)(l_166 != (void*)0) << (uint16_t)10) | l_161) >> (uint16_t)14) == p_58))) - (uint16_t)(**l_166)) & g_5) + (int16_t)(**l_166)) & (-1L)) | 0x2B9DL) > (**l_166))) - (uint32_t)g_5) , (-1L)) << (int16_t)g_2) < l_161)) % (int16_t)0x1501L))
            { /* block id: 47 */
                if (l_168)
                    break;
            }
            else
            { /* block id: 49 */
                int32_t *l_183 = &g_2;
                union U0 *l_193 = &l_139;
                union U0 **l_192 = &l_193;
                for (l_123 = 0; (l_123 < 1); l_123 += 2)
                { /* block id: 52 */
                    union U0 *l_171 = &l_139;
                    union U0 **l_172 = &l_171;
                    int32_t l_198 = (-4L);
                    (*l_172) = l_171;
                    if (((uint16_t)((uint16_t)((uint16_t)((((((uint16_t)((((l_161 >= (((uint16_t)(g_102 == (((l_183 == (void*)0) & ((p_56 < p_58) & (+((uint16_t)(((((uint16_t)g_5 << (uint16_t)((p_59 || ((g_189 != l_192) , p_57)) < p_56)) > 6UL) , l_194) == g_195) * (uint16_t)l_198)))) , 0x7E66L)) - (uint16_t)1UL) , p_56)) , 0UL) || (-1L)) ^ 0xEB578CF1L) - (uint16_t)(*l_183)) != p_58) != g_2) > g_5) >= 0x0752C94BL) << (uint16_t)12) >> (uint16_t)12) - (uint16_t)(-1L)))
                    { /* block id: 54 */
                        return g_5;
                    }
                    else
                    { /* block id: 56 */
                        volatile float *l_199 = &g_191.f4;
                        (*g_195) = (*g_195);
                        (*l_199) = g_197;
                        /* statement id: 58 */
                        return g_102;
                    }
                }
            }
            (*g_196) = p_59;
            if ((*g_196))
                break;
        }
        /* facts after branching */
                (*l_200) = &g_190;
        return g_5;
    }
    /* facts after for loop */
    assert (l_94 == &l_83 || l_94 == &g_2 || l_94 == &g_5);
    return p_57;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc_bytes (&g_93, sizeof(g_93), "g_93", print_hash_value);
    transparent_crc(g_102, "g_102", print_hash_value);
    transparent_crc_bytes (&g_141, sizeof(g_141), "g_141", print_hash_value);
    transparent_crc(g_191.f0, "g_191.f0", print_hash_value);
    transparent_crc(g_191.f1, "g_191.f1", print_hash_value);
    transparent_crc(g_191.f2, "g_191.f2", print_hash_value);
    transparent_crc_bytes (&g_191.f3, sizeof(g_191.f3), "g_191.f3", print_hash_value);
    transparent_crc_bytes (&g_191.f4, sizeof(g_191.f4), "g_191.f4", print_hash_value);
    transparent_crc(g_197, "g_197", print_hash_value);
    transparent_crc(g_262, "g_262", print_hash_value);
    transparent_crc(g_280.f0, "g_280.f0", print_hash_value);
    transparent_crc(g_280.f1, "g_280.f1", print_hash_value);
    transparent_crc(g_280.f2, "g_280.f2", print_hash_value);
    transparent_crc_bytes (&g_280.f3, sizeof(g_280.f3), "g_280.f3", print_hash_value);
    transparent_crc_bytes (&g_280.f4, sizeof(g_280.f4), "g_280.f4", print_hash_value);
    transparent_crc(g_418, "g_418", print_hash_value);
    transparent_crc(g_706, "g_706", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 126
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 47
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 22
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2
   depth: 29, occurrence: 2
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 47, occurrence: 1

XXX total number of pointers: 97

XXX times a variable address is taken: 109
XXX times a pointer is dereferenced on RHS: 88
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 17
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 73
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 3
   depth: 3, occurrence: 5
   depth: 4, occurrence: 5
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 311

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 183
   level: 2, occurrence: 67
   level: 3, occurrence: 22
   level: 4, occurrence: 14
XXX number of pointers point to pointers: 52
XXX number of pointers point to scalars: 33
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 12.4
XXX average alias set size: 1.12

XXX times a non-volatile is read: 672
XXX times a non-volatile is write: 192
XXX times a volatile is read: 57
XXX    times read thru a pointer: 21
XXX times a volatile is write: 15
XXX    times written thru a pointer: 13
XXX times a volatile is available for access: 172
XXX percentage of non-volatile access: 92.3

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 117
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 29
   depth: 2, occurrence: 18
   depth: 3, occurrence: 18
   depth: 4, occurrence: 10
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
********************* end of statistics **********************/

