/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      236599855
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   int32_t  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_25 = 0x47706695L;
static int32_t g_29 = 0x012AF048L;
static int16_t g_77 = 0L;
static uint32_t g_113 = 0x3CC2ED11L;
static uint32_t g_117 = 0x30550D74L;
static struct S0 g_120 = {0UL,0xD2D99110L,0L};
static struct S0 g_148 = {0UL,2L,1L};
static float g_176 = 0x7.5p+1;
static uint32_t g_211 = 0UL;
static int32_t g_221 = 0xDACD49A5L;
static volatile uint32_t g_225 = 0x6E4037C9L;/* VOLATILE GLOBAL g_225 */
static float g_237 = 0x1.1p-1;
static volatile uint32_t g_247 = 0x97A0B385L;/* VOLATILE GLOBAL g_247 */
static uint32_t g_260 = 4294967287UL;
static int32_t g_286 = 1L;
static uint32_t g_312 = 0UL;
static float g_335 = 0xE.E0E653p+27;
static int32_t g_362 = 0xD5EAB3F5L;
static int16_t g_426 = 0x08FFL;
static int16_t g_471 = 1L;
static struct S0 g_499 = {0x3D9BD2ADL,0x55E93804L,0L};
static int32_t g_545 = 0x42BE219BL;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_30(void);
static int16_t  func_39(uint32_t  p_40, uint16_t  p_41, uint32_t  p_42, uint16_t  p_43);
static int16_t  func_49(float  p_50, uint32_t  p_51, int16_t  p_52, uint32_t  p_53, int16_t  p_54);
static struct S0  func_55(uint16_t  p_56, uint16_t  p_57, int32_t  p_58, int16_t  p_59, int32_t  p_60);
static uint32_t  func_65(int32_t  p_66, float  p_67, uint32_t  p_68, int32_t  p_69);
static int32_t  func_79(int16_t  p_80);
static struct S0  func_85(struct S0  p_86);
static struct S0  func_87(int32_t  p_88);
static uint16_t  func_105(int32_t  p_106);
static int32_t  func_107(struct S0  p_108);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_25 g_29 g_77 g_117 g_120 g_148.f1 g_148 g_113 g_176 g_225 g_211 g_247 g_221 g_237 g_260 g_286 g_312 g_362 g_426 g_471 g_499
 * writes: g_25 g_77 g_113 g_117 g_120 g_148 g_176 g_211 g_221 g_237 g_260 g_286 g_312 g_362 g_29 g_335 g_426 g_499 g_545
 */
static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_36 = (-1L);
    int32_t l_218 = 0xFFB06713L;
    uint32_t l_219 = 0UL;
    int32_t l_222 = 0xBD303A7FL;
    float l_226 = 0x3.72152Dp-78;
    uint32_t l_231 = 4294967295UL;
    uint32_t l_250 = 4294967295UL;
    uint16_t l_258 = 0UL;
    int32_t l_263 = 0x70C35646L;
    struct S0 l_265 = {0xB359D269L,0x899C4599L,0x9CE8B853L};
    int32_t l_320 = (-10L);
    int32_t l_507 = 0x5954689DL;
    for (g_25 = (-8); (g_25 > (-17)); g_25 -= 3)
    { /* block id: 39 */
        uint16_t l_33 = 6UL;
        l_33 = g_29;
    }
    l_222 = (0x9DF9481FL && (((uint16_t)(g_221 = ((((l_36 = 4294967292UL) >= ((uint16_t)0xB9C6L * (uint16_t)g_25)) && ((func_39(l_36, g_29, ((int32_t)(((uint16_t)(-(uint32_t)(l_218 = (func_49(g_25, g_29, l_36, l_36, l_36) <= g_29))) >> (uint16_t)l_36) | 0x69D0CB17L) + (int32_t)0xCDE767DAL), l_219) ^ 0xB226L) < 5UL)) != g_29)) * (uint16_t)g_29) <= g_29));
    if (l_36)
    { /* block id: 158 */
        uint32_t l_227 = 0xFAC45323L;
        float l_336 = (-0x5.Ap+1);
        struct S0 l_354 = {0xEFFA4C75L,0x7988940AL,0x0277C8FFL};
        uint32_t l_359 = 4294967295UL;
        float l_385 = 0x4.BE099Cp-21;
        struct S0 l_389 = {3UL,0L,0xEC4609C7L};
        for (g_117 = 0; (g_117 != 51); g_117++)
        { /* block id: 161 */
            int32_t l_230 = 0xE875DABCL;
            struct S0 l_234 = {0xA02D44F0L,0xA9BC9FA8L,0x5E18F196L};
            l_227 = (g_225 & g_120.f0);
            for (g_120.f2 = 0; (g_120.f2 <= 12); g_120.f2 += 6)
            { /* block id: 165 */
                g_176 = l_230;
                l_230 = __builtin_ia32_crc32qi((l_222 = 1UL), g_120.f2);
                if (l_231)
                    continue;
                g_176 = (l_230 >= (((float)((0x6.E51560p+45 <= g_148.f2) >= func_107(l_234)) - (float)g_211) != l_230));
            }
        }
        for (g_77 = 0; (g_77 != 14); g_77++)
        { /* block id: 175 */
            uint32_t l_240 = 4294967295UL;
            uint32_t l_253 = 0xCA03A09FL;
            int16_t l_257 = 0x7133L;
            float l_264 = (-0x2.2p+1);
            int32_t l_280 = 0x419D225DL;
            int32_t l_337 = 0xCAB69B81L;
            g_237 = func_79(g_120.f2);
            if (((int32_t)func_79(__builtin_ffs((((g_148.f2 >= g_113) <= l_240) && (((0x7552E39FL >= ((uint16_t)(((int16_t)((((int16_t)g_247 >> (int16_t)((((0x4135L && (((int32_t)(l_218 = ((l_250 ^ l_227) <= l_227)) - (int32_t)g_148.f0) > g_120.f1)) > l_240) != g_113) >= l_227)) == g_211) < g_77) >> (int16_t)3) < 0x5BE9L) >> (uint16_t)g_148.f1)) < l_222) ^ l_231)))) + (int32_t)l_227))
            { /* block id: 178 */
                uint32_t l_256 = 2UL;
                struct S0 l_296 = {0x527F5A8CL,-4L,1L};
                if ((g_113 | (0xA9D3D986L == (((g_117 = (g_113 == (((((g_25 != ((int16_t)((l_253 == (0x6E39L | ((l_240 < ((int32_t)l_256 + (int32_t)l_227)) != g_148.f1))) == l_227) + (int16_t)g_120.f2)) ^ g_25) != (-1L)) != 0UL) && l_256))) & l_257) | l_258))))
                { /* block id: 180 */
                    uint32_t l_259 = 18446744073709551611UL;
                    if (l_259)
                        break;
                    l_265 = func_55(((l_227 <= (g_260 = func_105(g_225))) > (1L > l_259)), l_227, l_259, ((uint16_t)(0x4D6AL < l_263) >> (uint16_t)l_259), g_221);
                }
                else
                { /* block id: 184 */
                    struct S0 l_266 = {0x95B6507DL,-4L,0x23DF58AAL};
                    l_265 = l_266;
                    if (g_113)
                        break;
                    for (g_148.f0 = 0; (g_148.f0 != 0); g_148.f0 += 5)
                    { /* block id: 189 */
                        float l_279 = 0xD.E82CD3p+4;
                        struct S0 l_281 = {1UL,0L,-1L};
                        float l_291 = 0xD.471C6Fp+51;
                        l_280 = ((float)(g_25 == ((float)g_237 * (float)(g_176 = (((float)(((float)g_148.f0 - (float)__builtin_ia32_crc32qi(l_227, g_221)) > g_25) * (float)(((float)0x4.0C56BDp+77 - (float)(l_279 = (g_176 == 0xE.A650ABp-71))) > g_148.f0)) >= l_265.f0)))) * (float)0x3.Dp-1);
                        l_281 = l_265;
                        l_265 = (l_266 = func_87((g_25 = g_148.f0)));
                        l_291 = __builtin_ctz((((uint16_t)l_265.f1 << (uint16_t)(0xE14EL == ((((int16_t)(g_286 = (g_260 | ((l_253 | 0L) <= g_225))) * (int16_t)__builtin_bswap64(g_260)) | (((uint16_t)((int16_t)(l_281.f2 <= 0xFEEDA3D8L) << (int16_t)l_256) * (uint16_t)g_120.f2) <= 7UL)) || 4294967295UL))) == g_221));
                    }
                    for (l_240 = 0; (l_240 < 22); l_240 += 3)
                    { /* block id: 202 */
                        struct S0 l_294 = {0xC70344B6L,0L,-8L};
                        uint32_t l_295 = 0UL;
                        l_265 = l_294;
                        l_295 = ((g_237 = g_120.f1) < 0x1.6p-1);
                        l_296 = func_87(g_77);
                    }
                }
                for (l_258 = (-20); (l_258 != 8); l_258 += 1)
                { /* block id: 211 */
                    uint32_t l_319 = 18446744073709551612UL;
                    uint32_t l_321 = 4294967295UL;
                    l_280 = ((g_260 = func_105(g_120.f2)) | (((uint16_t)(((((uint16_t)((((((int16_t)((uint16_t)(g_25 == (g_221 = (~((uint16_t)((int32_t)g_221 + (int32_t)(g_312 = 0x52347958L)) + (uint16_t)(g_221 != (((uint16_t)g_247 + (uint16_t)((int32_t)(l_240 ^ __builtin_ffsll(((uint32_t)g_221 % (uint32_t)g_286))) % (int32_t)g_29)) & g_25)))))) >> (uint16_t)1) % (int16_t)g_25) != l_319) ^ g_25) > l_227) < l_320) >> (uint16_t)12) == l_296.f2) < l_265.f0) || l_227) >> (uint16_t)l_227) && 0x72DDL));
                    g_148 = g_148;
                    if (l_231)
                    { /* block id: 217 */
                        l_321 = g_113;
                        l_280 = 0x5.C309F2p+31;
                    }
                    else
                    { /* block id: 220 */
                        int16_t l_322 = 0xA769L;
                        int32_t l_325 = 3L;
                        g_176 = ((((l_240 < g_113) <= l_322) >= ((float)((((__builtin_ctzll(l_325) <= ((g_237 = ((float)((!(l_263 = 0x8.714FB1p+50)) == g_221) * (float)((float)((float)((((float)((0x1.9p+1 >= ((l_296.f2 = ((0x6.3C09CDp+75 > g_77) >= 0x7.280A01p-74)) == 0x3.610C01p-33)) >= g_312) + (float)l_240) != 0x0.44170Fp-23) < g_120.f1) + (float)l_240) + (float)g_148.f2))) == l_36)) != l_319) > g_148.f1) == l_319) - (float)0x1.9p-1)) == l_322);
                        l_280 = (l_296.f2 = 0x55788511L);
                        g_120.f1 = ((l_296.f1 = l_296.f0) ^ g_247);
                        g_148.f2 = g_120.f2;
                    }
                    l_222 = (l_337 = g_225);
                }
                g_120 = func_87(g_221);
            }
            else
            { /* block id: 235 */
                float l_346 = 0x1.2E3F94p-95;
                g_286 = ((l_280 = __builtin_parityl(g_120.f0)) > 0xBD01FAB7L);
                g_237 = (0x4.16943Cp+38 != ((float)((float)l_253 * (float)l_227) - (float)((float)((float)(((l_346 > g_120.f1) < __builtin_parityll(((uint16_t)(g_286 && (0x1D027067L == g_211)) % (uint16_t)g_77))) != l_227) * (float)0x0.734DF6p+69) + (float)g_247)));
            }
        }
        g_148 = g_148;
        for (g_120.f0 = 0; (g_120.f0 > 26); g_120.f0 += 1)
        { /* block id: 244 */
            int32_t l_351 = 1L;
            int32_t l_353 = (-8L);
            struct S0 l_363 = {0UL,0x014E35ADL,0x9D26362CL};
            int32_t l_377 = 1L;
            g_120.f2 = ((l_265.f2 & (l_351 = l_227)) > ((!l_227) ^ (l_354.f2 = (l_353 || (func_107(l_354) | l_222)))));
            if (l_250)
            { /* block id: 248 */
                struct S0 l_367 = {0xD98C76D8L,-1L,0xF7A6D099L};
                int32_t l_388 = 0L;
                for (l_354.f1 = (-18); (l_354.f1 == (-24)); l_354.f1 -= 3)
                { /* block id: 251 */
                    uint16_t l_376 = 1UL;
                    g_286 = l_231;
                    if ((g_120.f2 <= ((int16_t)l_359 - (int16_t)((uint16_t)(g_362 = l_265.f2) * (uint16_t)g_113))))
                    { /* block id: 254 */
                        struct S0 l_364 = {4UL,0x2DA0952DL,0L};
                        g_237 = g_120.f1;
                        l_364 = l_363;
                        g_148 = func_87((l_364.f1 != (((__builtin_ffsll((((int32_t)func_107(func_85(l_367)) + (int32_t)(g_362 = l_364.f1)) | (l_364.f2 = (g_77 > ((uint16_t)(g_286 | (((int16_t)(((int16_t)(1UL || (g_120.f1 <= g_120.f0)) * (int16_t)0UL) != g_25) << (int16_t)9) <= g_77)) >> (uint16_t)15))))) & 0xA13487E7L) & g_120.f2) & g_120.f1)));
                    }
                    else
                    { /* block id: 260 */
                        if (g_148.f1)
                            break;
                    }
                    l_388 = (__builtin_clzll(((((int32_t)l_376 - (int32_t)l_377) < g_362) || (!g_148.f1))) <= ((int16_t)((uint16_t)((uint32_t)l_231 - (uint32_t)((int16_t)(l_367.f1 = l_367.f1) - (int16_t)l_353)) >> (uint16_t)2) * (int16_t)(g_362 != l_359)));
                }
                l_363 = l_354;
                g_29 = __builtin_ffs(g_221);
                l_354.f1 = l_388;
            }
            else
            { /* block id: 269 */
                float l_390 = (-0x1.Bp-1);
                int32_t l_391 = 0xD7362E18L;
                l_389 = l_389;
                l_391 = (l_390 == func_107(l_354));
            }
        }
    }
    else
    { /* block id: 274 */
        int32_t l_392 = (-1L);
        int32_t l_398 = (-10L);
        struct S0 l_411 = {18446744073709551615UL,8L,0xA630E985L};
        float l_447 = 0x9.E02075p+50;
        g_148 = func_85(g_120);
        if ((g_286 = g_312))
        { /* block id: 277 */
            return l_392;
        }
        else
        { /* block id: 279 */
            int32_t l_397 = 0xD7814597L;
            uint32_t l_409 = 6UL;
            int32_t l_424 = 0x02097631L;
            int32_t l_431 = (-6L);
            uint16_t l_446 = 0UL;
            int32_t l_460 = 0x736BB284L;
            uint32_t l_486 = 9UL;
            if (((int16_t)((((int16_t)l_397 << (int16_t)(l_398 = (l_392 < 0x3955CDD6L))) & (((int32_t)((((g_77 = (func_39(g_148.f2, (l_263 = ((((int16_t)l_392 << (int16_t)g_117) == (((((uint16_t)((int32_t)0x3038DF43L + (int32_t)g_211) + (uint16_t)g_120.f1) & l_219) && g_113) > l_392)) < l_397)), g_312, g_286) < 0xE3F1L)) > g_120.f0) && g_221) & g_312) - (int32_t)0L) == l_36)) < 0x5532F401L) - (int16_t)l_392))
            { /* block id: 283 */
                float l_410 = 0x6.95220Bp-78;
                g_148.f2 = ((uint16_t)l_409 << (uint16_t)5);
            }
            else
            { /* block id: 285 */
                g_120 = func_85(l_411);
            }
            for (l_250 = 22; (l_250 != 37); l_250 += 5)
            { /* block id: 290 */
                int16_t l_425 = (-1L);
                int32_t l_448 = (-1L);
                int32_t l_459 = (-1L);
                int32_t l_495 = 0xC0B0C993L;
                g_426 = (g_237 = ((float)((l_425 = ((g_335 = ((float)((float)g_237 - (float)(l_424 = ((((float)g_120.f2 + (float)g_221) < g_120.f1) <= (g_176 = ((((float)0x4.4B2BAFp+66 + (float)(l_265.f0 != ((__builtin_bswap64(l_231) >= __builtin_clz(l_397)) != l_222))) != g_225) < g_120.f0))))) * (float)g_237)) > l_411.f1)) != g_148.f1) + (float)l_411.f2));
                g_237 = ((l_448 = (((-0x1.1p+1) <= ((float)g_113 * (float)((((float)(l_265.f1 == l_431) * (float)((float)((float)(g_25 != (l_398 = (g_176 = ((float)(l_425 >= func_39(((int16_t)((int32_t)(((uint16_t)l_250 + (uint16_t)((int32_t)l_425 + (int32_t)0x1018A835L)) ^ l_231) % (int32_t)l_409) >> (int16_t)5), l_397, g_362, l_446)) + (float)(-0x1.Dp+1))))) - (float)g_25) * (float)0x0.Dp-1)) <= l_447) >= (-0x1.7p-1)))) < g_247)) < g_286);
                for (l_219 = (-7); (l_219 <= 5); l_219 += 1)
                { /* block id: 303 */
                    uint16_t l_476 = 0UL;
                    int32_t l_487 = (-1L);
                    volatile int32_t l_488 = 0xD2B40A93L;/* VOLATILE GLOBAL l_488 */
                    if ((g_362 = g_221))
                    { /* block id: 305 */
                        uint32_t l_454 = 0UL;
                        l_263 = func_65(l_411.f1, g_211, l_424, (l_460 = (((int32_t)(l_459 = (((g_148.f1 != l_397) > (!(l_454 > (~(g_120.f2 > (1UL && (l_448 = __builtin_popcount((((((-(int32_t)((int16_t)(g_148.f2 == g_148.f0) - (int16_t)l_411.f0)) < g_426) && l_392) >= g_362) != g_120.f2))))))))) || 0xDDDB8344L)) - (int32_t)0x057126FDL) < g_221)));
                        g_176 = 0xB.0F7C6Cp-88;
                    }
                    else
                    { /* block id: 311 */
                        uint32_t l_463 = 0x5A0BC34AL;
                        struct S0 l_468 = {0x6A3FFE95L,-5L,0L};
                        l_468 = func_55(g_148.f2, (g_148.f0 == ((uint32_t)(g_247 != 0UL) - (uint32_t)(l_463 = (0xFBDBL <= (g_120.f0 == g_29))))), (l_411.f1 = ((((int32_t)((int16_t)(l_459 = g_113) * (int16_t)__builtin_bswap32(l_448)) + (int32_t)g_120.f1) != l_411.f1) <= l_448)), l_431, g_148.f1);
                        g_286 = ((int16_t)(g_29 ^ 0xD7BFL) % (int16_t)__builtin_parity((g_113 = g_471)));
                    }
                    g_362 = l_411.f2;
                    if (g_221)
                    { /* block id: 320 */
                        uint32_t l_481 = 0xBC20F76DL;
                        l_448 = (((float)((-0x1.Dp+1) == ((float)(-0x1.Cp+1) * (float)0x8.0D73E1p+40)) + (float)0x7.274255p+39) < ((l_476 = g_176) < (g_237 = ((float)(l_487 = (((float)l_481 - (float)(g_471 < ((float)(((float)(l_222 = g_211) + (float)(g_335 = func_107(func_85(func_85(l_265))))) > l_486) * (float)g_471))) >= 0xB.AE9DF7p+41)) - (float)l_481))));
                        if (g_120.f0)
                            break;
                    }
                    else
                    { /* block id: 328 */
                        uint16_t l_498 = 0UL;
                        l_488 = g_247;
                        g_286 = __builtin_popcountl(func_65(l_446, g_426, ((uint16_t)((uint16_t)0x2151L + (uint16_t)((int16_t)l_459 << (int16_t)(g_221 >= (func_49(g_120.f2, l_495, ((int16_t)7L % (int16_t)l_265.f1), g_77, g_25) & l_495)))) >> (uint16_t)g_221), g_471));
                        g_221 = g_120.f0;
                        g_499 = (g_148 = (g_120 = func_87((g_25 = ((g_148.f2 | (l_498 = (l_487 = (-3L)))) || g_148.f1)))));
                    }
                }
                if ((l_425 <= (g_426 = ((uint16_t)l_431 << (uint16_t)13))))
                { /* block id: 341 */
                    uint16_t l_525 = 0x21D8L;
                    for (g_29 = 0; (g_29 != 12); g_29 += 1)
                    { /* block id: 344 */
                        return g_312;
                    }
                    g_148 = (g_120 = g_120);
                    if ((((g_426 ^ ((int16_t)((__builtin_popcount(g_471) == g_148.f1) && 0x1DC4L) * (int16_t)__builtin_popcountl((-(uint32_t)(l_411.f2 == g_260))))) ^ l_397) < l_507))
                    { /* block id: 349 */
                        int16_t l_526 = (-4L);
                        int32_t l_527 = (-6L);
                        l_527 = ((((float)(l_495 = g_120.f1) + (float)((l_446 == ((0x1.Ep+1 > ((float)(!(l_265.f1 = ((float)(g_237 = func_39(((uint16_t)((uint16_t)((int16_t)l_459 + (int16_t)l_460) >> (uint16_t)4) - (uint16_t)(((int16_t)func_107(g_148) << (int16_t)15) & ((int16_t)l_459 << (int16_t)4))), l_525, l_392, l_459)) + (float)l_526))) * (float)0x1.8p+1)) <= (-0x8.Fp+1))) >= g_362)) >= l_411.f0) >= 0x7.D4662Bp-45);
                        l_411.f1 = 0L;
                    }
                    else
                    { /* block id: 355 */
                        l_411 = func_85(g_499);
                    }
                    for (g_148.f1 = 0; (g_148.f1 != (-30)); g_148.f1 -= 6)
                    { /* block id: 360 */
                        g_499.f1 = g_211;
                        l_411.f2 = (g_426 > l_507);
                    }
                }
                else
                { /* block id: 364 */
                    l_411 = g_148;
                }
            }
        }
        for (g_120.f0 = 8; (g_120.f0 >= 49); g_120.f0 += 1)
        { /* block id: 371 */
            uint32_t l_532 = 0x7598967CL;
            g_29 = (l_532 && ((uint16_t)((g_113 = (g_471 <= ((int16_t)((l_398 <= 0xD528L) == l_532) * (int16_t)((int32_t)g_499.f0 - (int32_t)l_398)))) > ((int16_t)((uint16_t)g_120.f2 >> (uint16_t)((int16_t)l_320 * (int16_t)l_222)) << (int16_t)9)) >> (uint16_t)13));
            return g_148.f1;
        }
        g_237 = __builtin_ctzll((g_545 = 18446744073709551612UL));
    }
    l_265 = g_120;
    return l_231;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_148
 */
static int16_t  func_39(uint32_t  p_40, uint16_t  p_41, uint32_t  p_42, uint16_t  p_43)
{ /* block id: 153 */
    struct S0 l_220 = {0x1F3868CFL,9L,0x6C989A69L};
    g_148 = l_220;
    return l_220.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_29 g_77 g_117 g_120 g_148.f1 g_148 g_113 g_176
 * writes: g_77 g_25 g_113 g_117 g_120 g_148 g_176 g_211
 */
static int16_t  func_49(float  p_50, uint32_t  p_51, int16_t  p_52, uint32_t  p_53, int16_t  p_54)
{ /* block id: 43 */
    int32_t l_63 = 0x16D0046BL;
    int32_t l_64 = 0x0F90F5F2L;
    struct S0 l_213 = {18446744073709551615UL,-6L,0xAA3BF259L};
    l_213 = func_55(((int32_t)(l_64 = (l_63 & l_63)) - (int32_t)func_65(l_63, p_54, ((p_52 = l_63) != (~((l_63 == (0x3212L > ((uint16_t)p_53 << (uint16_t)10))) && (l_63 > g_25)))), l_63)), g_29, g_29, g_29, l_63);
    g_176 = g_176;
    g_148 = l_213;
    for (g_77 = 0; (g_77 > 14); g_77 += 1)
    { /* block id: 146 */
        struct S0 l_216 = {0xEF6B1D4CL,-8L,0xA5ED94E9L};
        struct S0 l_217 = {0x19071DA0L,0x6FCE70BDL,0x7AD0C03DL};
        g_120 = g_148;
        l_217 = (l_216 = l_213);
    }
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads : g_148 g_25 g_77 g_29 g_117 g_120 g_113
 * writes: g_113 g_25 g_117 g_120 g_148 g_176 g_211
 */
static struct S0  func_55(uint16_t  p_56, uint16_t  p_57, int32_t  p_58, int16_t  p_59, int32_t  p_60)
{ /* block id: 131 */
    struct S0 l_193 = {18446744073709551615UL,1L,0x92E5D78FL};
    int32_t l_208 = 1L;
    struct S0 l_212 = {1UL,-1L,0x79624376L};
    l_193 = g_148;
    p_58 = ((int16_t)func_79(((int16_t)func_107(l_193) - (int16_t)((int32_t)((uint32_t)p_60 % (uint32_t)p_60) + (int32_t)l_193.f2))) * (int16_t)p_56);
    l_208 = (0x8.4p+1 == (__builtin_popcount(g_120.f0) > (0xC.50D5A8p+4 <= (l_193.f2 = ((((float)l_193.f0 + (float)(l_193.f0 >= (g_176 = (!p_57)))) != ((l_193.f2 <= (((float)(((l_193.f1 = (((!((0xA.A1104Bp-11 == 0x5.FD2FE4p+20) == l_193.f1)) >= p_57) != 0x0.6p+1)) > g_148.f0) < 0x0.8p+1) + (float)g_117) == p_59)) >= g_117)) >= (-0x5.Ep-1))))));
    p_58 = (((int32_t)(g_211 = 0xB98E7B1AL) - (int32_t)p_57) <= g_148.f2);
    return l_212;
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_29 g_77 g_117 g_120 g_148.f1 g_148 g_113
 * writes: g_77 g_25 g_113 g_117 g_120 g_148 g_176
 */
static uint32_t  func_65(int32_t  p_66, float  p_67, uint32_t  p_68, int32_t  p_69)
{ /* block id: 46 */
    uint32_t l_78 = 0x44077424L;
    int32_t l_183 = (-7L);
    int32_t l_184 = 1L;
    int32_t l_190 = 0xD4632091L;
    int32_t l_192 = (-7L);
    for (p_68 = 0; (p_68 >= 54); p_68 += 1)
    { /* block id: 49 */
        uint32_t l_189 = 4294967295UL;
        int32_t l_191 = 4L;
        l_78 = ((((p_67 = g_25) >= (((float)(g_77 = ((-0x1.8p+1) < 0x9.Ep+1)) + (float)0xE.AD5889p-62) <= p_68)) <= p_69) > 0x1.7p+1);
        if (g_29)
            break;
        l_192 = (l_191 = ((((l_184 = (l_183 = func_79(p_68))) ^ l_78) <= g_29) <= (l_78 < (__builtin_parity((l_190 = (((uint32_t)5UL % (uint32_t)0x1BC699B5L) && (((int16_t)0x7F4EL << (int16_t)l_189) | 0xD5FB7F66L)))) && l_189))));
    }
    return g_117;
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_29 g_77 g_117 g_120 g_148.f1 g_148 g_113
 * writes: g_25 g_113 g_117 g_120 g_148 g_176
 */
static int32_t  func_79(int16_t  p_80)
{ /* block id: 54 */
    int32_t l_91 = (-9L);
    int32_t l_149 = (-3L);
    struct S0 l_180 = {6UL,7L,0x4109EAC8L};
    for (p_80 = 0; (p_80 != (-4)); p_80--)
    { /* block id: 57 */
        struct S0 l_109 = {0x7BB9FEC4L,1L,8L};
        for (g_25 = 0; (g_25 == 28); g_25 += 1)
        { /* block id: 60 */
            uint32_t l_150 = 4294967289UL;
            int32_t l_151 = 1L;
            l_180 = func_85(func_87(((uint16_t)(l_91 = g_29) * (uint16_t)((l_151 = ((g_29 ^ (((int16_t)(l_109.f2 = (((uint16_t)((int16_t)(__builtin_parityll((((int16_t)(((!(-9L)) && ((((uint16_t)((g_77 <= ((uint16_t)65535UL >> (uint16_t)(l_149 = func_105((p_80 ^ func_107(l_109)))))) && (-1L)) * (uint16_t)p_80) <= g_77) | l_109.f2)) != 0x8299C91EL) >> (int16_t)1) < g_25)) == p_80) >> (int16_t)l_150) << (uint16_t)7) <= l_150)) % (int16_t)0x848CL) & l_109.f1)) >= p_80)) != g_25))));
            g_176 = (((float)0x1.4p+1 - (float)0x1.FA2DA9p+35) <= func_107(l_180));
            if (g_77)
                continue;
        }
        g_120 = l_109;
        l_180.f2 = 0L;
    }
    l_180 = g_148;
    return g_113;
}


/* ------------------------------------------ */
/* 
 * reads : g_120.f2 g_29 g_120.f0 g_148.f1
 * writes: g_148.f2 g_113
 */
static struct S0  func_85(struct S0  p_86)
{ /* block id: 106 */
    uint32_t l_153 = 18446744073709551615UL;
    uint16_t l_175 = 0xEBECL;
    int32_t l_177 = 0xD8A59CA4L;
    int32_t l_178 = 1L;
    struct S0 l_179 = {18446744073709551611UL,0x78BF6E46L,0x303744F0L};
    g_148.f2 = p_86.f1;
    l_153 = p_86.f2;
    l_178 = ((int16_t)g_120.f2 + (int16_t)(l_153 ^ ((uint16_t)((int16_t)g_120.f2 >> (int16_t)(((g_29 > (p_86.f1 = (-2L))) && ((uint16_t)(((uint16_t)((uint16_t)(l_177 = ((((((int32_t)p_86.f1 + (int32_t)((((int16_t)((g_113 = ((-7L) > ((uint16_t)(((uint16_t)(0x6642384DL != (~(l_175 = 0x1173L))) >> (uint16_t)8) == p_86.f1) >> (uint16_t)l_153))) > g_120.f0) - (int16_t)65534UL) > p_86.f0) != 1L)) >= g_120.f0) | g_148.f1) > 0UL) >= l_153)) + (uint16_t)0x997DL) * (uint16_t)l_153) & l_153) * (uint16_t)p_86.f0)) && (-4L))) * (uint16_t)l_153)));
    return l_179;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_87(int32_t  p_88)
{ /* block id: 102 */
    struct S0 l_152 = {18446744073709551611UL,1L,1L};
    l_152 = l_152;
    l_152.f2 = p_88;
    return l_152;
}


/* ------------------------------------------ */
/* 
 * reads : g_117 g_77 g_120 g_25 g_29
 * writes: g_117 g_120 g_113 g_148
 */
static uint16_t  func_105(int32_t  p_106)
{ /* block id: 67 */
    int16_t l_115 = 0x27EAL;
    struct S0 l_116 = {0xBE66BFFEL,0xAB02DA2EL,0x94A57C39L};
    if ((l_115 = 0L))
    { /* block id: 69 */
        l_116 = l_116;
        return p_106;
    }
    else
    { /* block id: 72 */
        int32_t l_123 = 0x8CFF8D1EL;
        int32_t l_136 = 1L;
        struct S0 l_147 = {0x11D1409FL,1L,0xED032138L};
        if ((g_117 = (0xE7B382E3L <= 0x6063715EL)))
        { /* block id: 74 */
            uint32_t l_130 = 4294967293UL;
            int32_t l_131 = 0x844B9EA6L;
            uint32_t l_132 = 0xDA84259BL;
            for (l_116.f0 = 28; (l_116.f0 != 31); l_116.f0++)
            { /* block id: 77 */
                g_120 = l_116;
                return p_106;
            }
            l_116.f2 = (((((int16_t)l_123 << (int16_t)5) && g_117) >= 0x6D1EL) && (l_116.f0 & (((uint16_t)g_77 + (uint16_t)((uint16_t)((uint16_t)p_106 >> (uint16_t)10) + (uint16_t)(0UL >= l_130))) != (l_131 = p_106))));
            l_132 = p_106;
        }
        else
        { /* block id: 84 */
            int32_t l_135 = 0xBDD4A0C5L;
            int32_t l_139 = 0L;
            int16_t l_144 = 0x7E5FL;
            l_123 = (-3L);
            l_136 = (func_107(g_120) <= (l_144 = (((float)(l_139 = ((l_135 = g_29) >= (((l_123 = p_106) != l_136) <= ((float)p_106 * (float)(l_139 != __builtin_parityll(((int16_t)l_139 * (int16_t)(((int16_t)((0xE5016CB7L != g_29) == p_106) - (int16_t)0x7E63L) ^ p_106)))))))) + (float)g_25) >= g_120.f2)));
            l_116.f2 = ((int16_t)p_106 * (int16_t)65535UL);
            l_147 = l_116;
        }
        g_148 = g_120;
    }
    l_116.f2 = p_106;
    l_116.f2 = l_116.f0;
    return p_106;
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_77
 * writes: g_113
 */
static int32_t  func_107(struct S0  p_108)
{ /* block id: 62 */
    int16_t l_112 = (-8L);
    int32_t l_114 = 0xAFB9B03FL;
    g_113 = (g_25 > ((int32_t)g_25 + (int32_t)(p_108.f1 = l_112)));
    l_114 = l_112;
    return g_77;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_25, "g_25", print_hash_value);
    transparent_crc(g_29, "g_29", print_hash_value);
    transparent_crc(g_77, "g_77", print_hash_value);
    transparent_crc(g_113, "g_113", print_hash_value);
    transparent_crc(g_117, "g_117", print_hash_value);
    transparent_crc(g_120.f0, "g_120.f0", print_hash_value);
    transparent_crc(g_120.f1, "g_120.f1", print_hash_value);
    transparent_crc(g_120.f2, "g_120.f2", print_hash_value);
    transparent_crc(g_148.f0, "g_148.f0", print_hash_value);
    transparent_crc(g_148.f1, "g_148.f1", print_hash_value);
    transparent_crc(g_148.f2, "g_148.f2", print_hash_value);
    transparent_crc_bytes (&g_176, sizeof(g_176), "g_176", print_hash_value);
    transparent_crc(g_211, "g_211", print_hash_value);
    transparent_crc(g_221, "g_221", print_hash_value);
    transparent_crc(g_225, "g_225", print_hash_value);
    transparent_crc_bytes (&g_237, sizeof(g_237), "g_237", print_hash_value);
    transparent_crc(g_247, "g_247", print_hash_value);
    transparent_crc(g_260, "g_260", print_hash_value);
    transparent_crc(g_286, "g_286", print_hash_value);
    transparent_crc(g_312, "g_312", print_hash_value);
    transparent_crc_bytes (&g_335, sizeof(g_335), "g_335", print_hash_value);
    transparent_crc(g_362, "g_362", print_hash_value);
    transparent_crc(g_426, "g_426", print_hash_value);
    transparent_crc(g_471, "g_471", print_hash_value);
    transparent_crc(g_499.f0, "g_499.f0", print_hash_value);
    transparent_crc(g_499.f1, "g_499.f1", print_hash_value);
    transparent_crc(g_499.f2, "g_499.f2", print_hash_value);
    transparent_crc(g_545, "g_545", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 122
   depth: 1, occurrence: 28
XXX total union variables: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 171
   depth: 2, occurrence: 37
   depth: 3, occurrence: 5
   depth: 4, occurrence: 7
   depth: 5, occurrence: 2
   depth: 7, occurrence: 2
   depth: 9, occurrence: 3
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 3
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 2
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 492
XXX times a non-volatile is write: 213
XXX times a volatile is read: 12
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 166
XXX percentage of non-volatile access: 98.2

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 155
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 21
   depth: 2, occurrence: 21
   depth: 3, occurrence: 23
   depth: 4, occurrence: 21
   depth: 5, occurrence: 33

XXX percentage a fresh-made variable is used: 21.5
XXX percentage an existing variable is used: 78.5
********************* end of statistics **********************/

