/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      60981883
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = 0xDCAD313DL;
static int32_t g_95 = 0L;
static volatile int32_t g_132 = 5L;/* VOLATILE GLOBAL g_132 */
static volatile int32_t *g_131 = &g_132;
static volatile int32_t **g_130 = &g_131;
static int32_t g_143 = 0L;
static int32_t *g_142 = &g_143;
static float g_152 = 0x5.Dp+1;
static volatile uint32_t g_191 = 0x3A23B042L;/* VOLATILE GLOBAL g_191 */
static volatile int16_t g_262 = (-6L);/* VOLATILE GLOBAL g_262 */
static volatile float g_269 = 0xD.C5461Fp-42;/* VOLATILE GLOBAL g_269 */
static volatile int16_t g_271 = 0x554CL;/* VOLATILE GLOBAL g_271 */
static volatile int16_t g_277 = 1L;/* VOLATILE GLOBAL g_277 */
static uint16_t g_299 = 0xEBE3L;
static int32_t **g_307 = &g_142;
static int32_t ***g_306 = &g_307;
static int32_t ****g_305 = &g_306;
static volatile uint32_t g_427 = 0xBA7CE9A3L;/* VOLATILE GLOBAL g_427 */
static uint16_t g_500 = 65528UL;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_23(void);
static int32_t * func_24(int32_t * p_25, int8_t  p_26);
inline static int32_t * func_30(int32_t  p_31, int16_t  p_32, int32_t * p_33, int16_t  p_34, int32_t * p_35);
inline static int16_t  func_37(int32_t * p_38, uint8_t  p_39, int32_t * p_40, uint16_t  p_41);
static int32_t * func_42(int32_t * p_43, int32_t * p_44, int32_t * p_45, int32_t * p_46, uint8_t  p_47);
static int32_t * func_48(int32_t * p_49);
inline static int32_t * func_50(int32_t  p_51, int32_t * p_52);
static int32_t * func_59(int16_t  p_60, int32_t * p_61, int32_t  p_62, int32_t  p_63);
static int8_t  func_73(float  p_74, uint32_t  p_75, int16_t  p_76, int32_t  p_77);
static int16_t  func_78(uint32_t  p_79, int32_t * p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_271 g_95 g_191 g_307 g_142 g_143 g_305 g_306 g_299 g_131 g_130 g_3 g_152 g_132 g_277 g_500 g_262
 * writes: g_152 g_142 g_132 g_143 g_3 g_131 g_95
 */
static uint32_t  func_23(void)
{ /* block id: 36 */
    int32_t l_27 = (-5L);
    int32_t *l_431 = &g_143;
    float *l_432 = (void*)0;
    l_431 = func_24(&g_3, l_27);
    if (((void*)0 == l_432))
    { /* block id: 143 */
        int32_t l_437 = 1L;
        float *l_438 = &g_152;
        (*l_438) = ((float)__builtin_popcount(g_271) * (float)((float)g_95 - (float)l_437));
        for (l_27 = 0; (l_27 == (-27)); l_27 -= 1)
        { /* block id: 147 */
            return g_191;
        }
    }
    else
    { /* block id: 150 */
        volatile int32_t *l_443 = &g_132;
        int32_t l_455 = 0xC64C0F7EL;
        int32_t ***l_473 = &g_307;
        float l_501 = (-0x1.Dp+1);
        if ((**g_307))
        { /* block id: 151 */
            (***g_305) = (*g_307);
            (*g_131) = ((int32_t)0xE235BBF7L - (int32_t)g_299);
        }
        else
        { /* block id: 154 */
            float l_450 = 0x2.139005p-19;
            int32_t l_451 = (-1L);
            float **l_462 = &l_432;
            l_443 = (*g_130);
            if (((uint8_t)(g_95 && g_271) << (uint8_t)7))
            { /* block id: 156 */
                float **l_461 = (void*)0;
                int32_t l_463 = 0L;
                for (g_143 = 0; (g_143 == (-25)); g_143--)
                { /* block id: 159 */
                    float l_448 = 0x4.1p-1;
                    uint32_t l_449 = 0UL;
                    if (l_449)
                        break;
                    if (((g_191 & g_299) || l_451))
                    { /* block id: 161 */
                        uint16_t l_452 = 0x0BD6L;
                        float *l_460 = &l_448;
                        (*l_460) = (l_452 == ((float)(((0x6.Dp+1 > (((void*)0 != &g_306) > g_271)) != __builtin_parity(l_449)) == ((l_455 >= ((((((float)((float)(l_455 != 0x1.2p+1) * (float)g_299) - (float)g_95) != g_152) == (-0x1.0p+1)) == 0x9.9p+1) <= g_143)) == g_95)) * (float)0x9.3C38EEp-0));
                    }
                    else
                    { /* block id: 163 */
                        (*g_131) = (***g_306);
                    }
                }
                l_462 = l_461;
                (*l_431) ^= l_463;
                (****g_305) = ((int8_t)((int16_t)(g_271 > (-1L)) << (int16_t)((l_463 & ((***g_306) >= (*g_142))) | g_299)) % (int8_t)g_3);
            }
            else
            { /* block id: 170 */
                int8_t l_472 = 3L;
                int32_t l_478 = (-1L);
                l_478 &= (((uint8_t)(g_132 ^ l_472) + (uint8_t)g_95) | (((-1L) <= (((void*)0 != l_473) || ((uint16_t)func_78(((((int32_t)1L + (int32_t)(0L < (func_78((0x66L != 0x76L), (***g_305)) && 65527UL))) == (***l_473)) > 0UL), (**g_306)) - (uint16_t)0xD9BFL))) == 0x4C3DL));
                for (g_3 = 15; (g_3 < 27); g_3 += 1)
                { /* block id: 174 */
                    (*g_130) = (*g_130);
                }
                l_451 = ((float)(((float)func_37(func_50((((uint16_t)0x6EE5L % (uint16_t)(*l_431)) <= ((uint8_t)((int16_t)0xD315L >> (int16_t)14) >> (uint8_t)g_132)), (**g_306)), (((void*)0 == &l_431) != ((uint16_t)g_299 + (uint16_t)(***l_473))), &l_451, g_299) - (float)(***l_473)) == (-0x1.6p-1)) * (float)g_143);
                (*l_443) ^= l_451;
            }
        }
        (***g_305) = (**g_306);
        for (g_143 = (-25); (g_143 != (-8)); g_143 += 1)
        { /* block id: 184 */
            int16_t l_495 = 0x1C96L;
            uint32_t l_498 = 4294967293UL;
            float l_499 = 0x1.5p+1;
            float *l_502 = (void*)0;
            float *l_503 = &l_501;
            (***g_305) = func_48(func_59(l_495, l_431, func_73(((((((-(float)(__builtin_clzll(((g_277 != (-(uint32_t)(*l_431))) != (0x1DL || (*l_431)))) >= l_498)) > ((**g_305) != &l_431)) == g_299) != 0x5.1p-1) >= 0x0.1p-1) >= (*l_431)), g_500, g_500, g_3), g_500));
            if ((****g_305))
                break;
            (*l_503) = l_501;
            (**l_473) = func_50(l_498, l_502);
        }
    }
    (****g_305) ^= (*l_431);
    return g_262;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_24(int32_t * p_25, int8_t  p_26)
{ /* block id: 37 */
    uint8_t l_36 = 1UL;
    int32_t *l_144 = &g_143;
    int32_t l_186 = (-7L);
    int32_t l_247 = 0L;
    for (p_26 = (-20); (p_26 > (-1)); p_26 += 2)
    { /* block id: 40 */
        int32_t *l_145 = (void*)0;
        int32_t l_146 = 1L;
        int32_t **l_155 = &l_144;
        int32_t l_158 = 0xA8165F17L;
        float *l_159 = (void*)0;
        float *l_160 = &g_152;
        int32_t ***l_162 = &l_155;
        int32_t ****l_161 = &l_162;
        int16_t l_206 = 0x86CCL;
        int32_t l_235 = 1L;
        int32_t l_264 = (-8L);
        int32_t l_280 = 3L;
    }
    return p_25;
}


/* ------------------------------------------ */
/* 
 * reads : g_95 g_3
 * writes: g_152 g_3
 */
inline static int32_t * func_30(int32_t  p_31, int16_t  p_32, int32_t * p_33, int16_t  p_34, int32_t * p_35)
{ /* block id: 81 */
    float *l_151 = &g_152;
    (*l_151) = ((float)((-0x8.4p+1) >= g_95) * (float)0x5.15DCBDp-73);
    for (p_34 = 0; (p_34 != (-16)); p_34 -= 1)
    { /* block id: 85 */
        (*p_35) &= (l_151 != (void*)0);
    }
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_131 g_132 g_130
 * writes: g_132
 */
inline static int16_t  func_37(int32_t * p_38, uint8_t  p_39, int32_t * p_40, uint16_t  p_41)
{ /* block id: 77 */
    uint32_t l_147 = 0x436FCA15L;
    int32_t l_148 = (-1L);
    (**g_130) = (*g_131);
    l_148 = l_147;
    return g_132;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_42(int32_t * p_43, int32_t * p_44, int32_t * p_45, int32_t * p_46, uint8_t  p_47)
{ /* block id: 75 */
    return &g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_95 g_130 g_131 g_132
 * writes: g_95 g_3 g_132 g_131
 */
static int32_t * func_48(int32_t * p_49)
{ /* block id: 56 */
    int32_t *l_114 = &g_3;
    int32_t l_124 = 8L;
    l_114 = (void*)0;
    (*p_49) = g_3;
    for (g_95 = 0; (g_95 >= 6); g_95 += 1)
    { /* block id: 61 */
        int32_t **l_120 = &l_114;
        int32_t ***l_119 = &l_120;
        int32_t l_136 = 0x5F0A2838L;
        if (((((uint8_t)1UL << (uint8_t)5) < (l_119 == (void*)0)) > 0L))
        { /* block id: 62 */
            int32_t *l_121 = (void*)0;
            int32_t *l_122 = &g_3;
            (**l_119) = (void*)0;
            (*l_122) ^= 2L;
            (*l_122) = 0x0388C07AL;
            (**g_130) = (~((l_124 == (((uint8_t)((uint16_t)0x163BL * (uint16_t)func_78((-(int32_t)((__builtin_ctzll(((0UL >= (((g_95 == (g_130 == &l_122)) >= ((*g_130) != p_49)) >= (~((int32_t)((((3L >= (-4L)) || l_136) && g_95) || l_136) + (int32_t)g_95)))) <= g_132)) >= g_95) != (-4L))), (**l_119))) << (uint8_t)5) > (*p_49))) <= g_95));
        }
        else
        { /* block id: 67 */
            uint32_t l_141 = 0x740E2D3EL;
            (*g_131) = __builtin_clzll(((uint8_t)((uint8_t)g_3 << (uint8_t)2) + (uint8_t)g_132));
            l_141 |= 0x6ABA2F2EL;
            (*g_130) = (*g_130);
        }
        if ((*p_49))
            break;
    }
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_95
 * writes: g_3 g_95
 */
inline static int32_t * func_50(int32_t  p_51, int32_t * p_52)
{ /* block id: 41 */
    uint32_t l_55 = 4294967289UL;
    int32_t l_58 = 0x3758185FL;
    int16_t l_81 = 6L;
    int32_t *l_113 = (void*)0;
    int32_t **l_112 = &l_113;
    l_58 ^= (g_3 == __builtin_clzl(((uint8_t)0x1DL << (uint8_t)((l_55 & (((0xD7D41305L | (((uint16_t)(p_52 == &g_3) >> (uint16_t)14) || l_55)) != (1L ^ g_3)) < 0x27L)) & p_51))));
    (*l_112) = func_59((((uint8_t)0xACL >> (uint8_t)6) != ((uint8_t)((uint32_t)l_58 - (uint32_t)((-(int16_t)((((((int16_t)(func_73(l_55, p_51, func_78((l_81 < p_51), &l_58), (!l_55)) > (-1L)) + (int16_t)p_51) <= 0x838156ACL) ^ 0xA2L) || g_3) != l_81)) < p_51)) * (uint8_t)l_55)), &l_58, l_55, l_55);
    return &g_95;
}


/* ------------------------------------------ */
/* 
 * reads : g_95 g_3
 * writes: g_3 g_95
 */
static int32_t * func_59(int16_t  p_60, int32_t * p_61, int32_t  p_62, int32_t  p_63)
{ /* block id: 50 */
    int32_t *l_97 = &g_95;
    int32_t **l_96 = &l_97;
    int32_t ***l_98 = &l_96;
    (*l_98) = l_96;
    (**l_96) = (((float)(((-(float)0x0.Dp+1) < (p_62 == ((float)func_78((*l_97), (**l_98)) + (float)((float)((float)(g_95 > ((***l_98) < 0x2.0p-1)) + (float)((float)((float)g_95 * (float)g_95) + (float)(*l_97))) - (float)0x3.91844Cp-16)))) <= p_60) + (float)g_95) <= 0x1.Dp-1);
    return &g_95;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_95
 * writes: g_3 g_95
 */
static int8_t  func_73(float  p_74, uint32_t  p_75, int16_t  p_76, int32_t  p_77)
{ /* block id: 47 */
    int32_t l_92 = 0x464CC08FL;
    int32_t *l_94 = &g_95;
    (*l_94) &= __builtin_popcountl((p_76 && func_78((g_3 & (250UL >= ((int16_t)(l_92 & (l_92 ^ p_76)) << (int16_t)((~((0x1F7FL == __builtin_bswap32(g_3)) < g_3)) && p_77)))), &g_3)));
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes: g_3
 */
static int16_t  func_78(uint32_t  p_79, int32_t * p_80)
{ /* block id: 43 */
    uint8_t l_82 = 4UL;
    int32_t *l_87 = (void*)0;
    int32_t *l_88 = &g_3;
    l_82 &= (p_79 != (p_80 != &g_3));
    (*l_88) &= (l_82 | ((-7L) < (((int8_t)(1L ^ (2UL > ((uint8_t)p_79 % (uint8_t)0x41L))) * (int8_t)(l_82 > l_82)) != l_82)));
    return g_3;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_23();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_95, "g_95", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_143, "g_143", print_hash_value);
    transparent_crc_bytes (&g_152, sizeof(g_152), "g_152", print_hash_value);
    transparent_crc(g_191, "g_191", print_hash_value);
    transparent_crc(g_262, "g_262", print_hash_value);
    transparent_crc_bytes (&g_269, sizeof(g_269), "g_269", print_hash_value);
    transparent_crc(g_271, "g_271", print_hash_value);
    transparent_crc(g_277, "g_277", print_hash_value);
    transparent_crc(g_299, "g_299", print_hash_value);
    transparent_crc(g_427, "g_427", print_hash_value);
    transparent_crc(g_500, "g_500", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 80
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 10
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 2

XXX total number of pointers: 230

XXX times a variable address is taken: 198
XXX times a pointer is dereferenced on RHS: 55
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 11
   depth: 3, occurrence: 10
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 49
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 7
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 584

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 191
   level: 2, occurrence: 50
   level: 3, occurrence: 30
   level: 4, occurrence: 11
XXX number of pointers point to pointers: 16
XXX number of pointers point to scalars: 214
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 19.1
XXX average alias set size: 1.08

XXX times a non-volatile is read: 344
XXX times a non-volatile is write: 142
XXX times a volatile is read: 25
XXX    times read thru a pointer: 2
XXX times a volatile is write: 8
XXX    times written thru a pointer: 6
XXX times a volatile is available for access: 87
XXX percentage of non-volatile access: 93.6

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 65
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 8
   depth: 2, occurrence: 16
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
********************* end of statistics **********************/

