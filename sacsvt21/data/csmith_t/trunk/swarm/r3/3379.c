/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2226295539
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   volatile uint32_t  f0;
   int8_t  f1;
   const uint32_t  f2;
   uint16_t  f3;
   int8_t  f4;
   uint32_t  f5;
   const volatile int32_t  f6;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int16_t  f0;
   const int16_t  f1;
   const uint32_t  f2;
   const struct S0  f3;
   float  f4;
   int32_t  f5;
   const uint32_t  f6;
   int32_t  f7;
   int8_t  f8;
};
#pragma pack(pop)

union U2 {
   uint32_t  f0;
   struct S0  f1;
   volatile int8_t  f2;
   volatile int16_t  f3;
   float  f4;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_10 = 1UL;
static const int32_t g_32 = 0x5E4BC795L;
static int32_t g_50 = 1L;
static struct S0 g_66 = {0x01AF02C1L,0x94L,4294967292UL,5UL,0xC7L,18446744073709551615UL,0x93DFE8E2L};/* VOLATILE GLOBAL g_66 */
static int32_t g_72 = 1L;
static int32_t * const  volatile g_71 = &g_72;/* VOLATILE GLOBAL g_71 */
static struct S0 g_74 = {1UL,0x16L,0x6C9A4A91L,0UL,1L,1UL,0x536CA9A4L};/* VOLATILE GLOBAL g_74 */
static struct S0 *g_73 = &g_74;
static struct S0 ** volatile g_75 = (void*)0;/* VOLATILE GLOBAL g_75 */
static int32_t *g_78 = (void*)0;
static int32_t ** volatile g_77 = &g_78;/* VOLATILE GLOBAL g_77 */
static int32_t g_85 = 4L;
static int32_t * const g_84 = &g_85;
static int32_t * const *g_83 = &g_84;
static float g_127 = 0xA.461874p-97;
static volatile union U2 g_129 = {0x3424908FL};/* VOLATILE GLOBAL g_129 */
static volatile union U2 * volatile g_128 = &g_129;/* VOLATILE GLOBAL g_128 */
static float * volatile g_151 = &g_127;/* VOLATILE GLOBAL g_151 */
static union U2 g_183 = {1UL};/* VOLATILE GLOBAL g_183 */
static float g_223 = 0xF.B9ED89p-55;
static float * volatile g_236 = (void*)0;/* VOLATILE GLOBAL g_236 */
static float * volatile g_237 = &g_223;/* VOLATILE GLOBAL g_237 */
static int32_t ** const  volatile g_241 = &g_78;/* VOLATILE GLOBAL g_241 */
static union U2 g_243 = {1UL};/* VOLATILE GLOBAL g_243 */
static union U2 *g_242 = &g_243;
static struct S1 g_252 = {1L,-10L,0xA8D3F645L,{0xBDCCDAA9L,1L,0x579BCBDFL,0x1FF8L,-1L,0x20862D8EL,0xCAC08942L},0x1.6p+1,0x3C3D6B9CL,18446744073709551615UL,0xBA933876L,0xE8L};/* VOLATILE GLOBAL g_252 */
static struct S1 *g_251 = &g_252;
static float * volatile g_314 = &g_127;/* VOLATILE GLOBAL g_314 */
static uint32_t g_363 = 4294967295UL;
static int32_t ** volatile g_419 = &g_78;/* VOLATILE GLOBAL g_419 */
static struct S0 ** volatile *g_424 = &g_75;
static struct S0 ** volatile ** const  volatile g_423 = &g_424;/* VOLATILE GLOBAL g_423 */
static int32_t ** volatile g_456 = &g_78;/* VOLATILE GLOBAL g_456 */
static volatile float *g_461 = &g_129.f4;
static volatile float * volatile *g_460 = &g_461;
static volatile float * volatile ** const g_459 = &g_460;
static const float g_485 = 0x2.A63300p-13;
static uint16_t g_521 = 0UL;
static int16_t g_532 = 1L;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static uint32_t  func_11(int8_t  p_12, float  p_13, uint32_t  p_14, float  p_15, float  p_16);
static uint32_t  func_17(uint16_t  p_18, uint16_t  p_19, int16_t  p_20);
static uint16_t  func_21(int8_t  p_22, float  p_23, uint16_t  p_24, int16_t  p_25, uint32_t  p_26);
static int32_t * func_33(uint32_t  p_34, const int32_t  p_35, int32_t * const * p_36, uint32_t  p_37);
static uint16_t  func_40(int32_t ** p_41, int32_t ** p_42, const uint32_t  p_43);
static int32_t ** func_44(int32_t  p_45, int32_t * p_46);
static int32_t * func_47(int32_t * p_48);
static struct S0 * func_51(int32_t  p_52, uint32_t  p_53, struct S0 * p_54, int32_t * p_55);
static uint16_t  func_58(const int32_t * const  p_59, struct S0 * p_60, struct S0 * p_61, int8_t  p_62, float  p_63);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_10 g_50 g_71 g_73 g_77 g_83 g_78 g_66.f5 g_74.f3 g_66.f3 g_32 g_74.f0 g_74.f2 g_84 g_66.f0 g_72 g_128 g_66.f2 g_66.f4 g_151 g_127 g_183.f0 g_223 g_237 g_241 g_183.f1.f3 g_251 g_252.f3.f4 g_252.f8 g_243.f1.f1 g_252.f3.f2 g_252.f6 g_314 g_74.f4 g_85 g_252.f7 g_363 g_66.f1 g_243.f1.f4 g_183.f3 g_252.f5 g_74.f5 g_419 g_423 g_252.f3.f6 g_456 g_459 g_252.f1 g_461 g_252.f3.f5 g_521 g_532
 * writes: g_72 g_50 g_78 g_85 g_127 g_128 g_66.f4 g_183.f4 g_223 g_242 g_10 g_183.f1.f3 g_243.f1.f1 g_251 g_74.f4 g_252.f7 g_243.f1.f4 g_424 g_129.f4
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_7 = 0L;
    const struct S0 *l_320 = (void*)0;
    const struct S0 **l_319 = &l_320;
    float *l_322 = &g_223;
    int8_t l_362 = 0xC9L;
    union U2 *l_417 = &g_243;
    struct S1 **l_429 = &g_251;
    struct S0 ***l_447 = (void*)0;
    struct S0 ****l_446 = &l_447;
    float **l_463 = (void*)0;
    float ** const *l_462 = &l_463;
    int8_t l_482 = 0x09L;
    if ((((uint32_t)(!((int16_t)(l_7 < l_7) / (int16_t)((int32_t)g_10 + (int32_t)g_10))) + (uint32_t)l_7) ^ func_11((func_17(g_10, ((g_10 == (func_21(g_10, (+((float)((l_7 != g_10) < l_7) - (float)(-0x10.7p-1))), l_7, l_7, g_10) | g_66.f2)) | 0xBFF5L), g_66.f4) <= 4294967290UL), g_223, l_7, l_7, l_7)))
    { /* block id: 95 */
        int32_t *l_244 = &g_50;
        const struct S0 *l_297 = &g_252.f3;
        const struct S0 **l_296 = &l_297;
        int32_t l_313 = 0x9842C5C3L;
        struct S0 **l_321 = (void*)0;
        const int16_t l_328 = 0xB682L;
        uint32_t l_361 = 1UL;
        int32_t **l_369 = &g_78;
        if ((65528UL | ((int16_t)g_183.f0 << (int16_t)8)))
        { /* block id: 96 */
            int32_t **l_240 = (void*)0;
            (*g_241) = (*g_83);
            /* statement id: 97 */
            assert (g_78 == &g_85);
            g_242 = &g_183;
            /* statement id: 98 */
            assert (g_242 == &g_183);
        }
        else
        { /* block id: 99 */
            uint32_t l_278 = 0x5BF4E3E4L;
            int32_t * const l_279 = &g_50;
lbl_299:
            (*g_77) = func_47(l_244);
            /* statement id: 100 */
            assert (g_78 == &g_50);
            for (g_10 = 0; (g_10 >= 10); g_10 += 1)
            { /* block id: 103 */
                float l_262 = 0xB.7576DCp-75;
                const int32_t l_292 = (-7L);
                for (g_183.f1.f3 = (-29); (g_183.f1.f3 <= 4); g_183.f1.f3 += 4)
                { /* block id: 106 */
                    struct S1 *l_249 = (void*)0;
                    struct S1 **l_250 = &l_249;
                    int32_t l_263 = 0x7A906813L;
                    (*l_250) = l_249;
                    (*l_250) = g_251;
                    /* statement id: 108 */
                    assert (l_249 == &g_252);
                    if (g_50)
                        goto lbl_368;
                    (*g_84) = ((uint16_t)((uint32_t)((int16_t)(((-(int16_t)0L) || ((int16_t)((&g_75 != &g_75) > l_263) << (int16_t)((((int32_t)((uint16_t)(l_263 ^ ((int32_t)((g_252.f3.f4 != ((uint16_t)(~1L) << (uint16_t)(((**g_241) >= ((!(((int16_t)0xDE5FL << (int16_t)g_252.f8) < 65531UL)) < (-1L))) >= l_278))) >= l_263) + (int32_t)g_252.f8)) >> (uint16_t)9) / (int32_t)0xF3A0AF4FL) > 3L) && g_10))) >= 1UL) << (int16_t)(*l_244)) + (uint32_t)(-1L)) + (uint16_t)g_32);
                }
                if (l_278)
                    continue;
                (*g_241) = l_279;
                for (g_243.f1.f1 = 0; (g_243.f1.f1 != 21); g_243.f1.f1 += 7)
                { /* block id: 115 */
                    float l_298 = 0x7.CB9172p+79;
                    for (g_183.f1.f3 = (-12); (g_183.f1.f3 != 27); ++g_183.f1.f3)
                    { /* block id: 118 */
                        struct S1 **l_284 = (void*)0;
                        int32_t **l_285 = &g_78;
                        float *l_293 = &l_262;
                        g_251 = &g_252;
                        (*l_285) = l_244;
                        (*l_285) = (*g_241);
                        (*l_293) = ((float)((((((-0x1.Cp-1) < ((float)((float)l_292 / (float)((((0x5.Dp+1 != (0xD.3B7AFEp-86 >= ((void*)0 != l_293))) != (*l_244)) < ((float)(((**l_285) == (l_296 != (void*)0)) != l_298) - (float)(*g_151))) > g_252.f3.f2)) - (float)(**l_285))) != g_223) != l_7) <= 0x8.54ED2Dp-32) == l_7) + (float)g_252.f6);
                    }
                }
            }
            if (g_72)
                goto lbl_299;
            for (g_10 = (-21); (g_10 != 39); g_10 += 1)
            { /* block id: 129 */
                struct S0 *l_310 = &g_74;
                struct S0 **l_312 = &g_73;
                struct S0 ***l_311 = &l_312;
                (**g_83) = ((int16_t)((uint16_t)l_7 % (uint16_t)((uint16_t)((l_310 != (void*)0) || (l_311 == &g_75)) - (uint16_t)(*l_244))) >> (int16_t)7);
            }
        }
        /* facts after branching */
        assert (g_78 == &g_50 || g_78 == &g_85);
        assert (g_242 == &g_243 || g_242 == &g_183);
        (*g_314) = ((*g_151) <= ((*l_244) == l_313));
        if ((((uint32_t)4294967295UL / (uint32_t)((int16_t)((l_319 != l_321) & (*l_244)) >> (int16_t)15)) == (((-1L) || (l_7 & ((void*)0 != l_322))) & ((l_7 != 0x7700L) ^ 0x16BBL))))
        { /* block id: 134 */
            int32_t *l_323 = &g_252.f7;
            int32_t **l_324 = &g_78;
            struct S0 *l_327 = &g_74;
            uint32_t l_364 = 18446744073709551612UL;
            (*l_324) = l_323;
            /* statement id: 135 */
            assert (g_78 == &g_252.f7);
            for (g_74.f4 = 0; (g_74.f4 != (-23)); g_74.f4 -= 1)
            { /* block id: 138 */
                int32_t ***l_338 = &l_324;
                (*l_319) = func_51((*g_84), g_32, l_327, l_244);
                /* statement id: 139 */
                assert (l_320 == &g_74);
            }
            /* facts after for loop */
            assert (l_320 == &g_74 || l_320 == 0);
            l_244 = func_47(func_47((*g_241)));
            for (g_243.f1.f1 = 0; (g_243.f1.f1 < 16); g_243.f1.f1 += 1)
            { /* block id: 145 */
                struct S0 ***l_349 = &l_321;
                float **l_365 = &l_322;
                float ***l_366 = (void*)0;
                float ***l_367 = &l_365;
                (*l_322) = ((float)((float)((float)((float)(((void*)0 == l_349) != (+((void*)0 == &g_252))) + (float)((void*)0 == l_244)) + (float)((float)(((void*)0 == (*l_324)) == ((((((float)((float)(((float)(((float)l_361 / (float)l_362) > g_363) + (float)0xA.13EBE0p-26) == (*g_151)) / (float)0xD.26BAD4p-90) / (float)(*l_323)) <= g_66.f1) < l_364) <= g_252.f3.f4) <= g_74.f2)) - (float)0x0.7p-1)) / (float)0x2.1D8A30p+52) - (float)0x7.D037EFp-91);
                if ((*l_244))
                    continue;
                (*l_367) = l_365;
                (*l_244) = l_7;
            }
        }
        else
        { /* block id: 151 */
lbl_368:
            (*l_319) = (void*)0;
            (*l_369) = (*g_241);
        }
        /* facts after branching */
        assert (g_78 == &g_50 || g_78 == &g_85 || g_78 == &g_252.f7);
        assert (l_320 == &g_74 || l_320 == 0);
    }
    else
    { /* block id: 156 */
        int8_t l_408 = (-7L);
        int32_t l_484 = 0x73CABBDAL;
        int32_t l_520 = 0xF83E59C1L;
        struct S0 **** const l_529 = (void*)0;
        if ((0x9FD1L || 0UL))
        { /* block id: 157 */
            union U2 *l_376 = &g_243;
            uint32_t l_379 = 4294967294UL;
            for (g_50 = 15; (g_50 <= (-29)); g_50 -= 1)
            { /* block id: 160 */
                for (g_243.f1.f1 = (-23); (g_243.f1.f1 < 11); ++g_243.f1.f1)
                { /* block id: 163 */
                    uint32_t l_380 = 1UL;
                    float l_383 = (-0x1.Cp-1);
                    (**g_83) = ((uint32_t)(l_376 != &g_129) + (uint32_t)((uint16_t)((((-9L) == l_379) & ((&g_129 != (void*)0) && (l_380 ^ 65535UL))) & ((((int16_t)0x2724L + (int16_t)g_66.f0) && g_66.f5) > g_72)) >> (uint16_t)g_252.f8));
                    return (*g_84);
                }
                if (l_362)
                    break;
            }
            for (g_243.f1.f4 = 26; (g_243.f1.f4 != (-23)); g_243.f1.f4 -= 1)
            { /* block id: 171 */
                uint32_t l_386 = 1UL;
                (**g_83) = (l_379 & l_386);
            }
        }
        else
        { /* block id: 174 */
            const int32_t *l_416 = &g_50;
            union U2 **l_422 = &g_242;
            struct S1 **l_430 = (void*)0;
            uint16_t l_445 = 65535UL;
            float l_505 = (-0x8.Cp-1);
            struct S0 **l_531 = &g_73;
            struct S0 *** const l_530 = &l_531;
            if ((((((int32_t)(-9L) % (int32_t)((int16_t)g_183.f3 % (int16_t)(((uint16_t)((uint32_t)((int16_t)(l_362 || ((uint32_t)g_66.f4 + (uint32_t)(+(((int32_t)((int32_t)((uint32_t)g_66.f1 - (uint32_t)((uint32_t)(l_408 <= ((uint16_t)((65535UL ^ ((int16_t)(l_362 > (!(((((uint16_t)((*g_83) != l_416) / (uint16_t)g_66.f5) ^ 0xD1303F42L) <= 0xC1B909C9L) < (*l_416)))) >> (int16_t)g_252.f5)) & (*l_416)) + (uint16_t)65535UL)) / (uint32_t)(**g_83))) - (int32_t)g_74.f5) - (int32_t)(**g_83)) ^ (-10L))))) / (int16_t)l_7) + (uint32_t)g_66.f2) << (uint16_t)2) && (*g_84)))) > l_408) | l_408) && 0x32BCL))
            { /* block id: 175 */
                union U2 **l_418 = &g_242;
                (*l_418) = l_417;
                (*g_419) = (*g_83);
                /* statement id: 177 */
                assert (g_78 == &g_85);
                (*l_322) = l_408;
                (*l_322) = ((float)l_362 + (float)((((void*)0 != l_422) >= l_7) <= 0x7.7EDE6Dp+78));
            }
            else
            { /* block id: 180 */
                (*g_423) = &g_75;
                (*g_84) = l_408;
            }
            if ((((uint16_t)((int16_t)((l_429 == l_430) >= ((void*)0 != l_416)) - (int16_t)((int16_t)(((uint16_t)g_252.f3.f6 >> (uint16_t)3) & (g_32 ^ (((int16_t)(((uint16_t)((uint16_t)(((((((uint16_t)((g_10 < (l_7 == ((((((((((**g_83) <= g_50) | 0x1FA9EB54L) && (*l_416)) >= (-1L)) != (*g_84)) | 1L) > g_72) == 0L) < 0x0DB6L))) <= g_183.f0) / (uint16_t)l_408) || (*g_84)) != l_445) > l_362) & l_408) == 1UL) >> (uint16_t)8) % (uint16_t)g_252.f8) & 0L) >> (int16_t)6) & 1UL))) >> (int16_t)g_50)) / (uint16_t)l_7) < g_252.f7))
            { /* block id: 184 */
                struct S0 ***l_452 = (void*)0;
                int32_t l_455 = (-1L);
                int32_t l_483 = 3L;
                (**g_83) = ((((l_446 != (void*)0) ^ (((int32_t)l_362 - (int32_t)((int32_t)0L + (int32_t)0x0AEB775FL)) != ((*g_77) != (void*)0))) > (*g_84)) < ((void*)0 == l_452));
                (*g_456) = (*g_83);
                /* statement id: 186 */
                assert (g_78 == &g_85);
                if ((*g_71))
                { /* block id: 187 */
                    float l_476 = 0x0.FF4E73p+4;
                    int32_t l_477 = 7L;
                    for (g_10 = (-1); (g_10 != 49); ++g_10)
                    { /* block id: 190 */
                        (**g_241) = (g_459 != l_462);
                    }
                    l_484 = ((((uint16_t)((uint16_t)((int32_t)(0xBE566FA9L < (*l_416)) / (int32_t)(((*g_71) != ((uint16_t)((uint16_t)((int16_t)(((l_455 ^ l_477) == ((&g_83 != (void*)0) <= (((int16_t)((uint16_t)(((l_482 > (l_477 | 4294967292UL)) ^ l_362) | l_483) % (uint16_t)65535UL) << (int16_t)(*l_416)) & l_483))) && l_455) / (int16_t)0x2980L) << (uint16_t)l_408) >> (uint16_t)15)) || l_455)) - (uint16_t)g_252.f1) << (uint16_t)12) | 0UL) < l_482);
                    (*g_461) = 0xA.D26DE1p-35;
                    /* statement id: 194 */
                }
                else
                { /* block id: 195 */
                    int32_t l_499 = (-7L);
                    l_484 = ((l_362 > ((int32_t)(l_362 == (g_66.f2 <= g_66.f2)) - (int32_t)(((+((0UL > (((uint16_t)((((uint16_t)(((*l_416) || ((int32_t)((uint16_t)l_499 + (uint16_t)((uint32_t)((+((*l_416) == g_66.f4)) > l_484) / (uint32_t)4294967286UL)) + (int32_t)g_74.f3)) < (*g_71)) >> (uint16_t)2) >= 0xF66E37D7L) <= 65535UL) << (uint16_t)10) | l_455)) > (*g_84))) >= g_183.f0) != 0x2EC4L))) != 0xF518L);
                    (*g_84) = 0x8E22B802L;
                    for (l_362 = 0; (l_362 > (-30)); l_362 -= 1)
                    { /* block id: 200 */
                        (**g_83) = 0x67ED223CL;
                    }
                }
                /* facts after branching */
            }
            else
            { /* block id: 204 */
                uint32_t l_522 = 0x3BE10830L;
                (**g_83) = ((1UL || (((*g_71) <= (((uint16_t)0x51D2L >> (uint16_t)((0x370BL < (((int32_t)((uint16_t)g_252.f7 >> (uint16_t)((int16_t)1L - (int16_t)(((int16_t)((((int16_t)(((g_252.f3.f2 & (0x89B8L | ((((uint16_t)(((g_74.f3 > 65533UL) | l_484) > 0x2C25F3FEL) - (uint16_t)g_72) | l_7) == 1UL))) && g_72) ^ l_520) << (int16_t)g_252.f3.f5) & (*l_416)) <= 0x7899L) % (int16_t)g_66.f4) < (*l_416)))) / (int32_t)l_408) & (-10L))) > g_521)) >= 1UL)) < l_522)) != 0L);
                return l_522;
            }
            /* facts after branching */
            assert (g_78 == &g_85);
            (*l_429) = &g_252;
            (*g_84) = (0xF8497041L || ((int32_t)(((((int16_t)g_50 << (int16_t)(l_484 || ((5L < (*g_78)) > ((((int32_t)((void*)0 == l_529) - (int32_t)(*g_78)) <= (l_530 != (void*)0)) ^ l_482)))) < 0x7BA18B5CL) && l_484) < (**g_83)) % (int32_t)(**g_83)));
        }
    }
    /* facts after branching */
    assert (g_78 == &g_85 || g_78 == &g_50 || g_78 == 0 || g_78 == &g_252.f7);
    assert (g_242 == &g_243 || g_242 == &g_183);
    assert (l_320 == &g_74 || l_320 == 0);
    return g_532;
}


/* ------------------------------------------ */
/* 
 * reads : g_151 g_127 g_73 g_32 g_50 g_237 g_10
 * writes: g_223
 */
static uint32_t  func_11(int8_t  p_12, float  p_13, uint32_t  p_14, float  p_15, float  p_16)
{ /* block id: 92 */
    uint32_t l_228 = 1UL;
    const struct S0 **l_233 = (void*)0;
    int16_t l_234 = (-1L);
    float *l_235 = (void*)0;
    (*g_237) = ((float)(-0x10.Ap+1) + (float)(((float)((l_228 >= (((((*g_151) > l_228) > ((float)((float)(((l_228 <= (((g_73 != (void*)0) <= g_32) < (((void*)0 == l_233) <= g_50))) > 0x0.Fp+1) >= 0x5.C5E8F4p+23) + (float)g_50) / (float)l_228)) <= p_16) <= l_228)) > l_234) - (float)l_228) < g_32));
    return g_10;
}


/* ------------------------------------------ */
/* 
 * reads : g_83 g_84 g_66.f4 g_77 g_78 g_151 g_127 g_183.f0 g_74.f2
 * writes: g_78 g_66.f4 g_183.f4
 */
static uint32_t  func_17(uint16_t  p_18, uint16_t  p_19, int16_t  p_20)
{ /* block id: 44 */
    struct S0 *l_131 = &g_66;
    int32_t l_132 = (-1L);
    float *l_222 = &g_183.f4;
lbl_166:
    l_132 = (l_131 == l_131);
    for (p_20 = 0; (p_20 >= 25); ++p_20)
    { /* block id: 48 */
        int32_t **l_135 = &g_78;
        const float l_150 = 0x1.Ep-1;
        int16_t l_211 = 1L;
        (*l_135) = (*g_83);
        /* statement id: 49 */
        assert (g_78 == &g_85);
        for (g_66.f4 = 0; (g_66.f4 <= (-27)); g_66.f4 -= 4)
        { /* block id: 52 */
            int8_t l_140 = 0x18L;
            float *l_161 = &g_127;
            int32_t *l_176 = (void*)0;
            struct S0 **l_187 = &l_131;
            struct S0 ***l_186 = &l_187;
            for (l_132 = 0; (l_132 > 21); l_132 += 7)
            { /* block id: 55 */
                (*l_135) = (*g_77);
            }
        }
        if (p_20)
            goto lbl_166;
    }
    (*l_222) = ((float)((*g_151) > (((((float)g_183.f0 / (float)0x8.94FB20p+5) >= ((float)0x1.8p-1 + (float)(g_74.f2 != (0x9.261EF3p-22 == l_132)))) != p_20) == ((float)((float)((void*)0 != &l_132) / (float)p_18) / (float)(-0x7.8p+1)))) - (float)p_20);
    /* statement id: 90 */
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_50 g_71 g_73 g_77 g_83 g_78 g_66.f5 g_74.f3 g_66.f3 g_32 g_74.f0 g_74.f2 g_84 g_66.f0 g_72 g_128
 * writes: g_72 g_50 g_78 g_85 g_127 g_128
 */
static uint16_t  func_21(int8_t  p_22, float  p_23, uint16_t  p_24, int16_t  p_25, uint32_t  p_26)
{ /* block id: 1 */
    const int32_t *l_31 = &g_32;
    const int32_t **l_30 = &l_31;
    uint32_t l_38 = 0x83312EF3L;
    int32_t *l_49 = &g_50;
    const int8_t l_122 = (-1L);
    (*l_30) = (void*)0;
    /* statement id: 2 */
    assert (l_31 == 0);
    (*l_30) = func_33(l_38, (+func_40(func_44(g_10, func_47(l_49)), &l_49, ((uint16_t)(((0x66ABL >= p_22) < (0x186EL | p_24)) < p_25) >> (uint16_t)p_22))), g_83, p_24);
    /* statement id: 32 */
    assert (l_31 == &g_50 || l_31 == 0);
    assert (g_78 == &g_50 || g_78 == 0);
    if (((((void*)0 != l_49) | ((!(((int16_t)p_25 + (int16_t)g_50) | ((0x6E4FL == ((int16_t)((0xC0B7L & (((void*)0 != &l_49) != g_74.f2)) ^ p_26) / (int16_t)l_122)) & p_25))) | 0x88605791L)) | (*g_71)))
    { /* block id: 33 */
        float *l_126 = &g_127;
        for (g_72 = 0; (g_72 >= 24); g_72 += 1)
        { /* block id: 36 */
            int32_t l_125 = 0xEA24D657L;
            return l_125;
        }
        (*l_126) = 0x8.Ep+1;
    }
    else
    { /* block id: 40 */
        volatile union U2 * volatile *l_130 = &g_128;
        (*l_130) = g_128;
    }
    return g_50;
}


/* ------------------------------------------ */
/* 
 * reads : g_77 g_78 g_50 g_10 g_71 g_73 g_66.f5 g_74.f3 g_66.f3 g_32 g_74.f0 g_74.f2 g_84 g_66.f0 g_127 g_85
 * writes: g_72 g_50 g_78 g_85 g_127
 */
static int32_t * func_33(uint32_t  p_34, const int32_t  p_35, int32_t * const * p_36, uint32_t  p_37)
{ /* block id: 19 */
    int32_t **l_86 = &g_78;
lbl_102:
    (*l_86) = func_47((*g_77));
    /* statement id: 20 */
    assert (g_78 == &g_50);
    (*l_86) = func_47((*l_86));
    if (((*l_86) != (*l_86)))
    { /* block id: 22 */
        float l_89 = 0x0.Ap-1;
        struct S0 *l_98 = (void*)0;
        float *l_101 = &l_89;
        int32_t l_105 = 0xD9C50E9BL;
        (*l_101) = ((float)l_89 + (float)(((float)((float)(p_37 == (**l_86)) + (float)0x4.B09233p-39) - (float)g_66.f5) != (((float)(((float)(l_98 != l_98) + (float)(((float)0x0.08F4F8p-96 - (float)((**l_86) > g_66.f5)) <= g_74.f3)) != g_66.f3) / (float)g_50) == g_32)));
        if (g_10)
            goto lbl_102;
        (*g_84) = ((uint16_t)(l_105 ^ ((1L || (+g_74.f0)) != g_74.f2)) >> (uint16_t)0);
        return (*g_77);
        /* statement id: 26 */
        //assert (func_33_rv == &g_50);
    }
    else
    { /* block id: 27 */
        uint32_t l_111 = 0x07A49E81L;
        int16_t l_116 = 0x9701L;
        (*g_78) = ((p_34 & (((uint32_t)(p_37 & 0x52CFL) / (uint32_t)((uint16_t)l_111 % (uint16_t)p_34)) <= ((uint32_t)(((p_37 == l_111) & g_66.f0) ^ (((((((int32_t)0L % (int32_t)l_116) != 4294967289UL) >= g_74.f3) < 0xC386L) <= p_35) >= l_116)) + (uint32_t)6UL))) != 65533UL);
    }
    (*l_86) = (void*)0;
    /* statement id: 30 */
    assert (g_78 == 0);
    return (*g_77);
    /* statement id: 31 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_50 g_10 g_71 g_73
 * writes: g_72 g_50 g_78
 */
static uint16_t  func_40(int32_t ** p_41, int32_t ** p_42, const uint32_t  p_43)
{ /* block id: 15 */
    struct S0 **l_82 = &g_73;
    struct S0 ***l_81 = &l_82;
    (*l_81) = &g_73;
    (*p_41) = func_47(func_47((*p_42)));
    /* statement id: 17 */
    assert (g_78 == &g_50);
    return g_10;
}


/* ------------------------------------------ */
/* 
 * reads : g_77
 * writes: g_78
 */
static int32_t ** func_44(int32_t  p_45, int32_t * p_46)
{ /* block id: 12 */
    (*g_77) = &p_45;
    /* statement id: 13 */
    assert (g_78 == &p_45);
    return &g_78;
    /* statement id: 14 */
    //assert (g_78 == dangling);
    //assert (func_44_rv == &g_78);
}


/* ------------------------------------------ */
/* 
 * reads : g_50 g_10 g_71 g_73 g_85 g_127 g_252.f7
 * writes: g_72 g_50 g_85 g_127 g_252.f7
 */
static int32_t * func_47(int32_t * p_48)
{ /* block id: 3 */
    const int32_t * const l_64 = &g_50;
    struct S0 *l_65 = &g_66;
    struct S0 **l_76 = &l_65;
    (*l_76) = func_51(((*p_48) | (((uint16_t)func_58(l_64, l_65, l_65, (!((uint16_t)0x9C74L >> (uint16_t)(*l_64))), (((0x4.ECDE47p+1 <= (*l_64)) == g_10) == 0x1.56995Ep+10)) >> (uint16_t)0) || 0x9C0D2877L)), g_10, g_73, p_48);
    /* statement id: 10 */
    assert (l_65 == &g_74);
    return &g_50;
    /* statement id: 11 */
    //assert (func_47_rv == &g_50);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_50 g_85 g_127 g_252.f7
 */
static struct S0 * func_51(int32_t  p_52, uint32_t  p_53, struct S0 * p_54, int32_t * p_55)
{ /* block id: 7 */
    (*p_55) = 0xB02088C4L;
    return &g_74;
    /* statement id: 9 */
    //assert (func_51_rv == &g_74);
}


/* ------------------------------------------ */
/* 
 * reads : g_71
 * writes: g_72
 */
static uint16_t  func_58(const int32_t * const  p_59, struct S0 * p_60, struct S0 * p_61, int8_t  p_62, float  p_63)
{ /* block id: 4 */
    const uint32_t l_70 = 0UL;
    (*g_71) = l_70;
    return l_70;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_10, "g_10", print_hash_value);
    transparent_crc(g_32, "g_32", print_hash_value);
    transparent_crc(g_50, "g_50", print_hash_value);
    transparent_crc(g_66.f0, "g_66.f0", print_hash_value);
    transparent_crc(g_66.f1, "g_66.f1", print_hash_value);
    transparent_crc(g_66.f2, "g_66.f2", print_hash_value);
    transparent_crc(g_66.f3, "g_66.f3", print_hash_value);
    transparent_crc(g_66.f4, "g_66.f4", print_hash_value);
    transparent_crc(g_66.f5, "g_66.f5", print_hash_value);
    transparent_crc(g_66.f6, "g_66.f6", print_hash_value);
    transparent_crc(g_72, "g_72", print_hash_value);
    transparent_crc(g_74.f0, "g_74.f0", print_hash_value);
    transparent_crc(g_74.f1, "g_74.f1", print_hash_value);
    transparent_crc(g_74.f2, "g_74.f2", print_hash_value);
    transparent_crc(g_74.f3, "g_74.f3", print_hash_value);
    transparent_crc(g_74.f4, "g_74.f4", print_hash_value);
    transparent_crc(g_74.f5, "g_74.f5", print_hash_value);
    transparent_crc(g_74.f6, "g_74.f6", print_hash_value);
    transparent_crc(g_85, "g_85", print_hash_value);
    transparent_crc_bytes (&g_127, sizeof(g_127), "g_127", print_hash_value);
    transparent_crc(g_129.f0, "g_129.f0", print_hash_value);
    transparent_crc(g_129.f2, "g_129.f2", print_hash_value);
    transparent_crc(g_129.f3, "g_129.f3", print_hash_value);
    transparent_crc_bytes (&g_129.f4, sizeof(g_129.f4), "g_129.f4", print_hash_value);
    transparent_crc(g_183.f0, "g_183.f0", print_hash_value);
    transparent_crc(g_183.f2, "g_183.f2", print_hash_value);
    transparent_crc(g_183.f3, "g_183.f3", print_hash_value);
    transparent_crc_bytes (&g_183.f4, sizeof(g_183.f4), "g_183.f4", print_hash_value);
    transparent_crc_bytes (&g_223, sizeof(g_223), "g_223", print_hash_value);
    transparent_crc(g_243.f0, "g_243.f0", print_hash_value);
    transparent_crc(g_243.f2, "g_243.f2", print_hash_value);
    transparent_crc(g_243.f3, "g_243.f3", print_hash_value);
    transparent_crc_bytes (&g_243.f4, sizeof(g_243.f4), "g_243.f4", print_hash_value);
    transparent_crc(g_252.f0, "g_252.f0", print_hash_value);
    transparent_crc(g_252.f1, "g_252.f1", print_hash_value);
    transparent_crc(g_252.f2, "g_252.f2", print_hash_value);
    transparent_crc(g_252.f3.f0, "g_252.f3.f0", print_hash_value);
    transparent_crc(g_252.f3.f1, "g_252.f3.f1", print_hash_value);
    transparent_crc(g_252.f3.f2, "g_252.f3.f2", print_hash_value);
    transparent_crc(g_252.f3.f3, "g_252.f3.f3", print_hash_value);
    transparent_crc(g_252.f3.f4, "g_252.f3.f4", print_hash_value);
    transparent_crc(g_252.f3.f5, "g_252.f3.f5", print_hash_value);
    transparent_crc(g_252.f3.f6, "g_252.f3.f6", print_hash_value);
    transparent_crc_bytes (&g_252.f4, sizeof(g_252.f4), "g_252.f4", print_hash_value);
    transparent_crc(g_252.f5, "g_252.f5", print_hash_value);
    transparent_crc(g_252.f6, "g_252.f6", print_hash_value);
    transparent_crc(g_252.f7, "g_252.f7", print_hash_value);
    transparent_crc(g_252.f8, "g_252.f8", print_hash_value);
    transparent_crc(g_363, "g_363", print_hash_value);
    transparent_crc_bytes (&g_485, sizeof(g_485), "g_485", print_hash_value);
    transparent_crc(g_521, "g_521", print_hash_value);
    transparent_crc(g_532, "g_532", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 93
XXX total union variables: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 116
   depth: 2, occurrence: 24
   depth: 3, occurrence: 4
   depth: 5, occurrence: 3
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 2
   depth: 34, occurrence: 1

XXX total number of pointers: 105

XXX times a variable address is taken: 97
XXX times a pointer is dereferenced on RHS: 81
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 16
XXX times a pointer is dereferenced on LHS: 69
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 9
XXX times a pointer is compared with null: 29
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 215

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 247
   level: 2, occurrence: 36
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 31
XXX number of pointers point to structs: 15
XXX percent of pointers has null in alias set: 21.9
XXX average alias set size: 1.21

XXX times a non-volatile is read: 492
XXX times a non-volatile is write: 155
XXX times a volatile is read: 35
XXX    times read thru a pointer: 0
XXX times a volatile is write: 15
XXX    times written thru a pointer: 2
XXX times a volatile is available for access: 194
XXX percentage of non-volatile access: 92.8

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 107
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 15
   depth: 2, occurrence: 20
   depth: 3, occurrence: 25
   depth: 4, occurrence: 13
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 19.7
XXX percentage an existing variable is used: 80.3
********************* end of statistics **********************/

