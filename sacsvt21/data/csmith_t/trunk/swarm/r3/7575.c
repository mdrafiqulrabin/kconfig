/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3307738944
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 14;
   signed f1 : 11;
   signed f2 : 1;
   const unsigned f3 : 9;
   unsigned f4 : 20;
   signed f5 : 27;
   int16_t  f6;
   signed f7 : 6;
   signed f8 : 14;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   const signed f0 : 11;
   unsigned f1 : 10;
   unsigned f2 : 14;
   unsigned f3 : 3;
   const int16_t  f4;
};
#pragma pack(pop)

struct S2 {
   unsigned f0 : 5;
   const int32_t  f1;
   unsigned f2 : 13;
   signed f3 : 25;
   signed f4 : 26;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_4 = 1;
static struct S0 g_42 = {65,16,-0,15,324,6070,0x5018,-7,69};
static int32_t *g_44 = &g_4;
static int32_t **g_43 = &g_44;
static struct S2 g_93 = {0,0x777BDFF1,56,-1286,-7932};
static struct S2 *g_92 = &g_93;
static struct S2 g_95 = {0,0x225587BB,79,3163,-6632};
static float g_98 = 0x1.Dp-1;
static const int32_t **g_121 = (void*)0;
static const int32_t ***g_120 = &g_121;
static const int32_t ****g_119 = &g_120;
static int32_t g_135 = 0x6C84E0FF;
static struct S2 **g_193 = &g_92;
static struct S2 ***g_192 = &g_193;
static struct S2 ****g_191 = &g_192;
static const struct S1 g_202 = {-36,7,119,0,0xD2C2};
static struct S0 *g_297 = &g_42;
static struct S0 **g_296 = &g_297;
static int32_t g_312 = 3;
static struct S1 g_379 = {4,31,118,1,0x8670};
static int32_t ***g_410 = &g_43;
static int32_t ****g_409 = &g_410;
static int32_t *****g_408 = &g_409;
static struct S1 *g_503 = &g_379;
static struct S1 **g_502 = &g_503;
static const struct S0 g_512 = {24,38,-0,3,813,-4037,-10,-0,112};
static uint16_t g_530 = 0xF289;
static uint16_t g_532 = 0x2476;
static struct S0 *g_542 = &g_42;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_28(void);
static const int32_t * func_29(uint32_t  p_30, uint32_t  p_31, uint16_t  p_32);
static const float  func_40(float  p_41);
static struct S0 * func_46(int32_t * p_47, int32_t ** p_48, int32_t  p_49, const uint32_t  p_50);
static int32_t * func_51(struct S2  p_52);
static struct S2  func_53(int32_t *** p_54);
static int32_t * func_55(int32_t ** p_56, uint32_t  p_57);
static int16_t  func_60(int32_t  p_61, struct S1  p_62, struct S0 * p_63);
static uint32_t  func_65(float  p_66, struct S0 * p_67, struct S0  p_68, float  p_69, uint32_t  p_70);
static int16_t  func_84(int32_t  p_85, float  p_86, int32_t  p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_410 g_43 g_44 g_542 g_42
 * writes:
 */
static struct S0  func_28(void)
{ /* block id: 36 */
    int32_t l_35 = 0x37F4A1D2;
    const int32_t *l_543 = &g_312;
    l_543 = func_29(__builtin_clz(g_4), (__builtin_ctzll(g_4) ^ (safe_div_func_uint16_t_u_u((0xDBCABEBF > ((g_4 , (((((l_35 > ((0x2B2F && 0) , 0x9384)) | l_35) , g_4) != 0x8160) & g_4)) >= g_4)), g_4))), g_4);
    return (*g_542);
}


/* ------------------------------------------ */
/* 
 * reads : g_410 g_43 g_44
 * writes:
 */
static const int32_t * func_29(uint32_t  p_30, uint32_t  p_31, uint16_t  p_32)
{ /* block id: 37 */
    int32_t *l_507 = (void*)0;
    int32_t **l_506 = &l_507;
    const struct S0 *l_511 = &g_512;
    const struct S0 **l_510 = &l_511;
    const struct S0 ***l_509 = &l_510;
    const struct S0 ****l_508 = &l_509;
    for (p_32 = 0; (p_32 > 56); p_32 = safe_add_func_uint16_t_u_u(p_32, 4))
    { /* block id: 40 */
        int16_t l_516 = 0x89C8;
        float *l_517 = &g_98;
        int32_t ***l_520 = (void*)0;
        struct S2 l_521 = {1,0x3ABB5D24,33,2841,-3523};
        uint16_t l_533 = 0xE0BB;
    }
    return (**g_410);
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_43 g_44 g_4 g_95.f0 g_95.f2 g_202.f1 g_202.f2 g_135 g_93.f0 g_202 g_93.f4 g_95.f3 g_95.f4 g_191 g_192 g_92 g_93 g_95.f1 g_312 g_297 g_379.f3 g_296 g_379.f1 g_409 g_410 g_119 g_120 g_193 g_379 g_502
 * writes: g_43 g_4 g_44 g_42.f6 g_98 g_135 g_408 g_297 g_92 g_296 g_312
 */
static const float  func_40(float  p_41)
{ /* block id: 41 */
    int32_t ***l_45 = &g_43;
    int32_t l_489 = 0xA70AC51F;
    struct S0 l_490 = {28,-14,0,4,123,6567,0x97F4,4,-21};
    struct S0 **l_500 = &g_297;
    (*l_45) = (g_42 , g_43);
    (*l_500) = func_46(func_51(func_53(l_45)), (*l_45), (safe_sub_func_uint32_t_u_u((safe_div_func_int32_t_s_s((safe_sub_func_int16_t_s_s(l_489, l_489)), (l_490 , (safe_mod_func_int32_t_s_s(((safe_lshift_func_int16_t_s_s((l_490.f2 != g_42.f2), 3)) != g_93.f4), 0xE8433C72))))), 0xE70CD373)), g_95.f2);
    (***g_410) = (safe_unary_minus_func_int16_t_s(((g_502 != (p_41 , &g_503)) , (***l_45))));
    return g_202.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_43 g_44 g_135
 * writes: g_135 g_98
 */
static struct S0 * func_46(int32_t * p_47, int32_t ** p_48, int32_t  p_49, const uint32_t  p_50)
{ /* block id: 347 */
    int32_t *l_495 = &g_135;
    struct S0 *l_496 = (void*)0;
    const struct S1 *l_498 = (void*)0;
    const struct S1 **l_497 = &l_498;
    float *l_499 = &g_98;
    l_495 = (*g_43);
    (**g_43) = (**p_48);
    (*l_497) = &g_202;
    (*l_499) = (*l_495);
    return l_496;
}


/* ------------------------------------------ */
/* 
 * reads : g_42.f2 g_409 g_410 g_43 g_44 g_135
 * writes: g_135
 */
static int32_t * func_51(struct S2  p_52)
{ /* block id: 343 */
    const struct S0 l_479 = {67,-10,-0,15,673,-2928,0x5F98,1,-55};
    struct S0 ***l_480 = (void*)0;
    int32_t *l_482 = &g_135;
    (*g_44) = ((safe_unary_minus_func_int16_t_s(g_42.f2)) > ((****g_409) & ((l_479 , l_480) != (void*)0)));
    (**g_43) = (g_135 , ((safe_unary_minus_func_uint32_t_u(p_52.f0)) , (****g_409)));
    return l_482;
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_43 g_44 g_4 g_95.f0 g_95.f2 g_202.f1 g_202.f2 g_135 g_93.f0 g_202 g_93.f4 g_95.f3 g_95.f4 g_191 g_192 g_92 g_93 g_95.f1 g_312 g_297 g_379.f3 g_296 g_379.f1 g_409 g_410 g_119 g_120 g_193 g_379
 * writes: g_4 g_44 g_42.f6 g_98 g_135 g_408 g_297 g_92 g_296 g_312
 */
static struct S2  func_53(int32_t *** p_54)
{ /* block id: 43 */
    int32_t **l_58 = (void*)0;
    struct S0 l_64 = {78,29,0,1,1004,-518,-6,6,38};
    int32_t l_71 = 0x1158A35C;
    struct S1 l_360 = {-27,27,44,0,-3};
    int32_t *l_476 = &g_135;
    struct S2 l_477 = {0,0xCD04215E,26,-3483,4226};
    (*g_43) = func_55(l_58, ((safe_unary_minus_func_int16_t_s((func_60((l_64 , __builtin_ctzl((func_65((0x0.Cp+1 > l_71), &l_64, g_42, (g_42.f3 >= ((l_64.f6 == ((l_64.f3 && l_64.f2) , 0x6.CC5CA3p-93)) > 0x0.3p-1)), g_42.f4) >= 0x3D898C33))), l_360, &l_64) < l_360.f2))) , g_95.f4));
    for (g_312 = 0; (g_312 > (-8)); g_312 = safe_sub_func_uint32_t_u_u(g_312, 6))
    { /* block id: 338 */
        int32_t **l_467 = &g_44;
        (**g_410) = func_55((g_95.f1 , (l_64 , l_467)), ((+((((safe_add_func_uint16_t_u_u(((safe_mod_func_int16_t_s_s(g_93.f4, (**l_467))) >= ((safe_unary_minus_func_int16_t_s(((l_64.f4 | (safe_rshift_func_uint16_t_u_u(g_202.f3, g_42.f7))) , ((**l_467) ^ 0x53CE)))) ^ l_71)), (**l_467))) && g_95.f3) || 5) , (**l_467))) || 0xAF5971CE));
    }
    (***g_409) = l_476;
    return l_477;
}


/* ------------------------------------------ */
/* 
 * reads : g_93.f3 g_202 g_43 g_379 g_410 g_297 g_42 g_312 g_4 g_93.f1 g_296 g_135 g_409 g_44 g_119 g_120 g_92 g_191 g_192 g_193 g_93
 * writes: g_296 g_42.f6 g_44 g_135 g_4 g_98 g_408 g_297 g_92
 */
static int32_t * func_55(int32_t ** p_56, uint32_t  p_57)
{ /* block id: 318 */
    struct S0 **l_443 = &g_297;
    struct S0 ***l_444 = (void*)0;
    int32_t l_453 = 8;
    struct S1 l_454 = {41,6,123,1,0};
    int32_t *l_461 = (void*)0;
    int32_t *l_462 = &g_135;
    float *l_463 = &g_98;
    int32_t *l_464 = &g_312;
    g_296 = l_443;
    for (p_57 = (-29); (p_57 <= 5); p_57 = safe_add_func_uint16_t_u_u(p_57, 6))
    { /* block id: 322 */
        uint32_t l_451 = 4294967295U;
        struct S0 ****l_455 = &l_444;
        int32_t *l_458 = &l_453;
        for (g_42.f6 = 0; (g_42.f6 <= (-21)); g_42.f6 = safe_sub_func_uint32_t_u_u(g_42.f6, 1))
        { /* block id: 325 */
            struct S0 *****l_456 = (void*)0;
            struct S0 *****l_457 = &l_455;
            (*l_457) = ((((safe_div_func_uint32_t_u_u(g_93.f3, __builtin_ctzl(l_451))) , (0x2BC1A5B9 || ((~l_453) , (l_454 , 0xAE2FDA72)))) , g_202) , l_455);
            (*g_43) = l_458;
        }
        (**g_410) = (g_379 , &l_453);
        (*l_458) = (func_60(l_454.f0, l_454, (*l_443)) , (safe_rshift_func_uint16_t_u_s(l_453, 7)));
    }
    (*l_462) = l_454.f3;
    (*l_463) = g_135;
    return l_464;
}


/* ------------------------------------------ */
/* 
 * reads : g_42.f6 g_297 g_42 g_312 g_93.f1 g_4 g_379.f3 g_296 g_43 g_135 g_93.f3 g_379.f1 g_409 g_410 g_44 g_119 g_120 g_92 g_191 g_192 g_193 g_93 l_64
 * writes: g_42.f6 g_135 g_4 g_44 g_98 g_408 g_297 g_92
 */
static int16_t  func_60(int32_t  p_61, struct S1  p_62, struct S0 * p_63)
{ /* block id: 239 */
    int32_t l_364 = (-8);
    struct S2 **l_365 = &g_92;
    int32_t l_370 = (-2);
    const int32_t *l_383 = &g_93.f1;
    struct S0 l_393 = {81,-31,0,17,237,-1967,0x59C3,-2,-94};
    struct S2 *****l_401 = &g_191;
    int32_t l_417 = 0x1DB1DC92;
    struct S1 l_425 = {-25,21,58,0,0x2173};
    int32_t l_427 = 0;
    for (g_42.f6 = 0; (g_42.f6 <= 13); g_42.f6 = safe_add_func_uint16_t_u_u(g_42.f6, 6))
    { /* block id: 242 */
        struct S0 l_363 = {12,5,-0,7,1019,11413,0x40B0,-1,-101};
        int32_t l_387 = 0;
        float *l_397 = &g_98;
        float l_419 = 0x1.0p+1;
        int32_t ***l_426 = &g_43;
        uint32_t l_440 = 0x98A925A2;
        int32_t *l_442 = &l_417;
        if (((((((l_363 , l_364) , p_62.f3) > ((void*)0 != l_365)) , (((l_363 , (safe_mod_func_int16_t_s_s(p_62.f3, (-1)))) , (~(!(l_370 || 0xBA00EA8E)))) , l_364)) & p_62.f3) , p_62.f1))
        { /* block id: 243 */
            int32_t *l_390 = &g_312;
            struct S0 l_400 = {113,8,0,6,692,-8685,0xD709,4,-49};
            struct S2 *l_413 = &g_93;
            const int32_t l_418 = 0xBF8B169A;
            for (l_370 = 6; (l_370 <= 0); l_370 = safe_sub_func_int16_t_s_s(l_370, 1))
            { /* block id: 246 */
                int32_t *l_381 = &g_4;
                const int32_t *l_384 = &g_312;
                struct S0 *l_396 = (void*)0;
                for (g_135 = 17; (g_135 != (-23)); g_135 = safe_sub_func_uint32_t_u_u(g_135, 5))
                { /* block id: 249 */
                    uint16_t l_380 = 0x1354;
                    int32_t *l_382 = &g_312;
                    for (l_364 = (-8); (l_364 > (-5)); l_364 = safe_add_func_uint32_t_u_u(l_364, 4))
                    { /* block id: 252 */
                        struct S1 *l_378 = &g_379;
                        struct S1 **l_377 = &l_378;
                        (*l_377) = ((*g_297) , &p_62);
                        if (l_380)
                            break;
                    }
                    l_382 = l_381;
                    if (p_61)
                    { /* block id: 257 */
                        l_384 = l_383;
                    }
                    else
                    { /* block id: 259 */
                        (*l_382) = ((*l_384) && (safe_lshift_func_int16_t_s_s(l_387, (safe_rshift_func_int16_t_s_u((__builtin_ia32_crc32qi(((*l_382) > (*l_381)), (*l_381)) , p_62.f4), 15)))));
                        l_390 = &p_61;
                    }
                    (*g_43) = ((((((g_379.f3 <= ((safe_rshift_func_int16_t_s_s((((*l_382) | l_363.f3) > (*l_383)), 2)) , (*l_383))) , l_393) , l_382) != ((safe_add_func_float_f_f((l_396 == (*g_296)), 0x5.8p-1)) , l_397)) >= 0x2.2869FDp-5) , &p_61);
                }
            }
            for (l_387 = 15; (l_387 == (-29)); l_387 = safe_sub_func_uint32_t_u_u(l_387, 1))
            { /* block id: 268 */
                return l_387;
            }
            if ((((g_379.f3 , l_400) , l_401) == &g_191))
            { /* block id: 271 */
                uint16_t l_403 = 0x3531;
                (*l_397) = ((-l_403) != g_42.f7);
                for (l_387 = 14; (l_387 != (-2)); l_387 = safe_sub_func_int16_t_s_s(l_387, 8))
                { /* block id: 275 */
                    (*g_43) = (void*)0;
                    (*g_43) = (__builtin_clzll(g_93.f1) , l_390);
                    for (l_393.f6 = 28; (l_393.f6 == (-18)); l_393.f6 = safe_sub_func_int16_t_s_s(l_393.f6, 1))
                    { /* block id: 280 */
                        g_408 = (void*)0;
                    }
                    if ((*l_390))
                        break;
                }
                if (p_62.f0)
                { /* block id: 285 */
                    return g_135;
                }
                else
                { /* block id: 287 */
                    (*g_296) = p_63;
                    l_393.f8 = p_62.f2;
                    if ((((safe_mod_func_int16_t_s_s(__builtin_parityl(g_93.f3), (*l_390))) || (l_413 == l_413)) || ((safe_mod_func_int32_t_s_s((!p_62.f2), l_417)) & p_62.f0)))
                    { /* block id: 290 */
                        return p_62.f0;
                    }
                    else
                    { /* block id: 292 */
                        (*l_397) = g_379.f1;
                        (***g_409) = &p_61;
                        (*g_44) = l_363.f1;
                    }
                    (****g_409) = 0x7D146537;
                }
            }
            else
            { /* block id: 299 */
                l_393.f8 = l_418;
            }
        }
        else
        { /* block id: 302 */
            int16_t l_428 = 1;
            struct S2 l_432 = {2,0x964FE7D8,78,-2976,7597};
            int32_t *l_433 = &g_135;
            for (l_363.f6 = 0; (l_363.f6 == (-5)); l_363.f6 = safe_sub_func_uint32_t_u_u(l_363.f6, 1))
            { /* block id: 305 */
                uint16_t l_424 = 0xA1D2;
                l_428 = (safe_mod_func_uint16_t_u_u((l_424 < ((((l_424 & (&g_379 != ((g_42.f5 >= g_4) , (((((l_425 , (*g_119)) != ((*p_63) , l_426)) ^ l_427) , 0U) , (void*)0)))) > (*l_383)) >= 0xA01B54EB) , l_424)), 0xFBE1));
                l_393.f8 = p_62.f2;
                (***g_191) = (*l_365);
            }
            l_393.f7 = (+((l_432 , 0xE79E) ^ (p_62.f1 == 0x9DBE0F00)));
            (***g_409) = l_433;
            (**g_410) = l_433;
        }
        (*l_397) = ((safe_sub_func_float_f_f((((((safe_sub_func_float_f_f(((((**g_193) , (&l_426 != &l_426)) > p_62.f2) == g_42.f5), (((void*)0 == &p_62) <= (g_42.f5 != ((__builtin_clz((safe_sub_func_int16_t_s_s((l_401 != l_401), l_440))) , 0x3.86E898p-64) == 0x0.Ap+1))))) == p_61) < 0x8.Ap+1) > 0x1.B7106Ap-26) > (-0x6.9p+1)), 0xC.CF3CF5p+97)) <= p_62.f2);
        (*l_442) = (((+p_62.f0) , (**l_401)) == (void*)0);
    }
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads : g_42.f1 g_43 g_44 g_42.f6 g_4 g_95.f0 g_95.f2 g_202.f1 g_202.f2 g_135 g_93.f0 g_202 g_93.f4 g_95.f3 g_95.f4 g_191 g_192 g_42.f2 g_92 g_93 g_42.f3 g_95.f1 g_312 g_42.f7
 * writes: g_4 g_44 g_42.f6 g_98 g_135
 */
static uint32_t  func_65(float  p_66, struct S0 * p_67, struct S0  p_68, float  p_69, uint32_t  p_70)
{ /* block id: 44 */
    struct S2 l_80 = {4,0x4A51E29A,47,1915,4398};
    const int32_t *l_358 = (void*)0;
    float *l_359 = &g_98;
    p_66 = ((safe_sub_func_float_f_f((((safe_rshift_func_uint16_t_u_u((safe_div_func_uint16_t_u_u((((((safe_rshift_func_int16_t_s_s((l_80 , g_42.f1), 6)) , p_68.f4) , ((~((*g_43) != (void*)0)) > g_42.f6)) && (safe_sub_func_int16_t_s_s(func_84(p_70, l_80.f4, l_80.f3), 1))) >= p_68.f8), 0x4729)), 6)) , g_202) , 0x9.DDD124p-37), p_68.f2)) == 0x0.8p+1);
    l_358 = l_358;
    (*l_359) = (g_95.f2 == 0xB.5F4550p-17);
    return g_42.f7;
}


/* ------------------------------------------ */
/* 
 * reads : g_43 g_44 g_4 g_95.f0 g_95.f2 g_202.f1 g_202.f2 g_135 g_42.f1 g_93.f0 g_202 g_93.f4 g_95.f3 g_95.f4 g_191 g_192 g_42.f6 g_42.f2 g_92 g_93 g_42.f3 g_95.f1 g_312
 * writes: g_4 g_44 g_42.f6 g_98 g_135
 */
static int16_t  func_84(int32_t  p_85, float  p_86, int32_t  p_87)
{ /* block id: 45 */
    int32_t l_91 = 0x0DEE2C54;
    struct S2 *l_94 = &g_95;
    struct S0 l_133 = {28,-9,-0,14,347,-5338,0xBA64,-2,-26};
    int32_t *l_134 = (void*)0;
    int32_t ***l_145 = &g_43;
    uint32_t l_158 = 0U;
    struct S0 **l_174 = (void*)0;
    struct S2 **l_190 = &l_94;
    struct S2 ***l_189 = &l_190;
    struct S2 ****l_188 = &l_189;
    int32_t l_203 = (-7);
    uint16_t l_208 = 0U;
    int32_t *l_218 = &g_4;
    uint32_t l_346 = 4294967294U;
    uint32_t l_349 = 0x2E56CC4E;
    int32_t l_352 = (-10);
    int32_t l_354 = 0x89C46040;
    for (p_87 = 0; (p_87 <= 24); p_87 = safe_add_func_int32_t_s_s(p_87, 6))
    { /* block id: 48 */
        int32_t *l_90 = &g_4;
        uint16_t l_115 = 0x1338;
        struct S0 *l_142 = &l_133;
        struct S2 *l_149 = (void*)0;
        struct S2 ***l_209 = &l_190;
        l_90 = (*g_43);
    }
    (*g_44) = __builtin_ffsl(p_87);
lbl_357:
    if (p_85)
    { /* block id: 134 */
        int32_t **l_219 = &l_134;
        const int32_t *l_237 = &g_135;
        int32_t l_240 = 0x5EB5E7AD;
        const struct S2 *l_258 = &g_95;
        const struct S2 ***l_279 = (void*)0;
        int32_t l_282 = 0x9FA56181;
        struct S0 *l_283 = &l_133;
        uint16_t l_353 = 0xBD49;
        float *l_355 = &g_98;
        (**l_145) = &p_87;
        if ((l_219 != (void*)0))
        { /* block id: 136 */
            struct S2 *l_221 = &g_93;
            int32_t l_225 = (-6);
            if (p_85)
            { /* block id: 137 */
                struct S2 *l_220 = &g_93;
                int32_t l_231 = 0xD4AAAEAE;
                struct S2 *****l_235 = &g_191;
                int32_t *l_256 = &g_4;
                if ((p_85 || (l_220 == l_221)))
                { /* block id: 138 */
                    uint32_t l_226 = 4U;
                    const int32_t *l_236 = &l_231;
                    (*l_219) = (void*)0;
lbl_255:
                    if ((((((safe_unary_minus_func_int32_t_s(p_87)) < 0U) == __builtin_ffs((*g_44))) == __builtin_popcountll(l_225)) , l_225))
                    { /* block id: 140 */
                        return l_226;
                    }
                    else
                    { /* block id: 142 */
                        float *l_232 = (void*)0;
                        p_86 = ((p_85 != ((p_87 <= 0x034B4D2A) == l_225)) , (safe_add_func_float_f_f(((safe_sub_func_float_f_f((((*l_219) != (*l_219)) != 0x5.Dp+1), ((g_95.f0 <= g_95.f0) > g_95.f2))) == l_231), 0x4.Ep+1)));
                        if (g_202.f1)
                            goto lbl_357;
                    }
                    for (g_42.f6 = 0; (g_42.f6 < 24); ++g_42.f6)
                    { /* block id: 147 */
                        float *l_253 = (void*)0;
                        float *l_254 = &g_98;
                        l_235 = l_235;
                        l_237 = l_236;
                        (*l_254) = ((p_86 == (((safe_div_func_float_f_f(p_87, (p_87 , l_240))) >= g_202.f1) == (safe_sub_func_float_f_f((((safe_sub_func_int16_t_s_s((((**g_43) >= ((safe_sub_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(g_202.f2, __builtin_popcountll((g_135 , (safe_rshift_func_uint16_t_u_s(((safe_div_func_int16_t_s_s(p_85, p_87)) & p_85), 2)))))), g_42.f1)) == 0xEC8C)) || l_231), (*l_237))) != p_87) , g_93.f0), p_85)))) < (-0x1.9p-1));
                        if (g_202.f2)
                            goto lbl_255;
                    }
                    l_256 = &l_231;
                }
                else
                { /* block id: 154 */
                    int32_t *****l_257 = (void*)0;
                    const struct S2 **l_259 = &l_258;
                    (***l_145) = p_87;
                    l_257 = (void*)0;
                    (*l_259) = l_258;
                    for (p_87 = (-17); (p_87 > 27); p_87 = safe_add_func_uint32_t_u_u(p_87, 1))
                    { /* block id: 160 */
                        const struct S2 l_264 = {2,0x0347C12E,31,-3543,3130};
                        float *l_265 = (void*)0;
                        g_98 = (safe_add_func_float_f_f((l_264 , (g_202 , __builtin_ia32_crc32qi(g_95.f2, g_93.f4))), l_225));
                    }
                }
            }
            else
            { /* block id: 164 */
                (*l_219) = &p_85;
            }
            p_86 = (__builtin_ffsl(l_225) < 0x1.BD7C48p-1);
            p_86 = (((-0x1.Ep-1) == ((safe_add_func_float_f_f(p_86, ((safe_sub_func_uint16_t_u_u(g_95.f2, ((safe_add_func_int16_t_s_s(p_85, g_95.f3)) , 65526U))) , l_225))) < g_95.f0)) == (p_87 > g_93.f4));
            (*g_44) = (g_95.f4 < (~(safe_div_func_int16_t_s_s((0xC7B7 | ((safe_sub_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((0x06D2 || (((0x6.0B5BDBp-3 >= l_225) , (l_279 != ((0xBB4E > ((**g_43) == ((safe_div_func_int32_t_s_s(((l_225 | l_282) == (*l_218)), l_225)) && 0xDEDF))) , (*g_191)))) && 0xD53B)), p_85)), g_135)) != p_87)), g_42.f6))));
        }
        else
        { /* block id: 170 */
            struct S0 **l_284 = &l_283;
            struct S2 l_314 = {1,0xB597B53C,15,-824,-1195};
            int32_t ***l_315 = &l_219;
            int32_t *l_323 = &g_135;
            struct S2 **l_336 = &g_92;
            (*l_284) = l_283;
        }
        (*l_355) = ((((l_346 < g_42.f2) != ((safe_rshift_func_uint16_t_u_u(((p_85 ^ ((((l_349 < ((((*g_92) , ((void*)0 == l_258)) , (((((__builtin_parity((safe_div_func_int32_t_s_s(l_352, p_87))) < 0xD85A) != 0x8A2F) ^ (*l_218)) <= 65535U) <= g_42.f3)) & (-3))) , (void*)0) != (void*)0) ^ g_95.f4)) , g_95.f1), l_353)) , l_354)) <= 0xA.FBCA2Ap+61) <= g_312);
    }
    else
    { /* block id: 228 */
        float *l_356 = &g_98;
        (*l_356) = ((***l_145) != __builtin_parityl(g_95.f2));
        return p_85;
    }
    (**l_145) = (**l_145);
    return (*l_218);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_42.f0, "g_42.f0", print_hash_value);
    transparent_crc(g_42.f1, "g_42.f1", print_hash_value);
    transparent_crc(g_42.f2, "g_42.f2", print_hash_value);
    transparent_crc(g_42.f3, "g_42.f3", print_hash_value);
    transparent_crc(g_42.f4, "g_42.f4", print_hash_value);
    transparent_crc(g_42.f5, "g_42.f5", print_hash_value);
    transparent_crc(g_42.f6, "g_42.f6", print_hash_value);
    transparent_crc(g_42.f7, "g_42.f7", print_hash_value);
    transparent_crc(g_42.f8, "g_42.f8", print_hash_value);
    transparent_crc(g_93.f0, "g_93.f0", print_hash_value);
    transparent_crc(g_93.f1, "g_93.f1", print_hash_value);
    transparent_crc(g_93.f2, "g_93.f2", print_hash_value);
    transparent_crc(g_93.f3, "g_93.f3", print_hash_value);
    transparent_crc(g_93.f4, "g_93.f4", print_hash_value);
    transparent_crc(g_95.f0, "g_95.f0", print_hash_value);
    transparent_crc(g_95.f1, "g_95.f1", print_hash_value);
    transparent_crc(g_95.f2, "g_95.f2", print_hash_value);
    transparent_crc(g_95.f3, "g_95.f3", print_hash_value);
    transparent_crc(g_95.f4, "g_95.f4", print_hash_value);
    transparent_crc_bytes (&g_98, sizeof(g_98), "g_98", print_hash_value);
    transparent_crc(g_135, "g_135", print_hash_value);
    transparent_crc(g_202.f0, "g_202.f0", print_hash_value);
    transparent_crc(g_202.f1, "g_202.f1", print_hash_value);
    transparent_crc(g_202.f2, "g_202.f2", print_hash_value);
    transparent_crc(g_202.f3, "g_202.f3", print_hash_value);
    transparent_crc(g_202.f4, "g_202.f4", print_hash_value);
    transparent_crc(g_312, "g_312", print_hash_value);
    transparent_crc(g_379.f0, "g_379.f0", print_hash_value);
    transparent_crc(g_379.f1, "g_379.f1", print_hash_value);
    transparent_crc(g_379.f2, "g_379.f2", print_hash_value);
    transparent_crc(g_379.f3, "g_379.f3", print_hash_value);
    transparent_crc(g_379.f4, "g_379.f4", print_hash_value);
    transparent_crc(g_512.f0, "g_512.f0", print_hash_value);
    transparent_crc(g_512.f1, "g_512.f1", print_hash_value);
    transparent_crc(g_512.f2, "g_512.f2", print_hash_value);
    transparent_crc(g_512.f3, "g_512.f3", print_hash_value);
    transparent_crc(g_512.f4, "g_512.f4", print_hash_value);
    transparent_crc(g_512.f5, "g_512.f5", print_hash_value);
    transparent_crc(g_512.f6, "g_512.f6", print_hash_value);
    transparent_crc(g_512.f7, "g_512.f7", print_hash_value);
    transparent_crc(g_512.f8, "g_512.f8", print_hash_value);
    transparent_crc(g_530, "g_530", print_hash_value);
    transparent_crc(g_532, "g_532", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 130
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 16
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 49
breakdown:
   indirect level: 0, occurrence: 20
   indirect level: 1, occurrence: 12
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 20
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 39
XXX times a single bitfield on LHS: 5
XXX times a single bitfield on RHS: 104

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 130
   depth: 2, occurrence: 22
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 140

XXX times a variable address is taken: 127
XXX times a pointer is dereferenced on RHS: 80
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 20
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 96
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 16
   depth: 3, occurrence: 11
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 389

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 315
   level: 2, occurrence: 88
   level: 3, occurrence: 66
   level: 4, occurrence: 26
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 58
XXX number of pointers point to structs: 20
XXX percent of pointers has null in alias set: 25.7
XXX average alias set size: 1.26

XXX times a non-volatile is read: 662
XXX times a non-volatile is write: 284
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 113
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 13
   depth: 2, occurrence: 14
   depth: 3, occurrence: 11
   depth: 4, occurrence: 21
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 21.3
XXX percentage an existing variable is used: 78.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

