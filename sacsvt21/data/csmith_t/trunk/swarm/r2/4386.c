/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1651580236
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 20;
   uint16_t  f1;
   uint16_t  f2;
   float  f3;
   int16_t  f4;
   int32_t  f5;
   uint32_t  f6;
   int32_t  f7;
   uint32_t  f8;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_30(void);
static struct S0  func_32(int32_t  p_33, struct S0  p_34, uint32_t  p_35, int16_t  p_36, int32_t  p_37);
static struct S0  func_38(uint16_t  p_39);
static struct S0  func_48(int32_t  p_49);
static int16_t  func_53(float  p_54);
static float  func_55(float  p_56, uint32_t  p_57, int32_t  p_58);
static float  func_64(struct S0  p_65, uint32_t  p_66, int32_t  p_67, int32_t  p_68);
static uint32_t  func_70(struct S0  p_71, int16_t  p_72, int32_t  p_73, float  p_74);
static int16_t  func_79(uint16_t  p_80, uint32_t  p_81, int16_t  p_82, int16_t  p_83, uint16_t  p_84);
static uint32_t  func_87(int32_t  p_88, struct S0  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_30(void)
{ /* block id: 36 */
    uint32_t l_31 = 18446744073709551614UL;
    struct S0 l_270 = {-905,0x75F5L,1UL,0x2.C75496p-40,0xEED0L,0xC249F414L,0x69CFB043L,0L,18446744073709551606UL};
    l_31 = 0xD.4DC41Fp+50;
    l_270 = func_32(l_31, func_38(((uint16_t)((int16_t)((int16_t)l_31 + (int16_t)l_31) << (int16_t)((((int16_t)(0xDF11L && l_31) >> (int16_t)(0x1F95L ^ __builtin_popcountll(__builtin_ffsl(l_31)))) | 1L) ^ 0xF5D1CC0CL)) >> (uint16_t)15)), l_31, l_31, l_31);
    return l_270.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_32(int32_t  p_33, struct S0  p_34, uint32_t  p_35, int16_t  p_36, int32_t  p_37)
{ /* block id: 44 */
    float l_59 = 0x0.Ap-1;
    int32_t l_60 = 0xC5A97588L;
    int32_t l_219 = (-1L);
    uint16_t l_236 = 65531UL;
    struct S0 l_237 = {996,0xBA31L,65532UL,0xB.38FE23p+40,0xF90EL,0xBE92DA70L,0x3D3039A1L,-3L,0xC35F3DD4L};
    int16_t l_251 = 0xAC70L;
    int16_t l_269 = (-1L);
    if (((((func_53(func_55(l_59, __builtin_ia32_crc32qi(p_37, l_60), __builtin_popcount(l_60))) == l_60) < l_60) || 0L) & 1L))
    { /* block id: 106 */
        int32_t l_199 = 3L;
        struct S0 l_213 = {288,0xC40DL,0xDE40L,0x3.Cp+1,0x0DA6L,0x3FA2BBC1L,0x1824737FL,-1L,0x3F1D640AL};
        uint32_t l_222 = 4294967295UL;
        for (p_33 = (-4); (p_33 == 4); p_33 += 1)
        { /* block id: 109 */
            int32_t l_202 = (-1L);
            int32_t l_220 = 0xC2147255L;
            l_199 = (0x6.EFAAB1p+94 == ((float)l_60 / (float)p_34.f3));
            l_213.f0 = (((((float)(((l_202 >= (((float)((float)(func_53((l_202 > ((float)((float)(p_34.f6 != p_34.f6) + (float)(((float)p_37 / (float)l_199) > func_70(l_213, ((int32_t)((l_213.f7 || func_53(((float)(-(float)__builtin_ia32_crc32qi(l_213.f6, l_219)) / (float)p_35))) >= (-1L)) / (int32_t)p_34.f7), l_219, p_34.f6))) + (float)l_202))) == 0x0.1p-1) - (float)l_202) - (float)p_34.f3) == l_219)) != p_34.f6) != l_219) - (float)l_60) < 0x8.2p-1) < p_36) > l_213.f1);
            if (l_219)
            { /* block id: 112 */
                l_220 = l_199;
            }
            else
            { /* block id: 114 */
                int16_t l_221 = 0xDB04L;
                l_221 = (-7L);
                p_34.f3 = p_34.f3;
                p_34.f3 = func_79((func_87(p_36, l_213) ^ (l_222 | p_34.f0)), p_36, (((~((((int32_t)((int16_t)(((int16_t)(-1L) + (int16_t)((int32_t)((((uint32_t)0xDA89D31CL - (uint32_t)((uint16_t)l_60 << (uint16_t)l_236)) < p_34.f7) >= l_236) + (int32_t)l_236)) >= l_236) >> (int16_t)11) + (int32_t)l_60) <= p_36) ^ 0x7613L)) | l_221) >= l_236), p_34.f7, l_221);
                p_34.f3 = l_213.f5;
            }
            p_34 = func_48(func_87(p_34.f2, p_34));
        }
        p_34.f5 = p_36;
        l_60 = 0x0.5p+1;
        p_34 = l_237;
    }
    else
    { /* block id: 125 */
        uint32_t l_244 = 0xBC5EB18EL;
        int32_t l_256 = (-9L);
        p_33 = ((((int32_t)(((uint16_t)(((((l_244 && (func_79((((0x0711L <= ((((int16_t)((l_244 | (4294967295UL != l_244)) <= (((uint16_t)l_60 << (uint16_t)p_34.f6) && l_244)) << (int16_t)3) < (((uint16_t)((l_251 >= 0L) & l_237.f5) << (uint16_t)l_244) ^ 0xA75BCBD6L)) < p_34.f8)) >= p_34.f5) && 0x7820L), l_244, p_34.f8, p_36, l_237.f6) < 3L)) < p_34.f4) ^ l_244) < p_34.f4) ^ l_244) >> (uint16_t)l_237.f5) ^ 0UL) + (int32_t)0x361B7BB6L) && l_237.f4) ^ 0UL);
        l_269 = func_53(func_53(((float)(p_34.f2 > ((float)l_256 / (float)(p_33 <= 0x0.2p+1))) + (float)((float)(((float)(p_35 > ((((func_53((((((float)(0xA.50E0C1p+36 == ((float)l_244 - (float)((((float)0x6.A71FD0p-59 / (float)(((float)l_60 - (float)l_237.f8) > l_219)) == p_34.f6) >= 0x6.825600p-97))) / (float)l_256) == p_34.f4) >= p_33) <= l_256)) <= 0x9.1p-1) == p_37) != p_34.f7) >= l_244)) - (float)p_34.f2) == l_237.f1) + (float)p_33))));
    }
    return l_237;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_38(uint16_t  p_39)
{ /* block id: 38 */
    int32_t l_50 = (-6L);
    struct S0 l_52 = {-178,5UL,65534UL,0x8.B60270p-33,-1L,0L,1UL,-1L,0x85C2C102L};
    l_52 = func_48(l_50);
    l_52.f0 = p_39;
    return l_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_48(int32_t  p_49)
{ /* block id: 39 */
    struct S0 l_51 = {375,65535UL,2UL,0xE.C7B249p+88,0x8D3FL,1L,2UL,0L,0x626AECE0L};
    return l_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_53(float  p_54)
{ /* block id: 103 */
    int32_t l_193 = 0x2EF62936L;
    int32_t l_194 = 0x77E71CC0L;
    l_194 = l_193;
    return l_193;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_55(float  p_56, uint32_t  p_57, int32_t  p_58)
{ /* block id: 45 */
    int32_t l_63 = 0x642A2CA0L;
    struct S0 l_69 = {698,0x2121L,0x659EL,0x6.8E27FBp+36,1L,-1L,7UL,0x298B2365L,1UL};
    p_56 = __builtin_clz(((int16_t)p_58 % (int16_t)l_63));
    l_69.f0 = (0xC.80411Bp-11 > (((func_64(l_69, p_57, (func_70(l_69, ((uint32_t)p_57 + (uint32_t)((int16_t)l_63 + (int16_t)func_79(((int32_t)(func_87(l_63, l_69) && 0xC19DAAC0L) / (int32_t)l_69.f5), p_58, p_57, l_69.f4, p_57))), p_57, l_69.f2) != l_69.f8), p_58) == l_69.f0) <= p_57) <= l_69.f0));
    return l_69.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_64(struct S0  p_65, uint32_t  p_66, int32_t  p_67, int32_t  p_68)
{ /* block id: 67 */
    float l_126 = 0x1.B3EE27p-25;
    int32_t l_127 = 0x975BB608L;
    struct S0 l_159 = {-475,0UL,0x0929L,0xA.F799FEp-15,0xE628L,1L,18446744073709551615UL,8L,1UL};
    uint16_t l_183 = 0x6EF4L;
    uint32_t l_188 = 4294967295UL;
    l_127 = (!((uint16_t)__builtin_bswap64(((uint16_t)l_127 << (uint16_t)2)) << (uint16_t)(((uint16_t)0xC227L / (uint16_t)__builtin_parity(l_127)) & p_68)));
    l_127 = (((float)(0x0.2p-1 != l_127) / (float)p_65.f4) >= (0x1.Ap+1 < l_127));
    for (p_68 = 0; (p_68 >= 10); p_68 += 1)
    { /* block id: 72 */
        float l_138 = 0x4.Bp-1;
        int32_t l_144 = (-1L);
        struct S0 l_148 = {-997,4UL,0UL,0x2.491B97p-73,0x4F22L,0xBF566147L,18446744073709551615UL,0x95FCC9BDL,18446744073709551613UL};
        p_65 = func_38(p_65.f8);
        if (p_65.f0)
            continue;
        if (__builtin_popcount(((int32_t)(-9L) - (int32_t)((uint32_t)p_67 - (uint32_t)((int32_t)((int16_t)l_127 >> (int16_t)0) - (int32_t)l_127)))))
        { /* block id: 75 */
            int32_t l_143 = 0x3EF5034EL;
            float l_161 = (-0x1.Fp+1);
            if (p_68)
                break;
            l_143 = l_127;
            if ((l_144 && (((uint32_t)(!0x40E7L) - (uint32_t)((l_144 > ((p_65.f7 > (l_143 && func_70(l_148, p_65.f1, p_66, p_67))) && l_127)) > p_67)) && p_65.f5)))
            { /* block id: 78 */
                uint32_t l_162 = 0x4C376665L;
                p_67 = ((uint32_t)__builtin_popcountll((((65526UL < ((uint16_t)((uint16_t)((int32_t)((__builtin_bswap32(((uint32_t)1UL % (uint32_t)4294967286UL)) | func_87(l_127, l_159)) & (0x920BL || (+0x0B68L))) % (int32_t)l_159.f6) % (uint16_t)l_162) % (uint16_t)p_65.f2)) || p_67) != l_159.f4)) % (uint32_t)0x69CFB4F4L);
                l_143 = 1L;
                return l_162;
            }
            else
            { /* block id: 82 */
                uint16_t l_173 = 0x441EL;
                int32_t l_174 = 0x5C51E81EL;
                struct S0 l_179 = {-54,65532UL,65532UL,0x9.E6A16Ap-33,-7L,0xEEACEA08L,18446744073709551615UL,1L,0x2AE489F4L};
                l_174 = func_79(l_143, l_159.f4, p_65.f8, p_65.f2, (l_143 > ((uint32_t)((int16_t)p_65.f7 % (int16_t)((uint16_t)((int16_t)l_159.f7 >> (int16_t)9) - (uint16_t)((uint16_t)l_173 % (uint16_t)l_143))) - (uint32_t)p_67)));
                p_65 = func_48(((int16_t)l_143 + (int16_t)p_68));
                for (p_65.f7 = 0; (p_65.f7 >= 16); p_65.f7 += 1)
                { /* block id: 87 */
                    struct S0 l_180 = {214,0x5C41L,0UL,-0x1.2p-1,1L,0xC0C6297AL,7UL,0xDAB54D39L,0x1EFE91F0L};
                    l_143 = __builtin_ctzll(p_65.f5);
                    l_180 = l_179;
                    l_179.f5 = __builtin_clzll(l_159.f2);
                    p_65.f3 = (0x3.Fp+1 > (l_159.f2 > 0xD.C78AF0p-28));
                }
            }
        }
        else
        { /* block id: 94 */
            p_65.f5 = (0xD24EL >= __builtin_bswap32(p_65.f4));
            p_65 = p_65;
        }
    }
    l_159.f0 = ((uint16_t)l_183 >> (uint16_t)((int16_t)(l_188 | ((l_183 <= ((0x41D1L ^ ((int32_t)0L / (int32_t)p_67)) | ((uint16_t)l_159.f2 >> (uint16_t)11))) == p_67)) - (int16_t)((l_159.f2 ^ p_65.f6) == l_159.f2)));
    return p_65.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_70(struct S0  p_71, int16_t  p_72, int32_t  p_73, float  p_74)
{ /* block id: 64 */
    int16_t l_118 = 1L;
    p_74 = (l_118 <= ((float)p_74 / (float)p_71.f3));
    return p_71.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_79(uint16_t  p_80, uint32_t  p_81, int16_t  p_82, int16_t  p_83, uint16_t  p_84)
{ /* block id: 53 */
    int16_t l_101 = 0xD9B4L;
    float l_104 = 0x0.Ap+1;
    int32_t l_105 = 5L;
    struct S0 l_108 = {-755,0x2296L,0xCB19L,-0x2.8p-1,-1L,0xE99C33BCL,0x37E5C358L,0x974949FCL,0xA87E6343L};
    float l_113 = 0xD.35E4DCp+60;
    float l_114 = 0x9.7p+1;
    l_105 = ((int16_t)((int16_t)((0xFAFD2A9EL < l_101) > p_83) << (int16_t)((l_101 >= 1UL) & ((((((int32_t)l_101 + (int32_t)((((l_101 != l_101) >= l_101) < 0x11F3L) <= 0xFA59L)) ^ 0x2DC12F67L) > l_101) ^ p_83) | l_101))) + (int16_t)l_101);
    l_105 = l_101;
    l_105 = ((func_87((((uint16_t)__builtin_clzll(p_81) >> (uint16_t)(1UL | 0x0F80L)) == l_101), l_108) > 1UL) != p_80);
    if (((int16_t)(l_108.f7 | l_108.f0) - (int16_t)((__builtin_parity(__builtin_bswap32(p_84)) & (p_82 || (0xB671L | ((((uint32_t)((0xCA39L & p_80) | l_108.f7) % (uint32_t)l_108.f2) <= 0x58B8L) && l_108.f0)))) | l_108.f5)))
    { /* block id: 57 */
        int32_t l_115 = 7L;
        return l_115;
    }
    else
    { /* block id: 59 */
        uint16_t l_116 = 65535UL;
        struct S0 l_117 = {285,0xC48DL,65527UL,0x5.3p+1,0xDB19L,0x4C0CEF9DL,1UL,0x62BBE412L,5UL};
        l_117 = func_38(l_116);
        l_117.f0 = (p_83 == __builtin_ffsl(l_108.f8));
    }
    return l_108.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_87(int32_t  p_88, struct S0  p_89)
{ /* block id: 47 */
    struct S0 l_90 = {-153,0xD598L,0x55CAL,-0x1.2p-1,0xC28CL,0x49887233L,0xD7856BCCL,-1L,7UL};
    uint32_t l_95 = 1UL;
    l_90 = p_89;
    l_95 = ((int16_t)(l_90.f5 | ((int32_t)l_90.f1 / (int32_t)l_90.f4)) + (int16_t)0x7409L);
    l_90.f5 = (-(uint32_t)4294967289UL);
    l_90 = func_48(l_95);
    return p_89.f2;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 48
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 5
XXX times a single bitfield on RHS: 7

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 9
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 255
XXX times a non-volatile is write: 48
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 67
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 12
   depth: 2, occurrence: 9
   depth: 3, occurrence: 11
   depth: 4, occurrence: 4

XXX percentage a fresh-made variable is used: 20.1
XXX percentage an existing variable is used: 79.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

