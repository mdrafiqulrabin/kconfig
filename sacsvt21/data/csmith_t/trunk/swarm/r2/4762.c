/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2232841176
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
};

struct S1 {
   signed f0 : 6;
   uint16_t  f1;
   int16_t  f2;
   uint32_t  f3;
   int32_t  f4;
   int32_t  f5;
   int32_t  f6;
   struct S0  f7;
   signed f8 : 6;
};

union U2 {
   int16_t  f0;
   int16_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static float  func_28(void);
static struct S1  func_29(struct S1  p_30);
static uint64_t  func_36(struct S0  p_37, uint16_t  p_38, uint16_t  p_39);
inline static union U2  func_42(int32_t  p_43);
inline static struct S0  func_54(int64_t  p_55, struct S0 * p_56, uint64_t  p_57);
inline static float  func_71(struct S0 ** p_72, struct S0 ** p_73, struct S0 ** p_74, struct S0 ** p_75, int8_t  p_76);
inline static struct S0 ** func_77(struct S0 ** p_78);
static int16_t  func_84(struct S0 ** p_85, int32_t  p_86, int16_t  p_87);
inline static struct S0 *** func_90(int16_t  p_91, int64_t  p_92, union U2  p_93);
static int64_t  func_97(int8_t  p_98, int32_t  p_99, struct S0 ** p_100, int32_t * p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_28(void)
{ /* block id: 36 */
    struct S1 l_31 = {-3,65528UL,0L,0x60813C27L,0x355C0C8FL,-1L,-5L,{-10L},-0};
    struct S0 *l_680 = &l_31.f7;
    struct S0 **l_679 = &l_680;
    union U2 *l_685 = (void*)0;
    union U2 **l_684 = &l_685;
    union U2 ***l_683 = &l_684;
    float l_687 = 0x0.39A112p-90;
    float *l_686 = &l_687;
    int32_t **l_688 = (void*)0;
    int32_t **l_689 = (void*)0;
    int32_t l_692 = 1L;
    int32_t *l_691 = &l_692;
    int32_t **l_690 = &l_691;
    struct S1 *l_693 = (void*)0;
    struct S1 *l_694 = (void*)0;
    struct S1 *l_695 = (void*)0;
    struct S1 *l_696 = &l_31;
    int32_t l_697 = 0x805347CBL;
    l_31 = func_29(l_31);
    (*l_686) = ((((l_31.f6 != func_84(func_77(l_679), (0xDA00L != (safe_rshift_func_int16_t_s_u(l_31.f6, 11))), (l_683 == &l_684))) , &l_680) == &l_680) >= 0xD.C205DFp+58);
    (*l_690) = l_686;
    /* statement id: 351 */
    assert (l_691 == &l_687);
    (*l_696) = func_29(l_31);
    return l_697;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_29(struct S1  p_30)
{ /* block id: 37 */
    struct S0 l_40 = {1L};
    struct S0 ***l_659 = (void*)0;
    struct S0 ****l_658 = &l_659;
    struct S1 l_675 = {4,0xF036L,0xA8CAL,0xEA3140D2L,2L,-7L,0xBBB207A4L,{-4L},-0};
    for (p_30.f1 = 0; (p_30.f1 <= 40); ++p_30.f1)
    { /* block id: 40 */
        uint16_t l_41 = 0UL;
        float *l_650 = (void*)0;
        int32_t l_651 = 0xDC5F0204L;
        struct S1 l_657 = {1,0UL,-10L,0xB1A2F894L,-9L,9L,-1L,{0x3A9FL},4};
        struct S1 *l_656 = &l_657;
        struct S1 **l_655 = &l_656;
        struct S1 ***l_654 = &l_655;
        float l_674 = (-0x5.Bp-1);
        float *l_673 = &l_674;
        union U2 l_677 = {0x9373L};
        union U2 *l_676 = &l_677;
        union U2 **l_678 = &l_676;
        l_651 = (((safe_add_func_uint64_t_u_u(func_36(l_40, ((p_30.f0 | 8UL) , (__builtin_clz(__builtin_ctzll((((l_41 , (func_42((((l_41 <= __builtin_parity(p_30.f1)) | (0x1CD4L ^ __builtin_ctzll((safe_sub_func_int32_t_s_s((__builtin_ctzll((safe_rshift_func_int16_t_s_s(((safe_sub_func_uint64_t_u_u(3UL, 0x7E2192FE2CCF58D9LL)) < l_41), l_41))) | l_40.f0), (-1L)))))) > p_30.f5)) , l_40.f0)) == 1L) ^ p_30.f6))) , p_30.f2)), p_30.f4), p_30.f4)) ^ l_41) , p_30.f1);
        (*l_673) = ((safe_rshift_func_uint16_t_u_u(((l_654 != (void*)0) , (l_658 != ((safe_mul_func_uint16_t_u_u((!(safe_rshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s(__builtin_popcountl(((-1L) || ((p_30.f7.f0 <= p_30.f4) == (safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((p_30.f6 && l_40.f0), 2)), 4))))), p_30.f2)), l_657.f3))), l_657.f4)) , (void*)0))), p_30.f3)) , l_657.f2);
        (***l_654) = l_675;
        (*l_678) = l_676;
    }
    return l_675;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_36(struct S0  p_37, uint16_t  p_38, uint16_t  p_39)
{ /* block id: 340 */
    int32_t l_647 = 0x72BD2894L;
    float l_649 = 0x8.CAC603p-72;
    float *l_648 = &l_649;
    (*l_648) = l_647;
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_42(int32_t  p_43)
{ /* block id: 41 */
    struct S0 **l_50 = (void*)0;
    struct S0 l_53 = {0x9132L};
    struct S0 *l_52 = &l_53;
    struct S0 **l_51 = &l_52;
    struct S0 *l_645 = &l_53;
    union U2 l_646 = {1L};
    (*l_51) = (void*)0;
    /* statement id: 42 */
    assert (l_52 == 0);
    (*l_645) = func_54(l_53.f0, (*l_51), l_53.f0);
    return l_646;
    /* statement id: 339 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_54(int64_t  p_55, struct S0 * p_56, uint64_t  p_57)
{ /* block id: 43 */
    float l_60 = (-0x2.8p+1);
    int32_t l_61 = 0xCF39588DL;
    uint32_t l_64 = 6UL;
    struct S0 l_455 = {-10L};
    struct S0 *l_454 = &l_455;
    struct S0 **l_453 = &l_454;
    uint32_t l_480 = 1UL;
    uint32_t l_513 = 18446744073709551610UL;
    struct S0 l_524 = {8L};
    int32_t l_552 = 0xECAC81F4L;
    struct S0 **l_559 = &l_454;
    struct S1 l_583 = {-1,65535UL,0x19E0L,4294967286UL,0L,0x7BEF1ED8L,-10L,{7L},3};
    float *l_607 = &l_60;
    float **l_606 = &l_607;
    struct S0 ****l_618 = (void*)0;
    int32_t *l_624 = &l_61;
    struct S0 l_642 = {-7L};
    struct S0 l_644 = {-1L};
    if ((safe_mul_func_uint16_t_u_u(l_61, ((void*)0 == &p_56))))
    { /* block id: 44 */
        float l_65 = (-0x1.Dp+1);
        struct S0 l_70 = {9L};
        struct S0 *l_69 = &l_70;
        struct S0 **l_68 = &l_69;
        struct S0 **l_452 = &l_69;
        float *l_469 = &l_65;
        struct S0 **l_473 = &l_69;
        struct S1 l_486 = {-4,0x23E0L,-7L,0x0802A146L,0x0039FF32L,3L,0xDF09485DL,{0xA29AL},-5};
        int32_t *l_491 = (void*)0;
        int32_t l_543 = 0L;
        union U2 *l_558 = (void*)0;
        union U2 **l_557 = &l_558;
        union U2 *l_592 = (void*)0;
        struct S1 **l_602 = (void*)0;
        struct S1 ***l_601 = &l_602;
        struct S1 ****l_600 = &l_601;
lbl_492:
        (*l_469) = ((safe_div_func_float_f_f(l_64, 0x8.83ADABp-42)) == (l_65 == ((safe_sub_func_float_f_f(__builtin_parity(p_55), (l_68 != &p_56))) >= func_71(func_77(((p_55 ^ (((p_55 < 0L) , (void*)0) == (void*)0)) , (void*)0)), &l_69, l_452, l_453, p_55))));
lbl_584:
        for (l_61 = 0; (l_61 > (-18)); l_61 = safe_sub_func_uint16_t_u_u(l_61, 1))
        { /* block id: 258 */
            struct S1 l_472 = {5,0x1E5BL,5L,0UL,0L,0xF597ACBCL,0xF0C64A28L,{0xBBBBL},-0};
            struct S0 **l_482 = &l_454;
            int32_t *l_493 = &l_61;
            int64_t l_516 = 4L;
            l_472 = l_472;
            l_472.f8 = (func_84(l_473, l_472.f6, p_57) < ((((void*)0 == &l_68) == l_70.f0) , p_57));
            for (p_55 = 0; (p_55 >= (-16)); --p_55)
            { /* block id: 263 */
                struct S0 **l_481 = &l_69;
                int32_t *l_483 = &l_61;
                struct S1 *l_522 = &l_472;
                struct S1 **l_521 = &l_522;
                struct S1 ***l_520 = &l_521;
                struct S0 ***l_541 = &l_68;
                struct S0 ****l_540 = &l_541;
                if (func_97(p_55, ((((void*)0 == p_56) ^ ((safe_mul_func_uint16_t_u_u(func_97((__builtin_ffsl(l_61) ^ (safe_add_func_int64_t_s_s(p_57, (((l_480 >= p_55) || (-1L)) <= p_55)))), p_57, l_481, &l_61), 0L)) , l_70.f0)) | p_55), l_482, l_483))
                { /* block id: 264 */
                    int32_t *l_484 = (void*)0;
                    int32_t **l_485 = &l_484;
                    struct S1 *l_487 = (void*)0;
                    struct S1 *l_488 = &l_486;
                    (*l_485) = l_484;
                    (*l_488) = l_486;
                    if ((safe_mul_func_int16_t_s_s(((**l_482) , func_84((l_472.f1 , &l_69), p_55, l_472.f6)), (l_480 & (p_55 , p_55)))))
                    { /* block id: 267 */
                        (*l_454) = (**l_453);
                        l_491 = (*l_485);
                        /* statement id: 269 */
                        assert (l_491 == 0);
                        if (l_472.f4)
                            goto lbl_492;
                    }
                    else
                    { /* block id: 271 */
                        (*l_485) = l_493;
                        /* statement id: 272 */
                        assert (l_484 == &l_61);
                        (*l_485) = l_483;
                    }
                    /* facts after branching */
                    assert (l_484 == &l_61 || l_484 == 0);
                }
                else
                { /* block id: 275 */
                    float l_514 = 0x5.A5EBC0p-18;
                    int32_t l_515 = 0x76455C84L;
                    struct S1 l_530 = {-2,0x0AC3L,0x2FF1L,0x54D93E94L,0x5BC5E591L,0L,0L,{0xECBDL},7};
                    struct S0 *l_542 = &l_486.f7;
                    int32_t **l_544 = &l_491;
                    for (l_486.f6 = 0; (l_486.f6 == (-17)); l_486.f6 = safe_sub_func_int16_t_s_s(l_486.f6, 4))
                    { /* block id: 278 */
                        (*l_469) = (safe_sub_func_float_f_f(((safe_sub_func_float_f_f(0xD.D557D1p-45, (safe_sub_func_float_f_f(l_61, (__builtin_parityll((+(*l_493))) <= (safe_add_func_float_f_f(p_57, ((safe_add_func_float_f_f((safe_add_func_float_f_f(l_486.f0, (((((safe_add_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u(((p_55 | ((p_55 | 0x537BL) , l_61)) && p_57), p_55)), l_513)) , (*l_483)) , l_514) < (*l_493)) == 0x0.7p-1))), (*l_493))) <= p_57)))))))) == p_57), l_515));
                        if (p_57)
                            break;
                    }
                    if ((l_516 >= (safe_rshift_func_uint16_t_u_u(1UL, 8))))
                    { /* block id: 282 */
                        int32_t **l_519 = &l_483;
                        struct S1 ****l_523 = &l_520;
                        (*l_519) = (void*)0;
                        /* statement id: 283 */
                        assert (l_483 == 0);
                        if (l_486.f6)
                            goto lbl_643;
                        (*l_523) = l_520;
                        if (l_455.f0)
                            goto lbl_492;
                        if (p_57)
                            break;
                    }
                    else
                    { /* block id: 287 */
                        int32_t l_525 = 0xBE8DE9C3L;
                        struct S0 ***l_539 = &l_482;
                        struct S0 ****l_538 = &l_539;
                        l_524 = (p_55 , (*l_454));
                        (*l_469) = (((l_525 <= (safe_mul_func_float_f_f(((0x3.3AC7ADp-88 != (-(+(l_530 , p_55)))) == l_530.f5), p_55))) < ((p_57 >= (safe_mul_func_float_f_f((!l_525), (l_525 <= p_55)))) > p_57)) <= 0x4.3966BFp+38);
                        if (l_513)
                            break;
                        l_515 = (safe_sub_func_float_f_f(((safe_div_func_float_f_f((l_538 != l_540), ((__builtin_clz(p_57) , (**l_539)) == l_542))) >= l_543), 0x0.6p-1));
                    }
                    /* facts after branching */
                    assert (l_483 == &l_61 || l_483 == 0);
                    (*l_544) = l_483;
                    l_491 = (*l_544);
                }
                /* facts after branching */
                assert (l_483 == &l_61 || l_483 == 0);
            }
        }
        for (l_61 = (-28); (l_61 == (-26)); ++l_61)
        { /* block id: 300 */
            int32_t *l_549 = &l_61;
            union U2 *l_556 = (void*)0;
            union U2 **l_555 = &l_556;
            int32_t *l_560 = &l_552;
            struct S0 l_568 = {0L};
            int32_t **l_570 = &l_491;
            int32_t ***l_569 = &l_570;
            for (l_486.f6 = 0; (l_486.f6 <= 11); ++l_486.f6)
            { /* block id: 303 */
                int32_t **l_550 = (void*)0;
                int32_t **l_551 = &l_549;
                (*l_68) = (void*)0;
                /* statement id: 304 */
                assert (l_69 == 0);
                (*l_551) = l_549;
                if (l_552)
                    continue;
            }
            (*l_560) = (((safe_add_func_int16_t_s_s(((p_55 == (0xC9A96BA77663CFE6LL < (func_97((l_555 != (p_57 , l_557)), p_57, func_77(l_559), (l_486 , (void*)0)) || p_55))) ^ p_55), 0xB76FL)) | (-10L)) & (*l_549));
            if ((safe_unary_minus_func_uint64_t_u((safe_sub_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((l_568 , (l_569 == (void*)0)), (safe_mod_func_uint16_t_u_u(3UL, p_57)))), (safe_div_func_uint64_t_u_u(1UL, (((safe_mul_func_int16_t_s_s((safe_mul_func_int16_t_s_s(((safe_div_func_uint64_t_u_u(__builtin_ctz(p_55), (safe_sub_func_uint32_t_u_u(((l_583 , l_583.f6) ^ p_57), 0xFC2AD7E1L)))) || 1L), l_486.f3)), p_55)) > (-4L)) && 0xE73E58A54B1F418CLL))))), p_55)))))
            { /* block id: 309 */
                if (l_583.f2)
                    goto lbl_584;
            }
            else
            { /* block id: 311 */
                int16_t l_587 = (-3L);
                struct S1 ****l_603 = &l_601;
                int32_t *l_605 = &l_61;
                struct S0 l_610 = {0x9CC4L};
                if ((safe_sub_func_uint16_t_u_u(l_587, (safe_rshift_func_uint16_t_u_u(l_583.f0, 1)))))
                { /* block id: 312 */
                    uint16_t l_596 = 1UL;
                    struct S0 **l_604 = &l_454;
                    (*l_560) = ((safe_lshift_func_int16_t_s_u(p_55, func_97((l_587 , ((void*)0 != l_592)), (p_57 == (safe_rshift_func_int16_t_s_s((((p_57 == (safe_unary_minus_func_uint64_t_u((l_596 > func_97((safe_mul_func_uint16_t_u_u(((0x1EC1L | (((+(l_600 == l_603)) || p_55) && l_596)) != p_57), p_55)), p_57, l_604, l_605))))) == 0xA564L) != (*l_560)), 14))), &l_69, l_469))) , l_596);
                }
                else
                { /* block id: 314 */
                    float ***l_608 = &l_606;
                    struct S0 ***l_609 = &l_453;
                    (*l_603) = (*l_600);
                    (*l_608) = l_606;
                    (*l_609) = &p_56;
                    /* statement id: 317 */
                    assert (l_453 == &p_56);
                }
                /* facts after branching */
                assert (l_453 == &p_56 || l_453 == &l_454);
                return l_610;
            }
        }
    }
    else
    { /* block id: 322 */
        struct S0 ****l_619 = (void*)0;
        float *l_620 = &l_60;
        int32_t l_621 = 0x6E7423A7L;
        int32_t *l_641 = &l_61;
        if ((0xCB60L & (0x545B3E25D42C2060LL | ((((((safe_sub_func_uint16_t_u_u((safe_unary_minus_func_uint64_t_u((safe_sub_func_int32_t_s_s((safe_mod_func_int32_t_s_s((l_618 != l_619), 4294967290UL)), ((*l_606) != (l_583 , l_620)))))), (l_621 <= l_621))) ^ l_621) | p_55) < l_621) & p_57) == l_583.f7.f0))))
        { /* block id: 323 */
            int32_t *l_622 = &l_61;
            int32_t **l_623 = &l_622;
            struct S0 **l_640 = &l_454;
            (*l_622) = 0xA76938A6L;
            (*l_623) = &l_61;
            (*l_623) = l_624;
            if (p_55)
                goto lbl_643;
            (*l_624) = ((p_57 ^ ((safe_add_func_int64_t_s_s(p_55, p_57)) | (safe_mul_func_uint16_t_u_u(l_621, func_97((!l_621), (safe_add_func_uint64_t_u_u(0x0335CE69AB97FC59LL, ((safe_add_func_int32_t_s_s((safe_mod_func_int64_t_s_s((safe_add_func_int32_t_s_s(((safe_sub_func_uint32_t_u_u(p_55, (*l_624))) < p_55), (-10L))), 1L)), 2UL)) < 0xF4BEL))), l_640, l_641))))) , (*l_624));
        }
        else
        { /* block id: 328 */
            return l_642;
        }
        l_641 = &l_621;
        /* statement id: 331 */
        assert (l_641 == &l_621);
    }
lbl_643:
    (*l_559) = (*l_453);
    (*l_454) = (*l_454);
    return l_644;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_71(struct S0 ** p_72, struct S0 ** p_73, struct S0 ** p_74, struct S0 ** p_75, int8_t  p_76)
{ /* block id: 251 */
    union U2 l_456 = {-6L};
    struct S0 *l_458 = (void*)0;
    struct S0 **l_457 = &l_458;
    int32_t *l_465 = (void*)0;
    float l_467 = 0x8.4D880Ep+87;
    float *l_466 = &l_467;
    int32_t **l_468 = &l_465;
    (*l_466) = func_97(((l_456 , l_456) , (__builtin_clz(((l_457 == p_72) < __builtin_clzl(((l_456.f1 < l_456.f0) && (p_76 || (safe_mul_func_uint16_t_u_u(0x0825L, ((safe_mod_func_uint16_t_u_u(((safe_mul_func_int16_t_s_s(p_76, p_76)) == l_456.f1), 0x1503L)) == (-10L))))))))) < l_456.f1)), l_456.f0, p_74, l_465);
    (*l_468) = l_466;
    /* statement id: 253 */
    assert (l_465 == &l_467);
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 ** func_77(struct S0 ** p_78)
{ /* block id: 45 */
    int32_t l_81 = 0L;
    float l_358 = 0xE.245F02p-64;
    float *l_357 = &l_358;
    float *l_359 = &l_358;
    uint16_t l_360 = 65535UL;
    int32_t *l_361 = &l_81;
    struct S0 **l_373 = (void*)0;
    struct S0 l_378 = {-1L};
    struct S1 l_408 = {0,1UL,-1L,0xE1F674C5L,0x383D2059L,0xE73978AAL,0L,{1L},4};
    int32_t ***l_410 = (void*)0;
    int32_t l_421 = 0x5B47B51DL;
    uint64_t l_441 = 0xC5CBC6346BD332B8LL;
    struct S0 ****l_447 = (void*)0;
    struct S0 *****l_446 = &l_447;
    (*l_361) = ((l_81 , ((safe_add_func_int16_t_s_s(func_84(p_78, l_81, l_81), ((safe_add_func_int16_t_s_s(__builtin_ctzll((((l_81 , (l_81 , l_357)) == l_359) , l_81)), l_360)) , l_81))) , 1UL)) >= 0x209F7C56E569AF53LL);
lbl_451:
    for (l_81 = 0; (l_81 > 5); l_81 = safe_add_func_int16_t_s_s(l_81, 1))
    { /* block id: 194 */
        int32_t l_365 = 0L;
        int32_t *l_364 = &l_365;
        struct S0 l_372 = {0x4CA9L};
        struct S0 *l_371 = &l_372;
        struct S0 **l_370 = &l_371;
        union U2 l_389 = {-5L};
        union U2 *l_388 = &l_389;
        struct S1 l_399 = {6,1UL,0x6DA2L,9UL,0x62143E2FL,-8L,0L,{6L},-1};
        struct S1 *l_398 = &l_399;
        int8_t l_405 = 0xCDL;
        int32_t ***l_409 = (void*)0;
        (*l_364) = 0xD57E038DL;
        for (l_360 = 25; (l_360 == 13); l_360 = safe_sub_func_int16_t_s_s(l_360, 6))
        { /* block id: 198 */
            struct S0 *l_369 = (void*)0;
            struct S0 **l_368 = &l_369;
            return l_373;
            /* statement id: 199 */
            //assert (func_77_rv == 0);
        }
        for (l_365 = 0; (l_365 == (-19)); l_365 = safe_sub_func_uint64_t_u_u(l_365, 8))
        { /* block id: 203 */
            int16_t l_377 = 0xDCECL;
            union U2 *l_387 = (void*)0;
            struct S1 l_394 = {2,8UL,0xD9B5L,0xCDB702C7L,6L,0xEBCC9911L,0x011C773FL,{0x6A34L},1};
            struct S1 **l_400 = &l_398;
            struct S0 ***l_420 = &l_370;
            struct S0 ****l_419 = &l_420;
            struct S0 *****l_418 = &l_419;
            union U2 **l_444 = &l_387;
            union U2 ***l_443 = &l_444;
        }
    }
    (*l_361) = (safe_lshift_func_uint16_t_u_u((*l_361), 10));
    if (l_81)
        goto lbl_451;
    return p_78;
    /* statement id: 250 */
    //assert (func_77_rv == 0 || func_77_rv == &l_454 || func_77_rv == &l_680);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_84(struct S0 ** p_85, int32_t  p_86, int16_t  p_87)
{ /* block id: 46 */
    int32_t l_89 = 9L;
    int32_t *l_88 = &l_89;
    int64_t l_96 = 1L;
    struct S0 l_106 = {0xF43CL};
    struct S0 *l_105 = &l_106;
    struct S0 **l_104 = &l_105;
    union U2 l_113 = {0x5A1CL};
    struct S0 ***l_352 = &l_104;
    struct S0 ****l_351 = &l_352;
    int32_t **l_353 = &l_88;
    (*l_88) = p_87;
    if (p_87)
        goto lbl_354;
    (*l_351) = func_90((safe_lshift_func_uint16_t_u_u(l_96, ((*l_88) | (((*l_88) && ((func_97((*l_88), ((((safe_mod_func_int32_t_s_s((((*l_88) >= (*l_88)) , p_86), (*l_88))) || ((*l_88) , (*l_88))) & 8L) <= p_87), l_104, &l_89) || 0x49D9BB22B282FFB0LL) >= 0xE2804CE6FA9739A1LL)) && p_87)))), p_87, l_113);
    /* statement id: 187 */
    assert (l_352 == 0);
lbl_354:
    (*l_353) = &l_89;
    return p_86;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 *** func_90(int16_t  p_91, int64_t  p_92, union U2  p_93)
{ /* block id: 56 */
    int64_t l_114 = (-3L);
    struct S1 l_119 = {-4,0x7EB9L,0x776CL,0x754D5C11L,0x0172C61BL,0xCE843D8BL,0xA40D6DD5L,{0x41E9L},-3};
    int32_t l_124 = 0xBEEE9A18L;
    int32_t *l_123 = &l_124;
    struct S0 *l_144 = &l_119.f7;
    struct S0 **l_143 = &l_144;
    struct S0 ***l_142 = &l_143;
    struct S0 ***l_145 = &l_143;
    struct S0 ***l_148 = (void*)0;
    struct S0 ****l_168 = &l_148;
    int32_t **l_189 = &l_123;
    int32_t ***l_188 = &l_189;
    int32_t ****l_187 = &l_188;
    int8_t l_213 = 0x62L;
    struct S0 ***l_336 = &l_143;
    struct S0 ***l_340 = &l_143;
    struct S0 ***l_341 = &l_143;
    struct S0 ***l_342 = &l_143;
    struct S0 ***l_343 = &l_143;
    struct S0 ***l_344 = &l_143;
    struct S0 ***l_345 = &l_143;
    struct S0 ***l_346 = &l_143;
    struct S0 ***l_347 = &l_143;
    struct S0 ***l_348 = &l_143;
    struct S0 ***l_349 = &l_143;
    struct S0 ***l_350 = (void*)0;
    if (l_114)
    { /* block id: 57 */
        struct S0 l_115 = {0x628AL};
        struct S0 *l_116 = &l_115;
        float l_118 = (-0x4.4p+1);
        float *l_117 = &l_118;
        (*l_116) = l_115;
        (*l_117) = (-0x10.3p+1);
    }
    else
    { /* block id: 60 */
        struct S1 *l_120 = &l_119;
        int32_t l_129 = 0x087C2297L;
        struct S0 *l_140 = &l_119.f7;
        struct S0 **l_139 = &l_140;
        struct S0 ***l_138 = &l_139;
        struct S0 ***l_146 = &l_139;
        uint16_t l_153 = 0x11C5L;
        float l_155 = 0x7.65799Cp-87;
        float *l_154 = &l_155;
        (*l_120) = (l_114 , l_119);
        if ((((0x054D2AC3227D8CF6LL <= (safe_div_func_uint64_t_u_u(((l_123 != (void*)0) < (safe_div_func_int64_t_s_s(p_93.f0, __builtin_ctz(((safe_mul_func_int16_t_s_s((*l_123), (((((*l_123) <= l_129) <= (safe_add_func_float_f_f((((((safe_rshift_func_int16_t_s_s((safe_sub_func_uint64_t_u_u(0xA5B5AAB37417BD2FLL, p_93.f0)), (*l_123))) > 0xF86792DBL) >= 1UL) == 1L) , 0x1.3p-1), l_129))) , p_92) > p_91))) && 0xF5A799B5C0F6DB6ALL))))), p_93.f0))) >= p_92) , 9L))
        { /* block id: 62 */
            (*l_123) = (safe_mul_func_int16_t_s_s(l_129, (*l_123)));
        }
        else
        { /* block id: 64 */
            struct S0 ***l_141 = &l_139;
            struct S0 ***l_147 = &l_139;
            return l_148;
            /* statement id: 65 */
            //assert (func_90_rv == 0);
        }
        (*l_154) = (safe_mul_func_float_f_f((safe_add_func_float_f_f(0x1.7p+1, (l_129 > l_129))), func_97(l_153, ((-9L) != ((*l_123) != ((*l_123) , l_129))), (*l_142), &l_129)));
    }
    for (p_93.f1 = 8; (p_93.f1 < (-29)); p_93.f1 = safe_sub_func_uint16_t_u_u(p_93.f1, 5))
    { /* block id: 71 */
        int32_t **l_158 = &l_123;
        struct S0 **l_167 = &l_144;
        struct S1 l_229 = {-2,0xED70L,0x56FAL,0x5395DFB6L,1L,0xBA012D08L,0x2D788D99L,{0x68BBL},6};
        struct S0 ***l_337 = &l_143;
        struct S0 ***l_338 = &l_167;
        (*l_158) = &l_124;
        (**l_158) = (*l_123);
        if ((safe_mod_func_int32_t_s_s((safe_mod_func_int32_t_s_s(((safe_sub_func_int16_t_s_s((((__builtin_bswap32(p_92) , p_93.f0) > (**l_158)) <= (0x39DAF5B91466E0B1LL != (*l_123))), ((safe_add_func_uint16_t_u_u((p_93.f0 > (__builtin_bswap32(func_97((**l_158), p_92, l_167, (*l_158))) > (**l_158))), 65535UL)) > 0x635DL))) ^ 0x7C643468L), (**l_158))), p_91)))
        { /* block id: 74 */
            l_168 = &l_142;
            /* statement id: 75 */
            assert (l_168 == &l_142);
            (*l_158) = &l_124;
        }
        else
        { /* block id: 77 */
            struct S0 **l_184 = &l_144;
            int32_t *l_185 = &l_124;
            uint32_t l_186 = 18446744073709551615UL;
            struct S0 **l_210 = &l_144;
            int32_t l_301 = 0L;
            uint32_t l_302 = 0x9793804DL;
            if ((((((p_91 , (safe_mod_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(((safe_mul_func_float_f_f((0x9.314DBEp-22 > (((((*l_123) | (safe_mod_func_int64_t_s_s((safe_mod_func_int16_t_s_s((((safe_mod_func_uint16_t_u_u((p_93.f0 , (func_97((0x0193L <= ((__builtin_parityll(p_91) <= (!((*l_123) <= p_91))) ^ p_91)), (**l_158), l_184, l_185) , 0x2F35L)), (**l_158))) , 0x052DL) < 0x885DL), p_92)), p_92))) != 0x67A8L) >= p_91) , (*l_185))), 0x4.B2C92Ap-80)) , (*l_123)), p_92)) | p_92), 2UL)), 0x4092L))) >= p_91) , p_93.f0) , l_186) > 0x6330L))
            { /* block id: 78 */
                int32_t *****l_190 = &l_187;
                struct S1 *l_206 = &l_119;
                struct S0 l_215 = {0L};
                (*l_190) = l_187;
                for (l_186 = (-18); (l_186 >= 2); l_186 = safe_add_func_uint32_t_u_u(l_186, 4))
                { /* block id: 82 */
                    uint16_t l_209 = 0x15C3L;
                    for (l_119.f5 = 0; (l_119.f5 > 15); l_119.f5 = safe_add_func_uint64_t_u_u(l_119.f5, 1))
                    { /* block id: 85 */
                        int32_t *l_195 = &l_124;
                        float l_208 = 0x3.92E011p+26;
                        float *l_207 = &l_208;
                        (*l_158) = (****l_190);
                        l_185 = l_195;
                        (*l_207) = (safe_mul_func_float_f_f(((*****l_190) <= (**l_158)), ((safe_div_func_int16_t_s_s(((*l_195) , (8L >= ((safe_mod_func_int32_t_s_s((safe_mul_func_uint16_t_u_u((safe_sub_func_int32_t_s_s(((*l_195) & (l_206 == (void*)0)), (-1L))), p_91)), 1L)) & p_91))), 8UL)) , p_92)));
                        (*l_207) = func_97((***l_188), l_209, l_210, (***l_187));
                    }
                }
                (****l_187) = (**l_189);
                for (l_119.f2 = 4; (l_119.f2 <= 17); l_119.f2 = safe_add_func_int16_t_s_s(l_119.f2, 1))
                { /* block id: 95 */
                    uint32_t l_232 = 3UL;
                    int32_t *l_233 = &l_124;
                }
            }
            else
            { /* block id: 115 */
                struct S1 l_250 = {-2,0x4785L,0L,1UL,8L,1L,0x5E633137L,{0L},-4};
                struct S0 ***l_260 = &l_167;
                struct S1 *l_262 = &l_229;
                struct S1 **l_261 = &l_262;
                for (l_119.f4 = 22; (l_119.f4 < (-17)); --l_119.f4)
                { /* block id: 118 */
                    struct S0 **l_239 = &l_144;
                    int32_t l_246 = (-8L);
                    int32_t *l_253 = &l_124;
                    if ((safe_rshift_func_int16_t_s_s(func_97(func_97((+18446744073709551615UL), __builtin_ia32_crc32qi((p_91 ^ (p_92 & func_97((**l_158), p_93.f0, l_239, (*l_158)))), (safe_mod_func_uint32_t_u_u((safe_div_func_int32_t_s_s((((safe_mul_func_int16_t_s_s(0xF1C8L, (*l_185))) > p_92) || p_91), p_91)), l_246))), l_210, (***l_187)), l_246, l_167, (*l_158)), 9)))
                    { /* block id: 119 */
                        if (p_91)
                            break;
                        (**l_189) = (*l_185);
                        if (p_92)
                            break;
                    }
                    else
                    { /* block id: 123 */
                        (**l_142) = (void*)0;
                        /* statement id: 124 */
                        assert (l_144 == 0);
                    }
                    for (l_119.f1 = 0; (l_119.f1 == 40); l_119.f1 = safe_add_func_uint16_t_u_u(l_119.f1, 2))
                    { /* block id: 128 */
                        struct S1 *l_249 = &l_229;
                        (*l_249) = l_119;
                        (*l_249) = l_250;
                        (*l_158) = (**l_188);
                    }
                    for (l_114 = (-1); (l_114 < (-8)); l_114 = safe_sub_func_uint32_t_u_u(l_114, 8))
                    { /* block id: 135 */
                        float l_256 = 0x0.4p+1;
                        float *l_259 = &l_256;
                        (***l_187) = l_253;
                        (*l_259) = (0xA.B15F34p+97 > (((p_93.f1 != (safe_sub_func_float_f_f(l_256, __builtin_ffsll((****l_187))))) >= (safe_sub_func_float_f_f(p_93.f0, p_93.f0))) == p_91));
                        l_260 = &l_210;
                        /* statement id: 138 */
                        assert (l_260 == &l_210);
                    }
                }
                /* facts after for loop */
                assert (l_260 == &l_210 || l_260 == &l_167);
                (*l_261) = (void*)0;
                /* statement id: 141 */
                assert (l_262 == 0);
            }
            for (l_119.f6 = (-24); (l_119.f6 > 22); l_119.f6 = safe_add_func_int64_t_s_s(l_119.f6, 1))
            { /* block id: 145 */
                int8_t l_265 = 1L;
                struct S0 ***l_273 = &l_184;
                int32_t *l_278 = &l_124;
                int16_t l_312 = 0xB809L;
            }
        }
    }
    /* facts after for loop */
        assert (l_144 == 0 || l_144 == &l_119.f7);
    assert (l_168 == &l_148 || l_168 == &l_142);
    return l_350;
    /* statement id: 186 */
    //assert (func_90_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_97(int8_t  p_98, int32_t  p_99, struct S0 ** p_100, int32_t * p_101)
{ /* block id: 48 */
    struct S1 l_112 = {-4,0x4755L,3L,0xA71D4F06L,0x86993EB3L,0x379BBDC2L,1L,{6L},-3};
    for (p_99 = 0; (p_99 == (-11)); p_99 = safe_sub_func_int16_t_s_s(p_99, 7))
    { /* block id: 51 */
        int32_t *l_110 = (void*)0;
        int32_t **l_109 = &l_110;
        int32_t ***l_111 = &l_109;
        (*l_111) = l_109;
        l_112 = l_112;
    }
    return p_98;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 163
   depth: 1, occurrence: 9
   depth: 2, occurrence: 14
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 14
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 0
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 22
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 5

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 155
   depth: 2, occurrence: 24
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 208

XXX times a variable address is taken: 196
XXX times a pointer is dereferenced on RHS: 121
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 26
   depth: 3, occurrence: 8
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 94
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 649

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 376
   level: 2, occurrence: 68
   level: 3, occurrence: 22
   level: 4, occurrence: 12
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 123
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 28
XXX percent of pointers has null in alias set: 23.1
XXX average alias set size: 1.19

XXX times a non-volatile is read: 813
XXX times a non-volatile is write: 252
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 5

XXX stmts: 133
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 22
   depth: 2, occurrence: 19
   depth: 3, occurrence: 13
   depth: 4, occurrence: 15
   depth: 5, occurrence: 30

XXX percentage a fresh-made variable is used: 14.5
XXX percentage an existing variable is used: 85.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

