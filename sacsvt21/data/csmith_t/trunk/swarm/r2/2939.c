/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3259693476
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int32_t  f1;
   uint32_t  f2;
   uint32_t  f3;
   uint16_t  f4;
   int32_t  f5;
   uint32_t  f6;
   int32_t  f7;
   const int16_t  f8;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   unsigned f0 : 8;
   unsigned f1 : 20;
   signed f2 : 2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_31(void);
static struct S1  func_35(uint32_t  p_36, uint32_t  p_37, struct S0  p_38, struct S0  p_39);
static int32_t  func_49(uint8_t  p_50);
static struct S1  func_51(int32_t  p_52, uint8_t  p_53);
static uint32_t  func_72(struct S1  p_73, struct S1  p_74, const struct S0  p_75, int32_t  p_76);
static uint32_t  func_82(uint32_t  p_83);
static uint32_t  func_91(int32_t  p_92, struct S0  p_93, uint32_t  p_94, struct S1  p_95, struct S1  p_96);
inline static struct S1  func_98(struct S0  p_99, uint32_t  p_100);
inline static struct S1  func_101(const uint32_t  p_102);
inline static uint32_t  func_103(uint32_t  p_104, int32_t  p_105, uint32_t  p_106, struct S0  p_107);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_31(void)
{ /* block id: 36 */
    uint8_t l_32 = 4UL;
    struct S0 l_40 = {0xBDAE8940L,-7L,18446744073709551615UL,0xDB51FD9AL,0x8A87L,-2L,4294967286UL,0x06383254L,0x3B19L};
    struct S0 l_41 = {-1L,0x1197BA27L,0x38E21363L,0xE7A32987L,0x837EL,0x5AF849FBL,0x5C1F4ACAL,0x2E26A8ACL,0xD1F6L};
    struct S1 l_46 = {8,209,-1};
    ++l_32;
    l_46 = func_35(l_32, l_32, l_40, l_41);
    for (l_40.f0 = (-8); (l_40.f0 != (-14)); l_40.f0 -= 2)
    { /* block id: 44 */
        l_41.f0 ^= func_49(l_41.f6);
    }
    return l_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_35(uint32_t  p_36, uint32_t  p_37, struct S0  p_38, struct S0  p_39)
{ /* block id: 38 */
    uint32_t l_43 = 0UL;
    int32_t l_44 = 0xA3CE724DL;
    struct S1 l_45 = {14,519,0};
    l_44 = (~l_43);
    return l_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_49(uint8_t  p_50)
{ /* block id: 45 */
    int32_t l_64 = 6L;
    struct S1 l_71 = {1,859,0};
    const struct S0 l_456 = {0x145B0690L,0xF26A2760L,5UL,0x822F24E1L,65526UL,8L,0x4ADD1B52L,-5L,0x89F4L};
    int32_t l_458 = 2L;
    int32_t l_462 = (-8L);
    int32_t l_463 = 9L;
    int32_t l_465 = 0x6A6A6E40L;
    int32_t l_466 = 0xA750B496L;
    int32_t l_474 = 0x63FD43EEL;
    int32_t l_476 = 0xF2F42F70L;
    int32_t l_477 = (-6L);
    int32_t l_481 = 0L;
    int32_t l_482 = 0x0FA4EE61L;
    uint32_t l_485 = 0x1DA92B66L;
    uint16_t l_506 = 0x2A05L;
    uint32_t l_532 = 0x4B30161BL;
    const uint32_t l_563 = 0x8316AFCFL;
    uint32_t l_641 = 4294967286UL;
lbl_645:
    l_71 = func_51((((int16_t)(((uint16_t)(((int16_t)((int32_t)0xE20E6E86L % (int32_t)p_50) << (int16_t)8) >= ((int16_t)l_64 >> (int16_t)(((~(((uint16_t)(((l_64 > p_50) == (0x2D30A937L || __builtin_parity(p_50))) > p_50) + (uint16_t)p_50) == (-1L))) & 0xE3B7L) & p_50))) + (uint16_t)1UL) || (-5L)) << (int16_t)p_50) != 0L), l_64);
    if (((func_72(func_51(((uint16_t)0x6244L << (uint16_t)((~1UL) | (((((uint32_t)func_82(p_50) + (uint32_t)((int16_t)(__builtin_ffsll(p_50) <= l_64) - (int16_t)((uint16_t)__builtin_ctz(l_71.f2) << (uint16_t)l_71.f1))) == 0x62B9L) || p_50) >= 0x66CE93E1L))), p_50), l_71, l_456, p_50) < 0xDBCE61ADL) >= l_456.f4))
    { /* block id: 196 */
        l_71.f2 = (65531UL > p_50);
        return p_50;
    }
    else
    { /* block id: 199 */
        int16_t l_457 = 0xB31AL;
        int32_t l_459 = 0xD18D7B6EL;
        int32_t l_460 = 0L;
        int32_t l_461 = (-5L);
        int32_t l_464 = 0x41C3D795L;
        int32_t l_467 = 0xBC7448AAL;
        int32_t l_468 = 0L;
        int32_t l_469 = 0x55CA80E3L;
        int32_t l_470 = 0x5420D13AL;
        int32_t l_471 = 0L;
        int32_t l_472 = 0x23898DAFL;
        int32_t l_473 = (-1L);
        int32_t l_475 = 0x2F5ED9FBL;
        int32_t l_478 = 0x940DA9D7L;
        int32_t l_479 = 0L;
        int32_t l_480 = 0xC4D2F9F2L;
        int32_t l_483 = 9L;
        int32_t l_484 = 0xE33E00F8L;
        l_485++;
        l_477 = ((((uint16_t)((uint32_t)(+l_456.f8) + (uint32_t)((uint16_t)p_50 >> (uint16_t)((((+((int16_t)(((int16_t)(1L ^ __builtin_clzl(__builtin_clzl(p_50))) << (int16_t)(p_50 > (-1L))) & 0x2D8FE386L) >> (int16_t)p_50)) || 1L) == l_461) & 0xFC97L))) << (uint16_t)l_467) | l_480) | l_482);
    }
    if (((p_50 <= ((int16_t)0x0487L >> (int16_t)((uint16_t)((int16_t)p_50 >> (int16_t)11) << (uint16_t)2))) || (l_482 && l_506)))
    { /* block id: 203 */
        struct S0 l_516 = {0xC3F74C84L,0x035C2B32L,1UL,0x0B747A80L,0x710FL,5L,4294967295UL,-4L,-4L};
        struct S1 l_517 = {3,809,1};
        uint8_t l_526 = 0xF8L;
        struct S1 l_605 = {6,146,0};
        uint32_t l_630 = 1UL;
        uint8_t l_640 = 0x99L;
        for (l_482 = (-23); (l_482 <= (-4)); l_482++)
        { /* block id: 206 */
            int32_t l_511 = (-1L);
            l_458 |= ((((uint16_t)l_511 << (uint16_t)l_456.f7) != l_511) == 0x1448L);
        }
        if (((uint16_t)((uint16_t)(func_91(p_50, l_516, p_50, l_517, l_71) > l_456.f7) << (uint16_t)((uint32_t)(((uint32_t)__builtin_ffsl(((int16_t)(func_82(((uint32_t)((func_103(p_50, p_50, l_526, l_456) <= l_516.f3) ^ 4L) - (uint32_t)0x4D7C293DL)) & 0x37C265CBL) >> (int16_t)l_481)) % (uint32_t)l_516.f5) != l_462) + (uint32_t)p_50)) % (uint16_t)l_64))
        { /* block id: 209 */
            uint32_t l_527 = 1UL;
            struct S1 l_580 = {0,846,-0};
            struct S0 l_583 = {-6L,0x3D680397L,1UL,4294967295UL,4UL,-10L,4294967295UL,-6L,-1L};
            struct S0 l_585 = {-1L,0xE994592DL,1UL,0x7215AE6EL,6UL,1L,0x4EA0DA7AL,0xE23ADA1FL,0x46BEL};
            int16_t l_589 = 3L;
            int16_t l_618 = 0x2F19L;
            uint16_t l_639 = 65535UL;
            ++l_527;
            for (l_458 = 22; (l_458 > (-8)); --l_458)
            { /* block id: 213 */
                if (p_50)
                { /* block id: 214 */
                    l_463 |= (0xE08FL || (p_50 <= 0x52C1L));
                    if (p_50)
                        break;
                }
                else
                { /* block id: 217 */
                    return l_532;
                }
            }
            if (((func_103((((int16_t)0L - (int16_t)((uint32_t)((1UL ^ ((int16_t)p_50 % (int16_t)((int16_t)(l_482 ^ ((uint32_t)p_50 - (uint32_t)((!((0UL | l_456.f5) && (((uint16_t)p_50 >> (uint16_t)((int32_t)(p_50 < l_516.f2) % (int32_t)0x43A2CD0AL)) <= p_50))) < 0x7C693CCDL))) >> (int16_t)1))) <= l_527) - (uint32_t)0xDA7264B7L)) >= 0x0E5574AFL), l_516.f0, p_50, l_456) != l_506) == l_527))
            { /* block id: 221 */
                struct S1 l_552 = {14,228,-1};
                for (l_477 = 0; (l_477 > (-27)); l_477 -= 3)
                { /* block id: 224 */
                    struct S1 l_553 = {6,850,1};
                    for (l_516.f0 = 25; (l_516.f0 > 15); l_516.f0 -= 2)
                    { /* block id: 227 */
                        uint32_t l_554 = 18446744073709551607UL;
                        l_553 = l_552;
                        l_554 ^= (l_466 != 4L);
                        l_553.f2 = ((p_50 || (((int32_t)((uint16_t)p_50 >> (uint16_t)4) + (int32_t)l_532) > ((-(uint16_t)(((uint16_t)(!(p_50 || l_563)) >> (uint16_t)2) <= ((-7L) ^ l_554))) != 0x262EE9CCL))) >= p_50);
                    }
                    l_516.f5 |= (((int16_t)(l_466 || 65535UL) << (int16_t)(((int32_t)(((int16_t)((0x680B7E34L != (l_553.f2 || ((l_553.f0 < (~(((int32_t)l_552.f1 - (int32_t)l_552.f1) | l_476))) == p_50))) ^ (-1L)) << (int16_t)p_50) || l_552.f1) - (int32_t)l_552.f1) && p_50)) >= 0x7D387E9AL);
                    for (l_481 = 0; (l_481 <= 6); l_481++)
                    { /* block id: 235 */
                        uint16_t l_579 = 1UL;
                        l_458 = ((uint32_t)l_579 - (uint32_t)__builtin_popcount(p_50));
                        l_71 = l_580;
                    }
                }
                return l_552.f1;
            }
            else
            { /* block id: 241 */
                uint32_t l_581 = 18446744073709551607UL;
                struct S0 l_582 = {-10L,1L,18446744073709551612UL,0UL,65529UL,0x38174678L,0x69DFE5DAL,0x64E9A230L,3L};
                struct S1 l_584 = {7,898,-0};
                struct S0 l_606 = {0x7597F1B5L,1L,18446744073709551609UL,0xFE50D40AL,6UL,-1L,0x18CBE8B2L,0x25985319L,0x86FBL};
                if (((l_581 || 65531UL) > func_103((((p_50 == ((4294967295UL && p_50) > func_91(l_581, l_516, l_477, func_35(l_506, p_50, l_582, l_583), l_584))) ^ l_71.f0) >= l_516.f0), p_50, l_583.f8, l_585)))
                { /* block id: 242 */
                    int16_t l_588 = 0L;
                    l_589 = (0x3F0ADC26L >= (1UL >= (0xB4BCA64FL <= (((uint16_t)(func_103(p_50, l_588, l_588, l_456) && (((0xC47AL || p_50) > p_50) || l_583.f7)) << (uint16_t)14) <= 0UL))));
                }
                else
                { /* block id: 244 */
                    int32_t l_591 = (-1L);
                    struct S0 l_601 = {0L,0L,0xF14996A1L,4294967295UL,0UL,0x4817ADA1L,4294967295UL,0xF80B686BL,-1L};
                    l_516.f0 = ((-(uint32_t)(p_50 > (l_516.f5 <= l_591))) <= ((((+(6L | ((int32_t)func_103(p_50, ((int32_t)l_516.f6 + (int32_t)(((l_585.f0 != (((((((uint16_t)p_50 << (uint16_t)((uint16_t)(p_50 | 0x5EA3L) << (uint16_t)7)) > p_50) ^ 5L) == p_50) && 9L) ^ l_532)) <= p_50) <= l_64)), p_50, l_601) + (int32_t)l_582.f8))) || p_50) > p_50) | p_50));
                    for (l_582.f1 = (-24); (l_582.f1 != (-15)); l_582.f1 += 1)
                    { /* block id: 248 */
                        struct S0 l_604 = {5L,-1L,4UL,0xB4B4B19AL,0x3AF5L,1L,4294967295UL,-1L,-1L};
                        l_605 = func_98(l_604, p_50);
                        l_583.f0 = (l_601.f1 == (-2L));
                        l_71 = func_51(__builtin_ffsll(l_581), (((((0xE024L == p_50) <= func_72(func_35(l_601.f8, p_50, l_583, l_606), l_580, l_585, p_50)) && p_50) ^ p_50) != p_50));
                    }
                    for (l_606.f6 = (-25); (l_606.f6 == 20); ++l_606.f6)
                    { /* block id: 255 */
                        struct S1 l_609 = {9,339,-0};
                        l_580 = l_609;
                    }
                    if (p_50)
                    { /* block id: 258 */
                        int16_t l_617 = 0xE7EAL;
                        struct S1 l_619 = {1,731,0};
                        l_584.f2 = __builtin_popcountll(l_485);
                        l_601.f0 = ((~((((uint16_t)((int16_t)l_617 % (int16_t)l_585.f2) << (uint16_t)l_601.f2) == (l_617 >= (func_91((l_618 && p_50), l_583, l_606.f4, l_619, l_619) && 0x4B60643AL))) & p_50)) | p_50);
                        l_619 = l_71;
                    }
                    else
                    { /* block id: 262 */
                        return p_50;
                    }
                }
                l_476 = ((1L < (p_50 && ((l_585.f4 == ((l_465 != ((-3L) > (p_50 && p_50))) && ((int32_t)((uint16_t)((((int16_t)((uint16_t)p_50 << (uint16_t)l_477) + (int16_t)l_517.f1) || l_583.f6) | 4UL) % (uint16_t)l_583.f0) + (int32_t)l_585.f0))) ^ 0x17B0L))) && p_50);
            }
            if ((l_630 | ((0xB406AF33L & l_462) != ((int16_t)(((uint32_t)l_583.f5 + (uint32_t)(-5L)) != ((uint16_t)(((uint16_t)(l_463 & (func_91(l_605.f1, l_516, p_50, l_517, l_580) || 0xCA4C91CAL)) >> (uint16_t)l_639) & l_640) + (uint16_t)l_516.f5)) + (int16_t)l_641))))
            { /* block id: 268 */
                uint16_t l_642 = 0x69E5L;
                l_458 = 0xF043AAD7L;
                l_642 = (func_72(l_605, l_580, l_516, l_583.f4) >= p_50);
                l_585.f5 = l_642;
                for (l_583.f7 = 6; (l_583.f7 < 20); l_583.f7++)
                { /* block id: 274 */
                    if (p_50)
                        break;
                }
            }
            else
            { /* block id: 277 */
                if (l_630)
                    goto lbl_645;
            }
        }
        else
        { /* block id: 280 */
            l_477 &= (0xE8B9C6FFL < (l_456.f3 && p_50));
        }
    }
    else
    { /* block id: 283 */
        int32_t l_646 = 0xAB172BB9L;
        int32_t l_657 = 0x8A56B187L;
        l_646 = p_50;
        l_657 = (l_646 || (l_456.f6 != ((uint16_t)((uint16_t)(((uint16_t)p_50 + (uint16_t)((uint16_t)l_646 + (uint16_t)l_476)) != 0xC391F126L) + (uint16_t)((l_456.f3 < (p_50 <= p_50)) >= l_646)) << (uint16_t)8)));
        l_466 |= (l_458 & ((uint16_t)0UL + (uint16_t)0x18DEL));
        l_71.f2 = ((~((((l_456.f1 || (((uint16_t)((uint16_t)((uint16_t)(1L >= ((int16_t)(-1L) + (int16_t)((l_532 > l_646) & ((uint32_t)l_657 - (uint32_t)((((int16_t)(((l_477 >= p_50) && 1UL) >= l_657) >> (int16_t)11) || l_563) <= p_50))))) << (uint16_t)p_50) >> (uint16_t)p_50) % (uint16_t)l_657) > l_646)) < p_50) && p_50) || 0x7CFC046BL)) | p_50);
    }
    return l_456.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_51(int32_t  p_52, uint8_t  p_53)
{ /* block id: 46 */
    int32_t l_68 = 5L;
    int32_t l_69 = 0L;
    struct S1 l_70 = {3,496,-1};
    l_69 ^= l_68;
    return l_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_72(struct S1  p_73, struct S1  p_74, const struct S0  p_75, int32_t  p_76)
{ /* block id: 193 */
    p_76 |= p_75.f3;
    return p_73.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_82(uint32_t  p_83)
{ /* block id: 50 */
    int32_t l_90 = 0x22D3B6D3L;
    struct S0 l_97 = {0x830F2B0EL,0x447E3892L,0UL,0xE15C8DD5L,0UL,-5L,4294967295UL,0xCE0BB6B9L,0L};
    struct S1 l_150 = {0,336,1};
    uint8_t l_180 = 0x50L;
    int32_t l_192 = 0x778D2D4EL;
    int32_t l_193 = 0x9F1FBD92L;
    int32_t l_194 = (-1L);
    int32_t l_195 = (-1L);
    int32_t l_196 = (-10L);
    int32_t l_197 = (-1L);
    int32_t l_198 = 0xB1AD61C5L;
    int32_t l_199 = 0x6B0373C0L;
    int32_t l_200 = 0x503C8821L;
    int32_t l_201 = 0x5D252147L;
    int32_t l_202 = 8L;
    int32_t l_203 = 0x572D6567L;
    int32_t l_204 = 0x83BE1114L;
    int32_t l_205 = 0L;
    int32_t l_206 = 0x8F17BB5DL;
    int32_t l_207 = 1L;
    int32_t l_208 = 0xF9FD15FEL;
    int32_t l_209 = 1L;
    int32_t l_210 = 9L;
    int32_t l_211 = 0x6A79BAE4L;
    int32_t l_212 = 0L;
    int32_t l_213 = 0x07284809L;
    int32_t l_214 = (-1L);
    int32_t l_215 = 1L;
    int32_t l_216 = (-1L);
    int32_t l_217 = 1L;
    int32_t l_218 = 7L;
    int32_t l_219 = (-7L);
    int32_t l_220 = 0xF9FA3D02L;
    int32_t l_221 = 1L;
    int32_t l_222 = 6L;
    int32_t l_223 = 0x04968785L;
    int32_t l_224 = (-5L);
    int32_t l_225 = 0L;
    int32_t l_226 = 1L;
    int32_t l_227 = 0xBB95996FL;
    int32_t l_228 = 1L;
    int32_t l_229 = 0xC7FA8C35L;
    int32_t l_230 = 0L;
    int32_t l_231 = 0x6B02753BL;
    int32_t l_232 = 0x28C0AEB2L;
    int32_t l_233 = 0L;
    int32_t l_234 = 0xE2A85B44L;
    int32_t l_235 = 0x53FAB730L;
    int32_t l_236 = 0x4EF10369L;
    int32_t l_237 = 0xA5B27021L;
    int32_t l_238 = 0xFD89EE91L;
    int32_t l_239 = 0L;
    int32_t l_240 = (-1L);
    int32_t l_241 = 0xBBCF4FF7L;
    int32_t l_242 = 0x9197F5A8L;
    int32_t l_243 = 0L;
    int32_t l_244 = 0x71CF8787L;
    int32_t l_245 = 0x0FF72CBDL;
    int32_t l_246 = 0x33FF7387L;
    int32_t l_247 = 3L;
    int32_t l_248 = 0x71F14954L;
    int32_t l_249 = (-6L);
    int32_t l_250 = 9L;
    int32_t l_251 = 0x7616D273L;
    int32_t l_252 = (-10L);
    int32_t l_253 = (-6L);
    int32_t l_254 = 0L;
    int32_t l_255 = (-7L);
    int32_t l_256 = 0x65CF4BAEL;
    int32_t l_257 = 0xCAA7A5E9L;
    int32_t l_258 = 0xFCF56D30L;
    int32_t l_259 = 1L;
    int32_t l_260 = 0x17AF234CL;
    int32_t l_261 = 0x25E49070L;
    int32_t l_262 = (-2L);
    int32_t l_263 = (-8L);
    int32_t l_264 = 1L;
    int32_t l_265 = 3L;
    int32_t l_266 = 9L;
    int32_t l_267 = 0x1EEABF48L;
    int32_t l_268 = 0x47C19EDDL;
    int32_t l_269 = (-1L);
    int32_t l_270 = 1L;
    int32_t l_271 = 1L;
    int32_t l_272 = 0xB943A5B3L;
    int32_t l_273 = 2L;
    int32_t l_274 = 0xF3A56081L;
    int32_t l_275 = 0x4A49A00BL;
    int32_t l_276 = 0L;
    int32_t l_277 = 1L;
    int32_t l_278 = (-9L);
    int32_t l_279 = (-2L);
    int32_t l_280 = 0x3DDF1352L;
    int32_t l_281 = 1L;
    int32_t l_282 = 0x59303987L;
    int32_t l_283 = 1L;
    int32_t l_284 = (-8L);
    int32_t l_285 = 0x7D65CAE7L;
    int32_t l_286 = 0x1E03DBD9L;
    int32_t l_287 = 5L;
    int32_t l_288 = 1L;
    int32_t l_289 = 0x13274FA1L;
    int32_t l_290 = 0xAAC5D9CEL;
    int32_t l_291 = 0L;
    int32_t l_292 = 0xB33238ADL;
    int32_t l_293 = (-1L);
    int32_t l_294 = (-1L);
    int32_t l_295 = 0x7393B26DL;
    int32_t l_296 = (-8L);
    int32_t l_297 = 0x54AC34ECL;
    int32_t l_298 = 0L;
    int32_t l_299 = (-4L);
    int32_t l_300 = 0x824B9CF8L;
    int32_t l_301 = 0xB7912393L;
    int32_t l_302 = 0L;
    int32_t l_303 = 0x711BF31FL;
    int32_t l_304 = 0x2E7577DDL;
    int32_t l_305 = 0x9F28A0E0L;
    int32_t l_306 = (-1L);
    int32_t l_307 = 0L;
    int32_t l_308 = 1L;
    int32_t l_309 = 0x8D94FF48L;
    int32_t l_310 = (-1L);
    int32_t l_311 = 0xFE6702E0L;
    int32_t l_312 = 4L;
    int32_t l_313 = 5L;
    int32_t l_314 = 0x0EF8E2C7L;
    int32_t l_315 = 1L;
    uint32_t l_316 = 0x0CB2AB0AL;
    struct S0 l_436 = {0x8FDA9C6AL,0L,0xA8FABBD0L,1UL,0x9F26L,-2L,4294967295UL,0L,0xF1D6L};
    const uint32_t l_439 = 18446744073709551615UL;
    l_180 = ((int16_t)p_83 % (int16_t)(((int16_t)((int32_t)(p_83 > l_90) + (int32_t)(__builtin_popcount(func_91(l_90, l_97, p_83, func_98(l_97, l_97.f6), l_150)) > l_97.f8)) << (int16_t)3) ^ 0xCF5AA1C8L));
    for (l_90 = 0; (l_90 > 12); l_90 += 3)
    { /* block id: 87 */
        const uint8_t l_183 = 255UL;
        int32_t l_184 = 4L;
        if ((l_183 == 3L))
        { /* block id: 88 */
            l_184 = l_183;
        }
        else
        { /* block id: 90 */
            int16_t l_187 = 0xA5E3L;
            struct S1 l_190 = {5,918,-1};
            l_190 = func_98(l_97, ((int16_t)(l_187 >= p_83) >> (int16_t)((-(uint16_t)(~0UL)) || p_83)));
            l_184 = 0xBE574E03L;
        }
        l_97.f5 = (-(int32_t)p_83);
        if (l_183)
            break;
    }
    l_316++;
    if (l_248)
    { /* block id: 98 */
        int16_t l_319 = 0L;
        struct S0 l_340 = {0x7623B56AL,0x92661E02L,0x6378B857L,0x39B39C02L,0x81B6L,-1L,4294967295UL,0x88EDFA16L,0x0D13L};
        struct S1 l_341 = {4,397,1};
        int16_t l_346 = 0xD8DDL;
        uint32_t l_394 = 0xF03B199EL;
        int16_t l_420 = 8L;
        if (p_83)
        { /* block id: 99 */
            int16_t l_327 = 0x052EL;
            struct S1 l_342 = {11,793,-1};
            struct S0 l_361 = {0L,0x8A842647L,18446744073709551614UL,0x4CA14331L,65535UL,0x1909923CL,1UL,0L,0xFA68L};
            int32_t l_417 = 0L;
lbl_407:
            if ((0xAD4EL > l_249))
            { /* block id: 100 */
                struct S1 l_322 = {9,970,1};
                uint8_t l_367 = 8UL;
                if ((__builtin_ctzl(l_319) < (~(-(uint32_t)p_83))))
                { /* block id: 101 */
                    struct S1 l_323 = {2,170,-0};
lbl_324:
                    l_242 = p_83;
                    l_323 = l_322;
                    if (l_97.f5)
                        goto lbl_324;
                }
                else
                { /* block id: 105 */
                    uint8_t l_332 = 254UL;
                    struct S0 l_343 = {-10L,5L,0xD344B94DL,0UL,0x0AF0L,0xE876B6C0L,0xD6E749ECL,0x4B766E8CL,0x0CBDL};
                    l_322.f2 = l_319;
                    for (l_230 = (-8); (l_230 >= (-9)); l_230 -= 1)
                    { /* block id: 109 */
                        int16_t l_339 = 1L;
                        uint16_t l_344 = 0xA956L;
                        struct S0 l_345 = {1L,1L,18446744073709551606UL,0x955634FAL,5UL,0L,0UL,0L,-2L};
                        l_343.f5 = ((l_327 ^ (((((((uint16_t)func_91(((uint16_t)(l_306 >= ((((-1L) != l_332) >= ((int16_t)func_103(((uint16_t)(5L >= func_103((((int16_t)(((func_91(l_339, l_340, (p_83 && p_83), l_341, l_342) & p_83) && 0UL) <= l_340.f8) << (int16_t)l_332) && p_83), l_339, p_83, l_343)) >> (uint16_t)3), p_83, l_344, l_345) << (int16_t)p_83)) && p_83)) << (uint16_t)11), l_97, p_83, l_341, l_342) - (uint16_t)0x9534L) < 0UL) > 0UL) || l_346) & l_340.f6) && 4294967295UL)) == 0x29F0L);
                        l_150 = func_101(p_83);
                        l_322.f2 = 0x848CC07BL;
                        if (p_83)
                            break;
                    }
                    for (l_281 = (-23); (l_281 >= (-13)); ++l_281)
                    { /* block id: 117 */
                        int32_t l_362 = (-2L);
                        int32_t l_363 = 6L;
                        l_342.f2 ^= l_342.f1;
                        l_272 = (4294967295UL != ((uint16_t)(((__builtin_bswap64(l_343.f7) | (l_327 > ((int16_t)(~func_103(((l_278 && (-(uint32_t)(p_83 == ((uint16_t)__builtin_parityl(p_83) << (uint16_t)((uint16_t)((uint16_t)(p_83 || l_97.f5) << (uint16_t)l_343.f6) % (uint16_t)l_343.f3))))) == 0x83FAL), l_261, l_340.f2, l_361)) - (int16_t)p_83))) < 1UL) || l_319) - (uint16_t)p_83));
                        l_363 ^= l_362;
                    }
                    for (l_361.f6 = (-17); (l_361.f6 > 30); ++l_361.f6)
                    { /* block id: 124 */
                        struct S1 l_366 = {11,712,1};
                        l_366 = l_366;
                        if (l_367)
                            break;
                        l_289 = (((uint32_t)l_340.f0 - (uint32_t)((((p_83 >= l_340.f7) != ((p_83 != ((int16_t)((p_83 > ((uint16_t)l_291 << (uint16_t)7)) < ((int16_t)p_83 + (int16_t)((((+p_83) ^ l_367) > l_340.f5) <= (-1L)))) + (int16_t)l_343.f3)) & l_319)) || l_346) ^ 0xCF44L)) | 0x1602L);
                    }
                }
                if (p_83)
                { /* block id: 130 */
                    uint8_t l_377 = 1UL;
                    l_377++;
                    return l_361.f0;
                }
                else
                { /* block id: 133 */
                    struct S1 l_380 = {12,154,1};
                    uint16_t l_392 = 0UL;
                    int32_t l_393 = 0xBDD68C78L;
                    l_380 = l_341;
                    l_393 &= (((((int16_t)p_83 << (int16_t)l_341.f2) && 0xDF2B2ED5L) == (-(int16_t)l_341.f0)) < (l_150.f0 || ((int16_t)func_91((l_298 > ((int16_t)(((-1L) == l_340.f0) > ((((uint16_t)((uint16_t)l_392 % (uint16_t)3L) >> (uint16_t)14) && p_83) >= l_361.f7)) + (int16_t)p_83)), l_361, l_340.f6, l_341, l_380) % (int16_t)p_83)));
                    l_322.f2 ^= (p_83 & p_83);
                }
                l_322 = func_98(l_361, l_394);
                l_150 = func_51(l_97.f6, p_83);
            }
            else
            { /* block id: 140 */
                for (l_262 = (-26); (l_262 < (-26)); l_262 += 3)
                { /* block id: 143 */
                    if (l_258)
                        break;
                }
            }
            l_361.f0 ^= (((+func_91(((int16_t)(0x3B12C701L >= p_83) << (int16_t)4), l_97, l_340.f7, l_342, l_150)) == l_203) ^ 0x1485D5FDL);
            if (__builtin_ffsll(l_361.f2))
            { /* block id: 148 */
                uint32_t l_400 = 0xBEF1F7B1L;
                struct S1 l_405 = {11,455,1};
                --l_400;
                for (l_256 = (-13); (l_256 < 4); l_256 += 7)
                { /* block id: 152 */
                    struct S1 l_406 = {10,220,1};
                    l_406 = l_405;
                }
                if (p_83)
                { /* block id: 155 */
                    if (l_281)
                        goto lbl_407;
                }
                else
                { /* block id: 157 */
                    int32_t l_424 = 0x6925A8B7L;
                    l_264 ^= ((l_342.f0 ^ ((uint16_t)((((uint16_t)(p_83 >= ((uint16_t)((((uint32_t)((!p_83) > p_83) % (uint32_t)l_417) ^ ((uint32_t)(l_241 ^ l_420) - (uint32_t)l_319)) > ((uint16_t)((~0x7BD7L) == p_83) << (uint16_t)11)) << (uint16_t)1)) << (uint16_t)p_83) != l_424) <= 0UL) >> (uint16_t)l_424)) < l_424);
                    return l_424;
                }
            }
            else
            { /* block id: 161 */
                l_341.f2 &= l_341.f1;
            }
            for (l_311 = (-11); (l_311 == 13); ++l_311)
            { /* block id: 166 */
                uint32_t l_429 = 4294967290UL;
                struct S1 l_437 = {5,730,1};
                for (l_236 = (-2); (l_236 >= (-14)); l_236 -= 7)
                { /* block id: 169 */
                    uint32_t l_438 = 0UL;
                    if (l_340.f0)
                    { /* block id: 170 */
                        l_429++;
                        l_307 ^= l_341.f2;
                        if (p_83)
                            break;
                    }
                    else
                    { /* block id: 174 */
                        l_342.f2 = ((l_361.f2 > p_83) > ((int32_t)func_103(((int16_t)(((0x2BB5L | ((((func_91(p_83, l_436, p_83, l_437, l_341) | p_83) != p_83) | l_437.f0) & p_83)) | 9UL) > (-3L)) - (int16_t)p_83), p_83, l_438, l_361) + (int32_t)l_341.f2));
                        l_361.f0 ^= (0UL & l_346);
                        if (p_83)
                            continue;
                        l_340.f5 = (((l_439 && 6UL) ^ p_83) && (0xE8F5L || l_214));
                    }
                }
                if (p_83)
                    break;
                if (l_210)
                    break;
            }
        }
        else
        { /* block id: 184 */
            return p_83;
        }
        l_340.f5 |= ((l_272 != 0x95F4L) & __builtin_clzll((+((int16_t)(p_83 >= (((int16_t)p_83 << (int16_t)p_83) > (65528UL | (!((uint16_t)func_103(l_340.f7, p_83, l_340.f6, l_436) - (uint16_t)l_341.f0))))) >> (int16_t)l_341.f2))));
    }
    else
    { /* block id: 188 */
        uint32_t l_450 = 4294967287UL;
        struct S1 l_451 = {12,983,1};
        l_276 = (p_83 <= (((int16_t)(l_450 && p_83) << (int16_t)(0xF49FL == l_316)) == (-8L)));
        l_451 = l_150;
    }
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_91(int32_t  p_92, struct S0  p_93, uint32_t  p_94, struct S1  p_95, struct S1  p_96)
{ /* block id: 78 */
    int16_t l_161 = 1L;
    int32_t l_170 = 0x3535620BL;
    struct S0 l_179 = {0x5B60AC72L,7L,18446744073709551612UL,4294967293UL,65535UL,1L,4UL,0xB37FBF51L,0x6F7CL};
    l_170 = (((((((!(((uint16_t)(((-(uint32_t)((int16_t)((uint16_t)((uint32_t)(((l_161 >= (((uint16_t)((uint16_t)((p_95.f0 ^ (((p_95.f2 & 9L) != l_161) < ((((((uint16_t)(0L < ((uint16_t)l_161 >> (uint16_t)((-10L) == ((p_93.f4 | (-8L)) < p_95.f2)))) % (uint16_t)l_161) & p_96.f2) ^ l_161) | 0L) & 65534UL))) ^ 7UL) >> (uint16_t)10) - (uint16_t)l_161) == l_161)) == p_93.f3) | p_93.f8) % (uint32_t)l_161) >> (uint16_t)p_95.f0) << (int16_t)l_161)) | l_161) && l_161) + (uint16_t)p_93.f4) != 0UL)) == 0UL) | p_96.f0) | p_95.f2) != p_93.f7) ^ 4294967295UL) && p_95.f1);
    l_170 = (0x0D308A82L || __builtin_clzll(l_161));
    p_95.f2 = (((int16_t)((func_103(((int32_t)__builtin_parityl(p_96.f2) + (int32_t)l_161), p_95.f2, (((((0xA18CL < (0xD56FL || l_161)) > p_93.f8) != ((int32_t)(p_93.f4 & 0x74649171L) % (int32_t)4294967287UL)) == p_93.f7) >= p_93.f1), p_93) > p_96.f2) || p_93.f5) + (int16_t)p_93.f1) < p_93.f0);
    l_179.f0 = ((0UL != ((int32_t)(p_93.f6 <= p_95.f1) - (int32_t)func_103(l_161, (l_170 >= l_170), l_161, l_179))) || l_179.f2);
    return p_96.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_98(struct S0  p_99, uint32_t  p_100)
{ /* block id: 51 */
    const uint32_t l_113 = 0x660493B4L;
    struct S1 l_149 = {14,375,0};
    l_149 = func_101((func_103(p_99.f8, p_99.f5, (0x7CB0L | (!(((int16_t)p_100 << (int16_t)((int32_t)l_113 - (int32_t)((int16_t)p_99.f7 + (int16_t)(((int16_t)l_113 >> (int16_t)1) >= ((int16_t)__builtin_clzll(l_113) >> (int16_t)9))))) || 0L))), p_99) < 0L));
    l_149.f2 = (p_99.f5 & __builtin_parityll(l_149.f0));
    return l_149;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_101(const uint32_t  p_102)
{ /* block id: 56 */
    uint32_t l_123 = 4UL;
    const int16_t l_133 = 0xDEFFL;
    int32_t l_140 = 0x3772BF5FL;
    uint8_t l_145 = 0x2CL;
    struct S1 l_148 = {13,854,0};
    if ((__builtin_ctzl(p_102) == p_102))
    { /* block id: 57 */
        uint32_t l_129 = 0xF62E77A0L;
        struct S0 l_139 = {0x7B476EADL,1L,0x77962233L,4294967288UL,0x1F27L,0xF2F4379DL,4294967286UL,0xCE59AEBFL,0x9C85L};
        int32_t l_144 = 0x1C5061D6L;
        if (p_102)
        { /* block id: 58 */
            int16_t l_128 = 0L;
            l_129 |= ((((uint16_t)__builtin_bswap64(l_123) - (uint16_t)(p_102 >= ((((uint16_t)p_102 << (uint16_t)11) <= (((((uint16_t)0x7E42L % (uint16_t)__builtin_ctzl(p_102)) == (0x3380028DL | 0x465DC084L)) < l_128) < 0x2D45L)) || p_102))) < 0UL) >= 0xFC97D5E0L);
        }
        else
        { /* block id: 60 */
            int32_t l_130 = 0xC2BD310EL;
            struct S0 l_138 = {-7L,1L,0x8EE3FE42L,0x2ADE66CDL,0xB547L,0xDC28BEC3L,0x116CE8D7L,0xDEC899BCL,0xBBF8L};
            l_130 ^= l_123;
            l_130 = ((((uint32_t)0x268291DAL % (uint32_t)5UL) && (((p_102 > l_130) & l_133) >= (0xDD027D66L ^ 0x17AC5C07L))) & ((func_103((func_103((((int16_t)((uint16_t)(l_129 > l_123) >> (uint16_t)14) % (int16_t)l_129) != l_133), p_102, p_102, l_138) | p_102), p_102, p_102, l_139) != p_102) >= l_123));
        }
        l_140 = __builtin_clzl(l_139.f0);
        for (l_123 = 17; (l_123 <= 8); l_123 -= 8)
        { /* block id: 67 */
            struct S1 l_143 = {6,471,0};
            return l_143;
        }
        l_144 ^= ((p_102 != 0x607CF515L) || ((l_139.f0 && ((l_139.f5 || 0x36E3L) < 5UL)) <= 1UL));
    }
    else
    { /* block id: 71 */
        l_145++;
    }
    return l_148;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_103(uint32_t  p_104, int32_t  p_105, uint32_t  p_106, struct S0  p_107)
{ /* block id: 52 */
    struct S1 l_120 = {5,335,0};
    l_120 = l_120;
    p_107.f5 = (l_120.f1 > p_107.f5);
    return l_120.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 229
   depth: 1, occurrence: 47
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 28
breakdown:
   indirect level: 0, occurrence: 28
XXX full-bitfields structs in the program: 28
breakdown:
   indirect level: 0, occurrence: 28
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 19
XXX times a bitfields struct on RHS: 37
XXX times a single bitfield on LHS: 12
XXX times a single bitfield on RHS: 40

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 161
   depth: 2, occurrence: 31
   depth: 3, occurrence: 11
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 4
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 5
   depth: 23, occurrence: 3
   depth: 25, occurrence: 1
   depth: 35, occurrence: 1
   depth: 41, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 554
XXX times a non-volatile is write: 105
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 155
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 23
   depth: 2, occurrence: 18
   depth: 3, occurrence: 22
   depth: 4, occurrence: 30
   depth: 5, occurrence: 30

XXX percentage a fresh-made variable is used: 34.9
XXX percentage an existing variable is used: 65.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

