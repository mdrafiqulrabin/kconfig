/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      361463716
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int32_t  f0;
   unsigned f1 : 30;
   int16_t  f2;
   uint32_t  f3;
   int16_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U0  func_30(void);
static int32_t  func_47(uint32_t  p_48, int16_t  p_49, const int32_t * p_50);
static union U0 *** func_75(union U0 * p_76, union U0 ** p_77, union U0  p_78);
static union U0 * func_79(int32_t ** p_80, uint32_t  p_81, uint32_t  p_82, union U0 * p_83, const uint32_t  p_84);
static int32_t ** func_85(int32_t ** p_86, int16_t  p_87, union U0 *** p_88);
static int32_t  func_93(uint32_t  p_94, int16_t  p_95, union U0  p_96, union U0 ** p_97, uint32_t  p_98);
static uint16_t  func_99(int16_t  p_100, const uint32_t  p_101, int32_t  p_102, union U0 ** p_103, int32_t  p_104);
static uint32_t  func_120(const uint32_t  p_121, union U0  p_122, union U0 * p_123, uint32_t  p_124);
static int32_t * func_132(union U0  p_133, uint32_t  p_134, const union U0  p_135);
static const union U0  func_136(const union U0 * p_137, union U0 * p_138, uint16_t  p_139);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_30(void)
{ /* block id: 36 */
    int16_t l_31 = 0xDE09;
    int32_t l_32 = 1;
    int32_t l_71 = 0x3312A7FA;
    union U0 l_72 = {0x8D402A53};
    uint32_t l_190 = 0x5E08C8AB;
    int32_t *l_779 = &l_32;
    int32_t **l_778 = &l_779;
    int32_t ***l_777 = &l_778;
    int32_t ****l_776 = &l_777;
    int32_t *****l_775 = &l_776;
    union U0 *l_797 = &l_72;
    union U0 **l_796 = &l_797;
    union U0 ***l_795 = &l_796;
    union U0 ****l_794 = &l_795;
    uint16_t l_883 = 65530U;
    int32_t *****l_926 = &l_776;
    union U0 *****l_928 = &l_794;
    int32_t l_985 = 0x0851C487;
    const int32_t *l_1011 = &l_32;
    uint32_t l_1045 = 0xD63E929F;
    uint32_t l_1046 = 0x5808C823;
    union U0 l_1047 = {0xCB5580FC};
    l_32 = l_31;
    for (l_31 = 0; (l_31 != 2); l_31 = safe_add_func_uint32_t_u_u(l_31, 1))
    { /* block id: 40 */
        int32_t l_42 = 1;
        int32_t *l_58 = &l_32;
        union U0 *l_117 = &l_72;
        union U0 **l_116 = &l_117;
        union U0 ***l_115 = &l_116;
        int32_t l_323 = 5;
        union U0 **l_774 = &l_117;
        int32_t *****l_805 = &l_776;
        int32_t l_814 = 1;
        uint16_t l_893 = 6U;
        uint32_t l_934 = 1U;
        uint16_t l_945 = 0xB2A6;
        int16_t l_981 = 2;
        int32_t l_992 = 0xDA25A450;
        int32_t l_1037 = 0x1D7D2A58;
        int32_t l_1038 = 0xD1604ACE;
        uint16_t l_1040 = 65528U;
        for (l_32 = (-11); (l_32 >= (-17)); l_32 = safe_sub_func_uint16_t_u_u(l_32, 1))
        { /* block id: 43 */
            int32_t l_37 = 0;
            for (l_37 = 0; (l_37 <= 3); ++l_37)
            { /* block id: 46 */
                int32_t l_41 = (-1);
                int32_t *l_40 = &l_41;
                (*l_40) = 0xE3CB5AF9;
            }
        }
    }
    (*****l_926) = (((safe_add_func_int32_t_s_s((func_93((*l_779), (safe_sub_func_int32_t_s_s((*****l_775), ((void*)0 != (*l_928)))), (*****l_928), (***l_928), (func_136((***l_794), (**l_795), (****l_776)) , l_1045)) || (**l_778)), l_1046)) >= (*****l_926)) && (****l_776));
    return l_1047;
    /* statement id: 548 */
    }


/* ------------------------------------------ */
/* 
 * reads : l_32
 * writes:
 */
static int32_t  func_47(uint32_t  p_48, int16_t  p_49, const int32_t * p_50)
{ /* block id: 57 */
    union U0 l_64 = {1};
    union U0 *l_63 = &l_64;
    int32_t *l_68 = (void*)0;
    int32_t **l_69 = &l_68;
    for (p_48 = 0; (p_48 != 16); p_48 = safe_add_func_uint16_t_u_u(p_48, 8))
    { /* block id: 60 */
        union U0 **l_65 = (void*)0;
        union U0 l_67 = {0x32987C83};
        union U0 *l_66 = &l_67;
        l_66 = l_63;
        /* statement id: 61 */
        assert (l_66 == &l_64);
    }
    (*l_69) = l_68;
    return (*p_50);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 *** func_75(union U0 * p_76, union U0 ** p_77, union U0  p_78)
{ /* block id: 402 */
    int32_t l_755 = (-4);
    int32_t l_758 = (-9);
    int32_t *l_760 = &l_755;
    union U0 l_764 = {7};
    union U0 *l_763 = &l_764;
    union U0 **l_762 = &l_763;
    union U0 ***l_761 = &l_762;
    union U0 ***l_765 = (void*)0;
    l_758 = ((((func_136((l_755 , (*p_77)), (*p_77), __builtin_parityl(l_755)) , 2U) < (safe_add_func_uint16_t_u_u(p_78.f2, l_755))) , l_755) ^ l_755);
    (*l_760) = (~p_78.f4);
    return l_765;
    /* statement id: 405 */
    //assert (func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_79(int32_t ** p_80, uint32_t  p_81, uint32_t  p_82, union U0 * p_83, const uint32_t  p_84)
{ /* block id: 322 */
    uint16_t l_606 = 0x9598;
    uint16_t l_612 = 0U;
    union U0 ****l_614 = (void*)0;
    union U0 *****l_613 = &l_614;
    uint16_t l_615 = 0x7D7F;
    int32_t l_616 = (-1);
    int32_t *l_691 = &l_616;
    int32_t **l_690 = &l_691;
    int32_t ***l_689 = &l_690;
    int32_t ****l_688 = &l_689;
    int32_t *****l_687 = &l_688;
    int32_t l_693 = 0x8978E613;
    const union U0 *l_714 = (void*)0;
    const union U0 l_728 = {-9};
    (**p_80) = (func_47((safe_add_func_int32_t_s_s((p_81 | ((l_606 & l_606) , 1U)), (l_606 <= (!(safe_mul_func_uint16_t_u_u(0x0DAF, ((safe_lshift_func_uint16_t_u_u(l_612, 14)) , (l_613 == &l_614)))))))), l_615, (*p_80)) >= (**p_80));
    l_616 = 0xD4AC71C8;
    for (l_615 = (-30); (l_615 == 1); ++l_615)
    { /* block id: 327 */
        int16_t l_619 = 0xF55A;
        int32_t ***l_639 = (void*)0;
        int16_t l_654 = 0x36B8;
        union U0 *****l_680 = &l_614;
        union U0 *****l_685 = &l_614;
        union U0 **l_706 = (void*)0;
        union U0 ***l_705 = &l_706;
        (**p_80) = ((0x0E91BA44 != l_619) , l_619);
        for (p_81 = 20; (p_81 < 39); p_81 = safe_add_func_uint32_t_u_u(p_81, 5))
        { /* block id: 331 */
            union U0 l_625 = {-1};
            union U0 *l_624 = &l_625;
            int32_t l_655 = 0xAAF3694C;
            int16_t l_657 = (-1);
            int32_t *l_660 = &l_655;
            union U0 *****l_675 = (void*)0;
            union U0 ***l_707 = (void*)0;
            uint32_t l_719 = 0x1E5830D6;
        }
        for (l_619 = 0; (l_619 < (-22)); l_619 = safe_sub_func_uint32_t_u_u(l_619, 9))
        { /* block id: 379 */
            int16_t l_726 = 0x9FC4;
            union U0 l_727 = {-9};
        }
    }
    if ((**p_80))
    { /* block id: 386 */
        int32_t ****l_738 = &l_689;
        const union U0 *l_749 = &l_728;
        for (l_615 = 3; (l_615 == 54); l_615 = safe_add_func_uint32_t_u_u(l_615, 1))
        { /* block id: 389 */
            int32_t *l_731 = &l_616;
            (**l_690) = (*****l_687);
            (*p_80) = l_731;
            /* statement id: 391 */
            //assert (l_58 == &l_616);
        }
        /* facts after for loop */
        //assert (l_58 == &l_616 || l_58 == &l_32);
        (**p_80) = (safe_add_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_s(((**p_80) || (((__builtin_ia32_crc32qi(((safe_mul_func_uint16_t_u_u(p_82, ((*l_687) == ((*p_83) , l_738)))) >= (safe_sub_func_uint16_t_u_u((safe_mul_func_int16_t_s_s((safe_mod_func_int32_t_s_s(((safe_mul_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((func_136(l_749, p_83, (safe_rshift_func_uint16_t_u_s((((****l_738) >= ((safe_rshift_func_uint16_t_u_u(((****l_738) ^ (***l_689)), p_81)) && (**p_80))) < (**p_80)), (****l_738)))) , 0x6221), p_84)), p_82)) | (**p_80)), 0x2886E475)), p_81)), p_82))), (**l_690)) >= (**p_80)) != (****l_738)) ^ p_84)), 10)) <= (**p_80)), 65526U));
        (****l_688) = (**p_80);
    }
    else
    { /* block id: 395 */
        const union U0 **l_754 = &l_714;
        (***l_689) = (p_81 & (*l_691));
        (**l_689) = (*p_80);
        /* statement id: 397 */
        //assert (l_691 == &l_32);
        (*l_754) = (void*)0;
        (**l_689) = (***l_688);
    }
    /* facts after branching */
    //assert (l_58 == &l_616 || l_58 == &l_32);
    //assert (l_691 == &l_32 || l_691 == &l_616);
    return p_83;
    /* statement id: 401 */
    //assert (l_58 == dangling || l_58 == &l_32);
    //assert (func_79_rv == &l_72);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_85(int32_t ** p_86, int16_t  p_87, union U0 *** p_88)
{ /* block id: 182 */
    int32_t l_326 = 0x91F7841C;
    union U0 l_330 = {0x8369C0D2};
    const union U0 *l_329 = &l_330;
    union U0 *l_334 = (void*)0;
    union U0 **l_333 = &l_334;
    union U0 ***l_332 = &l_333;
    union U0 ****l_331 = &l_332;
    int32_t l_337 = 1;
    int32_t *l_343 = &l_326;
    int32_t **l_342 = &l_343;
    int32_t l_354 = 6;
    int32_t l_390 = 0x00601462;
    int32_t ****l_429 = (void*)0;
    uint32_t l_500 = 4294967290U;
    int16_t l_537 = 0xFB80;
    int32_t l_545 = (-1);
    (*l_331) = (func_136((((p_88 != p_88) , ((l_326 , l_326) , (l_326 == (safe_rshift_func_uint16_t_u_s(0xD62F, (__builtin_ctz(l_326) <= ((***p_88) , p_87))))))) , l_329), &l_330, p_87) , (void*)0);
    /* statement id: 183 */
    assert (l_332 == 0);
    (*p_86) = (*p_86);
    if ((safe_lshift_func_int16_t_s_s((((((p_87 , (*p_88)) != (*p_88)) && l_337) ^ l_330.f0) <= ((*p_88) != ((__builtin_popcountll((safe_sub_func_int16_t_s_s(l_330.f0, ((safe_rshift_func_uint16_t_u_u(p_87, 13)) | (p_87 > l_330.f2))))) & 0x1884) , (*p_88)))), 8)))
    { /* block id: 185 */
        uint32_t l_344 = 0x340A2A62;
        union U0 *l_355 = &l_330;
        int32_t l_370 = 0x34E5B996;
        union U0 *l_374 = &l_330;
        int32_t l_503 = 9;
        union U0 l_504 = {0x4C725113};
        union U0 *****l_519 = &l_331;
        int32_t **l_522 = &l_343;
        if (((l_342 != &l_343) > ((l_344 , ((5U <= (*l_343)) && (((safe_sub_func_int32_t_s_s((~(safe_mod_func_uint32_t_u_u((safe_mod_func_uint16_t_u_u(((*l_343) , __builtin_popcountll(((l_344 , (void*)0) == (void*)0))), p_87)), l_354))), (*l_343))) , l_355) != (void*)0))) < l_344)))
        { /* block id: 186 */
            union U0 ****l_356 = &l_332;
            int32_t l_357 = 7;
            (*l_342) = ((l_356 != (((l_357 || __builtin_popcount(p_87)) > ((l_357 , ((l_357 <= __builtin_clzll(l_357)) && (func_120(l_344, (*l_355), (**p_88), l_344) > (-10)))) | l_344)) , &p_88)) , (*l_342));
            (*l_343) = ((**l_342) || ((safe_add_func_uint32_t_u_u(p_87, 0x417FA21A)) , (safe_mul_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(l_344, 15)), ((safe_mod_func_int16_t_s_s(((safe_rshift_func_int16_t_s_u(l_344, 1)) >= (safe_mul_func_uint16_t_u_u(65532U, p_87))), ((p_87 , ((((**p_86) && (-1)) | l_357) < l_370)) , p_87))) | p_87)))));
        }
        else
        { /* block id: 189 */
            int32_t *l_371 = &l_370;
            (*l_342) = l_371;
            /* statement id: 190 */
            assert (l_343 == &l_370);
        }
        /* facts after branching */
        assert (l_343 == &l_370 || l_343 == &l_326);
        for (l_330.f3 = 0; (l_330.f3 != 6); l_330.f3 = safe_add_func_int16_t_s_s(l_330.f3, 1))
        { /* block id: 194 */
            int16_t l_388 = 1;
            union U0 *l_392 = &l_330;
            union U0 ****l_409 = &l_332;
            int32_t ***l_420 = &l_342;
            const union U0 l_521 = {0x4EC54B45};
            (*l_342) = (void*)0;
            /* statement id: 195 */
            assert (l_343 == 0);
        }
        /* facts after for loop */
                assert (l_343 == 0 || l_343 == &l_370 || l_343 == &l_326);
        if ((p_87 & ((safe_add_func_uint32_t_u_u(p_87, (safe_sub_func_int32_t_s_s((**p_86), (**p_86))))) , ((safe_rshift_func_int16_t_s_s(((((***p_88) , (safe_unary_minus_func_uint32_t_u((safe_unary_minus_func_uint32_t_u(__builtin_parityl(p_87)))))) || p_87) , func_93(((void*)0 != (*l_519)), p_87, (***p_88), (*p_88), p_87)), 10)) >= p_87))))
        { /* block id: 302 */
            (**p_86) = (&l_331 != &l_331);
            return p_86;
            /* statement id: 304 */
            //assert (func_85_rv == &l_58);
        }
        else
        { /* block id: 305 */
            uint32_t l_577 = 4294967295U;
            (**p_86) = l_577;
        }
        for (l_390 = 13; (l_390 >= 0); l_390 = safe_sub_func_uint32_t_u_u(l_390, 1))
        { /* block id: 310 */
            if ((safe_add_func_uint32_t_u_u(((safe_mod_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(p_87, (~(p_87 >= ((safe_rshift_func_int16_t_s_u((safe_add_func_uint16_t_u_u(__builtin_parityl((0x070472C2 == (safe_mul_func_int16_t_s_s(l_504.f4, __builtin_parityll(p_87))))), (__builtin_parityl(p_87) , p_87))), 10)) , p_87))))), p_87)) >= 8U), 0x8739926E)))
            { /* block id: 311 */
                uint32_t l_593 = 0x04B57859;
                if ((**p_86))
                    break;
                if (l_593)
                    break;
            }
            else
            { /* block id: 314 */
                const union U0 *l_594 = &l_330;
                int32_t l_602 = 0x2B99C833;
                (**p_86) = (((func_120(__builtin_popcountl(l_504.f4), func_136(l_594, (**p_88), (safe_add_func_uint16_t_u_u((((p_87 == (!(safe_mul_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((-1), l_602)), (p_87 < p_87))))) & 65531U) == p_87), p_87))), (**p_88), p_87) , p_87) & (**p_86)) <= 0);
            }
        }
    }
    else
    { /* block id: 318 */
        union U0 *****l_603 = &l_331;
        (*l_603) = &l_332;
    }
    /* facts after branching */
        //assert (l_343 == 0 || l_343 == dangling || l_343 == &l_326);
    return p_86;
    /* statement id: 321 */
    //assert (func_85_rv == &l_58);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_93(uint32_t  p_94, int16_t  p_95, union U0  p_96, union U0 ** p_97, uint32_t  p_98)
{ /* block id: 177 */
    int32_t l_304 = 0x67E56959;
    int32_t *l_303 = &l_304;
    const int16_t l_319 = 0;
    union U0 l_322 = {0x1F2D7377};
    union U0 *l_321 = &l_322;
    union U0 **l_320 = &l_321;
    l_303 = l_303;
    (*l_303) = (safe_add_func_int16_t_s_s((((~p_96.f4) ^ func_99(((safe_rshift_func_int16_t_s_s(((*l_303) & __builtin_ffs((*l_303))), 10)) && (safe_sub_func_int32_t_s_s((*l_303), (safe_mod_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(0U, 5)) ^ (safe_rshift_func_int16_t_s_u((p_94 | (~(p_98 >= (((-4) > (*l_303)) | p_94)))), 11))), (*l_303)))))), l_319, p_98, l_320, p_95)) > 0xDABB3DD9), p_94));
    (*l_303) = __builtin_bswap64(p_95);
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_99(int16_t  p_100, const uint32_t  p_101, int32_t  p_102, union U0 ** p_103, int32_t  p_104)
{ /* block id: 100 */
    int32_t l_193 = 4;
    int32_t *l_192 = &l_193;
    int32_t **l_191 = &l_192;
    union U0 **l_206 = (void*)0;
    union U0 ***l_205 = &l_206;
    int16_t l_269 = 0;
    union U0 l_299 = {2};
    union U0 *l_298 = &l_299;
    (**l_191) = __builtin_clzll(((((void*)0 == l_191) <= (*l_192)) , ((**l_191) , ((p_100 || ((void*)0 != p_103)) , (((-6) | ((*l_192) , 0xEFFE)) != (**l_191))))));
    for (l_193 = (-17); (l_193 == 27); l_193 = safe_add_func_uint32_t_u_u(l_193, 3))
    { /* block id: 104 */
        uint32_t l_196 = 0x4420CCC2;
        union U0 l_211 = {0x050D3AC3};
        union U0 *l_210 = &l_211;
        union U0 **l_209 = &l_210;
    }
    return p_104;
}


/* ------------------------------------------ */
/* 
 * reads : l_72
 * writes:
 */
static uint32_t  func_120(const uint32_t  p_121, union U0  p_122, union U0 * p_123, uint32_t  p_124)
{ /* block id: 71 */
    uint32_t l_128 = 0x3F774032;
    union U0 *l_140 = (void*)0;
    union U0 **l_189 = &l_140;
    for (p_122.f2 = (-16); (p_122.f2 == 7); ++p_122.f2)
    { /* block id: 74 */
        int32_t l_130 = 0xD35930CB;
        int32_t *l_129 = &l_130;
        uint16_t l_131 = 7U;
        int32_t **l_188 = &l_129;
        (*l_129) = l_128;
        if (l_131)
            break;
        (*l_188) = func_132((*p_123), p_121, func_136(&p_122, l_140, l_128));
        /* statement id: 96 */
        assert (l_129 == 0);
        l_189 = l_189;
    }
    /* facts after for loop */
        return p_121;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_132(union U0  p_133, uint32_t  p_134, const union U0  p_135)
{ /* block id: 80 */
    int16_t l_150 = 0;
    int32_t **l_155 = (void*)0;
    union U0 *l_162 = (void*)0;
    uint32_t l_170 = 0U;
    int32_t l_173 = 0xDA9CD7CB;
    int32_t *l_172 = &l_173;
    uint32_t l_185 = 0x4ECE64C3;
    int32_t *l_186 = &l_173;
    int32_t *l_187 = (void*)0;
    for (p_133.f3 = 7; (p_133.f3 > 1); p_133.f3 = safe_sub_func_uint32_t_u_u(p_133.f3, 6))
    { /* block id: 83 */
        int32_t l_148 = 0x855A4044;
        int32_t *l_147 = &l_148;
        int32_t **l_149 = &l_147;
        union U0 l_154 = {7};
        union U0 *l_153 = &l_154;
        uint32_t l_171 = 0x98DEB230;
        (*l_149) = l_147;
        (*l_147) = ((p_135.f1 > (l_150 > (((safe_rshift_func_uint16_t_u_u((((l_153 != &l_154) < ((p_135.f0 , l_155) != l_155)) ^ p_135.f4), 11)) <= __builtin_ffsl((safe_mul_func_int16_t_s_s((((safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(func_47(__builtin_popcount((**l_149)), (*l_147), (*l_149)), p_133.f0)), (*l_147))) != (-9)) | p_135.f0), p_133.f1)))) || 9U))) > 0x89868D59);
        if (l_150)
        { /* block id: 86 */
            union U0 **l_163 = &l_162;
            (*l_163) = l_162;
        }
        else
        { /* block id: 88 */
            (*l_147) = p_134;
        }
        (**l_149) = (((p_133.f1 || (safe_mul_func_uint16_t_u_u((0x2902 == ((*l_147) < ((**l_149) && (7 != (safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(1, 2)), (((p_135.f1 != (l_170 < func_47((*l_147), (**l_149), (*l_149)))) != l_171) || (*l_147)))))))), p_133.f4))) == p_135.f2) >= p_133.f1);
    }
    /* facts after for loop */
        l_172 = l_172;
    (*l_172) = ((func_136(l_162, l_162, (*l_172)) , (safe_add_func_uint16_t_u_u((p_135.f3 < (((safe_mod_func_int32_t_s_s(p_135.f3, (safe_mul_func_int16_t_s_s(((((p_135.f4 >= ((safe_add_func_int32_t_s_s((((__builtin_ctzl((((*l_172) <= (!func_47(p_133.f4, p_135.f4, &l_173))) == l_185)) == p_133.f3) >= p_133.f1) & p_133.f0), (*l_172))) > (*l_172))) , p_135.f1) <= (*l_172)) > p_135.f0), p_133.f4)))) , &l_172) == &l_172)), 0x2100))) != p_134);
    return l_187;
    /* statement id: 95 */
    //assert (func_132_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const union U0  func_136(const union U0 * p_137, union U0 * p_138, uint16_t  p_139)
{ /* block id: 77 */
    int32_t l_142 = 1;
    int32_t *l_141 = &l_142;
    int32_t **l_143 = &l_141;
    const union U0 l_144 = {-4};
    (*l_143) = l_141;
    return l_144;
    /* statement id: 79 */
    }




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 301
XXX total union variables: 24

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 92
breakdown:
   indirect level: 0, occurrence: 24
   indirect level: 1, occurrence: 33
   indirect level: 2, occurrence: 10
   indirect level: 3, occurrence: 13
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 8
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 37
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 43
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 13

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 2
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 208

XXX times a variable address is taken: 193
XXX times a pointer is dereferenced on RHS: 412
breakdown:
   depth: 1, occurrence: 254
   depth: 2, occurrence: 88
   depth: 3, occurrence: 32
   depth: 4, occurrence: 16
   depth: 5, occurrence: 22
XXX times a pointer is dereferenced on LHS: 155
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 32
   depth: 3, occurrence: 8
   depth: 4, occurrence: 9
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 37
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 15
XXX times a pointer is qualified to be dereferenced: 1145

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 653
   level: 2, occurrence: 322
   level: 3, occurrence: 129
   level: 4, occurrence: 68
   level: 5, occurrence: 89
XXX number of pointers point to pointers: 106
XXX number of pointers point to scalars: 54
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.4
XXX average alias set size: 1.28

XXX times a non-volatile is read: 2011
XXX times a non-volatile is write: 466
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 76
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 25
   depth: 2, occurrence: 13
   depth: 3, occurrence: 4

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

