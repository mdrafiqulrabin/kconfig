/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3879375312
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
};

union U1 {
   float  f0;
};

union U2 {
   uint32_t  f0;
   volatile int32_t  f1;
   volatile uint16_t  f2;
   uint32_t  f3;
   volatile int16_t  f4;
};

union U3 {
   volatile float  f0;
   volatile unsigned f1 : 14;
   volatile uint8_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static uint8_t g_4 = 0xF2;
static float g_31 = 0x7.22BA7Bp+11;
static uint16_t g_34 = 1U;
static int32_t g_83 = (-2);
static float *g_93 = &g_31;
static int32_t *g_111 = &g_83;
static int32_t ** volatile g_110 = &g_111;/* VOLATILE GLOBAL g_110 */
static int32_t g_114 = (-7);
static int32_t ** volatile g_131 = &g_111;/* VOLATILE GLOBAL g_131 */
static union U1 g_137 = {0x1.5p-1};
static union U1 *g_139 = &g_137;
static union U1 ** volatile g_138 = &g_139;/* VOLATILE GLOBAL g_138 */
static union U0 g_155 = {0x1CF63C10};
static union U0 * volatile g_154 = &g_155;/* VOLATILE GLOBAL g_154 */
static union U0 * volatile * volatile g_157 = &g_154;/* VOLATILE GLOBAL g_157 */
static int32_t ** volatile g_162 = (void*)0;/* VOLATILE GLOBAL g_162 */
static int32_t ** volatile g_163 = &g_111;/* VOLATILE GLOBAL g_163 */
static int32_t **g_177 = &g_111;
static int32_t ***g_176 = &g_177;
static float g_223 = 0x1.2F62A8p+9;
static uint32_t g_242 = 0x625639F1;
static uint8_t g_363 = 0x0A;
static union U2 g_372 = {1U};/* VOLATILE GLOBAL g_372 */
static union U2 *g_371 = &g_372;
static union U2 ** volatile g_370 = &g_371;/* VOLATILE GLOBAL g_370 */
static int32_t ** volatile *g_422 = &g_131;
static int32_t ** volatile ** volatile g_421 = &g_422;/* VOLATILE GLOBAL g_421 */
static float ***g_425 = (void*)0;
static volatile union U3 g_433 = {-0x10.9p+1};/* VOLATILE GLOBAL g_433 */
static volatile union U3 * volatile g_432 = &g_433;/* VOLATILE GLOBAL g_432 */
static volatile union U3 * volatile * volatile g_434 = &g_432;/* VOLATILE GLOBAL g_434 */
static union U3 *g_446 = (void*)0;
static union U2 **g_465 = &g_371;
static union U2 ***g_464 = &g_465;
static union U2 **** volatile g_463 = &g_464;/* VOLATILE GLOBAL g_463 */
static union U1 * volatile *g_487 = &g_139;
static union U1 * volatile **g_486 = &g_487;
static union U1 * volatile ** volatile *g_485 = &g_486;
static int32_t * volatile g_509 = &g_83;/* VOLATILE GLOBAL g_509 */
static union U0 *g_534 = &g_155;
static union U0 **g_533 = &g_534;
static union U0 ***g_532 = &g_533;
static union U0 **** volatile g_531 = &g_532;/* VOLATILE GLOBAL g_531 */
static int32_t g_535 = (-6);
static float g_540 = 0x6.Fp-1;
static float *g_651 = &g_540;
static union U0 ****g_704 = &g_532;
static union U0 *****g_703 = &g_704;


/* --- FORWARD DECLARATIONS --- */
static union U1  func_27(void);
static uint16_t  func_38(union U1  p_39, float * p_40, int32_t  p_41, union U0  p_42, float * p_43);
static float * func_45(int32_t  p_46, float * p_47);
static uint16_t  func_52(union U1  p_53);
static union U1  func_54(uint32_t  p_55, uint32_t  p_56, float * p_57, uint16_t  p_58, int16_t  p_59);
static uint32_t  func_60(int16_t  p_61, union U1  p_62, int32_t  p_63);
static union U1  func_64(float * p_65, union U0  p_66, float * p_67);
static float * func_69(uint32_t  p_70, int32_t  p_71, float * p_72);
static int32_t  func_77(int32_t  p_78, float * p_79);
static int32_t * func_86(int32_t  p_87, union U1  p_88, uint16_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_372.f2 g_177 g_111 g_533 g_176 g_31 g_83 g_114 g_34 g_535 g_93 g_540 g_465 g_421 g_422 g_131 g_110 g_532 g_534 g_155 g_651 g_138 g_154 g_157 g_139 g_137 g_163 g_372.f0 g_242 g_372.f3 g_433.f1 g_487
 * writes: g_4 g_31 g_34 g_363 g_83 g_114 g_534 g_155.f0 g_371 g_111 g_139 g_540 g_154 g_703 g_223
 */
static union U1  func_27(void)
{ /* block id: 36 */
    int32_t l_33 = 0x29B85755;
    float *l_492 = &g_223;
    float *l_539 = &g_540;
    union U1 l_584 = {-0x1.0p-1};
    uint32_t l_592 = 0xD6C35AEC;
    union U0 ****l_702 = &g_532;
    union U0 *****l_701 = &l_702;
    for (g_4 = 0; (g_4 == 20); g_4 += 8)
    { /* block id: 39 */
        float *l_30 = &g_31;
        int32_t l_32 = 0x1C587C7A;
        union U0 l_68 = {-1};
        float *l_560 = &g_223;
        union U0 **l_561 = &g_534;
        int32_t l_622 = (-3);
        int16_t l_673 = (-1);
        union U1 l_674 = {-0x1.Bp-1};
        (*l_30) = g_4;
        if ((l_32 >= 0))
        { /* block id: 41 */
            union U1 l_35 = {0xD.1C77DCp+40};
            g_34 = (l_32 & l_33);
            return l_35;
            /* statement id: 43 */
            //assert (g_703 == dangling || g_703 == &g_704);
                    }
        else
        { /* block id: 44 */
            union U1 l_44 = {0xA.B9628Ep+32};
            float l_493 = 0x0.091B64p+49;
            int32_t l_494 = 0;
            union U0 ***l_573 = &g_533;
            int32_t ****l_580 = &g_176;
            int32_t *****l_579 = &l_580;
            int32_t *l_585 = &l_68.f0;
            uint8_t l_605 = 0x01;
            uint8_t l_650 = 0xB6;
            for (g_34 = 0; (g_34 >= 25); g_34 += 1)
            { /* block id: 47 */
                float *l_80 = &l_44.f0;
                int32_t l_538 = 0;
                union U0 ***l_553 = (void*)0;
                int32_t *****l_581 = &l_580;
            }
            for (g_363 = (-7); (g_363 >= 28); g_363 += 1)
            { /* block id: 330 */
                int32_t l_590 = 0x1F946E43;
                union U0 *l_591 = &g_155;
                (**g_177) = ((int16_t)l_590 % (int16_t)__builtin_ctzl(g_372.f2));
                (**l_573) = l_591;
                if (l_592)
                    break;
            }
            if ((*l_585))
            { /* block id: 335 */
                (*g_111) = (l_32 != ((int16_t)(((****l_580) >= (g_372.f2 <= g_34)) || 0x43CF) + (int16_t)g_535));
            }
            else
            { /* block id: 337 */
                uint8_t l_620 = 0x8F;
                uint32_t l_621 = 4294967289U;
                float *l_647 = (void*)0;
                (*l_30) = ((float)(0xA.061781p+73 == ((float)((float)(((float)((((float)l_605 / (float)(((float)(0x0.Cp+1 != ((float)((float)(****l_580) + (float)((float)(*g_93) + (float)((float)((0x5.4EEDCFp+69 <= ((func_77(((int32_t)l_592 / (int32_t)((int16_t)0 - (int16_t)(l_620 <= g_372.f2))), l_539) < l_68.f0) == (*g_93))) >= (*g_93)) + (float)l_68.f0))) - (float)0x2.C7FCC7p+43)) + (float)l_33) == l_621)) != (*g_93)) > (*g_93)) - (float)(*g_93)) > 0xB.E88D1Cp-57) / (float)l_622) / (float)l_68.f0)) / (float)l_592);
                for (l_605 = 0; (l_605 >= 24); l_605 += 9)
                { /* block id: 341 */
                    float l_637 = 0xA.10C952p+55;
                    int32_t l_638 = 0xF461358F;
                    union U1 l_642 = {0xB.137E70p+66};
                }
                for (g_155.f0 = 0; (g_155.f0 >= (-12)); g_155.f0--)
                { /* block id: 361 */
                    (*g_465) = (void*)0;
                    /* statement id: 362 */
                    assert (g_371 == 0);
                    for (g_363 = 0; (g_363 == 42); g_363 += 1)
                    { /* block id: 365 */
                        (***l_580) = (***g_421);
                        if ((*****l_579))
                            break;
                        return l_584;
                        /* statement id: 368 */
                        //assert (g_703 == dangling || g_703 == &g_704);
                                            }
                }
                (**g_176) = func_69((*****l_579), g_34, l_647);
                /* statement id: 371 */
                assert (g_111 == &g_31);
            }
            (*g_111) = ((uint16_t)l_650 << (uint16_t)g_535);
        }
        if (func_38(func_64(l_539, (***g_532), g_651), l_492, ((int16_t)((*g_176) != (void*)0) >> (int16_t)14), (*g_534), l_30))
        { /* block id: 375 */
            union U1 l_654 = {0x5.35950Ep+77};
            return l_654;
            /* statement id: 376 */
            //assert (g_703 == dangling || g_703 == &g_704);
                    }
        else
        { /* block id: 377 */
            float l_661 = 0x8.73D433p+96;
            int32_t l_662 = 8;
            (***g_422) = l_33;
            if (l_33)
                break;
            if ((g_372.f0 == (((uint16_t)__builtin_bswap64(l_32) + (uint16_t)((int32_t)__builtin_parity((l_622 < (65535U <= ((int32_t)(((l_662 > (((uint16_t)((int16_t)((uint16_t)((int32_t)(**g_110) / (int32_t)(((uint16_t)g_242 << (uint16_t)10) | ((((l_662 >= l_592) && (-8)) | l_673) != 0x3585880D))) >> (uint16_t)12) >> (int16_t)10) / (uint16_t)0x3029) == l_33)) >= (***g_176)) == 1U) % (int32_t)0xC2CF7A3F)))) + (int32_t)(-1))) | l_662)))
            { /* block id: 380 */
                (*l_30) = (0x8.DAC0E3p-14 <= (*g_651));
            }
            else
            { /* block id: 382 */
                uint8_t l_675 = 7U;
                l_675 = func_52(l_674);
            }
            if (((uint32_t)l_662 + (uint32_t)(l_68.f0 || ((int16_t)((uint32_t)((l_592 <= 5U) & (__builtin_ffsl(g_372.f3) && 1U)) % (uint32_t)((uint16_t)((uint16_t)1U >> (uint16_t)((int16_t)(l_32 != g_4) << (int16_t)11)) << (uint16_t)13)) - (int16_t)l_662))))
            { /* block id: 385 */
                uint32_t l_698 = 6U;
                (***g_176) = (0xED77D429 & (((uint32_t)((void*)0 != &l_539) - (uint32_t)((int16_t)__builtin_clz(g_433.f1) >> (int16_t)((int16_t)((***g_176) || (((int16_t)l_698 >> (int16_t)12) > g_83)) >> (int16_t)((uint16_t)g_372.f0 + (uint16_t)0xB8FE)))) && g_372.f0));
                g_703 = l_701;
                /* statement id: 387 */
                assert (g_703 == &l_702);
            }
            else
            { /* block id: 388 */
                float *l_705 = &g_223;
                (*g_177) = func_45(__builtin_clzl(l_662), l_705);
                /* statement id: 389 */
                assert (g_111 == &g_223);
                return (*g_139);
                /* statement id: 390 */
                //assert (g_703 == dangling || g_703 == &g_704);
                            }
            /* facts after branching */
            assert (g_703 == &l_702);
        }
        /* facts after branching */
        assert (g_703 == &l_702);
        if (l_592)
            break;
    }
    /* facts after for loop */
    assert (g_111 == &g_31 || g_111 == &g_83 || g_111 == &g_114);
    assert (g_371 == 0 || g_371 == &g_372);
    assert (g_703 == &l_702 || g_703 == &g_704);
    return (**g_487);
    /* statement id: 395 */
    //assert (g_703 == dangling || g_703 == &g_704);
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_38(union U1  p_39, float * p_40, int32_t  p_41, union U0  p_42, float * p_43)
{ /* block id: 300 */
    uint8_t l_548 = 250U;
    return l_548;
}


/* ------------------------------------------ */
/* 
 * reads : g_433.f1 g_111
 * writes: g_114 g_83 g_540 g_31 g_223
 */
static float * func_45(int32_t  p_46, float * p_47)
{ /* block id: 290 */
    union U2 ****l_546 = &g_464;
    union U2 *****l_545 = &l_546;
    (*g_111) = ((uint16_t)0xFD9D << (uint16_t)g_433.f1);
    for (p_46 = 21; (p_46 == (-20)); p_46 -= 3)
    { /* block id: 294 */
        union U2 *****l_547 = &l_546;
        (*g_111) = p_46;
        l_547 = l_545;
    }
    (*p_47) = 0x0.Fp+1;
    return p_47;
    /* statement id: 299 */
    //assert (func_45_rv == &g_540 || func_45_rv == &g_223);
}


/* ------------------------------------------ */
/* 
 * reads : g_535 g_372.f3 g_4 g_83 g_31 g_110 g_114 g_111 g_422 g_131
 * writes: g_114 g_83 g_31
 */
static uint16_t  func_52(union U1  p_53)
{ /* block id: 287 */
    int32_t l_536 = (-1);
    union U1 l_537 = {0xF.6CD7C1p-31};
    (***g_422) = ((__builtin_popcount(g_535) > (3U || (-1))) | __builtin_ffs(__builtin_ctzl(func_77(l_536, func_86((g_372.f3 != (l_536 ^ 0xD29F545C)), l_537, l_536)))));
    return l_536;
}


/* ------------------------------------------ */
/* 
 * reads : g_363 g_372.f0 g_433.f1 g_34 g_93 g_31 g_4 g_83 g_110 g_114 g_111 g_131 g_509 g_486 g_487 g_139 g_177 g_223 g_531 g_137
 * writes: g_83 g_114 g_111 g_372.f0 g_223 g_532
 */
static union U1  func_54(uint32_t  p_55, uint32_t  p_56, float * p_57, uint16_t  p_58, int16_t  p_59)
{ /* block id: 277 */
    int32_t ****l_495 = &g_176;
    int32_t l_506 = 0x41F59CED;
    uint16_t l_507 = 0x7039;
    float *l_508 = &g_223;
    union U1 *l_510 = (void*)0;
    union U3 **l_525 = &g_446;
    union U0 *l_530 = &g_155;
    union U0 **l_529 = &l_530;
    union U0 ***l_528 = &l_529;
    (*g_509) = (((((l_495 != l_495) >= (~(!1))) & (((int16_t)0x9F14 / (int16_t)func_77(g_363, func_69((((int16_t)((uint32_t)((int16_t)(p_56 != (g_372.f0 > 4294967287U)) + (int16_t)(g_433.f1 & g_372.f0)) % (uint32_t)l_506) - (int16_t)g_34) && p_58), l_507, l_508))) <= g_372.f0)) < g_4) || 2U);
    (**g_177) = (l_510 != (**g_486));
    for (g_372.f0 = 0; (g_372.f0 >= 10); g_372.f0 += 1)
    { /* block id: 282 */
        uint32_t l_526 = 1U;
        float *l_527 = (void*)0;
        (*l_508) = ((*p_57) == (((float)0x3.3D730Ep-97 + (float)(*g_93)) == ((float)((float)(*p_57) / (float)(*g_93)) / (float)(*p_57))));
    }
    (*g_531) = l_528;
    /* statement id: 285 */
    assert (g_532 == &l_529);
    return (***g_486);
    /* statement id: 286 */
    //assert (g_532 == dangling);
    }


/* ------------------------------------------ */
/* 
 * reads : g_137.f0 g_4 g_93 g_31 g_83 g_110 g_114 g_111 g_131 g_34 g_363 g_372.f1 g_485
 * writes: g_83 g_114 g_111 g_176 g_137.f0
 */
static uint32_t  func_60(int16_t  p_61, union U1  p_62, int32_t  p_63)
{ /* block id: 113 */
    float *l_166 = &g_137.f0;
    union U0 **l_171 = (void*)0;
    int16_t l_172 = 1;
    int32_t *l_173 = &g_114;
    int32_t ***l_190 = (void*)0;
    union U1 l_255 = {0x9.1A41AFp-58};
    int32_t **l_267 = &g_111;
    float ***l_283 = (void*)0;
    (*l_173) = ((!4) < (func_77(((-1) <= (-10)), l_166) != ((int32_t)((int32_t)func_77(g_4, func_69((1 > (l_171 == l_171)), l_172, l_166)) + (int32_t)(-8)) % (int32_t)0x5718CB29)));
    if (((void*)0 != l_173))
    { /* block id: 115 */
        int32_t **l_175 = &l_173;
        int32_t ***l_174 = &l_175;
        float l_195 = 0xB.9E523Dp-35;
        union U1 *l_199 = &g_137;
        int32_t l_252 = 0x7A056DCA;
        union U1 *l_253 = &g_137;
        union U0 *l_322 = &g_155;
        uint8_t l_364 = 0xE1;
        union U2 *l_369 = (void*)0;
        uint32_t l_391 = 0xAF387689;
        uint16_t l_393 = 65535U;
        float *l_418 = &l_195;
        int32_t l_419 = 0x323A33DE;
        union U3 *l_445 = (void*)0;
        g_176 = l_174;
        /* statement id: 116 */
        assert (g_176 == &l_175);
        if (((int32_t)__builtin_ffsl((***l_174)) - (int32_t)((((-1) || ((int16_t)(g_83 > 0x1973) % (int16_t)g_34)) > (*l_173)) > (((uint32_t)(p_63 & g_114) % (uint32_t)1U) > 0U))))
        { /* block id: 117 */
            uint32_t l_184 = 0U;
            int32_t l_196 = 0xD19C5106;
            float *l_200 = (void*)0;
            int16_t l_225 = 0;
            union U1 **l_266 = &l_199;
            union U0 **l_304 = (void*)0;
            uint16_t l_309 = 1U;
            int32_t *l_368 = &g_114;
        }
        else
        { /* block id: 267 */
            int32_t l_472 = 0;
            float **l_479 = &l_166;
            float ***l_478 = &l_479;
            (**l_175) = p_63;
            (***l_478) = (func_77(((uint16_t)__builtin_ia32_crc32qi((**l_175), (*l_173)) << (uint16_t)((int16_t)l_472 - (int16_t)((((int16_t)g_363 % (int16_t)0x4C98) ^ (!(__builtin_popcount(p_61) >= ((void*)0 != l_478)))) == g_83))), (*l_479)) <= (*g_93));
        }
    }
    else
    { /* block id: 271 */
        union U1 *l_484 = &g_137;
        union U1 **l_490 = &l_484;
        union U1 ***l_489 = &l_490;
        union U1 ****l_488 = &l_489;
lbl_491:
        (*l_173) = ((int16_t)((uint16_t)p_61 >> (uint16_t)((p_63 > (0xFA912836 | ((g_372.f1 != ((l_484 == &p_62) > p_63)) | (g_485 == l_488)))) && g_34)) + (int16_t)65535U);
        (*l_166) = 0x3.EC7DB4p-56;
        if (g_34)
            goto lbl_491;
    }
    /* facts after branching */
    //assert (g_176 == &g_177 || g_176 == dangling);
    return g_34;
}


/* ------------------------------------------ */
/* 
 * reads : g_111 g_114 g_138 g_83 g_93 g_31 g_154 g_157 g_139 g_137 g_110 g_163 g_540
 * writes: g_83 g_114 g_139 g_31 g_154 g_111 g_540
 */
static union U1  func_64(float * p_65, union U0  p_66, float * p_67)
{ /* block id: 76 */
    union U1 *l_136 = &g_137;
    int32_t *l_140 = &g_83;
    for (p_66.f0 = (-9); (p_66.f0 != 18); p_66.f0 += 1)
    { /* block id: 79 */
        int32_t *l_141 = &g_83;
        (*g_111) = p_66.f0;
        for (g_114 = 0; (g_114 <= (-30)); g_114 -= 9)
        { /* block id: 83 */
            (*g_138) = l_136;
            if (p_66.f0)
                goto lbl_146;
            l_141 = l_140;
        }
    }
    (*l_140) = __builtin_popcountl((*l_140));
lbl_146:
    (*p_67) = ((float)(*g_93) + (float)(((float)(*l_140) + (float)(*l_140)) >= ((*p_65) <= (*p_65))));
    if (((g_83 ^ ((int16_t)(*l_140) - (int16_t)(*l_140))) && func_77(g_114, p_67)))
    { /* block id: 91 */
        union U1 **l_151 = &l_136;
        float *l_152 = &g_31;
        (*g_111) = (((uint16_t)p_66.f0 >> (uint16_t)6) > func_77((p_66.f0 != (l_151 != &g_139)), l_152));
    }
    else
    { /* block id: 93 */
        int32_t l_153 = 0x59E040F3;
        if (l_153)
        { /* block id: 94 */
            union U0 * volatile *l_156 = (void*)0;
            (*g_157) = g_154;
        }
        else
        { /* block id: 96 */
            union U1 l_164 = {0x8.AE26BDp+75};
            for (p_66.f0 = 21; (p_66.f0 != 21); p_66.f0 += 5)
            { /* block id: 99 */
                int32_t *l_160 = &g_114;
                int32_t **l_161 = &g_111;
                (*l_161) = l_160;
                /* statement id: 100 */
                assert (g_111 == &g_114);
                return (*g_139);
                /* statement id: 101 */
                            }
            if (l_153)
            { /* block id: 103 */
                (*g_163) = (*g_110);
            }
            else
            { /* block id: 105 */
                return (**g_138);
                /* statement id: 106 */
                            }
            (*p_65) = (*g_93);
            return l_164;
            /* statement id: 109 */
                    }
    }
    return (*l_136);
    /* statement id: 112 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_83 g_93 g_31 g_4 g_110 g_114 g_111 g_131
 * writes: g_83 g_114 g_111
 */
static float * func_69(uint32_t  p_70, int32_t  p_71, float * p_72)
{ /* block id: 51 */
    float *l_90 = &g_31;
    union U1 l_91 = {-0x3.3p-1};
    for (g_83 = (-3); (g_83 == (-10)); g_83 -= 8)
    { /* block id: 54 */
        int32_t l_92 = (-1);
        float *l_94 = &g_31;
        (*g_131) = func_86((p_72 != l_90), l_91, (l_92 < func_77((l_92 < ((void*)0 == g_93)), l_94)));
    }
    return l_90;
    /* statement id: 75 */
    //assert (func_69_rv == &g_31);
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_114 g_137.f0 g_155.f0 g_83 g_223 g_540
 * writes:
 */
static int32_t  func_77(int32_t  p_78, float * p_79)
{ /* block id: 48 */
    int32_t *l_82 = &g_83;
    int32_t **l_81 = &l_82;
    (*l_81) = p_79;
    /* statement id: 49 */
    //assert (l_82 == &l_44.f0 || l_82 == &g_31 || l_82 == &g_114 || l_82 == &g_137.f0 || l_82 == &l_195 || l_82 == &g_155.f0 || l_82 == &g_83 || l_82 == &g_223 || l_82 == &g_540);
    return (**l_81);
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_83 g_31 g_110 g_114 g_111
 * writes: g_114
 */
static int32_t * func_86(int32_t  p_87, union U1  p_88, uint16_t  p_89)
{ /* block id: 55 */
    uint32_t l_102 = 1U;
    int32_t *l_104 = &g_83;
    int32_t **l_103 = &l_104;
    uint32_t l_105 = 0xEE4B4BC0;
    float *l_106 = &g_31;
    int32_t l_130 = 0x55FA7FFF;
    if (func_77(((int32_t)(((void*)0 != &p_87) || ((int16_t)((int16_t)__builtin_ffs((-(int16_t)(l_102 != ((l_103 != &l_104) | g_4)))) >> (int16_t)l_105) % (int16_t)(g_4 & g_83))) + (int32_t)p_87), l_106))
    { /* block id: 56 */
        int32_t *l_109 = &g_83;
        for (p_87 = 0; (p_87 >= (-22)); p_87--)
        { /* block id: 59 */
            return &g_83;
            /* statement id: 60 */
            //assert (func_86_rv == &g_83);
        }
        return l_109;
        /* statement id: 62 */
        //assert (func_86_rv == &g_83);
    }
    else
    { /* block id: 63 */
        int32_t **l_112 = &l_104;
        int32_t *l_113 = &g_114;
        (*l_113) = (g_110 != l_112);
        for (l_102 = 4; (l_102 > 7); l_102 += 2)
        { /* block id: 67 */
            p_88.f0 = p_87;
            l_130 = (((uint32_t)((uint16_t)(((int16_t)((uint16_t)(*l_104) << (uint16_t)g_114) >> (int16_t)((uint16_t)65529U + (uint16_t)func_77(((*l_113) || __builtin_ctzl(((int32_t)(!(**l_103)) - (int32_t)(0x63D7 && (((&l_113 != &g_111) <= (p_87 || 0U)) >= p_87))))), l_113))) > 0x6A4DCBD9) >> (uint16_t)10) - (uint32_t)p_87) <= g_114);
        }
        return (*g_110);
        /* statement id: 71 */
        //assert (func_86_rv == &g_83 || func_86_rv == &g_114 || func_86_rv == 0 || func_86_rv == &g_31 || func_86_rv == &l_68.f0 || func_86_rv == &l_494);
    }
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc_bytes (&g_31, sizeof(g_31), "g_31", print_hash_value);
    transparent_crc(g_34, "g_34", print_hash_value);
    transparent_crc(g_83, "g_83", print_hash_value);
    transparent_crc(g_114, "g_114", print_hash_value);
    transparent_crc_bytes (&g_137.f0, sizeof(g_137.f0), "g_137.f0", print_hash_value);
    transparent_crc(g_155.f0, "g_155.f0", print_hash_value);
    transparent_crc_bytes (&g_223, sizeof(g_223), "g_223", print_hash_value);
    transparent_crc(g_242, "g_242", print_hash_value);
    transparent_crc(g_363, "g_363", print_hash_value);
    transparent_crc(g_372.f0, "g_372.f0", print_hash_value);
    transparent_crc(g_372.f1, "g_372.f1", print_hash_value);
    transparent_crc(g_372.f2, "g_372.f2", print_hash_value);
    transparent_crc(g_372.f3, "g_372.f3", print_hash_value);
    transparent_crc(g_372.f4, "g_372.f4", print_hash_value);
    transparent_crc_bytes (&g_433.f0, sizeof(g_433.f0), "g_433.f0", print_hash_value);
    transparent_crc(g_433.f1, "g_433.f1", print_hash_value);
    transparent_crc(g_433.f2, "g_433.f2", print_hash_value);
    transparent_crc(g_535, "g_535", print_hash_value);
    transparent_crc_bytes (&g_540, sizeof(g_540), "g_540", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 160
XXX total union variables: 13

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 4
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 1
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 4

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 24
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 135

XXX times a variable address is taken: 129
XXX times a pointer is dereferenced on RHS: 147
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 30
   depth: 3, occurrence: 18
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 102
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 19
   depth: 3, occurrence: 11
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 427

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 452
   level: 2, occurrence: 192
   level: 3, occurrence: 59
   level: 4, occurrence: 12
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 73
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20.7
XXX average alias set size: 1.43

XXX times a non-volatile is read: 846
XXX times a non-volatile is write: 280
XXX times a volatile is read: 46
XXX    times read thru a pointer: 8
XXX times a volatile is write: 19
XXX    times written thru a pointer: 8
XXX times a volatile is available for access: 253
XXX percentage of non-volatile access: 94.5

XXX forward jumps: 2
XXX backward jumps: 3

XXX stmts: 96
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 22
   depth: 2, occurrence: 24
   depth: 3, occurrence: 18
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 19.4
XXX percentage an existing variable is used: 80.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

