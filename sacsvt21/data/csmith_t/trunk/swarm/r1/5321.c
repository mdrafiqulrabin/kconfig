/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3382289704
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static float g_4 = 0x1.Fp+1;
static float g_7 = 0x8.8B108Fp-14;
static int16_t g_14 = (-1);
static int32_t g_31 = (-10);
static int32_t *g_30 = &g_31;
static uint16_t g_39 = 1U;
static float g_40 = 0x9.6p+1;
static uint16_t g_42 = 1U;
static uint16_t g_90 = 0x9116;
static uint32_t g_120 = 0U;
static uint16_t g_157 = 65535U;
static int32_t g_166 = (-7);
static uint32_t g_169 = 4294967295U;
static uint16_t g_183 = 8U;
static int32_t *g_186 = &g_31;
static int32_t **g_185 = &g_186;
static uint16_t g_210 = 65527U;
static uint32_t g_212 = 9U;
static uint64_t g_215 = 3U;
static uint32_t *g_237 = (void*)0;
static uint32_t **g_236 = &g_237;
static int32_t *g_253 = &g_31;
static int32_t **g_252 = &g_253;
static uint16_t g_255 = 0x1752;
static int32_t ***g_265 = &g_252;
static int32_t ****g_264 = &g_265;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_29(void);
static int32_t * func_34(uint32_t  p_35);
static float  func_52(uint32_t  p_53, int32_t ** p_54, int32_t * p_55);
static int32_t * func_60(uint16_t * p_61, uint32_t  p_62, int32_t  p_63, int32_t ** p_64, uint16_t  p_65);
static uint16_t * func_66(int32_t  p_67, uint32_t * p_68, int32_t ** p_69);
static uint16_t  func_72(uint16_t * p_73, int32_t ** p_74, float  p_75);
static uint16_t * func_76(int32_t ** p_77, uint32_t  p_78, uint32_t  p_79, int32_t * p_80, int32_t * p_81);
static int32_t ** func_82(int16_t  p_83, float  p_84);
static uint32_t  func_91(int32_t  p_92);
static float  func_135(int32_t ** p_136, uint32_t  p_137, uint16_t * p_138, uint32_t  p_139);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_31 g_39 g_40 g_210 g_169 g_157 g_212 g_90 g_120 g_30 g_14 g_166 g_265 g_252 g_253 g_186 g_185 g_236 g_264
 * writes: g_30 g_39 g_42 g_4 g_40 g_212 g_120 g_90 g_7 g_14 g_157 g_166 g_210 g_215 g_186 g_253
 */
static int32_t  func_29(void)
{ /* block id: 36 */
    int32_t *l_33 = &g_31;
    int32_t **l_32 = &l_33;
    uint16_t *l_38 = &g_39;
    uint16_t *l_41 = &g_42;
    int32_t l_49 = 1;
    uint32_t l_58 = 0x161E33EC;
    uint32_t *l_59 = &l_58;
    float *l_323 = &g_4;
    (*l_32) = (g_30 = (void*)0);
    /* statement id: 38 */
    assert (g_30 == 0);
    assert (l_33 == 0);
    (***g_264) = func_34(((safe_rshift_func_uint16_t_u_u(g_31, (((*l_41) = ((*l_38) &= g_31)) ^ (((safe_div_func_float_f_f((g_40 = ((*l_323) = (((((safe_add_func_float_f_f((safe_div_func_float_f_f((g_31 > 0x0.FD5228p-16), g_40)), l_49)) > ((void*)0 == &g_31)) > (safe_add_func_float_f_f(func_52(((*l_59) = (safe_add_func_int32_t_s_s(l_58, 0x3EEDA781))), &g_30, &g_31), 0x3.Bp-1))) != 0xA.58D7BDp+82) > g_210))), g_169)) > (-0x5.Ap+1)) , 65532U)))) >= 3));
    /* statement id: 187 */
    //assert (g_30 == &g_31 || g_30 == 0 || g_30 == dangling);
    return g_90;
}


/* ------------------------------------------ */
/* 
 * reads : g_157 g_212 g_40 g_90 g_31 g_120 g_30 g_14 g_166 g_265 g_252 g_253 g_210 g_169 g_186 g_185 g_236
 * writes: g_212 g_120 g_90 g_30 g_7 g_14 g_4 g_157 g_166 g_210 g_215 g_186 g_253
 */
static int32_t * func_34(uint32_t  p_35)
{ /* block id: 182 */
    uint32_t *l_324 = &g_212;
    int32_t l_327 = 7;
    uint16_t *l_329 = (void*)0;
    uint16_t **l_328 = &l_329;
    int32_t **l_330 = &g_186;
    (*g_252) = func_60(((*l_328) = func_76(func_82((p_35 > g_157), ((--(*l_324)) , (g_40 == g_90))), l_327, __builtin_parityl(l_327), (**g_265), &l_327)), l_327, l_327, l_330, p_35);
    /* statement id: 185 */
    //assert (g_30 == &g_31 || g_30 == 0 || g_30 == dangling);
    assert (l_329 == &g_157);
    return (*g_185);
    /* statement id: 186 */
    //assert (func_34_rv == &g_31);
}


/* ------------------------------------------ */
/* 
 * reads : g_40
 * writes:
 */
static float  func_52(uint32_t  p_53, int32_t ** p_54, int32_t * p_55)
{ /* block id: 42 */
    uint16_t l_167 = 65531U;
    uint32_t *l_168 = &g_169;
    int32_t *l_170 = &g_31;
    uint16_t *l_181 = (void*)0;
    uint16_t *l_182 = &g_183;
    float l_184 = 0x7.336AE2p+73;
    int32_t ***l_241 = &g_185;
    int32_t ****l_242 = &l_241;
    uint16_t l_249 = 65535U;
    float *l_251 = (void*)0;
    float **l_250 = &l_251;
    int16_t *l_254 = &g_14;
    uint32_t ***l_256 = &g_236;
    int32_t **l_260 = &g_186;
    uint16_t l_266 = 0x82E1;
    int16_t l_275 = 0;
    float **l_293 = (void*)0;
    int32_t l_304 = 0;
    int32_t l_315 = (-5);
    int32_t l_316 = (-3);
    return g_40;
}


/* ------------------------------------------ */
/* 
 * reads : g_14 g_210 g_169 g_186 g_31 g_185 g_236
 * writes: g_210 g_90 g_212 g_215 g_166 g_14 g_186 g_157
 */
static int32_t * func_60(uint16_t * p_61, uint32_t  p_62, int32_t  p_63, int32_t ** p_64, uint16_t  p_65)
{ /* block id: 104 */
    uint32_t l_204 = 0x42F98E8F;
    int32_t l_207 = 0;
    int32_t l_213 = (-1);
    for (p_62 = 28; (p_62 >= 40); p_62 = safe_add_func_int32_t_s_s(p_62, 1))
    { /* block id: 107 */
        int32_t l_208 = 0x19E39778;
        uint32_t *l_211 = &g_212;
        uint64_t *l_214 = &g_215;
        float l_216 = 0x2.0p+1;
        uint32_t **l_217 = (void*)0;
        uint32_t *l_219 = &g_169;
        uint32_t **l_218 = &l_219;
        int32_t *l_230 = &g_166;
        int32_t *l_231 = &l_213;
        l_213 = __builtin_popcount(((*l_211) = (safe_lshift_func_uint16_t_u_s(((*p_61) = ((safe_add_func_int16_t_s_s(0x5FE4, (l_204 ^ ((safe_div_func_int32_t_s_s(l_207, __builtin_popcountll(l_208))) != (!p_62))))) == (g_210 ^= 0x91CAF8AA))), 12))));
        (*l_231) = ((*l_230) = ((((__builtin_popcountll(((*l_214) = p_65)) & (g_169 ^ ((p_63 = l_208) <= ((((*l_218) = &p_62) != (void*)0) < ((safe_sub_func_int32_t_s_s(__builtin_popcountll(((g_14 >= (safe_rshift_func_int16_t_s_u((safe_mod_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((l_204 >= (-10)), g_210)), 1U)), l_213)), 14))) > l_207)), l_207)) && p_65))))) != l_204) ^ l_207) , l_207));
        /* statement id: 116 */
        assert (l_219 == &p_62);
    }
    for (p_65 = 23; (p_65 == 38); p_65 = safe_add_func_uint16_t_u_u(p_65, 1))
    { /* block id: 120 */
        float l_234 = (-0x1.Cp-1);
        int16_t *l_235 = &g_14;
        uint32_t **l_239 = &g_237;
        uint32_t ***l_238 = &l_239;
        int32_t *l_240 = &g_166;
        (*l_240) = ((((*l_235) = ((**p_64) | ((**g_185) && (g_210 || __builtin_popcountll(l_213))))) , g_236) != ((*l_238) = &g_237));
        (*g_185) = (*g_185);
        if ((**p_64))
            break;
    }
    return (*g_185);
    /* statement id: 127 */
    //assert (func_60_rv == &g_31);
}


/* ------------------------------------------ */
/* 
 * reads : g_186 g_31
 * writes: g_90
 */
static uint16_t * func_66(int32_t  p_67, uint32_t * p_68, int32_t ** p_69)
{ /* block id: 100 */
    int16_t l_191 = 0xA75A;
    uint32_t *l_192 = &g_120;
    uint16_t *l_193 = &g_90;
    int32_t l_194 = (-5);
    uint16_t l_195 = 0x64FF;
    int32_t l_196 = 0x10F06FB9;
    uint16_t *l_197 = &g_90;
    l_196 ^= (((*l_193) = (((safe_lshift_func_int16_t_s_s((safe_add_func_uint32_t_u_u((l_191 | (((*g_186) , l_192) == p_68)), 0xECA9F70E)), (l_194 == l_195))) , l_195) , p_67)) < 0x9C57);
    return l_197;
    /* statement id: 103 */
    //assert (func_66_rv == &g_90);
}


/* ------------------------------------------ */
/* 
 * reads : g_157
 * writes: g_186
 */
static uint16_t  func_72(uint16_t * p_73, int32_t ** p_74, float  p_75)
{ /* block id: 96 */
    (*p_74) = (void*)0;
    /* statement id: 97 */
    //assert (l_170 == 0);
    return (*p_73);
}


/* ------------------------------------------ */
/* 
 * reads : g_166 g_120
 * writes: g_166 g_120 g_90
 */
static uint16_t * func_76(int32_t ** p_77, uint32_t  p_78, uint32_t  p_79, int32_t * p_80, int32_t * p_81)
{ /* block id: 88 */
    int32_t l_174 = 1;
    for (g_166 = 0; (g_166 == 27); g_166 = safe_add_func_uint32_t_u_u(g_166, 1))
    { /* block id: 91 */
        int32_t l_178 = 1;
        uint16_t *l_179 = &g_90;
        int32_t *l_180 = &l_174;
        (*l_180) = (((*l_179) = ((+((l_174 != (safe_div_func_int32_t_s_s((~0xAC0C), l_178))) == func_91(l_174))) , p_78)) || 0x24BA);
    }
    return &g_157;
    /* statement id: 95 */
    //assert (func_76_rv == &g_157);
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_120 g_30 g_14 g_90 g_157 g_166
 * writes: g_120 g_90 g_30 g_7 g_14 g_4 g_157 g_166
 */
static int32_t ** func_82(int16_t  p_83, float  p_84)
{ /* block id: 43 */
    int32_t l_86 = (-6);
    uint16_t *l_141 = (void*)0;
    float l_154 = 0xB.6D0914p-50;
    int16_t l_158 = (-5);
    if ((~l_86))
    { /* block id: 44 */
        uint16_t *l_89 = &g_90;
        int32_t **l_124 = (void*)0;
        int32_t **l_125 = &g_30;
        int32_t *l_126 = &l_86;
        (*l_126) &= (((*l_125) = (((*l_89) = (((0xF9898791 <= __builtin_clz(g_31)) ^ ((void*)0 != l_89)) >= func_91(p_83))) , &l_86)) == (void*)0);
        /* statement id: 52 */
        assert (g_30 == &l_86);
        for (g_120 = 0; (g_120 >= 56); g_120 = safe_add_func_int32_t_s_s(g_120, 1))
        { /* block id: 55 */
            if ((*g_30))
                break;
        }
    }
    else
    { /* block id: 58 */
        int32_t **l_140 = &g_30;
        for (l_86 = 1; (l_86 < 15); l_86 = safe_add_func_uint16_t_u_u(l_86, 2))
        { /* block id: 61 */
            if (p_83)
                break;
        }
        if ((safe_div_func_int16_t_s_s(l_86, (g_14 ^ (safe_rshift_func_int16_t_s_s((func_135(l_140, p_83, l_141, p_83) , (l_86 >= (safe_mod_func_uint32_t_u_u(((((l_141 != (void*)0) , (void*)0) == g_30) > l_86), 0xB5195E1C)))), 7))))))
        { /* block id: 72 */
            uint16_t l_151 = 0x7178;
            int16_t *l_155 = &g_14;
            float *l_156 = &g_4;
            l_158 |= ((((((*l_155) = (__builtin_ffsll(((safe_add_func_int16_t_s_s(l_151, ((*l_155) ^= (safe_div_func_int32_t_s_s(l_151, p_83))))) <= l_151)) , p_83)) <= (((*l_156) = l_86) , g_90)) , ((((*l_155) = (g_157 |= __builtin_bswap32(__builtin_parityll(((void*)0 != &p_83))))) != 0xD611) , p_83)) > p_83) , 0xFE816D3F);
        }
        else
        { /* block id: 79 */
            int32_t **l_159 = &g_30;
            int32_t *l_160 = &l_86;
            int16_t *l_161 = (void*)0;
            int16_t *l_162 = &g_14;
            int32_t *l_163 = (void*)0;
            int32_t *l_164 = (void*)0;
            int32_t *l_165 = &g_166;
            (*l_140) = &g_31;
            /* statement id: 80 */
            assert (g_30 == &g_31);
            (*l_165) |= (((*l_162) &= (((*g_30) , func_91(((*l_160) &= (l_140 == l_159)))) <= 0x3FE2F772)) == g_157);
        }
    }
    /* facts after branching */
    assert (g_30 == &g_31 || g_30 == 0 || g_30 == &l_86);
    return &g_30;
    /* statement id: 86 */
    //assert (g_30 == &g_31 || g_30 == 0 || g_30 == dangling);
    //assert (func_82_rv == &g_30);
}


/* ------------------------------------------ */
/* 
 * reads : g_120
 * writes: g_120
 */
static uint32_t  func_91(int32_t  p_92)
{ /* block id: 45 */
    int32_t *l_93 = (void*)0;
    int32_t l_94 = 0xC2B2A8F3;
    int32_t *l_95 = (void*)0;
    int32_t l_96 = 0x0421A167;
    int32_t *l_97 = &l_94;
    int32_t *l_98 = &l_94;
    int32_t *l_99 = &l_94;
    int32_t *l_100 = &l_94;
    int32_t *l_101 = &l_94;
    int32_t *l_102 = &l_96;
    int32_t *l_103 = &l_94;
    int32_t *l_104 = &l_94;
    int32_t *l_105 = &l_96;
    int32_t *l_106 = (void*)0;
    int32_t *l_107 = (void*)0;
    int32_t *l_108 = &l_94;
    int32_t *l_109 = (void*)0;
    int32_t *l_110 = &l_94;
    int32_t *l_111 = &l_94;
    int32_t *l_112 = &l_94;
    int32_t *l_113 = &l_96;
    int32_t *l_114 = &l_96;
    int32_t *l_115 = (void*)0;
    int32_t *l_116 = &l_96;
    int32_t *l_117 = &l_96;
    int32_t *l_118 = &l_96;
    int32_t *l_119 = &l_94;
    int32_t **l_123 = &l_113;
    --g_120;
    (*l_105) = 0xC53D1739;
    (*l_123) = (void*)0;
    /* statement id: 48 */
    assert (l_113 == 0);
    return p_92;
}


/* ------------------------------------------ */
/* 
 * reads : g_90
 * writes: g_7 g_90
 */
static float  func_135(int32_t ** p_136, uint32_t  p_137, uint16_t * p_138, uint32_t  p_139)
{ /* block id: 64 */
    int32_t l_142 = 1;
    float *l_143 = &g_7;
    (*l_143) = l_142;
    for (g_90 = 14; (g_90 == 38); g_90 = safe_add_func_uint32_t_u_u(g_90, 7))
    { /* block id: 68 */
        int16_t l_146 = 0x4372;
        return l_146;
    }
    return l_142;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc_bytes (&g_4, sizeof(g_4), "g_4", print_hash_value);
    transparent_crc_bytes (&g_7, sizeof(g_7), "g_7", print_hash_value);
    transparent_crc(g_14, "g_14", print_hash_value);
    transparent_crc(g_31, "g_31", print_hash_value);
    transparent_crc(g_39, "g_39", print_hash_value);
    transparent_crc_bytes (&g_40, sizeof(g_40), "g_40", print_hash_value);
    transparent_crc(g_42, "g_42", print_hash_value);
    transparent_crc(g_90, "g_90", print_hash_value);
    transparent_crc(g_120, "g_120", print_hash_value);
    transparent_crc(g_157, "g_157", print_hash_value);
    transparent_crc(g_166, "g_166", print_hash_value);
    transparent_crc(g_169, "g_169", print_hash_value);
    transparent_crc(g_183, "g_183", print_hash_value);
    transparent_crc(g_210, "g_210", print_hash_value);
    transparent_crc(g_212, "g_212", print_hash_value);
    transparent_crc(g_215, "g_215", print_hash_value);
    transparent_crc(g_255, "g_255", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 74
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 7
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 131

XXX times a variable address is taken: 111
XXX times a pointer is dereferenced on RHS: 40
breakdown:
   depth: 1, occurrence: 25
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 57
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 325

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 292
   level: 2, occurrence: 81
   level: 3, occurrence: 22
   level: 4, occurrence: 13
XXX number of pointers point to pointers: 39
XXX number of pointers point to scalars: 92
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.7
XXX average alias set size: 1.11

XXX times a non-volatile is read: 279
XXX times a non-volatile is write: 152
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 40
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 11
   depth: 2, occurrence: 5

XXX percentage a fresh-made variable is used: 22.6
XXX percentage an existing variable is used: 77.4
********************* end of statistics **********************/

