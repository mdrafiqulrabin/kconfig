/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3788282032
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint16_t g_3 = 0U;
static uint8_t g_11 = 0x3B;
static int32_t g_15 = 0xF23B1A95;
static int32_t *g_138 = &g_15;
static int32_t **g_137 = &g_138;
static volatile uint32_t g_227 = 4294967292U;/* VOLATILE GLOBAL g_227 */
static uint8_t g_301 = 0x7C;
static int32_t g_329 = 2;
static int32_t *g_328 = &g_329;
static int32_t g_396 = 0x13E6207B;
static uint16_t g_431 = 0x317F;


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_29(void);
static int16_t  func_35(int32_t  p_36, int32_t  p_37, int32_t  p_38);
static uint16_t  func_47(int16_t  p_48, uint32_t  p_49, uint16_t  p_50, int32_t  p_51, int32_t  p_52);
static int32_t  func_61(int16_t  p_62, uint8_t  p_63, int32_t  p_64, int16_t  p_65);
static int32_t  func_78(const uint8_t  p_79, uint32_t  p_80, const int16_t  p_81);
static uint16_t  func_84(int32_t  p_85, uint16_t  p_86, int16_t  p_87, const uint32_t  p_88);
static int32_t * func_90(uint32_t  p_91, int32_t * p_92, int32_t * const  p_93, const int32_t * p_94, uint16_t  p_95);
static int16_t  func_96(int32_t * p_97, int16_t  p_98, int32_t * p_99);
static uint16_t  func_100(int32_t * p_101, int32_t * p_102, int32_t  p_103, int32_t * p_104);
static int32_t * func_105(int32_t * p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_11 g_3 g_15 g_137 g_138 g_227 g_301 g_328 g_329 g_431
 * writes: g_15 g_138 g_301 g_329 g_3
 */
static uint8_t  func_29(void)
{ /* block id: 36 */
    int16_t l_34 = (-3);
    uint32_t l_56 = 0x27720104;
    int32_t l_358 = 8;
    int16_t l_359 = 0x0BAC;
    int32_t l_432 = (-1);
    (*g_328) = ((((int32_t)g_11 % (int32_t)((((int16_t)l_34 - (int16_t)func_35(((uint32_t)g_11 / (uint32_t)((0x18C9A01C ^ ((int32_t)l_34 / (int32_t)((uint16_t)(((int16_t)(g_3 < l_34) + (int16_t)l_34) & (func_47((-(uint32_t)((int32_t)(__builtin_ctz(g_3) && g_11) % (int32_t)l_34)), g_11, g_15, l_56, g_11) != l_358)) << (uint16_t)12))) || g_301)), g_11, l_359)) & g_11) ^ l_56)) != l_359) || g_11);
    (**g_137) = (g_301 > ((int32_t)(((((+l_359) | (0x07101F39 >= ((+(l_359 >= (**g_137))) == __builtin_parityll(((uint16_t)(+(g_11 > __builtin_popcount(g_3))) - (uint16_t)((int32_t)((*g_328) == 0) + (int32_t)g_431)))))) || l_358) & 0x35C1B076) && l_34) % (int32_t)l_358));
    return l_432;
}


/* ------------------------------------------ */
/* 
 * reads : g_138 g_3 g_137 g_11
 * writes: g_329 g_3 g_138
 */
static int16_t  func_35(int32_t  p_36, int32_t  p_37, int32_t  p_38)
{ /* block id: 230 */
    uint16_t l_402 = 1U;
    int32_t * const l_403 = &g_15;
    for (p_36 = 0; (p_36 == 8); p_36 += 1)
    { /* block id: 233 */
        int32_t *l_394 = &g_15;
        (*g_138) = (-1);
        for (g_3 = 0; (g_3 < 10); g_3 += 9)
        { /* block id: 237 */
            int32_t *l_367 = &g_329;
            int32_t ***l_387 = &g_137;
            int32_t ****l_386 = &l_387;
        }
    }
    (*g_137) = func_90(p_37, (*g_137), (*g_137), (*g_137), ((&g_137 != (void*)0) > g_11));
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_15 g_3 g_137 g_138 g_227 g_301 g_328 g_329
 * writes: g_15 g_138 g_301 g_329
 */
static uint16_t  func_47(int16_t  p_48, uint32_t  p_49, uint16_t  p_50, int32_t  p_51, int32_t  p_52)
{ /* block id: 37 */
    uint8_t l_66 = 0xC1;
    int16_t l_77 = 1;
    uint32_t l_347 = 7U;
    int32_t *l_348 = &g_329;
    (*g_328) = ((uint16_t)((int32_t)func_61(g_11, l_66, ((int16_t)((((uint32_t)((uint16_t)g_11 << (uint16_t)p_49) - (uint32_t)((uint16_t)((uint16_t)l_77 * (uint16_t)(func_78(p_49, ((9U || (p_49 ^ (((((int32_t)l_66 / (int32_t)g_11) & g_15) != 0x7646) ^ l_77))) ^ p_48), l_77) ^ 4294967295U)) % (uint16_t)l_77)) | l_66) & 0xBBFA) * (int16_t)p_48), p_51) % (int32_t)l_347) % (uint16_t)l_77);
    (*g_137) = l_348;
    (*l_348) = (((uint16_t)((uint16_t)((int16_t)(~((int16_t)((p_52 & p_49) > (*g_328)) - (int16_t)8U)) / (int16_t)(*l_348)) << (uint16_t)__builtin_clzl(p_50)) << (uint16_t)__builtin_parityll((p_48 <= ((-1) > g_15)))) <= g_227);
    return g_301;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_301 g_328 g_329
 * writes: g_15 g_301 g_329
 */
static int32_t  func_61(int16_t  p_62, uint8_t  p_63, int32_t  p_64, int16_t  p_65)
{ /* block id: 213 */
    for (g_15 = 0; (g_15 <= (-27)); g_15 -= 6)
    { /* block id: 216 */
        const int32_t l_346 = 0xC2331319;
        for (g_301 = 22; (g_301 != 35); g_301 += 1)
        { /* block id: 219 */
            return (*g_328);
        }
        (*g_328) = (-9);
        if (l_346)
            continue;
    }
    return (*g_328);
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_15 g_3 g_137 g_138 g_227 g_301 g_328 g_329
 * writes: g_15 g_138 g_301 g_329
 */
static int32_t  func_78(const uint8_t  p_79, uint32_t  p_80, const int16_t  p_81)
{ /* block id: 38 */
    int16_t l_341 = 1;
    (*g_328) = (0xAB95 < func_84(g_11, (-(int16_t)0x45F0), p_80, p_79));
    return l_341;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_3 g_137 g_138 g_11 g_227 g_301 g_328 g_329
 * writes: g_15 g_138 g_301 g_329
 */
static uint16_t  func_84(int32_t  p_85, uint16_t  p_86, int16_t  p_87, const uint32_t  p_88)
{ /* block id: 39 */
    int32_t l_327 = 0x2184DD8C;
    const int32_t *l_330 = &g_329;
    int32_t l_332 = 0x34368CCA;
    int16_t l_338 = 0x02F8;
    int32_t ***l_340 = (void*)0;
    l_330 = func_90((func_96(&g_15, g_15, &g_15) == l_327), g_328, &g_329, l_330, g_3);
    l_332 = 0xCA7656AE;
    (*g_328) = (((-(int16_t)(p_85 >= ((int16_t)((void*)0 == &g_137) / (int16_t)((uint16_t)(__builtin_parity(__builtin_popcountll(g_3)) | (l_338 == ((((-1) == (~(l_340 != l_340))) <= 0) != p_87))) * (uint16_t)p_88)))) ^ p_85) != (*l_330));
    return p_86;
}


/* ------------------------------------------ */
/* 
 * reads : g_137 g_138
 * writes: g_138
 */
static int32_t * func_90(uint32_t  p_91, int32_t * p_92, int32_t * const  p_93, const int32_t * p_94, uint16_t  p_95)
{ /* block id: 204 */
    int32_t *l_331 = &g_329;
    (*g_137) = (*g_137);
    return p_92;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_3 g_137 g_138 g_11 g_227 g_301 g_329
 * writes: g_15 g_138 g_301 g_329
 */
static int16_t  func_96(int32_t * p_97, int16_t  p_98, int32_t * p_99)
{ /* block id: 40 */
    int32_t *l_233 = &g_15;
    int32_t ***l_241 = &g_137;
    int32_t l_299 = 0x64ED7519;
    if (__builtin_popcountll(p_98))
    { /* block id: 41 */
        uint8_t l_212 = 255U;
        int32_t *l_221 = &g_15;
        if ((0xF696 || (func_100(&g_15, func_105(p_99), p_98, p_99) > ((int32_t)(l_212 || g_11) - (int32_t)1))))
        { /* block id: 118 */
            uint8_t l_228 = 0x64;
            int32_t *l_230 = &g_15;
            (*g_138) = l_212;
            for (p_98 = 14; (p_98 == 10); p_98 -= 1)
            { /* block id: 122 */
                int32_t *l_229 = &g_15;
                int32_t ***l_232 = &g_137;
                int32_t ****l_231 = &l_232;
            }
            (*g_137) = func_105(l_233);
            for (l_212 = 0; (l_212 == 16); l_212 += 7)
            { /* block id: 137 */
                int32_t *l_236 = &g_15;
                (*g_137) = l_236;
                if (((*l_221) != p_98))
                { /* block id: 139 */
                    uint16_t l_249 = 65535U;
                    if ((g_15 || (-(uint32_t)p_98)))
                    { /* block id: 140 */
                        (*g_138) = (*p_97);
                        (*l_230) = ((int16_t)(p_98 | (!func_100(l_236, p_99, ((void*)0 != l_241), p_99))) << (int16_t)((uint32_t)(__builtin_parityll(p_98) >= 1U) / (uint32_t)g_11));
                        (*g_137) = l_230;
                        (*g_138) = ((void*)0 == &g_138);
                    }
                    else
                    { /* block id: 145 */
                        uint32_t l_248 = 0x8C604228;
                        (*g_137) = func_105(p_99);
                        (*p_97) = (0 && ((((func_100(p_99, (*g_137), g_15, p_99) == ((int16_t)((-2) | g_227) * (int16_t)g_3)) | l_248) < 0xCE37CC86) <= l_249));
                        (*l_221) = ((void*)0 != &l_230);
                    }
                }
                else
                { /* block id: 150 */
                    (*l_233) = func_100((*g_137), (**l_241), ((int16_t)(p_99 == p_99) << (int16_t)g_227), p_99);
                }
            }
        }
        else
        { /* block id: 154 */
            (*g_137) = p_99;
            (*l_221) = ((*g_137) != (*g_137));
        }
    }
    else
    { /* block id: 158 */
        (***l_241) = (~((int16_t)2 >> (int16_t)15));
    }
    for (g_15 = (-30); (g_15 <= (-16)); g_15 += 2)
    { /* block id: 163 */
        uint32_t l_278 = 0x87AE741E;
        uint16_t l_298 = 0x5BB5;
        int32_t * const ***l_300 = (void*)0;
        int32_t l_302 = 0xBB3E451E;
        for (p_98 = 0; (p_98 >= (-27)); --p_98)
        { /* block id: 166 */
            uint16_t l_259 = 0xE044;
            l_259 = (*p_99);
            for (l_259 = 10; (l_259 < 27); l_259 += 1)
            { /* block id: 170 */
                uint32_t l_262 = 0x9F560096;
                const int32_t * const *l_269 = (void*)0;
                const int32_t * const **l_268 = &l_269;
                const int32_t * const ***l_267 = &l_268;
                if ((l_262 > p_98))
                { /* block id: 171 */
                    uint32_t l_277 = 1U;
                    int32_t * const l_279 = &g_15;
                    int32_t **l_280 = (void*)0;
                    int32_t **l_281 = &g_138;
                    (**l_241) = (*g_137);
                    l_278 = (__builtin_ctzll(l_259) <= ((uint16_t)(((uint16_t)(l_267 != &l_268) >> (uint16_t)13) > ((uint16_t)((int16_t)g_3 - (int16_t)(((int16_t)(&g_138 != &p_99) << (int16_t)6) | ((!p_98) == g_15))) >> (uint16_t)l_277)) * (uint16_t)l_259));
                    (*l_281) = l_279;
                }
                else
                { /* block id: 175 */
                    int16_t l_286 = 0x26D7;
                    int32_t l_291 = 0x24FA9163;
                    l_291 = __builtin_bswap64(((uint16_t)((uint32_t)(l_286 <= (g_3 < ((uint32_t)p_98 + (uint32_t)p_98))) % (uint32_t)l_286) * (uint16_t)(((uint16_t)l_286 + (uint16_t)__builtin_ia32_crc32qi(g_11, p_98)) && g_11)));
                    l_298 = ((int16_t)((int16_t)((int16_t)(__builtin_clzl((*l_233)) <= (((**l_267) == &g_138) != (__builtin_parityl((l_278 || 0x40898BEA)) <= ((*l_233) && (1U < 6))))) % (int16_t)0xB81B) * (int16_t)p_98) / (int16_t)(*l_233));
                    if ((*p_97))
                        break;
                }
            }
            l_299 = (-5);
        }
        g_301 = ((void*)0 != l_300);
        if (g_3)
        { /* block id: 184 */
            int32_t *l_305 = &l_302;
            l_302 = (*p_97);
            (*l_305) = (0x7D20 >= ((int16_t)g_3 - (int16_t)0xA9C1));
        }
        else
        { /* block id: 187 */
            int32_t l_312 = 0x4E24FC96;
            uint16_t l_314 = 0x0934;
            int32_t ****l_326 = &l_241;
            for (l_302 = (-24); (l_302 >= 16); l_302 += 5)
            { /* block id: 190 */
                uint32_t l_313 = 0U;
                int32_t *l_325 = &l_312;
                if (((uint16_t)((((int16_t)(&p_97 == (void*)0) + (int16_t)l_312) != l_313) > l_314) + (uint16_t)((0xD891B158 == 0x9E85B977) | ((uint16_t)0x3031 * (uint16_t)l_313))))
                { /* block id: 191 */
                    int32_t *l_317 = &g_15;
                    int16_t l_322 = 1;
                    int32_t l_324 = 0xFE637BB3;
                    (**l_241) = l_317;
                    l_324 = ((uint16_t)((uint16_t)l_322 << (uint16_t)p_98) * (uint16_t)(((*l_233) <= (~(*l_233))) <= 0));
                }
                else
                { /* block id: 194 */
                    (*g_137) = (**l_241);
                }
                (*l_325) = ((void*)0 != &g_138);
            }
            (*l_326) = &g_137;
        }
        (**l_241) = p_97;
    }
    return g_301;
}


/* ------------------------------------------ */
/* 
 * reads : g_137 g_15 g_138 g_3 g_11
 * writes: g_138 g_15
 */
static uint16_t  func_100(int32_t * p_101, int32_t * p_102, int32_t  p_103, int32_t * p_104)
{ /* block id: 93 */
    int32_t *l_152 = &g_15;
    int32_t *l_153 = &g_15;
    (*g_137) = p_104;
    if ((l_153 != (void*)0))
    { /* block id: 95 */
        uint16_t l_166 = 0x3D77;
        uint32_t l_173 = 0xBC7E195E;
        (*p_104) = ((int16_t)(((uint16_t)(((uint16_t)((int16_t)0xC74B << (int16_t)5) >> (uint16_t)(65533U && 6U)) == 1) * (uint16_t)p_103) <= (0U && (*p_104))) % (int16_t)p_103);
        if ((p_103 < ((((((uint16_t)((uint16_t)l_166 * (uint16_t)g_15) * (uint16_t)l_166) <= (*g_138)) <= ((*g_138) | (*p_104))) < ((uint32_t)(*l_153) - (uint32_t)((uint16_t)0x2A41 - (uint16_t)0x3ED5))) <= l_166)))
        { /* block id: 97 */
            p_101 = (*g_137);
        }
        else
        { /* block id: 99 */
            int32_t l_191 = 9;
            (*g_137) = (void*)0;
            (*l_152) = ((int16_t)((l_173 ^ (((*l_152) & (&g_138 == &l_152)) >= (*l_152))) & g_3) / (int16_t)l_173);
            (*g_137) = p_101;
            for (l_166 = 0; (l_166 == 9); l_166 += 1)
            { /* block id: 105 */
                uint16_t l_184 = 0xA5F0;
                (*l_152) = (((uint16_t)((int16_t)l_166 << (int16_t)3) >> (uint16_t)(1U >= (((int32_t)l_184 % (int32_t)g_15) > ((p_103 && ((*g_138) == (*p_104))) & p_103)))) > p_103);
                (*g_137) = (*g_137);
                (*l_152) = (((int16_t)(((int32_t)((p_102 != p_101) & ((int16_t)(((*g_138) && l_191) > (l_184 == ((uint32_t)(((g_11 ^ (4U == (((l_184 < (-1)) && p_103) ^ l_184))) & l_191) & 0) % (uint32_t)p_103))) << (int16_t)g_3)) / (int32_t)(*g_138)) == p_103) << (int16_t)14) & l_173);
            }
        }
        (*g_137) = (void*)0;
    }
    else
    { /* block id: 112 */
        uint32_t l_200 = 1U;
        (*l_152) = (*p_101);
        (**g_137) = ((2 != g_11) || (((int16_t)((int16_t)((uint32_t)l_200 / (uint32_t)g_11) * (int16_t)p_103) * (int16_t)((((((-6) && ((int16_t)p_103 >> (int16_t)4)) ^ ((int16_t)((uint16_t)__builtin_parityll((+((__builtin_ffs(((uint16_t)0xCB47 << (uint16_t)(*l_152))) ^ g_3) == g_15))) - (uint16_t)(*l_152)) / (int16_t)p_103)) < 0x0889) || 0x1EBD87E6) <= (*l_153))) <= p_103));
    }
    (*g_137) = p_101;
    return g_11;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_3 g_137 g_138 g_11 g_329
 * writes: g_15 g_138 g_329
 */
static int32_t * func_105(int32_t * p_106)
{ /* block id: 42 */
    uint32_t l_107 = 4294967289U;
    int32_t l_116 = 0xA93538B8;
    int32_t **l_139 = &g_138;
    if (l_107)
    { /* block id: 43 */
        int16_t l_112 = 0x8A7C;
        int32_t *l_115 = &g_15;
        (*p_106) = __builtin_clzl(l_107);
        l_116 = (1 ^ ((uint16_t)((int16_t)((l_112 ^ l_107) || l_107) + (int16_t)((-1) > (l_112 | ((uint32_t)((((l_107 == (((l_107 && (l_115 == l_115)) < g_15) >= l_107)) || (*p_106)) >= 0x9E06D3C1) > g_15) - (uint32_t)(-9))))) << (uint16_t)l_107));
    }
    else
    { /* block id: 46 */
        int32_t *l_119 = &l_116;
        int32_t **l_120 = &l_119;
        for (l_107 = 0; (l_107 >= 4); l_107 += 1)
        { /* block id: 49 */
            if ((*p_106))
                break;
        }
        (*l_120) = l_119;
        for (l_116 = 0; (l_116 > (-21)); --l_116)
        { /* block id: 55 */
            for (g_15 = (-24); (g_15 < (-22)); g_15 += 1)
            { /* block id: 58 */
                return p_106;
            }
            (*l_120) = &g_15;
            return &g_15;
        }
        (*l_120) = &l_116;
    }
    if (((int32_t)l_107 / (int32_t)0x28903759))
    { /* block id: 66 */
        uint16_t l_136 = 0xA0A0;
        for (l_116 = 19; (l_116 != (-27)); --l_116)
        { /* block id: 69 */
            for (l_107 = 28; (l_107 > 10); l_107 -= 3)
            { /* block id: 72 */
                int32_t *l_132 = &g_15;
                int32_t **l_131 = &l_132;
                (*l_131) = p_106;
                if (((g_3 < (!l_136)) || l_136))
                { /* block id: 74 */
                    (**g_137) = (g_137 == l_139);
                }
                else
                { /* block id: 76 */
                    return p_106;
                }
                (*l_131) = (void*)0;
                (**l_139) = ((uint16_t)g_11 << (uint16_t)((int16_t)__builtin_bswap64(g_15) * (int16_t)g_11));
            }
        }
        for (l_107 = 0; (l_107 < 25); l_107 += 1)
        { /* block id: 85 */
            (*g_137) = p_106;
        }
        (**g_137) = ((int16_t)g_15 << (int16_t)(~(0xD2A5 || (((int32_t)(**l_139) % (int32_t)(**l_139)) || g_11))));
    }
    else
    { /* block id: 89 */
        int32_t *l_151 = (void*)0;
        (*l_139) = l_151;
    }
    return (*g_137);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_11, "g_11", print_hash_value);
    transparent_crc(g_15, "g_15", print_hash_value);
    transparent_crc(g_227, "g_227", print_hash_value);
    transparent_crc(g_301, "g_301", print_hash_value);
    transparent_crc(g_329, "g_329", print_hash_value);
    transparent_crc(g_396, "g_396", print_hash_value);
    transparent_crc(g_431, "g_431", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 83
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 121
   depth: 2, occurrence: 33
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 3
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 53

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 76
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 71
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 271

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 492
   level: 2, occurrence: 82
   level: 3, occurrence: 13
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 18
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 17
XXX average alias set size: 1.26

XXX times a non-volatile is read: 484
XXX times a non-volatile is write: 187
XXX times a volatile is read: 7
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 74
XXX percentage of non-volatile access: 99

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 114
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 26
   depth: 2, occurrence: 25
   depth: 3, occurrence: 13
   depth: 4, occurrence: 13
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 17.8
XXX percentage an existing variable is used: 82.2
********************* end of statistics **********************/

