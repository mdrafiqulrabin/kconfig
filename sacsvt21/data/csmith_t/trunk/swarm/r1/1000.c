/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1676809768
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 2;
};

/* --- GLOBAL VARIABLES --- */
static float g_7 = 0x8.8B108Fp+10;
static int32_t g_15 = (-1);
static uint32_t g_133 = 0xA77380A6;
static float g_151 = 0x9.667C2Dp-10;
static struct S0 g_156 = {0};
static int32_t g_319 = 0;
static uint16_t g_322 = 65535U;
static uint32_t g_448 = 0x22B81ACE;
static struct S0 g_482 = {1};
static int16_t g_496 = 0x8239;


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_27(void);
static uint32_t  func_32(uint16_t  p_33, uint32_t  p_34, const uint32_t  p_35, uint16_t  p_36);
static int16_t  func_39(uint16_t  p_40, uint16_t  p_41, uint32_t  p_42);
static int16_t  func_43(const uint16_t  p_44);
static int16_t  func_47(uint32_t  p_48, struct S0  p_49, float  p_50);
static int32_t  func_51(float  p_52, uint32_t  p_53, int32_t  p_54, int32_t  p_55, uint32_t  p_56);
static float  func_67(int32_t  p_68, int32_t  p_69, struct S0  p_70);
static uint16_t  func_76(float  p_77, int32_t  p_78, int32_t  p_79, uint32_t  p_80);
static uint32_t  func_81(uint32_t  p_82, int16_t  p_83);
static uint16_t  func_99(uint32_t  p_100, int16_t  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_15 g_133 g_156.f0 g_156 g_7 g_322 g_319 g_448 g_482 g_496
 * writes: g_7 g_133 g_156 g_151 g_319 g_322 g_482
 */
static uint16_t  func_27(void)
{ /* block id: 36 */
    int32_t l_37 = 0;
    struct S0 l_71 = {1};
    uint16_t l_467 = 0x4ABC;
    int32_t l_494 = 0x9F4D4497;
    int32_t l_502 = 2;
    if (((uint16_t)((uint32_t)((func_32((l_37 == l_37), (((-(int16_t)func_39(g_15, (l_37 & func_43(((int16_t)func_47((func_51((((float)((float)((float)((0x3.214F16p-64 > 0x1.3p+1) > ((float)0x0.Cp-1 - (float)((float)g_15 - (float)((func_67(l_37, g_15, l_71) <= g_448) == l_71.f0)))) + (float)0x0.6p-1) - (float)l_467) + (float)l_37) < 0xF.FE5F93p+96), l_467, l_71.f0, g_448, g_448) > g_448), g_482, l_467) % (int16_t)l_494))), g_496)) ^ 1) <= l_37), g_496, l_37) & 1) < l_37) - (uint32_t)g_15) % (uint16_t)65533U))
    { /* block id: 281 */
        struct S0 l_498 = {-0};
        g_482 = l_71;
        g_482 = l_498;
        g_482.f0 = ((uint16_t)((+0x3182638C) <= (1 > l_502)) % (uint16_t)l_494);
    }
    else
    { /* block id: 285 */
        return g_319;
    }
    g_319 = 0x5097E263;
    return l_71.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_7
 * writes:
 */
static uint32_t  func_32(uint16_t  p_33, uint32_t  p_34, const uint32_t  p_35, uint16_t  p_36)
{ /* block id: 278 */
    uint32_t l_497 = 4294967295U;
    l_497 = g_7;
    return l_497;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_39(uint16_t  p_40, uint16_t  p_41, uint32_t  p_42)
{ /* block id: 276 */
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_43(const uint16_t  p_44)
{ /* block id: 273 */
    int16_t l_495 = 0x27C3;
    l_495 = (p_44 != 0x2.B89E42p-47);
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads : g_156.f0 g_15 g_133 g_156 g_7 g_448 g_319 g_322
 * writes: g_7 g_133 g_156 g_151
 */
static int16_t  func_47(uint32_t  p_48, struct S0  p_49, float  p_50)
{ /* block id: 268 */
    int16_t l_483 = 0;
    uint32_t l_492 = 0xF1BFF009;
    int32_t l_493 = 0xE4D90370;
    l_483 = g_156.f0;
    p_50 = (p_50 <= (l_483 >= (((float)((float)((func_99(l_483, g_15) != ((((((float)0x2.CA536Fp-3 + (float)g_448) >= (((0x7.95881Ap+75 >= ((float)((l_483 >= p_48) <= l_492) + (float)g_15)) <= l_492) >= l_492)) >= p_49.f0) > g_448) < l_483)) >= l_483) - (float)0xF.AA0D40p-72) + (float)g_319) > g_322)));
    l_493 = (0 > p_49.f0);
    return g_319;
}


/* ------------------------------------------ */
/* 
 * reads : g_156.f0 g_448 g_133 g_15 g_156 g_7 g_319
 * writes: g_7 g_133 g_156 g_151 g_319
 */
static int32_t  func_51(float  p_52, uint32_t  p_53, int32_t  p_54, int32_t  p_55, uint32_t  p_56)
{ /* block id: 255 */
    int32_t l_468 = 1;
    struct S0 l_481 = {0};
    p_52 = (((l_468 != ((float)0x8.01941Dp-22 + (float)0x1.7p-1)) == ((float)(func_99(g_156.f0, (g_156.f0 <= ((int32_t)(__builtin_ctzl(g_448) != g_133) - (int32_t)((int32_t)g_156.f0 % (int32_t)1U)))) >= g_448) + (float)l_468)) <= (-0x8.Fp+1));
    for (g_319 = 0; (g_319 < 22); g_319 += 2)
    { /* block id: 259 */
        for (g_133 = (-21); (g_133 > 60); ++g_133)
        { /* block id: 262 */
            l_481 = g_156;
        }
    }
    l_481.f0 = (l_468 <= l_481.f0);
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_133 g_156.f0 g_156 g_7 g_322 g_319 g_448
 * writes: g_7 g_133 g_156 g_151 g_319 g_322
 */
static float  func_67(int32_t  p_68, int32_t  p_69, struct S0  p_70)
{ /* block id: 37 */
    int32_t l_73 = (-1);
    int32_t l_94 = 0xACAEC2B2;
    int32_t l_466 = (-6);
    if ((p_68 != (!l_73)))
    { /* block id: 38 */
        int32_t l_449 = 7;
        l_449 = ((uint16_t)func_76(g_15, (g_15 == (func_81((((uint16_t)g_15 + (uint16_t)p_68) ^ ((uint32_t)(((((int16_t)g_15 - (int16_t)g_15) == ((0xF9898791 & (((int32_t)3 % (int32_t)(0x5901 || 0xBC64)) && l_94)) != 0x302D)) != p_69) & l_73) + (uint32_t)p_68)), p_69) | l_73)), g_15, l_94) << (uint16_t)l_449);
        p_70.f0 = (((uint32_t)1U + (uint32_t)(0xBFD2 != (((uint16_t)p_68 + (uint16_t)((int16_t)(-5) >> (int16_t)g_448)) || (func_81(p_69, g_319) != ((((uint16_t)(((int16_t)((uint16_t)(((int16_t)((p_69 <= 0x30DA) <= 0xF85F3CF5) >> (int16_t)13) | p_69) >> (uint16_t)p_69) >> (int16_t)g_322) < l_94) % (uint16_t)g_448) < p_68) != 0x5402))))) < g_15);
    }
    else
    { /* block id: 247 */
        for (g_322 = 0; (g_322 == 43); g_322 += 1)
        { /* block id: 250 */
            l_466 = (g_7 == p_68);
        }
    }
    return g_448;
}


/* ------------------------------------------ */
/* 
 * reads : g_319 g_133 g_15 g_322 g_156.f0 g_156 g_7 g_448
 * writes: g_7 g_133 g_156 g_151 g_319
 */
static uint16_t  func_76(float  p_77, int32_t  p_78, int32_t  p_79, uint32_t  p_80)
{ /* block id: 222 */
    uint32_t l_402 = 0x036B767B;
    float l_415 = (-0x6.4p+1);
    int32_t l_421 = 0xA1B3EB41;
    for (p_80 = 0; (p_80 < 25); ++p_80)
    { /* block id: 225 */
        uint32_t l_392 = 0U;
        int32_t l_401 = 0x41199389;
        l_402 = (((float)(0xC.9E3581p-64 == ((-(float)((l_392 == ((float)0x4.FD3BF1p+39 - (float)((float)__builtin_popcount(((int16_t)(g_319 & (func_99(g_133, ((uint16_t)p_79 - (uint16_t)((-1) & ((((g_15 <= (0xC38B < l_392)) <= 0) && g_322) || l_392)))) == 2)) << (int16_t)p_78)) + (float)0x1.2p-1))) > 0x5.513D34p+93)) == l_401)) + (float)g_15) > l_392);
        p_78 = (((((int16_t)func_81(p_80, l_401) + (int16_t)__builtin_parityl((((int16_t)__builtin_parity(((uint32_t)((g_15 <= g_15) > 0x3F8E) - (uint32_t)((uint16_t)l_392 << (uint16_t)2))) + (int16_t)((int16_t)(4294967294U ^ p_80) >> (int16_t)g_15)) || 0x6D7F0A69))) <= g_15) >= l_392) > l_402);
    }
    l_421 = ((__builtin_ctzl(l_402) <= ((float)((l_415 >= ((((((float)(!p_77) - (float)0x1.4204E5p-47) < p_80) >= 0x5.7AB3F3p-59) <= ((float)p_78 - (float)((__builtin_ffs(p_80) >= l_402) != 0xE.F17299p-91))) == (-0x1.Ap-1))) <= g_7) + (float)g_319)) == 0x1.F625D8p-17);
    p_77 = func_99(g_322, (((l_421 >= ((l_421 && (l_402 & 0xF912)) || (((int32_t)((((-7) && p_79) < (((int32_t)(g_322 <= l_421) % (int32_t)p_79) | 9)) & p_80) + (int32_t)1) <= 6U))) >= p_78) & (-5)));
    if (p_78)
    { /* block id: 231 */
        int16_t l_433 = 0x0854;
        const struct S0 l_434 = {1};
        struct S0 l_435 = {0};
        p_78 = (((uint16_t)((int32_t)0 + (int32_t)(((int16_t)(~l_433) % (int16_t)(65529U || p_79)) >= g_15)) << (uint16_t)g_133) < (p_79 > (l_433 >= 0x2D5834FC)));
        l_435 = l_434;
    }
    else
    { /* block id: 234 */
        float l_442 = 0x0.5p-1;
        int32_t l_443 = (-1);
        p_78 = ((uint16_t)(((1 == 0x5C3F50D5) >= p_79) | (__builtin_popcount((((int16_t)((int16_t)__builtin_parityl(g_322) << (int16_t)10) % (int16_t)g_133) > l_443)) == (l_443 < l_443))) >> (uint16_t)4);
        l_443 = p_77;
        for (p_80 = 0; (p_80 < 17); ++p_80)
        { /* block id: 239 */
            g_7 = (0x9.E40A83p+27 >= (p_79 > (g_322 > g_322)));
            l_421 = (!(-(uint32_t)(0U | g_15)));
        }
    }
    return g_448;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_133 g_156.f0 g_156 g_7 g_322 g_319
 * writes: g_7 g_133 g_156 g_151 g_319
 */
static uint32_t  func_81(uint32_t  p_82, int16_t  p_83)
{ /* block id: 39 */
    uint32_t l_106 = 0x3A768FB0;
    struct S0 l_252 = {-0};
    for (p_83 = 0; (p_83 < 17); p_83 += 4)
    { /* block id: 42 */
        const int16_t l_107 = (-1);
        int32_t l_119 = 0x173B00C6;
        int16_t l_250 = 1;
        uint32_t l_269 = 4294967291U;
        struct S0 l_342 = {-0};
        if ((((int16_t)p_83 % (int16_t)0xEE4F) >= ((func_99(((g_15 & (((uint16_t)(((0x5F1D < p_83) > ((uint16_t)(l_106 != l_107) >> (uint16_t)11)) <= p_82) >> (uint16_t)9) | (((uint32_t)(((int32_t)((((uint16_t)((uint16_t)((int16_t)((~p_83) & p_83) << (int16_t)g_15) << (uint16_t)6) - (uint16_t)l_106) != p_82) && 0x74CA) % (int32_t)0x6835AC29) && l_119) % (uint32_t)(-1)) >= 1U))) & g_15), g_15) == p_83) <= 0xACB6)))
        { /* block id: 133 */
            uint32_t l_249 = 1U;
            for (p_82 = 0; (p_82 <= 25); p_82 += 4)
            { /* block id: 136 */
                uint32_t l_251 = 4294967295U;
                l_251 = (((uint16_t)(p_82 >= ((((uint16_t)p_83 % (uint16_t)__builtin_ctzl(p_83)) > 8U) == (p_82 ^ ((((p_83 <= ((int16_t)l_119 - (int16_t)((-(int32_t)0xA33B8ED1) ^ g_156.f0))) < g_156.f0) && l_249) != g_133)))) % (uint16_t)l_250) <= p_82);
                g_156 = l_252;
            }
            g_156.f0 = l_250;
        }
        else
        { /* block id: 141 */
            int32_t l_257 = (-1);
            l_252.f0 = p_82;
            for (g_133 = 1; (g_133 == 36); g_133++)
            { /* block id: 145 */
                g_151 = 0x4.9BF21Dp-75;
                g_7 = (((float)l_257 - (float)p_82) >= p_83);
                if (p_82)
                    break;
            }
        }
        l_252.f0 = (__builtin_ffsl((((int16_t)(g_133 <= __builtin_clzll((g_156.f0 > ((uint32_t)0x8A72973F + (uint32_t)(((g_15 == ((uint16_t)((uint16_t)((uint32_t)(+g_156.f0) % (uint32_t)p_83) + (uint16_t)(2U || (p_83 || p_83))) % (uint16_t)(-1))) | g_156.f0) < l_269))))) >> (int16_t)5) < l_252.f0)) | 0x173F1819);
        for (l_269 = 0; (l_269 > 40); ++l_269)
        { /* block id: 154 */
            return p_82;
        }
        if (l_269)
        { /* block id: 157 */
            uint32_t l_284 = 0xE9A1A128;
            int32_t l_356 = (-1);
            if (g_156.f0)
            { /* block id: 158 */
                int16_t l_317 = 0x9E67;
                int32_t l_330 = 0x39C4DF7F;
                if (((int16_t)p_83 << (int16_t)7))
                { /* block id: 159 */
                    uint32_t l_274 = 0x9EC935B3;
                    int32_t l_298 = (-1);
                    l_274 = (-1);
                    l_252 = l_252;
                    g_156 = g_156;
                    if ((__builtin_popcount(((int16_t)p_82 >> (int16_t)(g_156.f0 || g_15))) != ((((((int16_t)p_83 + (int16_t)g_15) & ((uint32_t)((0xC8DC0C5F & ((+(g_156.f0 > (g_15 && l_274))) && 0xD838E576)) || g_156.f0) - (uint32_t)0x4B138E73)) | g_133) == 0x8BB56DCD) != p_83)))
                    { /* block id: 163 */
                        g_156 = g_156;
                        l_298 = ((uint32_t)(l_269 > l_284) - (uint32_t)__builtin_ffsl((0x9645 <= (((uint32_t)p_83 + (uint32_t)((((uint16_t)((g_156.f0 || __builtin_bswap32(((int32_t)(!65535U) - (int32_t)((int16_t)(g_15 < ((int32_t)0x9E970FD2 + (int32_t)((int32_t)0xBCB941C5 - (int32_t)p_83))) % (int16_t)l_250)))) != 0x8632) << (uint16_t)2) & p_83) < p_82)) >= g_156.f0))));
                    }
                    else
                    { /* block id: 166 */
                        uint16_t l_318 = 9U;
                        uint16_t l_339 = 0xC249;
                        g_319 = __builtin_clz(((((l_106 || l_252.f0) > func_99(func_99(g_133, ((((uint16_t)((uint32_t)((4294967295U != ((uint16_t)(((int32_t)4 % (int32_t)((uint16_t)g_15 - (uint16_t)((int16_t)((uint16_t)((((int16_t)((int32_t)l_317 - (int32_t)l_317) % (int16_t)g_156.f0) == g_133) == g_15) << (uint16_t)l_318) << (int16_t)g_133))) <= p_82) >> (uint16_t)g_15)) == p_83) + (uint32_t)p_83) << (uint16_t)3) == 4294967295U) >= g_133)), l_318)) | 0xFD50) ^ (-7)));
                        l_330 = (0x7.535091p-36 == (((float)(-0x5.5p+1) - (float)g_322) < (l_106 > ((-(float)func_99(l_274, ((int32_t)l_318 % (int32_t)((((!(((((int32_t)(+((0 || (((__builtin_bswap64(g_15) != p_82) > g_15) & p_82)) < (-1))) - (int32_t)p_83) && 0xB64537C1) >= g_319) == 0x185503AD)) <= g_156.f0) != p_82) && g_319)))) >= 0x4.475195p+79))));
                        l_252.f0 = ((__builtin_clzll((l_317 < (((uint16_t)p_83 << (uint16_t)l_274) >= g_156.f0))) && 6U) ^ ((l_250 | (((int16_t)p_83 + (int16_t)g_156.f0) ^ 65529U)) | g_319));
                        g_151 = ((g_156.f0 < (p_83 == __builtin_clzl(((uint16_t)((int32_t)l_107 - (int32_t)l_339) << (uint16_t)l_119)))) > g_7);
                    }
                }
                else
                { /* block id: 172 */
                    g_156.f0 = p_83;
                    for (l_269 = 0; (l_269 >= 57); l_269 += 9)
                    { /* block id: 176 */
                        return p_82;
                    }
                }
                g_319 = 0xDF8891E8;
                if (l_119)
                    break;
            }
            else
            { /* block id: 182 */
                g_156 = l_342;
            }
            for (l_250 = 0; (l_250 == (-29)); l_250 -= 4)
            { /* block id: 187 */
                struct S0 l_345 = {0};
                l_345 = g_156;
                if (l_342.f0)
                { /* block id: 189 */
                    float l_346 = 0x2.93EE43p+46;
                    int32_t l_353 = (-7);
                    l_356 = ((g_156.f0 || p_82) || (func_99(l_345.f0, (((uint16_t)(8U | __builtin_clzll(((int16_t)0x7C2A >> (int16_t)func_99(((int16_t)(l_353 < g_319) << (int16_t)g_156.f0), ((uint16_t)(((p_82 != g_133) ^ g_133) | g_133) + (uint16_t)g_319))))) - (uint16_t)l_345.f0) && g_133)) ^ g_15));
                    g_319 = __builtin_popcountl(((uint16_t)__builtin_bswap64(l_284) << (uint16_t)3));
                }
                else
                { /* block id: 192 */
                    g_7 = l_119;
                }
            }
            return l_119;
        }
        else
        { /* block id: 197 */
            int16_t l_372 = 0xEDAA;
            float l_379 = 0xF.B989AAp-41;
            struct S0 l_383 = {-0};
            g_156.f0 = 0x69C6D1A9;
            g_156 = g_156;
            if (g_319)
            { /* block id: 200 */
                return l_106;
            }
            else
            { /* block id: 202 */
                int32_t l_365 = 0x1546A55D;
                g_156.f0 = ((l_106 == (l_269 >= __builtin_ctzl(g_133))) != (((uint16_t)g_133 % (uint16_t)l_106) && ((int16_t)(((int16_t)l_365 << (int16_t)((uint16_t)l_365 << (uint16_t)(p_82 | l_252.f0))) == p_82) - (int16_t)l_252.f0)));
                if (((int32_t)((uint16_t)l_106 >> (uint16_t)__builtin_parityll(((g_15 <= (g_133 != (l_372 <= ((((l_252.f0 >= ((uint16_t)l_119 >> (uint16_t)4)) >= l_119) | ((((uint16_t)(((((uint16_t)__builtin_ctz(l_250) << (uint16_t)3) < l_252.f0) != g_133) < 0xEC12) << (uint16_t)g_322) >= 0xEAAC) | 4294967295U)) && p_82)))) && l_106))) - (int32_t)l_372))
                { /* block id: 204 */
                    uint32_t l_382 = 0xB2C4312D;
                    l_365 = ((uint32_t)g_156.f0 + (uint32_t)(g_133 | __builtin_parity(p_82)));
                    if (g_319)
                    { /* block id: 206 */
                        l_365 = l_382;
                        l_252.f0 = (p_82 > p_82);
                        g_156.f0 = l_365;
                    }
                    else
                    { /* block id: 210 */
                        g_156 = l_383;
                    }
                }
                else
                { /* block id: 213 */
                    struct S0 l_386 = {-0};
                    l_342 = g_156;
                    l_383.f0 = (0xDE12 == (((int16_t)g_133 % (int16_t)0x7EDD) | (g_133 == __builtin_clzll(l_107))));
                    g_156 = l_386;
                }
            }
        }
    }
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_133 g_156.f0 g_156 g_7
 * writes: g_7 g_133 g_156 g_151
 */
static uint16_t  func_99(uint32_t  p_100, int16_t  p_101)
{ /* block id: 43 */
    int16_t l_121 = 0;
    int32_t l_152 = 0x2900EB00;
    int32_t l_168 = 6;
    struct S0 l_182 = {1};
    g_7 = (-(float)l_121);
    for (l_121 = 0; (l_121 >= (-16)); l_121 -= 3)
    { /* block id: 47 */
        int32_t l_124 = 0xA90DD067;
        struct S0 l_170 = {1};
        int32_t l_226 = 0x3F5DAB0F;
        l_124 = 2;
        g_133 = ((int16_t)((__builtin_ctzll(p_100) >= 0x152899D3) != ((uint16_t)(0xB4F9 != ((((uint32_t)l_121 + (uint32_t)p_100) & ((uint32_t)p_100 + (uint32_t)(g_15 & __builtin_popcountl((__builtin_clz(((((p_101 > l_124) == (-7)) > 0x3FBE) & 0U)) >= g_15))))) ^ l_124)) << (uint16_t)15)) + (int16_t)p_101);
        if ((((int32_t)(((p_101 <= ((int32_t)l_121 - (int32_t)p_100)) | 1U) && ((p_100 | ((((int16_t)((int16_t)(-10) + (int16_t)(((uint16_t)g_15 % (uint16_t)((uint16_t)(((uint16_t)65535U << (uint16_t)((uint16_t)l_121 << (uint16_t)l_124)) | p_100) + (uint16_t)g_15)) > 0x15AC0CBF)) - (int16_t)0x5C77) != g_133) != p_101)) && 1)) + (int32_t)4294967295U) != l_124))
        { /* block id: 50 */
            int16_t l_150 = (-1);
            struct S0 l_155 = {-1};
            const float l_167 = 0x1.Fp-1;
            float l_169 = 0x0.2p-1;
            l_152 = l_150;
            for (g_133 = 0; (g_133 == 44); g_133 += 6)
            { /* block id: 54 */
                g_156 = l_155;
            }
            if ((((((((0 <= ((int16_t)((0xA53783AD <= ((int16_t)(4U >= g_15) >> (int16_t)7)) && (((((int16_t)0 + (int16_t)((int16_t)(g_133 < 4294967294U) % (int16_t)p_101)) || ((int32_t)0xF9C57FF4 - (int32_t)g_156.f0)) ^ l_168) | l_124)) << (int16_t)8)) > l_152) > g_156.f0) == l_124) | g_15) & 4294967286U) != p_101))
            { /* block id: 57 */
                const int32_t l_181 = 3;
                int32_t l_189 = 0x0EE989E9;
                struct S0 l_197 = {0};
                l_170 = g_156;
                if ((g_15 ^ 0xA42F98E8))
                { /* block id: 59 */
                    for (g_133 = (-28); (g_133 <= 16); g_133 += 1)
                    { /* block id: 62 */
                        return g_156.f0;
                    }
                    if (p_101)
                        break;
                    l_124 = ((uint16_t)0xF119 << (uint16_t)3);
                    return l_150;
                }
                else
                { /* block id: 68 */
                    struct S0 l_178 = {-1};
                    for (l_124 = 0; (l_124 <= 4); l_124 += 6)
                    { /* block id: 71 */
                        struct S0 l_177 = {0};
                        g_156.f0 = g_15;
                        l_177 = l_155;
                        l_178 = g_156;
                    }
                }
                if (((uint16_t)l_124 >> (uint16_t)13))
                { /* block id: 77 */
                    uint32_t l_192 = 0U;
                    g_156 = g_156;
                    if ((l_181 && p_101))
                    { /* block id: 79 */
                        if (p_101)
                            break;
                        g_156 = l_182;
                        l_182.f0 = ((__builtin_parityll(p_100) <= __builtin_ffsll(p_100)) >= 0x1.1p+1);
                    }
                    else
                    { /* block id: 83 */
                        l_189 = ((int16_t)(((int16_t)((0x8397568C > (-1)) == p_101) << (int16_t)3) ^ p_101) - (int16_t)(((0x506553B8 < l_155.f0) & p_101) == ((uint16_t)p_100 << (uint16_t)4)));
                        if (g_15)
                            continue;
                        g_156.f0 = ((uint16_t)p_101 << (uint16_t)l_192);
                    }
                    for (p_101 = (-4); (p_101 < (-25)); p_101--)
                    { /* block id: 90 */
                        uint32_t l_195 = 4294967295U;
                        l_195 = 0x4D5004DB;
                        if (p_101)
                            continue;
                    }
                }
                else
                { /* block id: 94 */
                    struct S0 l_196 = {-0};
                    l_196 = l_170;
                    l_197 = l_170;
                    l_196.f0 = p_101;
                }
            }
            else
            { /* block id: 99 */
                int32_t l_221 = 0x75342E7D;
                g_156.f0 = l_121;
                for (l_124 = 20; (l_124 < 15); l_124 -= 7)
                { /* block id: 103 */
                    int32_t l_203 = 1;
                    if ((p_100 >= ((int16_t)((p_101 <= (-(int32_t)(g_133 >= l_203))) & (((g_133 <= ((uint16_t)g_156.f0 + (uint16_t)((uint32_t)p_101 % (uint32_t)g_15))) & (((uint16_t)((uint16_t)((((((int16_t)l_203 << (int16_t)p_101) != 0x2853) & 0xD532) <= p_100) <= g_133) >> (uint16_t)14) - (uint16_t)0x701C) || p_100)) != p_100)) >> (int16_t)g_156.f0)))
                    { /* block id: 104 */
                        struct S0 l_220 = {0};
                        g_156.f0 = ((int16_t)(65527U & ((int16_t)p_101 << (int16_t)7)) % (int16_t)((l_150 || (__builtin_ffsl(g_15) != p_100)) | ((uint16_t)4U << (uint16_t)3)));
                        g_156 = l_220;
                        g_156 = l_170;
                        l_221 = (0 ^ 6U);
                    }
                    else
                    { /* block id: 109 */
                        return l_155.f0;
                    }
                }
                l_182.f0 = (__builtin_ctzll((((uint32_t)(((uint16_t)(g_15 & g_133) - (uint16_t)(__builtin_ia32_crc32qi(l_221, ((l_152 != p_101) < g_15)) != (l_155.f0 >= ((((((-4) >= l_221) & g_133) == l_221) < g_156.f0) < l_221)))) && l_226) + (uint32_t)4294967286U) != 0xE4936EB0)) >= l_150);
            }
            for (p_100 = 0; (p_100 <= 30); p_100 += 1)
            { /* block id: 117 */
                l_155.f0 = (((p_101 != (+(p_101 && ((uint32_t)(((((int16_t)(g_133 == (0U & (g_15 >= ((int16_t)l_121 << (int16_t)10)))) >> (int16_t)g_133) > ((int32_t)g_15 + (int32_t)(l_168 < g_156.f0))) < (-1)) == g_15) % (uint32_t)p_100)))) <= 0U) & p_100);
                return p_100;
            }
        }
        else
        { /* block id: 121 */
            g_151 = ((g_156.f0 > 0x6.Ap+1) < g_7);
            l_170 = l_182;
        }
    }
    for (l_168 = (-19); (l_168 < (-25)); --l_168)
    { /* block id: 128 */
        return p_100;
    }
    l_182.f0 = 0xC.DD16FCp+47;
    return p_101;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc_bytes (&g_7, sizeof(g_7), "g_7", print_hash_value);
    transparent_crc(g_15, "g_15", print_hash_value);
    transparent_crc(g_133, "g_133", print_hash_value);
    transparent_crc_bytes (&g_151, sizeof(g_151), "g_151", print_hash_value);
    transparent_crc(g_156.f0, "g_156.f0", print_hash_value);
    transparent_crc(g_319, "g_319", print_hash_value);
    transparent_crc(g_322, "g_322", print_hash_value);
    transparent_crc(g_448, "g_448", print_hash_value);
    transparent_crc(g_482.f0, "g_482.f0", print_hash_value);
    transparent_crc(g_496, "g_496", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 71
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX full-bitfields structs in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 25
XXX times a bitfields struct on RHS: 27
XXX times a single bitfield on LHS: 22
XXX times a single bitfield on RHS: 49

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 167
   depth: 2, occurrence: 33
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 5
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 3
   depth: 26, occurrence: 2
   depth: 40, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 500
XXX times a non-volatile is write: 107
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 151
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 23
   depth: 2, occurrence: 21
   depth: 3, occurrence: 23
   depth: 4, occurrence: 26
   depth: 5, occurrence: 28

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

