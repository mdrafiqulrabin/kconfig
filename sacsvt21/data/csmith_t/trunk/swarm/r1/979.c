/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1287322404
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const uint32_t  func_34(void);
static int16_t  func_40(const int32_t  p_41, const int32_t  p_42, uint32_t  p_43);
static int16_t  func_46(int32_t  p_47, int32_t  p_48);
static uint32_t  func_61(int16_t  p_62, int32_t * p_63, const int32_t * p_64, uint64_t  p_65);
static int16_t  func_71(uint64_t  p_72, int32_t * p_73, int32_t * p_74, int32_t * p_75);
inline static int32_t * func_76(int32_t * const  p_77);
static int32_t * func_78(int32_t * p_79, uint64_t  p_80, const int64_t  p_81, int32_t  p_82, const int32_t  p_83);
inline static int32_t * func_84(int32_t * p_85, const float  p_86);
static int32_t * func_87(uint32_t  p_88, int32_t * p_89);
inline static int64_t  func_90(int64_t  p_91, int32_t * p_92, int32_t  p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint32_t  func_34(void)
{ /* block id: 36 */
    uint32_t l_35 = 0UL;
    int32_t l_428 = 0x20350C09L;
    int32_t *l_429 = &l_428;
    const uint64_t l_430 = 0UL;
    (*l_429) = ((l_35 , ((uint64_t)(((int16_t)func_40(l_35, l_35, ((((((((((int16_t)(l_35 , (l_35 , func_46(((((int64_t)((int16_t)(((uint32_t)(l_35 != ((uint16_t)l_35 + (uint16_t)l_35)) % (uint32_t)((int64_t)l_35 - (int64_t)0x7511ECBFCF419C2BLL)) , (-1L)) >> (int16_t)l_35) % (int64_t)0x679BDD86BDAE8940LL) , (-9L)) , 3L), l_35))) * (int16_t)65527UL) || l_35) , 0x84F3L) && l_35) < l_35) , l_35) , l_35) == l_35) , 0UL)) << (int16_t)l_35) , 0x6C8E1A1BED76A3A4LL) % (uint64_t)l_428)) == 4L);
    (*l_429) = (*l_429);
    return l_430;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_40(const int32_t  p_41, const int32_t  p_42, uint32_t  p_43)
{ /* block id: 118 */
    const float l_243 = 0x0.9p+1;
    const float *l_242 = &l_243;
    const float **l_241 = &l_242;
    float l_247 = 0x0.3p-1;
    float * const l_246 = &l_247;
    float * const *l_245 = &l_246;
    float * const **l_244 = &l_245;
    int32_t l_251 = 0xB660035EL;
    int32_t l_283 = (-1L);
    int32_t *l_313 = &l_283;
    int16_t l_400 = 0xDD8AL;
    uint32_t l_404 = 0x42A023E6L;
    int64_t l_407 = 0L;
    int32_t l_425 = 0x7E6215E6L;
    int32_t l_427 = (-6L);
    (*l_244) = l_241;
    (*l_246) = ((float)(!l_251) / (float)0x4.F3C619p+79);
    for (l_251 = 6; (l_251 == (-5)); l_251 -= 7)
    { /* block id: 123 */
        int32_t *l_256 = (void*)0;
        int32_t **l_255 = &l_256;
        int32_t ***l_254 = &l_255;
        int64_t l_257 = 3L;
        const uint32_t l_272 = 0x38A55269L;
        uint64_t l_311 = 0x5B44177A3353FAB7LL;
        int16_t l_321 = 4L;
        float l_371 = (-0x1.8p+1);
        uint64_t l_398 = 0xCA189BC5BAC3DFB1LL;
        if (((void*)0 == l_254))
        { /* block id: 124 */
            return l_257;
        }
        else
        { /* block id: 126 */
            int16_t l_258 = 1L;
            int32_t *l_293 = (void*)0;
            int32_t ***l_298 = &l_255;
            float *l_333 = &l_247;
            float **l_332 = &l_333;
            float ** const *l_331 = &l_332;
            int32_t l_373 = 0xDA7329BDL;
            int64_t l_401 = 1L;
            if (l_258)
                break;
            for (l_258 = (-29); (l_258 < 16); l_258 += 1)
            { /* block id: 130 */
                uint32_t l_267 = 0UL;
                int32_t l_269 = 0x7F249042L;
                int32_t *l_268 = &l_269;
                float * const **l_334 = &l_245;
                uint16_t l_343 = 0xD3A6L;
                (*l_268) = (((p_41 && (((int32_t)((uint16_t)(p_43 & (0x94E36BB2AB673122LL != (((uint16_t)p_43 * (uint16_t)(p_42 == 0xB60AC72209DD6967LL)) >= 65528UL))) << (uint16_t)p_43) % (int32_t)l_267) != 0xF7C30530C7A2D7FELL)) ^ 0x6FCF5082L) | p_41);
                for (l_269 = (-20); (l_269 > 1); l_269 += 5)
                { /* block id: 134 */
                    uint32_t l_273 = 1UL;
                    int32_t * const l_305 = &l_251;
                    int32_t *l_306 = &l_283;
                    int32_t *l_316 = &l_283;
                    if (l_272)
                    { /* block id: 135 */
                        if (l_273)
                            break;
                        if (p_42)
                            continue;
                    }
                    else
                    { /* block id: 138 */
                        uint16_t l_278 = 2UL;
                        int32_t *l_284 = (void*)0;
                        l_283 = ((float)((float)(*l_268) - (float)l_278) - (float)((((float)(+(-0x1.Ap+1)) / (float)(-(float)p_43)) == p_42) != p_42));
                        (*l_255) = l_284;
                        l_293 = ((0xE7E30283L != (p_43 , ((int16_t)(l_273 , ((((uint16_t)p_41 / (uint16_t)p_42) && __builtin_popcountl(p_41)) != ((uint16_t)(p_42 , ((uint16_t)p_42 >> (uint16_t)p_42)) << (uint16_t)12))) >> (int16_t)6))) , (void*)0);
                    }
                    l_306 = (p_41 , func_78(func_78(func_76((((((uint32_t)((uint16_t)1UL << (uint16_t)(((((((l_298 != &l_255) , ((-9L) > ((uint16_t)l_273 * (uint16_t)((uint32_t)(p_43 , (((uint16_t)__builtin_ffs(((l_273 <= 1L) >= p_43)) - (uint16_t)(*l_268)) > (*l_268))) + (uint32_t)p_43)))) , 0x1.8p-1) >= 0xA.358170p+57) , l_283) , 0x97C0A964B6351B0FLL) | 0xA3D0280CFF7C043BLL)) + (uint32_t)p_42) <= p_43) >= (*l_268)) , l_305)), (*l_305), l_283, (*l_268), (*l_268)), l_283, (*l_268), p_43, p_41));
                    l_313 = func_87(((((int32_t)(((int32_t)(*l_305) + (int32_t)l_311) != 0x275B194EL) % (int32_t)(~l_283)) ^ ((*l_305) , l_283)) && l_283), &l_251);
                    (*l_316) |= ((int16_t)0x8919L << (int16_t)15);
                }
                (*l_268) &= ((int16_t)(-1L) << (int16_t)10);
                (*l_255) = ((4294967295UL <= ((l_321 == ((uint64_t)((int32_t)((int64_t)((!((*l_268) >= (*l_268))) & (l_331 == l_334)) - (int64_t)(((uint32_t)((((uint16_t)p_42 >> (uint16_t)p_42) || ((uint64_t)((int32_t)(l_343 < p_41) / (int32_t)p_43) + (uint64_t)0xE88F4ACA7994EB94LL)) <= p_43) / (uint32_t)0xCE81F14CL) , p_41)) + (int32_t)p_42) / (uint64_t)p_42)) < p_41)) , &l_283);
            }
            if ((((uint16_t)((uint32_t)p_42 % (uint32_t)p_41) % (uint16_t)0xC166L) && (((int64_t)func_46(p_42, ((int16_t)l_251 * (int16_t)p_43)) / (int64_t)__builtin_clz(p_42)) != 1UL)))
            { /* block id: 150 */
                uint64_t l_357 = 18446744073709551608UL;
                int32_t *l_360 = &l_251;
                int16_t l_369 = 0x3F98L;
                for (l_257 = 0; (l_257 != 18); l_257 += 9)
                { /* block id: 153 */
                    float l_356 = 0x7.9p+1;
                    int32_t l_370 = 4L;
                    int32_t *l_372 = &l_370;
                    for (l_321 = 0; (l_321 != (-6)); l_321 -= 1)
                    { /* block id: 156 */
                        l_357 |= p_43;
                    }
                    (*l_372) = (func_90(((((int16_t)(l_370 != l_258) / (int16_t)0x5124L) , (*l_360)) > 0xDAF6430CB2AB0A6CLL), &l_370, (*l_360)) , (-1L));
                }
                if (p_41)
                    continue;
                l_373 = (*l_360);
                (**l_332) = ((float)(p_43 == ((float)((float)0xA.377B2Bp-25 - (float)p_41) * (float)(((*l_360) >= 6UL) , 0x3.E55590p-84))) + (float)((*l_255) != (void*)0));
            }
            else
            { /* block id: 164 */
                int32_t l_399 = 1L;
                int32_t **** const l_402 = &l_298;
                for (l_321 = 0; (l_321 >= 28); l_321 += 9)
                { /* block id: 167 */
                    uint32_t l_388 = 0x6CE5F64FL;
                    uint32_t l_395 = 0x23B56AE9L;
                    int32_t *l_396 = (void*)0;
                    int32_t *l_397 = (void*)0;
                    if (((((((p_43 , func_46(((l_400 || 1UL) , l_401), l_399)) , l_402) != (void*)0) ^ 0x31EC438BL) || 0xCF7F315CL) && 0x3883B9D3L))
                    { /* block id: 168 */
                        int32_t *l_403 = &l_373;
                        (*l_403) = 2L;
                    }
                    else
                    { /* block id: 170 */
                        l_404 &= p_41;
                    }
                    for (l_400 = 0; (l_400 < (-27)); l_400 -= 9)
                    { /* block id: 175 */
                        return p_43;
                    }
                }
                if (l_407)
                    break;
            }
        }
        for (l_311 = 0; (l_311 == 30); l_311 += 1)
        { /* block id: 184 */
            uint32_t l_414 = 0x296ACBEDL;
            int32_t * const l_426 = &l_283;
            (*l_426) = ((float)((((float)p_43 / (float)(__builtin_popcount(p_41) , l_414)) <= ((((p_42 , (((int16_t)((uint16_t)((uint16_t)65535UL << (uint16_t)((int16_t)p_42 << (int16_t)5)) << (uint16_t)4) << (int16_t)((((int32_t)(l_414 == (l_414 ^ l_414)) - (int32_t)p_42) | p_42) && 0xC07B78506ACAF532LL)) , l_425)) , l_426) == (void*)0) , 0xC.97892Cp-37)) == (-0x9.1p+1)) - (float)l_427);
            (*l_255) = (void*)0;
        }
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_46(int32_t  p_47, int32_t  p_48)
{ /* block id: 37 */
    int32_t l_60 = 0x06383254L;
    int32_t *l_59 = &l_60;
    int32_t **l_212 = &l_59;
    const int32_t * const ***l_220 = (void*)0;
    const int32_t * const ****l_219 = &l_220;
    const int64_t l_239 = 0xE181DA4DADB69EBDLL;
    const int32_t l_240 = 0x045B0E51L;
    l_59 = &p_48;
    (*l_212) = (func_61((((uint64_t)p_48 + (uint64_t)((~((((((int16_t)func_71((*l_59), &l_60, func_76(func_78(func_84((p_48 , func_87((func_90((*l_59), &l_60, (__builtin_bswap32((*l_59)) && 0UL)) == 0L), l_59)), (*l_59)), (*l_59), (*l_59), (*l_59), p_48)), l_59) >> (int16_t)12) , (*l_59)) && p_48) < (*l_59)) && p_47)) && p_47)) , (*l_59)), l_59, l_59, p_48) , &p_48);
    (*l_59) = (((int32_t)((*l_59) && ((uint16_t)((uint16_t)((((((void*)0 != l_219) ^ ((1UL < ((uint32_t)((int16_t)((int16_t)p_48 * (int16_t)p_47) - (int16_t)p_47) % (uint32_t)((int32_t)((((((((int16_t)((int16_t)((int16_t)((int16_t)(p_47 ^ ((uint64_t)p_47 + (uint64_t)p_47)) * (int16_t)(**l_212)) << (int16_t)14) >> (int16_t)p_48) >> (int16_t)4) && p_48) , (*l_59)) , 0xDA0BE5584E04F8DBLL) || (*l_59)) , l_239) , p_47) + (int32_t)p_47))) ^ 1L)) ^ p_47) > (*l_59)) ^ p_48) * (uint16_t)p_47) + (uint16_t)0xC62AL)) % (int32_t)(**l_212)) , (**l_212));
    (*l_212) = func_84((*l_212), l_240);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_61(int16_t  p_62, int32_t * p_63, const int32_t * p_64, uint64_t  p_65)
{ /* block id: 109 */
    int32_t l_209 = 0x075B0AE6L;
    int32_t *l_208 = &l_209;
    int32_t **l_210 = &l_208;
    int32_t *l_211 = &l_209;
    (*l_210) = func_84(l_208, p_65);
    (*l_210) = p_63;
    (*l_211) |= (*p_63);
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_71(uint64_t  p_72, int32_t * p_73, int32_t * p_74, int32_t * p_75)
{ /* block id: 106 */
    uint16_t l_206 = 65532UL;
    int32_t l_207 = 1L;
    (*p_73) |= l_206;
    return l_207;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_76(int32_t * const  p_77)
{ /* block id: 103 */
    int32_t l_202 = (-10L);
    int32_t l_204 = (-1L);
    int32_t *l_203 = &l_204;
    int32_t *l_205 = (void*)0;
    l_202 |= 0L;
    return l_205;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_78(int32_t * p_79, uint64_t  p_80, const int64_t  p_81, int32_t  p_82, const int32_t  p_83)
{ /* block id: 96 */
    int32_t **l_200 = (void*)0;
    int32_t ***l_199 = &l_200;
    int32_t *l_201 = (void*)0;
    for (p_80 = 0; (p_80 >= 41); p_80 += 4)
    { /* block id: 99 */
        l_199 = (void*)0;
    }
    return l_201;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_84(int32_t * p_85, const float  p_86)
{ /* block id: 93 */
    float l_193 = 0x0.2p+1;
    int32_t l_194 = 0x44C0915FL;
    int32_t *l_195 = &l_194;
    int32_t *l_196 = &l_194;
    l_195 = func_87(l_194, &l_194);
    return p_85;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_87(uint32_t  p_88, int32_t * p_89)
{ /* block id: 86 */
    int16_t l_171 = 6L;
    int32_t *l_192 = (void*)0;
    for (p_88 = 29; (p_88 > 11); p_88 -= 5)
    { /* block id: 89 */
        uint32_t l_182 = 4294967295UL;
        const int32_t *l_189 = (void*)0;
        int32_t *l_191 = (void*)0;
        int32_t **l_190 = &l_191;
        (*l_190) = (((l_171 < l_171) == ((uint32_t)((uint16_t)(((uint32_t)p_88 / (uint32_t)((int16_t)0xF8DAL - (int16_t)((int64_t)(l_182 & ((uint64_t)p_88 - (uint64_t)18446744073709551608UL)) + (int64_t)(((int16_t)(((uint32_t)p_88 / (uint32_t)(__builtin_ffsl(l_182) && l_171)) <= 0xAEBFL) * (int16_t)0x86F3L) != 0x561DL)))) || 0xA3011AC9FAB1CF0ALL) * (uint16_t)0xADEFL) % (uint32_t)(*p_89))) , l_189);
    }
    return l_192;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_90(int64_t  p_91, int32_t * p_92, int32_t  p_93)
{ /* block id: 39 */
    float l_94 = 0x0.1p-1;
    int32_t l_95 = 0x8ECA1AEAL;
    uint16_t l_112 = 65533UL;
    int32_t *l_160 = &l_95;
    int32_t **l_159 = &l_160;
    int32_t ***l_158 = &l_159;
    int32_t ****l_166 = &l_158;
    int32_t *****l_165 = &l_166;
    if (l_95)
    { /* block id: 40 */
        int32_t l_105 = (-5L);
        uint32_t l_111 = 0x3AA3630DL;
        int64_t l_126 = 0L;
        int32_t *l_130 = &l_95;
        int32_t **l_129 = &l_130;
        int32_t ***l_128 = &l_129;
        if ((&p_93 == &l_95))
        { /* block id: 41 */
            int32_t *l_98 = &l_95;
            int32_t **l_97 = &l_98;
            int32_t ***l_96 = &l_97;
            (*l_96) = &p_92;
        }
        else
        { /* block id: 43 */
            float l_103 = 0x5.6CB52Fp-16;
            int32_t l_104 = 0L;
            uint32_t l_135 = 0xBA7F7E75L;
            if (((((int16_t)((((int16_t)l_104 + (int16_t)l_105) , ((((uint64_t)(((((int16_t)0xD7B9L * (int16_t)l_95) , p_91) < (((((p_93 > (__builtin_ctz(l_104) == (-(int32_t)(*p_92)))) < l_95) != l_95) <= 0xEDED6215A4C4AE3BLL) , l_104)) > 0xE668196E547EF217LL) / (uint64_t)l_95) , p_91) , l_95)) < l_111) / (int16_t)p_93) | l_112) , (*p_92)))
            { /* block id: 44 */
                (*p_92) &= ((int16_t)p_93 << (int16_t)p_93);
            }
            else
            { /* block id: 46 */
                uint32_t l_115 = 4UL;
                return l_115;
            }
            if ((&p_93 == &l_95))
            { /* block id: 49 */
                int32_t **l_120 = (void*)0;
                float **l_137 = (void*)0;
                int32_t **l_152 = (void*)0;
                if (((((uint16_t)(l_104 <= ((((p_91 , ((((((p_91 , &p_92) != l_120) > (((((l_104 , p_91) >= ((__builtin_ffs(l_105) , p_93) == (*p_92))) >= l_95) == l_95) == p_91)) , (void*)0) == (void*)0) || p_91)) != p_93) , l_95) >= p_93)) >> (uint16_t)0) , (*p_92)) , l_95))
                { /* block id: 50 */
                    uint32_t l_123 = 1UL;
                    int32_t * const l_127 = (void*)0;
                    (***l_128) = (l_123 <= (((int16_t)l_126 * (int16_t)p_93) > (l_123 <= ((l_127 != (((-3L) | ((void*)0 != l_128)) , &p_93)) , (**l_129)))));
                    (**l_128) = &l_104;
                    (*l_130) = ((l_104 < p_91) & (p_93 > ((*l_130) , l_95)));
                }
                else
                { /* block id: 54 */
                    float *l_139 = &l_94;
                    float **l_138 = &l_139;
                    const uint32_t l_155 = 0x5B34A7E5L;
                    if (((int16_t)p_93 * (int16_t)l_135))
                    { /* block id: 55 */
                        float *l_136 = &l_103;
                        (*l_136) = l_95;
                    }
                    else
                    { /* block id: 57 */
                        l_138 = l_137;
                        (*l_139) = ((float)p_91 * (float)(((void*)0 != l_120) , ((float)0x5.DE0632p+41 + (float)__builtin_ctzll(l_112))));
                        (**l_129) |= (*p_92);
                    }
                    for (l_135 = (-10); (l_135 <= 9); l_135 += 1)
                    { /* block id: 64 */
                        if ((***l_128))
                            break;
                        (**l_128) = &p_93;
                    }
                    (**l_128) = ((l_104 < ((((3L && ((uint16_t)p_93 % (uint16_t)(p_93 ^ (__builtin_clz((**l_129)) <= 0x3B4F45EEL)))) , p_91) >= p_93) == l_135)) , &p_93);
                    (**l_128) = ((l_135 , (((((int16_t)((0x556C5F03L & ((int16_t)(p_91 || (l_104 == (&p_92 != l_152))) * (int16_t)l_135)) | 0L) / (int16_t)((int16_t)(-1L) << (int16_t)l_112)) , p_93) , l_155) & (*l_130))) , (void*)0);
                }
                (*p_92) &= (l_112 < p_91);
                (*p_92) |= (((uint16_t)p_93 >> (uint16_t)p_93) && p_91);
                (*l_160) ^= (((((void*)0 == l_158) <= p_93) | ((l_104 , p_93) >= l_104)) , (p_93 ^ (((uint16_t)p_91 * (uint16_t)0UL) > 0xD80D4602L)));
            }
            else
            { /* block id: 74 */
                (***l_128) = (*l_160);
            }
            (***l_158) = ((uint16_t)(*l_160) >> (uint16_t)3);
        }
    }
    else
    { /* block id: 79 */
        (*l_158) = (*l_158);
        (**l_158) = &p_93;
    }
    (*l_165) = &l_158;
    (*p_92) &= __builtin_popcount((((uint64_t)(*****l_165) / (uint64_t)(*****l_165)) , p_93));
    return p_91;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 99
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 21
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 3
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 78

XXX times a variable address is taken: 72
XXX times a pointer is dereferenced on RHS: 53
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 42
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 213

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 168
   level: 2, occurrence: 42
   level: 3, occurrence: 42
   level: 4, occurrence: 1
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 29
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 38.5
XXX average alias set size: 1.26

XXX times a non-volatile is read: 440
XXX times a non-volatile is write: 120
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 7
   depth: 2, occurrence: 10
   depth: 3, occurrence: 17
   depth: 4, occurrence: 15
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 21.5
XXX percentage an existing variable is used: 78.5
********************* end of statistics **********************/

