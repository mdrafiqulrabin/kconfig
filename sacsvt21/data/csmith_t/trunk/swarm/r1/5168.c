/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      516133988
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   const int16_t  f1;
   uint32_t  f2;
   const uint32_t  f3;
   uint32_t  f4;
   int32_t  f5;
   uint16_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_29(void);
static uint16_t  func_35(uint32_t  p_36);
static int32_t  func_46(struct S0  p_47, int16_t  p_48, int32_t  p_49, uint32_t  p_50);
static struct S0  func_51(int32_t  p_52, uint32_t  p_53, int32_t  p_54);
static int32_t  func_55(int32_t  p_56);
static struct S0  func_60(int16_t  p_61, uint16_t  p_62, int32_t  p_63, uint32_t  p_64);
static uint16_t  func_70(int32_t  p_71, uint16_t  p_72, int16_t  p_73, const int16_t  p_74);
inline static int16_t  func_76(uint16_t  p_77, int16_t  p_78);
static uint16_t  func_79(uint16_t  p_80, const uint32_t  p_81, uint32_t  p_82, uint32_t  p_83, uint32_t  p_84);
inline static uint16_t  func_85(int16_t  p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_29(void)
{ /* block id: 36 */
    int32_t l_30 = 1;
    struct S0 l_308 = {4294967295U,1,0x644B6C62,0xADB3B8D3,0xEC438B65,0xF7F315CC,65528U};
    const uint32_t l_313 = 4294967291U;
    int32_t l_376 = (-1);
    int32_t *l_375 = &l_376;
    uint32_t l_410 = 0x8580AB61;
    if (((l_30 , (safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_s((((l_30 >= func_35(__builtin_popcount((safe_sub_func_int16_t_s_s(0x2E3C, l_30))))) | (((l_308 , (safe_add_func_uint16_t_u_u((7 ^ (safe_rshift_func_int16_t_s_u(__builtin_parityll(l_308.f5), l_308.f0))), l_313))) >= l_308.f2) < 1)) || 65535U), l_308.f6)), l_308.f5))) , 0x4E5EDCD1))
    { /* block id: 167 */
        uint32_t l_316 = 0xED25AB72;
        struct S0 *l_325 = &l_308;
        for (l_308.f4 = 0; (l_308.f4 != 16); l_308.f4 = safe_add_func_int32_t_s_s(l_308.f4, 4))
        { /* block id: 170 */
            int32_t l_318 = 0x6F7A8BFF;
            int32_t *l_317 = &l_318;
            struct S0 *l_324 = &l_308;
            int32_t l_327 = 0x78506ACA;
            int32_t *l_326 = &l_327;
            (*l_317) = l_316;
            (*l_326) &= ((safe_unary_minus_func_uint16_t_u((safe_mod_func_uint16_t_u_u((safe_add_func_uint32_t_u_u(l_316, (__builtin_clz(l_308.f4) == (l_324 != (func_76((*l_317), (*l_317)) , l_325))))), l_316)))) || l_308.f1);
            if ((*l_317))
                continue;
        }
    }
    else
    { /* block id: 175 */
        int32_t l_329 = (-7);
        int32_t *l_328 = &l_329;
        (*l_328) |= (l_308.f4 && 0xE6215E6E);
        for (l_308.f0 = (-16); (l_308.f0 < 3); l_308.f0 = safe_add_func_int32_t_s_s(l_308.f0, 1))
        { /* block id: 179 */
            int32_t l_342 = 0x7628F6B5;
            struct S0 *l_365 = &l_308;
            struct S0 **l_364 = &l_365;
        }
    }
    return l_410;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_35(uint32_t  p_36)
{ /* block id: 37 */
    uint16_t l_41 = 65529U;
    int32_t l_306 = (-5);
    int32_t *l_305 = &l_306;
    int32_t **l_307 = &l_305;
    (*l_305) = ((safe_lshift_func_int16_t_s_u((0xB32E ^ p_36), l_41)) == (((safe_sub_func_uint16_t_u_u((safe_mod_func_int16_t_s_s(__builtin_ffsl(p_36), p_36)), l_41)) < p_36) != func_46(func_51(func_55(p_36), p_36, l_41), p_36, l_41, l_41)));
    (*l_307) = &l_306;
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_46(struct S0  p_47, int16_t  p_48, int32_t  p_49, uint32_t  p_50)
{ /* block id: 154 */
    struct S0 l_286 = {0x223DDD05,0x887C,0U,0xD0708E55,0x90321B15,-9,0x5053};
    struct S0 *l_285 = &l_286;
    struct S0 **l_287 = &l_285;
    struct S0 ***l_291 = &l_287;
    struct S0 ****l_290 = &l_291;
    (*l_287) = l_285;
    for (p_47.f6 = (-2); (p_47.f6 >= 43); p_47.f6 = safe_add_func_uint16_t_u_u(p_47.f6, 1))
    { /* block id: 158 */
        struct S0 ****l_292 = &l_291;
        int32_t l_294 = 0x2E91BB18;
        int32_t *l_293 = &l_294;
        int32_t l_304 = 0x130F14CA;
        int32_t *l_303 = &l_304;
        (*l_293) = __builtin_clzll((l_290 != l_292));
        (*l_303) &= ((((((*l_293) == p_47.f2) == ((safe_rshift_func_int16_t_s_u(0x0A2A, (*l_293))) && (safe_mod_func_int32_t_s_s((safe_sub_func_int32_t_s_s(0xEA837A7E, 4294967295U)), ((safe_sub_func_int32_t_s_s(0x8EF07762, ((*l_287) != (void*)0))) || p_47.f1))))) == 65529U) , p_47.f0) <= p_50);
        (*l_293) &= ((p_47.f6 == (*l_303)) > p_47.f5);
    }
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_51(int32_t  p_52, uint32_t  p_53, int32_t  p_54)
{ /* block id: 40 */
    uint16_t l_65 = 0xDD1F;
    int32_t l_282 = (-9);
    struct S0 l_284 = {1U,-1,0xD836B3EB,7U,1U,0x2F63DB9C,0xB1DA};
    l_282 = ((safe_rshift_func_uint16_t_u_s((func_60(l_65, func_55(l_65), l_65, (func_55(l_65) ^ ((safe_sub_func_uint32_t_u_u(l_65, 8U)) != __builtin_ffsll(__builtin_clzl(p_54))))) , p_53), 0)) < l_65);
    l_282 ^= (safe_unary_minus_func_int32_t_s((-1)));
    return l_284;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_55(int32_t  p_56)
{ /* block id: 38 */
    int32_t l_57 = 3;
    return l_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_60(int16_t  p_61, uint16_t  p_62, int32_t  p_63, uint32_t  p_64)
{ /* block id: 41 */
    uint32_t l_75 = 0xC012777F;
    int32_t l_280 = 0x166874D8;
    int32_t *l_279 = &l_280;
    struct S0 l_281 = {0x488365C3,-1,0xB1E4FE67,0x2E0BC558,0xFAC850F5,-9,65535U};
    (*l_279) &= (4294967293U < (safe_rshift_func_uint16_t_u_u(func_70(l_75, p_64, func_76(func_79(func_85(l_75), ((0U > ((__builtin_clzll(p_61) < 0x1EBB) & 0xCB52)) , p_61), p_63, l_75, l_75), p_62), p_64), p_61)));
    return l_281;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_70(int32_t  p_71, uint16_t  p_72, int16_t  p_73, const int16_t  p_74)
{ /* block id: 54 */
    int16_t l_119 = 8;
    int32_t l_121 = 0xE343BB5A;
    int32_t *l_120 = &l_121;
    int32_t l_128 = 0x300A9085;
    int32_t l_132 = (-9);
    const struct S0 l_141 = {4294967289U,1,3U,4294967289U,0xF4A07556,9,65531U};
    struct S0 l_174 = {0x0CFF6E6F,-4,0U,0x3CE86B16,0x8A3390C0,-9,0x8C49};
    struct S0 *l_173 = &l_174;
    struct S0 **l_172 = &l_173;
    const int32_t l_189 = (-1);
    const struct S0 *l_259 = &l_141;
    const struct S0 **l_258 = &l_259;
    const struct S0 ***l_257 = &l_258;
    const struct S0 ****l_256 = &l_257;
    uint32_t l_273 = 0xB2DAAAC5;
    uint32_t l_275 = 8U;
    int32_t **l_278 = &l_120;
    if ((safe_unary_minus_func_int16_t_s(func_79(((l_119 >= (&p_71 != l_120)) != ((void*)0 == &l_120)), (p_72 , (safe_add_func_int16_t_s_s(((((safe_mod_func_uint16_t_u_u(__builtin_bswap64((*l_120)), (safe_add_func_int32_t_s_s(p_73, l_128)))) || p_71) < (*l_120)) | (-4)), (*l_120)))), (*l_120), p_73, (*l_120)))))
    { /* block id: 55 */
        int32_t l_142 = 0x89D5723D;
        int32_t *l_143 = (void*)0;
        int32_t *l_144 = (void*)0;
        int32_t l_146 = 0x1A098967;
        int32_t *l_145 = &l_146;
        struct S0 *l_150 = (void*)0;
        struct S0 **l_149 = &l_150;
        int32_t l_151 = (-1);
        int16_t l_184 = 0x9B0E;
        (*l_145) ^= (~(safe_sub_func_uint16_t_u_u(func_85(l_132), (safe_mod_func_int16_t_s_s((0 || (((safe_rshift_func_uint16_t_u_s((p_71 != func_76((safe_rshift_func_uint16_t_u_u(((__builtin_ctzl(((safe_sub_func_int32_t_s_s(1, (l_141 , ((*l_120) != (0x739A == (0xCE64C31C ^ l_142)))))) && 0U)) , 0xD179B141) > (*l_120)), 13)), l_142)), 0)) >= p_74) , (-1))), l_142)))));
        if ((((0xCCF7 & (func_55((safe_rshift_func_int16_t_s_u((*l_120), 8))) == (*l_145))) , l_149) == (void*)0))
        { /* block id: 57 */
            (*l_120) = (-10);
            l_151 = p_71;
        }
        else
        { /* block id: 60 */
            (*l_145) ^= (-1);
        }
        if (((safe_add_func_int32_t_s_s(p_71, ((0x054360E2 <= (*l_120)) || ((safe_lshift_func_int16_t_s_u(func_85(p_72), func_55(((1 == ((safe_sub_func_int32_t_s_s(((*l_145) || 0x20CCC24D), (*l_120))) & 9)) , (*l_120))))) && 4294967295U)))) , (*l_145)))
        { /* block id: 63 */
            uint32_t l_160 = 1U;
            int32_t l_175 = 0x355BA672;
            int16_t l_182 = 9;
            (*l_120) = ((__builtin_ffsl((__builtin_parityl((safe_mod_func_int32_t_s_s((__builtin_clzll((7U | l_160)) || (func_79((~(((0x2DA50C60 != ((void*)0 != &l_141)) , ((p_74 , l_141) , ((&l_120 != (void*)0) == p_74))) == (*l_120))), (*l_120), p_74, (*l_120), p_72) ^ l_160)), 0xAC9FAB1C))) >= l_160)) != 0xADEF) == (*l_120));
            (*l_120) ^= 0x428438D7;
            if (l_160)
            { /* block id: 66 */
                struct S0 **l_162 = &l_150;
                int32_t **l_178 = &l_120;
                if (func_55((l_162 != (void*)0)))
                { /* block id: 67 */
                    int32_t **l_163 = &l_143;
                    (*l_163) = &l_142;
                    /* statement id: 68 */
                    assert (l_143 == &l_142);
                    (**l_163) = p_74;
                }
                else
                { /* block id: 70 */
                    (*l_145) = (func_79(p_73, (*l_120), (safe_add_func_uint32_t_u_u((safe_sub_func_int32_t_s_s((((safe_mod_func_uint16_t_u_u(((__builtin_clzll((safe_sub_func_int32_t_s_s(p_72, 0x41FE22FA))) <= (*l_120)) , 0x002C), func_55((((void*)0 == l_172) , l_160)))) > 0x4357C3C5) & 0U), p_74)), l_175)), (*l_145), p_72) != p_71);
                    for (l_151 = 26; (l_151 >= (-1)); l_151 = safe_sub_func_int16_t_s_s(l_151, 1))
                    { /* block id: 74 */
                        if (p_72)
                            break;
                        if (p_73)
                            continue;
                    }
                }
                /* facts after branching */
                assert (l_143 == 0 || l_143 == &l_142);
                (*l_178) = &l_175;
                /* statement id: 79 */
                assert (l_120 == &l_175);
                (*l_145) = (*l_120);
            }
            else
            { /* block id: 81 */
                int32_t **l_179 = &l_120;
                (*l_145) &= (*l_120);
                (*l_179) = &p_71;
                /* statement id: 83 */
                assert (l_120 == &p_71);
                for (l_121 = (-2); (l_121 <= (-19)); l_121 = safe_sub_func_int32_t_s_s(l_121, 1))
                { /* block id: 86 */
                    int16_t l_183 = 0x8CC4;
                    (*l_179) = (p_74 , (void*)0);
                    /* statement id: 87 */
                    assert (l_120 == 0);
                    l_182 ^= func_85(p_72);
                    return l_183;
                }
                return l_184;
            }
            /* facts after branching */
            assert (l_120 == &l_175);
            assert (l_143 == 0 || l_143 == &l_142);
        }
        else
        { /* block id: 93 */
            return p_73;
        }
        /* facts after branching */
        //assert (l_120 == dangling);
        assert (l_143 == 0 || l_143 == &l_142);
        for (p_73 = (-25); (p_73 < (-7)); p_73 = safe_add_func_uint16_t_u_u(p_73, 1))
        { /* block id: 98 */
            uint32_t l_192 = 4294967287U;
            struct S0 l_193 = {0xB8F45AC6,0xA2EA,4294967295U,4294967292U,4294967295U,0,65535U};
            int32_t l_196 = (-10);
            struct S0 ***l_212 = &l_149;
            struct S0 ****l_211 = &l_212;
            l_196 &= (__builtin_bswap32((l_132 | (func_79((safe_add_func_uint16_t_u_u(l_189, __builtin_bswap32((safe_sub_func_uint16_t_u_u(l_192, (*l_145)))))), (p_74 > l_192), func_79((((l_193 , (safe_sub_func_uint16_t_u_u(__builtin_ctz((*l_145)), (*l_145)))) && p_74) || p_72), p_72, p_73, p_71, l_193.f4), l_193.f1, (*l_145)) , l_193.f0))) & l_119);
            if ((((((safe_sub_func_int32_t_s_s((l_174.f3 && __builtin_clzll(((&l_150 != ((p_73 < p_71) , (__builtin_parityl(((p_73 , &l_150) != &l_173)) , (void*)0))) , p_71))), (*l_145))) , l_193.f0) != p_71) > p_73) >= p_72))
            { /* block id: 100 */
                (*l_149) = &l_193;
                /* statement id: 101 */
                assert (l_150 == &l_193);
            }
            else
            { /* block id: 102 */
                int16_t l_207 = 0xFCF5;
                int32_t *l_208 = &l_142;
                (*l_208) |= ((p_74 >= p_74) != (((*l_145) >= ((p_71 && ((((safe_mod_func_int16_t_s_s((safe_lshift_func_int16_t_s_u(p_73, (safe_sub_func_uint32_t_u_u(l_207, l_207)))), 0xF460)) && (1 ^ p_71)) != 0xB2E5F269) < p_74)) , (-2))) == p_72));
                if ((*l_145))
                    break;
            }
            /* facts after branching */
            //assert (l_150 == 0 || l_150 == dangling || l_150 == &l_193);
            (*l_145) |= (safe_rshift_func_int16_t_s_u(p_73, 11));
            (*l_211) = &l_149;
        }
        /* facts after for loop */
        //assert (l_150 == 0 || l_150 == dangling);
    }
    else
    { /* block id: 109 */
        uint32_t l_220 = 4294967295U;
        int32_t *l_221 = &l_121;
        struct S0 ***l_245 = &l_172;
        int32_t *l_277 = &l_132;
        for (l_128 = 0; (l_128 <= 5); l_128 = safe_add_func_uint32_t_u_u(l_128, 1))
        { /* block id: 112 */
            uint32_t l_235 = 0x86F38ED0;
            const struct S0 *l_254 = &l_174;
            int32_t *l_276 = &l_121;
            for (l_174.f2 = 10; (l_174.f2 < 19); l_174.f2 = safe_add_func_int16_t_s_s(l_174.f2, 1))
            { /* block id: 115 */
                int32_t l_219 = 0x23561A8A;
                int32_t **l_222 = &l_221;
                (*l_120) = (p_72 , (&l_120 != ((safe_lshift_func_int16_t_s_u((__builtin_clzl(l_219) != (((l_220 < p_71) < l_220) , ((-1) > (1U || 0xF3BF)))), 15)) , (void*)0)));
                (*l_222) = l_221;
            }
            for (l_174.f2 = 0; (l_174.f2 == 1); l_174.f2 = safe_add_func_int16_t_s_s(l_174.f2, 1))
            { /* block id: 121 */
                uint16_t l_230 = 0xFD15;
                int32_t **l_243 = &l_221;
                struct S0 ***l_248 = &l_172;
                if (p_72)
                { /* block id: 122 */
                    struct S0 ****l_249 = &l_248;
                    int32_t l_274 = (-9);
                    if (((safe_rshift_func_uint16_t_u_u((*l_221), (*l_120))) , ((safe_sub_func_int16_t_s_s(((p_72 , p_73) == p_71), 0x8F83)) != (((~(__builtin_parityl(l_230) , (p_74 <= (*l_120)))) < p_74) >= l_230))))
                    { /* block id: 123 */
                        int32_t l_244 = (-1);
                        struct S0 ****l_246 = (void*)0;
                        struct S0 ****l_247 = (void*)0;
                        (*l_120) = (safe_add_func_int32_t_s_s((safe_mod_func_int32_t_s_s(p_71, (l_235 , (((safe_sub_func_uint32_t_u_u(l_235, __builtin_ctzll((((safe_lshift_func_uint16_t_u_s(p_74, 5)) > p_74) > 0x979B65F2)))) | 2) | (!(((((safe_sub_func_int32_t_s_s((l_243 != (void*)0), 0xA85B4417)) & 0x7302) < 0x94EF) < l_244) && 0xB270)))))), p_72));
                        (**l_243) = p_73;
                        l_248 = l_245;
                        (*l_243) = (void*)0;
                        /* statement id: 127 */
                        assert (l_221 == 0);
                    }
                    else
                    { /* block id: 128 */
                        struct S0 *l_255 = &l_174;
                        (*l_120) = ((l_249 == ((safe_rshift_func_int16_t_s_s((l_249 == (void*)0), ((((((safe_add_func_uint32_t_u_u(p_73, p_72)) >= (0x5CAA7A5E <= (**l_243))) , l_254) == l_255) , p_71) >= p_73))) , l_256)) >= (*l_120));
                    }
                    /* facts after branching */
                    assert (l_221 == &l_121 || l_221 == 0);
                    for (l_174.f0 = 0; (l_174.f0 > 14); l_174.f0 = safe_add_func_uint16_t_u_u(l_174.f0, 2))
                    { /* block id: 133 */
                        if (p_73)
                            break;
                        return p_71;
                    }
                    (*l_120) = (p_73 , (p_74 != (safe_rshift_func_uint16_t_u_u(((*l_120) && (((-1) > (func_55(func_85((~(((safe_rshift_func_int16_t_s_u((((***l_249) == (func_85((safe_lshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s(p_73, (((safe_sub_func_uint16_t_u_u((p_74 && l_273), ((void*)0 == &p_71))) >= p_71) != l_274))), 7))) , l_254)) == p_74), 12)) & p_74) && l_274)))) , l_275)) == l_274)), p_72))));
                }
                else
                { /* block id: 138 */
                    (*l_243) = &p_71;
                    /* statement id: 139 */
                    assert (l_221 == &p_71);
                }
                /* facts after branching */
                assert (l_221 == &p_71 || l_221 == &l_121 || l_221 == 0);
                (*l_243) = l_276;
                /* statement id: 141 */
                assert (l_221 == &l_121);
            }
        }
        (*l_277) |= (*l_120);
        (*l_277) |= 0xE7577DDA;
    }
    /* facts after branching */
    //assert (l_120 == &l_121 || l_120 == dangling);
    (*l_278) = &p_71;
    /* statement id: 147 */
    assert (l_120 == &p_71);
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_76(uint16_t  p_77, int16_t  p_78)
{ /* block id: 49 */
    int32_t l_102 = 0xB5300FFB;
    int32_t *l_101 = &l_102;
    int32_t **l_100 = &l_101;
    struct S0 l_110 = {0xFB0E7FB9,0xE98D,0x1E582B27,4294967290U,0x43529ADF,3,0x5EB9};
    struct S0 *l_109 = &l_110;
    int32_t l_114 = 0x6D4D43A6;
    int32_t *l_113 = &l_114;
    uint32_t l_117 = 0x65AFEF71;
    l_100 = l_100;
    (*l_113) ^= (safe_mod_func_int32_t_s_s((safe_rshift_func_uint16_t_u_u((p_77 <= (((__builtin_parity(p_77) || ((((((((*l_101) | (safe_lshift_func_int16_t_s_u((**l_100), (l_109 == (void*)0)))) | (safe_mod_func_int32_t_s_s((-7), ((p_77 != (-1)) , p_78)))) <= 0x1191) ^ p_78) != 4) | p_78) < 0x3C25347F)) , 3U) , (**l_100))), (*l_101))), p_78));
    (*l_113) = ((safe_add_func_uint32_t_u_u(0U, (*l_113))) < ((*l_109) , ((*l_113) == (((*l_101) , (*l_109)) , (p_77 ^ p_77)))));
    return l_117;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_79(uint16_t  p_80, const uint32_t  p_81, uint32_t  p_82, uint32_t  p_83, uint32_t  p_84)
{ /* block id: 45 */
    int32_t l_92 = 0x1F5FBD7B;
    int32_t *l_91 = &l_92;
    int32_t **l_90 = &l_91;
    struct S0 l_94 = {0U,0xD870,0U,0x6596AAD9,0x1AA4961F,0x846D72D3,1U};
    struct S0 *l_93 = &l_94;
    struct S0 **l_95 = (void*)0;
    struct S0 **l_96 = (void*)0;
    struct S0 **l_97 = (void*)0;
    struct S0 **l_98 = (void*)0;
    struct S0 **l_99 = (void*)0;
    (*l_91) = ((l_90 == (void*)0) , 3);
    l_93 = l_93;
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_85(int16_t  p_86)
{ /* block id: 42 */
    int32_t l_88 = 0x7DA87815;
    int32_t *l_87 = &l_88;
    int32_t **l_89 = &l_87;
    (*l_89) = l_87;
    return p_86;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 76
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 24, occurrence: 3

XXX total number of pointers: 76

XXX times a variable address is taken: 82
XXX times a pointer is dereferenced on RHS: 94
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 54
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 216

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 193
   level: 2, occurrence: 19
   level: 3, occurrence: 1
XXX number of pointers point to pointers: 39
XXX number of pointers point to scalars: 26
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 21.1
XXX average alias set size: 1.14

XXX times a non-volatile is read: 504
XXX times a non-volatile is write: 132
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 13
   depth: 2, occurrence: 16
   depth: 3, occurrence: 14
   depth: 4, occurrence: 11
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 18.7
XXX percentage an existing variable is used: 81.3
********************* end of statistics **********************/

