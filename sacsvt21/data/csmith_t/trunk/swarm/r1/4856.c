/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      2299763408
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t  func_8(int8_t  p_9, const uint64_t  p_10);
static int16_t  func_11(uint32_t  p_12);
static uint16_t  func_14(uint64_t  p_15, uint16_t  p_16, uint64_t  p_17, int16_t  p_18, int16_t  p_19);
static const int64_t  func_22(int64_t  p_23);
static uint32_t  func_31(uint32_t  p_32, int8_t  p_33);
static uint32_t  func_34(int32_t ** p_35, int32_t  p_36, uint16_t  p_37);
static int32_t ** func_38(int32_t ** p_39, int32_t * p_40, uint32_t  p_41, int32_t ** p_42, int32_t ** p_43);
static int32_t ** func_44(uint32_t  p_45);
static uint32_t  func_46(uint32_t  p_47, uint32_t  p_48, uint16_t  p_49);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int8_t l_6 = 0x52L;
    int64_t l_545 = 0xA710C952A7C1728DLL;
    int32_t l_547 = 0x44300DDBL;
    int32_t *l_546 = &l_547;
    const int32_t ***l_577 = (void*)0;
    const int32_t ****l_576 = &l_577;
    int8_t l_582 = 0xD7L;
    const uint32_t l_592 = 0UL;
    int32_t **l_595 = &l_546;
    int64_t l_598 = 0L;
    int32_t l_607 = 2L;
    if ((((uint16_t)(((((uint16_t)((((l_6 != l_6) || 0x16A2L) == (!func_8(l_6, (l_6 | func_11((l_6 || ((8UL <= l_6) > l_6))))))) != 0x36A0E87853086DBELL) >> (uint16_t)3) || l_545) || l_545) <= l_6) << (uint16_t)1) != l_545))
    { /* block id: 237 */
        int32_t **l_548 = (void*)0;
        int32_t **l_549 = &l_546;
        (*l_549) = l_546;
        for (l_6 = 24; (l_6 <= 16); l_6 -= 8)
        { /* block id: 241 */
            int32_t ***l_564 = &l_549;
            int32_t ****l_563 = &l_564;
            (*l_546) = (**l_549);
            (*l_546) = ((((int32_t)((int32_t)((int32_t)((int16_t)((-(int16_t)((l_563 != &l_564) < (**l_549))) <= ((void*)0 != (*l_563))) / (int16_t)((int32_t)((uint32_t)(****l_563) - (uint32_t)((int16_t)((**l_564) == &l_547) >> (int16_t)4)) % (int32_t)((***l_564) | (***l_564)))) / (int32_t)(*l_546)) + (int32_t)0L) - (int32_t)(*l_546)) <= 0L) != (***l_564));
        }
        l_546 = &l_547;
    }
    else
    { /* block id: 246 */
        int32_t l_573 = 1L;
        (*l_546) = (0x01AADC9CL != ((int64_t)(*l_546) + (int64_t)(((l_573 == ((int64_t)1L + (int64_t)((((l_576 == (void*)0) || (((int64_t)((int16_t)l_573 >> (int16_t)13) + (int64_t)((*l_546) <= (l_573 && l_573))) < l_573)) >= l_573) != (-1L)))) && l_573) <= 7L)));
        return l_582;
    }
    (*l_546) = ((int32_t)((uint16_t)(*l_546) / (uint16_t)((uint16_t)6UL / (uint16_t)(-(int16_t)((uint16_t)l_592 - (uint16_t)((((uint64_t)((void*)0 == l_595) / (uint64_t)(l_598 & ((((int16_t)(((0xA254L >= ((uint16_t)((int32_t)(((*l_546) <= (((uint16_t)(**l_595) >> (uint16_t)(**l_595)) ^ (*l_546))) == 0xCDAF3530299EC872LL) - (int32_t)0x7CFBFDBFL) << (uint16_t)1)) == 1L) == (*l_546)) / (int16_t)(-2L)) != 0xF7A3L) > (**l_595)))) & 0x435A646DL) != (**l_595)))))) % (int32_t)(*l_546));
    return l_607;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_8(int8_t  p_9, const uint64_t  p_10)
{ /* block id: 212 */
    int32_t *l_481 = (void*)0;
    int32_t **l_494 = &l_481;
    int32_t ***l_493 = &l_494;
    int32_t ****l_492 = &l_493;
    int32_t *****l_491 = &l_492;
    uint64_t l_513 = 0x85C06E6E6B571F5CLL;
    uint64_t l_542 = 1UL;
    int32_t l_543 = (-6L);
    int32_t *l_544 = &l_543;
    for (p_9 = (-13); (p_9 == 13); p_9 += 1)
    { /* block id: 215 */
        int32_t **l_482 = &l_481;
        int32_t ****l_497 = (void*)0;
        int32_t l_498 = 0L;
        (*l_482) = l_481;
        if ((p_10 || ((uint16_t)(p_10 & (((uint64_t)((uint16_t)((void*)0 == l_482) >> (uint16_t)14) + (uint64_t)((((uint16_t)((l_491 == (void*)0) == p_10) << (uint16_t)((int64_t)(l_497 != (*l_491)) / (int64_t)18446744073709551610UL)) || 0xD09BL) || p_9)) > 0L)) >> (uint16_t)10)))
        { /* block id: 217 */
            if (p_10)
                break;
        }
        else
        { /* block id: 219 */
            return p_10;
        }
        if (l_498)
        { /* block id: 222 */
            int32_t *****l_501 = &l_497;
            int32_t l_512 = 0xD9A08F3BL;
            int32_t *l_529 = &l_498;
            l_513 = ((uint16_t)((((l_501 == l_501) <= ((uint16_t)(((((-1L) >= ((void*)0 == (*l_494))) != p_10) == (((int16_t)1L % (int16_t)((1L ^ ((uint16_t)((uint32_t)p_9 - (uint32_t)p_9) % (uint16_t)l_512)) | l_512)) == p_9)) >= p_9) >> (uint16_t)8)) <= p_10) == 0x4D16FD438B19DBEBLL) << (uint16_t)15);
            (*l_529) = ((p_10 <= 1L) > ((uint64_t)((int32_t)(-1L) - (int32_t)((((((uint16_t)((((((int16_t)((((-(int32_t)(((0x954FDB46L > (((p_9 <= ((void*)0 == &l_482)) < ((uint64_t)((uint16_t)(((((int64_t)p_9 - (int64_t)p_9) < p_9) && 0x3DB87A49L) <= (-1L)) << (uint16_t)l_512) + (uint64_t)(-8L))) | p_10)) >= p_9) == p_10)) >= 0xB5C68F9EL) <= 0L) < p_9) + (int16_t)5L) & p_9) > 18446744073709551612UL) && p_9) >= p_9) << (uint16_t)9) < 1UL) != p_10) == 4294967288UL) | p_9)) % (uint64_t)p_9));
            (*l_482) = (**l_493);
        }
        else
        { /* block id: 226 */
            int64_t l_530 = 0x594CAF5227B02F82LL;
            int32_t l_538 = 1L;
            int32_t *l_541 = &l_538;
            l_530 = p_9;
            l_538 = ((int16_t)l_530 / (int16_t)((0x21F7CC3D62FD9E34LL ^ ((-(uint16_t)(((int16_t)((p_10 && (l_497 != (void*)0)) == (p_9 > 0x286D6DA56A923163LL)) - (int16_t)l_530) < (((int32_t)(-1L) % (int32_t)l_530) & 8L))) > 0xBB4FA76D76F845BFLL)) | l_530));
            (*l_541) = ((uint16_t)(l_538 ^ 0xEB41L) % (uint16_t)l_530);
        }
        l_543 = (l_542 || 0x984DL);
    }
    (***l_492) = (void*)0;
    (*l_544) = p_10;
    (*l_544) = 9L;
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_11(uint32_t  p_12)
{ /* block id: 1 */
    uint64_t l_13 = 0x87C7AB89BDD7770BLL;
    int32_t *l_477 = (void*)0;
    int32_t l_478 = 0L;
    l_478 = (l_13 && (func_14(((int16_t)(func_22(l_13) & l_13) << (int16_t)0), p_12, l_13, l_13, (((int16_t)((p_12 || p_12) >= l_13) << (int16_t)p_12) >= p_12)) && l_13));
    return p_12;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_14(uint64_t  p_15, uint16_t  p_16, uint64_t  p_17, int16_t  p_18, int16_t  p_19)
{ /* block id: 206 */
    uint16_t l_452 = 0UL;
    int32_t ***l_457 = (void*)0;
    int32_t ****l_456 = &l_457;
    int32_t *****l_455 = &l_456;
    int64_t l_468 = 0L;
    int32_t l_469 = 0xE93FE035L;
    uint32_t l_476 = 0x478303DCL;
    l_469 = (0x3F40L | ((((l_452 < ((uint64_t)((((l_455 != &l_456) | (0UL ^ ((((int16_t)(((int16_t)0x57C0L % (int16_t)(((int16_t)(((p_16 & ((int16_t)(p_17 | ((*l_456) == (void*)0)) << (int16_t)p_16)) || p_15) >= 0xE39718DDL) - (int16_t)p_17) && l_468)) > p_15) << (int16_t)p_17) == p_16) >= p_16))) > 0x3B5990A5554EDFD1LL) >= p_17) + (uint64_t)0xDA54368FA089E560LL)) || p_17) < 18446744073709551615UL) < 0x2893DC6341F22137LL));
    l_469 = ((p_18 < (p_17 < ((p_18 < (p_15 == 0x1EC76F50C885CE1ELL)) || (p_17 || ((int16_t)(((uint64_t)(((uint16_t)((((p_15 | p_17) | l_476) | p_19) > p_18) << (uint16_t)14) & p_19) / (uint64_t)8UL) <= p_17) >> (int16_t)p_16))))) && p_19);
    return p_15;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int64_t  func_22(int64_t  p_23)
{ /* block id: 2 */
    int32_t *l_25 = (void*)0;
    int32_t **l_24 = &l_25;
    const int16_t l_30 = (-2L);
    int32_t l_422 = 0x32886206L;
    int32_t *l_421 = &l_422;
    int32_t ***l_425 = &l_24;
    int32_t ****l_424 = &l_425;
    int32_t *****l_423 = &l_424;
    int64_t l_448 = 9L;
    int8_t l_449 = 0x9FL;
    (*l_24) = (void*)0;
    (*l_421) = ((int64_t)((int64_t)((l_30 | p_23) != (func_31(func_34(func_38(func_44(func_46(((&l_25 == &l_25) >= (((-1L) >= 0L) & 0x4EDB553AL)), ((3UL >= (((uint16_t)0x0D29L << (uint16_t)4) >= p_23)) & p_23), l_30)), (*l_24), p_23, &l_25, &l_25), p_23, p_23), p_23) > p_23)) - (int64_t)0x977FC4C1116C565ALL) % (int64_t)p_23);
    if ((((l_423 == (void*)0) | ((uint16_t)(*l_421) - (uint16_t)0x03A8L)) | ((p_23 < ((*l_425) == (***l_423))) || (((uint16_t)0x51FEL >> (uint16_t)((void*)0 != (**l_425))) < (*l_421)))))
    { /* block id: 195 */
        int32_t *****l_440 = (void*)0;
        int32_t l_443 = (-9L);
        for (p_23 = 0; (p_23 == (-9)); p_23 -= 9)
        { /* block id: 198 */
            int32_t l_442 = (-1L);
            l_443 = (((((int64_t)((int32_t)((p_23 & ((uint16_t)7UL % (uint16_t)p_23)) >= p_23) % (int32_t)((int16_t)((((void*)0 != l_440) && (0x965BL & (~((p_23 > 1L) ^ l_442)))) | p_23) >> (int16_t)2)) % (int64_t)0xC5A9C8A47113E96BLL) || 0xF79CL) >= l_442) & p_23);
        }
    }
    else
    { /* block id: 201 */
        (****l_423) = (*l_24);
    }
    (*l_421) = (0xCD48L || ((((*l_421) ^ (((p_23 != 0x1E6D9B8B5A0E175ALL) > (18446744073709551615UL == (p_23 <= (((((((((p_23 != ((((int64_t)(p_23 != p_23) - (int64_t)p_23) < (*l_421)) > (*l_421))) >= l_448) >= 0x84EC7DB4L) | p_23) == (*l_421)) < 0L) | p_23) <= l_449) < p_23)))) != (-9L))) && 0xFC5E0286AF9661FELL) | p_23));
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_31(uint32_t  p_32, int8_t  p_33)
{ /* block id: 125 */
    int32_t l_293 = 1L;
    int32_t *l_292 = &l_293;
    int32_t **l_294 = &l_292;
    int32_t *****l_328 = (void*)0;
    int32_t ***l_346 = &l_294;
lbl_327:
    (*l_294) = l_292;
    for (l_293 = 0; (l_293 != 24); l_293 += 3)
    { /* block id: 129 */
        const int32_t l_307 = 0L;
        int32_t *l_312 = (void*)0;
        int32_t l_326 = 0x2CBDC25AL;
        int32_t ***l_331 = (void*)0;
        int32_t ****l_330 = &l_331;
        int32_t *****l_329 = &l_330;
        for (p_32 = (-20); (p_32 > 22); p_32 += 8)
        { /* block id: 132 */
            int32_t *l_299 = (void*)0;
            int32_t ***l_309 = &l_294;
            (*l_294) = l_299;
            /* statement id: 133 */
            assert (l_292 == 0);
            for (p_33 = (-19); (p_33 <= 15); p_33 += 1)
            { /* block id: 136 */
                int32_t l_308 = 0xBA40BAC5L;
                int32_t l_311 = (-1L);
                int32_t *l_310 = &l_311;
                (*l_310) = ((((uint16_t)((int32_t)(~p_33) + (int32_t)(0xAD52E694L | (((((1UL | 0xC8AD6DF7L) < p_33) && ((-9L) != l_307)) ^ (l_308 > (l_309 != l_309))) > p_32))) - (uint16_t)p_32) != 0xFA897B05L) > p_33);
                l_312 = l_312;
                l_326 = ((uint16_t)((1L && (~((p_32 && ((uint64_t)((uint16_t)(((int32_t)0x638CF908L + (int32_t)p_32) | (((uint16_t)0xD730L / (uint16_t)((uint32_t)(0UL || (p_33 == p_33)) - (uint32_t)p_33)) >= (*l_310))) >> (uint16_t)12) - (uint64_t)0x78231FD8CBC5EB3FLL)) <= p_33))) || (*l_310)) >> (uint16_t)1);
                (*l_310) = (p_32 >= p_33);
            }
            (**l_309) = (**l_309);
            if (p_32)
                goto lbl_327;
        }
    }
    for (p_32 = 0; (p_32 == 44); p_32 += 8)
    { /* block id: 184 */
        int8_t l_397 = 0xABL;
        int32_t ***l_407 = &l_294;
        int32_t *l_419 = (void*)0;
        int32_t *l_420 = &l_293;
        for (p_33 = 0; (p_33 == (-21)); --p_33)
        { /* block id: 187 */
            int32_t l_396 = (-1L);
            int32_t *l_400 = &l_293;
            l_397 = l_396;
            (*l_400) = (0L <= (p_32 < (-8L)));
        }
        (*l_420) = (((uint16_t)(l_397 <= (((((int16_t)(((void*)0 == (**l_346)) > ((int64_t)(l_407 != (void*)0) - (int64_t)((uint32_t)((uint16_t)p_33 >> (uint16_t)(((int16_t)p_32 << (int16_t)8) ^ (!(p_32 && ((uint16_t)5UL - (uint16_t)p_32))))) % (uint32_t)p_32))) << (int16_t)p_32) < l_397) | p_32) >= 0xC3B4L)) >> (uint16_t)l_397) <= 0xEAD6L);
    }
    return p_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_34(int32_t ** p_35, int32_t  p_36, uint16_t  p_37)
{ /* block id: 122 */
    int32_t l_291 = 0x547229B2L;
    int32_t *l_290 = &l_291;
    int32_t **l_289 = &l_290;
    int32_t ***l_288 = &l_289;
    int32_t ****l_287 = &l_288;
    (**l_289) = ((void*)0 == l_287);
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_38(int32_t ** p_39, int32_t * p_40, uint32_t  p_41, int32_t ** p_42, int32_t ** p_43)
{ /* block id: 120 */
    int32_t l_281 = 0xA7656AE9L;
    int32_t *l_280 = &l_281;
    int32_t **l_279 = &l_280;
    int32_t **l_282 = &l_280;
    int32_t **l_283 = &l_280;
    int32_t **l_284 = &l_280;
    int32_t **l_285 = &l_280;
    int32_t **l_286 = (void*)0;
    return l_286;
    /* statement id: 121 */
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_44(uint32_t  p_45)
{ /* block id: 116 */
    int32_t ****l_272 = (void*)0;
    int32_t *****l_271 = &l_272;
    const int32_t **l_274 = (void*)0;
    const int32_t ***l_273 = &l_274;
    int32_t l_276 = 0x88EDF5FAL;
    int32_t *l_275 = &l_276;
    int32_t **l_277 = &l_275;
    int32_t **l_278 = (void*)0;
    (*l_275) = ((((uint32_t)((l_271 != (void*)0) && (l_273 != (void*)0)) - (uint32_t)(l_275 == (void*)0)) != p_45) ^ (p_45 >= p_45));
    (*l_277) = &l_276;
    return l_278;
    /* statement id: 119 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_46(uint32_t  p_47, uint32_t  p_48, uint16_t  p_49)
{ /* block id: 4 */
    int8_t l_60 = (-1L);
    int32_t l_68 = (-4L);
    uint16_t l_69 = 0x3564L;
    int32_t *l_79 = (void*)0;
    int16_t l_130 = 0L;
    int32_t ***l_171 = (void*)0;
    int32_t ****l_225 = &l_171;
    if ((((int32_t)(p_47 && (((uint16_t)(((int16_t)p_48 >> (int16_t)13) < p_48) >> (uint16_t)(((uint16_t)(0x6463A47399D012CDLL | ((l_60 > (((((int16_t)((int32_t)(((uint32_t)((!p_48) <= l_60) % (uint32_t)l_68) <= (((l_68 ^ p_47) < 1UL) && l_60)) % (int32_t)l_69) + (int16_t)l_69) | l_69) != p_47) || 0x4914D865E429B053LL)) != p_47)) << (uint16_t)l_68) != p_48)) ^ 0xCA2AE39B9AA6B35ELL)) + (int32_t)l_69) == p_49))
    { /* block id: 5 */
        int32_t **l_72 = (void*)0;
        int32_t l_73 = (-7L);
        int32_t *l_84 = &l_73;
        for (l_60 = 9; (l_60 <= (-9)); --l_60)
        { /* block id: 8 */
            l_73 = (l_72 != (void*)0);
        }
        (*l_84) = ((uint64_t)((-(uint32_t)(((int16_t)(l_79 != l_79) / (int16_t)((uint32_t)p_48 % (uint32_t)((0x607968679DD5AE90LL <= (((uint16_t)p_48 << (uint16_t)(p_47 <= ((p_47 <= (l_72 == &l_79)) || p_47))) == p_49)) | (-7L)))) ^ p_47)) || p_47) + (uint64_t)0xA864CC4390AC9F79LL);
        l_84 = l_79;
        /* statement id: 12 */
        assert (l_84 == 0);
    }
    else
    { /* block id: 13 */
        uint32_t l_85 = 0x4114ABDCL;
        int32_t l_98 = (-7L);
        int32_t *l_97 = &l_98;
        uint32_t l_114 = 0UL;
        uint16_t l_115 = 0x59E0L;
        l_85 = p_48;
        (*l_97) = (((p_49 <= l_69) | ((int64_t)(2UL & (((((-(int64_t)1L) ^ ((uint16_t)((int32_t)p_48 % (int32_t)p_47) - (uint16_t)((((int16_t)((int16_t)l_85 << (int16_t)1) >> (int16_t)(p_47 || 0x4255L)) > l_85) ^ p_47))) | p_49) & p_47) == (-1L))) % (int64_t)0x16ABE3F132C5A173LL)) < p_48);
        l_115 = (((uint16_t)((int64_t)(!p_49) - (int64_t)((0UL && (((uint16_t)0UL << (uint16_t)5) | p_47)) < (p_48 <= ((((((uint32_t)(1L & ((int16_t)((int64_t)l_114 / (int64_t)p_47) >> (int16_t)13)) - (uint32_t)p_48) ^ (*l_97)) ^ 0xA40F947660C92991LL) || 0L) <= 0x20E74272ABD0CEA3LL)))) >> (uint16_t)(*l_97)) > 2UL);
    }
    if (((int16_t)(l_79 == l_79) + (int16_t)(p_49 != p_48)))
    { /* block id: 18 */
        int32_t l_119 = 0x59BB015CL;
        int32_t *l_118 = &l_119;
        int32_t **l_120 = &l_118;
        int32_t l_147 = (-1L);
        const int32_t l_247 = 7L;
        (*l_120) = l_118;
        (*l_120) = l_79;
        /* statement id: 20 */
        assert (l_118 == 0);
        if (p_47)
        { /* block id: 21 */
            return p_48;
        }
        else
        { /* block id: 23 */
            int8_t l_121 = 0x41L;
            int32_t *l_122 = &l_119;
            int32_t ***l_188 = (void*)0;
            int32_t l_197 = 0xB4FEF38AL;
            uint32_t l_204 = 4294967290UL;
            int32_t *l_210 = &l_147;
            (*l_122) = l_121;
            (*l_122) = ((int16_t)p_47 >> (int16_t)((int16_t)(*l_122) >> (int16_t)12));
            for (p_49 = 0; (p_49 == 33); p_49 += 8)
            { /* block id: 28 */
                uint32_t l_134 = 0x9EBF7ADEL;
                int32_t **l_137 = &l_118;
            }
            if ((((p_48 || (&l_118 == (void*)0)) || (l_147 >= (!((int16_t)(((l_171 == &l_120) < (p_49 && ((p_48 != (~(((int16_t)(0x0FDDEAC1AD123397LL & 0xA91C2E77F79E9FF3LL) << (int16_t)p_48) ^ p_47))) ^ p_47))) != l_197) / (int16_t)p_49)))) ^ p_49))
            { /* block id: 62 */
                int32_t **l_200 = &l_79;
                int32_t ****l_216 = &l_171;
                int32_t *****l_217 = &l_216;
                for (l_119 = (-29); (l_119 == (-1)); l_119 += 3)
                { /* block id: 65 */
                    int32_t ****l_202 = &l_171;
                    if (l_60)
                    { /* block id: 66 */
                        int32_t ***l_201 = &l_200;
                        (*l_201) = l_200;
                        (**l_201) = (*l_200);
                    }
                    else
                    { /* block id: 69 */
                        int32_t *****l_203 = &l_202;
                        (*l_203) = l_202;
                        (*l_200) = (*l_120);
                        l_197 = p_47;
                    }
                    return l_204;
                }
                for (p_47 = 0; (p_47 > 58); p_47 += 7)
                { /* block id: 78 */
                    uint32_t l_207 = 0x39252E7EL;
                    l_207 = (*l_122);
                    (*l_120) = (*l_120);
                    for (l_119 = (-22); (l_119 >= (-7)); l_119 += 1)
                    { /* block id: 83 */
                        int16_t l_215 = (-5L);
                        l_210 = (*l_200);
                        /* statement id: 84 */
                        assert (l_210 == 0);
                        l_215 = ((int64_t)(p_47 >= p_49) + (int64_t)(((&l_118 != l_200) && 0xF9474E044EFE0625LL) && (l_207 | ((uint32_t)4294967292UL / (uint32_t)p_47))));
                        (*l_120) = (*l_120);
                        if ((*l_122))
                            break;
                    }
                    (*l_200) = (*l_200);
                }
                /* facts after for loop */
                assert (l_210 == 0 || l_210 == &l_147);
                (*l_217) = l_216;
                for (l_68 = 0; (l_68 != (-24)); --l_68)
                { /* block id: 94 */
                    int16_t l_226 = 1L;
                    l_226 = ((uint16_t)(-(uint16_t)((int64_t)(l_225 == &l_171) + (int64_t)0xDDA9EB16AD88BDD4LL)) % (uint16_t)(*l_122));
                }
            }
            else
            { /* block id: 97 */
                int64_t l_248 = 0x30141AF60F279C46LL;
                int32_t l_250 = (-9L);
lbl_251:
                (*l_210) = (p_49 < 0UL);
                if (((int16_t)((int64_t)p_47 - (int64_t)((uint64_t)((p_47 >= ((((uint16_t)(p_49 || (p_47 ^ ((int32_t)p_49 + (int32_t)(((int16_t)(((uint16_t)p_48 % (uint16_t)(((int16_t)(((uint64_t)l_247 % (uint64_t)0xC8FD093CF0600BE3LL) || l_248) - (int16_t)p_47) ^ 4294967288UL)) >= (*l_210)) << (int16_t)3) & 0xF48159CCD5EB8BACLL)))) >> (uint16_t)1) == 1L) || (-1L))) <= (*l_210)) % (uint64_t)p_47)) << (int16_t)6))
                { /* block id: 99 */
                    int8_t l_249 = 0xF2L;
                    int32_t ***l_260 = &l_120;
                    l_250 = l_249;
                    if (l_121)
                        goto lbl_251;
                    (*l_122) = (((int64_t)((uint16_t)(0x25BB58BC3C5A20AELL && 0x11C7F72D5D3A580ELL) - (uint16_t)0x164EL) % (int64_t)((uint64_t)((int16_t)((l_188 != l_260) || p_47) - (int16_t)(((void*)0 != l_260) >= ((uint16_t)(((uint16_t)p_49 + (uint16_t)0xD20DL) ^ p_49) << (uint16_t)p_49))) / (uint64_t)p_49)) < 0UL);
                }
                else
                { /* block id: 103 */
                    (*l_122) = p_49;
                    (*l_210) = (p_47 ^ ((uint16_t)p_48 / (uint16_t)1UL));
                    (*l_120) = (*l_120);
                    l_250 = p_47;
                }
                (*l_120) = &l_250;
                /* statement id: 109 */
                assert (l_118 == &l_250);
            }
            /* facts after branching */
            //assert (l_118 == dangling || l_118 == 0);
            assert (l_210 == 0 || l_210 == &l_147);
        }
        /* facts after branching */
        //assert (l_118 == dangling || l_118 == 0);
    }
    else
    { /* block id: 112 */
        int32_t l_268 = (-5L);
        int32_t *l_267 = &l_268;
        (*l_267) = 0xA275D891L;
    }
    return p_49;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 111
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 130
   depth: 2, occurrence: 19
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 4
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 92

XXX times a variable address is taken: 94
XXX times a pointer is dereferenced on RHS: 82
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 17
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 66
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 548

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 143
   level: 2, occurrence: 88
   level: 3, occurrence: 39
   level: 4, occurrence: 52
   level: 5, occurrence: 37
XXX number of pointers point to pointers: 63
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 31.5
XXX average alias set size: 1.1

XXX times a non-volatile is read: 619
XXX times a non-volatile is write: 190
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 112
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 24
   depth: 2, occurrence: 23
   depth: 3, occurrence: 11
   depth: 4, occurrence: 14
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 11.6
XXX percentage an existing variable is used: 88.4
********************* end of statistics **********************/

