/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      47411016
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_34(void);
static uint16_t  func_39(uint32_t  p_40, uint16_t  p_41);
inline static uint32_t  func_49(int32_t  p_50);
static const uint16_t  func_55(uint32_t  p_56, uint32_t  p_57, uint32_t  p_58, float  p_59, uint32_t  p_60);
static uint32_t  func_61(uint32_t  p_62, int32_t  p_63, int16_t  p_64, uint32_t  p_65, int16_t  p_66);
static const uint32_t  func_68(uint16_t  p_69);
inline static int32_t * func_70(int32_t * p_71, int32_t * p_72, int32_t * p_73, int32_t  p_74, uint32_t  p_75);
inline static int32_t * func_76(int32_t * p_77, uint16_t  p_78);
static int32_t * func_79(const int32_t * p_80, int16_t  p_81);
inline static const int32_t * func_82(int32_t  p_83, uint32_t  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_34(void)
{ /* block id: 36 */
    uint32_t l_35 = 4294967291UL;
    int32_t l_339 = 0L;
    float l_349 = (-0x9.Ep+1);
    float *l_348 = &l_349;
    float *l_350 = (void*)0;
    const int32_t *l_351 = &l_339;
    int32_t **l_372 = (void*)0;
    int32_t ***l_371 = &l_372;
    int32_t ****l_370 = &l_371;
    float l_407 = 0x2.ECD058p-73;
    uint32_t l_408 = 0x8B0A408DL;
    if (l_35)
    { /* block id: 37 */
        int32_t l_36 = 0x81438367L;
        int32_t **l_264 = (void*)0;
        int32_t ***l_263 = &l_264;
        int32_t l_313 = 0x1AFBE9ABL;
        int32_t *l_315 = &l_313;
        int32_t **l_314 = &l_315;
        l_36 = 1L;
        for (l_35 = 15; (l_35 >= 14); l_35 = safe_sub_func_int16_t_s_s(l_35, 1))
        { /* block id: 41 */
            int32_t l_67 = 0xF39F3C5AL;
            int32_t ** const * const l_265 = &l_264;
            l_313 = (((func_39((l_35 > (safe_mul_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u((+(safe_add_func_uint16_t_u_u(((__builtin_ffsl((func_49((safe_rshift_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(func_55(func_61(l_67, ((l_67 >= func_68(l_36)) != (safe_mul_func_int16_t_s_s(l_36, __builtin_parityl(l_36)))), (l_263 == l_265), l_35, l_35), l_67, l_35, l_67, l_67), l_35)), l_35))) == l_35)) > l_35) < l_35), l_36))), l_35)), l_35))), l_35) < 1UL) ^ 0UL) != 0xD729L);
            if (l_35)
                continue;
        }
        (*l_314) = (void*)0;
    }
    else
    { /* block id: 182 */
        float l_321 = (-0x2.5p-1);
        int32_t l_322 = 0x0EFD0CC2L;
        float *l_342 = &l_321;
        for (l_35 = 19; (l_35 >= 5); l_35 = safe_sub_func_int16_t_s_s(l_35, 6))
        { /* block id: 185 */
            int32_t l_318 = 0x2E633990L;
            int32_t *l_319 = (void*)0;
            int32_t *l_320 = &l_318;
            int32_t **l_334 = (void*)0;
            int32_t ** const *l_333 = &l_334;
            (*l_320) = l_318;
            l_322 = l_321;
            for (l_322 = 0; (l_322 <= (-12)); l_322 = safe_sub_func_uint16_t_u_u(l_322, 9))
            { /* block id: 190 */
                int32_t l_329 = (-1L);
                const int32_t * const **l_335 = (void*)0;
                float *l_336 = &l_321;
                (*l_336) = (safe_sub_func_float_f_f((safe_add_func_float_f_f(l_329, (-(safe_sub_func_float_f_f(l_329, __builtin_ctz((((__builtin_ffs(l_329) >= l_322) != 0xC20CL) > (l_333 != l_335)))))))), l_329));
                l_339 = ((*l_320) & (safe_lshift_func_int16_t_s_s(l_322, 9)));
            }
        }
        (*l_342) = (l_322 > (safe_sub_func_float_f_f(l_35, l_322)));
        return l_339;
    }
    l_351 = func_82(func_61((+((safe_lshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s((l_348 != l_350), func_39(l_339, l_35))), l_35)) <= l_339)), (l_35 || l_339), l_35, l_35, l_339), l_339);
    for (l_339 = 0; (l_339 < (-16)); l_339 = safe_sub_func_uint16_t_u_u(l_339, 1))
    { /* block id: 201 */
        int32_t *l_355 = &l_339;
        int32_t **l_354 = &l_355;
        uint16_t l_388 = 65535UL;
        int16_t l_390 = 0x5195L;
        (*l_354) = &l_339;
        for (l_35 = 15; (l_35 < 14); l_35 = safe_sub_func_uint32_t_u_u(l_35, 9))
        { /* block id: 205 */
            uint16_t l_358 = 0x081AL;
            float l_389 = 0x1.4p-1;
            int32_t *l_391 = (void*)0;
            int32_t l_393 = 0L;
            int32_t *l_392 = &l_393;
            l_351 = &l_339;
        }
        for (l_388 = 0; (l_388 < 18); l_388++)
        { /* block id: 217 */
            float l_398 = 0x3.A59629p+39;
            int32_t l_401 = 0L;
            int32_t ***l_404 = &l_354;
            int32_t l_405 = 0x249A5B31L;
            int32_t *l_406 = &l_405;
        }
    }
    return l_408;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_39(uint32_t  p_40, uint16_t  p_41)
{ /* block id: 169 */
    int32_t *l_309 = (void*)0;
    int32_t l_311 = 0x7D77FA01L;
    int32_t *l_310 = &l_311;
    int32_t **l_312 = &l_309;
    (*l_310) = p_40;
    if ((*l_310))
    { /* block id: 171 */
        return p_40;
    }
    else
    { /* block id: 173 */
        l_312 = &l_310;
    }
    (*l_312) = (void*)0;
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_49(int32_t  p_50)
{ /* block id: 166 */
    const int32_t l_306 = 0x71478F81L;
    const int32_t *l_305 = &l_306;
    int32_t *l_308 = (void*)0;
    int32_t **l_307 = &l_308;
    (*l_307) = func_79(func_79(l_305, p_50), p_50);
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_55(uint32_t  p_56, uint32_t  p_57, uint32_t  p_58, float  p_59, uint32_t  p_60)
{ /* block id: 158 */
    const uint16_t l_304 = 0xD9DEL;
    for (p_58 = 23; (p_58 == 7); --p_58)
    { /* block id: 161 */
        int32_t l_298 = 0x747682D1L;
        float l_300 = 0x2.BC268Fp+67;
        float *l_299 = &l_300;
        int32_t l_303 = 0L;
        int32_t *l_302 = &l_303;
        int32_t **l_301 = &l_302;
        (*l_299) = l_298;
        (*l_301) = func_82((l_298 | 4294967295UL), p_56);
    }
    return l_304;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_61(uint32_t  p_62, int32_t  p_63, int16_t  p_64, uint32_t  p_65, int16_t  p_66)
{ /* block id: 136 */
    int32_t l_269 = (-2L);
    int32_t *l_268 = &l_269;
    int32_t * const **l_293 = (void*)0;
    int32_t * const ***l_292 = &l_293;
    int32_t * const ****l_291 = &l_292;
    int32_t **l_294 = &l_268;
    float l_295 = 0x1.8p+1;
    if (p_66)
    { /* block id: 137 */
        int32_t l_267 = 1L;
        int32_t *l_266 = &l_267;
        int32_t ****l_271 = (void*)0;
        int32_t *****l_270 = &l_271;
        int32_t **l_274 = (void*)0;
        int32_t **l_275 = &l_268;
        (*l_275) = func_70(l_266, &l_267, l_268, (*l_266), __builtin_parity((func_68(p_65) != (((void*)0 != l_270) & (((safe_mod_func_int32_t_s_s(p_64, (*l_268))) >= p_66) == 0UL)))));
    }
    else
    { /* block id: 139 */
        int32_t *****l_276 = (void*)0;
        uint32_t l_277 = 1UL;
        int32_t *l_279 = &l_269;
        l_276 = (void*)0;
        if (l_277)
        { /* block id: 141 */
            int32_t *l_278 = &l_269;
            l_279 = l_278;
        }
        else
        { /* block id: 143 */
            int32_t *l_280 = &l_269;
            l_279 = func_76(l_280, (*l_279));
            return p_64;
        }
        for (p_66 = 0; (p_66 > (-18)); p_66 = safe_sub_func_int32_t_s_s(p_66, 6))
        { /* block id: 149 */
            const int32_t *l_283 = &l_269;
            int32_t **l_287 = (void*)0;
            int32_t *** const l_286 = &l_287;
            int32_t *** const *l_285 = &l_286;
            int32_t *** const ** const l_284 = &l_285;
            int32_t **l_288 = &l_268;
            (*l_288) = func_76(func_79(l_283, ((void*)0 == l_284)), (*l_283));
            (*l_279) = __builtin_ia32_crc32qi((safe_mod_func_uint16_t_u_u(l_269, p_66)), l_269);
        }
    }
    l_291 = l_291;
    l_269 = p_63;
    (*l_294) = &l_269;
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_68(uint16_t  p_69)
{ /* block id: 42 */
    uint16_t l_85 = 0x4A4EL;
    uint16_t l_117 = 0UL;
    int32_t l_225 = 0L;
    int32_t *l_224 = &l_225;
    int32_t **l_256 = &l_224;
    int32_t ***l_255 = &l_256;
    int32_t ****l_254 = &l_255;
    const uint16_t l_260 = 8UL;
    l_224 = func_70(func_76(func_79(func_82(p_69, l_85), l_117), (l_85 == p_69)), l_224, &l_225, (*l_224), (*l_224));
    for (p_69 = 0; (p_69 > 21); ++p_69)
    { /* block id: 130 */
        float *l_251 = (void*)0;
        float *l_252 = (void*)0;
        int32_t l_253 = 1L;
        int32_t ** const *l_259 = &l_256;
        int32_t ** const **l_258 = &l_259;
        int32_t ** const ***l_257 = &l_258;
        l_253 = 0x0.0p-1;
        (*l_257) = l_254;
        if (l_260)
            break;
    }
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_70(int32_t * p_71, int32_t * p_72, int32_t * p_73, int32_t  p_74, uint32_t  p_75)
{ /* block id: 111 */
    int32_t * const l_230 = (void*)0;
    int32_t * const *l_229 = &l_230;
    int32_t * const **l_228 = &l_229;
    float l_244 = 0x1.5p-1;
    float *l_243 = &l_244;
    int32_t l_246 = 0xF467C7D0L;
    int32_t *l_245 = &l_246;
    int32_t *l_247 = &l_246;
    int32_t *l_248 = (void*)0;
    (*p_73) = (safe_lshift_func_int16_t_s_u((l_228 != &l_229), (safe_sub_func_uint16_t_u_u((p_75 == p_74), (0x5E4FF753L > (*p_72))))));
    (*p_73) = (safe_rshift_func_uint16_t_u_s(p_74, 11));
    for (p_74 = 17; (p_74 != (-23)); --p_74)
    { /* block id: 116 */
        int32_t l_238 = (-9L);
        const int32_t *l_237 = &l_238;
        int32_t *l_240 = &l_238;
        int32_t **l_239 = &l_240;
        (*l_239) = func_79(l_237, p_74);
        for (l_238 = (-18); (l_238 == 13); l_238++)
        { /* block id: 120 */
            (*p_72) = 0L;
        }
        (*p_73) = ((void*)0 == &p_74);
    }
    (*l_243) = p_74;
    return l_248;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_76(int32_t * p_77, uint16_t  p_78)
{ /* block id: 66 */
    uint32_t l_144 = 18446744073709551615UL;
    int32_t ****l_147 = (void*)0;
    uint16_t l_160 = 0x7C2DL;
    int32_t l_165 = 0x0E566308L;
    int32_t *l_164 = &l_165;
    int32_t * const l_220 = &l_165;
    int32_t *l_223 = &l_165;
    for (p_78 = 0; (p_78 != 38); ++p_78)
    { /* block id: 69 */
        int32_t l_152 = 0x736D3DFDL;
        int32_t *l_151 = &l_152;
        int32_t **l_150 = &l_151;
        int32_t ***l_149 = &l_150;
        int32_t ****l_148 = &l_149;
        float l_154 = (-0x6.Bp-1);
        float *l_153 = &l_154;
        (*l_153) = (safe_mul_func_float_f_f((safe_sub_func_float_f_f((safe_sub_func_float_f_f((0xC.9556C6p+79 <= ((safe_sub_func_float_f_f((l_144 >= p_78), (((l_144 != (safe_sub_func_float_f_f(p_78, ((l_147 == l_147) > (0x4.5p+1 != (l_148 == (void*)0)))))) >= 0x9.294528p-65) >= 0x0.Ap-1))) >= (*l_151))), 0xE.2B8ADFp+19)), 0x1.Dp-1)), p_78));
    }
    if (((1L || (0L && (safe_mul_func_int16_t_s_s(((!p_78) ^ p_78), (p_78 | p_78))))) || ((((65530UL | l_144) & ((safe_add_func_uint32_t_u_u(p_78, 0x4BAAF504L)) == 1L)) < 3L) == l_160)))
    { /* block id: 72 */
        uint32_t l_161 = 8UL;
        float l_163 = (-0x1.Fp-1);
        float *l_162 = &l_163;
        (*l_162) = (l_161 <= l_160);
        l_164 = l_162;
    }
    else
    { /* block id: 75 */
        float l_166 = (-0x1.9p+1);
        int32_t l_167 = 1L;
        int32_t ***l_186 = (void*)0;
        if ((((l_167 && ((*l_164) < p_78)) == (l_167 > ((safe_mul_func_int16_t_s_s((p_78 != (0xF1AFL == __builtin_clzll(((void*)0 != l_164)))), l_167)) >= 4294967289UL))) < p_78))
        { /* block id: 76 */
            (*l_164) = p_78;
        }
        else
        { /* block id: 78 */
            int32_t l_178 = (-4L);
            int32_t *l_201 = &l_167;
            const int32_t *l_222 = &l_167;
            const int32_t **l_221 = &l_222;
            (*l_164) = (safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u(1UL, (safe_mul_func_int16_t_s_s(l_178, p_78)))), 1)), 6));
            if ((~(((safe_add_func_int32_t_s_s(((safe_add_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((l_186 == l_186) != __builtin_bswap32(p_78)), p_78)), ((!p_78) >= (safe_lshift_func_uint16_t_u_u(((((safe_unary_minus_func_int16_t_s(0L)) >= (((1L && (((p_78 > (*l_164)) != p_78) >= l_178)) && p_78) | 1UL)) != 65534UL) | l_167), p_78))))) >= p_78), (*l_164))) || 0xE3071259L) > 0xB9B0A51EL)))
            { /* block id: 80 */
                float *l_196 = (void*)0;
                float *l_197 = &l_166;
                (*l_197) = (p_78 > ((+(safe_sub_func_float_f_f(p_78, (0xC.397568p-60 <= p_78)))) == 0x1.9p+1));
                for (p_78 = 0; (p_78 > 28); p_78 = safe_add_func_uint16_t_u_u(p_78, 2))
                { /* block id: 84 */
                    int32_t *l_200 = &l_167;
                    return p_77;
                }
            }
            else
            { /* block id: 87 */
                const int32_t l_202 = (-1L);
                if ((*l_201))
                { /* block id: 88 */
                    int32_t l_214 = 0xBD2AF93AL;
                    int32_t l_216 = 0x8B9DDC81L;
                    (*l_164) = ((p_78 <= ((((void*)0 != p_77) < p_78) ^ l_202)) > l_202);
                    if ((__builtin_popcountll(p_78) | l_202))
                    { /* block id: 90 */
                        float l_205 = 0x3.0CBE00p-88;
                        int32_t l_206 = 0xAE4519CDL;
                        float l_207 = 0xE.9EB048p-11;
                        (*l_164) = __builtin_parityll(l_202);
                        (*l_201) = ((((safe_add_func_uint16_t_u_u(p_78, (*l_164))) <= p_78) || l_206) == p_78);
                    }
                    else
                    { /* block id: 93 */
                        uint32_t l_215 = 0x59E5908BL;
                        (*l_164) = (((safe_mod_func_uint16_t_u_u((*l_201), (safe_lshift_func_int16_t_s_s((__builtin_popcount(l_214) >= (l_215 != 2UL)), 8)))) | l_215) ^ p_78);
                        p_77 = p_77;
                        l_216 = p_78;
                    }
                    for (l_214 = 26; (l_214 > (-2)); l_214 = safe_sub_func_uint32_t_u_u(l_214, 8))
                    { /* block id: 100 */
                        (*l_201) = (p_77 != p_77);
                    }
                }
                else
                { /* block id: 103 */
                    int32_t l_219 = 0x03D30EE1L;
                    (*l_201) = l_219;
                }
            }
            (*l_221) = l_220;
        }
    }
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_79(const int32_t * p_80, int16_t  p_81)
{ /* block id: 60 */
    int32_t l_118 = (-3L);
    int32_t l_120 = 0x52E9AD70L;
    int32_t *l_119 = &l_120;
    const int32_t *l_126 = &l_120;
    int32_t **l_128 = &l_119;
    int32_t ***l_127 = &l_128;
    const int32_t **l_131 = &l_126;
    const int32_t ***l_130 = &l_131;
    const int32_t ****l_129 = &l_130;
    int32_t *l_132 = &l_120;
    int32_t *l_133 = (void*)0;
    l_126 = func_82(l_118, (((void*)0 != l_119) >= (safe_sub_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u(0x657DL, ((*l_119) | (safe_unary_minus_func_int32_t_s((((__builtin_parity(((*l_119) < 9UL)) >= 0x685B35A0L) || p_81) && 7UL)))))) && p_81), p_81))));
    (*l_119) = (*l_119);
    (*l_129) = l_127;
    (***l_129) = p_80;
    return l_133;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_82(int32_t  p_83, uint32_t  p_84)
{ /* block id: 43 */
    int32_t l_100 = 0x21A16747L;
    int32_t *l_102 = (void*)0;
    int32_t **l_108 = &l_102;
    float l_112 = 0x1.1p+1;
    float *l_111 = &l_112;
    const int32_t l_114 = 0x8FB0C4F3L;
    const int32_t *l_113 = &l_114;
    const int32_t *l_115 = &l_114;
    const int32_t *l_116 = (void*)0;
    for (p_84 = 0; (p_84 > 33); ++p_84)
    { /* block id: 46 */
        uint16_t l_88 = 0x91A7L;
        int32_t l_101 = 0x7C2923F8L;
        if (l_88)
            break;
        l_101 = ((__builtin_parity((!(safe_lshift_func_int16_t_s_u(__builtin_clz(p_83), (safe_lshift_func_uint16_t_u_u((l_88 != l_88), ((p_83 || (safe_sub_func_int16_t_s_s(l_88, (safe_mod_func_uint32_t_u_u((p_83 ^ p_84), (safe_mod_func_uint32_t_u_u(__builtin_ctzll(p_83), l_100))))))) == p_83))))))) < p_83) > p_83);
    }
    l_102 = l_102;
    for (p_83 = (-4); (p_83 > 4); p_83 = safe_add_func_int32_t_s_s(p_83, 1))
    { /* block id: 53 */
        int32_t **l_105 = &l_102;
        int32_t * const **l_106 = (void*)0;
        int32_t ***l_107 = (void*)0;
        (*l_105) = (void*)0;
        l_108 = &l_102;
        (*l_105) = (*l_108);
    }
    (*l_111) = (safe_mul_func_float_f_f(p_83, (p_84 != (p_83 >= (p_84 <= p_83)))));
    return l_116;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 107
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 21
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 5
   depth: 6, occurrence: 3
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 21, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 117

XXX times a variable address is taken: 93
XXX times a pointer is dereferenced on RHS: 33
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 3
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 45
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 0
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 279

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 142
   level: 2, occurrence: 14
   level: 3, occurrence: 28
   level: 4, occurrence: 8
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 63
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 36.8
XXX average alias set size: 1.21

XXX times a non-volatile is read: 367
XXX times a non-volatile is write: 129
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 102
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 38
   depth: 1, occurrence: 32
   depth: 2, occurrence: 16
   depth: 3, occurrence: 5
   depth: 4, occurrence: 5
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 20
XXX percentage an existing variable is used: 80
********************* end of statistics **********************/

