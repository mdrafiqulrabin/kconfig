/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1500504796
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static uint16_t g_5 = 1U;
static struct S0 g_62 = {0U};
static int32_t g_77 = 0x544BD1A6;
static const int32_t *g_91 = (void*)0;
static const int32_t **g_90 = &g_91;
static const int32_t ***g_89 = &g_90;
static float g_101 = 0xC.293E9Fp-52;
static struct S0 g_122 = {65532U};
static int32_t g_152 = 0xFD8E19E2;
static uint16_t g_156 = 0xAC17;
static int32_t *g_166 = &g_152;
static const int16_t g_195 = 0xBB6E;
static struct S0 *g_231 = (void*)0;
static struct S0 **g_230 = &g_231;
static uint16_t g_271 = 65535U;
static const float *g_309 = (void*)0;
static const float **g_308 = &g_309;
static float *g_392 = &g_101;
static float **g_391 = &g_392;
static float ***g_390 = &g_391;
static float g_426 = 0x7.FD2F14p+4;
static int32_t *g_582 = &g_152;
static float ****g_624 = &g_390;
static float *****g_623 = &g_624;
static int16_t g_730 = 0x2E82;
static uint32_t g_737 = 4294967295U;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_26(void);
static uint16_t  func_33(uint16_t  p_34, uint32_t  p_35, uint32_t  p_36);
static float  func_41(int32_t  p_42);
static float  func_44(float  p_45, uint32_t  p_46, int16_t  p_47, int32_t  p_48);
static int16_t  func_55(uint32_t  p_56);
static int32_t * func_57(int32_t  p_58, struct S0  p_59, uint32_t  p_60, int32_t * p_61);
static int32_t  func_64(int32_t * p_65);
static int32_t * func_66(struct S0  p_67);
static struct S0  func_68(struct S0  p_69, struct S0  p_70);
static struct S0  func_71(float  p_72, int32_t * p_73, const uint32_t  p_74, int32_t  p_75);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_62 g_77 g_89 g_101 g_90 g_91 g_156 g_166 g_122 g_152 g_195 g_230 g_271 g_308 g_309 g_390 g_391 g_392 g_582 g_624 g_623 g_730 g_737 g_231
 * writes: g_101 g_77 g_122 g_91 g_152 g_156 g_166 g_62 g_230 g_231 g_90 g_271 g_5
 */
static int32_t  func_26(void)
{ /* block id: 36 */
    int16_t l_49 = 0x16B5;
    struct S0 l_696 = {65535U};
    int32_t *l_697 = &g_152;
    int32_t *l_698 = &g_152;
    struct S0 ***l_713 = &g_230;
    uint32_t l_732 = 0x162EB888;
    struct S0 **l_733 = &g_231;
    if (((int16_t)((int32_t)g_5 / (int32_t)(-1)) - (int16_t)((uint16_t)func_33(((((float)(((float)func_41(g_5) + (float)func_44(l_49, ((((!(g_5 , ((int32_t)g_5 % (int32_t)(((uint32_t)((func_55(l_49) && g_5) && l_49) + (uint32_t)l_49) ^ g_195)))) > g_5) <= 0x6E04B886) >= l_49), g_195, g_195)) <= l_49) / (float)l_49) == l_49) , g_195), l_49, g_271) % (uint16_t)g_5)))
    { /* block id: 474 */
        float *****l_701 = &g_624;
        int32_t l_702 = 1;
        uint16_t l_723 = 65535U;
        struct S0 l_731 = {0x3FA1};
        (*g_90) = l_698;
        for (l_696.f0 = 13; (l_696.f0 >= 20); l_696.f0 += 2)
        { /* block id: 478 */
            int32_t l_709 = 0xA8BE222E;
            const struct S0 *l_712 = &g_62;
            const struct S0 **l_711 = &l_712;
            const struct S0 ***l_710 = &l_711;
            if ((*l_698))
                break;
            (*l_698) = (((__builtin_ffsll(g_77) & (((***g_89) ^ (&g_624 == l_701)) , (((*l_698) & g_156) | g_5))) | g_62.f0) | l_702);
            for (g_5 = 20; (g_5 < 11); --g_5)
            { /* block id: 483 */
                int32_t l_714 = 0x3A806DE8;
                uint32_t l_722 = 0xBF6291EF;
                (*l_697) = func_33((((*l_698) == ((uint16_t)(((uint32_t)(g_5 >= ((**g_90) > (((l_709 , l_710) != l_713) <= (l_714 ^ (((uint32_t)((int32_t)((int16_t)(*l_698) >> (int16_t)(~(**g_90))) - (int32_t)0x0E93672E) % (uint32_t)g_156) , l_722))))) - (uint32_t)0xC496931C) < g_195) + (uint16_t)0x9845)) , l_723), l_714, g_156);
                (*g_90) = (((uint16_t)(((int32_t)__builtin_clz((__builtin_parity(l_709) < (__builtin_ffs(l_709) | (0U >= 0U)))) / (int32_t)g_730) > ((**l_711) , 8)) >> (uint16_t)g_122.f0) , (void*)0);
                return l_709;
            }
            l_731 = g_122;
        }
    }
    else
    { /* block id: 490 */
        float l_744 = 0x8.FE9F81p-34;
        float ***l_745 = &g_391;
        struct S0 l_748 = {65535U};
        (***g_390) = l_732;
        (*l_713) = l_733;
        if ((*l_698))
        { /* block id: 493 */
            (*g_582) = ((+1) , (*l_698));
            (*l_697) = ((int32_t)g_737 / (int32_t)0xFB06963E);
        }
        else
        { /* block id: 496 */
            int32_t l_742 = (-1);
            (*l_733) = &g_122;
            (**l_733) = (((float)(((float)l_742 - (float)(-(float)l_744)) < ((void*)0 == l_745)) + (float)((float)(*****g_623) / (float)(***g_390))) , func_68((__builtin_popcount(__builtin_bswap32((*l_698))) , l_748), (***l_713)));
            (*l_733) = &l_748;
        }
    }
    return (*g_582);
}


/* ------------------------------------------ */
/* 
 * reads : g_122.f0 g_390 g_391 g_392 g_101 g_62.f0 g_152 g_77 g_271 g_89 g_90 g_156 g_5 g_91 g_62 g_195 g_582 g_230 g_624 g_623 g_166
 * writes: g_122.f0 g_101 g_152 g_91 g_156 g_62 g_271 g_77 g_90 g_122 g_231 g_166
 */
static uint16_t  func_33(uint16_t  p_34, uint32_t  p_35, uint32_t  p_36)
{ /* block id: 268 */
    struct S0 **l_419 = &g_231;
    int32_t l_424 = 1;
    struct S0 **l_425 = (void*)0;
    float l_427 = (-0x1.Ep+1);
    struct S0 l_454 = {0x0D2C};
    float ***l_487 = &g_391;
    struct S0 l_502 = {65527U};
    uint32_t l_535 = 0U;
    int32_t **l_562 = &g_166;
    int32_t ***l_561 = &l_562;
    int32_t ****l_560 = &l_561;
    int32_t l_563 = 1;
    int32_t *****l_564 = &l_560;
    float l_565 = 0xE.3C03E8p-60;
    struct S0 l_584 = {0xF47A};
lbl_665:
    for (g_122.f0 = (-5); (g_122.f0 == 30); g_122.f0 += 5)
    { /* block id: 271 */
        struct S0 l_412 = {0x60F0};
        int32_t *l_434 = (void*)0;
        int32_t l_452 = (-10);
        float l_489 = 0x8.Fp-1;
        l_412 = l_412;
        (***g_390) = ((((float)(p_34 >= func_41(l_412.f0)) - (float)(((((int16_t)((((((uint32_t)((l_419 != (((***g_390) > (0x1.Cp+1 > ((*g_392) >= ((float)0x6.304496p-95 + (float)((float)(l_424 <= p_36) + (float)p_34))))) , l_419)) || g_62.f0) % (uint32_t)l_412.f0) , &g_231) == l_425) & g_152) , g_77) - (int16_t)g_271) & (-1)) ^ g_122.f0) , l_424)) != (***g_390)) == 0x0.97AFF5p-33);
        if (l_424)
        { /* block id: 274 */
            struct S0 l_430 = {0x4E62};
            float ****l_432 = &g_390;
            int32_t *l_437 = &g_77;
            for (g_152 = (-20); (g_152 >= (-21)); g_152 -= 8)
            { /* block id: 277 */
                struct S0 *l_431 = &l_412;
                float *****l_433 = &l_432;
                (*l_431) = func_68(l_412, l_430);
                (*l_433) = l_432;
            }
            (*g_90) = l_434;
            for (g_156 = 0; (g_156 == 47); ++g_156)
            { /* block id: 284 */
                (*g_90) = &l_424;
                (**g_89) = l_437;
                if (l_424)
                    continue;
            }
            return g_152;
        }
        else
        { /* block id: 290 */
            int32_t l_442 = 0xF04D9FC2;
            struct S0 l_455 = {0xE8B7};
            int32_t **l_474 = (void*)0;
            struct S0 *l_503 = &g_62;
            if (((p_35 ^ (((g_5 | (l_442 == __builtin_ctzl(((int32_t)p_34 + (int32_t)p_35)))) < ((int16_t)p_34 % (int16_t)((g_122.f0 <= (((uint16_t)(0x1F3A && l_424) % (uint16_t)p_34) < 0xC510959B)) | l_424))) != 0xD45A)) < p_36))
            { /* block id: 291 */
                uint16_t l_451 = 1U;
                int32_t *l_453 = &l_442;
                l_452 = (l_451 == g_122.f0);
                (*g_90) = l_453;
            }
            else
            { /* block id: 294 */
                struct S0 l_456 = {0x59E4};
                struct S0 *l_457 = (void*)0;
                struct S0 *l_458 = &l_455;
                int32_t **l_461 = (void*)0;
                int32_t ***l_460 = &l_461;
                int32_t ****l_459 = &l_460;
                int32_t *****l_462 = &l_459;
                (*l_458) = ((l_442 & p_34) , ((p_36 <= l_442) , func_68(l_454, func_68(l_455, l_456))));
                (**g_391) = l_454.f0;
                (*l_462) = l_459;
            }
            if (l_454.f0)
            { /* block id: 299 */
                int32_t **l_467 = &g_166;
                struct S0 l_476 = {0x116C};
                (**g_89) = &l_424;
                if ((((uint16_t)(((int16_t)(l_455 , ((((g_62.f0 >= (-10)) , (*g_89)) != l_467) > ((!0xE3F4236D) | (((int16_t)(((~(l_474 != (*g_89))) <= (&g_90 == &l_467)) <= g_122.f0) / (int16_t)g_62.f0) < p_34)))) >> (int16_t)g_152) < (***g_89)) << (uint16_t)l_442) == 1))
                { /* block id: 301 */
                    struct S0 l_475 = {0x9E9B};
                    int32_t l_490 = 0x275C3BD3;
                    if (p_34)
                    { /* block id: 302 */
                        uint32_t l_482 = 5U;
                        int32_t *l_483 = (void*)0;
                        int32_t *l_484 = &l_442;
                        l_476 = func_68(l_475, l_455);
                        (*l_484) = ((uint16_t)(__builtin_ffs(((uint32_t)4294967295U / (uint32_t)((((__builtin_bswap32((-(int16_t)g_77)) <= (*g_91)) <= (((p_34 || __builtin_bswap32(g_122.f0)) , 0x0783) , p_36)) | 0U) , l_482))) < p_35) >> (uint16_t)l_424);
                        (*l_484) = (((int16_t)(((p_34 , l_487) != (void*)0) ^ l_424) - (int16_t)p_34) , (***g_89));
                        (***l_487) = (*g_392);
                    }
                    else
                    { /* block id: 307 */
                        (*g_392) = ((!p_34) , l_489);
                        l_490 = (**g_90);
                    }
                    (*g_90) = &l_490;
                    if ((*g_91))
                        break;
                    for (l_475.f0 = (-1); (l_475.f0 <= 42); l_475.f0++)
                    { /* block id: 315 */
                        const int16_t l_493 = (-1);
                        if (l_493)
                            break;
                        if (l_454.f0)
                            continue;
                        return l_493;
                    }
                }
                else
                { /* block id: 320 */
                    struct S0 l_494 = {1U};
                    if ((func_68(func_68(l_412, (func_68(l_455, func_68(func_68(func_68(l_412, l_494), l_494), l_494)) , l_455)), l_476) , (-7)))
                    { /* block id: 321 */
                        return l_454.f0;
                    }
                    else
                    { /* block id: 323 */
                        struct S0 ***l_496 = &l_419;
                        struct S0 ****l_495 = &l_496;
                        int32_t **l_497 = &l_434;
                        int32_t ***l_498 = &l_497;
                        int32_t *l_499 = &g_152;
                        (*l_495) = &g_230;
                        (*l_498) = l_497;
                        (*l_499) = (**g_90);
                        if ((***g_89))
                            continue;
                    }
                    (**g_89) = (*g_90);
                }
                if (p_36)
                    break;
            }
            else
            { /* block id: 332 */
                struct S0 l_500 = {0x5BD1};
                struct S0 *l_501 = &l_455;
                l_434 = &l_452;
                (*l_501) = func_68(((*l_434) , (l_500 , l_412)), func_68(g_62, l_412));
            }
            (*l_503) = func_68(func_68(l_455, l_502), l_412);
        }
    }
    for (p_34 = 14; (p_34 == 27); p_34 += 9)
    { /* block id: 341 */
        struct S0 l_506 = {0xBDD0};
        float ***l_549 = &g_391;
        struct S0 ***l_559 = &g_230;
        const int32_t *l_581 = &l_563;
        int32_t l_657 = 0x936A02B3;
        l_506 = l_506;
        (**g_391) = l_506.f0;
        if (p_34)
        { /* block id: 344 */
            const float l_507 = 0x4.670A1Ap-28;
            int32_t l_512 = 0xE355F6F7;
            const struct S0 ****l_538 = (void*)0;
            const int32_t ***l_548 = &g_90;
            struct S0 l_566 = {1U};
            int32_t *l_579 = (void*)0;
            int32_t *l_580 = &l_512;
            if (l_424)
            { /* block id: 345 */
                uint32_t l_514 = 4294967295U;
                int32_t *l_520 = &l_512;
                uint32_t l_529 = 1U;
                struct S0 l_540 = {4U};
                struct S0 *l_546 = (void*)0;
                struct S0 *l_547 = &l_454;
                for (g_156 = 17; (g_156 > 53); ++g_156)
                { /* block id: 348 */
                    struct S0 l_515 = {0x7BD0};
                    int32_t *l_516 = &l_424;
                    (*g_90) = &l_512;
                    (**g_89) = l_520;
                    for (g_62.f0 = (-18); (g_62.f0 < 43); g_62.f0 += 6)
                    { /* block id: 353 */
                        uint16_t l_532 = 0x456A;
                        (*l_520) = ((0xBC187AC4 == ((int16_t)((p_36 , ((uint16_t)(g_271 == (((((__builtin_parity(((uint32_t)(l_529 , (((uint16_t)(l_512 <= (*l_520)) - (uint16_t)(0x786CBCB0 > ((((l_532 & ((uint16_t)g_122.f0 >> (uint16_t)1)) > 7U) > p_35) <= 0x84A2))) , p_35)) - (uint32_t)1U)) , l_535) & (***g_89)) > (***g_89)) && g_5) >= p_35)) % (uint16_t)g_5)) | p_36) / (int16_t)0x186E)) >= 0x963E2073);
                    }
                }
                for (g_271 = 0; (g_271 >= 39); g_271 += 7)
                { /* block id: 359 */
                    const float **l_539 = &g_309;
                    int32_t l_545 = 9;
                    l_538 = (void*)0;
                    (*g_90) = l_520;
                    if (((l_539 != (l_540 , (void*)0)) != ((uint32_t)((((l_506 , (g_122.f0 && ((int32_t)__builtin_parityl(p_34) - (int32_t)g_77))) > g_122.f0) <= p_36) == 0x651F) % (uint32_t)4294967295U)))
                    { /* block id: 362 */
                        (*g_392) = l_502.f0;
                        return l_506.f0;
                    }
                    else
                    { /* block id: 365 */
                        (**g_89) = (**g_89);
                    }
                }
                (*l_547) = l_506;
                if (p_36)
                    break;
            }
            else
            { /* block id: 371 */
                struct S0 l_550 = {0x353D};
                struct S0 *l_551 = &g_62;
                (***l_487) = (((l_548 == &g_90) , l_487) != (p_35 , l_549));
                (*l_551) = func_68(l_550, l_550);
                if (((void*)0 == (*g_390)))
                { /* block id: 374 */
                    struct S0 l_552 = {0x668D};
                    int32_t *l_553 = &g_77;
                    struct S0 ***l_558 = &l_425;
                    if ((***l_548))
                    { /* block id: 375 */
                        (**g_89) = l_553;
                        (***l_549) = (*g_392);
                    }
                    else
                    { /* block id: 378 */
                        l_512 = ((float)((float)0x2.0p+1 + (float)(***g_390)) / (float)(***g_390));
                    }
                    (*l_553) = 0x9EDCDDD3;
                    l_564 = ((__builtin_parity(((-1) || (((((***l_548) != (l_535 , (l_558 == l_559))) <= (((*l_551) , l_560) == &l_561)) < l_506.f0) , l_563))) , 0U) , &l_560);
                }
                else
                { /* block id: 383 */
                    struct S0 l_567 = {1U};
                    int32_t *l_570 = &l_563;
                    struct S0 ***l_571 = &g_230;
                    if ((**g_90))
                        break;
                    (*l_570) = (0xBA38 & (((&g_308 == &g_308) > (l_566 , (g_152 < ((l_567 , p_34) > g_195)))) || ((uint16_t)(__builtin_ffsl((g_62.f0 | (***l_548))) && g_5) - (uint16_t)p_35)));
                    (*l_570) = ((l_571 == (g_195 , &g_230)) < (&l_425 != (void*)0));
                }
                (*l_548) = (*g_89);
            }
            (*l_580) = ((((!((int16_t)((uint16_t)p_34 << (uint16_t)10) % (int16_t)((uint16_t)1U % (uint16_t)g_62.f0))) && g_62.f0) <= (__builtin_ia32_crc32qi((0x7078620B != 2U), l_506.f0) == ((p_35 , (***g_390)) , (-7)))) == p_35);
            (**g_89) = l_581;
            return p_35;
        }
        else
        { /* block id: 393 */
            struct S0 l_583 = {0U};
            float ***l_599 = &g_391;
            const int32_t *l_663 = (void*)0;
            int32_t *l_669 = (void*)0;
            int32_t l_679 = 1;
            (**g_89) = g_582;
            g_62 = func_68(l_583, l_584);
            if ((*l_581))
            { /* block id: 396 */
                uint16_t l_594 = 65535U;
                struct S0 l_606 = {65527U};
                int32_t l_627 = 0x3DBE77CA;
                uint32_t l_629 = 0x8DB43B4A;
                float l_631 = 0x4.3p-1;
                struct S0 ****l_660 = (void*)0;
                if (((uint16_t)g_62.f0 >> (uint16_t)__builtin_parity(p_34)))
                { /* block id: 397 */
                    struct S0 l_591 = {0U};
                    for (p_35 = 0; (p_35 <= 50); p_35 += 3)
                    { /* block id: 400 */
                        struct S0 ***l_589 = &l_425;
                        struct S0 ****l_590 = &l_559;
                        (*l_590) = l_589;
                        l_591 = func_71((**g_391), &g_152, (p_36 == g_152), g_152);
                        (**g_89) = (**g_89);
                    }
                    (*g_89) = (*g_89);
                }
                else
                { /* block id: 406 */
                    int16_t l_612 = 0x64E5;
                    int32_t *l_628 = &l_563;
                    if ((((uint16_t)0U + (uint16_t)(g_156 , ((l_594 , (p_35 > ((uint32_t)__builtin_bswap32(p_36) + (uint32_t)l_583.f0))) == 4))) && p_36))
                    { /* block id: 407 */
                        return g_152;
                    }
                    else
                    { /* block id: 409 */
                        int16_t l_605 = 1;
                        (**g_89) = (*g_90);
                        (**l_559) = &g_62;
                    }
                    (*g_582) = (l_583.f0 != ((uint16_t)(g_5 & (((l_583.f0 || (!((uint16_t)(l_612 ^ p_34) / (uint16_t)g_271))) , (g_195 , (void*)0)) != (void*)0)) + (uint16_t)p_36));
                    for (l_584.f0 = 21; (l_584.f0 <= 1); l_584.f0 -= 8)
                    { /* block id: 416 */
                        uint16_t l_616 = 0x32BA;
                    }
                }
                if (l_627)
                { /* block id: 422 */
                    uint32_t l_646 = 0U;
                    if (((*g_624) == (void*)0))
                    { /* block id: 423 */
                        int32_t *l_630 = &g_152;
                        (*g_392) = p_36;
                        (*g_90) = (l_629 , l_630);
                        (***g_390) = p_36;
                        (*****g_623) = (((((l_631 >= ((float)((-(float)((float)p_36 + (float)((*l_581) == ((float)((__builtin_ffs((((l_583.f0 ^ (p_34 && (+((uint16_t)((int32_t)((((uint16_t)((&g_90 != (void*)0) | (0x089C922C == 0x64E8EE3A)) >> (uint16_t)g_195) , (*l_581)) & p_36) + (int32_t)0xB52815D4) << (uint16_t)g_156)))) , 65535U) <= g_271)) != (**g_391)) <= l_606.f0) / (float)p_35)))) == l_583.f0) / (float)(***g_390))) == p_36) < (*l_630)) != p_36) >= 0x5.F874E7p-66);
                    }
                    else
                    { /* block id: 428 */
                        return l_646;
                    }
                    l_657 = ((uint16_t)((uint16_t)p_36 >> (uint16_t)l_646) >> (uint16_t)(((int32_t)l_583.f0 % (int32_t)((int16_t)g_152 / (int16_t)g_195)) , (((int16_t)(g_271 && g_156) >> (int16_t)p_35) == (&g_231 != &g_231))));
                    for (g_271 = (-20); (g_271 > 9); g_271 += 3)
                    { /* block id: 434 */
                        (**g_89) = (*g_90);
                        l_663 = ((((void*)0 != l_660) , ((int16_t)p_36 << (int16_t)p_36)) , (**g_89));
                    }
                    (*g_90) = (**g_89);
                }
                else
                { /* block id: 439 */
                    struct S0 l_664 = {0x567B};
                    (**l_561) = &l_627;
                    if ((*g_91))
                        continue;
                    if (p_36)
                        goto lbl_665;
                }
            }
            else
            { /* block id: 444 */
                int16_t l_685 = (-1);
                struct S0 l_692 = {0U};
                for (l_584.f0 = (-24); (l_584.f0 != 23); ++l_584.f0)
                { /* block id: 447 */
                    struct S0 l_668 = {0U};
                    l_663 = (*g_90);
                    if ((*g_582))
                        continue;
                }
                if (p_35)
                    continue;
                if (g_195)
                    goto lbl_665;
                for (l_584.f0 = 8; (l_584.f0 == 40); l_584.f0 += 2)
                { /* block id: 455 */
                    uint16_t l_677 = 65535U;
                    struct S0 ***l_678 = &g_230;
                    struct S0 *l_680 = (void*)0;
                    float ***l_693 = &g_391;
                    l_679 = (((~((uint32_t)(((p_34 & ((*l_581) , ((int32_t)(((((*l_581) || (l_677 , (p_36 <= (4294967294U ^ 0U)))) <= ((((&g_230 == l_678) , g_271) , p_36) , (***g_89))) >= (*l_581)) <= l_677) - (int32_t)p_34))) , 0x28EA) || 0xCC61) + (uint32_t)(**g_90))) <= p_36) | g_62.f0);
                    l_663 = (**g_89);
                    l_583 = l_583;
                    for (g_122.f0 = (-29); (g_122.f0 != 55); g_122.f0 += 6)
                    { /* block id: 461 */
                        (**l_561) = &l_657;
                        if ((**g_90))
                            continue;
                        (***l_561) = (p_34 || g_195);
                        (*g_166) = ((uint16_t)(l_685 , (((((float)(((((int16_t)((int32_t)(1U ^ (*l_663)) % (int32_t)p_35) / (int16_t)g_5) < (func_68(func_68(l_583, l_692), l_583) , p_34)) , l_693) != (void*)0) - (float)p_35) > (****g_624)) , 0xD02DF72A) , g_152)) + (uint16_t)(*l_663));
                    }
                }
            }
        }
        g_62 = func_71((**g_391), &g_152, (*l_581), g_5);
    }
    (*g_582) = (-4);
    return g_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_41(int32_t  p_42)
{ /* block id: 37 */
    uint32_t l_43 = 1U;
    return l_43;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_152 g_271 g_77 g_89 g_62.f0 g_101 g_90 g_91 g_62 g_156 g_308 g_309 g_195 g_122 g_230 g_390 g_391 g_392
 * writes: g_101 g_152 g_77 g_122 g_91 g_90 g_231
 */
static float  func_44(float  p_45, uint32_t  p_46, int16_t  p_47, int32_t  p_48)
{ /* block id: 190 */
    int32_t *l_289 = &g_152;
    float *l_290 = &g_101;
    int32_t l_310 = 0x186A3D86;
    struct S0 l_311 = {1U};
    struct S0 l_314 = {6U};
    const int32_t *l_379 = (void*)0;
    (*l_290) = g_5;
    (*l_289) = p_48;
    l_314 = func_71(((g_152 , l_311) , (*l_289)), &g_77, g_271, ((int16_t)(*l_289) << (int16_t)p_47));
    if ((((**g_90) ^ (((int16_t)((int32_t)0x3DD7BFDB % (int32_t)((g_156 > (l_290 == (*g_308))) && ((uint16_t)((*l_289) , (((void*)0 != (*g_308)) , ((void*)0 == l_290))) >> (uint16_t)1))) >> (int16_t)(*l_289)) != (**g_90))) | (*l_289)))
    { /* block id: 194 */
        int32_t l_327 = 0xC9E95FC9;
        int32_t *l_329 = &l_310;
        (*l_289) = (((uint32_t)p_48 - (uint32_t)0x90AB5DB3) || ((int32_t)0x7B37DF5F + (int32_t)0x094F27FA));
        if (p_48)
            goto lbl_328;
lbl_328:
        (*l_289) = ((__builtin_clz(g_271) == (p_48 && l_327)) , l_327);
        (*g_90) = (g_271 , l_329);
        (*g_89) = (*g_89);
    }
    else
    { /* block id: 200 */
        int16_t l_335 = 9;
        int32_t **l_341 = (void*)0;
        int32_t ***l_340 = &l_341;
        struct S0 *l_363 = &l_314;
        struct S0 l_407 = {65529U};
        if ((**g_90))
        { /* block id: 201 */
            struct S0 l_330 = {65532U};
            g_122 = l_330;
        }
        else
        { /* block id: 203 */
            uint32_t l_336 = 1U;
            int32_t *l_339 = &g_77;
            float **l_345 = (void*)0;
            float ***l_344 = &l_345;
            int16_t l_362 = 0xCC33;
            (*l_339) = (((float)(((((int16_t)g_62.f0 + (int16_t)(p_46 != ((l_335 <= ((l_336 ^ (l_335 ^ p_47)) ^ ((uint16_t)(((((l_336 >= (__builtin_popcountll(l_335) <= l_336)) , l_335) , &l_310) != l_339) , 4U) - (uint16_t)0xD1B2))) && 0x00CF))) , (void*)0) != l_340) , 0x2.F56FE3p+22) / (float)p_47) , 1);
            if ((***g_89))
            { /* block id: 205 */
                struct S0 l_360 = {0xA175};
                if (p_46)
                { /* block id: 206 */
                    for (p_46 = 0; (p_46 < 16); p_46++)
                    { /* block id: 209 */
                        (*l_339) = (***g_89);
                        (*l_289) = (l_344 != &l_345);
                        (*l_339) = ((int16_t)g_152 - (int16_t)g_77);
                        (*g_90) = (**g_89);
                    }
                }
                else
                { /* block id: 215 */
                    struct S0 ***l_348 = (void*)0;
                    float l_353 = 0xA.92A305p+57;
                    float ****l_371 = (void*)0;
                    if (((l_348 != (void*)0) < 0))
                    { /* block id: 216 */
                        uint16_t l_354 = 0x4E70;
                        (*g_90) = &l_310;
                        (*l_289) = (((uint16_t)((uint16_t)g_195 / (uint16_t)(*l_289)) + (uint16_t)4U) >= (l_354 & p_47));
                    }
                    else
                    { /* block id: 219 */
                        struct S0 l_361 = {0x295B};
                        struct S0 l_372 = {0U};
                        (*l_290) = __builtin_popcount((((g_156 | (**g_90)) || ((0x34B30178 > 0) < (!(((&l_311 == ((((int16_t)p_48 / (int16_t)(*l_289)) ^ ((uint16_t)(func_68(func_68(g_122, l_360), l_361) , l_362) << (uint16_t)13)) , l_363)) || g_271) , (*l_289))))) < 8));
                        (*g_90) = (**g_89);
                        (*l_363) = (((int16_t)((uint16_t)(~(p_47 ^ ((g_195 <= (((p_46 | (l_360.f0 , (((g_195 <= p_47) || p_46) | (l_371 != (void*)0)))) != 0x55DE8ABE) <= p_46)) < (*l_339)))) / (uint16_t)p_46) << (int16_t)l_360.f0) , l_372);
                    }
                    (*g_230) = &l_360;
                }
                for (l_311.f0 = (-23); (l_311.f0 < 29); ++l_311.f0)
                { /* block id: 228 */
                    return p_46;
                }
            }
            else
            { /* block id: 231 */
                struct S0 l_378 = {0U};
                for (g_77 = 0; (g_77 > (-17)); --g_77)
                { /* block id: 234 */
                    struct S0 l_377 = {0x8D5C};
                    (*l_363) = func_68(func_68(l_377, l_378), l_378);
                    l_379 = (**g_89);
                    (*l_289) = 5;
                }
            }
            (*l_289) = ((((!(((*l_339) , (*g_90)) == (**g_89))) > p_48) > ((int16_t)g_271 + (int16_t)p_47)) < ((((__builtin_bswap32(p_48) != ((g_122.f0 , p_47) , p_48)) | 0x3AEF) >= g_77) && (-3)));
        }
        if (p_48)
        { /* block id: 242 */
            uint32_t l_386 = 6U;
            int32_t *l_387 = (void*)0;
            float ***l_393 = &g_391;
            struct S0 l_396 = {65533U};
            const float ***l_401 = &g_308;
            const float ****l_400 = &l_401;
            const float *****l_399 = &l_400;
            (*l_290) = __builtin_parityl((-(int32_t)(p_46 == (__builtin_ffsl(((-8) == ((*g_89) != (func_68(func_71(p_45, &g_77, p_48, p_46), g_62) , (void*)0)))) <= 9))));
            (*l_289) = (l_386 & ((0xBE19 >= (65532U < ((uint32_t)(((g_390 == l_393) && p_48) > 9U) % (uint32_t)((int32_t)(((func_68(l_396, l_396) , 0x3D12) , g_5) | p_48) % (int32_t)p_46)))) < (*l_289)));
            for (l_310 = (-8); (l_310 > (-8)); ++l_310)
            { /* block id: 247 */
                float ****l_403 = &l_393;
                float *****l_402 = &l_403;
            }
            (**g_89) = (*g_90);
        }
        else
        { /* block id: 255 */
            int32_t l_408 = 0xDEBA0886;
            int32_t *l_409 = &l_310;
            for (l_310 = 10; (l_310 != 29); ++l_310)
            { /* block id: 258 */
                (*l_363) = g_122;
                (*l_363) = l_407;
            }
            (*g_90) = (*g_90);
            l_409 = &l_408;
        }
        (*l_363) = l_314;
    }
    return (***g_390);
}


/* ------------------------------------------ */
/* 
 * reads : g_62 g_77 g_89 g_5 g_101 g_90 g_91 g_156 g_166 g_122 g_152 g_195 g_230 g_271
 * writes: g_101 g_77 g_122 g_91 g_152 g_156 g_166 g_62 g_230 g_231
 */
static int16_t  func_55(uint32_t  p_56)
{ /* block id: 39 */
    uint16_t l_63 = 65535U;
    int32_t *l_76 = &g_77;
    struct S0 l_157 = {65535U};
    (*g_90) = func_57(p_56, g_62, l_63, ((func_64(func_66(func_68((g_62 , func_71(p_56, (__builtin_popcountll(p_56) , l_76), (((-(uint16_t)(g_62 , g_77)) >= p_56) == (*l_76)), (*l_76))), l_157))) & p_56) , &g_152));
    return g_271;
}


/* ------------------------------------------ */
/* 
 * reads : g_89 g_90 g_77 g_166 g_152 g_122.f0 g_101 g_195 g_122 g_91 g_62.f0 g_5 g_156 g_62 g_230 g_271
 * writes: g_91 g_101 g_166 g_152 g_77 g_122 g_62 g_230 g_231
 */
static int32_t * func_57(int32_t  p_58, struct S0  p_59, uint32_t  p_60, int32_t * p_61)
{ /* block id: 123 */
    int32_t **l_187 = &g_166;
    int32_t **l_188 = &g_166;
    struct S0 l_196 = {65535U};
    float **l_208 = (void*)0;
    int32_t *l_236 = &g_152;
    uint16_t l_268 = 65535U;
    struct S0 **l_283 = &g_231;
    int32_t *l_288 = &g_152;
    (**g_89) = &p_58;
    if ((((uint16_t)p_58 + (uint16_t)((int16_t)(g_77 == (l_187 != ((**l_187) , l_188))) / (int16_t)((-7) || (((uint16_t)g_122.f0 >> (uint16_t)11) <= 0xA6205CD2)))) && (0x011E == 0x4809)))
    { /* block id: 125 */
        float *l_191 = &g_101;
        int32_t l_192 = 1;
        (*l_191) = (g_101 > __builtin_ctzll(p_59.f0));
        (*l_187) = (*l_188);
        (**l_188) = (((**l_187) != (((1U & l_192) , func_68((((int16_t)p_60 >> (int16_t)(g_195 == g_152)) , p_59), l_196)) , g_152)) , (*g_166));
    }
    else
    { /* block id: 129 */
        int32_t l_197 = 1;
        float *l_210 = &g_101;
        float **l_209 = &l_210;
        const uint32_t l_235 = 0xA8471376;
        int32_t l_274 = 0x1E7D8B5B;
        struct S0 **l_284 = &g_231;
        if (l_197)
        { /* block id: 130 */
            for (p_60 = (-25); (p_60 != 45); p_60 += 5)
            { /* block id: 133 */
                uint32_t l_213 = 1U;
                struct S0 *l_219 = &g_62;
                (*l_219) = func_71(p_58, func_66(p_59), ((uint32_t)(((uint32_t)(((uint32_t)(((float)((g_62.f0 >= (l_208 != l_209)) >= (((float)l_197 - (float)(l_213 , ((float)(+((float)g_5 + (float)0x1.8p-1)) + (float)p_59.f0))) <= g_156)) + (float)p_59.f0) , p_58) - (uint32_t)0x7D6C01FF) , p_60) % (uint32_t)0xC7B67EAC) == p_60) / (uint32_t)g_5), p_58);
                if (l_197)
                    continue;
                (**l_188) = (func_41((l_213 , (((g_77 , func_71(((float)(**l_188) - (float)(-0x9.3p-1)), &g_77, l_213, l_213)) , (l_197 && 4294967287U)) > 0x96C7A114))) , 0xC0B4975F);
                (**g_89) = func_66(p_59);
            }
        }
        else
        { /* block id: 139 */
            float l_222 = 0xB.ADDED1p-44;
            int32_t l_224 = (-1);
            struct S0 *l_276 = &l_196;
            g_62 = func_68(g_62, p_59);
            if (((g_122.f0 >= (__builtin_clzl(g_5) != ((**l_187) ^ (**g_90)))) | (((g_62 , ((!l_224) && (g_122.f0 > (l_197 == (*p_61))))) <= 65535U) , g_5)))
            { /* block id: 141 */
                float ***l_226 = &l_208;
                float ****l_225 = &l_226;
                float *****l_227 = &l_225;
                int32_t *l_233 = &g_77;
                int16_t l_272 = 0x2300;
                (*l_227) = l_225;
                (**g_89) = (void*)0;
                if (l_224)
                { /* block id: 144 */
                    struct S0 l_234 = {0x0BF5};
                    for (g_62.f0 = 0; (g_62.f0 >= 34); g_62.f0++)
                    { /* block id: 147 */
                        struct S0 ***l_232 = &g_230;
                        (**g_89) = l_210;
                        (*l_232) = g_230;
                        (*l_187) = l_233;
                    }
                    (*l_187) = &p_58;
                }
                else
                { /* block id: 153 */
                    return &g_152;
                }
                if (l_235)
                { /* block id: 156 */
                    const int16_t l_245 = 0x172C;
                    (*g_90) = (func_71(p_60, l_236, g_195, p_59.f0) , (**g_89));
                    (**l_187) = ((int32_t)((((int16_t)(p_60 && 0x9E63) << (int16_t)(((g_62.f0 < p_59.f0) & g_195) | (l_235 > (g_5 , ((uint16_t)((int32_t)l_245 - (int32_t)(((int32_t)(((int16_t)(0x2B8B1C4E & l_245) << (int16_t)l_224) == 1) - (int32_t)0) != l_224)) >> (uint16_t)g_5))))) , (void*)0) != (*g_89)) % (int32_t)1);
                }
                else
                { /* block id: 159 */
                    struct S0 *l_250 = &g_62;
                    int32_t l_273 = (-1);
                    if (__builtin_parityl(g_195))
                    { /* block id: 160 */
                        (*g_230) = l_250;
                    }
                    else
                    { /* block id: 162 */
                        int32_t *l_275 = (void*)0;
                        l_274 = (!((((int32_t)(((uint16_t)(((((((((((uint32_t)(((int16_t)(((*g_166) , ((uint32_t)((uint32_t)(**l_188) + (uint32_t)((uint16_t)((uint16_t)(**l_188) >> (uint16_t)l_268) + (uint16_t)((((int16_t)l_197 / (int16_t)5U) , 0x2A3349E9) , g_77))) % (uint32_t)(-9))) > 0x821C75A4) % (int16_t)l_224) , g_5) % (uint32_t)0xF4AEB97D) && 4294967295U) , (void*)0) != &l_188) <= (*p_61)) < p_59.f0) <= (*p_61)) < g_271) , p_60) , l_272) << (uint16_t)(*l_233)) , l_235) - (int32_t)l_273) && 0xBD37) , l_224));
                        (*l_188) = func_66(l_196);
                    }
                    return &g_152;
                }
            }
            else
            { /* block id: 168 */
                struct S0 l_281 = {2U};
                (*l_236) = ((((p_59 , (((p_58 , p_59.f0) || ((*g_91) , ((void*)0 != &l_208))) , (((int16_t)__builtin_clz(g_77) >> (int16_t)5) || (0xD83B ^ (**l_188))))) >= g_77) && 1U) && 1U);
                for (l_197 = 0; (l_197 >= 5); l_197 += 5)
                { /* block id: 172 */
                    int32_t *l_282 = &g_152;
                    (*l_188) = (((p_58 == __builtin_ctz((g_122.f0 | p_58))) >= 0x5.ABDCF2p-80) , (l_281 , l_282));
                    (*l_188) = &p_58;
                    if ((*g_91))
                        break;
                }
            }
        }
        l_284 = l_283;
    }
    (*l_236) = (*p_61);
    for (g_62.f0 = 0; (g_62.f0 >= 10); g_62.f0 += 2)
    { /* block id: 184 */
        float *l_287 = &g_101;
        (*l_287) = 0x0.9p-1;
    }
    return l_288;
}


/* ------------------------------------------ */
/* 
 * reads : g_156 g_90 g_91 g_77 g_62.f0 g_166 g_122 g_89 g_5
 * writes: g_156 g_77 g_91 g_122 g_152
 */
static int32_t  func_64(int32_t * p_65)
{ /* block id: 115 */
    uint32_t l_175 = 0xE3922E0D;
    float *l_176 = (void*)0;
    const struct S0 l_181 = {0x289B};
    for (g_156 = 27; (g_156 >= 52); ++g_156)
    { /* block id: 118 */
        if ((**g_90))
            break;
    }
    (*p_65) = (((((float)g_62.f0 + (float)l_175) , 4294967295U) > (((l_175 & (((void*)0 == l_176) && ((((uint32_t)((int16_t)(p_65 != (l_181 , func_66((((+(**g_90)) == 0x8E5E8280) , l_181)))) >> (int16_t)15) % (uint32_t)l_175) , (void*)0) != &l_181))) != l_181.f0) < 0x2C1C9F68)) || g_5);
    return l_181.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_77 g_166 g_90 g_122 g_89 g_91
 * writes: g_77 g_91 g_122 g_152
 */
static int32_t * func_66(struct S0  p_67)
{ /* block id: 99 */
    const int32_t *l_169 = &g_77;
    int32_t *l_170 = &g_77;
    for (g_77 = 0; (g_77 < 20); ++g_77)
    { /* block id: 102 */
        struct S0 *l_167 = &g_122;
        for (p_67.f0 = (-7); (p_67.f0 <= 41); ++p_67.f0)
        { /* block id: 105 */
            (*g_90) = g_166;
        }
        (*l_167) = g_122;
        (*g_166) = (~g_77);
        (*g_90) = (**g_89);
    }
    (**g_89) = l_169;
    (*g_90) = l_170;
    return l_170;
}


/* ------------------------------------------ */
/* 
 * reads : g_89 g_90
 * writes: g_91
 */
static struct S0  func_68(struct S0  p_69, struct S0  p_70)
{ /* block id: 95 */
    float *l_159 = &g_101;
    float **l_158 = &l_159;
    float ***l_160 = &l_158;
    struct S0 l_161 = {1U};
    (*l_160) = l_158;
    (**g_89) = l_159;
    return l_161;
}


/* ------------------------------------------ */
/* 
 * reads : g_77 g_89 g_62.f0 g_5 g_101 g_90 g_91 g_62 g_156 g_152
 * writes: g_101 g_77 g_122 g_91 g_152
 */
static struct S0  func_71(float  p_72, int32_t * p_73, const uint32_t  p_74, int32_t  p_75)
{ /* block id: 40 */
    int32_t l_79 = 1;
    int32_t l_80 = 0xABDC9A81;
    int32_t *l_82 = &g_77;
    int32_t **l_81 = &l_82;
    int32_t ***l_83 = &l_81;
    struct S0 l_86 = {65535U};
    int32_t l_102 = 0x3E8932A2;
    l_80 = (g_77 == (g_77 , l_79));
    (*l_83) = l_81;
    if (((uint32_t)(l_86 , (((0xA.7FB6F8p-73 < (0x7.BBDB81p-45 != (**l_81))) , 0) , ((uint32_t)p_75 - (uint32_t)(g_89 == ((g_62.f0 < g_5) , &l_81))))) % (uint32_t)(***l_83)))
    { /* block id: 43 */
        struct S0 *l_93 = &g_62;
        struct S0 **l_92 = &l_93;
        int32_t l_98 = 0x9934B93D;
        float *l_103 = &g_101;
        int32_t **l_108 = &l_82;
        (*l_92) = &g_62;
        (*l_103) = ((0x6.E6B3E9p+27 < (((((float)0x9.0955DFp-44 / (float)(((p_73 == (void*)0) < (!(((+l_98) == (((((&l_98 == (void*)0) , ((int16_t)(l_98 ^ (*p_73)) / (int16_t)g_62.f0)) || 1U) , 0x95BD) , g_101)) != p_74))) >= p_75)) <= g_77) != l_102) >= g_77)) < p_75);
        (*l_82) = ((int16_t)(((*l_82) != ((uint16_t)p_74 - (uint16_t)(***l_83))) , ((void*)0 != l_108)) % (int16_t)((((p_74 , (*l_92)) == (*l_92)) , ((**l_108) < 4294967295U)) && g_77));
        if ((g_5 | ((**l_81) >= (g_77 < p_74))))
        { /* block id: 47 */
            int16_t l_111 = (-1);
            float *l_117 = &g_101;
            (*l_92) = &g_62;
            for (p_75 = 0; (p_75 < (-26)); p_75 -= 1)
            { /* block id: 51 */
                const int32_t **l_114 = &g_91;
                float *l_118 = &g_101;
                struct S0 l_121 = {0U};
                (**l_81) = (g_5 && ((l_111 == 0xD205C6C2) , ((**l_108) , (((((*g_89) == l_114) && (__builtin_popcount(((uint16_t)(l_117 == (((l_86 , p_74) , g_62.f0) , l_118)) - (uint16_t)(*l_82))) < g_77)) >= 0xD3C07AF8) & 0x1C9D))));
                if ((*p_73))
                    continue;
                if ((**l_108))
                    continue;
                g_122 = ((p_75 , ((uint16_t)g_5 << (uint16_t)6)) , l_121);
            }
            (**g_89) = (**g_89);
            (*l_103) = (l_111 >= (+g_5));
        }
        else
        { /* block id: 59 */
            struct S0 *l_124 = (void*)0;
            struct S0 *l_125 = &g_122;
            (*l_125) = g_62;
            (*l_125) = (*l_93);
            return g_62;
        }
    }
    else
    { /* block id: 64 */
        uint16_t l_130 = 1U;
        struct S0 l_131 = {65528U};
        int32_t l_153 = 1;
        for (p_75 = 0; (p_75 >= (-5)); p_75 -= 7)
        { /* block id: 67 */
            (**l_81) = ((int32_t)l_130 + (int32_t)l_130);
            return l_131;
        }
        for (g_77 = (-30); (g_77 == 4); g_77 += 6)
        { /* block id: 73 */
            int32_t *l_134 = &l_80;
            (*l_134) = l_130;
            (*l_134) = (-(int32_t)(-8));
            for (l_79 = (-19); (l_79 <= 5); ++l_79)
            { /* block id: 78 */
                const uint32_t l_140 = 0U;
                struct S0 l_145 = {8U};
                (*l_134) = 0;
                (*l_134) = ((uint32_t)(l_140 ^ p_75) / (uint32_t)(((0x37D808B4 < ((uint16_t)((uint16_t)(((p_74 | __builtin_parityl((***l_83))) >= (**l_81)) >= p_74) << (uint16_t)0) / (uint16_t)(l_145 , p_74))) || l_130) , 1U));
                g_152 = (((*p_73) > (0x4757 | ((p_75 , (g_5 | p_74)) && g_77))) && ((int16_t)((***l_83) == ((uint16_t)(((int32_t)(*p_73) + (int32_t)g_77) <= g_62.f0) >> (uint16_t)6)) >> (int16_t)10));
                l_153 = 0x6291C459;
            }
            if ((*l_82))
                break;
        }
        for (p_75 = (-17); (p_75 != 3); ++p_75)
        { /* block id: 88 */
            (*p_73) = __builtin_parity(l_130);
            if (g_156)
                break;
        }
        (**g_89) = (*l_81);
    }
    return l_86;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_62.f0, "g_62.f0", print_hash_value);
    transparent_crc(g_77, "g_77", print_hash_value);
    transparent_crc_bytes (&g_101, sizeof(g_101), "g_101", print_hash_value);
    transparent_crc(g_122.f0, "g_122.f0", print_hash_value);
    transparent_crc(g_152, "g_152", print_hash_value);
    transparent_crc(g_156, "g_156", print_hash_value);
    transparent_crc(g_195, "g_195", print_hash_value);
    transparent_crc(g_271, "g_271", print_hash_value);
    transparent_crc_bytes (&g_426, sizeof(g_426), "g_426", print_hash_value);
    transparent_crc(g_730, "g_730", print_hash_value);
    transparent_crc(g_737, "g_737", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 170
   depth: 1, occurrence: 49
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 339
   depth: 2, occurrence: 50
   depth: 3, occurrence: 10
   depth: 4, occurrence: 3
   depth: 5, occurrence: 8
   depth: 6, occurrence: 3
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 3
   depth: 11, occurrence: 4
   depth: 12, occurrence: 5
   depth: 13, occurrence: 5
   depth: 14, occurrence: 5
   depth: 15, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 4
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2

XXX total number of pointers: 149

XXX times a variable address is taken: 177
XXX times a pointer is dereferenced on RHS: 162
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 43
   depth: 3, occurrence: 26
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 148
breakdown:
   depth: 1, occurrence: 106
   depth: 2, occurrence: 34
   depth: 3, occurrence: 7
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 691

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 725
   level: 2, occurrence: 418
   level: 3, occurrence: 144
   level: 4, occurrence: 10
   level: 5, occurrence: 9
XXX number of pointers point to pointers: 75
XXX number of pointers point to scalars: 55
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 18.1
XXX average alias set size: 1.19

XXX times a non-volatile is read: 1157
XXX times a non-volatile is write: 412
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 286
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 39
   depth: 2, occurrence: 53
   depth: 3, occurrence: 55
   depth: 4, occurrence: 53
   depth: 5, occurrence: 53

XXX percentage a fresh-made variable is used: 19.1
XXX percentage an existing variable is used: 80.9
********************* end of statistics **********************/

