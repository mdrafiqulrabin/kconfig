/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2955935838
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S1 {
   signed f0 : 6;
   signed f1 : 6;
   volatile int32_t  f2;
   volatile signed f3 : 24;
   signed f4 : 16;
   unsigned f5 : 11;
   volatile unsigned f6 : 20;
   const unsigned f7 : 22;
   const signed : 0;
   signed f8 : 4;
};

/* --- GLOBAL VARIABLES --- */
static uint8_t g_4 = 0x31L;
static volatile int32_t g_105 = (-10L);/* VOLATILE GLOBAL g_105 */
static volatile int32_t *g_104 = &g_105;
static float g_108 = 0x6.DEC46Bp-53;
static struct S1 g_110 = {-0,-7,0x7CF0AE94L,2793,-114,34,27,810,-0};/* VOLATILE GLOBAL g_110 */
static volatile struct S1 g_128 = {7,5,0xD3D76C94L,-725,172,14,281,1580,-0};/* VOLATILE GLOBAL g_128 */
static volatile struct S1 *g_127 = &g_128;
static volatile struct S1 **g_126 = &g_127;
static int32_t g_156 = (-5L);
static int8_t g_182 = (-7L);
static int32_t **g_257 = (void*)0;
static volatile struct S1 ***g_304 = &g_126;
static volatile struct S1 ****g_303 = &g_304;
static int32_t ****g_393 = (void*)0;
static int32_t *****g_392 = &g_393;
static float g_412 = 0x1.Fp-1;
static struct S1 g_477 = {-5,4,0xB36D9B1EL,109,179,37,637,772,-3};/* VOLATILE GLOBAL g_477 */
static int32_t *g_526 = &g_156;
static uint64_t g_564 = 0x4F73BC8AFDABBB0CLL;
static struct S1 g_589 = {7,-6,0xDB3B0AF0L,-1480,-227,38,386,1975,-0};/* VOLATILE GLOBAL g_589 */
static const int32_t *g_594 = &g_156;
static const int32_t **g_593 = &g_594;
static const int32_t ***g_592 = &g_593;
static uint32_t g_630 = 0xCEE041ABL;
static struct S1 g_645 = {1,5,0x3CF161F4L,999,20,41,605,532,2};/* VOLATILE GLOBAL g_645 */


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_1(void);
static float  func_5(uint32_t  p_6, uint8_t  p_7);
static uint32_t  func_8(int8_t  p_9, uint32_t  p_10, int32_t  p_11, uint8_t  p_12, float  p_13);
static int64_t  func_24(uint8_t  p_25, int32_t  p_26);
static int16_t  func_31(uint32_t  p_32, int8_t  p_33, float  p_34, uint8_t  p_35);
static uint32_t  func_50(uint64_t  p_51, float  p_52, uint32_t  p_53, int32_t  p_54, uint32_t  p_55);
static uint8_t  func_63(uint64_t  p_64);
static uint8_t  func_67(const int64_t  p_68, uint32_t  p_69, uint32_t  p_70, int8_t  p_71, uint32_t  p_72);
static uint16_t  func_77(uint16_t  p_78, uint16_t  p_79, int32_t  p_80);
static struct S1 * func_81(uint32_t  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_104 g_105 g_110.f0 g_128.f7 g_182 g_110.f5 g_110.f4 g_156 g_110.f8 g_128.f0 g_110.f7 g_110.f1 g_128.f1 g_108 g_303 g_110.f2 g_304 g_128.f4 g_110.f6 g_126 g_110.f3 g_128.f5 g_127 g_392 g_412 g_128.f2 g_128.f3 g_477.f1 g_477.f2 g_477.f8 g_477.f3 g_128 g_477.f0 g_564 g_477.f7 g_589 g_593 g_594 g_477.f5 g_630 g_645
 * writes: g_108 g_105 g_156 g_257 g_526 g_182 g_412 g_4 g_592 g_594
 */
static struct S1  func_1(void)
{ /* block id: 0 */
    uint32_t l_36 = 4UL;
    int32_t *l_550 = (void*)0;
    struct S1 ****l_606 = (void*)0;
    float *l_613 = &g_412;
    float l_620 = (-0x1.6p+1);
    int8_t l_642 = 0x7BL;
    if (((uint16_t)g_4 - (uint16_t)1L))
    { /* block id: 1 */
        int32_t l_14 = 0x0198AB79L;
        float *l_542 = (void*)0;
        float *l_543 = &g_412;
        (*l_543) = ((g_4 > func_5((func_8(l_14, ((((l_14 != ((uint32_t)((uint8_t)g_4 * (uint8_t)((uint8_t)((uint64_t)g_4 + (uint64_t)(-(uint16_t)(g_4 | (-7L)))) >> (uint8_t)4)) / (uint32_t)(func_24(g_4, ((uint64_t)((int16_t)func_31(l_14, l_36, g_4, g_4) >> (int16_t)15) + (uint64_t)l_36)) && 0xD385E13CD4FE9304LL))) == g_4) != 0UL) >= g_4), l_14, l_14, l_14) < g_110.f7), l_14)) != l_14);
    }
    else
    { /* block id: 199 */
        int32_t *l_549 = &g_156;
        float *l_552 = &g_108;
        int32_t ***l_563 = &g_257;
        int32_t ****l_562 = &l_563;
        int32_t *l_600 = &g_156;
        for (l_36 = (-26); (l_36 != 28); l_36 += 3)
        { /* block id: 202 */
            float l_546 = 0x8.0FEFC5p-74;
            float *l_547 = &l_546;
            (*l_547) = l_546;
            if (l_36)
            { /* block id: 204 */
                int32_t **l_548 = (void*)0;
                g_526 = l_547;
                /* statement id: 205 */
                assert (g_526 == &l_546);
            }
            else
            { /* block id: 206 */
                int32_t **l_551 = &g_526;
                l_550 = l_549;
                /* statement id: 207 */
                assert (l_550 == &g_156);
                (*l_551) = l_547;
                /* statement id: 208 */
                assert (g_526 == &l_546);
                return (***g_304);
                /* statement id: 209 */
                //assert (g_526 == dangling);
            }
            /* facts after branching */
            assert (g_526 == &l_546);
        }
        /* facts after for loop */
        //assert (g_526 == dangling || g_526 == &g_156);
        (*l_552) = g_156;
        if (((int8_t)(((4UL >= ((*l_549) || 0x4E096BAAEF25888DLL)) != ((uint64_t)((*l_549) & ((int8_t)(((void*)0 != l_550) != (((int8_t)(+(l_562 != (void*)0)) >> (int8_t)(g_477.f0 | g_128.f0)) > 0xFDL)) >> (int8_t)5)) - (uint64_t)g_564)) && 9UL) / (int8_t)g_477.f1))
        { /* block id: 213 */
            uint32_t l_569 = 1UL;
            const int32_t **l_591 = (void*)0;
            const int32_t ***l_590 = &l_591;
            const int32_t *l_595 = &g_156;
            for (g_4 = 19; (g_4 > 40); g_4 += 7)
            { /* block id: 216 */
                int32_t l_585 = 0L;
                (*g_104) = (((((((int32_t)l_569 / (int32_t)(*g_104)) != ((uint16_t)l_569 - (uint16_t)0xCA6EL)) | (l_569 & (((int64_t)((((((+((uint8_t)(((0L && ((g_477.f1 == g_477.f0) != (((int8_t)((((((((uint16_t)(((int8_t)((int16_t)(g_477.f0 <= 0x0905694FL) % (int16_t)g_4) % (int8_t)(-1L)) <= g_156) << (uint16_t)8) || g_110.f1) != g_156) < g_4) || l_585) > 1UL) | g_110.f8) + (int8_t)g_477.f8) && 0xEA743C6EL))) && (*l_549)) > g_156) + (uint8_t)l_569)) || l_569) & g_564) ^ 0xCCL) || g_110.f8) ^ 0x48L) / (int64_t)g_477.f7) >= 0L))) == l_36) <= g_477.f7) && (-1L));
                if (((uint16_t)(g_110.f6 < g_110.f1) % (uint16_t)0x31CEL))
                { /* block id: 218 */
                    int32_t l_588 = 0xF3DF36D3L;
                    (*g_104) = (*g_104);
                    (*l_552) = l_588;
                    (*g_104) = l_585;
                }
                else
                { /* block id: 222 */
                    (*l_549) = (-1L);
                }
                return g_589;
            }
            g_592 = l_590;
            /* statement id: 227 */
            assert (g_592 == &l_591);
            (*g_593) = (void*)0;
            /* statement id: 228 */
            assert (g_594 == 0);
            (*g_593) = l_595;
            /* statement id: 229 */
            assert (g_594 == &g_156);
        }
        else
        { /* block id: 230 */
            (*l_549) = ((uint8_t)g_589.f3 / (uint8_t)l_36);
        }
        /* facts after branching */
        //assert (g_592 == &g_593 || g_592 == dangling);
        for (g_156 = 0; (g_156 <= 29); g_156 += 6)
        { /* block id: 235 */
            int32_t *l_601 = (void*)0;
            (*g_593) = l_600;
            /* statement id: 236 */
            assert (g_594 == &g_156);
            (*g_593) = (*g_593);
            (*g_593) = l_601;
            /* statement id: 238 */
            assert (g_594 == 0);
        }
        /* facts after for loop */
        assert (g_594 == 0 || g_594 == &g_156);
    }
    /* facts after branching */
    //assert (g_526 == dangling || g_526 == &g_156);
    assert (g_594 == 0 || g_594 == &g_156);
    //assert (g_592 == &g_593 || g_592 == dangling);
    (*g_104) = ((int32_t)(&g_393 != &g_393) + (int32_t)g_477.f5);
    (*l_613) = ((float)(l_36 == g_564) + (float)((g_182 != (l_606 != (void*)0)) != (((float)(g_128.f7 == g_589.f1) / (float)((float)((((((float)(-0x1.1p+1) + (float)g_110.f5) > g_477.f1) < 0x6.Fp+1) == g_412) >= g_110.f0) + (float)g_589.f0)) < g_412)));
    for (l_36 = 24; (l_36 != 38); l_36 += 7)
    { /* block id: 245 */
        int32_t l_631 = 1L;
        const int32_t *l_632 = &g_156;
        uint16_t l_640 = 1UL;
        (*l_613) = ((float)((float)(0x0.4p+1 < g_110.f3) + (float)(l_620 > ((float)(-(float)((l_36 <= l_36) == g_564)) * (float)((float)0x0.AF854Ep+41 / (float)g_110.f1)))) * (float)((float)((((((float)0x8.0p-1 / (float)(-0x1.Ap-1)) >= 0xF.BDA31Dp+84) > 0x1.9p-1) >= 0xD.6E4302p-46) != g_630) + (float)l_36));
        if (l_631)
            break;
        (*g_593) = l_632;
        /* statement id: 248 */
        assert (g_594 == &g_156);
        (*g_104) = (((uint16_t)((&l_632 == &l_632) || (-(int16_t)(0L > ((uint8_t)g_128.f6 << (uint8_t)6)))) >> (uint16_t)10) ^ ((uint8_t)255UL << (uint8_t)((l_640 < (+l_36)) >= (l_642 <= (((((uint16_t)((*l_632) != (*l_632)) / (uint16_t)(*l_632)) || g_110.f5) >= (*l_632)) & 0x8DL)))));
    }
    return g_645;
}


/* ------------------------------------------ */
/* 
 * reads : g_110.f2 g_110.f5 g_477.f8 g_156 g_477.f1 g_477.f3 g_104 g_4 g_105 g_110.f0 g_128.f7 g_182 g_110.f7
 * writes: g_526 g_105 g_108 g_182 g_156
 */
static float  func_5(uint32_t  p_6, uint8_t  p_7)
{ /* block id: 167 */
    uint64_t l_510 = 1UL;
    int32_t *l_511 = &g_156;
    int32_t ***l_525 = &g_257;
    if ((((int8_t)((((uint16_t)((uint8_t)(l_510 == ((void*)0 != l_511)) << (uint8_t)(((int8_t)((g_110.f2 >= (+((int8_t)(g_110.f5 | g_477.f8) >> (int8_t)5))) >= ((((int64_t)(p_6 == (((int64_t)((int32_t)((int16_t)((((void*)0 != l_525) > (*l_511)) & p_7) % (int16_t)p_7) % (int32_t)p_7) % (int64_t)p_6) & 0x6D2EE6C1B3C04639LL)) / (int64_t)g_477.f1) > 255UL) ^ p_7)) >> (int8_t)5) <= p_6)) << (uint16_t)11) && g_477.f3) <= 0UL) << (int8_t)0) ^ (*l_511)))
    { /* block id: 168 */
        int32_t *l_527 = &g_156;
        int32_t **l_528 = (void*)0;
        int32_t **l_529 = &g_526;
        struct S1 *l_531 = &g_110;
        struct S1 **l_530 = &l_531;
        g_526 = &g_156;
        (*g_104) = 6L;
        (*l_529) = l_527;
        (*l_530) = func_81((*l_511));
    }
    else
    { /* block id: 173 */
        int32_t *l_534 = &g_156;
        if (p_7)
        { /* block id: 174 */
            for (g_182 = (-28); (g_182 <= 26); g_182 += 7)
            { /* block id: 177 */
                int32_t **l_535 = &g_526;
                uint32_t l_539 = 9UL;
                (*l_535) = l_534;
                for (p_7 = 10; (p_7 >= 54); p_7 += 5)
                { /* block id: 181 */
                    float *l_538 = &g_108;
                    (*l_538) = (-0x2.2p+1);
                    return l_539;
                }
                return g_110.f7;
            }
            (*l_534) = p_7;
        }
        else
        { /* block id: 188 */
            for (p_6 = 20; (p_6 < 26); p_6 += 8)
            { /* block id: 191 */
                (*l_511) = (*g_104);
            }
            (*l_534) = p_7;
        }
    }
    return p_7;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_104 g_105 g_110.f0 g_128.f7 g_182 g_110.f5 g_110.f4 g_156 g_110.f8 g_128.f0 g_110.f7 g_110.f1 g_128.f1 g_108 g_303 g_110.f2 g_304 g_128.f4 g_110.f6 g_126 g_110.f3 g_128.f5 g_127 g_392 g_412 g_128.f2 g_128.f3 g_477.f1 g_477.f2 g_477.f8 g_477.f3
 * writes: g_108 g_105 g_156 g_257
 */
static uint32_t  func_8(int8_t  p_9, uint32_t  p_10, int32_t  p_11, uint8_t  p_12, float  p_13)
{ /* block id: 6 */
    uint16_t l_56 = 0x65E1L;
    uint32_t l_281 = 4294967291UL;
    float *l_480 = &g_108;
    struct S1 *l_483 = (void*)0;
    int32_t *l_486 = (void*)0;
    const int32_t *l_502 = &g_156;
    const int32_t **l_501 = &l_502;
    const int32_t ***l_500 = &l_501;
    (*l_480) = ((float)((float)g_4 + (float)p_11) + (float)((-0x1.Cp-1) >= (((float)((float)0x4.CB0BE9p-23 - (float)(((float)(((float)(0xF.B9622Cp-21 > ((((func_31(func_50(p_12, l_56, ((int8_t)l_56 - (int8_t)((int8_t)func_24(((((uint8_t)func_63(func_31((((uint8_t)func_67((((int8_t)((uint16_t)func_77(p_12, p_12, p_12) * (uint16_t)p_12) * (int8_t)g_110.f5) == 8UL), g_110.f4, g_110.f4, l_56, l_56) >> (uint8_t)2) < 0xEA0EL), l_56, p_13, p_10)) + (uint8_t)l_281) && l_281) ^ p_9), g_182) << (int8_t)3)), l_281, p_10), g_110.f0, g_110.f0, p_10) == l_56) > l_56) <= l_56) < g_477.f8)) - (float)g_182) < (-0x1.3p+1)) / (float)l_56) > g_110.f0)) * (float)g_412) <= p_13)));
    if (((uint16_t)p_9 + (uint16_t)(l_483 != (***g_303))))
    { /* block id: 159 */
        int32_t l_484 = 0L;
        int32_t *l_485 = &g_156;
        (*l_480) = l_484;
        l_486 = l_485;
        /* statement id: 161 */
        assert (l_486 == &g_156);
    }
    else
    { /* block id: 162 */
        uint8_t l_503 = 0UL;
        (*g_104) = 0x682E6C3BL;
        (*l_480) = ((float)(p_9 > ((float)(p_11 == (((float)(-(float)((0xC.627330p-71 != (((float)(g_477.f3 >= 0x7.F7D211p+0) * (float)(-(float)(-0x1.9p+1))) > ((p_13 <= (((!(+(+(l_500 == (void*)0)))) > 0xF.7CEEB1p-86) == 0x8.AF3484p-97)) > 0x9.76AAA2p-16))) <= l_503)) / (float)(***l_500)) > g_110.f1)) - (float)(***l_500))) * (float)p_13);
    }
    /* facts after branching */
    assert (l_486 == 0 || l_486 == &g_156);
    return g_128.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_4
 * writes:
 */
static int64_t  func_24(uint8_t  p_25, int32_t  p_26)
{ /* block id: 4 */
    return g_4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_31(uint32_t  p_32, int8_t  p_33, float  p_34, uint8_t  p_35)
{ /* block id: 2 */
    int32_t l_37 = 0L;
    return l_37;
}


/* ------------------------------------------ */
/* 
 * reads : g_104 g_303 g_156 g_128.f7 g_182 g_110.f4 g_110.f7 g_110.f2 g_304 g_110.f0 g_110.f8 g_128.f4 g_4 g_110.f5 g_110.f6 g_126 g_110.f3 g_128.f5 g_127 g_110.f1 g_392 g_412 g_128.f1 g_108 g_128.f2 g_128.f3 g_477.f1 g_477.f2
 * writes: g_105 g_156 g_108
 */
static uint32_t  func_50(uint64_t  p_51, float  p_52, uint32_t  p_53, int32_t  p_54, uint32_t  p_55)
{ /* block id: 92 */
    int16_t l_287 = (-1L);
    int32_t l_288 = 0x0DEF69FDL;
    struct S1 *l_299 = &g_110;
    struct S1 **l_298 = &l_299;
    struct S1 ***l_297 = &l_298;
    struct S1 ****l_296 = &l_297;
    struct S1 *****l_295 = &l_296;
    int32_t ***l_324 = &g_257;
    float *l_353 = &g_108;
    for (p_51 = (-6); (p_51 > 60); p_51 += 2)
    { /* block id: 95 */
        int8_t l_284 = 0x29L;
        int32_t *l_294 = &g_156;
        struct S1 *****l_300 = (void*)0;
        int32_t *****l_394 = &g_393;
        if (l_284)
        { /* block id: 96 */
            int32_t *l_292 = (void*)0;
            for (p_54 = 0; (p_54 > 28); p_54 += 3)
            { /* block id: 99 */
                (*g_104) = l_287;
                l_288 = 0x922A5CADL;
            }
            (*g_104) = (!(0x5C67L < 0xD8AAL));
            for (p_55 = 18; (p_55 == 44); p_55++)
            { /* block id: 106 */
                int32_t **l_293 = &l_292;
                (*l_293) = l_292;
                (*l_293) = l_294;
                /* statement id: 108 */
                assert (l_292 == &g_156);
            }
            /* facts after for loop */
            assert (l_292 == &g_156 || l_292 == 0);
        }
        else
        { /* block id: 110 */
            struct S1 ****l_302 = (void*)0;
            l_300 = l_295;
            /* statement id: 111 */
            assert (l_300 == &l_296);
            (*g_104) = (~(l_302 == g_303));
        }
        /* facts after branching */
        assert (l_300 == &l_296 || l_300 == 0);
        (*l_294) = ((uint8_t)((p_53 <= (!(((uint32_t)(((uint16_t)(*l_294) / (uint16_t)(~g_128.f7)) ^ (0x7620ED24L <= (((uint8_t)(*l_294) * (uint8_t)((int8_t)(((uint8_t)((((uint16_t)((uint16_t)p_51 >> (uint16_t)(!(l_324 != (void*)0))) << (uint16_t)(*l_294)) ^ 0L) == g_182) - (uint8_t)g_110.f4) <= 2L) * (int8_t)(*l_294))) < g_110.f7))) % (uint32_t)p_51) || g_110.f2))) && p_55) >> (uint8_t)1);
        g_108 = ((((float)(l_324 != (void*)0) * (float)(((float)((void*)0 == (*g_303)) / (float)(((float)(p_55 > (((float)(-0x6.9p+1) + (float)(((((float)0x9.AE8CEFp-50 + (float)(&l_296 != l_300)) < 0xF.D2D848p-79) >= p_52) < p_55)) <= 0x1.6p-1)) * (float)p_51) <= g_110.f0)) != 0x5.4212A5p-34)) <= (*l_294)) == 0x8.EC9082p+8);
        if (((int16_t)(g_110.f8 | ((((int32_t)(((int64_t)g_128.f4 + (int64_t)(((!(((uint8_t)g_110.f7 >> (uint8_t)((int16_t)((+((int16_t)g_182 - (int16_t)5L)) >= ((int16_t)((((int8_t)((l_353 != l_294) && (p_51 >= (p_51 < g_4))) / (int8_t)p_54) | g_110.f7) < 0x9E0D2702L) >> (int16_t)7)) / (int16_t)0x5472L)) || g_110.f5)) > 1UL) && p_51)) || g_110.f6) % (int32_t)p_54) == 0x9C2ECA86F70DEFB8LL) >= (*l_294))) >> (int16_t)p_55))
        { /* block id: 116 */
            int32_t *l_357 = &l_288;
            int32_t ***l_365 = &g_257;
            for (g_156 = 0; (g_156 != (-15)); g_156 -= 5)
            { /* block id: 119 */
                int32_t **l_356 = &l_294;
                l_294 = l_294;
                (*l_356) = &g_156;
                /* statement id: 121 */
                assert (l_294 == &g_156);
                (*l_356) = l_357;
                /* statement id: 122 */
                assert (l_294 == &l_288);
                (**l_356) = 0x537FA7DBL;
            }
            /* facts after for loop */
            assert (l_294 == &l_288 || l_294 == &g_156);
            if ((((-8L) < (+((int16_t)((uint8_t)(((int16_t)(*l_294) % (int16_t)(((void*)0 == (*g_304)) | p_54)) & (((l_365 != &g_257) >= ((uint8_t)((uint8_t)((((int16_t)g_110.f3 >> (int16_t)14) & g_182) >= p_53) * (uint8_t)(*l_357)) % (uint8_t)g_110.f5)) > g_156)) * (uint8_t)g_110.f4) / (int16_t)p_51))) != (-8L)))
            { /* block id: 125 */
                int64_t l_380 = 1L;
                int32_t *l_381 = &g_156;
                (*l_357) = ((uint8_t)((g_128.f5 & ((int32_t)0x0577D41CL - (int32_t)(g_110.f5 >= (p_55 <= ((((int16_t)0x69FCL >> (int16_t)6) <= (1L > ((uint8_t)((***g_303) != (void*)0) * (uint8_t)(g_110.f4 >= (-6L))))) | g_110.f7))))) == l_380) + (uint8_t)g_110.f1);
                l_381 = &g_156;
            }
            else
            { /* block id: 128 */
                return g_110.f4;
            }
        }
        else
        { /* block id: 131 */
            uint64_t l_384 = 18446744073709551615UL;
            int32_t *l_385 = (void*)0;
            (*g_104) = (-1L);
            l_384 = ((*l_294) & ((****l_295) != (***g_303)));
            l_385 = l_385;
            for (p_55 = 0; (p_55 != 14); p_55 += 7)
            { /* block id: 137 */
                int16_t l_406 = 0x834FL;
                (*l_353) = (p_52 == 0x9.D86674p-53);
                if (((uint8_t)g_110.f3 * (uint8_t)g_110.f1))
                { /* block id: 139 */
                    const int16_t l_390 = 0x069CL;
                    (*l_294) = l_390;
                }
                else
                { /* block id: 141 */
                    int32_t l_391 = (-1L);
                    return l_391;
                }
                l_394 = g_392;
                (*l_353) = (((float)((float)0x1.8B5A75p-76 / (float)g_110.f2) + (float)0xC.4EACAEp+77) >= ((0x2.0p+1 <= (+((float)(((float)g_4 + (float)((((((float)l_406 * (float)(!(g_156 >= ((float)((float)p_55 + (float)((-0x1.9p-1) == l_288)) - (float)g_182)))) >= g_156) == (-0x8.Dp-1)) > g_412) == p_53)) > 0x2.208A20p+28) * (float)0x0.6p+1))) == p_54));
            }
        }
        /* facts after branching */
        assert (l_294 == &l_288 || l_294 == &g_156);
    }
    for (p_54 = 0; (p_54 < 5); p_54++)
    { /* block id: 151 */
        uint64_t l_425 = 0x01D482241D0A166FLL;
        float *l_460 = (void*)0;
        struct S1 *l_476 = &g_477;
        (*l_353) = ((float)(0xE.CEAFB2p+14 < ((!(((float)((float)((float)0x2.35B3B3p+52 - (float)(-(float)0x3.3D1CDCp+18)) / (float)g_128.f1) + (float)l_425) < (g_108 >= (+((float)((((float)g_110.f0 / (float)0x2.62802Ap+8) < p_53) == (-0x7.Dp-1)) * (float)l_425))))) <= 0xE.E377B8p+51)) + (float)0xA.A95572p-4);
        (*g_104) = ((((uint16_t)((uint8_t)p_53 + (uint8_t)(((uint8_t)((uint64_t)18446744073709551609UL % (uint64_t)((uint8_t)(((int32_t)l_287 - (int32_t)(-(int64_t)(g_128.f2 || l_425))) ^ ((((int8_t)((uint64_t)(((uint64_t)((int16_t)1L * (int16_t)(((uint64_t)9UL % (uint64_t)((p_55 && (8UL > p_51)) | 0L)) <= g_110.f8)) + (uint64_t)p_51) <= 65528UL) % (uint64_t)p_54) * (int8_t)p_55) && g_182) != 0xAF371F8CL)) << (uint8_t)g_110.f5)) >> (uint8_t)p_55) == 0x59DAEE6FL)) % (uint16_t)g_110.f4) >= (-10L)) != g_156);
        (*l_353) = ((((float)((float)(((float)g_128.f3 - (float)((void*)0 != l_460)) != ((float)(l_287 < (((float)(((float)p_53 - (float)(-0x6.Dp-1)) >= ((float)(((float)(((float)((float)(+((void*)0 == l_476)) / (float)((float)g_110.f4 * (float)g_110.f8)) * (float)l_425) <= g_4) + (float)p_54) <= 0xF.AE79C7p+55) + (float)0x7.Bp-1)) * (float)g_477.f1) > (-0x5.2p-1))) + (float)l_425)) + (float)0x0.1p+1) * (float)p_52) <= g_108) == (-0x6.5p-1));
    }
    (*l_353) = (g_477.f2 != (((*l_295) != &g_304) >= p_51));
    return g_110.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_104 g_105 g_128.f1 g_4 g_110.f5 g_110.f1 g_128.f0 g_108
 * writes: g_257 g_105 g_108
 */
static uint8_t  func_63(uint64_t  p_64)
{ /* block id: 81 */
    const struct S1 *l_254 = (void*)0;
    const struct S1 **l_253 = &l_254;
    const struct S1 ***l_252 = &l_253;
    const struct S1 ****l_255 = &l_252;
    int32_t **l_256 = (void*)0;
    int16_t l_269 = 0x5467L;
    (*l_255) = l_252;
    g_257 = l_256;
    (*g_104) = (~((*g_104) || ((uint16_t)((((uint8_t)(g_128.f1 <= ((uint16_t)(p_64 != (((((uint16_t)p_64 >> (uint16_t)(&l_252 != &l_252)) | ((uint8_t)0UL << (uint8_t)((&g_126 != (void*)0) == g_4))) || g_4) >= 0x5F4DCE59F5865897LL)) >> (uint16_t)g_110.f5)) * (uint8_t)p_64) | g_110.f1) || l_269) / (uint16_t)p_64)));
    for (l_269 = 9; (l_269 == (-3)); l_269 -= 5)
    { /* block id: 87 */
        int32_t ***l_272 = &l_256;
        int32_t ****l_273 = &l_272;
        float *l_280 = &g_108;
        (*l_273) = l_272;
        (*l_280) = ((float)(((void*)0 != &g_257) > ((p_64 < 0x0.3p-1) <= g_128.f0)) / (float)(((float)((float)p_64 - (float)g_108) + (float)g_4) == (0x0.Fp+1 >= g_4)));
    }
    return g_105;
}


/* ------------------------------------------ */
/* 
 * reads : g_156 g_104 g_105 g_110.f8 g_182 g_128.f0 g_110.f7 g_110.f1 g_110.f4
 * writes: g_156 g_105
 */
static uint8_t  func_67(const int64_t  p_68, uint32_t  p_69, uint32_t  p_70, int8_t  p_71, uint32_t  p_72)
{ /* block id: 64 */
    int32_t *l_233 = &g_156;
    struct S1 *l_243 = &g_110;
    struct S1 **l_242 = &l_243;
    struct S1 ***l_241 = &l_242;
    uint32_t l_250 = 0xFC2D246EL;
    int32_t **l_251 = &l_233;
    for (g_156 = 0; (g_156 < 10); g_156 += 1)
    { /* block id: 67 */
        int32_t **l_234 = &l_233;
        uint32_t l_244 = 0x2A1B4295L;
        (*l_234) = l_233;
        if (p_70)
            continue;
        if ((*g_104))
            continue;
        if (((int8_t)p_72 - (int8_t)p_69))
        { /* block id: 71 */
            return g_110.f8;
        }
        else
        { /* block id: 73 */
            struct S1 ***l_246 = &l_242;
            int32_t l_249 = (-1L);
            (*g_104) = ((int8_t)((((((int16_t)(((((l_241 == &g_126) | (l_244 <= (((((((&g_156 == &g_105) >= ((!(((void*)0 == l_246) || ((uint8_t)(p_69 <= 0xC09E53F8L) - (uint8_t)p_69))) > p_70)) && (**l_234)) >= p_71) == l_249) || l_250) != 1L))) < g_182) >= 0x9CL) | g_128.f0) / (int16_t)(*l_233)) & (-6L)) != g_110.f7) >= g_110.f1) != (**l_234)) * (int8_t)p_68);
            l_249 = (&g_126 == (void*)0);
            return (*l_233);
        }
    }
    (*l_251) = &g_156;
    return g_110.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_104 g_105 g_110.f0 g_128.f7 g_182
 * writes: g_108 g_105
 */
static uint16_t  func_77(uint16_t  p_78, uint16_t  p_79, int32_t  p_80)
{ /* block id: 7 */
    struct S1 **l_223 = (void*)0;
    struct S1 *l_224 = (void*)0;
    float *l_229 = &g_108;
    int32_t l_230 = 1L;
    l_224 = func_81(p_78);
    /* statement id: 56 */
    assert (l_224 == &g_110);
    for (p_78 = 18; (p_78 >= 19); p_78 += 1)
    { /* block id: 59 */
        int32_t *l_228 = &g_156;
        int32_t **l_227 = &l_228;
        (*l_227) = &g_156;
    }
    (*l_229) = (&l_224 == &l_224);
    return l_230;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_104 g_105 g_110.f0 g_128.f7 g_182
 * writes: g_108 g_105
 */
static struct S1 * func_81(uint32_t  p_82)
{ /* block id: 8 */
    int32_t *l_83 = (void*)0;
    int32_t **l_84 = &l_83;
    struct S1 *l_109 = &g_110;
    int32_t l_208 = 0xDB1EA26DL;
    int16_t l_211 = 0xBCEFL;
    (*l_84) = l_83;
    (*l_84) = (*l_84);
    for (p_82 = (-26); (p_82 >= 55); p_82 += 1)
    { /* block id: 13 */
        uint64_t l_101 = 8UL;
        int64_t l_106 = 0xBF4D75DB0C68D18ELL;
        float *l_107 = &g_108;
        float l_123 = 0x5.AA3FDDp+10;
        struct S1 *l_165 = (void*)0;
        (*l_107) = ((float)((((g_4 != 0x9.3p-1) == ((float)p_82 / (float)((g_4 <= (((((((((float)(((float)(0x6.C3AC5Bp+2 >= ((((((float)0xF.396C7Bp+32 - (float)0x1.Fp-1) == ((float)(((float)l_101 * (float)((float)(((g_104 != (void*)0) == 0xA.5EB906p-70) > 0x0.0p-1) + (float)(-0x1.4p-1))) == g_4) * (float)g_4)) >= 0x7.355DD1p+95) <= p_82) >= p_82)) - (float)p_82) <= g_4) - (float)g_105) > l_101) <= p_82) != g_4) < g_4) < 0x3.B1ADF1p-38) >= (-0x1.2p+1)) <= 0x5.C3DCCDp+82)) <= l_106))) > 0x7.B5A03Fp+48) > g_4) - (float)g_4);
    }
    (*g_104) = (((uint16_t)p_82 >> (uint16_t)15) ^ ((uint8_t)0x09L % (uint8_t)((l_208 || ((int8_t)1L << (int8_t)(((l_211 & (((uint16_t)((uint8_t)g_110.f0 >> (uint8_t)5) / (uint16_t)(((int8_t)((uint16_t)((-(uint16_t)(0xF1312D135F3850ECLL || p_82)) == ((uint16_t)(0x36F4042E0B307BF7LL != g_128.f7) * (uint16_t)g_182)) + (uint16_t)0x866DL) / (int8_t)0x26L) && (-1L))) != 1UL)) != g_182) < p_82))) && (*g_104))));
    return l_109;
    /* statement id: 55 */
    //assert (func_81_rv == &g_110);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_105, "g_105", print_hash_value);
    transparent_crc_bytes (&g_108, sizeof(g_108), "g_108", print_hash_value);
    transparent_crc(g_110.f0, "g_110.f0", print_hash_value);
    transparent_crc(g_110.f1, "g_110.f1", print_hash_value);
    transparent_crc(g_110.f2, "g_110.f2", print_hash_value);
    transparent_crc(g_110.f3, "g_110.f3", print_hash_value);
    transparent_crc(g_110.f4, "g_110.f4", print_hash_value);
    transparent_crc(g_110.f5, "g_110.f5", print_hash_value);
    transparent_crc(g_110.f6, "g_110.f6", print_hash_value);
    transparent_crc(g_110.f7, "g_110.f7", print_hash_value);
    transparent_crc(g_110.f8, "g_110.f8", print_hash_value);
    transparent_crc(g_128.f0, "g_128.f0", print_hash_value);
    transparent_crc(g_128.f1, "g_128.f1", print_hash_value);
    transparent_crc(g_128.f2, "g_128.f2", print_hash_value);
    transparent_crc(g_128.f3, "g_128.f3", print_hash_value);
    transparent_crc(g_128.f4, "g_128.f4", print_hash_value);
    transparent_crc(g_128.f5, "g_128.f5", print_hash_value);
    transparent_crc(g_128.f6, "g_128.f6", print_hash_value);
    transparent_crc(g_128.f7, "g_128.f7", print_hash_value);
    transparent_crc(g_128.f8, "g_128.f8", print_hash_value);
    transparent_crc(g_156, "g_156", print_hash_value);
    transparent_crc(g_182, "g_182", print_hash_value);
    transparent_crc_bytes (&g_412, sizeof(g_412), "g_412", print_hash_value);
    transparent_crc(g_477.f0, "g_477.f0", print_hash_value);
    transparent_crc(g_477.f1, "g_477.f1", print_hash_value);
    transparent_crc(g_477.f2, "g_477.f2", print_hash_value);
    transparent_crc(g_477.f3, "g_477.f3", print_hash_value);
    transparent_crc(g_477.f4, "g_477.f4", print_hash_value);
    transparent_crc(g_477.f5, "g_477.f5", print_hash_value);
    transparent_crc(g_477.f6, "g_477.f6", print_hash_value);
    transparent_crc(g_477.f7, "g_477.f7", print_hash_value);
    transparent_crc(g_477.f8, "g_477.f8", print_hash_value);
    transparent_crc(g_564, "g_564", print_hash_value);
    transparent_crc(g_589.f0, "g_589.f0", print_hash_value);
    transparent_crc(g_589.f1, "g_589.f1", print_hash_value);
    transparent_crc(g_589.f2, "g_589.f2", print_hash_value);
    transparent_crc(g_589.f3, "g_589.f3", print_hash_value);
    transparent_crc(g_589.f4, "g_589.f4", print_hash_value);
    transparent_crc(g_589.f5, "g_589.f5", print_hash_value);
    transparent_crc(g_589.f6, "g_589.f6", print_hash_value);
    transparent_crc(g_589.f7, "g_589.f7", print_hash_value);
    transparent_crc(g_589.f8, "g_589.f8", print_hash_value);
    transparent_crc(g_630, "g_630", print_hash_value);
    transparent_crc(g_645.f0, "g_645.f0", print_hash_value);
    transparent_crc(g_645.f1, "g_645.f1", print_hash_value);
    transparent_crc(g_645.f2, "g_645.f2", print_hash_value);
    transparent_crc(g_645.f3, "g_645.f3", print_hash_value);
    transparent_crc(g_645.f4, "g_645.f4", print_hash_value);
    transparent_crc(g_645.f5, "g_645.f5", print_hash_value);
    transparent_crc(g_645.f6, "g_645.f6", print_hash_value);
    transparent_crc(g_645.f7, "g_645.f7", print_hash_value);
    transparent_crc(g_645.f8, "g_645.f8", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 96
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 2
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 2
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 99

XXX max expression depth: 50
breakdown:
   depth: 1, occurrence: 152
   depth: 2, occurrence: 28
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 10, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1
   depth: 35, occurrence: 1
   depth: 50, occurrence: 1

XXX total number of pointers: 99

XXX times a variable address is taken: 101
XXX times a pointer is dereferenced on RHS: 45
breakdown:
   depth: 1, occurrence: 36
   depth: 2, occurrence: 2
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 77
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 333

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 129
   level: 2, occurrence: 38
   level: 3, occurrence: 43
   level: 4, occurrence: 17
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 51
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 24.2
XXX average alias set size: 1.13

XXX times a non-volatile is read: 514
XXX times a non-volatile is write: 178
XXX times a volatile is read: 41
XXX    times read thru a pointer: 8
XXX times a volatile is write: 16
XXX    times written thru a pointer: 16
XXX times a volatile is available for access: 225
XXX percentage of non-volatile access: 92.4

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 129
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 33
   depth: 2, occurrence: 29
   depth: 3, occurrence: 26
   depth: 4, occurrence: 8

XXX percentage a fresh-made variable is used: 15.2
XXX percentage an existing variable is used: 84.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

