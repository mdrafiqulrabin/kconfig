/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      401604826
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_8 = (-3L);
static int32_t g_64 = 0x3ADE45A9L;
static int32_t **g_92 = (void*)0;
static float g_122 = 0x1.7p+1;
static int64_t g_123 = 0x5A40E5C4FF8C8F4DLL;
static int32_t *g_132 = &g_64;
static int32_t **g_131 = &g_132;
static int32_t g_142[3][1][6] = {{{0x3EB6B183L,0x47CB24E9L,0x47CB24E9L,0x3EB6B183L,0xA6E2EE97L,(-10L)}},{{(-10L),0x3EB6B183L,(-1L),0x3EB6B183L,(-10L),0x6139C8B3L}},{{0x3EB6B183L,(-10L),0x6139C8B3L,0x6139C8B3L,(-10L),0x3EB6B183L}}};
static const int32_t *g_174 = &g_142[0][0][3];
static const int32_t **g_173 = &g_174;
static int32_t ***g_246[9] = {&g_131,&g_131,&g_131,&g_131,&g_131,&g_131,&g_131,&g_131,&g_131};
static int32_t ****g_245 = &g_246[4];
static uint16_t g_248 = 0UL;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_28(void);
static int32_t * func_29(int32_t * p_30, int32_t  p_31);
static int32_t * func_32(int32_t  p_33, uint64_t  p_34, int32_t * p_35, int32_t * p_36);
static int32_t  func_39(float  p_40, int64_t  p_41, uint64_t  p_42);
static float  func_47(uint32_t  p_48, int32_t  p_49, int32_t * p_50, float  p_51, uint32_t  p_52);
static uint16_t  func_56(uint32_t  p_57, uint32_t  p_58, int32_t * p_59);
inline static int32_t * func_60(int32_t  p_61, int64_t  p_62);
inline static int64_t  func_77(int16_t  p_78, int16_t  p_79, uint64_t  p_80, int32_t * p_81);
inline static int16_t  func_103(int64_t  p_104, int32_t * p_105, int32_t  p_106, int32_t * p_107, int64_t  p_108);
static int32_t * func_109(const int32_t ** p_110, int32_t ** const  p_111, int32_t  p_112, int32_t ** p_113);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_64 g_142 g_131 g_132 g_174 g_245 g_246 g_248 g_122
 * writes: g_64 g_142 g_132 g_122 g_248
 */
static int32_t  func_28(void)
{ /* block id: 36 */
    uint64_t l_43 = 0x1649BC00EADD5D08LL;
    int32_t *l_310 = &g_142[2][0][0];
    (*g_131) = func_29(func_32(((uint16_t)3UL + (uint16_t)((((g_8 > func_39(l_43, g_8, g_8)) && (((func_77(l_43, (0x2171L > (!g_142[2][0][0])), l_43, l_310) || 0xF678EF2CL) && (*l_310)) <= g_64)) ^ l_43) || (*l_310))), l_43, l_310, l_310), l_43);
    return (*g_132);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_64
 */
static int32_t * func_29(int32_t * p_30, int32_t  p_31)
{ /* block id: 230 */
    int32_t *l_312 = &g_64;
    (*l_312) = 0xBE3F64ECL;
    return l_312;
    /* statement id: 232 */
    //assert (func_29_rv == &g_64);
}


/* ------------------------------------------ */
/* 
 * reads : g_245 g_246 g_131
 * writes: g_132
 */
static int32_t * func_32(int32_t  p_33, uint64_t  p_34, int32_t * p_35, int32_t * p_36)
{ /* block id: 227 */
    int32_t *l_311 = (void*)0;
    (***g_245) = &p_33;
    /* statement id: 228 */
    assert (g_132 == &p_33);
    return l_311;
    /* statement id: 229 */
    //assert (g_132 == dangling);
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_64 g_142 g_131 g_132 g_174 g_245 g_246 g_248 g_122
 * writes: g_64 g_142 g_132 g_122 g_248
 */
static int32_t  func_39(float  p_40, int64_t  p_41, uint64_t  p_42)
{ /* block id: 37 */
    int32_t l_53[4];
    float *l_250 = (void*)0;
    float *l_251 = (void*)0;
    float *l_252 = &g_122;
    int32_t *****l_280 = &g_245;
    uint32_t l_306 = 3UL;
    int i;
    for (i = 0; i < 4; i++)
        l_53[i] = (-1L);
    (*l_252) = (p_42 == ((float)0x2.1D534Ap-96 - (float)(-(float)((func_47(l_53[2], ((uint16_t)1UL << (uint16_t)func_56(g_8, g_8, &l_53[0])), &l_53[1], g_122, g_248) > p_42) != g_8))));
    for (g_248 = 14; (g_248 == 46); g_248 += 5)
    { /* block id: 178 */
        int32_t * const **l_263 = (void*)0;
        int32_t * const ***l_262 = &l_263;
        int32_t * const ****l_261 = &l_262;
        int32_t *l_268 = &g_64;
        uint32_t l_302 = 4294967289UL;
        for (p_42 = 0; (p_42 == 21); p_42++)
        { /* block id: 181 */
            int32_t *** const *l_260 = &g_246[4];
            int32_t *** const **l_259[3];
            int i;
            for (i = 0; i < 3; i++)
                l_259[i] = &l_260;
            (*g_132) = ((int16_t)(l_259[2] == l_261) - (int16_t)((*g_174) > p_41));
        }
        return (*g_174);
    }
    return l_306;
}


/* ------------------------------------------ */
/* 
 * reads : g_132 g_142
 * writes: g_64
 */
static float  func_47(uint32_t  p_48, int32_t  p_49, int32_t * p_50, float  p_51, uint32_t  p_52)
{ /* block id: 172 */
    uint32_t l_249 = 0x0B2EBA6AL;
    (*g_132) = (*p_50);
    return l_249;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_64 g_142 g_131 g_132 g_174 g_245 g_246 g_248
 * writes: g_64 g_142 g_132
 */
static uint16_t  func_56(uint32_t  p_57, uint32_t  p_58, int32_t * p_59)
{ /* block id: 38 */
    int32_t *l_63 = &g_64;
    (***g_245) = func_60(g_8, ((void*)0 != l_63));
    return (*l_63);
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_8 g_142 g_131 g_132 g_174 g_245 g_246 g_248
 * writes: g_64 g_142
 */
inline static int32_t * func_60(int32_t  p_61, int64_t  p_62)
{ /* block id: 39 */
    float l_84 = 0x1.Ep-1;
    int32_t l_153 = (-8L);
    const int32_t **l_184 = &g_174;
    int32_t ** const l_205 = &g_132;
    float *l_230 = (void*)0;
    for (g_64 = (-12); (g_64 == 12); g_64 += 1)
    { /* block id: 42 */
        float l_75 = (-0x4.9p+1);
        int64_t l_76 = (-1L);
        int32_t *l_85 = (void*)0;
        int32_t ***l_164[8] = {&g_131,&g_131,&g_131,&g_131,&g_131,&g_131,&g_131,&g_131};
        int32_t ****l_163 = &l_164[5];
        int32_t *l_203 = &l_153;
        const int32_t **l_222 = &g_174;
        uint32_t l_224[7][9][4] = {{{18446744073709551612UL,9UL,0x3E23C1EDL,0UL},{0x66DA5D0AL,18446744073709551611UL,0x15336B33L,18446744073709551612UL},{18446744073709551609UL,1UL,0xAB9F6C52L,0UL},{0xF0F0B529L,18446744073709551615UL,0x66DA5D0AL,6UL},{18446744073709551612UL,0xF0F0B529L,18446744073709551612UL,0xAF039434L},{18446744073709551609UL,0xAB9F6C52L,0x3E23C1EDL,18446744073709551615UL},{0UL,18446744073709551612UL,6UL,0xAB9F6C52L},{0x22974175L,18446744073709551612UL,6UL,0x15336B33L},{0UL,1UL,0x3E23C1EDL,0x3E23C1EDL}},{{18446744073709551609UL,18446744073709551609UL,18446744073709551612UL,0x22974175L},{18446744073709551612UL,0x22974175L,0x66DA5D0AL,0xF0F0B529L},{0xF0F0B529L,0xFF0F8D77L,18446744073709551609UL,0x66DA5D0AL},{18446744073709551611UL,0xFF0F8D77L,9UL,0xF0F0B529L},{0xFF0F8D77L,0x22974175L,0xAF039434L,0x22974175L},{18446744073709551611UL,18446744073709551609UL,0xAB9F6C52L,0x3E23C1EDL},{0xAF039434L,1UL,18446744073709551612UL,0x15336B33L},{0x3E23C1EDL,18446744073709551612UL,0xFF0F8D77L,0xAB9F6C52L},{0x3E23C1EDL,18446744073709551612UL,18446744073709551612UL,18446744073709551615UL}},{{0xAF039434L,0xAB9F6C52L,0xAB9F6C52L,0xAF039434L},{18446744073709551611UL,0xF0F0B529L,0xAF039434L,6UL},{0xFF0F8D77L,18446744073709551615UL,9UL,0UL},{18446744073709551611UL,0x15336B33L,18446744073709551609UL,0UL},{0xF0F0B529L,18446744073709551615UL,0x66DA5D0AL,6UL},{18446744073709551612UL,0xF0F0B529L,18446744073709551612UL,0xAF039434L},{18446744073709551609UL,0xAB9F6C52L,0x3E23C1EDL,18446744073709551615UL},{0UL,18446744073709551612UL,6UL,0xAB9F6C52L},{0x22974175L,18446744073709551612UL,6UL,0x15336B33L}},{{0UL,1UL,0x3E23C1EDL,0x3E23C1EDL},{18446744073709551609UL,18446744073709551609UL,18446744073709551612UL,0x22974175L},{18446744073709551612UL,0x22974175L,0x66DA5D0AL,0xF0F0B529L},{0xF0F0B529L,0xFF0F8D77L,18446744073709551609UL,0x66DA5D0AL},{18446744073709551611UL,0xFF0F8D77L,9UL,0xF0F0B529L},{0xFF0F8D77L,0x22974175L,0xAF039434L,0x22974175L},{18446744073709551611UL,18446744073709551609UL,0xAB9F6C52L,0x3E23C1EDL},{0xAF039434L,1UL,18446744073709551612UL,0x15336B33L},{0x3E23C1EDL,18446744073709551612UL,0xFF0F8D77L,0xAB9F6C52L}},{{0x3E23C1EDL,18446744073709551612UL,18446744073709551612UL,18446744073709551615UL},{0xAF039434L,0xAB9F6C52L,0xAB9F6C52L,0xAF039434L},{18446744073709551611UL,0xF0F0B529L,0xAF039434L,6UL},{0xFF0F8D77L,18446744073709551615UL,9UL,0UL},{18446744073709551611UL,0x15336B33L,18446744073709551609UL,0UL},{0xF0F0B529L,18446744073709551615UL,0x66DA5D0AL,6UL},{18446744073709551612UL,0xF0F0B529L,18446744073709551612UL,0xAF039434L},{18446744073709551609UL,0xAB9F6C52L,0x3E23C1EDL,18446744073709551615UL},{0UL,18446744073709551612UL,6UL,0xAB9F6C52L}},{{0x22974175L,18446744073709551612UL,6UL,0x15336B33L},{0UL,1UL,0x3E23C1EDL,0x3E23C1EDL},{18446744073709551609UL,18446744073709551609UL,18446744073709551612UL,0x22974175L},{18446744073709551612UL,0x22974175L,0x66DA5D0AL,0xF0F0B529L},{0xF0F0B529L,0xFF0F8D77L,18446744073709551609UL,0x66DA5D0AL},{18446744073709551611UL,0xFF0F8D77L,0xF0F0B529L,18446744073709551612UL},{0x22974175L,0xAB9F6C52L,18446744073709551612UL,0xAB9F6C52L},{18446744073709551615UL,18446744073709551611UL,18446744073709551609UL,0xAF039434L},{18446744073709551612UL,0x15336B33L,0UL,9UL}},{{0xAF039434L,0UL,0x22974175L,18446744073709551609UL},{0xAF039434L,18446744073709551611UL,0UL,0x66DA5D0AL},{18446744073709551612UL,18446744073709551609UL,18446744073709551609UL,18446744073709551612UL},{18446744073709551615UL,18446744073709551612UL,18446744073709551612UL,0x3E23C1EDL},{0x22974175L,0x66DA5D0AL,0xF0F0B529L,6UL},{18446744073709551610UL,9UL,18446744073709551611UL,6UL},{18446744073709551612UL,0x66DA5D0AL,0xFF0F8D77L,0x3E23C1EDL},{18446744073709551611UL,18446744073709551612UL,18446744073709551611UL,18446744073709551612UL},{18446744073709551611UL,18446744073709551609UL,0xAF039434L,0x66DA5D0AL}}};
        int32_t *l_227 = &g_142[2][0][3];
        int i, j, k;
        for (p_62 = 0; (p_62 < (-18)); p_62--)
        { /* block id: 45 */
            int32_t l_69[4][6][1] = {{{(-10L)},{0x111919B1L},{0xF05746ACL},{0xF05746ACL},{0x111919B1L},{(-10L)}},{{0x00B46F9FL},{(-10L)},{0x111919B1L},{0xF05746ACL},{0xF05746ACL},{0x111919B1L}},{{(-10L)},{0x00B46F9FL},{(-10L)},{0x111919B1L},{0xF05746ACL},{0xF05746ACL}},{{0x111919B1L},{(-10L)},{0x00B46F9FL},{(-10L)},{0x111919B1L},{0xF05746ACL}}};
            float *l_154 = &l_84;
            int32_t *** const l_206 = &g_92;
            int32_t ****l_213 = &l_164[5];
            float l_225 = 0x5.B2AA7Fp-38;
            int i, j, k;
            (*l_154) = (g_8 <= ((l_69[2][1][0] <= (0x7.A9A262p+44 >= ((p_62 != 0x6.3p-1) > (((((!__builtin_popcountl(((uint32_t)(((uint64_t)g_8 % (uint64_t)(l_76 | func_77(((int32_t)g_8 % (int32_t)1L), p_62, g_8, l_85))) | p_61) + (uint32_t)0UL))) > p_62) > l_153) != g_142[2][0][0]) == (-0x10.9p-1))))) != 0x0.Bp+1));
        }
        (*l_227) = ((g_64 != (p_62 < g_64)) != ((float)(g_64 <= (l_230 != (void*)0)) + (float)__builtin_bswap64(((uint64_t)g_8 - (uint64_t)(-9L)))));
        if (p_62)
            continue;
    }
    for (p_61 = 0; (p_61 < (-27)); p_61--)
    { /* block id: 163 */
        float l_235 = 0x0.5p+1;
        int32_t l_236 = 0L;
        int32_t ****l_247 = &g_246[4];
        l_235 = (g_142[1][0][4] <= g_8);
        (**g_131) = 0x6B0FEA9BL;
        (*g_132) = (**g_131);
        (****g_245) = func_77((**l_205), (l_236 >= ((((uint32_t)((**l_184) <= __builtin_popcount((**l_205))) + (uint32_t)(p_62 & ((int32_t)p_61 - (int32_t)(((uint16_t)0x6F19L % (uint16_t)((uint32_t)(g_245 == l_247) + (uint32_t)0x106F96AAL)) != 5L)))) <= (****l_247)) | 0x88489572L)), g_248, (***l_247));
    }
    return (*l_205);
    /* statement id: 169 */
    //assert (func_60_rv == &g_64);
}


/* ------------------------------------------ */
/* 
 * reads : g_8
 * writes:
 */
inline static int64_t  func_77(int16_t  p_78, int16_t  p_79, uint64_t  p_80, int32_t * p_81)
{ /* block id: 46 */
    int32_t *l_86 = (void*)0;
    int32_t **l_87 = &l_86;
    (*l_87) = l_86;
    for (p_78 = 0; (p_78 <= (-18)); p_78--)
    { /* block id: 50 */
        int64_t l_96 = 0xCAA0E685266ADDA1LL;
        int32_t *l_141 = &g_142[2][0][0];
        const int32_t *l_145[4] = {&g_142[2][0][0],&g_142[2][0][0],&g_142[2][0][0],&g_142[2][0][0]};
        const int32_t **l_144 = &l_145[3];
        int i;
    }
    return g_8;
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_92 g_8
 * writes: g_92 g_122 g_123
 */
inline static int16_t  func_103(int64_t  p_104, int32_t * p_105, int32_t  p_106, int32_t * p_107, int64_t  p_108)
{ /* block id: 54 */
    const int32_t *l_115 = &g_64;
    const int32_t **l_114 = &l_115;
    int32_t *l_117[2][10][10] = {{{&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,&g_64,&g_64,&g_64,(void*)0,&g_64,&g_64,&g_64,(void*)0},{&g_64,&g_64,&g_64,(void*)0,&g_64,(void*)0,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,(void*)0,&g_64,&g_64,&g_64,&g_64,(void*)0,(void*)0,&g_64},{&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64},{&g_64,(void*)0,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,(void*)0,(void*)0},{(void*)0,&g_64,&g_64,(void*)0,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,(void*)0,&g_64,&g_64,(void*)0,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,&g_64,&g_64,&g_64,(void*)0,(void*)0,&g_64,(void*)0,&g_64}},{{(void*)0,(void*)0,(void*)0,&g_64,&g_64,&g_64,(void*)0,(void*)0,(void*)0,&g_64},{&g_64,&g_64,&g_64,(void*)0,&g_64,&g_64,&g_64,&g_64,(void*)0,&g_64},{&g_64,&g_64,&g_64,(void*)0,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,&g_64,(void*)0,(void*)0,&g_64,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,(void*)0,&g_64,(void*)0,&g_64,&g_64,(void*)0,&g_64,(void*)0},{&g_64,&g_64,(void*)0,(void*)0,&g_64,(void*)0,&g_64,&g_64,&g_64,&g_64},{&g_64,&g_64,&g_64,&g_64,(void*)0,&g_64,&g_64,&g_64,(void*)0,&g_64},{&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64,&g_64}}};
    int32_t ** const l_116 = &l_117[1][8][1];
    int32_t **l_128 = &l_117[1][9][7];
    int i, j, k;
    (*l_116) = func_109(l_114, l_116, (**l_114), g_92);
    if (g_64)
    { /* block id: 62 */
        int32_t ***l_120 = &g_92;
        float *l_121[9][10] = {{&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122},{&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,(void*)0,&g_122,&g_122},{&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122},{&g_122,&g_122,&g_122,&g_122,(void*)0,(void*)0,&g_122,&g_122,&g_122,(void*)0},{&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,(void*)0,&g_122,&g_122},{(void*)0,&g_122,&g_122,(void*)0,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122},{&g_122,(void*)0,&g_122,&g_122,&g_122,&g_122,(void*)0,&g_122,&g_122,(void*)0},{(void*)0,(void*)0,&g_122,&g_122,(void*)0,(void*)0,&g_122,&g_122,&g_122,&g_122},{&g_122,(void*)0,&g_122,&g_122,&g_122,&g_122,&g_122,&g_122,(void*)0,&g_122}};
        int i, j;
        (*l_120) = &p_107;
        /* statement id: 63 */
        assert (g_92 == &p_107);
        g_122 = ((g_8 < (p_108 < (g_8 > g_8))) < 0xE.BB8780p-94);
    }
    else
    { /* block id: 65 */
        int32_t *l_126 = &g_64;
        g_123 = 1L;
        for (p_106 = 21; (p_106 != (-3)); p_106 -= 3)
        { /* block id: 69 */
            int32_t l_127[3];
            int i;
            for (i = 0; i < 3; i++)
                l_127[i] = (-8L);
            (*l_116) = l_126;
            l_127[2] = ((void*)0 == p_107);
        }
    }
    /* facts after branching */
    assert (g_92 == 0 || g_92 == &p_107);
    l_128 = &p_105;
    /* statement id: 74 */
    assert (l_128 == &p_105);
    (*l_116) = p_107;
    /* statement id: 75 */
    //assert (l_117[0][0][0] == 0 || l_117[0][0][0] == &g_64 || (l_117[0][0][0] >= &l_69[0][0][0] && l_117[0][0][0] <= &l_69[3][5][0]));
    return p_108;
    /* statement id: 76 */
    //assert (g_92 == 0 || g_92 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_8 g_132
 * writes:
 */
static int32_t * func_109(const int32_t ** p_110, int32_t ** const  p_111, int32_t  p_112, int32_t ** p_113)
{ /* block id: 55 */
    uint32_t l_118 = 0xD7FDF8BFL;
    int32_t *l_119 = (void*)0;
    if (((g_64 < (g_64 || l_118)) & g_8))
    { /* block id: 56 */
        return l_119;
        /* statement id: 57 */
        //assert (func_109_rv == 0);
    }
    else
    { /* block id: 58 */
        return (*p_111);
        /* statement id: 59 */
        //assert (func_109_rv == 0 || func_109_rv == &g_64);
    }
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_64, "g_64", print_hash_value);
    transparent_crc_bytes (&g_122, sizeof(g_122), "g_122", print_hash_value);
    transparent_crc(g_123, "g_123", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 1; j++)
        {
            for (k = 0; k < 6; k++)
            {
                transparent_crc(g_142[i][j][k], "g_142[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_248, "g_248", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 81
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 9
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 9, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 85

XXX times a variable address is taken: 338
XXX times a pointer is dereferenced on RHS: 42
breakdown:
   depth: 1, occurrence: 23
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 40
breakdown:
   depth: 1, occurrence: 34
   depth: 2, occurrence: 3
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 406

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 126
   level: 2, occurrence: 36
   level: 3, occurrence: 9
   level: 4, occurrence: 22
   level: 5, occurrence: 13
XXX number of pointers point to pointers: 46
XXX number of pointers point to scalars: 39
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 34.1
XXX average alias set size: 1.56

XXX times a non-volatile is read: 378
XXX times a non-volatile is write: 124
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 44
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 15
   depth: 2, occurrence: 4

XXX percentage a fresh-made variable is used: 19.6
XXX percentage an existing variable is used: 80.4
********************* end of statistics **********************/

