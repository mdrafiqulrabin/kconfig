/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3906332974
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint16_t g_6 = 65530UL;
static int32_t g_42 = (-10L);
static int32_t *g_44 = &g_42;
static int32_t ** volatile g_43 = &g_44;/* VOLATILE GLOBAL g_43 */
static uint32_t g_46 = 1UL;
static int32_t g_88 = 0x88B3176AL;
static int32_t g_90 = 1L;
static uint64_t g_100 = 0xA4ED9E6264A05A9ELL;
static int32_t * volatile g_101 = &g_88;/* VOLATILE GLOBAL g_101 */
static int32_t * volatile g_115 = &g_88;/* VOLATILE GLOBAL g_115 */
static int16_t g_127 = 8L;
static int32_t **g_133 = (void*)0;
static uint32_t * volatile g_145 = &g_46;/* VOLATILE GLOBAL g_145 */
static uint32_t * volatile *g_144 = &g_145;
static uint32_t * volatile ** volatile g_146 = (void*)0;/* VOLATILE GLOBAL g_146 */
static int32_t g_159 = 0L;
static int32_t g_171 = 0x0AD34F8EL;
static int32_t *g_196 = &g_90;
static int32_t ** volatile g_195 = &g_196;/* VOLATILE GLOBAL g_195 */
static int32_t ***g_223 = &g_133;
static int64_t g_244 = (-1L);
static const uint64_t g_245 = 2UL;
static const int32_t g_248 = 0xCE6E74F6L;
static uint32_t **g_270 = (void*)0;
static uint32_t ***g_269 = &g_270;
static uint16_t *g_278 = &g_6;
static uint16_t ** volatile g_277 = &g_278;/* VOLATILE GLOBAL g_277 */
static uint16_t ** volatile * volatile g_279 = &g_277;/* VOLATILE GLOBAL g_279 */
static int32_t * volatile g_292 = &g_90;/* VOLATILE GLOBAL g_292 */
static int32_t **** volatile g_305 = (void*)0;/* VOLATILE GLOBAL g_305 */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_28(void);
inline static uint32_t  func_33(int32_t  p_34, int32_t  p_35, uint16_t  p_36, const int64_t  p_37, uint32_t  p_38);
static uint32_t  func_39(uint16_t  p_40);
inline static int32_t  func_48(int32_t * p_49, int64_t  p_50);
inline static int32_t * func_53(int32_t * p_54, int32_t ** p_55, int32_t ** p_56);
inline static int32_t * func_57(const int32_t * p_58);
inline static int32_t * func_59(int32_t ** p_60, int32_t * p_61);
inline static uint32_t  func_69(const uint64_t  p_70, int32_t ** p_71);
static const uint16_t  func_77(uint32_t  p_78, const int32_t * p_79, int32_t ** p_80);
inline static int32_t * func_81(uint16_t  p_82, int32_t * p_83, int64_t  p_84, uint64_t  p_85, int32_t  p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_43 g_42 g_44 g_223 g_133 g_171 g_196 g_100 g_46 g_88 g_101 g_115 g_90 g_144 g_145 g_269 g_248 g_195 g_277 g_279 g_278 g_127 g_292 g_245
 * writes: g_44 g_46 g_42 g_171 g_244 g_127 g_90 g_88 g_100 g_144 g_269 g_196 g_277 g_6 g_223
 */
static uint64_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = (-3L);
    int64_t l_47 = 0xB8EB5EA28C7FFFAALL;
    int32_t l_291 = 0L;
    int32_t * volatile l_293 = &g_42;/* VOLATILE GLOBAL l_293 */
    uint32_t l_301 = 0x467133BAL;
    int32_t ***l_304 = &g_133;
    int64_t l_310 = 0L;
    if (l_29)
    { /* block id: 37 */
        int32_t l_32 = 0xD0B5486BL;
        uint32_t *l_45 = &g_46;
        if ((((int16_t)(l_32 == g_6) >> (int16_t)11) && (func_33(l_32, (((*l_45) = func_39(g_6)) != (&g_42 != &g_42)), l_29, g_42, l_47) & l_47)))
        { /* block id: 191 */
            int32_t **l_276 = &g_196;
            (*l_276) = func_57(&l_32);
            /* statement id: 192 */
            assert (g_196 == &g_171);
            (**l_276) = 0xD425E7FCL;
            (*l_276) = (*g_195);
        }
        else
        { /* block id: 195 */
            l_32 = (*g_196);
            return l_47;
        }
        /* facts after branching */
        assert (g_44 == &g_171 || g_44 == &g_42 || g_44 == 0);
        assert (g_196 == &g_171);
        (*g_196) = l_29;
    }
    else
    { /* block id: 200 */
        uint16_t l_284 = 6UL;
        int32_t ****l_290 = &g_223;
        (*g_279) = g_277;
        l_291 = ((uint16_t)(((uint16_t)(l_284 != g_100) << (uint16_t)12) || (*g_44)) + (uint16_t)(((uint64_t)((uint16_t)(***g_279) * (uint16_t)(~0xC26BE9DCL)) + (uint64_t)((__builtin_ffs(l_29) & (&g_223 != l_290)) < l_29)) > g_127));
    }
    /* facts after branching */
    assert (g_44 == &g_171 || g_44 == &g_42 || g_44 == 0);
    assert (g_196 == &g_90 || g_196 == &g_171);
    (*g_196) = 1L;
    l_293 = g_292;
    /* statement id: 205 */
    assert (l_293 == &g_90);
    if (((*l_293) >= (&g_144 == &g_270)))
    { /* block id: 206 */
        const int32_t *l_297 = &l_291;
        for (g_6 = 0; (g_6 != 38); ++g_6)
        { /* block id: 209 */
            int32_t **l_296 = (void*)0;
            l_293 = ((*g_43) = (*g_43));
            /* statement id: 211 */
            assert (l_293 == &g_171 || l_293 == &g_42 || l_293 == 0);
            (*g_195) = func_57(l_297);
            /* statement id: 212 */
            assert (g_196 == &g_171);
            (*g_196) = (*l_297);
        }
        /* facts after for loop */
        assert (l_293 == &g_171 || l_293 == &g_42 || l_293 == 0 || l_293 == &g_90);
    }
    else
    { /* block id: 215 */
        uint64_t l_300 = 2UL;
        int16_t *l_302 = (void*)0;
        int16_t *l_303 = &g_127;
        int32_t ****l_306 = &g_223;
        (*g_195) = func_81((((((void*)0 != &g_146) >= ((-8L) || ((*g_115) || ((uint16_t)l_300 << (uint16_t)1)))) != g_90) || l_301), &g_159, (((*l_303) = 0L) < 0x3A89L), l_29, l_301);
        /* statement id: 217 */
        assert (g_196 == &g_90);
        (*l_306) = l_304;
        if (((((void*)0 == &g_223) || ((**g_144) = (*l_293))) < ((uint16_t)65535UL << (uint16_t)0)))
        { /* block id: 220 */
            uint32_t l_309 = 0x3AF6F8DDL;
            return l_309;
        }
        else
        { /* block id: 222 */
            return g_245;
        }
    }
    /* facts after branching */
    assert (l_293 == &g_171 || l_293 == &g_42 || l_293 == 0 || l_293 == &g_90);
    return l_310;
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_44 g_223 g_133 g_171 g_6 g_196 g_100 g_46 g_88 g_101 g_43 g_115 g_90 g_144 g_145 g_269 g_248
 * writes: g_42 g_44 g_171 g_244 g_127 g_90 g_88 g_100 g_46 g_144 g_269
 */
inline static uint32_t  func_33(int32_t  p_34, int32_t  p_35, uint16_t  p_36, const int64_t  p_37, uint32_t  p_38)
{ /* block id: 42 */
    int32_t *l_51 = &g_42;
    uint32_t ****l_271 = &g_269;
    int32_t ****l_275 = &g_223;
    int32_t *****l_274 = &l_275;
    (*g_196) = func_48(l_51, (*l_51));
    /* statement id: 186 */
    assert (g_44 == &g_171 || g_44 == &g_42 || g_44 == 0);
    (*l_51) = (-(uint64_t)(p_35 || (g_42 && p_36)));
    (*g_196) = (func_69(g_100, &l_51) >= (p_34 > ((int32_t)(0x4E3F69E2L > ((((*l_271) = g_269) != (void*)0) & g_248)) - (int32_t)((uint16_t)((void*)0 != l_274) << (uint16_t)g_6))));
    /* statement id: 189 */
    assert (l_51 == &g_42 || l_51 == &g_90);
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads : g_43
 * writes: g_44
 */
static uint32_t  func_39(uint16_t  p_40)
{ /* block id: 38 */
    int32_t *l_41 = &g_42;
    (*g_43) = l_41;
    /* statement id: 39 */
    assert (g_44 == &g_42);
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_44 g_223 g_133 g_171 g_6 g_196
 * writes: g_42 g_44 g_171 g_244 g_127 g_90
 */
inline static int32_t  func_48(int32_t * p_49, int64_t  p_50)
{ /* block id: 43 */
    int8_t l_52 = 0L;
    int32_t **l_62 = &g_44;
    int32_t ***l_63 = &l_62;
    int32_t *l_64 = (void*)0;
    const int32_t **l_246 = (void*)0;
    const int32_t *l_247 = &g_248;
    int32_t **l_265 = &g_44;
    (*p_49) = (0xE291920BL < l_52);
    (*g_44) = __builtin_ia32_crc32qi(g_42, (0xB58FE4DEL != 1L));
    (*l_265) = func_53(func_57((l_247 = func_59(((*l_63) = l_62), l_64))), (*g_223), &p_49);
    /* statement id: 184 */
    assert (g_44 == &g_171 || g_44 == &g_42 || g_44 == 0);
    assert (p_49 == &g_171 || p_49 == &g_42);
    assert (l_247 == 0);
    return (*p_49);
}


/* ------------------------------------------ */
/* 
 * reads : g_171 g_6 g_196
 * writes: g_171 g_244 g_127 g_90
 */
inline static int32_t * func_53(int32_t * p_54, int32_t ** p_55, int32_t ** p_56)
{ /* block id: 166 */
    int64_t l_253 = 0x7DA2B03852427BCELL;
    int16_t *l_254 = &g_127;
    int64_t l_261 = 0xD17D0ED01F525330LL;
    int64_t *l_262 = &l_261;
    int64_t *l_263 = &g_244;
    int32_t *l_264 = (void*)0;
    for (g_171 = 14; (g_171 == 10); g_171 -= 1)
    { /* block id: 169 */
        int32_t *l_252 = &g_171;
        (*p_56) = l_252;
        /* statement id: 170 */
        //assert (p_49 == &g_171);
    }
    /* facts after for loop */
    //assert (p_49 == &g_171 || p_49 == &g_42);
    if ((l_253 ^ ((void*)0 == l_254)))
    { /* block id: 172 */
        (*p_54) = 8L;
        (*p_56) = (*p_56);
    }
    else
    { /* block id: 175 */
        (*p_56) = (*p_56);
        return (*p_56);
        /* statement id: 177 */
        //assert (func_53_rv == &g_171 || func_53_rv == &g_42);
    }
    (*g_196) = ((int16_t)(4294967295UL >= (((uint16_t)__builtin_ffsl(l_253) * (uint16_t)0x0A73L) & ((l_253 ^ (1L >= l_253)) != ((*l_254) = ((((uint16_t)g_171 * (uint16_t)(((*l_263) = ((*l_262) = l_261)) != l_253)) | g_6) | l_253))))) * (int16_t)l_253);
    return l_264;
    /* statement id: 183 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_57(const int32_t * p_58)
{ /* block id: 164 */
    int32_t *l_249 = &g_171;
    return l_249;
    /* statement id: 165 */
    //assert (func_57_rv == &g_171);
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_44
 * writes: g_44 g_42
 */
inline static int32_t * func_59(int32_t ** p_60, int32_t * p_61)
{ /* block id: 47 */
    int32_t **l_163 = &g_44;
    uint32_t l_183 = 0x10A815A6L;
    (*p_60) = (void*)0;
    /* statement id: 48 */
    assert (g_44 == 0);
    for (g_42 = 0; (g_42 == (-27)); g_42 -= 4)
    { /* block id: 51 */
        int8_t l_155 = (-1L);
        int32_t *l_156 = (void*)0;
        int32_t *l_157 = (void*)0;
        int32_t *l_158 = &g_159;
        uint64_t l_207 = 0UL;
    }
    return (*p_60);
    /* statement id: 162 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_42 g_46 g_88 g_101 g_43 g_100 g_115 g_90 g_133 g_6 g_144 g_145
 * writes: g_88 g_90 g_100 g_44 g_46 g_127 g_144
 */
inline static uint32_t  func_69(const uint64_t  p_70, int32_t ** p_71)
{ /* block id: 52 */
    int32_t ***l_76 = (void*)0;
    int32_t *l_87 = &g_88;
    int32_t *l_89 = &g_90;
    uint32_t *l_143 = &g_46;
    if (((0xF05DE082ADE89B93LL > __builtin_popcount(((*l_143) = ((((int16_t)(l_76 != &p_71) * (int16_t)func_77(p_70, func_81(p_70, (*p_71), p_70, g_42, ((*l_89) = ((*l_87) = (g_42 < 0UL)))), g_133)) < 0UL) <= 0x0F45F4D98BCDAFCELL)))) || g_6))
    { /* block id: 86 */
        uint32_t * volatile **l_147 = &g_144;
        int32_t *l_148 = &g_90;
        uint32_t * volatile ***l_149 = &l_147;
        (*l_147) = g_144;
        (*p_71) = l_148;
        /* statement id: 88 */
        assert (g_44 == &g_90 || g_44 == &g_171 || g_44 == &g_42 || g_44 == 0);
        (*l_149) = &g_144;
    }
    else
    { /* block id: 90 */
        uint64_t *l_154 = &g_100;
        (*l_89) = ((uint16_t)(5L > ((*l_154) = ((int16_t)((0x986B1ECDL < p_70) ^ g_46) + (int16_t)p_70))) * (uint16_t)0x6C8BL);
    }
    return (**g_144);
}


/* ------------------------------------------ */
/* 
 * reads : g_100 g_43 g_44 g_42 g_6 g_46 g_88 g_101 g_115 g_90
 * writes: g_100 g_88 g_44 g_46 g_90 g_127
 */
static const uint16_t  func_77(uint32_t  p_78, const int32_t * p_79, int32_t ** p_80)
{ /* block id: 78 */
    int64_t l_134 = (-1L);
    uint32_t *l_136 = &g_46;
    uint32_t **l_135 = &l_136;
    uint32_t *l_138 = &g_46;
    uint32_t **l_137 = &l_138;
    uint32_t *l_140 = &g_46;
    uint32_t **l_139 = &l_140;
    int32_t *l_141 = (void*)0;
    int32_t *l_142 = &g_88;
    (*l_142) = (((&g_46 == ((*l_139) = ((*l_137) = ((*l_135) = func_81(g_100, (*g_43), p_78, __builtin_parityl(g_42), l_134))))) || ((*l_136) = 0xB3C44AE9L)) >= 0xE22B755DL);
    /* statement id: 83 */
    assert (l_136 == &g_90);
    assert (l_138 == &g_90);
    assert (l_140 == &g_90);
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads : g_46 g_88 g_101 g_43 g_100 g_115 g_90 g_42
 * writes: g_100 g_88 g_44 g_46 g_90 g_127
 */
inline static int32_t * func_81(uint16_t  p_82, int32_t * p_83, int64_t  p_84, uint64_t  p_85, int32_t  p_86)
{ /* block id: 55 */
    int32_t l_96 = 0xC9EEB3BDL;
    uint64_t *l_99 = &g_100;
    uint32_t *l_106 = &g_46;
    int32_t *l_109 = &g_90;
    (*g_101) = (!((*l_99) = ((uint32_t)((uint16_t)l_96 >> (uint16_t)3) % (uint32_t)((uint64_t)(p_84 ^ g_46) + (uint64_t)g_88))));
    (*l_109) = ((0x7D79L && ((int16_t)p_84 % (int16_t)65526UL)) || (((((uint16_t)func_39(p_82) * (uint16_t)l_96) > ((*l_106) = l_96)) && ((l_96 != ((int16_t)0xBE4BL << (int16_t)4)) | p_82)) != l_96));
    for (g_100 = (-27); (g_100 == 16); g_100 += 4)
    { /* block id: 62 */
        int8_t l_114 = 0x8BL;
        int32_t **l_121 = &g_44;
        int32_t ***l_120 = &l_121;
        int16_t *l_126 = &g_127;
        for (p_86 = 0; (p_86 != 15); p_86 += 3)
        { /* block id: 65 */
            if ((*g_101))
                break;
            (*g_115) = ((*l_109) = l_114);
            (*l_109) = (-1L);
        }
        (*l_109) = ((uint16_t)((int64_t)(l_120 == (void*)0) / (int64_t)0x97C51C8BDC662BFFLL) >> (uint16_t)6);
        (*l_109) = ((*g_115) == (1L == ((int16_t)((*l_126) = p_84) * (int16_t)(g_90 <= g_42))));
        (*l_109) = (((0x6E38L & func_39((~p_82))) >= ((*l_109) <= g_88)) > (((*l_109) < ((uint16_t)0xAD79L * (uint16_t)(0x12D9L || ((uint16_t)g_42 - (uint16_t)p_86)))) > g_42));
        /* statement id: 74 */
        assert (g_44 == &g_42);
    }
    (*l_109) = 1L;
    return l_109;
    /* statement id: 77 */
    //assert (func_81_rv == &g_90);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_42, "g_42", print_hash_value);
    transparent_crc(g_46, "g_46", print_hash_value);
    transparent_crc(g_88, "g_88", print_hash_value);
    transparent_crc(g_90, "g_90", print_hash_value);
    transparent_crc(g_100, "g_100", print_hash_value);
    transparent_crc(g_127, "g_127", print_hash_value);
    transparent_crc(g_159, "g_159", print_hash_value);
    transparent_crc(g_171, "g_171", print_hash_value);
    transparent_crc(g_244, "g_244", print_hash_value);
    transparent_crc(g_245, "g_245", print_hash_value);
    transparent_crc(g_248, "g_248", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 66
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 20, occurrence: 1

XXX total number of pointers: 101

XXX times a variable address is taken: 93
XXX times a pointer is dereferenced on RHS: 45
breakdown:
   depth: 1, occurrence: 39
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 86
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 364

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 311
   level: 2, occurrence: 66
   level: 3, occurrence: 21
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 45
XXX number of pointers point to scalars: 56
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.7
XXX average alias set size: 1.26

XXX times a non-volatile is read: 258
XXX times a non-volatile is write: 183
XXX times a volatile is read: 21
XXX    times read thru a pointer: 4
XXX times a volatile is write: 13
XXX    times written thru a pointer: 2
XXX times a volatile is available for access: 77
XXX percentage of non-volatile access: 92.8

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 66
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 21
   depth: 2, occurrence: 13

XXX percentage a fresh-made variable is used: 18.6
XXX percentage an existing variable is used: 81.4
********************* end of statistics **********************/

