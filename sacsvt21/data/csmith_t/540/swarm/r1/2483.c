/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2923795802
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   const uint8_t  f1;
   uint16_t  f2;
   int8_t  f3;
   uint16_t  f4;
   uint8_t  f5;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_29(void);
inline static int32_t * func_30(float  p_31, int32_t * p_32, int32_t * p_33);
static int32_t * func_35(const int32_t * p_36, uint32_t  p_37);
static int32_t * func_38(uint32_t  p_39);
static float  func_40(uint32_t  p_41, uint16_t  p_42, int8_t  p_43, const int16_t  p_44, float  p_45);
inline static uint8_t  func_46(const int32_t * p_47, int32_t * p_48, int32_t * p_49, int8_t  p_50);
static int32_t * func_51(uint32_t  p_52, int32_t * p_53, uint32_t  p_54);
inline static uint8_t  func_59(uint16_t  p_60, const uint8_t  p_61, float  p_62, uint16_t  p_63, const uint32_t  p_64);
inline static int32_t  func_65(const float  p_66, const uint32_t  p_67, struct S0  p_68, const uint32_t  p_69);
static float  func_80(int32_t * p_81, uint8_t  p_82, float  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_29(void)
{ /* block id: 36 */
    int8_t l_34 = 0xFD;
    int32_t l_670 = 0;
    int32_t *l_669 = &l_670;
    int32_t **l_690 = &l_669;
    (*l_690) = func_30(l_34, func_35(func_38(((-1) & (l_34 <= 0x92))), l_34), l_669);
    for (l_34 = 0; (l_34 == 25); l_34 = safe_add_func_int16_t_s_s(l_34, 1))
    { /* block id: 394 */
        uint32_t l_693 = 0x0EA05DB0;
        uint8_t l_694 = 0xA3;
        l_694 = l_693;
        if ((l_670 != ((safe_rshift_func_uint8_t_u_s(l_694, 5)) < (l_693 >= (safe_add_func_uint8_t_u_u((safe_div_func_uint16_t_u_u(__builtin_ctzl(l_670), l_694)), 0xC7))))))
        { /* block id: 396 */
            uint8_t l_711 = 0x81;
            struct S0 ** const l_716 = (void*)0;
            float l_718 = 0x5.9p-1;
            float *l_717 = &l_718;
            (*l_717) = (safe_div_func_float_f_f((safe_add_func_float_f_f(((safe_div_func_float_f_f((safe_add_func_float_f_f(l_694, 0x3.376107p-91)), (l_711 >= (safe_div_func_float_f_f((safe_div_func_float_f_f((0x8.B3AE41p+95 != l_711), 0x9.1CF9E4p+25)), (l_716 == (void*)0)))))) > l_694), (-0x1.5p-1))), l_693));
        }
        else
        { /* block id: 398 */
            int32_t l_719 = 1;
            return l_719;
        }
    }
    return l_670;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_30(float  p_31, int32_t * p_32, int32_t * p_33)
{ /* block id: 386 */
    const int32_t *l_671 = (void*)0;
    int32_t l_673 = 0;
    int32_t *l_672 = &l_673;
    struct S0 l_674 = {0xFC8E2312,0x50,3U,-1,1U,8U};
    int16_t l_675 = 5;
    float l_677 = 0x1.9p-1;
    float *l_676 = &l_677;
    int32_t **l_689 = &l_672;
    int32_t ***l_688 = &l_689;
    (*l_676) = p_31;
    (*p_33) = (safe_lshift_func_int8_t_s_u(__builtin_ffsll(((((*l_672) != (safe_div_func_uint32_t_u_u((safe_lshift_func_uint8_t_u_s((((safe_lshift_func_uint8_t_u_s((*l_672), 5)) > ((-6) != func_65(((*l_672) != (safe_div_func_float_f_f(p_31, 0x4.4B5701p+93))), (*l_672), l_674, (*l_672)))) == 0x78), (*l_672))), (*p_33)))) && (*l_672)) == (*l_672))), (*l_672)));
    (*l_688) = &l_672;
    return p_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_35(const int32_t * p_36, uint32_t  p_37)
{ /* block id: 348 */
    uint8_t l_625 = 251U;
    float l_643 = 0x1.Ep-1;
    float *l_642 = &l_643;
    int32_t l_644 = 0;
    int32_t *l_668 = (void*)0;
    for (p_37 = 0; (p_37 > 32); ++p_37)
    { /* block id: 351 */
        uint32_t l_613 = 5U;
        const int32_t *l_617 = (void*)0;
        int32_t l_621 = (-7);
        int32_t *l_620 = &l_621;
        int32_t **l_624 = &l_620;
        int32_t ** const *l_623 = &l_624;
        int32_t ** const **l_622 = &l_623;
        float l_627 = (-0x7.9p+1);
        float *l_626 = &l_627;
        if (__builtin_bswap32(p_37))
        { /* block id: 352 */
            if (l_613)
                break;
        }
        else
        { /* block id: 354 */
            uint32_t l_616 = 0xDDB2AB74;
            int32_t l_619 = 0x29EB7519;
            int32_t *l_618 = &l_619;
            (*l_620) = (p_37 & (safe_div_func_uint16_t_u_u((p_37 == p_37), ((l_616 || l_625) ^ (*l_618)))));
        }
        (*l_626) = 0xD.62CBD8p+54;
    }
    for (l_625 = 0; (l_625 < 5); ++l_625)
    { /* block id: 361 */
        int16_t l_634 = 0xD9DA;
        l_644 = (safe_mod_func_int8_t_s_s((safe_rshift_func_int8_t_s_s(0xFD, 2)), (((((l_634 != p_37) || (((safe_unary_minus_func_int8_t_s((func_59(l_625, p_37, (safe_sub_func_float_f_f((safe_div_func_float_f_f(l_625, __builtin_parity(p_37))), (safe_div_func_float_f_f((l_642 == (void*)0), l_625)))), l_634, p_37) >= 1))) > 0x2ABC) | l_634)) || 3) != 0xFDB9) || p_37)));
    }
    for (l_644 = 0; (l_644 == 12); l_644 = safe_add_func_uint32_t_u_u(l_644, 9))
    { /* block id: 366 */
        for (p_37 = 0; (p_37 <= 34); p_37 = safe_add_func_uint32_t_u_u(p_37, 1))
        { /* block id: 369 */
            int32_t *l_653 = &l_644;
            int32_t l_655 = 4;
            int32_t *l_654 = &l_655;
            (*l_642) = 0x1.7p+1;
            (*l_654) = (safe_mod_func_int8_t_s_s((__builtin_ia32_crc32qi((safe_sub_func_int32_t_s_s(p_37, (*l_653))), p_37) < p_37), 0xEF));
        }
    }
    for (l_625 = (-21); (l_625 > 44); l_625 = safe_add_func_int8_t_s_s(l_625, 1))
    { /* block id: 376 */
        int32_t l_663 = 0x70C73C10;
        struct S0 l_664 = {0U,0U,0x107A,0x89,65530U,0xF1};
        for (l_644 = 0; (l_644 >= 8); l_644 = safe_add_func_int32_t_s_s(l_644, 1))
        { /* block id: 379 */
            uint32_t l_662 = 4294967294U;
            int32_t *l_665 = &l_663;
            (*l_665) = ((safe_add_func_uint16_t_u_u(l_662, ((((0xA98F >= __builtin_popcount(l_663)) == p_37) != __builtin_clzll(func_65(l_662, p_37, l_664, (((l_625 < 0x11E1) && p_37) > 9)))) == p_37))) ^ l_664.f2);
            l_663 = 0x3.3448D2p+20;
        }
        l_663 = ((safe_add_func_uint8_t_u_u(__builtin_ffsl(p_37), p_37)) | (__builtin_ffs(p_37) >= (p_36 != (void*)0)));
    }
    return l_668;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_38(uint32_t  p_39)
{ /* block id: 37 */
    int32_t l_56 = (-9);
    int32_t *l_55 = &l_56;
    struct S0 l_70 = {0xD479EA40,0x7B,1U,0x0C,65526U,0x63};
    int32_t *l_75 = &l_56;
    float l_571 = 0x3.625494p-51;
    float *l_609 = (void*)0;
    int32_t *l_610 = (void*)0;
    (*l_75) = func_40((func_46(func_51(p_39, l_55, (safe_mod_func_int16_t_s_s((((*l_55) == func_59((*l_55), (func_65(((void*)0 == &l_56), (*l_55), l_70, (safe_lshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_s(((void*)0 != l_75), (*l_75))), (*l_75)))) < 0x898AFBB1), (*l_55), (*l_55), p_39)) > 0x6C037735), 0xE036))), l_75, l_55, p_39) == p_39), p_39, p_39, p_39, p_39);
    return l_610;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_40(uint32_t  p_41, uint16_t  p_42, int8_t  p_43, const int16_t  p_44, float  p_45)
{ /* block id: 322 */
    int32_t l_573 = 3;
    int32_t *l_572 = &l_573;
    int32_t **l_574 = &l_572;
    int16_t l_593 = (-1);
    struct S0 l_595 = {0xC9471226,1U,65529U,0x27,65529U,7U};
    struct S0 *l_594 = &l_595;
    (*l_574) = func_51(p_43, l_572, (*l_572));
    p_45 = (safe_sub_func_float_f_f((*l_572), p_43));
    if ((safe_mod_func_uint8_t_u_u((**l_574), 0x62)))
    { /* block id: 325 */
        (*l_574) = (*l_574);
        for (l_573 = 27; (l_573 == 4); l_573 = safe_sub_func_int16_t_s_s(l_573, 5))
        { /* block id: 329 */
            int32_t l_582 = 1;
            int32_t *l_581 = &l_582;
            (*l_581) = (0x2400 >= (0x9265 ^ __builtin_clzl(p_43)));
        }
    }
    else
    { /* block id: 332 */
        const int32_t *l_592 = &l_573;
        struct S0 **l_596 = &l_594;
        uint8_t l_598 = 0x54;
        (*l_574) = func_51(p_44, (*l_574), (~((0xBD >= (safe_add_func_int16_t_s_s(((-7) || (safe_sub_func_uint32_t_u_u(((safe_sub_func_int16_t_s_s(p_41, (**l_574))) < p_41), ((safe_sub_func_uint16_t_u_u(l_593, 0x9F1F)) < 0x9F)))), p_42))) != (*l_592))));
        (*l_574) = (*l_574);
        (*l_596) = l_594;
        if ((4294967295U > (*l_572)))
        { /* block id: 336 */
            int32_t **l_597 = &l_572;
            (*l_574) = (void*)0;
            (*l_597) = l_592;
            return p_44;
        }
        else
        { /* block id: 340 */
            return l_598;
        }
    }
    (*l_572) = ((safe_mod_func_uint16_t_u_u(((safe_sub_func_int32_t_s_s(p_41, __builtin_parity(((p_41 && 0x50C9) | p_44)))) >= (safe_sub_func_uint32_t_u_u((safe_mod_func_uint8_t_u_u(p_44, (0U ^ (safe_div_func_int32_t_s_s(p_43, p_41))))), (*l_572)))), (*l_572))) && p_44);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_46(const int32_t * p_47, int32_t * p_48, int32_t * p_49, int8_t  p_50)
{ /* block id: 317 */
    const float l_552 = 0xB.1FE765p-18;
    const struct S0 l_554 = {0xE54BFEFC,250U,0xE875,0xD9,0x5D3D,0x35};
    const struct S0 *l_553 = &l_554;
    float l_556 = (-0x2.2p+1);
    float *l_555 = &l_556;
    (*p_49) = (*p_49);
    (*l_555) = ((void*)0 == l_553);
    (*p_49) = (safe_div_func_int32_t_s_s(((safe_div_func_uint16_t_u_u(l_554.f1, (safe_sub_func_uint32_t_u_u((safe_rshift_func_uint8_t_u_s(l_554.f4, 5)), (safe_lshift_func_uint8_t_u_s(255U, ((safe_sub_func_uint32_t_u_u(((1 & (l_554.f4 > 0xCA4F)) & (*p_47)), l_554.f2)) <= (safe_mod_func_int16_t_s_s(((0x50562DB6 >= l_554.f1) == p_50), (-5)))))))))) ^ l_554.f0), p_50));
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_51(uint32_t  p_52, int32_t * p_53, uint32_t  p_54)
{ /* block id: 270 */
    int32_t l_438 = 8;
    int32_t *l_437 = &l_438;
    const int32_t *l_440 = &l_438;
    const int32_t **l_439 = &l_440;
    int32_t **l_452 = &l_437;
    struct S0 l_472 = {0xC83CE190,246U,0xCF0D,0x39,0xDA64,0x13};
    uint32_t l_490 = 1U;
    uint8_t l_498 = 0x04;
    struct S0 *l_533 = &l_472;
    struct S0 **l_532 = &l_533;
    struct S0 ***l_531 = &l_532;
    (*l_439) = l_437;
    for (l_438 = 0; (l_438 < (-24)); l_438 = safe_sub_func_int8_t_s_s(l_438, 1))
    { /* block id: 274 */
        int32_t l_450 = 0x6725A7C1;
        int32_t l_471 = 0x8497B7C6;
        struct S0 * const *l_482 = (void*)0;
        struct S0 * const **l_481 = &l_482;
        uint32_t l_489 = 0x326D28A6;
        const int32_t **l_517 = (void*)0;
        int32_t ** const **l_527 = (void*)0;
        for (p_52 = (-2); (p_52 != 49); p_52 = safe_add_func_uint32_t_u_u(p_52, 1))
        { /* block id: 277 */
            int32_t *l_456 = &l_438;
            int16_t l_463 = 0xC017;
            float l_474 = 0x1.Ep+1;
            float *l_473 = &l_474;
        }
    }
    (*p_53) = 0x0D66F16D;
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_59(uint16_t  p_60, const uint8_t  p_61, float  p_62, uint16_t  p_63, const uint32_t  p_64)
{ /* block id: 51 */
    uint16_t l_106 = 0x14E9;
    struct S0 ***l_111 = (void*)0;
    int32_t l_147 = (-1);
    int32_t *l_146 = &l_147;
    int32_t l_189 = 0x2BF1337B;
    struct S0 l_268 = {4294967294U,0x1E,1U,6,65528U,0xAE};
    struct S0 *l_267 = &l_268;
    int32_t l_274 = 0x83BAE3D2;
    int32_t **l_345 = &l_146;
    int32_t ***l_344 = &l_345;
    int32_t **** const l_343 = &l_344;
    const int8_t l_351 = 8;
    int32_t * const ****l_381 = (void*)0;
    if ((__builtin_ffs(((l_106 ^ (safe_add_func_uint16_t_u_u(l_106, (-4)))) & 8U)) || (safe_mod_func_int8_t_s_s(((void*)0 != l_111), 0x34))))
    { /* block id: 52 */
        float l_114 = 0x1.Fp-1;
        int32_t l_115 = 0x01D5BC3F;
        struct S0 l_135 = {1U,0x08,1U,0x08,0xAC20,1U};
        const struct S0 *l_134 = &l_135;
        const struct S0 **l_133 = &l_134;
        int32_t *l_145 = &l_115;
        for (l_106 = 6; (l_106 <= 14); l_106 = safe_add_func_uint32_t_u_u(l_106, 1))
        { /* block id: 55 */
            uint32_t l_126 = 4294967289U;
            if ((p_64 || p_64))
            { /* block id: 56 */
                int32_t l_136 = 0;
                float * const l_139 = &l_114;
                if (l_115)
                    break;
                if (l_106)
                { /* block id: 58 */
                    const int32_t l_121 = 0xDCF8E450;
                    float *l_129 = &l_114;
                    struct S0 l_132 = {0xC7D23680,0U,0U,0,0xED88,0xAC};
                    struct S0 *l_131 = &l_132;
                    struct S0 **l_130 = &l_131;
                    int32_t *l_137 = (void*)0;
                    int32_t *l_138 = &l_136;
                    for (p_63 = 0; (p_63 != 1); p_63 = safe_add_func_int8_t_s_s(p_63, 1))
                    { /* block id: 61 */
                        int32_t *l_118 = &l_115;
                        p_62 = p_60;
                        (*l_118) = ((((1 && p_60) && __builtin_ctzll(p_61)) & p_61) | ((1 || p_64) == p_60));
                    }
                    (*l_138) = (safe_rshift_func_uint8_t_u_s(l_121, (safe_mod_func_uint32_t_u_u((p_60 == (l_126 != (safe_sub_func_uint32_t_u_u((((void*)0 != l_129) < (((((((l_130 == l_133) | l_135.f3) < (p_64 <= l_135.f1)) != l_135.f2) ^ l_135.f1) ^ l_136) | l_135.f5)), l_135.f1)))), 0xF772618A))));
                }
                else
                { /* block id: 66 */
                    int32_t *l_140 = &l_136;
                    (*l_140) = (l_139 == (void*)0);
                    if (l_126)
                        continue;
                    if (l_106)
                        continue;
                }
                if (p_61)
                    continue;
                return p_60;
            }
            else
            { /* block id: 73 */
                int32_t *l_141 = (void*)0;
                int32_t *l_142 = &l_115;
                (*l_142) = l_135.f2;
                p_62 = (safe_sub_func_float_f_f((0xF.09C2EEp-17 <= p_61), ((-0x1.8p+1) != l_135.f2)));
            }
        }
        l_145 = (void*)0;
    }
    else
    { /* block id: 79 */
        int32_t **l_148 = &l_146;
        int32_t l_169 = 8;
        struct S0 *l_171 = (void*)0;
        struct S0 * const *l_186 = &l_171;
        struct S0 * const **l_185 = &l_186;
        (*l_148) = l_146;
        for (l_147 = (-23); (l_147 < 9); l_147 = safe_add_func_int32_t_s_s(l_147, 3))
        { /* block id: 83 */
            int32_t **l_162 = (void*)0;
            int32_t l_166 = 0x60EE8D33;
            float l_199 = 0x2.110DD6p-97;
            struct S0 l_222 = {1U,0x32,0xB72E,8,0x47F3,250U};
            for (p_60 = (-25); (p_60 > 42); p_60 = safe_add_func_int32_t_s_s(p_60, 2))
            { /* block id: 86 */
                uint32_t l_153 = 0x8BB06C87;
                int32_t *l_154 = (void*)0;
                const int16_t l_173 = (-1);
            }
            for (l_222.f3 = (-13); (l_222.f3 >= 17); ++l_222.f3)
            { /* block id: 143 */
                uint16_t l_231 = 0xA7D4;
                float *l_232 = &l_199;
                (*l_232) = (p_62 != (((void*)0 == (*l_185)) < l_231));
            }
        }
    }
    if ((((*l_146) ^ (safe_mod_func_uint32_t_u_u((((((safe_lshift_func_int8_t_s_u((safe_sub_func_uint8_t_u_u(247U, (*l_146))), 2)) <= (safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(p_60, 12)), (safe_add_func_int8_t_s_s((safe_rshift_func_int8_t_s_s((*l_146), 1)), 0x88))))) | (*l_146)) && ((safe_add_func_uint8_t_u_u((*l_146), (*l_146))) <= (*l_146))) | 0xB99C00F1), 0x5A8BD48D))) <= (*l_146)))
    { /* block id: 148 */
        const int32_t ****l_249 = (void*)0;
        int32_t l_265 = 0;
        struct S0 *l_266 = (void*)0;
        if (((void*)0 != l_249))
        { /* block id: 149 */
            int32_t **l_253 = &l_146;
            int32_t ***l_252 = &l_253;
            int32_t ****l_251 = &l_252;
            int32_t *****l_250 = &l_251;
            (*l_250) = (void*)0;
        }
        else
        { /* block id: 151 */
            int32_t l_263 = 0x540276F7;
            int32_t **l_264 = &l_146;
            for (p_63 = (-2); (p_63 != 33); p_63 = safe_add_func_int32_t_s_s(p_63, 1))
            { /* block id: 154 */
                float *l_258 = (void*)0;
                float l_260 = 0xD.9DE11Bp-71;
                float *l_259 = &l_260;
                (*l_259) = (safe_div_func_float_f_f((-0x1.7p+1), __builtin_popcountl(p_64)));
                for (l_189 = 0; (l_189 != 24); ++l_189)
                { /* block id: 158 */
                    if (p_64)
                        break;
                    (*l_259) = p_64;
                    (*l_259) = l_263;
                    return p_60;
                }
            }
            (*l_264) = &l_147;
            l_265 = (*l_146);
        }
        l_267 = l_266;
    }
    else
    { /* block id: 169 */
        return p_60;
    }
    if ((*l_146))
    { /* block id: 172 */
lbl_292:
        (*l_146) = (*l_146);
    }
    else
    { /* block id: 174 */
        const int16_t l_275 = 0x7642;
        int8_t l_312 = 0x03;
        int32_t ***l_339 = (void*)0;
        int32_t ****l_338 = &l_339;
        int32_t *****l_337 = &l_338;
        struct S0 l_420 = {0xD0CA8F3B,0x88,0xF57A,4,0U,0x6D};
        int16_t l_436 = 0x221E;
        (*l_146) = ((*l_146) & (!(safe_lshift_func_uint8_t_u_s(6U, ((safe_rshift_func_uint8_t_u_u((l_274 != l_275), 4)) >= ((safe_add_func_uint32_t_u_u(p_63, ((*l_146) > p_60))) & (-5)))))));
        if ((safe_lshift_func_uint16_t_u_u((&l_189 == (void*)0), 12)))
        { /* block id: 176 */
            int32_t * const l_280 = &l_147;
            int32_t **l_281 = &l_146;
            (*l_281) = l_280;
        }
        else
        { /* block id: 178 */
            uint32_t l_284 = 1U;
            int32_t **l_332 = &l_146;
            int32_t ****l_342 = &l_339;
            int32_t **l_375 = &l_146;
            float l_377 = 0x4.022036p+7;
            float *l_376 = &l_377;
            struct S0 l_393 = {0x20C17890,0U,0x2586,0x30,0x174E,0x29};
            int32_t *l_400 = &l_189;
            for (l_189 = 12; (l_189 != 25); l_189 = safe_add_func_int16_t_s_s(l_189, 1))
            { /* block id: 181 */
                float l_286 = 0x1.Dp-1;
                float *l_285 = &l_286;
                struct S0 l_311 = {4U,0x98,0U,1,65534U,0x52};
                int32_t *l_330 = (void*)0;
                int32_t *****l_340 = &l_338;
                (*l_285) = (l_284 < (p_63 >= p_62));
                for (l_268.f2 = 5; (l_268.f2 > 23); ++l_268.f2)
                { /* block id: 185 */
                    float l_328 = (-0x3.Bp-1);
                    int32_t l_329 = 0;
                    int32_t * const *l_334 = &l_146;
                    int32_t * const **l_333 = &l_334;
                    if ((0 > (-9)))
                    { /* block id: 186 */
                        int32_t **l_289 = (void*)0;
                        int32_t **l_290 = (void*)0;
                        int32_t *l_291 = (void*)0;
                        l_291 = l_285;
                        if (p_60)
                            goto lbl_292;
                        (*l_291) = (safe_add_func_int8_t_s_s((~(safe_sub_func_uint8_t_u_u(((safe_sub_func_uint8_t_u_u(p_64, (l_284 > l_275))) || ((safe_div_func_int16_t_s_s(0x2393, (safe_sub_func_int32_t_s_s((safe_mod_func_int32_t_s_s((safe_mod_func_uint16_t_u_u((!func_65(p_62, p_61, l_311, p_61)), l_312)), p_63)), 0x9526B4DC)))) >= p_63)), p_60))), 0));
                        (*l_146) = ((safe_div_func_uint32_t_u_u(__builtin_ffsl(((p_63 < (p_64 >= (safe_div_func_uint16_t_u_u((safe_sub_func_int8_t_s_s(p_64, ((safe_unary_minus_func_int16_t_s((safe_sub_func_int32_t_s_s(p_63, (safe_sub_func_int32_t_s_s(((-7) | 0xE6A8), ((*l_146) | (p_63 || (safe_sub_func_int16_t_s_s((__builtin_parityll(((((safe_sub_func_int16_t_s_s((l_312 & (*l_146)), 0xFD02)) == (*l_291)) <= p_64) < 1)) < 1), l_329)))))))))) ^ p_60))), 0x2FC0)))) && (-1))), (*l_146))) < p_63);
                    }
                    else
                    { /* block id: 191 */
                        int32_t **l_331 = &l_330;
                        (*l_285) = p_61;
                        (*l_331) = l_330;
                        (*l_331) = l_330;
                    }
                    (*l_333) = l_332;
                }
                for (l_311.f5 = (-30); (l_311.f5 >= 2); l_311.f5 = safe_add_func_int16_t_s_s(l_311.f5, 1))
                { /* block id: 200 */
                    int32_t l_350 = 0xDB8DD240;
                    l_340 = l_337;
                    p_62 = ((-0x6.2p-1) < ((l_342 == l_343) < (((safe_sub_func_float_f_f((0x1.Bp+1 >= ((__builtin_parity(func_65((((p_61 > p_62) < (((safe_add_func_float_f_f(((*l_146) <= __builtin_popcount(l_350)), (**l_332))) < (****l_343)) > (**l_332))) < (****l_343)), p_63, l_311, l_351)) < (-0x6.5p+1)) <= 0x9.29E3FCp+1)), p_61)) <= (-0x7.Ep-1)) >= p_62)));
                }
            }
            if ((safe_add_func_uint16_t_u_u(p_60, (safe_add_func_int32_t_s_s(((~65530U) == ((safe_lshift_func_uint8_t_u_s(p_60, 2)) < p_64)), __builtin_ffsll(p_64))))))
            { /* block id: 205 */
                int32_t *l_363 = &l_189;
                int32_t *****l_391 = &l_342;
                struct S0 **l_394 = &l_267;
                (****l_343) = 0x7179A043;
                for (l_268.f5 = 0; (l_268.f5 == 23); l_268.f5 = safe_add_func_uint32_t_u_u(l_268.f5, 1))
                { /* block id: 209 */
                    (**l_344) = l_363;
                }
                if ((0xAD && 0))
                { /* block id: 212 */
                    struct S0 l_372 = {0xA6AD2B18,1U,2U,1,1U,0xBE};
                    (***l_343) = (*l_332);
                    for (l_147 = 21; (l_147 >= (-3)); l_147 = safe_sub_func_uint32_t_u_u(l_147, 3))
                    { /* block id: 216 */
                        (*l_363) = 0;
                    }
                    (*l_146) = ((safe_div_func_uint16_t_u_u(p_61, (safe_div_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u((p_60 > p_63), (func_65((*l_363), __builtin_parityll((*l_363)), l_372, p_64) && (**l_332)))) >= p_64), 8U)))) & (*l_363));
                }
                else
                { /* block id: 220 */
                    int32_t *****l_382 = &l_342;
                    int8_t l_403 = (-6);
                    for (l_268.f3 = 8; (l_268.f3 > (-2)); l_268.f3 = safe_sub_func_int16_t_s_s(l_268.f3, 2))
                    { /* block id: 223 */
                        (**l_343) = l_375;
                        (**l_345) = (l_376 == l_146);
                        if (l_268.f2)
                            goto lbl_401;
                    }
                    (*l_376) = (__builtin_ctzl(p_61) <= p_61);
                    if (((void*)0 != (**l_344)))
                    { /* block id: 228 */
                        struct S0 l_392 = {0x8605452B,0xE0,0U,0xC2,0x9C39,0U};
                        struct S0 ***l_395 = (void*)0;
                        struct S0 ***l_396 = &l_394;
                        int32_t *l_399 = &l_189;
                        (**l_375) = func_65((!func_65((safe_div_func_float_f_f((((l_381 == l_382) > (safe_add_func_float_f_f(((safe_sub_func_float_f_f((*l_363), ((safe_sub_func_float_f_f(p_61, ((safe_div_func_float_f_f(((l_391 == &l_343) < ((**l_345) < (**l_345))), p_64)) != (-0x1.8p-1)))) >= 0x8.73D8C0p-94))) != p_63), (*l_363)))) == p_62), p_63)), p_60, l_392, p_64)), p_64, l_393, p_63);
                        (*l_396) = l_394;
                        (*l_363) = (safe_div_func_int32_t_s_s((l_392.f3 <= p_61), 0x713395F3));
                        l_399 = (***l_343);
                    }
                    else
                    { /* block id: 233 */
                        (*l_332) = (*l_332);
lbl_401:
                        (***l_343) = l_400;
                        (**l_344) = (*l_345);
                        (*l_376) = (!l_403);
                    }
                }
            }
            else
            { /* block id: 241 */
                int8_t l_411 = 0x2E;
                int32_t *l_415 = (void*)0;
                struct S0 l_421 = {0xCD5BE581,0x16,0x5E0B,0xF4,0xADA6,0xF6};
                (*l_376) = (0x0.8p-1 != (!p_61));
                (***l_344) = (safe_mod_func_int16_t_s_s(func_65(((safe_div_func_float_f_f(p_61, (((func_65((safe_add_func_float_f_f((l_411 == l_411), (safe_add_func_float_f_f((p_61 >= (!0xC.AF3E0Fp+12)), func_80(l_415, (safe_mod_func_int32_t_s_s(p_61, __builtin_ctzll(((**l_375) && (safe_rshift_func_uint8_t_u_s(p_63, 7)))))), l_411))))), p_63, l_420, (*l_400)) < p_63) < 0xA.CF4CB1p+25) <= (**l_332)))) != p_61), (*l_146), l_421, p_64), (**l_332)));
                (**l_332) = (-3);
            }
            for (p_63 = 0; (p_63 > 17); p_63 = safe_add_func_uint32_t_u_u(p_63, 1))
            { /* block id: 248 */
                (***l_344) = p_60;
            }
            for (l_268.f2 = 0; (l_268.f2 == 50); ++l_268.f2)
            { /* block id: 253 */
                uint16_t l_426 = 65533U;
                int32_t *l_434 = (void*)0;
                uint8_t l_435 = 0x3A;
                if ((l_426 | (-6)))
                { /* block id: 254 */
                    int32_t l_427 = 1;
                    return l_427;
                }
                else
                { /* block id: 256 */
                    uint32_t l_432 = 4294967289U;
                    if (((safe_div_func_int32_t_s_s((((0x81015B2B != l_432) && ((-1) < (__builtin_ia32_crc32qi((**l_345), p_60) == p_64))) ^ ((__builtin_ia32_crc32qi((!0x3A), p_64) & p_60) == p_61)), 1U)) <= l_426))
                    { /* block id: 257 */
                        return l_426;
                    }
                    else
                    { /* block id: 259 */
                        (***l_343) = l_434;
                        (*l_400) = (l_435 | 0x24);
                        (*l_376) = ((l_436 != 0x9.Fp-1) > p_63);
                    }
                    return p_64;
                }
            }
        }
    }
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_65(const float  p_66, const uint32_t  p_67, struct S0  p_68, const uint32_t  p_69)
{ /* block id: 38 */
    int16_t l_76 = (-5);
    int32_t l_85 = 0xD63F7CEC;
    int32_t *l_84 = &l_85;
    float l_98 = 0x1.4p+1;
    float *l_97 = &l_98;
    struct S0 l_103 = {4294967292U,255U,6U,-9,0xF02C,254U};
    struct S0 *l_102 = &l_103;
    struct S0 **l_101 = &l_102;
    int32_t **l_105 = &l_84;
    (*l_97) = (l_76 != (!(safe_div_func_float_f_f((l_76 != func_80(l_84, p_69, ((0x1.0p-1 == (safe_add_func_float_f_f(0x0.7p-1, ((*l_84) >= p_66)))) > (__builtin_ctzl((*l_84)) >= 0x9.69E96Cp-21)))), p_68.f5))));
    for (p_68.f0 = (-3); (p_68.f0 >= 42); ++p_68.f0)
    { /* block id: 46 */
        struct S0 ***l_104 = &l_101;
        (*l_104) = l_101;
    }
    (*l_105) = &l_85;
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_80(int32_t * p_81, uint8_t  p_82, float  p_83)
{ /* block id: 39 */
    int32_t l_89 = 0xD77138BF;
    int32_t * const l_88 = &l_89;
    int32_t **l_90 = (void*)0;
    int32_t **l_91 = (void*)0;
    int32_t *l_93 = (void*)0;
    int32_t **l_92 = &l_93;
    struct S0 l_95 = {1U,1U,0xBE16,4,65535U,1U};
    struct S0 *l_94 = &l_95;
    struct S0 **l_96 = &l_94;
    (*l_92) = l_88;
    (*l_96) = l_94;
    return p_82;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 139
   depth: 1, occurrence: 14
XXX total union variables: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 166
   depth: 2, occurrence: 41
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 3
   depth: 9, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 3
   depth: 26, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 160

XXX times a variable address is taken: 128
XXX times a pointer is dereferenced on RHS: 120
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 25
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 99
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 6
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 337

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 221
   level: 2, occurrence: 66
   level: 3, occurrence: 17
   level: 4, occurrence: 22
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 71
XXX number of pointers point to scalars: 79
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 31.2
XXX average alias set size: 1.13

XXX times a non-volatile is read: 815
XXX times a non-volatile is write: 273
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 157
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 38
   depth: 1, occurrence: 26
   depth: 2, occurrence: 25
   depth: 3, occurrence: 20
   depth: 4, occurrence: 23
   depth: 5, occurrence: 25

XXX percentage a fresh-made variable is used: 20.3
XXX percentage an existing variable is used: 79.7
********************* end of statistics **********************/

