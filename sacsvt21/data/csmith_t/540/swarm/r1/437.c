/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --no-pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      417451938
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   const uint32_t  f1;
   unsigned f2 : 23;
   uint32_t  f3;
   signed f4 : 23;
   signed f5 : 18;
   const float  f6;
   int16_t  f7;
   int16_t  f8;
   int32_t  f9;
};

struct S1 {
   signed f0 : 1;
   signed f1 : 24;
   signed f2 : 16;
   struct S0  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_29(void);
static uint32_t  func_48(uint16_t  p_49, uint32_t  p_50, int16_t  p_51, uint16_t  p_52);
static uint32_t  func_56(struct S1  p_57, struct S0  p_58, struct S0  p_59, const uint8_t  p_60, uint16_t  p_61);
static struct S0  func_63(uint16_t  p_64);
static const float  func_82(uint16_t  p_83, uint32_t  p_84, const uint32_t  p_85, uint32_t  p_86);
static int32_t  func_93(float  p_94, float  p_95, int16_t  p_96, const uint8_t  p_97, int32_t  p_98);
static int32_t  func_104(uint32_t  p_105, int32_t  p_106, uint32_t  p_107, int16_t  p_108, float  p_109);
static int16_t  func_115(struct S1  p_116, int16_t  p_117, uint32_t  p_118, float  p_119);
static float  func_121(int32_t  p_122, uint8_t  p_123, uint8_t  p_124, uint16_t  p_125);
static int16_t  func_140(struct S0  p_141, const uint32_t  p_142, const int16_t  p_143, int16_t  p_144);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_29(void)
{ /* block id: 36 */
    int32_t l_30 = 0xA5EA964A;
    uint8_t l_35 = 0x21;
    int32_t l_36 = 0xD2044653;
    struct S1 l_62 = {0,1878,104,{-1,4294967287U,410,0x92EDCDDC,2493,269,0xF.BFBD42p+81,0x32B8,0x468F,-1}};
    struct S0 l_963 = {2,0xC75A444D,1719,4294967295U,2200,-203,0xA.662BABp+77,-1,9,0xB9D8365A};
    for (l_30 = 0; (l_30 < 6); l_30 += 1)
    { /* block id: 39 */
        int32_t l_33 = 1;
        float l_39 = 0x4.8E60D7p-47;
        l_33 = ((l_33 < l_33) <= (-(float)l_30));
        l_36 = l_35;
        l_33 = (l_36 | (((uint32_t)(l_30 | ((int32_t)l_35 / (int32_t)(-7))) - (uint32_t)__builtin_popcountll((((uint32_t)((int16_t)(1U && (l_30 >= ((((uint16_t)((((func_48(__builtin_parityl(__builtin_parityl((-(uint32_t)((int16_t)l_33 << (int16_t)(func_56(l_62, func_63(l_33), l_963, l_33, l_33) < l_33))))), l_62.f3.f8, l_33, l_62.f1) || l_33) && 5U) && l_62.f3.f1) < l_62.f3.f1) << (uint16_t)l_62.f3.f1) < l_33) & l_963.f5))) - (int16_t)l_62.f2) - (uint32_t)l_30) != l_62.f3.f2))) >= l_33));
    }
    l_30 = ((int16_t)(((uint32_t)((l_62.f3.f3 | l_62.f3.f8) < l_963.f5) % (uint32_t)l_963.f9) && 0x4112426A) + (int16_t)l_963.f2);
    return l_62.f3.f8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_48(uint16_t  p_49, uint32_t  p_50, int16_t  p_51, uint16_t  p_52)
{ /* block id: 413 */
    float l_1004 = 0x5.1E53BCp-94;
    int32_t l_1005 = 0xAD458953;
    uint32_t l_1006 = 0xEEBFA17F;
    int16_t l_1007 = (-1);
    struct S0 l_1008 = {0,0x8F9A5B9E,2212,0x3A347288,2455,-426,0x1.0p-1,3,2,0x98FCFB8C};
    l_1005 = (((int16_t)(((uint32_t)((int16_t)((uint32_t)l_1005 + (uint32_t)(__builtin_popcount(p_49) < p_52)) / (int16_t)(l_1006 && p_52)) / (uint32_t)((l_1007 <= ((func_140(l_1008, (((int32_t)((int32_t)(((int32_t)(l_1008.f7 && 0U) % (int32_t)l_1007) == 0x28CC1D01) - (int32_t)0U) % (int32_t)4294967289U) ^ l_1008.f2), p_50, p_49) && p_49) < l_1006)) && 0x0253)) || l_1008.f4) >> (int16_t)l_1008.f3) > l_1006);
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_56(struct S1  p_57, struct S0  p_58, struct S0  p_59, const uint8_t  p_60, uint16_t  p_61)
{ /* block id: 402 */
    int32_t l_965 = 0x48A1E6BA;
    int32_t l_966 = 0x755AED90;
    if ((p_57.f3.f5 <= ((+l_965) || l_965)))
    { /* block id: 403 */
        uint32_t l_975 = 1U;
        int32_t l_982 = 0;
        l_966 = p_57.f2;
        l_982 = (((int16_t)__builtin_clz(p_59.f2) << (int16_t)p_59.f3) && ((int32_t)(65535U == ((int16_t)(func_115(p_57, (l_965 >= (((int32_t)(0x0FDD6180 && l_975) % (int32_t)((int16_t)((int16_t)((uint16_t)l_975 >> (uint16_t)14) / (int16_t)0xAE5F) - (int16_t)(-1))) & 0xB896A439)), l_966, l_975) | p_60) >> (int16_t)l_966)) - (int32_t)l_975));
    }
    else
    { /* block id: 406 */
        uint32_t l_983 = 0U;
        int32_t l_984 = 0;
        l_984 = l_983;
        l_984 = (__builtin_popcount(l_966) < l_965);
        l_966 = ((int32_t)(func_93(p_57.f3.f6, p_58.f4, (((uint16_t)p_57.f3.f3 >> (uint16_t)8) & (~((uint32_t)((int16_t)((p_57.f3.f4 > 0x2F1FDAA5) & l_965) >> (int16_t)0) - (uint32_t)((uint16_t)((p_59.f0 < (9U < l_983)) == l_966) / (uint16_t)p_57.f3.f3)))), p_59.f2, l_984) ^ l_984) - (int32_t)l_984);
        return l_983;
    }
    return l_966;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_63(uint16_t  p_64)
{ /* block id: 42 */
    int32_t l_77 = 0;
    int32_t l_654 = 0xEEE257C0;
    uint16_t l_673 = 6U;
    struct S0 l_685 = {-1,0x3D71C867,1677,0xEEDA162A,2820,-373,0xF.E5542Dp-77,1,1,0xA5333A9C};
    uint16_t l_708 = 1U;
    struct S1 l_716 = {0,-2670,-91,{7,4294967288U,2818,0x8FC01245,2751,-426,-0x1.Dp-1,0xF42E,-3,0xC828B80C}};
    const int32_t l_726 = (-1);
    const int32_t l_836 = 0x2EB2826D;
    const uint16_t l_933 = 65534U;
    for (p_64 = (-10); (p_64 < 6); p_64++)
    { /* block id: 45 */
        int32_t l_67 = 1;
        int32_t l_659 = (-3);
        int32_t l_666 = 0xDC5444BF;
        uint8_t l_717 = 255U;
        float l_747 = 0x3.E23087p-31;
        struct S1 l_876 = {-0,1588,125,{0x22B07C32,4294967295U,2313,0x1D7D3781,2505,439,0x3.991B76p-1,-7,1,0xFA0726F3}};
        for (l_67 = 0; (l_67 >= 19); l_67++)
        { /* block id: 48 */
            uint16_t l_87 = 0x57E6;
            l_654 = ((float)0x1.4p-1 + (float)((float)((float)0x3.C6C423p-4 / (float)(l_67 <= (+(l_77 <= (p_64 == ((((((((float)((float)(((func_82(l_87, (~p_64), (p_64 <= (((((int16_t)l_77 % (int16_t)(-1)) | p_64) == l_77) || l_87)), p_64) == l_67) < l_77) != l_67) - (float)l_67) + (float)l_77) > 0x8.Dp-1) != l_77) == 0xD.8784B8p-96) >= l_67) != p_64) >= l_67)))))) + (float)p_64));
            l_659 = (func_93((p_64 != l_654), l_87, ((int16_t)(0x0302 ^ l_654) << (int16_t)15), l_77, l_77) && (((uint16_t)(l_87 <= p_64) << (uint16_t)l_87) > 0x0502C387));
        }
        if (p_64)
        { /* block id: 296 */
            struct S0 l_660 = {7,0x664745B9,1433,9U,2413,-223,0xA.B97ED7p-56,0x2C74,1,1};
            struct S1 l_663 = {0,-3679,-144,{0x07BFAE4F,0x81AB7A69,652,0xAC9AED5A,-1905,27,-0x3.7p-1,1,0xC132,1}};
            uint32_t l_684 = 0x3D96E772;
            l_663.f3.f4 = __builtin_parityl(func_140(l_660, (((uint16_t)(p_64 | ((func_115(l_663, l_67, ((int32_t)l_666 + (int32_t)((int16_t)((1 || ((int16_t)l_654 >> (int16_t)5)) == p_64) >> (int16_t)0)), ((float)l_67 / (float)l_673)) == l_673) != p_64)) >> (uint16_t)l_67) != p_64), l_77, l_663.f3.f8));
            if (func_104(l_654, (l_666 != p_64), __builtin_popcountl(((uint32_t)(~((int16_t)(((uint32_t)((int32_t)(0x1B991BE7 <= (((+(p_64 == l_684)) || (p_64 & 0)) && l_673)) % (int32_t)l_663.f3.f2) + (uint32_t)(-10)) > l_663.f3.f3) % (int16_t)0xC765)) + (uint32_t)p_64)), l_660.f9, p_64))
            { /* block id: 298 */
                uint16_t l_695 = 2U;
                int32_t l_709 = 0;
                if (((p_64 | (-5)) ^ func_140(l_685, ((0xD293 <= 0x17B7) & ((int16_t)((p_64 <= l_663.f3.f9) > p_64) >> (int16_t)1)), ((-(int16_t)l_663.f3.f5) ^ 0xD9FE), p_64)))
                { /* block id: 299 */
                    uint32_t l_689 = 0x69667A9E;
                    l_689 = 0xC.DD9EDCp+38;
                    l_67 = (((int32_t)((!8) & l_689) + (int32_t)p_64) ^ ((uint16_t)l_666 >> (uint16_t)1));
                    l_709 = (0xF1CF010D == (p_64 != (l_695 | (l_695 & __builtin_ctzl(((uint32_t)(((int16_t)((int16_t)((int32_t)0 + (int32_t)(l_685.f1 >= 0xF0999442)) - (int16_t)l_695) + (int16_t)((int16_t)((uint16_t)l_666 << (uint16_t)8) + (int16_t)0xC6F9)) == l_708) - (uint32_t)l_695))))));
                    for (l_684 = 19; (l_684 == 42); l_684 += 8)
                    { /* block id: 305 */
                        uint16_t l_712 = 0xBC01;
                        struct S0 l_713 = {6,0xFC73391C,1218,0xF61CFCEF,-2779,107,0xE.9AF835p-90,2,0x416E,0};
                        l_712 = p_64;
                        return l_713;
                    }
                }
                else
                { /* block id: 309 */
                    uint8_t l_723 = 0U;
                    for (l_666 = (-4); (l_666 >= (-20)); l_666 -= 5)
                    { /* block id: 312 */
                        int32_t l_720 = 0x934DEA91;
                        l_654 = p_64;
                        l_660.f4 = func_115(l_716, l_67, l_717, (((((float)p_64 + (float)(__builtin_ctzll(p_64) != (((p_64 == l_720) == ((float)0x8.E10E6Bp-2 + (float)l_673)) == l_723))) >= 0x0.1p-1) <= l_659) > p_64));
                        l_709 = l_660.f9;
                    }
                    if (p_64)
                        break;
                }
                l_685.f5 = (((+l_685.f3) != func_121((+l_726), (((int16_t)(~(p_64 > __builtin_bswap32(p_64))) >> (int16_t)((uint16_t)((int16_t)((uint16_t)((uint32_t)(l_709 < ((uint16_t)(((uint16_t)0x7FFE << (uint16_t)(__builtin_bswap64(((int16_t)(!1U) / (int16_t)0x1D6A)) || l_659)) <= l_709) >> (uint16_t)2)) + (uint32_t)l_685.f7) % (uint16_t)p_64) << (int16_t)l_659) % (uint16_t)0x8390)) | 0x0756C575), l_660.f9, p_64)) < l_716.f1);
            }
            else
            { /* block id: 320 */
                l_663.f2 = (((p_64 <= 0x1681) == l_666) <= l_685.f0);
            }
            l_716.f3.f5 = (l_717 < func_93(p_64, l_67, p_64, p_64, (0xEB218753 | (((uint16_t)(p_64 || l_663.f3.f5) >> (uint16_t)12) < func_104(p_64, l_666, p_64, p_64, l_747)))));
        }
        else
        { /* block id: 324 */
            int16_t l_765 = 0x254D;
            int32_t l_766 = (-1);
            int16_t l_847 = 0x9D4E;
            uint8_t l_850 = 0xE4;
            uint32_t l_884 = 0xC6399717;
            struct S0 l_924 = {0x7CC353EE,0x7DFB87F4,1756,4294967295U,44,108,0x0.687002p+79,0x5E44,0x3794,0};
            for (l_716.f3.f3 = 0; (l_716.f3.f3 < 50); l_716.f3.f3++)
            { /* block id: 327 */
                int16_t l_758 = (-1);
                int32_t l_767 = 0x4ECB0395;
                uint32_t l_818 = 0x217FBE71;
                for (l_685.f9 = (-9); (l_685.f9 < 12); l_685.f9 += 1)
                { /* block id: 330 */
                    int32_t l_768 = (-1);
                    for (l_685.f7 = 8; (l_685.f7 <= (-7)); l_685.f7 -= 9)
                    { /* block id: 333 */
                        int32_t l_761 = (-6);
                        l_766 = ((0xA678845A & (((uint16_t)(((uint32_t)l_758 + (uint32_t)((int16_t)l_761 << (int16_t)13)) ^ (((int16_t)p_64 << (int16_t)(0xE102F7C9 != l_716.f3.f1)) >= l_659)) % (uint16_t)p_64) >= (+l_765))) | p_64);
                        l_767 = p_64;
                        l_766 = (-1);
                        if (l_654)
                            continue;
                    }
                    if (l_768)
                        continue;
                }
                if (l_765)
                { /* block id: 341 */
                    float l_784 = (-0x1.Bp+1);
                    int32_t l_785 = 1;
                    l_767 = ((int32_t)(((-(int16_t)(func_104(((int32_t)(((uint32_t)(((int16_t)((((((+(!l_765)) < p_64) && (p_64 | l_758)) < ((uint32_t)(((((((-1) > (0xD95E <= ((uint32_t)4294967295U / (uint32_t)p_64))) & (l_765 != l_758)) >= 0xA11F) & l_67) | p_64) >= p_64) - (uint32_t)l_67)) > p_64) < (-1)) >> (int16_t)p_64) >= l_685.f4) % (uint32_t)l_765) && l_716.f3.f3) + (int32_t)l_766), p_64, p_64, p_64, l_785) == l_685.f0)) <= p_64) >= 1U) / (int32_t)p_64);
                    l_767 = (-0x1.6p+1);
                    if (((l_717 != (((uint16_t)((uint32_t)((l_765 | p_64) > 0x4A2F) % (uint32_t)l_67) << (uint16_t)((p_64 || (0x9C14C707 == (+((int32_t)0xDC65D68E - (int32_t)(0x49B9 >= 0x31F3))))) ^ l_765)) || l_685.f1)) != p_64))
                    { /* block id: 344 */
                        float l_801 = (-0x1.8p+1);
                        int32_t l_810 = (-1);
                        l_766 = ((float)((float)(-0x9.0p-1) + (float)(((float)l_801 - (float)((float)(0xF.1A8732p+1 != (p_64 == l_767)) / (float)(0x8.Cp+1 >= ((float)(p_64 == ((float)0x3.7FF9CEp+68 + (float)((float)p_64 + (float)p_64))) - (float)0x3.6F51A3p+46)))) == p_64)) / (float)p_64);
                        l_810 = p_64;
                    }
                    else
                    { /* block id: 347 */
                        uint32_t l_813 = 0U;
                        l_785 = ((float)l_813 - (float)((float)(((float)(func_104(l_818, l_717, ((uint16_t)((uint16_t)(l_716.f2 && (((uint16_t)((int16_t)((uint32_t)func_93((+((float)((-(float)((!((l_685.f2 < l_758) >= ((float)p_64 + (float)0xF.D48193p+84))) <= (0x6.491730p+38 >= 0xD.FF97AAp+96))) <= l_716.f3.f8) - (float)l_716.f3.f5)), p_64, p_64, l_836, p_64) % (uint32_t)l_785) >> (int16_t)l_766) % (uint16_t)p_64) >= l_785)) << (uint16_t)l_717) >> (uint16_t)l_766), p_64, l_717) != 0xC.C97EDBp+48) + (float)p_64) <= (-0x4.Ep-1)) + (float)l_767));
                    }
                    l_785 = 0x8.A433C1p+48;
                }
                else
                { /* block id: 351 */
                    const uint8_t l_862 = 6U;
                    struct S1 l_873 = {-0,-3329,95,{0x60B09C2F,1U,408,0xDE2DB677,-824,480,0x2.21DE5Bp+27,-4,0x745E,8}};
                    l_766 = ((float)(-0x5.5p-1) - (float)(((p_64 > ((float)p_64 + (float)((float)p_64 + (float)((float)(p_64 < p_64) - (float)(((float)l_847 / (float)0x8.A62202p-77) != p_64))))) != 0x6.A9C2C1p+96) <= p_64));
                    for (l_77 = 0; (l_77 <= 0); l_77++)
                    { /* block id: 355 */
                        uint8_t l_851 = 0x73;
                        l_716.f1 = l_850;
                        l_67 = p_64;
                        l_766 = ((l_851 ^ ((int16_t)((uint32_t)p_64 % (uint32_t)((uint32_t)p_64 + (uint32_t)((func_93(l_767, ((float)(((float)(l_862 == p_64) + (float)((float)((float)((float)(((-0x1.7p+1) < ((((p_64 == (((float)p_64 - (float)0x1.2p+1) < l_862)) == l_767) != p_64) != p_64)) != p_64) - (float)l_851) + (float)(-0x7.4p-1)) / (float)0x0.6p-1)) == l_685.f4) + (float)0x0.9p+1), l_67, p_64, l_851) || p_64) || 4))) - (int16_t)p_64)) ^ p_64);
                        l_766 = ((float)0xC.A65A9Dp-83 / (float)func_115(l_873, __builtin_bswap64(l_851), l_851, ((float)func_115(l_876, p_64, (l_766 >= ((uint16_t)(l_818 == l_765) << (uint16_t)p_64)), l_876.f3.f3) - (float)(-0x2.8p+1))));
                    }
                    l_767 = ((+p_64) & 0x168C);
                    l_884 = (l_873.f2 != (p_64 >= ((float)((float)(0xD.DDD68Bp-16 > p_64) - (float)0xC.5F58E5p+87) / (float)p_64)));
                }
                if (((uint16_t)(l_758 && ((int16_t)l_850 >> (int16_t)((int16_t)l_876.f3.f9 % (int16_t)(0x0CBB0609 | 1U)))) / (uint16_t)(0xA525 | 0xF52B)))
                { /* block id: 364 */
                    const int16_t l_902 = 8;
                    l_766 = p_64;
                    if (l_716.f3.f1)
                        break;
                    for (l_758 = 0; (l_758 == 17); l_758++)
                    { /* block id: 369 */
                        uint32_t l_903 = 0x6DB719DA;
                        l_766 = ((uint32_t)((int16_t)(l_758 || (p_64 >= ((+p_64) <= (9 & func_93(l_847, ((float)l_876.f3.f4 + (float)p_64), l_876.f3.f5, l_902, l_903))))) << (int16_t)12) % (uint32_t)p_64);
                    }
                }
                else
                { /* block id: 372 */
                    struct S0 l_916 = {0x1C4D0CDE,0x56B0884B,2398,4294967295U,-1072,-228,0xF.6D73E3p+66,0xDE63,-1,2};
                    struct S1 l_934 = {-0,-1157,185,{0x42B31332,4294967286U,1471,1U,-2892,317,0x9.A87D88p+25,-1,0x42AE,-9}};
                    l_716.f3.f4 = (l_717 | ((((4294967295U != ((uint16_t)0U + (uint16_t)l_836)) >= __builtin_bswap64(((uint16_t)l_765 + (uint16_t)((int32_t)func_140(l_876.f3, ((int32_t)p_64 / (int32_t)((int16_t)0xA1DD << (int16_t)3)), l_765, p_64) - (int32_t)0xE707C4F0)))) && p_64) > 0xE91BBA01));
                    if ((((uint16_t)func_140(l_916, (((int16_t)p_64 << (int16_t)13) | 0xBC5FE408), (((+(l_916.f1 || p_64)) | func_104(((uint16_t)((uint32_t)func_104(func_140(l_924, l_767, __builtin_clzll(((uint16_t)((int16_t)((((int32_t)0xAD965040 / (int32_t)((int16_t)(func_93(p_64, l_765, p_64, l_933, p_64) < p_64) % (int16_t)p_64)) ^ p_64) & l_924.f3) / (int16_t)l_758) << (uint16_t)p_64)), p_64), l_847, p_64, p_64, l_836) - (uint32_t)0x1D9A5D94) - (uint16_t)0xDA75), l_716.f3.f2, p_64, p_64, p_64)) <= 0xC065), l_916.f2) + (uint16_t)0x6EDF) > 0x497D))
                    { /* block id: 374 */
                        int32_t l_935 = 1;
                        l_766 = func_115(l_934, (l_716.f0 >= p_64), l_935, __builtin_clz(((uint16_t)0x72CB << (uint16_t)10)));
                    }
                    else
                    { /* block id: 376 */
                        struct S0 l_938 = {9,3U,21,9U,-29,-106,0xD.595578p+87,-1,0xB417,-1};
                        l_659 = (0x193E72F5 || func_140(l_938, l_77, (0xB49D || l_766), p_64));
                        l_938.f5 = l_884;
                    }
                }
            }
            l_766 = ((((float)((float)0x0.5p-1 / (float)p_64) + (float)p_64) >= (l_716.f3.f5 < 0x0.Bp-1)) >= 0x9.8A05AEp+37);
            l_876.f3.f4 = (~l_685.f1);
            for (l_685.f8 = 0; (l_685.f8 == 28); l_685.f8 += 1)
            { /* block id: 386 */
                struct S0 l_950 = {1,0U,457,4294967292U,1230,343,0xA.CCC746p+94,0x5C44,-5,-1};
                l_654 = l_884;
                l_716.f3.f5 = 0x6.Dp+1;
                for (l_924.f9 = (-4); (l_924.f9 != (-25)); l_924.f9 -= 7)
                { /* block id: 391 */
                    float l_948 = (-0x1.Ep+1);
                    int32_t l_949 = 1;
                    if (l_949)
                        break;
                    l_924.f4 = l_924.f1;
                }
                l_766 = func_82(func_140(l_950, p_64, func_93(l_876.f3.f8, p_64, p_64, (((int16_t)p_64 << (int16_t)5) ^ ((uint32_t)(p_64 < func_104(((l_950.f9 <= (((((int16_t)((int16_t)(((uint16_t)(p_64 > p_64) + (uint16_t)0x6B95) >= 0x1CD00C74) >> (int16_t)p_64) + (int16_t)l_685.f2) | p_64) == l_950.f3) >= p_64)) | l_716.f3.f7), p_64, l_924.f1, p_64, l_950.f5)) % (uint32_t)1)), l_659), p_64), p_64, p_64, p_64);
            }
        }
        l_67 = ((int16_t)p_64 + (int16_t)1);
    }
    l_716.f3.f4 = l_716.f3.f9;
    return l_685;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_82(uint16_t  p_83, uint32_t  p_84, const uint32_t  p_85, uint32_t  p_86)
{ /* block id: 49 */
    uint32_t l_91 = 4294967290U;
    int32_t l_92 = 0x4AC9AC80;
    l_92 = l_91;
    l_92 = func_93(l_92, l_92, l_92, p_84, l_91);
    l_92 = 0;
    l_92 = ((((float)0x7.60BE88p+13 / (float)l_92) <= ((float)__builtin_ffsl(l_92) + (float)((func_104(l_91, ((l_92 >= p_84) != ((func_93((p_84 > l_91), l_91, l_92, l_92, p_85) | l_92) < 0U)), p_83, l_92, l_91) == l_91) < 0x2.DB2DB6p+85))) == l_91);
    return l_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_93(float  p_94, float  p_95, int16_t  p_96, const uint8_t  p_97, int32_t  p_98)
{ /* block id: 51 */
    uint32_t l_103 = 3U;
    uint8_t l_112 = 255U;
    struct S1 l_120 = {0,2424,-74,{0x0DB06F5C,0xCD63D7C5,415,0x7B865DB3,-1048,346,0x0.9p+1,0x85B7,0x5D82,1}};
    int32_t l_251 = 0x699311DF;
    int32_t l_267 = 0;
    int32_t l_304 = 0x05BCD4A8;
    int32_t l_322 = (-2);
    uint32_t l_330 = 0x924F2385;
    int16_t l_335 = 0x7FA2;
    const uint32_t l_362 = 0x316CF73F;
    float l_561 = 0x1.Ep+1;
    int32_t l_575 = 0x4D51D867;
    if ((__builtin_bswap64(p_97) >= ((uint32_t)((uint32_t)l_103 % (uint32_t)func_104(((int16_t)(l_112 < __builtin_clzll(l_103)) - (int16_t)((int16_t)func_115(l_120, (0 ^ 0xE46079F8), p_98, l_120.f3.f5) - (int16_t)l_120.f3.f9)), l_103, l_120.f3.f4, l_120.f3.f4, l_120.f3.f0)) / (uint32_t)l_120.f3.f9)))
    { /* block id: 106 */
        uint32_t l_230 = 0x1BB3FC7F;
        struct S1 l_297 = {-0,-2809,-248,{0xE6060EF3,0U,1046,0x62126B8E,2613,41,0x6.6468F9p-37,1,0x506C,-1}};
        float l_336 = 0x1.4p-1;
        if (((int16_t)(0U & __builtin_parityll(p_97)) - (int16_t)(l_230 ^ l_230)))
        { /* block id: 107 */
            float l_242 = (-0x1.4p-1);
            uint32_t l_243 = 4294967295U;
            int32_t l_244 = 1;
            if (p_96)
            { /* block id: 108 */
                float l_235 = 0x0.89F278p-79;
                int32_t l_252 = 0xDE541012;
                for (l_230 = (-7); (l_230 == 2); l_230 += 1)
                { /* block id: 111 */
                    uint32_t l_241 = 0xD8708D74;
                    l_244 = ((((float)(p_96 <= (-0x3.Bp-1)) + (float)func_121(l_120.f3.f5, p_96, l_103, p_97)) > (-0x5.6p+1)) > (!func_121((((int32_t)((uint32_t)((p_98 ^ 0xA9BD93B3) ^ l_241) + (uint32_t)p_98) % (int32_t)p_96) == 0), l_241, p_96, l_243)));
                }
                if (l_112)
                { /* block id: 114 */
                    l_244 = ((float)func_121(((uint16_t)p_98 << (uint16_t)6), (((l_120.f3.f2 && ((0xF262 > l_243) != 0x4A3DAEE2)) & ((int16_t)p_97 << (int16_t)((-5) != l_120.f3.f1))) < (l_230 || p_97)), p_98, l_251) + (float)(-0x1.2p-1));
                }
                else
                { /* block id: 116 */
                    l_252 = p_98;
                }
                p_95 = (0xC.3E42A8p+32 != ((float)l_244 + (float)(p_95 > ((float)((float)(-0x9.3p+1) / (float)__builtin_ffs((0x8F7B >= p_98))) - (float)((float)p_96 / (float)((float)(((float)((((float)p_97 / (float)0x6.Fp-1) < 0x0.5p-1) >= l_252) / (float)l_267) == p_96) - (float)p_97))))));
                return p_96;
            }
            else
            { /* block id: 121 */
                uint16_t l_282 = 0xA152;
                for (l_243 = (-28); (l_243 > 54); l_243 += 9)
                { /* block id: 124 */
                    float l_270 = 0x4.8C95F2p+9;
                    int32_t l_271 = 0;
                    if (p_98)
                    { /* block id: 125 */
                        l_120.f0 = l_271;
                        p_94 = ((float)((float)(-0x1.9p-1) / (float)((float)(((0x0.6p-1 >= (p_95 == p_98)) >= func_121(p_97, ((int16_t)p_96 >> (int16_t)0), p_96, ((p_96 || ((p_97 == p_96) <= p_98)) <= p_96))) != 0xF.E36C9Bp+52) / (float)(-0x1.Bp+1))) + (float)l_282);
                        p_95 = p_94;
                        l_244 = (!((float)((-0x1.4p+1) != p_96) - (float)l_103));
                    }
                    else
                    { /* block id: 130 */
                        l_120.f3.f4 = p_98;
                        return p_97;
                    }
                    if ((l_282 || ((uint16_t)l_120.f3.f0 << (uint16_t)14)))
                    { /* block id: 134 */
                        uint32_t l_300 = 0x4E78FF90;
                        int32_t l_309 = 0x9377EC1D;
                        l_309 = (~(((uint32_t)p_96 + (uint32_t)((((int16_t)(p_97 == ((uint16_t)((int32_t)(__builtin_ctzll(((__builtin_parity(func_115(l_297, ((uint32_t)__builtin_clzll(l_300) + (uint32_t)((uint16_t)(p_97 == (+l_304)) - (uint16_t)(((uint16_t)((int16_t)(p_96 <= 0U) >> (int16_t)1) >> (uint16_t)1) < l_120.f3.f3))), p_96, p_96)) < 0x09B9) < 0x066C)) > p_98) / (int32_t)l_120.f2) >> (uint16_t)2)) << (int16_t)p_97) | p_98) == p_96)) <= (-8)));
                        p_95 = 0x2.1132A1p-41;
                        p_95 = (((p_98 >= __builtin_clzll(l_120.f2)) <= ((float)(func_140(l_297.f3, (__builtin_ffsll((6 <= (((((int16_t)(0xA2C1D85E ^ (l_244 < l_271)) % (int16_t)((uint16_t)((int16_t)((uint32_t)__builtin_ffsl((l_297.f3.f9 < 0xDDDD)) % (uint32_t)4) << (int16_t)p_96) / (uint16_t)0x83A6)) > l_282) <= l_271) < p_96))) <= 0x4E37), l_282, l_282) >= p_96) + (float)(-0x3.Ap+1))) > l_309);
                    }
                    else
                    { /* block id: 138 */
                        l_244 = (p_94 <= p_97);
                        return p_96;
                    }
                    if (l_120.f3.f3)
                        continue;
                    l_297.f3.f4 = 0x1.3p+1;
                }
                l_297.f0 = l_322;
                return l_297.f3.f3;
            }
        }
        else
        { /* block id: 148 */
            int16_t l_327 = 0x380F;
            l_120.f0 = ((float)p_97 / (float)(((float)l_230 / (float)(0x7.7AAFA6p-1 <= l_327)) != p_94));
        }
        l_322 = (6U == ((uint16_t)l_330 / (uint16_t)1));
        l_120.f0 = ((0x7CC11C1C & l_297.f1) == ((((p_97 | (p_98 ^ p_96)) == ((uint32_t)(((uint32_t)l_335 / (uint32_t)func_104(l_120.f3.f1, ((int16_t)(((~3U) > (l_297.f3.f5 || p_97)) != p_96) % (int16_t)p_98), l_297.f3.f2, l_297.f1, p_94)) >= 0x289F0428) + (uint32_t)0xC5FF90D8)) && p_97) >= 0x681670B5));
    }
    else
    { /* block id: 153 */
        const float l_342 = 0x2.48497Dp+18;
        int32_t l_349 = 0;
        struct S0 l_357 = {8,0x02CAED80,2481,4294967295U,1164,-187,-0x5.7p+1,-1,0xCA31,0xB828BC55};
        struct S1 l_382 = {0,1983,51,{1,0xEE314A90,2653,0xA0A2916B,-2354,-296,0x5.59A623p+89,0x23FE,0x1FB4,0xB6AFF3CF}};
        uint32_t l_429 = 1U;
        if (((uint16_t)(l_335 >= p_96) - (uint16_t)((uint32_t)l_120.f3.f0 % (uint32_t)((uint16_t)l_120.f0 >> (uint16_t)4))))
        { /* block id: 154 */
            const int16_t l_363 = 0x3901;
            int32_t l_364 = 7;
            p_94 = p_94;
            for (l_267 = (-27); (l_267 < (-26)); l_267++)
            { /* block id: 158 */
                uint16_t l_356 = 0x5800;
                int32_t l_361 = 0x0FBAEA80;
                if (p_96)
                { /* block id: 159 */
                    return l_349;
                }
                else
                { /* block id: 161 */
                    int32_t l_355 = 0xE1C893E1;
                    l_355 = ((((int16_t)(0 && (p_96 > (-1))) << (int16_t)(0 && p_96)) | 0U) < ((int16_t)((~l_355) > ((((p_96 | l_355) == l_120.f3.f3) >= l_349) || l_349)) >> (int16_t)14));
                    l_361 = (l_356 != func_140(l_357, l_356, p_97, ((uint16_t)((__builtin_bswap64(l_356) | p_98) && (~l_356)) % (uint16_t)1)));
                }
                if (l_361)
                    break;
            }
            l_364 = (l_120.f0 <= (l_330 <= (func_140(l_357, l_362, l_363, l_363) <= p_94)));
        }
        else
        { /* block id: 168 */
            p_94 = ((float)0x0.Fp+1 + (float)p_98);
        }
        l_251 = (l_120.f3.f2 ^ p_97);
        for (l_335 = 14; (l_335 < (-15)); l_335 -= 1)
        { /* block id: 174 */
            float l_375 = 0x5.7025D4p-84;
            float l_383 = 0x9.6p+1;
            int32_t l_384 = (-1);
            struct S0 l_393 = {-1,1U,10,0U,2831,154,-0x1.Dp+1,-8,3,0xD9AD2610};
            struct S1 l_426 = {-0,2169,68,{0xF78B6800,0xC1AA73F9,2619,0x6A1A296D,-2800,-364,0x5.25B2EAp+46,0x4EEE,-1,0x4FB6F61C}};
            l_120.f3.f4 = 0x6B41D626;
            if (p_98)
            { /* block id: 176 */
                if (p_98)
                    break;
            }
            else
            { /* block id: 178 */
                uint8_t l_369 = 0xBE;
                int32_t l_370 = 0x74A55781;
                l_120.f1 = l_357.f8;
                l_370 = (l_369 > 2);
                for (l_357.f9 = (-4); (l_357.f9 == (-2)); l_357.f9 += 6)
                { /* block id: 183 */
                    float l_380 = (-0x9.Ep-1);
                    int32_t l_381 = 0x919C03BF;
                    uint16_t l_398 = 0xB673;
                    l_357.f5 = l_330;
                    l_357.f5 = 0x36638D83;
                    p_95 = ((float)l_375 + (float)((float)l_120.f3.f2 + (float)((float)l_380 - (float)(l_370 != ((l_381 > (0xA.76B5FFp+39 != func_115(l_382, l_370, l_357.f8, l_103))) < l_384)))));
                    if (p_97)
                    { /* block id: 187 */
                        uint8_t l_385 = 1U;
                        struct S1 l_388 = {-0,-3601,247,{0x457048CE,0xE4D31844,2567,0xDE8D8AB8,-2505,-505,0x4.30A3E0p+38,9,-8,0}};
                        l_388.f0 = (((l_385 != func_121((p_98 <= (p_97 & ((uint32_t)((p_98 && 1U) == l_304) - (uint32_t)(func_115(l_388, p_98, p_98, l_384) & 0xD8008BCA)))), p_98, p_98, l_388.f3.f1)) <= 0xA.4235F6p-1) != l_381);
                        l_388.f3.f5 = l_384;
                    }
                    else
                    { /* block id: 190 */
                        uint16_t l_408 = 0xB9E6;
                        l_384 = p_97;
                        p_94 = ((float)((float)(-0x1.Bp+1) + (float)(func_140(l_393, l_369, l_382.f3.f0, p_98) == (l_370 != (((float)((((float)l_398 / (float)((float)((float)((((float)p_94 / (float)0x8.1789B2p+96) > l_398) >= l_369) + (float)p_94) / (float)0x1.7p-1)) > l_120.f3.f8) <= 0x1.9p+1) - (float)p_96) < p_97)))) / (float)0x2.C582DDp+75);
                        l_408 = ((uint16_t)0x63A5 >> (uint16_t)(p_96 < ((+l_120.f0) | p_96)));
                    }
                }
                l_120.f3.f5 = (1 <= l_382.f1);
            }
            for (l_304 = 0; (l_304 > (-8)); l_304 -= 1)
            { /* block id: 200 */
                uint32_t l_430 = 1U;
                int32_t l_434 = 0xADF2E0D3;
                l_251 = ((int16_t)p_98 >> (int16_t)((int16_t)((-1) ^ 0xA441) << (int16_t)9));
                if (l_393.f2)
                    continue;
                for (l_120.f3.f3 = 0; (l_120.f3.f3 < 48); l_120.f3.f3++)
                { /* block id: 205 */
                    uint8_t l_433 = 246U;
                    l_393.f4 = (func_104(l_120.f3.f8, p_97, p_98, l_335, p_98) <= ((uint16_t)((~((uint16_t)0x627E - (uint16_t)(((int16_t)(((uint16_t)p_97 << (uint16_t)p_97) <= l_393.f1) >> (int16_t)2) && l_362))) || 0xE46E) / (uint16_t)p_96));
                    l_434 = func_115(l_426, (func_115(l_120, l_393.f5, (p_96 || func_104(((int16_t)l_429 - (int16_t)(l_430 < (((int16_t)(__builtin_popcountll(((l_433 && (-6)) & p_96)) > 9U) >> (int16_t)1) > l_430))), l_393.f2, p_97, p_98, p_98)), l_430) >= l_426.f3.f9), l_357.f2, p_96);
                }
            }
            p_94 = ((float)p_94 + (float)p_96);
        }
        l_382.f0 = (((int16_t)((int16_t)__builtin_ffsll(l_382.f3.f1) / (int16_t)(p_97 || 65531U)) << (int16_t)5) != 9U);
    }
    for (l_120.f3.f8 = (-22); (l_120.f3.f8 == 21); l_120.f3.f8 += 2)
    { /* block id: 216 */
        uint8_t l_445 = 1U;
        int32_t l_471 = 0;
        int16_t l_494 = 0x3EB0;
        p_95 = ((float)(l_445 > ((float)((((float)p_95 - (float)l_445) > ((float)((float)((float)((float)((float)(((float)((float)p_96 + (float)p_95) / (float)(((((!((float)(((((float)p_97 / (float)p_94) >= (l_120.f3.f8 < p_94)) <= l_445) != l_103) - (float)l_445)) >= l_103) != l_445) > l_120.f2) > l_120.f0)) <= l_120.f3.f8) - (float)p_97) - (float)p_96) + (float)l_445) + (float)p_97) - (float)0x3.8FB1EAp-78)) != p_96) / (float)0xE.ACF154p-25)) + (float)p_95);
        l_471 = ((int16_t)p_98 << (int16_t)7);
        if (l_120.f3.f3)
            break;
        l_471 = ((__builtin_ctzl(l_445) > ((float)((float)p_95 / (float)(0x0.3p+1 <= ((float)p_97 + (float)((((float)(((float)((float)func_104(p_97, ((((0xDF7F != ((int32_t)((int32_t)p_96 + (int32_t)((uint16_t)((int32_t)((uint16_t)p_96 + (uint16_t)l_120.f3.f1) % (int32_t)0x378EC2CE) + (uint16_t)l_445)) - (int32_t)l_103)) & l_494) | l_494) && p_97), p_98, l_471, l_471) + (float)(-0x1.Dp-1)) + (float)p_98) != p_95) + (float)0x8.B6CAF0p+23) <= (-0x9.6p+1)) != l_120.f3.f4)))) + (float)p_96)) < p_95);
    }
    if (((uint32_t)(l_304 < (((__builtin_ia32_crc32qi(p_96, func_104(l_304, p_98, p_97, ((uint16_t)p_98 / (uint16_t)((int32_t)(p_98 ^ 2U) - (int32_t)(((int16_t)l_362 << (int16_t)11) > p_97))), l_335)) && 0) & l_362) >= p_96)) % (uint32_t)p_97))
    { /* block id: 222 */
        uint8_t l_518 = 0xD2;
        int32_t l_527 = 0;
        float l_559 = 0x1.6p+1;
        uint32_t l_606 = 4294967295U;
        if (p_96)
        { /* block id: 223 */
            uint32_t l_509 = 4294967295U;
            uint8_t l_525 = 247U;
            int32_t l_526 = (-6);
            p_95 = ((float)((float)((float)(p_94 != l_509) - (float)(p_98 > __builtin_popcount((!((uint32_t)l_509 / (uint32_t)l_509))))) / (float)(((float)(!0x6.5p+1) + (float)((float)0x3.94BCBDp+32 - (float)p_97)) > l_518)) + (float)0xF.466EF3p-34);
            l_526 = (65528U ^ (((int16_t)p_96 >> (int16_t)l_518) && (((int32_t)(((uint32_t)((p_98 ^ (p_96 != l_518)) == 0x2C01) - (uint32_t)0x6B3C6EF0) & 4294967291U) % (int32_t)l_509) & l_525)));
            l_120.f0 = p_95;
            l_527 = (-0x8.Cp-1);
        }
        else
        { /* block id: 228 */
            int32_t l_528 = (-7);
            struct S0 l_582 = {0xAFB3C503,1U,1615,9U,-1483,-393,-0x6.9p-1,-7,4,0};
            if (l_528)
            { /* block id: 229 */
                const int16_t l_545 = (-1);
                float l_583 = 0xB.8E2104p+36;
                l_527 = (((int16_t)0xE395 << (int16_t)6) || ((-1) && (((uint16_t)l_103 % (uint16_t)(l_527 ^ (l_518 >= l_528))) >= ((int16_t)0 - (int16_t)(p_97 || (65535U > 1))))));
                if (((int32_t)((func_115(l_120, l_527, ((uint16_t)p_97 >> (uint16_t)0), p_94) <= 0x054F) > ((uint16_t)((int32_t)(p_96 != p_97) % (int32_t)l_545) >> (uint16_t)7)) + (int32_t)4))
                { /* block id: 231 */
                    int32_t l_546 = 0xC13B5F98;
                    l_527 = (p_98 > ((p_98 > (l_546 == p_96)) > 0x5E51));
                }
                else
                { /* block id: 233 */
                    struct S1 l_551 = {0,-2329,-23,{0x487F2F06,0x53ADFECC,2383,1U,-745,-219,-0x1.2p+1,0x5629,0x3D1C,6}};
                    float l_560 = 0x4.1E1E88p-80;
                    for (l_112 = 0; (l_112 != 25); l_112++)
                    { /* block id: 236 */
                        l_528 = ((l_545 != l_518) == (0x5.D0021Ap-83 >= (p_94 <= ((float)p_98 - (float)(-0x9.Ap+1)))));
                    }
                    if ((((((p_97 ^ (p_96 ^ (func_115(l_551, (p_98 > ((-(uint32_t)p_98) > ((((uint32_t)func_104(((l_120.f3.f4 & ((int16_t)p_96 >> (int16_t)l_551.f2)) < ((uint32_t)((((p_96 > l_527) != 1) >= p_96) >= l_551.f3.f3) + (uint32_t)p_98)), l_518, p_98, l_528, p_98) - (uint32_t)p_97) < p_96) | l_545))), l_528, l_545) != p_98))) ^ l_527) < 0x7F65) == 0x2BDE94D0) && l_120.f2))
                    { /* block id: 239 */
                        return p_97;
                    }
                    else
                    { /* block id: 241 */
                        p_94 = (func_121(p_96, (((int32_t)l_528 + (int32_t)p_98) & p_96), p_98, __builtin_clz(((((((uint16_t)(l_527 >= (p_96 > ((l_551.f1 != 0U) > l_545))) >> (uint16_t)9) == l_527) != l_518) != l_545) <= l_518))) > l_120.f3.f7);
                        return l_518;
                    }
                }
                l_582.f5 = (l_545 && ((+((int32_t)((uint32_t)l_527 - (uint32_t)((uint16_t)l_575 >> (uint16_t)((uint16_t)(((l_120.f3.f9 >= ((l_527 <= (-(int16_t)((+((((int16_t)func_140(l_582, l_527, (p_96 < (0x544E2B29 < p_96)), p_98) >> (int16_t)7) < (-1)) | p_98)) ^ p_96))) >= 0x0F69)) && l_582.f0) >= l_112) - (uint16_t)l_545))) % (int32_t)l_545)) ^ 4294967295U));
                return l_120.f3.f3;
            }
            else
            { /* block id: 248 */
                uint32_t l_592 = 1U;
                struct S0 l_604 = {0x4000DC1B,4U,2574,9U,-253,-444,0x8.2FA72Cp+64,0,0xC05F,1};
                int16_t l_627 = 1;
                l_592 = ((float)(p_94 == func_121(p_96, ((uint16_t)func_104(((((int16_t)(p_97 >= p_97) - (int16_t)((int16_t)(func_104(p_97, p_96, l_120.f1, l_527, ((-0x1.9p-1) < p_97)) >= 0x98B7E4ED) - (int16_t)l_527)) == 0xE66F) > l_582.f9), p_96, p_97, p_98, l_527) / (uint16_t)l_527), l_120.f3.f2, l_518)) + (float)0x0.1p-1);
                for (l_322 = 0; (l_322 > 4); l_322 += 1)
                { /* block id: 252 */
                    uint16_t l_612 = 6U;
                    struct S1 l_619 = {-0,2410,89,{0x44E4862D,0x4033CD71,2147,4U,-1808,114,-0x1.7p+1,0x3B46,-4,0}};
                    for (l_582.f7 = (-6); (l_582.f7 <= (-14)); l_582.f7 -= 4)
                    { /* block id: 255 */
                        float l_603 = (-0x1.Fp+1);
                        int32_t l_605 = 0x4633D413;
                        struct S1 l_611 = {0,-3907,-239,{-1,0xF617D356,38,1U,-123,48,0x2.4p-1,0x24CF,0xB5EE,4}};
                        l_528 = ((l_592 > ((((float)0x2.194D3Ep-65 - (float)p_97) >= ((float)((float)(-0x4.8p+1) + (float)0x5.E7ECF5p+78) + (float)((l_603 < func_140(l_604, (p_98 == ((l_605 || p_98) ^ p_98)), p_96, l_518)) <= 0x9.Fp+1))) < l_606)) > p_95);
                        p_94 = ((float)p_98 - (float)((float)(((func_115(l_611, l_612, p_96, ((((0x6.2p-1 < 0xE.0F91F6p-12) >= l_582.f9) >= ((((((float)__builtin_parityll(p_97) - (float)l_518) < (-0x1.Bp+1)) >= p_97) >= l_612) != (-0x1.Ap+1))) == l_582.f7)) <= p_95) <= 0x3.743E9Fp-16) >= l_362) / (float)l_304));
                    }
                    for (l_251 = 19; (l_251 > (-9)); l_251 -= 1)
                    { /* block id: 261 */
                        int32_t l_626 = 5;
                        l_627 = ((int16_t)(func_115(l_619, p_98, ((uint16_t)((l_604.f4 >= ((int32_t)1 + (int32_t)((p_98 ^ ((uint16_t)((p_98 > 8) > p_97) << (uint16_t)2)) == (l_619.f2 | p_97)))) >= l_626) >> (uint16_t)13), p_95) ^ l_304) >> (int16_t)0);
                        l_120.f0 = (0xD74C835D | 4294967295U);
                        l_527 = ((int32_t)l_619.f3.f2 / (int32_t)((int32_t)(-1) % (int32_t)((uint16_t)p_97 << (uint16_t)6)));
                    }
                }
            }
            l_527 = 0;
            l_575 = ((int16_t)((p_98 && ((8 != p_96) ^ ((uint16_t)p_96 << (uint16_t)9))) <= 0x76702FE4) % (int16_t)__builtin_ffsll((l_120.f2 <= (~(9 != (((int16_t)((((((uint16_t)l_575 + (uint16_t)p_98) > l_335) >= (-1)) ^ 0) != 0) - (int16_t)l_120.f3.f5) != 0x075F629F))))));
            for (l_322 = 13; (l_322 > 3); l_322 -= 1)
            { /* block id: 272 */
                for (l_518 = 25; (l_518 <= 34); l_518 += 1)
                { /* block id: 275 */
                    l_120.f3.f5 = 0x516F625E;
                    if (p_97)
                        break;
                    if (l_575)
                        break;
                }
                return l_518;
            }
        }
        l_120.f0 = func_104(l_120.f3.f0, __builtin_clzl(p_96), p_96, l_362, l_527);
        l_527 = (((l_362 >= l_251) <= l_527) >= (0x922CFA40 >= 0U));
    }
    else
    { /* block id: 285 */
        uint32_t l_649 = 1U;
        p_94 = l_649;
    }
    return l_330;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_104(uint32_t  p_105, int32_t  p_106, uint32_t  p_107, int16_t  p_108, float  p_109)
{ /* block id: 91 */
    float l_192 = (-0x3.2p+1);
    struct S0 l_193 = {-1,0x3F5755E1,697,9U,735,-333,0x9.1F4848p-62,0xFC60,3,2};
    struct S1 l_224 = {-0,2008,235,{-8,4294967286U,245,1U,593,63,0x2.E914EDp-61,0xC9B1,1,-10}};
    uint32_t l_227 = 0x684A9858;
    p_106 = (p_107 == func_140(l_193, p_107, p_106, __builtin_popcountl(l_193.f8)));
    for (l_193.f7 = (-15); (l_193.f7 < (-18)); l_193.f7 -= 1)
    { /* block id: 95 */
        uint32_t l_211 = 0x86254796;
        if (p_105)
        { /* block id: 96 */
            uint32_t l_196 = 0xF0680C1E;
            l_193.f5 = l_196;
            return p_107;
        }
        else
        { /* block id: 99 */
            uint32_t l_208 = 4294967295U;
            int32_t l_212 = 0x77AE9643;
            l_212 = (p_107 && ((((-(int32_t)(0xEEF4D9A0 == (((((uint16_t)((uint16_t)((int32_t)p_105 / (int32_t)((int32_t)((uint32_t)l_208 - (uint32_t)((int32_t)p_105 - (int32_t)p_107)) + (int32_t)0x151B0854)) << (uint16_t)(8 || l_211)) >> (uint16_t)14) == p_108) >= p_105) != p_107))) && l_211) <= 0xF79F9116) < l_208));
        }
    }
    l_193.f4 = ((uint16_t)p_106 << (uint16_t)0);
    p_106 = (+((uint32_t)((uint16_t)func_140(l_193, func_140(l_193, __builtin_clzll((-(int16_t)(((__builtin_ctz((p_105 ^ (~l_193.f8))) && ((int16_t)l_193.f0 >> (int16_t)5)) | (1 == func_115(l_224, (((int16_t)p_106 - (int16_t)p_105) | l_224.f3.f7), p_107, l_227))) < 0x71772FEA))), p_108, l_193.f3), l_193.f9, l_193.f5) - (uint16_t)l_224.f3.f3) - (uint32_t)p_105));
    return l_224.f3.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_115(struct S1  p_116, int16_t  p_117, uint32_t  p_118, float  p_119)
{ /* block id: 52 */
    float l_130 = 0x1.Ap+1;
    int32_t l_131 = (-10);
    p_119 = func_121(((int32_t)((uint16_t)l_131 << (uint16_t)((uint32_t)((-7) != (__builtin_bswap32(l_131) < (((int32_t)(p_118 == l_131) - (int32_t)((int32_t)l_131 % (int32_t)l_131)) ^ func_140(p_116.f3, l_131, l_131, p_117)))) - (uint32_t)l_131)) + (int32_t)l_131), l_131, p_116.f3.f3, p_116.f0);
    return l_131;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_121(int32_t  p_122, uint8_t  p_123, uint8_t  p_124, uint16_t  p_125)
{ /* block id: 56 */
    int32_t l_147 = 0x7B2EA262;
    int32_t l_149 = 0x7338C8B0;
    struct S0 l_164 = {0xD10A89F6,0x7EE216E9,1739,0x8868497F,2853,-48,0xD.D5ECC4p-5,0,0x6826,0};
    int32_t l_176 = 1;
    const uint32_t l_190 = 0x99481441;
    int32_t l_191 = 8;
    if (p_124)
    { /* block id: 57 */
        uint8_t l_162 = 0x88;
        int32_t l_163 = 0;
        struct S0 l_174 = {6,4294967295U,2724,0x1DCF3264,-2402,-499,-0x8.Ep+1,1,1,0xAA0BFB30};
        if (l_147)
        { /* block id: 58 */
            uint32_t l_148 = 1U;
            l_149 = l_148;
            p_122 = (-3);
            l_163 = ((float)((float)(((float)((p_125 <= ((float)l_149 / (float)(-0x3.2p+1))) >= l_148) - (float)(((float)l_147 - (float)((float)(l_148 <= ((0x0.5D5B94p+19 > ((l_162 < (l_162 <= l_148)) < p_124)) == l_147)) - (float)0x5.B449E2p+73)) >= l_149)) == p_125) - (float)p_122) + (float)p_125);
        }
        else
        { /* block id: 62 */
            return l_163;
        }
        if ((func_140(l_164, ((__builtin_ctzl(l_163) ^ p_123) != l_162), (p_123 & p_122), ((l_162 && (l_147 && 0x6CDD)) != l_163)) >= 1))
        { /* block id: 65 */
            uint32_t l_167 = 3U;
            l_164.f4 = p_124;
            l_164.f4 = ((float)l_167 - (float)((float)l_167 / (float)l_163));
            l_163 = (-1);
        }
        else
        { /* block id: 69 */
            const float l_175 = 0xE.BA1556p+7;
            struct S0 l_180 = {0xAED9211E,1U,242,0x916BB261,-221,342,0xD.83A9A7p-97,0,0x0396,0x4FF77B4A};
            uint32_t l_185 = 2U;
            l_164.f4 = ((float)p_123 + (float)((float)func_140(l_174, l_163, (l_176 == (l_174.f7 | (~(((uint32_t)__builtin_clz((func_140(l_180, (l_174.f3 > (((4294967291U == l_164.f2) & p_125) == 0xA087)), l_174.f4, p_122) >= 0x0707)) - (uint32_t)l_180.f3) == l_162)))), l_180.f8) - (float)0x9.8CBB59p-87));
            l_163 = ((float)((((p_124 > l_174.f4) >= (((float)p_124 - (float)l_164.f5) >= p_125)) > (func_140(l_180, l_164.f8, (0x18F6632B < (0xD2957CE5 <= 1)), p_123) > l_164.f2)) >= 0x1.CB64C1p+21) / (float)p_123);
            l_174.f5 = __builtin_ffsll(l_185);
            l_149 = l_164.f3;
        }
    }
    else
    { /* block id: 75 */
        l_176 = l_147;
    }
    for (p_124 = (-6); (p_124 >= 13); p_124 += 1)
    { /* block id: 80 */
        uint16_t l_188 = 2U;
        int32_t l_189 = (-1);
        p_122 = (6U >= p_123);
        l_189 = l_188;
        if (l_164.f5)
            break;
        if (l_188)
            continue;
    }
    l_149 = 1;
    l_149 = (((l_164.f5 == func_140(l_164, l_164.f1, l_190, l_191)) <= l_149) >= l_164.f9);
    return l_164.f8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_140(struct S0  p_141, const uint32_t  p_142, const int16_t  p_143, int16_t  p_144)
{ /* block id: 53 */
    float l_145 = 0xF.F1E809p+54;
    int32_t l_146 = 0x57DFA0F4;
    l_146 = l_146;
    return l_146;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 157
   depth: 1, occurrence: 17
   depth: 2, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 32
breakdown:
   indirect level: 0, occurrence: 32
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 44
XXX times a single bitfield on LHS: 38
XXX times a single bitfield on RHS: 76

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 246
   depth: 2, occurrence: 41
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 6
   depth: 6, occurrence: 6
   depth: 7, occurrence: 4
   depth: 8, occurrence: 3
   depth: 10, occurrence: 1
   depth: 11, occurrence: 5
   depth: 12, occurrence: 2
   depth: 13, occurrence: 7
   depth: 14, occurrence: 2
   depth: 15, occurrence: 5
   depth: 16, occurrence: 3
   depth: 17, occurrence: 5
   depth: 18, occurrence: 6
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 4
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 30, occurrence: 2
   depth: 31, occurrence: 1
   depth: 33, occurrence: 2
   depth: 41, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 1085
XXX times a non-volatile is write: 172
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 236
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 35
   depth: 2, occurrence: 41
   depth: 3, occurrence: 35
   depth: 4, occurrence: 47
   depth: 5, occurrence: 45

XXX percentage a fresh-made variable is used: 15.5
XXX percentage an existing variable is used: 84.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

