/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2754045578
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
static int32_t  func_13(int32_t  p_14, uint32_t  p_15, uint32_t  p_16, uint32_t  p_17);
static int16_t  func_18(int16_t  p_19, uint32_t  p_20);
inline static int16_t  func_29(const float  p_30, float  p_31, uint32_t  p_32, int16_t  p_33);
static float  func_38(int32_t  p_39, int32_t  p_40, uint16_t  p_41, uint16_t  p_42);
static int32_t  func_45(int32_t  p_46);
static int32_t * func_52(uint32_t  p_53, int32_t * p_54, int32_t * const  p_55, int32_t  p_56);
inline static int32_t * func_61(int32_t * p_62, int32_t * p_63);
inline static int32_t * func_65(int16_t  p_66, int32_t * p_67);
inline static int32_t * func_68(int32_t * p_69, int32_t * p_70, const int32_t * p_71, int32_t  p_72, uint32_t  p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_8 = 1U;
    uint32_t l_530 = 0U;
    int32_t l_584 = 0x8F7C3800;
    int32_t *l_583 = &l_584;
    int32_t **l_585 = &l_583;
    float l_587 = 0x0.A356F7p-52;
    float *l_586 = &l_587;
    int32_t ***l_605 = (void*)0;
    int32_t ****l_604 = &l_605;
    uint16_t l_606 = 65535U;
    int16_t l_607[7];
    uint16_t l_608[2];
    float l_609[9] = {0x1.6p+1,0x1.6p+1,0x1.6p+1,0x1.6p+1,0x1.6p+1,0x1.6p+1,0x1.6p+1,0x1.6p+1,0x1.6p+1};
    uint32_t l_610 = 1U;
    int i;
    for (i = 0; i < 7; i++)
        l_607[i] = 0x95EB;
    for (i = 0; i < 2; i++)
        l_608[i] = 65533U;
    (*l_583) = ((int32_t)0x3622BA39 % (int32_t)((uint16_t)((uint32_t)l_8 + (uint32_t)((uint16_t)((int16_t)(func_13((func_18(((uint16_t)(((((int16_t)((uint16_t)((int16_t)func_29(((float)((float)0x7.Ap-1 + (float)(func_38(l_8, l_8, l_8, l_8) < (l_8 < 0x1.838A19p-33))) - (float)l_8), l_8, l_8, l_8) * (int16_t)0x9840) >> (uint16_t)l_8) % (int16_t)0xF1E4) > l_8) >= (-4)) ^ l_8) / (uint16_t)l_530), l_530) <= l_8), l_8, l_8, l_530) & 1U) * (int16_t)0x4406) * (uint16_t)8)) >> (uint16_t)l_8));
    (*l_586) = ((*l_583) != ((l_585 == (void*)0) != (*l_583)));
    (*l_583) = ((uint16_t)((int16_t)((uint16_t)(((int16_t)(((((uint16_t)((uint16_t)(((((0x10C79545 > (**l_585)) >= (*l_583)) | ((void*)0 == &l_583)) < 0U) & ((((int16_t)0xEFB9 % (int16_t)(((((-1) || ((((((void*)0 != l_604) <= (*l_583)) ^ 0xC3F2) == 0x34C3) > l_606)) | (**l_585)) == 65528U) & 0xDA915E49)) > l_607[3]) == l_608[0])) << (uint16_t)2) + (uint16_t)65533U) ^ (*l_583)) | 0x324D5EF6) > 0x9A2713F2) % (int16_t)(*l_583)) | (**l_585)) >> (uint16_t)(**l_585)) >> (int16_t)0) - (uint16_t)(*l_583));
    return l_610;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_13(int32_t  p_14, uint32_t  p_15, uint32_t  p_16, uint32_t  p_17)
{ /* block id: 273 */
    int32_t l_539 = 7;
    int32_t *l_538 = &l_539;
    int32_t **l_540 = &l_538;
    int32_t ***l_545[9][6] = {{&l_540,&l_540,&l_540,&l_540,&l_540,&l_540},{(void*)0,&l_540,(void*)0,(void*)0,&l_540,&l_540},{&l_540,&l_540,&l_540,(void*)0,(void*)0,&l_540},{(void*)0,(void*)0,&l_540,(void*)0,&l_540,(void*)0},{&l_540,&l_540,&l_540,(void*)0,&l_540,&l_540},{(void*)0,&l_540,&l_540,&l_540,(void*)0,(void*)0},{&l_540,&l_540,(void*)0,(void*)0,&l_540,(void*)0},{(void*)0,&l_540,(void*)0,&l_540,(void*)0,&l_540},{&l_540,&l_540,&l_540,&l_540,&l_540,&l_540}};
    int32_t ****l_544 = &l_545[4][1];
    int32_t ***** const l_543 = &l_544;
    uint32_t l_561 = 0x000A0819;
    int32_t l_562[10][5] = {{0x34CA72E6,0xAC3BA0AB,0x34CA72E6,0xAC3BA0AB,0x34CA72E6},{0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC},{0x34CA72E6,0xAC3BA0AB,0x34CA72E6,0xAC3BA0AB,0x34CA72E6},{0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC},{0x34CA72E6,0xAC3BA0AB,0x34CA72E6,0xAC3BA0AB,0x34CA72E6},{0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC},{0x34CA72E6,0xAC3BA0AB,0x34CA72E6,0xAC3BA0AB,0x34CA72E6},{0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC},{0x34CA72E6,0xAC3BA0AB,0x34CA72E6,0xAC3BA0AB,0x34CA72E6},{0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC,0x3C99A5FC}};
    int i, j;
    l_538 = l_538;
    (*l_538) = (*l_538);
    (*l_540) = &l_539;
    if (((int32_t)((l_543 != &l_544) ^ 0x177010FA) - (int32_t)(8 > (((((int16_t)(-8) * (int16_t)(~((int16_t)(((uint16_t)(p_15 || (0xCC6A < ((int32_t)((uint32_t)((~((uint16_t)(~4294967295U) * (uint16_t)(l_561 | 0x57472F43))) && (-1)) % (uint32_t)p_14) % (int32_t)p_15))) + (uint16_t)p_16) > l_562[7][4]) / (int16_t)0x5DF4))) < (**l_540)) != p_17) <= p_17))))
    { /* block id: 277 */
        int32_t *l_563 = (void*)0;
        float l_567[3];
        float *l_566 = &l_567[0];
        int32_t *****l_570 = &l_544;
        int16_t l_581 = 0xA63E;
        int32_t l_582[10][2] = {{0x163E4180,0xE80C6336},{1,0xE80C6336},{0x163E4180,0xE80C6336},{1,0xE80C6336},{0x163E4180,0xE80C6336},{1,0xE80C6336},{0x163E4180,0xE80C6336},{1,0xE80C6336},{0x163E4180,0xE80C6336},{1,0xE80C6336}};
        int i, j;
        for (i = 0; i < 3; i++)
            l_567[i] = 0x7.022C29p-3;
        (*l_540) = l_563;
        /* statement id: 278 */
        assert (l_538 == 0);
        (*l_566) = ((float)(p_15 == ((void*)0 != l_538)) - (float)0x9.EB941Fp-97);
        l_582[7][1] = ((int16_t)(&l_544 == l_570) + (int16_t)((uint32_t)(((((((uint16_t)1U + (uint16_t)((0x435054B5 & 0U) ^ (((int32_t)p_16 % (int32_t)p_16) | (((int32_t)p_14 + (int32_t)p_16) <= p_16)))) == 0x9E8AA237) > p_14) != 0xB9151525) && p_16) | p_17) % (uint32_t)l_581));
    }
    else
    { /* block id: 281 */
        (**l_540) = p_16;
        return p_17;
    }
    /* facts after branching */
    assert (l_538 == 0);
    return p_17;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_18(int16_t  p_19, uint32_t  p_20)
{ /* block id: 269 */
    int32_t *l_531 = (void*)0;
    int32_t **l_532 = (void*)0;
    int32_t **l_533[9];
    int32_t l_535[4][1][7] = {{{(-1),0,0xC568763C,0xC568763C,0,(-1),6}},{{0x8DEA53E3,0xC568763C,0x37F59120,6,1,1,6}},{{(-10),0x95FF3E53,(-10),(-8),6,0x8DEA53E3,(-1)}},{{0x37F59120,0xC568763C,0x8DEA53E3,(-8),0x8DEA53E3,0xC568763C,0x37F59120}}};
    int32_t *l_534 = &l_535[3][0][1];
    int32_t *l_536 = &l_535[2][0][4];
    int32_t *l_537[4][3] = {{&l_535[1][0][4],&l_535[3][0][1],&l_535[3][0][1]},{&l_535[0][0][5],&l_535[3][0][1],&l_535[3][0][1]},{&l_535[1][0][4],&l_535[3][0][1],&l_535[3][0][1]},{&l_535[0][0][5],&l_535[3][0][1],&l_535[3][0][1]}};
    int i, j, k;
    for (i = 0; i < 9; i++)
        l_533[i] = &l_531;
    l_534 = l_531;
    /* statement id: 270 */
    assert (l_534 == 0);
    l_537[3][1] = l_536;
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_29(const float  p_30, float  p_31, uint32_t  p_32, int16_t  p_33)
{ /* block id: 266 */
    int32_t l_528 = (-4);
    int32_t *l_527 = &l_528;
    int32_t **l_526 = &l_527;
    int32_t ***l_529 = &l_526;
    (*l_529) = l_526;
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_38(int32_t  p_39, int32_t  p_40, uint16_t  p_41, uint16_t  p_42)
{ /* block id: 1 */
    int32_t l_446 = 0x534D2820;
    const int32_t *l_445 = &l_446;
    uint16_t l_496 = 0U;
    uint32_t l_522 = 2U;
    float *l_523 = (void*)0;
    float l_525 = 0x5.E50D29p+1;
    float *l_524 = &l_525;
    for (p_41 = 0; (p_41 != 6); p_41 += 6)
    { /* block id: 4 */
        float l_421 = 0x0.7p-1;
        int32_t l_440[1];
        int32_t *****l_466 = (void*)0;
        int32_t *l_476 = &l_446;
        int32_t **l_493 = &l_476;
        int32_t ***l_492 = &l_493;
        int i;
        for (i = 0; i < 1; i++)
            l_440[i] = 0xAF615F0D;
    }
    (*l_524) = ((((float)p_39 - (float)((float)((((float)((float)((l_522 > (0x5.3DFDAEp-31 <= (&l_446 != &l_446))) < ((0x1.Fp+1 != p_40) >= ((l_445 != l_445) == p_39))) * (float)(*l_445)) * (float)0xB.3D9431p+49) == (-0x3.Fp+1)) <= p_41) - (float)0xD.DC7A78p-2)) < p_41) >= p_39);
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_45(int32_t  p_46)
{ /* block id: 5 */
    uint32_t l_47[1];
    int32_t l_396[3][6] = {{5,0x1250996D,5,(-2),(-2),5},{0x535EAC5A,0x535EAC5A,(-2),(-6),(-2),0x535EAC5A},{(-2),0x1250996D,(-6),(-6),0x1250996D,(-2)}};
    int32_t *l_395 = &l_396[1][1];
    const int32_t l_398 = 1;
    int32_t *l_400 = &l_396[1][1];
    int32_t **l_401 = &l_395;
    int i, j;
    for (i = 0; i < 1; i++)
        l_47[i] = 0x56095DBC;
    for (p_46 = 0; (p_46 <= 0); p_46 += 1)
    { /* block id: 8 */
        int32_t l_49[1];
        int32_t *l_48 = &l_49[0];
        int32_t l_50[4];
        int i;
        for (i = 0; i < 1; i++)
            l_49[i] = 9;
        for (i = 0; i < 4; i++)
            l_50[i] = 0x0F213ED4;
        (*l_48) = l_47[p_46];
        for (l_50[3] = 0; (l_50[3] >= 0); l_50[3] -= 1)
        { /* block id: 12 */
            int32_t l_51 = 0x03C3FA3C;
            int32_t **l_399 = &l_48;
            for (l_51 = 0; (l_51 >= 0); l_51 -= 1)
            { /* block id: 15 */
                int32_t **l_393 = &l_48;
                int32_t l_394 = (-1);
                int i;
            }
            for (l_51 = 0; (l_51 <= 0); l_51 += 1)
            { /* block id: 173 */
                int32_t **l_397 = &l_395;
                int i;
                l_395 = &l_49[l_51];
                /* statement id: 174 */
                assert ((l_395 >= &l_49[0] && l_395 <= &l_49[0]));
                (*l_397) = &l_51;
                /* statement id: 175 */
                assert (l_395 == &l_51);
            }
            /* facts after for loop */
            //assert (l_395 == &l_51 || l_395 == dangling || (l_395 >= &l_396[0][0] && l_395 <= &l_396[2][5]));
            if (l_398)
                continue;
            //assert (l_395 == dangling || (l_395 >= &l_396[0][0] && l_395 <= &l_396[2][5]));
            (*l_399) = &p_46;
            /* statement id: 178 */
            assert (l_48 == &p_46);
        }
        /* facts after for loop */
        assert (l_48 == &p_46 || (l_48 >= &l_49[0] && l_48 <= &l_49[0]));
    }
    /* facts after for loop */
    //assert (l_395 == dangling || (l_395 >= &l_396[0][0] && l_395 <= &l_396[2][5]));
    (*l_401) = l_400;
    /* statement id: 181 */
    assert ((l_395 >= &l_396[0][0] && l_395 <= &l_396[2][5]));
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_52(uint32_t  p_53, int32_t * p_54, int32_t * const  p_55, int32_t  p_56)
{ /* block id: 159 */
    int32_t l_364 = 0x0866FE60;
    int32_t *l_363[4];
    int32_t **l_365 = &l_363[1];
    int32_t l_388 = 0x50AF9C1A;
    int32_t *l_389 = &l_364;
    int32_t *l_390 = &l_364;
    int32_t *l_391[5] = {&l_364,&l_364,&l_364,&l_364,&l_364};
    int32_t *l_392 = (void*)0;
    int i;
    for (i = 0; i < 4; i++)
        l_363[i] = &l_364;
    (*l_365) = l_363[1];
    (*l_365) = func_65(((uint16_t)(**l_365) >> (uint16_t)4), (*l_365));
    /* statement id: 161 */
    //assert (l_363[0] == 0 || l_363[0] == &l_364);
    l_388 = ((uint16_t)((int16_t)(((int32_t)((int32_t)p_53 - (int32_t)((uint16_t)(p_56 >= (((int16_t)((uint16_t)((0xBC621D0D | p_53) & ((-1) >= ((int32_t)((uint16_t)(((void*)0 != &p_56) | ((int16_t)(0x898F && p_53) % (int16_t)p_56)) - (uint16_t)p_53) % (int32_t)0x8367C925))) >> (uint16_t)p_56) * (int16_t)p_56) >= p_53)) % (uint16_t)p_53)) + (int32_t)p_56) ^ 0U) + (int16_t)p_56) * (uint16_t)p_53);
    return l_392;
    /* statement id: 163 */
    //assert (func_52_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_61(int32_t * p_62, int32_t * p_63)
{ /* block id: 16 */
    int32_t *l_64 = (void*)0;
    return l_64;
    /* statement id: 17 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_65(int16_t  p_66, int32_t * p_67)
{ /* block id: 21 */
    int32_t *l_103 = (void*)0;
    int32_t **l_102 = &l_103;
    int32_t ***l_104 = &l_102;
    int32_t l_115 = (-4);
    const int32_t *l_190[4] = {&l_115,&l_115,&l_115,&l_115};
    uint32_t l_191[8] = {1U,1U,1U,1U,1U,1U,1U,1U};
    uint16_t l_254[2];
    uint32_t l_266 = 0xAB1BAC27;
    float l_268 = 0x0.5p-1;
    float *l_267 = &l_268;
    uint16_t l_296 = 0x3CD3;
    uint32_t l_321 = 0x266B89E3;
    int i;
    for (i = 0; i < 2; i++)
        l_254[i] = 0x2DA8;
    (*l_104) = l_102;
    if (((((0x4D83 == (((uint16_t)((((*l_104) != (void*)0) && (0x237E92B0 > ((uint16_t)(((uint16_t)p_66 * (uint16_t)((p_66 < p_66) <= p_66)) | ((int16_t)p_66 * (int16_t)0)) >> (uint16_t)p_66))) < 0x6BEA) + (uint16_t)l_115) >= p_66)) > p_66) & p_66) == p_66))
    { /* block id: 23 */
        uint32_t l_129 = 0xFFFF0E59;
        float l_133 = 0x0.Ep+1;
        float *l_132 = &l_133;
        uint32_t l_176[8][3] = {{0xD56E0077,0xD56E0077,0xD56E0077},{0U,4U,0U},{0xD56E0077,0xD56E0077,0xD56E0077},{0U,4U,0U},{0xD56E0077,0xD56E0077,0xD56E0077},{0U,4U,0U},{0xD56E0077,0xD56E0077,0xD56E0077},{0U,4U,0U}};
        int32_t l_179 = 0x7C5A92DA;
        const int32_t **l_201 = (void*)0;
        const int32_t ***l_200[10] = {&l_201,&l_201,&l_201,&l_201,&l_201,&l_201,&l_201,&l_201,&l_201,&l_201};
        int i, j;
        (*l_132) = (((float)(0x0.Ep-1 != ((((float)((float)(!((((p_66 <= ((((&p_67 == (void*)0) != p_66) <= ((float)0x2.3p-1 - (float)((float)((float)l_129 - (float)p_66) * (float)((((float)l_129 / (float)0x7.385945p+50) < l_129) != (-0x10.3p+1))))) == 0x0.Ap+1)) < (-0x1.Fp-1)) > l_129) != l_129)) + (float)(-0x1.Dp-1)) + (float)p_66) != p_66) != l_129)) - (float)p_66) >= 0x6.600D47p+63);
        for (l_115 = (-7); (l_115 != (-13)); l_115 -= 3)
        { /* block id: 27 */
            int32_t *l_136[7] = {&l_115,&l_115,&l_115,&l_115,&l_115,&l_115,&l_115};
            int i;
            (**l_104) = l_136[5];
            for (p_66 = 0; (p_66 != 17); p_66++)
            { /* block id: 31 */
                int16_t l_146 = 0;
                int32_t l_153 = 1;
                (*l_132) = (p_67 == p_67);
            }
        }
        /* facts after for loop */
        assert (l_103 == 0 || l_103 == &l_115);
        if ((~((uint32_t)l_176[2][0] + (uint32_t)((uint16_t)(~(1 >= (p_67 == l_103))) >> (uint16_t)(-(int32_t)((int16_t)p_66 - (int16_t)l_176[2][2]))))))
        { /* block id: 54 */
            const int32_t *l_189 = &l_115;
            (**l_104) = p_67;
            /* statement id: 55 */
            //assert (l_103 == 0 || l_103 == &l_364);
            (**l_104) = func_68(p_67, (*l_102), l_189, p_66, l_176[7][2]);
            (*l_104) = (void*)0;
            /* statement id: 57 */
            assert (l_102 == 0);
            l_190[2] = l_189;
        }
        else
        { /* block id: 59 */
            int32_t l_198 = 0xB4B0C768;
            int32_t ***l_199 = &l_102;
            int32_t *l_204 = &l_115;
            (*l_204) = (p_66 < (l_191[1] < ((uint16_t)((int16_t)(((int16_t)(l_198 && l_198) >> (int16_t)(l_199 != l_200[7])) | ((p_66 == ((uint32_t)(p_67 == (void*)0) + (uint32_t)p_66)) || 0x8338)) * (int16_t)0x322F) << (uint16_t)12)));
            (*l_204) = ((uint16_t)(((uint16_t)((int16_t)p_66 >> (int16_t)((int32_t)p_66 + (int32_t)((((int16_t)((int16_t)((uint32_t)((uint16_t)((((*l_204) <= p_66) ^ (((uint16_t)p_66 + (uint16_t)(((int32_t)p_66 - (int32_t)(((((*l_104) == &p_67) > ((int16_t)((int16_t)((int32_t)((*l_104) == &p_67) - (int32_t)p_66) / (int16_t)p_66) / (int16_t)(*l_204))) >= (*l_204)) != p_66)) > p_66)) == 0xE8A264C3)) != 0xF1EB2153) + (uint16_t)(*l_204)) - (uint32_t)0x540F12F2) * (int16_t)p_66) << (int16_t)2) != p_66) <= p_66))) << (uint16_t)p_66) < p_66) / (uint16_t)(-1));
        }
        /* facts after branching */
        //assert (l_103 == 0 || l_103 == &l_115 || l_103 == &l_364);
        assert (l_102 == &l_103 || l_102 == 0);
    }
    else
    { /* block id: 63 */
        int16_t l_233 = 9;
        uint16_t l_244 = 65532U;
        int32_t *l_245 = &l_115;
        float l_247 = (-0x1.8p-1);
        float *l_246 = &l_247;
        int32_t ****l_248 = &l_104;
        l_244 = (((float)l_233 + (float)0x1.EED684p-87) < ((float)(((float)((((float)p_66 + (float)(((p_66 < 0x0.4p-1) < l_233) >= ((float)(-0x1.7p+1) / (float)(p_66 >= ((float)((void*)0 == p_67) / (float)p_66))))) > p_66) <= p_66) * (float)l_233) <= p_66) / (float)p_66));
        (*l_102) = func_61(l_245, p_67);
        (*l_246) = ((void*)0 != (*l_104));
        (*l_248) = &l_102;
    }
    /* facts after branching */
    //assert (l_103 == 0 || l_103 == &l_115 || l_103 == &l_364);
    assert (l_102 == &l_103 || l_102 == 0);
    (*l_267) = ((float)(((!p_66) >= ((float)l_254[0] / (float)((float)p_66 * (float)(p_66 <= (((float)p_66 / (float)p_66) == 0x2.FCB356p+62))))) > ((p_66 <= ((float)((-(float)((((float)(((float)p_66 + (float)0x0.5p-1) > (-0x1.Ap+1)) - (float)p_66) != l_266) >= 0x4.8p-1)) > p_66) + (float)(-0x8.Ap+1))) >= p_66)) / (float)p_66);
    for (p_66 = (-25); (p_66 != 19); p_66 += 4)
    { /* block id: 72 */
        int32_t * const **l_295 = (void*)0;
        int32_t l_297 = 0xFD7EBAF8;
        int32_t *l_320 = &l_115;
        int32_t ****l_346 = &l_104;
        int32_t *****l_345 = &l_346;
        for (l_266 = 9; (l_266 != 53); l_266++)
        { /* block id: 75 */
            uint32_t l_273 = 4294967293U;
            int32_t l_280 = 4;
            p_67 = p_67;
            if (l_273)
                continue;
            l_280 = (p_66 == ((int16_t)(((p_67 == p_67) & (!p_66)) == ((0xCE85 >= (~(p_66 && l_273))) || (&l_102 != (void*)0))) >> (int16_t)12));
            return p_67;
            /* statement id: 79 */
            //assert (func_65_rv == 0 || func_65_rv == &l_364);
        }
        (*l_267) = ((float)((((((float)(&l_102 == (void*)0) - (float)0x2.DA43A8p+96) < ((float)0x3.B15D64p-73 - (float)(p_66 > ((((((float)((float)((float)p_66 / (float)((float)((-0x4.2p+1) <= (l_295 == &l_102)) - (float)p_66)) - (float)p_66) - (float)0xE.4B1B77p+34) <= l_296) != p_66) == p_66) < p_66)))) != 0x0.6p-1) >= p_66) > l_297) * (float)p_66);
        for (l_115 = 0; (l_115 <= 3); l_115 += 1)
        { /* block id: 84 */
            int32_t *l_298 = (void*)0;
            int32_t ** const *l_310 = &l_102;
            int32_t ** const **l_309 = &l_310;
            int32_t *** const *l_312 = &l_104;
            int32_t *** const **l_311 = &l_312;
            int i;
        }
        if (p_66)
        { /* block id: 89 */
            for (l_296 = 0; (l_296 > 28); ++l_296)
            { /* block id: 92 */
                int32_t *l_319 = &l_297;
                for (l_266 = 0; (l_266 < 18); l_266++)
                { /* block id: 95 */
                    const int32_t **l_317 = (void*)0;
                    int32_t **l_318 = &l_103;
                    (*l_318) = p_67;
                    /* statement id: 96 */
                    //assert (l_103 == 0 || l_103 == &l_364);
                }
                l_320 = l_319;
                /* statement id: 98 */
                assert (l_320 == &l_297);
            }
            /* facts after for loop */
            assert (l_320 == &l_297 || l_320 == &l_115);
            if (l_321)
                continue;
        }
        else
        { /* block id: 101 */
            uint32_t l_329 = 7U;
            int32_t l_336 = (-1);
            for (l_115 = (-4); (l_115 == 1); l_115 += 4)
            { /* block id: 104 */
                int32_t *** const *l_326 = &l_104;
                int32_t *l_343[2];
                int i;
                for (i = 0; i < 2; i++)
                    l_343[i] = &l_336;
                if ((*l_320))
                { /* block id: 105 */
                    int32_t *l_344 = &l_336;
                    if ((((int32_t)((*l_320) & ((void*)0 == l_326)) - (int32_t)(p_66 < ((-3) > (l_329 >= ((uint16_t)l_329 % (uint16_t)((p_66 | (p_66 <= 1U)) || 2)))))) != 1U))
                    { /* block id: 106 */
                        int32_t *l_332 = &l_297;
                        (*l_332) = p_66;
                    }
                    else
                    { /* block id: 108 */
                        const int32_t **l_333 = (void*)0;
                        int32_t *****l_347 = &l_346;
                        l_190[2] = p_67;
                        /* statement id: 109 */
                        //assert (l_190[0] == 0 || l_190[0] == &l_115 || l_190[0] == &l_364);
                        l_336 = (p_66 & ((uint16_t)0xBDC3 + (uint16_t)l_329));
                        (*l_267) = ((p_66 < (((((float)((((((float)l_329 * (float)(((float)(l_329 < ((((l_343[0] != l_344) != p_66) >= (l_345 == l_347)) != p_66)) / (float)0x1.204E7Cp-95) >= p_66)) < 0x1.Cp-1) >= (*l_344)) == 0xF.D20CEAp-63) >= p_66) + (float)p_66) == p_66) <= 0x1.37FCBAp-42) >= 0x9.290DDEp-80)) != p_66);
                        return p_67;
                        /* statement id: 112 */
                        //assert (func_65_rv == 0 || func_65_rv == &l_364);
                    }
                }
                else
                { /* block id: 114 */
                    int32_t *l_350 = &l_336;
                    for (l_296 = (-4); (l_296 < 31); l_296 += 7)
                    { /* block id: 117 */
                        int32_t *l_351[10][7][3] = {{{&l_336,(void*)0,&l_115},{(void*)0,(void*)0,&l_297},{(void*)0,(void*)0,&l_336},{&l_297,&l_336,&l_297},{&l_297,&l_297,&l_115},{&l_297,&l_336,(void*)0},{&l_297,(void*)0,&l_336}},{{(void*)0,&l_297,&l_297},{(void*)0,&l_115,&l_336},{&l_336,&l_115,(void*)0},{&l_115,&l_297,&l_115},{&l_336,&l_297,&l_297},{&l_297,&l_115,&l_336},{&l_336,&l_115,&l_297}},{{(void*)0,&l_297,&l_115},{&l_336,(void*)0,&l_115},{&l_297,&l_336,&l_297},{&l_336,&l_297,&l_297},{&l_115,&l_336,&l_115},{&l_336,(void*)0,&l_115},{(void*)0,(void*)0,&l_297}},{{(void*)0,(void*)0,&l_336},{&l_297,&l_336,&l_297},{&l_297,&l_297,&l_115},{&l_297,&l_336,(void*)0},{&l_297,(void*)0,&l_336},{(void*)0,&l_297,&l_297},{(void*)0,&l_115,&l_336}},{{&l_336,&l_115,(void*)0},{&l_115,&l_297,&l_115},{&l_336,&l_297,&l_297},{&l_297,&l_115,&l_336},{&l_336,&l_115,&l_297},{(void*)0,&l_297,&l_115},{&l_336,(void*)0,&l_115}},{{&l_297,&l_336,&l_297},{&l_336,&l_297,&l_297},{&l_115,&l_336,&l_115},{&l_336,(void*)0,&l_115},{(void*)0,(void*)0,&l_297},{(void*)0,(void*)0,&l_336},{&l_297,&l_336,&l_297}},{{&l_297,&l_297,&l_115},{&l_297,&l_336,(void*)0},{&l_297,(void*)0,&l_336},{(void*)0,&l_297,&l_297},{(void*)0,&l_115,&l_336},{&l_336,&l_115,(void*)0},{&l_115,&l_297,&l_115}},{{&l_336,&l_297,&l_297},{&l_297,&l_115,&l_336},{&l_336,&l_115,&l_297},{(void*)0,&l_297,&l_115},{&l_336,(void*)0,&l_115},{&l_297,&l_336,&l_297},{&l_336,&l_297,&l_297}},{{&l_115,&l_336,&l_115},{&l_336,(void*)0,&l_115},{(void*)0,(void*)0,&l_297},{(void*)0,&l_336,&l_297},{&l_336,&l_297,&l_297},{&l_336,(void*)0,&l_297},{&l_336,&l_297,&l_336}},{{&l_336,&l_115,&l_336},{&l_336,&l_336,&l_336},{&l_115,(void*)0,&l_336},{&l_336,&l_297,&l_336},{&l_297,&l_336,&l_297},{&l_297,&l_336,&l_297},{&l_297,&l_297,&l_297}}};
                        int i, j, k;
                        return p_67;
                        /* statement id: 118 */
                        //assert (func_65_rv == 0 || func_65_rv == &l_364);
                    }
                    for (l_297 = 0; (l_297 <= 1); l_297 += 1)
                    { /* block id: 122 */
                        int i;
                        if (l_254[l_297])
                            break;
                    }
                }
                for (l_266 = 0; (l_266 <= 45); l_266++)
                { /* block id: 128 */
                    return p_67;
                    /* statement id: 129 */
                    //assert (func_65_rv == 0 || func_65_rv == &l_364);
                }
                for (l_329 = (-9); (l_329 == 40); ++l_329)
                { /* block id: 133 */
                    uint32_t l_357 = 0xF94DFDEB;
                    int32_t *l_362 = &l_336;
                    if (p_66)
                    { /* block id: 134 */
                        int32_t **l_356[6] = {(void*)0,&l_320,(void*)0,(void*)0,&l_320,(void*)0};
                        int i;
                        p_67 = (void*)0;
                        /* statement id: 135 */
                        assert (p_67 == 0);
                        if (l_336)
                            break;
                        if (l_357)
                            continue;
                        (*l_267) = p_66;
                    }
                    else
                    { /* block id: 139 */
                        return p_67;
                        /* statement id: 140 */
                        //assert (func_65_rv == 0 || func_65_rv == &l_364);
                    }
                    /* facts after branching */
                    assert (p_67 == 0);
                    for (l_321 = 0; (l_321 <= 1); l_321 += 1)
                    { /* block id: 144 */
                        int i;
                        l_336 = ((uint16_t)((uint16_t)l_254[l_321] << (uint16_t)((*l_320) <= 0x1E1AD130)) << (uint16_t)2);
                        l_343[l_321] = l_343[l_321];
                        if (l_336)
                            break;
                        return p_67;
                        /* statement id: 148 */
                        //assert (func_65_rv == 0);
                    }
                    l_362 = func_61(p_67, p_67);
                    /* statement id: 150 */
                    assert (l_362 == 0);
                    if (l_329)
                        break;
                }
            }
            p_67 = p_67;
            return p_67;
            /* statement id: 155 */
            //assert (func_65_rv == 0 || func_65_rv == &l_364);
        }
        /* facts after branching */
        assert (l_320 == &l_297 || l_320 == &l_115);
    }
    return p_67;
    /* statement id: 158 */
    //assert (func_65_rv == 0 || func_65_rv == &l_364);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_68(int32_t * p_69, int32_t * p_70, const int32_t * p_71, int32_t  p_72, uint32_t  p_73)
{ /* block id: 18 */
    int16_t l_91 = (-1);
    int16_t l_96[6][6][7] = {{{(-6),0x5B79,0x8828,(-3),0xCBC1,0x8828,(-5)},{0x149A,0x6E0D,(-3),0x778A,(-3),0x1411,0x5D62},{0xEE56,0,0xA422,(-1),0x351D,0xFE49,0x9701},{0x8828,(-1),(-1),0,8,0xA422,0},{(-1),0x9701,0x2677,0xCBC1,8,(-9),0x149A},{0x0898,0xFE49,0x39CA,0x9701,0x351D,0x251D,(-1)}},{{0x0A08,1,0xFE49,0,(-3),(-6),(-6)},{0xCBC1,(-1),0xCF76,(-1),0xCBC1,9,(-2)},{0x778A,(-1),0xC53F,5,(-6),0xFE49,(-1)},{0xC53F,8,0,0x298A,0xB986,(-3),1},{0x778A,5,(-3),0x149A,0x6E0D,(-3),0x778A},{0xCBC1,0x8828,(-5),(-2),0xF2F4,0,0x9701}},{{0x0A08,8,0x0237,(-5),0x149A,0x4AAC,(-1)},{0x0898,0x5D62,0x461D,0x1B86,5,0x7A76,0x5B79},{(-1),0xF2F4,0x251D,0x1B86,0x39CA,0xC53F,0xB986},{0x8828,1,0,(-5),0x9701,(-1),0xA422},{0xEE56,0x210A,0x6401,(-2),1,0xC45D,1},{0x149A,0x0A08,0x0A08,0x149A,0x8828,0x351D,(-1)}},{{(-6),(-1),0xFE49,0x298A,0x149A,(-1),7},{0x5B79,0x0898,(-2),5,(-1),0x6401,(-1)},{0x1B86,0x251D,0xF2F4,(-1),0x251D,7,1},{7,0x5B79,(-1),0,0xB986,0x4AAC,(-3)},{(-3),0x298A,0x6E0D,1,(-5),0x210A,1},{(-5),0x1411,0xCF76,0xC53F,0x6401,0xCF76,(-3)}},{{(-6),0x0237,0xCF76,0x2FB3,0x351D,0x6401,9},{0xD29C,(-6),0x6E0D,(-1),0x8828,0x0898,1},{0x0A08,1,9,0xFE49,(-3),(-3),0xFE49},{0xD1F9,1,0xD1F9,0x6401,0x251D,0x461D,(-6)},{(-6),0,0x1B86,1,0x8828,(-1),0x39CA},{1,0x7A76,0x9CA2,(-6),0xC45D,0x461D,(-5)}},{{0x6401,8,1,0xD1F9,0xC53F,(-3),0x461D},{0xFE49,0xA422,0x5D62,0x0A08,(-5),0x0898,0x39CA},{(-1),(-3),(-9),0xD29C,0xF205,0x6401,0x4AAC},{0x2FB3,0x0A08,0xEE25,(-6),0x0237,0xCF76,0x2FB3},{0xC53F,0x0A08,0xCBC1,(-5),8,0x210A,1},{1,(-3),0x1D8B,(-3),(-6),(-2),0xA422}}};
    int32_t l_97 = 0xBF95235B;
    int32_t l_99[10] = {1,1,1,1,1,1,1,1,1,1};
    int32_t *l_98[8];
    float l_100 = 0x7.3p+1;
    uint32_t l_101 = 4294967295U;
    int i, j, k;
    for (i = 0; i < 8; i++)
        l_98[i] = &l_99[4];
    l_101 = ((((int32_t)(1U == ((!((int16_t)(((int32_t)(((uint16_t)((int32_t)((int32_t)((((uint16_t)((uint16_t)(l_91 >= (0x120B879B ^ 0x42A457AF)) / (uint16_t)(((uint16_t)((int16_t)p_73 >> (int16_t)3) * (uint16_t)((*p_71) != ((*p_71) > (p_72 != l_96[1][2][1])))) | 0x5237AE93)) / (uint16_t)p_72) < 0x44B0) || p_73) % (int32_t)l_96[1][2][1]) + (int32_t)0x5F9D9D8A) << (uint16_t)l_91) == 0x48A9) / (int32_t)l_91) || l_97) / (int16_t)p_72)) | 0x764F)) + (int32_t)(*p_71)) >= l_97) >= 0x41E233C2);
    return p_69;
    /* statement id: 20 */
    //assert (func_68_rv == 0 || func_68_rv == &l_364 || (func_68_rv >= &l_440[0] && func_68_rv <= &l_440[0]));
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 103
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 111
   depth: 2, occurrence: 20
   depth: 3, occurrence: 3
   depth: 4, occurrence: 4
   depth: 6, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 115

XXX times a variable address is taken: 206
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 38
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 53
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 5
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 563

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 155
   level: 2, occurrence: 49
   level: 3, occurrence: 40
   level: 4, occurrence: 22
   level: 5, occurrence: 11
XXX number of pointers point to pointers: 55
XXX number of pointers point to scalars: 60
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 37.4
XXX average alias set size: 1.39

XXX times a non-volatile is read: 550
XXX times a non-volatile is write: 183
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 104
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 18
   depth: 2, occurrence: 21
   depth: 3, occurrence: 8
   depth: 4, occurrence: 9
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 12.9
XXX percentage an existing variable is used: 87.1
********************* end of statistics **********************/

