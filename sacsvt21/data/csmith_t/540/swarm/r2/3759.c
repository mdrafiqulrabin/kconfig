/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      4157909992
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_35(void);
inline static const float  func_39(const int32_t  p_40, float  p_41, const uint8_t  p_42);
inline static int32_t  func_53(int32_t  p_54, uint32_t  p_55, int32_t * p_56, int16_t  p_57, int32_t * p_58);
inline static float  func_71(uint32_t  p_72, uint8_t  p_73, float  p_74, const int32_t  p_75, int32_t ** p_76);
static float  func_80(uint16_t  p_81, int32_t * p_82, int32_t * p_83, int32_t  p_84, float  p_85);
inline static int16_t  func_91(int32_t * p_92, int32_t * p_93, int32_t * p_94, uint32_t  p_95);
static int32_t * func_96(int16_t  p_97, uint32_t  p_98);
inline static uint32_t  func_101(uint32_t  p_102, int32_t  p_103);
inline static int32_t  func_104(const int16_t  p_105, uint32_t  p_106, int32_t ** p_107);
inline static const uint16_t  func_114(const int32_t ** p_115, int32_t  p_116);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_35(void)
{ /* block id: 36 */
    int32_t l_36 = 0x76373A4C;
    int32_t *l_220 = (void*)0;
    const int32_t *l_252 = &l_36;
    const int32_t **l_251 = &l_252;
    uint8_t l_255 = 1U;
    int32_t l_256 = 0xEBE5BDD1;
    int32_t *l_260 = &l_36;
    int32_t **l_263 = &l_260;
    int32_t ***l_262 = &l_263;
    int32_t ****l_261 = &l_262;
    float l_265 = 0x5.40BFAEp-57;
    float *l_264 = &l_265;
    int32_t l_266 = 0x5E4C5809;
    for (l_36 = 12; (l_36 <= (-22)); l_36 = safe_sub_func_int16_t_s_s(l_36, 1))
    { /* block id: 39 */
        int32_t l_43 = 0x537C57F3;
        int32_t *l_212 = &l_36;
        uint32_t l_247 = 1U;
        if (l_36)
        { /* block id: 40 */
            uint8_t l_209 = 0U;
            int32_t *l_213 = &l_36;
            float l_215 = 0x8.78A6B1p+55;
            float *l_214 = &l_215;
            const int32_t *l_233 = &l_36;
            (*l_214) = (0x1.6p+1 < ((func_39(l_36, l_43, l_43) >= ((((func_80((~(safe_sub_func_int32_t_s_s(__builtin_clzl(l_43), ((~l_209) && (safe_lshift_func_uint16_t_u_u((l_43 & l_36), l_36)))))), l_212, l_213, (*l_213), (*l_212)) >= l_36) <= (*l_212)) >= (*l_213)) != (*l_213))) < 0xE.F51D59p-45));
            for (l_43 = (-10); (l_43 > 25); l_43 = safe_add_func_int32_t_s_s(l_43, 5))
            { /* block id: 131 */
                const int32_t l_219 = 9;
                float *l_227 = &l_215;
                int32_t **l_228 = &l_213;
                (*l_228) = func_96(l_36, ((((!l_219) || (l_220 == l_212)) < ((((safe_rshift_func_int16_t_s_s((-1), ((safe_lshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_s(0xBD2C, 15)), l_219)) ^ 0x48144486))) & ((void*)0 != l_227)) > 0) && (*l_212))) & 0xE144));
                /* statement id: 132 */
                assert (l_213 == 0);
                (*l_228) = func_96(l_209, (*l_212));
                for (l_209 = (-24); (l_209 != 12); l_209 = safe_add_func_int32_t_s_s(l_209, 9))
                { /* block id: 136 */
                    int32_t l_241 = 0xE4936EB0;
                    int32_t *l_240 = &l_241;
                    int32_t ***l_244 = &l_228;
                    (*l_240) = ((__builtin_parity((safe_mod_func_int32_t_s_s(((void*)0 != l_233), (safe_sub_func_uint16_t_u_u((*l_212), (((safe_sub_func_uint16_t_u_u(((safe_add_func_uint16_t_u_u((l_36 == (*l_212)), 5U)) || (*l_233)), l_219)) == (3U <= 0xBABF467C)) != l_36)))))) <= (*l_212)) ^ (-1));
                    for (l_241 = 0; (l_241 == (-24)); l_241 = safe_sub_func_int16_t_s_s(l_241, 1))
                    { /* block id: 140 */
                        int32_t l_245 = (-1);
                        (*l_228) = l_212;
                        /* statement id: 141 */
                        assert (l_213 == &l_36);
                        (*l_228) = func_96(((void*)0 != l_244), (((*l_233) <= (__builtin_parityll((*l_212)) > (**l_228))) | (*l_212)));
                        /* statement id: 142 */
                        assert (l_213 == 0);
                        l_247 = (l_245 < (!(*l_233)));
                    }
                    (**l_244) = &l_36;
                    /* statement id: 145 */
                    assert (l_213 == &l_36);
                }
                /* facts after for loop */
                assert (l_213 == &l_36 || l_213 == 0);
            }
            /* facts after for loop */
            assert (l_213 == &l_36 || l_213 == 0);
        }
        else
        { /* block id: 148 */
            int32_t **l_248 = &l_220;
            (*l_248) = (void*)0;
            /* statement id: 149 */
            assert (l_220 == 0);
            (*l_248) = l_212;
            /* statement id: 150 */
            assert (l_220 == &l_36);
            (*l_248) = (*l_248);
        }
    }
    /* facts after for loop */
    assert (l_220 == &l_36 || l_220 == 0);
    (*l_260) = (safe_rshift_func_int16_t_s_u(func_114(l_251, (**l_251)), ((safe_sub_func_int32_t_s_s((((l_36 | (((l_255 ^ l_256) >= 2U) < (~(safe_rshift_func_uint16_t_u_s(l_256, l_256))))) || l_255) ^ 4294967295U), l_256)) ^ 0U)));
    /* statement id: 154 */
    //assert (l_252 == dangling || l_252 == &l_36);
    (*l_264) = ((&l_36 != &l_36) >= (l_261 != &l_262));
    (*l_264) = (****l_261);
    return l_266;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const float  func_39(const int32_t  p_40, float  p_41, const uint8_t  p_42)
{ /* block id: 41 */
    int32_t l_45 = 0xD4840737;
    int32_t *l_44 = &l_45;
    int32_t **l_46 = &l_44;
    float *l_204 = (void*)0;
    (*l_46) = l_44;
    (*l_44) = (((((safe_rshift_func_int16_t_s_s(((safe_unary_minus_func_uint32_t_u((__builtin_clz((*l_44)) != (safe_mod_func_uint32_t_u_u((~(**l_46)), func_53(((*l_44) & ((0xADD33D73 && (safe_add_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(((safe_sub_func_int16_t_s_s(0, p_42)) == (**l_46)), 12)) == (safe_add_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_u((((safe_lshift_func_uint16_t_u_u((&l_44 == &l_44), (*l_44))) < (*l_44)) | (*l_44)), (*l_44))) == 0x132DC1B2), p_42))), (*l_44)))) != 65532U)), (*l_44), (*l_46), p_42, (*l_46))))))) != 0xC9D1), (*l_44))) != p_42) & (**l_46)) == p_40) <= (*l_44));
    p_41 = p_41;
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_53(int32_t  p_54, uint32_t  p_55, int32_t * p_56, int16_t  p_57, int32_t * p_58)
{ /* block id: 43 */
    int32_t l_77 = 0x3F8C0E5C;
    int32_t **l_196 = (void*)0;
    const uint16_t l_200 = 0x8ECC;
    float l_202 = 0x9.F71531p+16;
    float *l_201 = &l_202;
    int32_t l_203 = 0;
    p_56 = &p_54;
    /* statement id: 44 */
    assert (p_56 == &p_54);
    (*l_201) = (((((&p_54 == &p_54) > func_71(p_57, l_77, (safe_sub_func_float_f_f(func_80(l_77, &l_77, &l_77, (safe_lshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s(((l_77 < (~(func_91(&l_77, &l_77, &l_77, p_54) ^ p_54))) & p_57), 11)), l_77)), l_77), 0x0.6C8CC7p+0)), l_77, l_196)) <= l_200) >= l_77) > p_55);
    return l_203;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_71(uint32_t  p_72, uint8_t  p_73, float  p_74, const int32_t  p_75, int32_t ** p_76)
{ /* block id: 119 */
    int32_t l_198 = (-8);
    int32_t *l_197 = &l_198;
    int32_t **l_199 = &l_197;
    (*l_199) = l_197;
    (*l_199) = func_96(p_75, (**l_199));
    /* statement id: 121 */
    assert (l_197 == 0);
    return l_198;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_80(uint16_t  p_81, int32_t * p_82, int32_t * p_83, int32_t  p_84, float  p_85)
{ /* block id: 111 */
    int32_t l_190 = 0;
    int32_t *l_189 = &l_190;
    int32_t **l_188 = &l_189;
    int32_t l_195 = 0;
    (**l_188) = (((!(l_188 == &p_83)) | 0x2E7BD33C) < (!p_81));
    for (l_190 = 0; (l_190 <= (-25)); l_190 = safe_sub_func_uint32_t_u_u(l_190, 7))
    { /* block id: 115 */
        int32_t l_194 = 0xFB85D134;
        if (l_194)
            break;
    }
    return l_195;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_91(int32_t * p_92, int32_t * p_93, int32_t * p_94, uint32_t  p_95)
{ /* block id: 45 */
    int32_t l_119 = 0;
    const int32_t *l_118 = &l_119;
    const int32_t **l_117 = &l_118;
    int32_t *l_147 = &l_119;
    int32_t **l_146 = &l_147;
    (*l_117) = func_96((safe_sub_func_uint32_t_u_u(func_101(p_95, (func_104((((((-1) || (safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_s((safe_sub_func_uint32_t_u_u((__builtin_ctz((func_114(l_117, ((__builtin_clz(((safe_lshift_func_int16_t_s_u((**l_117), 7)) && __builtin_bswap64((**l_117)))) != (-3)) <= (safe_mod_func_uint32_t_u_u((**l_117), (**l_117))))) <= p_95)) && p_95), 0xC377822E)), 4)), p_95))) | (-6)) || (-10)) == l_119), p_95, l_146) == (*l_147))), (*p_94))), (**l_146));
    /* statement id: 109 */
    assert (l_118 == 0);
    return p_95;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_96(int16_t  p_97, uint32_t  p_98)
{ /* block id: 94 */
    int32_t *l_160 = (void*)0;
    int32_t ***l_161 = (void*)0;
    const int32_t l_165 = 0xCA9F70EF;
    const int32_t *l_164 = &l_165;
    const int32_t **l_163 = &l_164;
    int32_t *l_166 = (void*)0;
    int32_t l_168 = 4;
    int32_t *l_167 = &l_168;
    int32_t *l_169 = &l_168;
    int32_t *l_170 = &l_168;
    int32_t *l_171 = &l_168;
    int32_t *l_172 = &l_168;
    int32_t *l_173 = &l_168;
    int32_t *l_174 = &l_168;
    int32_t *l_175 = &l_168;
    int32_t *l_176 = &l_168;
    int32_t *l_177 = &l_168;
    int32_t *l_178 = &l_168;
    int32_t *l_179 = &l_168;
    int32_t *l_180 = &l_168;
    int32_t *l_181 = &l_168;
    int32_t *l_182 = &l_168;
    int32_t *l_183 = &l_168;
    int32_t *l_184 = &l_168;
    int32_t *l_185 = &l_168;
    int32_t *l_186 = (void*)0;
    for (p_98 = 1; (p_98 != 35); p_98 = safe_add_func_uint16_t_u_u(p_98, 2))
    { /* block id: 97 */
        uint8_t l_157 = 0xF7;
        int32_t l_159 = (-1);
        int32_t *l_158 = &l_159;
        if (((p_98 == 3) | 0))
        { /* block id: 98 */
            l_157 = (p_97 > 0x8.DDE1E7p-71);
            return l_160;
            /* statement id: 100 */
            //assert (func_96_rv == 0);
        }
        else
        { /* block id: 101 */
            int32_t ****l_162 = &l_161;
            (*l_162) = l_161;
            if (p_98)
                break;
        }
    }
    (*l_163) = (void*)0;
    /* statement id: 106 */
    assert (l_164 == 0);
    (*l_167) = ((*l_163) == l_166);
    return l_186;
    /* statement id: 108 */
    //assert (func_96_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_101(uint32_t  p_102, int32_t  p_103)
{ /* block id: 92 */
    uint32_t l_152 = 0U;
    return l_152;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_104(const int16_t  p_105, uint32_t  p_106, int32_t ** p_107)
{ /* block id: 84 */
    int32_t l_149 = (-5);
    int32_t *l_148 = &l_149;
    l_148 = (void*)0;
    /* statement id: 85 */
    assert (l_148 == 0);
    for (l_149 = 9; (l_149 >= (-16)); l_149 = safe_sub_func_uint16_t_u_u(l_149, 5))
    { /* block id: 88 */
        return (**p_107);
    }
    return (**p_107);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_114(const int32_t ** p_115, int32_t  p_116)
{ /* block id: 46 */
    float l_124 = 0xA.4BB8EBp-35;
    int32_t *l_135 = (void*)0;
    if ((**p_115))
    { /* block id: 47 */
        const uint32_t l_132 = 0U;
        for (p_116 = 0; (p_116 <= (-14)); p_116 = safe_sub_func_uint16_t_u_u(p_116, 1))
        { /* block id: 50 */
            int32_t l_127 = 0x77E56D7C;
            (*p_115) = (*p_115);
            for (l_127 = 0; (l_127 <= 10); l_127 = safe_add_func_int32_t_s_s(l_127, 5))
            { /* block id: 54 */
                return p_116;
            }
            for (l_127 = 0; (l_127 >= 20); ++l_127)
            { /* block id: 59 */
                return l_132;
            }
            (*p_115) = (*p_115);
        }
    }
    else
    { /* block id: 64 */
        int32_t l_134 = (-6);
        const int32_t *l_133 = &l_134;
        if ((l_133 == l_135))
        { /* block id: 65 */
            (*p_115) = (*p_115);
            return p_116;
        }
        else
        { /* block id: 68 */
            for (p_116 = 0; (p_116 <= (-22)); p_116 = safe_sub_func_uint16_t_u_u(p_116, 1))
            { /* block id: 71 */
                int32_t l_140 = 2;
                float *l_145 = &l_124;
                (*p_115) = (*p_115);
                (*p_115) = &l_134;
                /* statement id: 73 */
                //assert (l_118 == &l_134);
                (*l_145) = (((safe_add_func_float_f_f(l_140, (safe_add_func_float_f_f((((-0x1.Cp-1) != (p_116 >= (safe_sub_func_float_f_f((0x3.E610DAp+77 > ((void*)0 != &l_140)), p_116)))) == ((-0x1.5p+1) < (((l_140 > 0x2.E06C79p-95) >= (*l_133)) >= p_116))), (*l_133))))) == 0x2.Dp-1) == (*l_133));
            }
            /* facts after for loop */
            //assert (l_118 == &l_134 || l_118 == &l_119);
            if ((p_115 != p_115))
            { /* block id: 76 */
                (*p_115) = &l_134;
                /* statement id: 77 */
                //assert (l_118 == &l_134);
            }
            else
            { /* block id: 78 */
                (*p_115) = &l_134;
                /* statement id: 79 */
                //assert (l_118 == &l_134);
            }
            /* facts after branching */
            //assert (l_118 == &l_134);
        }
        /* facts after branching */
        //assert (l_118 == &l_134);
    }
    /* facts after branching */
    //assert (l_118 == dangling || l_118 == &l_119);
    return p_116;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_35();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 72
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 16
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 8, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 21, occurrence: 1
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 71

XXX times a variable address is taken: 71
XXX times a pointer is dereferenced on RHS: 53
breakdown:
   depth: 1, occurrence: 38
   depth: 2, occurrence: 14
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 31
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 307

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 121
   level: 2, occurrence: 36
   level: 3, occurrence: 0
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 19
XXX number of pointers point to scalars: 52
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.1
XXX average alias set size: 1.15

XXX times a non-volatile is read: 269
XXX times a non-volatile is write: 80
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 69
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 6
   depth: 2, occurrence: 17
   depth: 3, occurrence: 10
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 17
XXX percentage an existing variable is used: 83
********************* end of statistics **********************/

