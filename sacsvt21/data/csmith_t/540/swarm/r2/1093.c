/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      472765204
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static const int16_t g_3 = 0xB8CEL;
static uint64_t g_49 = 0xEF13550E352601C8LL;
static int32_t g_53 = 4L;
static float g_55 = 0x9.2F8BA7p-97;
static int32_t g_96 = (-1L);
static float g_116 = (-0x6.Cp+1);
static float *g_192 = &g_55;
static float **g_191 = &g_192;
static const float *g_205 = &g_55;
static uint64_t g_234 = 18446744073709551606UL;
static int32_t g_235 = 0xCA2BCBDFL;
static int32_t *g_280 = (void*)0;
static float ***g_300 = &g_191;
static volatile uint32_t g_331 = 0xAFC72990L;/* VOLATILE GLOBAL g_331 */
static volatile int32_t g_392 = 0L;/* VOLATILE GLOBAL g_392 */
static const volatile int32_t *g_391 = &g_392;
static const volatile int32_t **g_390 = &g_391;
static const volatile int32_t ***g_389 = &g_390;
static const volatile int32_t ****g_411 = &g_389;
static const volatile int32_t *****g_410 = &g_411;
static int32_t g_471 = 0x4DFFC005L;
static uint8_t g_511 = 0xEEL;


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_28(void);
static float  func_58(const int16_t  p_59, uint64_t  p_60, const int32_t * p_61);
inline static uint16_t  func_62(float * p_63, int32_t * p_64, uint8_t  p_65, float  p_66);
static uint8_t  func_68(uint32_t  p_69, int32_t  p_70, int64_t  p_71, float * p_72, int16_t  p_73);
static int32_t  func_74(uint64_t  p_75, const int32_t * p_76, float * p_77, int16_t  p_78, int64_t  p_79);
static uint64_t  func_80(int32_t  p_81, int32_t * p_82, uint16_t  p_83);
static int32_t * func_84(uint16_t  p_85, float * p_86, int32_t * p_87);
static float * func_89(int16_t  p_90, const int32_t * p_91);
inline static int32_t * func_98(uint64_t  p_99, const float * p_100, uint16_t  p_101);
static uint64_t  func_102(int32_t  p_103, uint8_t  p_104, uint64_t  p_105);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_53 g_55 g_96 g_49 g_191 g_116 g_205 g_192 g_234 g_389 g_390 g_391 g_280 g_411 g_410 g_235 g_331 g_511
 * writes: g_49 g_53 g_55 g_96 g_116 g_234 g_235 g_280 g_471 g_391 g_389
 */
static uint64_t  func_28(void)
{ /* block id: 36 */
    uint32_t l_43 = 0UL;
    uint16_t l_48 = 0x3A6DL;
    int32_t *l_67 = &g_53;
    int32_t l_513 = 0x93DA9893L;
    g_49 = ((safe_lshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s(((safe_mod_func_int64_t_s_s((((safe_add_func_uint64_t_u_u((safe_add_func_uint32_t_u_u((((((safe_lshift_func_int16_t_s_s((2UL >= ((((-7L) | (safe_sub_func_uint64_t_u_u(0xC82104667120DD93LL, g_3))) | 0xED1DL) >= l_43)), l_43)) >= (safe_sub_func_int32_t_s_s((safe_mod_func_uint64_t_u_u(l_43, g_3)), l_43))) == l_43) >= l_43) >= g_3), l_43)), g_3)) | g_3) && 0x2D50L), l_43)) || 65530UL), g_3)), l_48)) < 1L);
    for (l_48 = 15; (l_48 >= 26); ++l_48)
    { /* block id: 40 */
        int32_t *l_52 = &g_53;
        float *l_54 = &g_55;
        int32_t **l_512 = &g_280;
        (*l_52) = g_3;
        (*l_54) = 0x0.AB3915p-28;
        (*l_54) = ((g_53 <= (g_55 != (0x9.079038p+35 > 0x6.2AFCB0p+23))) != (safe_sub_func_float_f_f(0xF.10F40Bp+6, (func_58(((-1L) && func_62(l_54, l_67, func_68(g_3, (*l_67), (*l_67), l_52, g_53), (*l_52))), (*l_52), l_52) <= (**g_191)))));
        /* statement id: 341 */
        assert (g_280 == &g_53 || g_280 == 0 || g_280 == &g_471);
        (*l_512) = l_67;
        /* statement id: 342 */
        assert (g_280 == &g_53);
    }
    /* facts after for loop */
    assert (g_280 == &g_53 || g_280 == 0);
    (*l_67) = 0xE2AFE838L;
    (*g_411) = (*g_411);
    return l_513;
}


/* ------------------------------------------ */
/* 
 * reads : g_235 g_410 g_411 g_389 g_390 g_391 g_53 g_331 g_511
 * writes: g_235 g_471
 */
static float  func_58(const int16_t  p_59, uint64_t  p_60, const int32_t * p_61)
{ /* block id: 334 */
    int32_t *l_506 = (void*)0;
    for (g_235 = 1; (g_235 >= (-12)); g_235 = safe_sub_func_uint16_t_u_u(g_235, 6))
    { /* block id: 337 */
        float *l_503 = &g_116;
        int32_t *l_509 = (void*)0;
        int32_t *l_510 = &g_471;
        (*l_510) = func_62(l_503, l_503, (((safe_mod_func_int64_t_s_s(((0x68F9FB7C174908F4LL ^ (-1L)) | ((****g_410) == l_506)), (safe_lshift_func_int16_t_s_u(g_235, __builtin_ffs((*p_61)))))) != 0x0A03590A5F404ECDLL) == g_331), p_59);
    }
    return g_511;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_62(float * p_63, int32_t * p_64, uint8_t  p_65, float  p_66)
{ /* block id: 332 */
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads : g_53 g_3 g_49 g_96 g_191 g_116 g_205 g_192 g_234 g_389 g_390 g_391 g_280 g_411
 * writes: g_96 g_49 g_116 g_234 g_235 g_280 g_471 g_391
 */
static uint8_t  func_68(uint32_t  p_69, int32_t  p_70, int64_t  p_71, float * p_72, int16_t  p_73)
{ /* block id: 43 */
    int32_t l_88 = 0xBA27FA52L;
    int32_t *l_499 = &g_471;
    int32_t l_500 = 0L;
    (*l_499) = func_74(((0x6825D8284A8988EDLL != func_80(g_53, func_84(l_88, func_89(p_69, &g_53), func_98(l_88, func_98((((1UL | (g_3 || 1L)) | 0x2E33L) < g_53), p_72, l_88), l_88)), l_88)) >= l_88), p_72, (*g_191), p_71, l_88);
    /* statement id: 329 */
    assert (g_280 == &g_471);
    (***g_411) = (***g_411);
    return l_500;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_74(uint64_t  p_75, const int32_t * p_76, float * p_77, int16_t  p_78, int64_t  p_79)
{ /* block id: 327 */
    int64_t l_498 = 0x1B3478E54A35818ELL;
    return l_498;
}


/* ------------------------------------------ */
/* 
 * reads : g_96 g_234 g_389 g_390 g_391 g_280 g_53
 * writes: g_96 g_280 g_234 g_116
 */
static uint64_t  func_80(int32_t  p_81, int32_t * p_82, uint16_t  p_83)
{ /* block id: 256 */
    uint64_t l_427 = 0x5951A69871A9B2B1LL;
    float ****l_441 = &g_300;
    int32_t *l_470 = &g_471;
    uint16_t l_493 = 8UL;
    int32_t **l_496 = (void*)0;
    int32_t **l_497 = &g_280;
    for (g_96 = (-27); (g_96 == 23); g_96 = safe_add_func_uint64_t_u_u(g_96, 9))
    { /* block id: 259 */
        uint32_t l_401 = 0x9F5A178EL;
        int32_t l_402 = 1L;
        int32_t **l_403 = &g_280;
        int32_t *l_421 = &l_402;
        int32_t *l_434 = &g_53;
        if (l_401)
            break;
        l_402 = p_81;
        (*l_403) = p_82;
        /* statement id: 262 */
        assert (g_280 == &g_53);
        for (g_234 = 0; (g_234 == 33); g_234 = safe_add_func_uint32_t_u_u(g_234, 1))
        { /* block id: 265 */
            const volatile int32_t *l_406 = &g_392;
            volatile int32_t l_407 = 0x6E6463BCL;/* VOLATILE GLOBAL l_407 */
            const int32_t ****l_409 = (void*)0;
            const int32_t *****l_408 = &l_409;
            uint32_t l_430 = 18446744073709551612UL;
            float ****l_440 = (void*)0;
            int32_t *l_448 = &l_402;
            l_406 = (**g_389);
        }
    }
    g_116 = l_493;
    (*l_497) = l_470;
    /* statement id: 324 */
    assert (g_280 == &g_471);
    (*l_497) = (*l_497);
    return g_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_96 g_191 g_116 g_53 g_205 g_3 g_192 g_234
 * writes: g_49 g_96 g_116 g_234 g_235
 */
static int32_t * func_84(uint16_t  p_85, float * p_86, int32_t * p_87)
{ /* block id: 88 */
    const float *l_168 = &g_116;
    int32_t l_173 = 0xA95DD02EL;
    int32_t *l_175 = &l_173;
    int32_t **l_174 = &l_175;
    uint16_t l_201 = 0UL;
    float ***l_236 = (void*)0;
    float **l_237 = &g_192;
    const uint32_t l_306 = 4294967293UL;
    int16_t l_309 = 3L;
    int64_t l_354 = 0x5FDC69A44A26B199LL;
    uint32_t l_367 = 4294967290UL;
    (*l_174) = func_98(p_85, l_168, (safe_rshift_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_u(4UL, 6)) <= p_85), l_173)));
    /* statement id: 89 */
    assert (l_175 == &g_96);
    for (l_173 = 0; (l_173 <= (-27)); l_173 = safe_sub_func_uint32_t_u_u(l_173, 3))
    { /* block id: 92 */
        int32_t *l_185 = (void*)0;
        for (g_49 = (-2); (g_49 != 6); ++g_49)
        { /* block id: 95 */
            int32_t l_180 = 1L;
            (*l_174) = (*l_174);
            if (l_180)
                continue;
        }
        for (p_85 = 0; (p_85 <= 30); ++p_85)
        { /* block id: 101 */
            (*l_174) = p_86;
            /* statement id: 102 */
            assert (l_175 == &g_116);
        }
        (*l_174) = p_87;
        /* statement id: 104 */
        assert (l_175 == &g_96);
        for (p_85 = (-21); (p_85 < 41); p_85 = safe_add_func_int16_t_s_s(p_85, 1))
        { /* block id: 107 */
            int16_t l_190 = 0xF285L;
            uint32_t l_206 = 1UL;
            l_185 = p_87;
            /* statement id: 108 */
            assert (l_185 == &g_96);
            (*l_174) = (void*)0;
            /* statement id: 109 */
            assert (l_175 == 0);
            (*l_185) = (((safe_sub_func_int16_t_s_s(g_49, (((g_96 || (l_190 < ((*l_185) == l_190))) <= (g_191 == (void*)0)) <= __builtin_ctzl((safe_add_func_int64_t_s_s((safe_add_func_int16_t_s_s(__builtin_ctzl(p_85), 0x728DL)), p_85)))))) < (*l_185)) || 0x87C57D7CL);
            for (g_49 = (-3); (g_49 < 36); ++g_49)
            { /* block id: 113 */
                float l_216 = 0xD.804477p+9;
                int32_t l_228 = 1L;
                for (g_96 = (-15); (g_96 == (-9)); g_96 = safe_add_func_int64_t_s_s(g_96, 8))
                { /* block id: 116 */
                    const float *l_214 = &g_55;
                    int32_t l_217 = 0xAFE078D0L;
                    (*l_174) = p_86;
                    /* statement id: 117 */
                    assert (l_175 == &g_116);
                    if ((*p_87))
                        continue;
                    if ((0L <= ((**l_174) != 0UL)))
                    { /* block id: 119 */
                        int64_t l_204 = 0L;
                        const uint8_t l_213 = 0UL;
                        (*p_86) = l_201;
                        (*l_175) = ((safe_add_func_uint16_t_u_u(1UL, 65531UL)) == l_204);
                        (**l_174) = (g_49 < (*p_87));
                        (*l_174) = func_98(g_53, g_205, (l_206 > (safe_mod_func_int64_t_s_s((safe_mod_func_int64_t_s_s((g_53 != (((safe_rshift_func_uint16_t_u_u(g_96, 12)) || ((g_96 <= __builtin_clzll(l_204)) ^ 0xF15030246D126375LL)) ^ g_3)), l_213)), p_85))));
                        /* statement id: 123 */
                        assert (l_175 == &g_96);
                    }
                    else
                    { /* block id: 124 */
                        uint16_t l_215 = 1UL;
                        p_87 = func_98(__builtin_clz(p_85), l_185, p_85);
                        (*l_174) = func_98(p_85, l_214, g_3);
                        /* statement id: 126 */
                        assert (l_175 == &g_96);
                        (*l_174) = &g_96;
                        p_87 = func_98(l_215, func_98(g_53, p_86, p_85), l_217);
                    }
                    /* facts after branching */
                    assert (l_175 == &g_96);
                    for (l_206 = 0; (l_206 > 24); l_206++)
                    { /* block id: 132 */
                        int32_t l_233 = (-3L);
                        g_234 = ((safe_rshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s(g_3, 3L)), 12)) < (safe_lshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_u(l_228, (safe_sub_func_uint64_t_u_u(((*l_175) && (((safe_mod_func_uint64_t_u_u(p_85, l_228)) || __builtin_ffsl(l_233)) >= (((*g_191) == (void*)0) <= 0x26E0L))), 0L)))), 7)));
                        g_235 = g_96;
                    }
                }
                (*l_185) = (*p_87);
            }
            /* facts after for loop */
            assert (l_175 == &g_96 || l_175 == &g_116 || l_175 == 0);
        }
        /* facts after for loop */
        assert (l_175 == &g_96 || l_175 == &g_116 || l_175 == 0);
        assert (l_185 == &g_96 || l_185 == 0);
    }
    /* facts after for loop */
    assert (l_175 == &g_96 || l_175 == &g_116 || l_175 == 0);
    l_237 = &g_192;
    for (g_234 = 0; (g_234 >= 23); ++g_234)
    { /* block id: 144 */
        uint32_t l_263 = 1UL;
        int32_t *l_266 = &l_173;
        uint32_t l_282 = 0x2AD850D4L;
        uint16_t l_357 = 0x9D3EL;
    }
    return &g_53;
    /* statement id: 255 */
    //assert (func_84_rv == &g_53);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_49 g_96 g_53 g_116
 * writes: g_96 g_49 g_116
 */
static float * func_89(int16_t  p_90, const int32_t * p_91)
{ /* block id: 44 */
    const int32_t l_92 = 0x9B5F814DL;
    uint64_t l_93 = 6UL;
    int32_t l_97 = 0x075F97E6L;
    const float *l_163 = (void*)0;
    const float **l_162 = &l_163;
    const float ***l_164 = (void*)0;
    const float ***l_165 = (void*)0;
    const float ***l_166 = &l_162;
    float *l_167 = &g_116;
    if (l_92)
    { /* block id: 45 */
        int32_t *l_94 = (void*)0;
        int32_t *l_95 = &g_96;
        (*l_95) = (l_93 <= p_90);
        l_97 = 0xD.CCC853p+90;
    }
    else
    { /* block id: 48 */
        int32_t *l_120 = &g_53;
        int32_t **l_119 = &l_120;
        (*l_119) = func_98(func_102(p_90, (safe_unary_minus_func_int64_t_s(g_3)), p_90), p_91, g_3);
        /* statement id: 67 */
        assert (l_120 == &g_96);
        (*l_119) = &g_96;
        for (g_96 = 0; (g_96 < (-4)); g_96 = safe_sub_func_int16_t_s_s(g_96, 5))
        { /* block id: 71 */
            uint32_t l_123 = 0x2C8CC2A3L;
            float *l_126 = &g_116;
            uint32_t l_139 = 0xF8C36B4AL;
            (*l_119) = (*l_119);
            (*l_126) = (((__builtin_popcount((p_90 | l_123)) != (safe_add_func_float_f_f(0x4.8FE3B6p+57, 0x1.ACC200p+2))) != (0x7.E77405p-29 == 0x8.9EC182p-13)) != p_90);
            if ((safe_add_func_uint64_t_u_u(p_90, (g_96 == 0xD543L))))
            { /* block id: 74 */
                uint64_t l_144 = 0x10E05D1EE040EEAALL;
                int32_t *l_149 = &l_97;
                (*l_119) = func_98((*l_120), p_91, (&p_91 == &p_91));
                (*l_119) = &g_96;
                (*l_149) = (safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u((((safe_lshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(l_139, 1L)), 0)), 11)) == ((void*)0 != p_91)) != (safe_lshift_func_uint16_t_u_s(((safe_add_func_uint32_t_u_u(l_144, g_96)) < (((safe_mod_func_uint32_t_u_u((safe_add_func_uint16_t_u_u(__builtin_ffsll(p_90), (**l_119))), (*p_91))) | 0xE316L) | (-1L))), l_144))), g_96)), 4294967290UL));
                (*l_149) = (0xB2332F7FL < (*l_120));
            }
            else
            { /* block id: 79 */
                int32_t l_161 = 0x5868DEE4L;
                l_97 = ((safe_sub_func_int64_t_s_s(0x457CE1196B4A016CLL, (1L == (safe_unary_minus_func_int16_t_s(g_53))))) != (safe_mod_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u(p_90, __builtin_clzll(((g_3 < (safe_sub_func_uint16_t_u_u(0xF135L, 0UL))) == ((l_123 & (*p_91)) | (*l_120)))))), (-9L))));
                g_116 = g_96;
                (*l_126) = (safe_add_func_float_f_f(((*l_120) > (l_161 != 0x1.9EEE8Cp-12)), __builtin_ffsll(p_90)));
            }
        }
    }
    (*l_166) = l_162;
    return l_167;
    /* statement id: 87 */
    //assert (func_89_rv == &g_116);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_98(uint64_t  p_99, const float * p_100, uint16_t  p_101)
{ /* block id: 64 */
    int32_t *l_117 = (void*)0;
    int32_t **l_118 = &l_117;
    (*l_118) = l_117;
    return &g_96;
    /* statement id: 66 */
    //assert (func_98_rv == &g_96);
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_3 g_96
 * writes: g_49 g_96 g_116
 */
static uint64_t  func_102(int32_t  p_103, uint8_t  p_104, uint64_t  p_105)
{ /* block id: 49 */
    int32_t *l_113 = &g_53;
    int32_t **l_114 = &l_113;
    float *l_115 = &g_116;
    for (p_104 = 0; (p_104 > 15); ++p_104)
    { /* block id: 52 */
        int32_t l_111 = (-1L);
        for (g_49 = 0; (g_49 >= 15); ++g_49)
        { /* block id: 55 */
            int32_t *l_112 = &g_96;
            (*l_112) = l_111;
            (*l_112) = l_111;
        }
        return g_3;
    }
    (*l_114) = l_113;
    (*l_115) = ((p_103 < ((*l_114) == (*l_114))) == g_3);
    return g_96;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_49, "g_49", print_hash_value);
    transparent_crc(g_53, "g_53", print_hash_value);
    transparent_crc_bytes (&g_55, sizeof(g_55), "g_55", print_hash_value);
    transparent_crc(g_96, "g_96", print_hash_value);
    transparent_crc_bytes (&g_116, sizeof(g_116), "g_116", print_hash_value);
    transparent_crc(g_234, "g_234", print_hash_value);
    transparent_crc(g_235, "g_235", print_hash_value);
    transparent_crc(g_331, "g_331", print_hash_value);
    transparent_crc(g_392, "g_392", print_hash_value);
    transparent_crc(g_471, "g_471", print_hash_value);
    transparent_crc(g_511, "g_511", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 113
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 18
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 95

XXX times a variable address is taken: 89
XXX times a pointer is dereferenced on RHS: 109
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 18
   depth: 3, occurrence: 8
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 87
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 3
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 353

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 414
   level: 2, occurrence: 64
   level: 3, occurrence: 21
   level: 4, occurrence: 13
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 38
XXX number of pointers point to scalars: 57
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.2
XXX average alias set size: 1.28

XXX times a non-volatile is read: 657
XXX times a non-volatile is write: 241
XXX times a volatile is read: 9
XXX    times read thru a pointer: 4
XXX times a volatile is write: 2
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 118
XXX percentage of non-volatile access: 98.8

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 87
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 20
   depth: 2, occurrence: 13
   depth: 3, occurrence: 9
   depth: 4, occurrence: 4
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 19.2
XXX percentage an existing variable is used: 80.8
********************* end of statistics **********************/

