/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2990443846
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 17;
   int32_t  f1;
   int16_t  f2;
   int16_t  f3;
   int32_t  f4;
   uint32_t  f5;
   uint32_t  f6;
   int32_t  f7;
   int16_t  f8;
   int32_t  f9;
};

union U1 {
   uint32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   int8_t * f3;
};

union U2 {
   int8_t * f0;
   uint32_t  f1;
   uint16_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_29(void);
static union U2 * func_30(int32_t  p_31, struct S0  p_32);
inline static struct S0  func_34(union U2 * p_35, uint32_t  p_36, int32_t  p_37);
inline static union U2 * func_38(int8_t * p_39, union U2 * p_40);
inline static int8_t * func_41(union U2 * p_42, int8_t * p_43);
inline static union U2 * func_44(int32_t  p_45, struct S0  p_46);
inline static int8_t * func_53(int8_t  p_54);
static int32_t  func_55(union U1  p_56, uint16_t  p_57);
static union U1  func_58(int16_t  p_59, union U2  p_60, union U1  p_61);
static int32_t  func_70(uint32_t  p_71, int16_t  p_72, int32_t * p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_29(void)
{ /* block id: 36 */
    int16_t l_33 = 0xEFE0;
    struct S0 l_47 = {-276,0x511904E2,0xEEB4,0x83CA,0x07758A8C,9U,0xA514227F,1,0x66C1,-1};
    union U2 l_582 = {0};
    union U2 *l_581 = &l_582;
    union U2 **l_580 = &l_581;
    (*l_580) = func_30(l_33, func_34(func_38(func_41(func_44(l_33, l_47), func_53(l_47.f3)), func_44(l_47.f2, l_47)), l_47.f4, l_47.f5));
    /* statement id: 372 */
    assert (l_582.f0 == 0);
    assert (l_581 == 0);
    return l_47.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2 * func_30(int32_t  p_31, struct S0  p_32)
{ /* block id: 362 */
    int32_t l_578 = 0x75F80A27;
    union U2 *l_579 = (void*)0;
    for (p_32.f5 = 0; (p_32.f5 < 31); p_32.f5 = safe_add_func_uint16_t_u_u(p_32.f5, 1))
    { /* block id: 365 */
        int32_t l_574 = 0xC403D4F7;
        int32_t **l_575 = (void*)0;
        int32_t *l_577 = (void*)0;
        int32_t **l_576 = &l_577;
        l_574 ^= p_32.f0;
        if (p_32.f2)
            continue;
        (*l_576) = &p_31;
        /* statement id: 368 */
        assert (l_577 == &p_31);
    }
    p_32.f9 = l_578;
    return l_579;
    /* statement id: 371 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_34(union U2 * p_35, uint32_t  p_36, int32_t  p_37)
{ /* block id: 271 */
    struct S0 l_434 = {56,1,1,7,0,0x3CB9FE37,1U,0x4132EE4A,-9,0xC52450AC};
    struct S0 *l_435 = &l_434;
    uint32_t l_438 = 0U;
    int32_t *l_445 = (void*)0;
    int32_t **l_444 = &l_445;
    int32_t ***l_443 = &l_444;
    int32_t ****l_442 = &l_443;
    int32_t *****l_441 = &l_442;
    int32_t *l_446 = &l_434.f1;
    uint32_t l_478 = 0x03D4C543;
    int32_t l_503 = 0x345E83C1;
    struct S0 *l_533 = &l_434;
    int32_t l_564 = 0xDF0B291B;
    struct S0 l_570 = {-200,-5,0x5880,0xB10F,-9,0x3368BC4F,4294967292U,-7,0,0x9B5EFEC0};
    struct S0 l_571 = {-188,0xE7C9A61A,1,0xA6FD,0xB57AD20D,4294967290U,4294967286U,0,-1,8};
    (*l_435) = l_434;
    if ((p_36 <= (safe_lshift_func_int16_t_s_u(func_70((l_438 || l_434.f5), (safe_lshift_func_int16_t_s_u(__builtin_popcountll(l_434.f6), (l_441 != (void*)0))), l_446), 3))))
    { /* block id: 273 */
        struct S0 l_449 = {-152,0xD97CFE25,8,0x715F,-1,0U,4294967295U,0x5EECF91C,0,1};
        struct S0 *l_453 = &l_449;
        union U1 l_454 = {2U};
        int32_t l_455 = 1;
        int16_t l_477 = 0;
        (*l_446) = p_36;
        if (p_37)
        { /* block id: 275 */
            (*l_446) = (safe_lshift_func_int16_t_s_s(p_36, p_37));
            return l_449;
        }
        else
        { /* block id: 278 */
            uint16_t l_450 = 0x9DD5;
            l_450 = p_37;
        }
        if (((safe_mod_func_uint16_t_u_u((&l_449 == l_453), __builtin_popcountll((func_55(l_454, l_454.f0) | l_449.f1)))) == (l_455 <= p_37)))
        { /* block id: 281 */
            int32_t *l_456 = (void*)0;
            (**l_443) = l_456;
            for (l_434.f8 = 0; (l_434.f8 != 27); l_434.f8 = safe_add_func_int16_t_s_s(l_434.f8, 1))
            { /* block id: 285 */
                int16_t l_469 = 0x58DA;
                union U1 l_470 = {4294967293U};
                for (l_434.f1 = 0; (l_434.f1 < (-29)); l_434.f1 = safe_sub_func_uint32_t_u_u(l_434.f1, 1))
                { /* block id: 288 */
                    uint32_t l_465 = 0x1F566A28;
                    int32_t *l_466 = &l_449.f9;
                    if (p_36)
                        break;
                    (*l_466) = ((safe_add_func_int16_t_s_s((safe_add_func_int16_t_s_s(l_465, 0x6191)), p_37)) > l_449.f7);
                }
                (*l_446) ^= ((p_37 | ((1U < p_36) <= p_37)) == func_55(l_454, (!((l_449.f6 ^ 0xC449) != p_36))));
                (*l_446) = (p_36 ^ ((!((0xE6BF356E > 0xCCBC7F95) == 0x9206)) > (__builtin_parity(l_469) && func_55(l_470, __builtin_popcountl(l_470.f1)))));
                if (p_36)
                    continue;
            }
        }
        else
        { /* block id: 296 */
            uint32_t l_482 = 0x6BDFC17A;
            int32_t *l_489 = &l_455;
            for (l_449.f7 = 10; (l_449.f7 <= 21); l_449.f7 = safe_add_func_int16_t_s_s(l_449.f7, 1))
            { /* block id: 299 */
                union U2 **l_475 = (void*)0;
                union U2 ***l_474 = &l_475;
                union U2 ****l_473 = &l_474;
                union U2 *****l_476 = &l_473;
                int32_t *l_479 = &l_449.f9;
                (*l_476) = l_473;
                (*l_446) = func_70(l_477, l_478, l_479);
                (*l_479) = (0x8E6C && __builtin_ia32_crc32qi((safe_lshift_func_uint16_t_u_s(l_482, (0x0DBD ^ (((__builtin_ffs(p_36) && __builtin_popcountll((safe_div_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((p_37 & (*l_479)), ((((p_36 > 0x2F89448A) != 1U) & l_449.f9) < (-4)))), p_36)))) == p_36) <= p_36)))), p_36));
            }
            (*l_446) |= (safe_div_func_uint32_t_u_u(func_70(p_36, l_482, l_489), 0x17FCE800));
        }
        (****l_441) = &p_37;
        /* statement id: 306 */
        assert (l_445 == &p_37);
    }
    else
    { /* block id: 307 */
        uint16_t l_493 = 1U;
        int8_t l_499 = 0x94;
        int8_t *l_498 = &l_499;
        int8_t **l_497 = &l_498;
        int8_t ***l_496 = &l_497;
        struct S0 **l_507 = &l_435;
        int8_t l_536 = 0x7E;
        if ((~(((safe_add_func_uint16_t_u_u(l_493, (p_37 >= p_36))) && p_36) | l_493)))
        { /* block id: 308 */
            int8_t *l_500 = &l_499;
            (**l_443) = &p_37;
            /* statement id: 309 */
            assert (l_445 == &p_37);
            (*l_446) ^= (((8 < (p_36 || (((safe_rshift_func_uint16_t_u_s((((l_496 == &l_497) == (p_37 <= (l_500 != (void*)0))) & (safe_rshift_func_uint16_t_u_u(8U, (*****l_441)))), 5)) != l_499) | 0x6352B671))) <= 0x02676754) & l_503);
        }
        else
        { /* block id: 311 */
            struct S0 *l_511 = &l_434;
            int32_t l_512 = 2;
            union U1 l_515 = {0x56B5A29B};
            int32_t **l_518 = &l_445;
            int32_t l_527 = 0xCFEEC7AE;
            for (p_36 = (-25); (p_36 <= 48); p_36 = safe_add_func_uint32_t_u_u(p_36, 6))
            { /* block id: 314 */
                struct S0 l_506 = {259,-5,-1,1,-9,1U,0x9628E17E,0x5F3A32B4,0xB580,-1};
                union U2 l_510 = {0};
                union U2 *l_509 = &l_510;
                union U2 **l_508 = &l_509;
                struct S0 ***l_523 = &l_507;
                union U1 l_524 = {0xB011D3AD};
                (*l_435) = l_506;
                (*l_446) = ((-1) || ((l_507 == l_507) == p_36));
                (*l_508) = p_35;
                /* statement id: 317 */
                assert (l_510.f0 == 0);
                assert (l_509 == 0);
                if (p_37)
                { /* block id: 318 */
                    (*l_507) = l_511;
                    if (p_36)
                        continue;
                    p_37 = ((p_36 && l_512) || p_37);
                }
                else
                { /* block id: 322 */
                    union U2 *l_520 = &l_510;
                    int32_t l_521 = 5;
                    struct S0 ***l_522 = &l_507;
                    (*l_446) &= ((safe_div_func_int16_t_s_s(((func_55(l_515, ((safe_rshift_func_uint16_t_u_u(p_37, 0)) || (__builtin_ffsl((((***l_441) == l_518) | (!((void*)0 != l_520)))) > 0U))) <= p_36) > l_521), (-9))) ^ p_37);
                    (*l_446) = p_37;
                    if ((l_522 == l_523))
                    { /* block id: 325 */
                        uint16_t l_525 = 6U;
                        (*l_511) = (*l_511);
                        if (p_37)
                            continue;
                        (*l_446) = func_55(l_524, p_37);
                        (*l_446) ^= (0x03A75E27 < (l_525 < (p_36 >= p_37)));
                    }
                    else
                    { /* block id: 330 */
                        struct S0 l_526 = {132,0x72B20218,0x0280,0xF1CC,1,0xE3838A26,0x72854C02,0xEC201F33,0x5825,1};
                        int32_t ***l_528 = &l_444;
                        (***l_523) = (***l_522);
                        l_520 = p_35;
                        /* statement id: 332 */
                        assert (l_520 == 0);
                        (***l_523) = l_526;
                        (*l_446) = (p_37 <= (((l_528 != (void*)0) > l_521) < p_36));
                    }
                    /* facts after branching */
                    assert (l_520 == 0 || l_520 == &l_510);
                }
            }
            l_536 &= (2 || (safe_rshift_func_int16_t_s_u(((((void*)0 == l_533) && (-10)) == (p_37 <= (safe_lshift_func_int16_t_s_s(p_36, 9)))), 7)));
            for (l_503 = 7; (l_503 <= 2); l_503 = safe_sub_func_int16_t_s_s(l_503, 1))
            { /* block id: 341 */
                uint16_t l_561 = 0x4543;
                uint32_t l_562 = 0U;
                for (l_434.f3 = 0; (l_434.f3 < 23); l_434.f3 = safe_add_func_uint32_t_u_u(l_434.f3, 4))
                { /* block id: 344 */
                    int8_t *l_560 = &l_536;
                    int32_t l_563 = (-1);
                    l_563 &= (safe_unary_minus_func_uint16_t_u((safe_div_func_int32_t_s_s(((safe_div_func_int16_t_s_s(__builtin_clzl((((p_37 < (1U < (safe_rshift_func_uint16_t_u_u(p_36, 2)))) < __builtin_popcountll(p_36)) != (safe_rshift_func_int16_t_s_u(((safe_add_func_int16_t_s_s((safe_add_func_uint32_t_u_u(p_37, (!p_36))), (!(safe_sub_func_int16_t_s_s((l_560 == (void*)0), l_561))))) ^ p_36), p_36)))), 1U)) > 3), l_562))));
                }
            }
        }
        /* facts after branching */
        assert (l_445 == 0 || l_445 == &p_37);
        l_564 = (-2);
    }
    /* facts after branching */
    assert (l_445 == 0 || l_445 == &p_37);
    for (l_434.f7 = (-11); (l_434.f7 >= (-17)); l_434.f7 = safe_sub_func_int32_t_s_s(l_434.f7, 7))
    { /* block id: 353 */
        struct S0 l_569 = {-196,0x89EBD89B,0x03B1,-7,0,0x5B5E9356,1U,0x6D6BC9B8,0,0};
        if ((*l_446))
            break;
        for (p_37 = 11; (p_37 >= 17); p_37 = safe_add_func_int32_t_s_s(p_37, 5))
        { /* block id: 357 */
            l_570 = l_569;
        }
    }
    return l_571;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * func_38(int8_t * p_39, union U2 * p_40)
{ /* block id: 216 */
    int16_t l_356 = 0xFA0B;
    int32_t *l_360 = (void*)0;
    int32_t **l_359 = &l_360;
    int32_t ***l_358 = &l_359;
    int32_t ****l_357 = &l_358;
    union U2 l_385 = {0};
    union U2 *l_384 = &l_385;
    struct S0 l_419 = {-95,0xFE31A3DC,0x2723,-1,0,0x3935D645,0x8AD08AB2,0xEA23E7ED,0x1D9B,1};
    int32_t *l_421 = (void*)0;
    uint16_t l_422 = 0xC085;
    int32_t *l_423 = &l_419.f9;
    union U2 *l_424 = &l_385;
    union U2 *l_425 = &l_385;
    union U2 *l_426 = &l_385;
    union U2 *l_427 = &l_385;
    union U2 *l_428 = &l_385;
    union U2 *l_429 = &l_385;
    union U2 *l_430 = &l_385;
    union U2 *l_431 = &l_385;
    union U2 *l_432 = &l_385;
    union U2 *l_433 = (void*)0;
    if (l_356)
    { /* block id: 217 */
        int32_t *****l_361 = (void*)0;
        int32_t *****l_362 = (void*)0;
        int32_t *****l_363 = &l_357;
        union U2 l_365 = {0};
        union U2 *l_364 = &l_365;
        union U2 *l_386 = &l_365;
        union U2 *l_387 = &l_385;
        struct S0 l_390 = {-109,0,0x0051,0,0xC10A0099,1U,0xDA6F13B9,0x4B3D6CBA,-8,4};
        int8_t *l_399 = (void*)0;
        int8_t **l_398 = &l_399;
        (*l_363) = l_357;
        p_40 = l_364;
        /* statement id: 219 */
        assert (p_40 == &l_365);
        assert (l_365.f0 == 0);
        for (l_356 = (-18); (l_356 >= (-23)); l_356 = safe_sub_func_uint32_t_u_u(l_356, 1))
        { /* block id: 222 */
            uint32_t l_369 = 0xA989546E;
            union U1 l_370 = {4294967295U};
            uint32_t l_371 = 4294967295U;
            struct S0 l_374 = {99,0x9225A238,-7,0xB3A8,0x0F250EA4,4294967290U,0xF99ECF71,0xB1AB868E,0xF515,0x4634641B};
            union U2 *l_383 = &l_365;
            int32_t *l_397 = &l_390.f1;
            if (((~l_369) || (func_55(func_58(l_369, (*p_40), l_370), l_371) != (5 & l_370.f1))))
            { /* block id: 223 */
                int32_t l_373 = 5;
                int32_t *l_372 = &l_373;
                struct S0 *l_375 = &l_374;
                union U2 **l_382 = &l_364;
                (*l_372) &= 0xDFDF90A1;
                (*l_372) |= (0U <= 0xEE6D5270);
                (*l_375) = l_374;
                for (l_374.f5 = 27; (l_374.f5 != 57); l_374.f5 = safe_add_func_int16_t_s_s(l_374.f5, 1))
                { /* block id: 229 */
                    int16_t l_380 = (-1);
                    union U2 *l_388 = &l_385;
                    l_374.f9 = l_374.f9;
                    if ((safe_lshift_func_uint16_t_u_u(l_380, (*l_372))))
                    { /* block id: 231 */
                        union U2 ***l_381 = (void*)0;
                        union U2 *l_389 = (void*)0;
                        l_382 = &p_40;
                        /* statement id: 232 */
                        assert (l_382 == &p_40);
                        return l_389;
                        /* statement id: 233 */
                        //assert (func_38_rv == 0);
                    }
                    else
                    { /* block id: 234 */
                        int32_t *l_391 = &l_373;
                        (*l_382) = func_44((*l_372), l_390);
                        /* statement id: 235 */
                        assert (l_364 == 0);
                        (***l_357) = l_391;
                        /* statement id: 236 */
                        assert (l_360 == &l_373);
                    }
                    /* facts after branching */
                    assert (l_360 == &l_373);
                    assert (l_364 == 0);
                }
                /* facts after for loop */
                //assert (l_360 == &l_373 || l_360 == &l_390.f1 || l_360 == dangling || l_360 == 0);
            }
            else
            { /* block id: 239 */
                int32_t *l_392 = &l_390.f9;
                (*l_392) = 0;
            }
            for (l_390.f4 = 0; (l_390.f4 < 13); l_390.f4 = safe_add_func_uint32_t_u_u(l_390.f4, 1))
            { /* block id: 244 */
                union U1 *l_395 = &l_370;
                union U1 **l_396 = &l_395;
                int8_t **l_400 = &l_399;
                int32_t l_401 = 1;
                (*l_396) = l_395;
                (****l_363) = l_397;
                /* statement id: 246 */
                assert (l_360 == &l_390.f1);
                l_400 = l_398;
                (*l_397) ^= l_401;
            }
        }
        /* facts after for loop */
        //assert (l_360 == &l_390.f1 || l_360 == dangling || l_360 == 0);
        assert (l_364 == 0 || l_364 == &l_365);
        assert (l_385.f0 == 0);
    }
    else
    { /* block id: 251 */
        int32_t l_405 = 0xEA60D0EF;
        int32_t *l_404 = &l_405;
        struct S0 l_406 = {-36,0xFC5ACD0A,0xEE8D,-6,-1,4294967286U,0xEFD67946,-7,1,1};
        int32_t *****l_413 = (void*)0;
        int32_t *l_416 = &l_406.f7;
        for (l_356 = 0; (l_356 <= (-28)); l_356 = safe_sub_func_uint32_t_u_u(l_356, 1))
        { /* block id: 254 */
            struct S0 *l_407 = (void*)0;
            struct S0 *l_408 = &l_406;
            int32_t l_409 = (-7);
            (*l_359) = l_404;
            /* statement id: 255 */
            assert (l_360 == &l_405);
            (*l_408) = l_406;
            if (l_409)
                break;
        }
        /* facts after for loop */
        assert (l_360 == &l_405 || l_360 == 0);
        (*l_404) = (*l_404);
        (*l_416) ^= ((((safe_unary_minus_func_uint32_t_u(__builtin_ffsl((*l_404)))) ^ (__builtin_ia32_crc32qi((*l_404), (((((*l_404) == (*l_404)) & (*l_404)) > (safe_mod_func_uint32_t_u_u((l_413 != &l_357), (safe_add_func_int32_t_s_s((-1), (*l_404)))))) && (*l_404))) != (*l_404))) || (*l_404)) || 0x1BB9BA46);
        for (l_406.f1 = 24; (l_406.f1 > (-15)); l_406.f1 = safe_sub_func_uint16_t_u_u(l_406.f1, 5))
        { /* block id: 263 */
            struct S0 *l_420 = &l_419;
            (*l_420) = l_419;
        }
    }
    /* facts after branching */
    //assert (p_40 == 0 || p_40 == dangling);
    //assert (l_360 == dangling || l_360 == 0);
    assert (l_385.f0 == 0);
    (*l_423) &= (((void*)0 != l_421) == ((__builtin_ffsll(l_422) | l_356) | l_419.f8));
    (*l_423) ^= 1;
    (**l_358) = l_421;
    /* statement id: 269 */
    assert (l_360 == 0);
    return l_433;
    /* statement id: 270 */
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t * func_41(union U2 * p_42, int8_t * p_43)
{ /* block id: 106 */
    int8_t l_208 = 0x51;
    int32_t l_213 = 0x53BD1B8E;
    int32_t l_215 = 0x437D32D8;
    int32_t *l_214 = &l_215;
    int16_t l_216 = 1;
    int32_t l_218 = 0xEAEA3061;
    int32_t *l_217 = &l_218;
    struct S0 l_220 = {134,1,-4,6,0x4AA91B6E,0x5F498FB1,0U,0x3CC005B2,-3,0x503560D2};
    struct S0 *l_219 = &l_220;
    struct S0 **l_221 = (void*)0;
    struct S0 **l_222 = (void*)0;
    uint32_t l_234 = 1U;
    uint16_t l_236 = 0xFB8A;
    uint32_t l_273 = 0xF7BD2AB7;
    int16_t l_275 = 1;
    union U1 l_277 = {4294967295U};
    union U1 *l_276 = &l_277;
    int32_t **l_298 = &l_217;
    int32_t ***l_297 = &l_298;
    int32_t ****l_296 = &l_297;
    (*l_217) &= (safe_div_func_int16_t_s_s((((~l_208) > (((safe_rshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s(l_208, (l_213 != func_70((p_43 != &l_208), l_208, l_214)))), l_216)) < l_213) || (*l_214))) && (*l_214)), l_208));
    l_219 = l_219;
    for (l_220.f6 = (-7); (l_220.f6 > 3); l_220.f6 = safe_add_func_uint16_t_u_u(l_220.f6, 4))
    { /* block id: 111 */
        struct S0 l_225 = {2,0,0x5DBE,0xBEAE,1,0xC1F30112,4294967295U,-2,1,0x42B6AA69};
        struct S0 *l_226 = (void*)0;
        struct S0 *l_227 = &l_225;
        int32_t *l_235 = (void*)0;
        int32_t **l_246 = (void*)0;
        int32_t ***l_245 = &l_246;
        union U1 *l_299 = &l_277;
        int32_t l_324 = 0;
        struct S0 ***l_340 = &l_221;
        int32_t l_355 = (-5);
        (*l_227) = l_225;
    }
    return p_43;
    /* statement id: 215 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * func_44(int32_t  p_45, struct S0  p_46)
{ /* block id: 37 */
    int32_t l_49 = 0x1FDA6603;
    int32_t *l_48 = &l_49;
    union U2 l_51 = {0};
    union U2 *l_50 = &l_51;
    union U2 *l_52 = (void*)0;
    (*l_48) ^= 0x4E69A457;
    return l_52;
    /* statement id: 39 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t * func_53(int8_t  p_54)
{ /* block id: 40 */
    int16_t l_64 = 0x7F14;
    union U2 l_75 = {0};
    union U2 *l_74 = &l_75;
    int8_t l_77 = 0xC4;
    int8_t *l_76 = &l_77;
    int32_t l_79 = 0x2C3E505C;
    int32_t *l_78 = &l_79;
    union U1 l_101 = {0xA55A6935};
    uint16_t l_122 = 1U;
    struct S0 l_124 = {11,0x2BF0D6E7,4,0x501C,-7,0xB4AB819B,4294967295U,0x6426D5D5,1,0};
    struct S0 *l_123 = &l_124;
    int8_t *l_198 = &l_77;
    int8_t *l_199 = &l_77;
    int8_t *l_200 = &l_77;
    int8_t *l_201 = &l_77;
    int8_t *l_202 = &l_77;
    int8_t *l_203 = &l_77;
    int8_t *l_204 = (void*)0;
    if (((((func_55(func_58(((safe_sub_func_uint16_t_u_u(((&p_54 != (void*)0) >= l_64), (safe_sub_func_int32_t_s_s((l_64 ^ 4294967295U), (safe_div_func_uint32_t_u_u(((!((func_70(__builtin_popcount((l_64 && (((void*)0 == l_74) || (l_76 != (void*)0)))), l_64, l_78) <= p_54) ^ 0U)) || (*l_78)), 8)))))) & p_54), (*l_74), l_101), l_77) & 0x72592CB3) || (*l_78)) | l_64) & l_122))
    { /* block id: 68 */
        struct S0 **l_125 = &l_123;
        union U1 l_143 = {4294967295U};
        int32_t *l_182 = &l_124.f7;
        (*l_125) = l_123;
        (*l_78) = ((!(safe_sub_func_int16_t_s_s((*l_78), 0xCDC6))) < 0U);
        if ((safe_div_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u((__builtin_clzl(((safe_div_func_int16_t_s_s((((0xFC87 == (*l_78)) >= (0xC46319CD == 0xB8F5B537)) > p_54), ((func_55(func_58((((safe_div_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((safe_div_func_int16_t_s_s(p_54, (*l_78))), func_55(l_143, p_54))), 0xE172)) | 0x35A52B8E) <= (*l_78)), (*l_74), l_101), (*l_78)) | l_143.f1) ^ (*l_78)))) && (*l_78))) & p_54), (*l_78))), p_54)))
        { /* block id: 71 */
            int32_t **l_144 = &l_78;
            int8_t **l_154 = &l_76;
            union U2 *l_160 = (void*)0;
            (*l_144) = &l_79;
            for (l_64 = 0; (l_64 != 24); l_64 = safe_add_func_uint32_t_u_u(l_64, 6))
            { /* block id: 75 */
                int32_t *l_147 = &l_124.f9;
                struct S0 l_152 = {-214,0x4E592539,0x12D8,0,1,0xE2A38A8C,0x10D83277,0x48F12A9C,0x8C32,1};
                int32_t ***l_157 = &l_144;
                (*l_147) ^= (*l_78);
                for (l_124.f7 = 0; (l_124.f7 == (-10)); l_124.f7 = safe_sub_func_int32_t_s_s(l_124.f7, 1))
                { /* block id: 79 */
                    int32_t l_155 = 0x8F595BA4;
                    union U2 **l_161 = (void*)0;
                    union U2 **l_162 = (void*)0;
                    union U2 **l_163 = &l_74;
                    int32_t ***l_181 = &l_144;
                    for (l_122 = 0; (l_122 <= 42); l_122 = safe_add_func_int32_t_s_s(l_122, 1))
                    { /* block id: 82 */
                        struct S0 *l_153 = &l_152;
                        int32_t l_156 = (-2);
                        int32_t ****l_158 = (void*)0;
                        int32_t ****l_159 = &l_157;
                        (*l_153) = l_152;
                        (*l_78) = (l_154 == l_154);
                        (*l_78) = ((__builtin_bswap32(l_155) <= l_156) & p_54);
                        (*l_159) = l_157;
                    }
                    (*l_163) = l_160;
                    /* statement id: 88 */
                    assert (l_74 == 0);
                    l_124.f1 ^= ((safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u((safe_add_func_int32_t_s_s(((((safe_rshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_u(((safe_rshift_func_int16_t_s_u((*l_147), p_54)) || (-8)), 5)), (**l_144))) > 0x7407BC3B) | (*l_182)) ^ (*l_78)), (***l_157))), (***l_181))), (-8))) <= p_54);
                }
            }
            /* facts after for loop */
            assert (l_74 == 0 || l_74 == &l_75);
        }
        else
        { /* block id: 92 */
            union U1 l_188 = {4294967292U};
            int32_t *l_189 = &l_124.f9;
            (*l_78) = (safe_div_func_uint32_t_u_u((((~((safe_sub_func_uint16_t_u_u(func_55(l_188, func_70(p_54, p_54, l_189)), ((&l_123 != l_125) != p_54))) && p_54)) | p_54) > 0x8C2D), (*l_182)));
        }
        /* facts after branching */
        assert (l_74 == 0 || l_74 == &l_75);
    }
    else
    { /* block id: 95 */
        int32_t *l_190 = &l_124.f7;
        int32_t **l_191 = (void*)0;
        int32_t **l_192 = &l_190;
        (*l_192) = l_190;
        for (l_124.f5 = 0; (l_124.f5 >= 4); l_124.f5 = safe_add_func_uint32_t_u_u(l_124.f5, 2))
        { /* block id: 99 */
            int32_t *l_195 = &l_124.f7;
            union U1 *l_197 = &l_101;
            union U1 **l_196 = &l_197;
            (*l_192) = l_195;
            (*l_196) = &l_101;
            l_78 = (*l_192);
            /* statement id: 102 */
            assert (l_78 == &l_124.f7);
        }
        /* facts after for loop */
        assert (l_78 == &l_124.f7 || l_78 == &l_79);
    }
    /* facts after branching */
    //assert (l_75.f0 == dangling || l_75.f0 == 0);
    assert (l_74 == 0 || l_74 == &l_75);
    assert (l_78 == &l_124.f7 || l_78 == &l_79);
    return l_204;
    /* statement id: 105 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_55(union U1  p_56, uint16_t  p_57)
{ /* block id: 63 */
    int32_t l_108 = 0x0F05760D;
    int32_t *l_107 = &l_108;
    struct S0 l_109 = {194,7,0x6EF7,0x18C3,-8,0xA5F0D236,0xE1CF7F80,-1,0x961B,1};
    struct S0 *l_110 = &l_109;
    uint32_t l_116 = 8U;
    int32_t **l_121 = (void*)0;
    int32_t ***l_120 = &l_121;
    l_107 = l_107;
    (*l_110) = l_109;
    (*l_107) = ((safe_unary_minus_func_int16_t_s((safe_mod_func_uint32_t_u_u((safe_mod_func_int32_t_s_s((((__builtin_ffs(l_116) || (((void*)0 != &l_109) || (safe_mod_func_uint32_t_u_u(p_56.f0, (safe_unary_minus_func_int16_t_s((l_120 != &l_121))))))) || (0xACE7 && p_56.f2)) >= p_56.f2), (*l_107))), p_56.f2)))) || (*l_107));
    return p_56.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_58(int16_t  p_59, union U2  p_60, union U1  p_61)
{ /* block id: 58 */
    uint32_t l_102 = 0xE9507407;
    int32_t l_103 = (-5);
    int32_t **l_104 = (void*)0;
    int32_t ***l_105 = &l_104;
    int32_t *l_106 = &l_103;
    l_103 &= l_102;
    (*l_105) = l_104;
    (*l_106) |= p_59;
    return p_61;
    /* statement id: 62 */
    //assert (func_58_rv.f3 == dangling);
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_70(uint32_t  p_71, int16_t  p_72, int32_t * p_73)
{ /* block id: 41 */
    int8_t l_85 = 0x05;
    int8_t *l_91 = &l_85;
    int8_t **l_90 = &l_91;
    int32_t l_94 = 0;
    int32_t *l_93 = &l_94;
    for (p_72 = (-29); (p_72 != (-11)); p_72 = safe_add_func_uint16_t_u_u(p_72, 6))
    { /* block id: 44 */
        int8_t *l_86 = &l_85;
        int32_t l_89 = (-1);
        int8_t ***l_92 = &l_90;
        int32_t *l_95 = &l_94;
        (*p_73) = (((__builtin_popcountll((0xF3FD26F3 & ((*p_73) <= (!0x79E4C0C5)))) < (l_85 & (l_86 != (void*)0))) <= 7U) || (safe_div_func_uint32_t_u_u(p_72, l_89)));
        (*l_92) = l_90;
        l_95 = l_93;
    }
    for (l_94 = 0; (l_94 < (-16)); l_94 = safe_sub_func_int32_t_s_s(l_94, 3))
    { /* block id: 51 */
        int8_t *l_100 = &l_85;
        (*p_73) = (safe_rshift_func_int16_t_s_u(0xDF38, ((*l_90) == l_100)));
        (*p_73) &= 2;
        (*p_73) ^= (*l_93);
    }
    (*p_73) ^= 1;
    return (*p_73);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 181
   depth: 1, occurrence: 17
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 29
breakdown:
   indirect level: 0, occurrence: 17
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 16
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 1

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 174
   depth: 2, occurrence: 26
   depth: 3, occurrence: 5
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 3
   depth: 10, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 205

XXX times a variable address is taken: 159
XXX times a pointer is dereferenced on RHS: 89
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 3
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 98
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 6
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 577

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 363
   level: 2, occurrence: 60
   level: 3, occurrence: 57
   level: 4, occurrence: 31
   level: 5, occurrence: 14
XXX number of pointers point to pointers: 71
XXX number of pointers point to scalars: 80
XXX number of pointers point to structs: 16
XXX percent of pointers has null in alias set: 29.3
XXX average alias set size: 1.16

XXX times a non-volatile is read: 603
XXX times a non-volatile is write: 274
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 142
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 30
   depth: 2, occurrence: 25
   depth: 3, occurrence: 23
   depth: 4, occurrence: 14
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 20.4
XXX percentage an existing variable is used: 79.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

