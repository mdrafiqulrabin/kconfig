/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1710274786
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 31;
   const signed f1 : 24;
   signed f2 : 26;
   unsigned f3 : 30;
   const unsigned f4 : 21;
   uint16_t  f5;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_29(void);
static int32_t  func_36(const int16_t  p_37, uint32_t  p_38, uint16_t  p_39, const uint32_t  p_40, int16_t  p_41);
inline static int16_t  func_42(int32_t  p_43, uint32_t  p_44, uint32_t  p_45);
inline static uint16_t  func_48(float  p_49);
inline static float  func_59(uint32_t  p_60, int32_t  p_61, int32_t  p_62, int32_t  p_63, int32_t  p_64);
static uint32_t  func_65(uint16_t  p_66, uint32_t  p_67, const int16_t  p_68);
static int32_t * func_69(const int16_t  p_70);
static int32_t  func_77(struct S0  p_78);
inline static struct S0  func_79(uint32_t  p_80, int32_t  p_81, int32_t  p_82, int32_t  p_83, const int32_t * p_84);
inline static int16_t  func_89(int32_t * p_90);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_29(void)
{ /* block id: 36 */
    int32_t l_30[9][2] = {{0xC7008B15L,(-1L)},{0xADF62858L,0xCD430964L},{0xADF62858L,(-1L)},{0xC7008B15L,0xADF62858L},{(-1L),0xCD430964L},{0x314A5EA9L,0x314A5EA9L},{0xC7008B15L,0x314A5EA9L},{0x314A5EA9L,0xCD430964L},{(-1L),0xADF62858L}};
    int32_t **l_712 = (void*)0;
    int32_t ***l_711[7];
    float l_806 = 0x0.8p+1;
    float *l_805 = &l_806;
    float **l_804 = &l_805;
    float ***l_803 = &l_804;
    float l_820 = 0x1.Bp-1;
    uint16_t l_889 = 0x1D01L;
    int16_t l_918[6][1][6] = {{{0x434FL,0xB94BL,6L,0xACE5L,0x60FAL,0x06ECL}},{{0x06ECL,0xB4D7L,0x2FEDL,0xB4D7L,0x06ECL,0xB94BL}},{{0x06ECL,0x434FL,0xB4D7L,0xACE5L,0x93A9L,0x93A9L}},{{0x434FL,0x60FAL,0x60FAL,0x434FL,0x2FEDL,0x93A9L}},{{6L,0x93A9L,0xB4D7L,0xB94BL,0x93A9L,0x434FL}},{{0xB94BL,0xACE5L,0xB94BL,0xB4D7L,0x93A9L,6L}}};
    int32_t ****l_947 = &l_711[3];
    int32_t *****l_946[8] = {&l_947,&l_947,&l_947,&l_947,&l_947,&l_947,&l_947,&l_947};
    float l_952 = (-0x1.3p+1);
    int32_t l_953[2];
    int i, j, k;
    for (i = 0; i < 7; i = i + 1)
        l_711[i] = &l_712;
    for (i = 0; i < 2; i = i + 1)
        l_953[i] = 0x31793F82L;
    for (l_30[5][0] = 0; (l_30[5][0] < 8); l_30[5][0] += 4)
    { /* block id: 39 */
        int32_t l_33 = 2L;
        uint16_t l_434[3][2][10] = {{{1UL,1UL,1UL,1UL,8UL,1UL,1UL,1UL,1UL,8UL},{1UL,1UL,1UL,1UL,8UL,1UL,1UL,1UL,1UL,8UL}},{{1UL,1UL,1UL,1UL,8UL,1UL,1UL,1UL,1UL,8UL},{1UL,1UL,1UL,1UL,8UL,1UL,1UL,1UL,1UL,8UL}},{{1UL,1UL,1UL,1UL,8UL,1UL,1UL,1UL,1UL,8UL},{1UL,1UL,1UL,1UL,8UL,1UL,1UL,1UL,1UL,8UL}}};
        int32_t l_734 = 0x9D7CA3E4L;
        float l_752 = 0x0.Cp+1;
        float *l_751 = &l_752;
        float **l_750 = &l_751;
        float ***l_749 = &l_750;
        int32_t *l_754 = &l_734;
        int32_t l_771 = 0x4F045915L;
        struct S0 l_773 = {7973,2140,-5421,23068,581,0xF56BL};
        struct S0 *l_772 = &l_773;
        int32_t **l_780 = &l_754;
        int32_t l_791 = (-10L);
        uint32_t l_795 = 4294967295UL;
        int32_t l_855[3];
        uint16_t l_931[3][4] = {{0xE69AL,65530UL,65530UL,0xE69AL},{65530UL,0xE69AL,65530UL,65530UL},{0xE69AL,0xE69AL,9UL,0xE69AL}};
        float l_943 = (-0x1.Ep+1);
        int i, j, k;
        for (i = 0; i < 3; i = i + 1)
            l_855[i] = 0x5CAEE140L;
        for (l_33 = 19; (l_33 < (-3)); l_33 -= 2)
        { /* block id: 42 */
            uint16_t l_50 = 0x4ADCL;
            const int32_t *l_739 = &l_30[5][0];
            int16_t l_740 = (-1L);
            int32_t l_744[10] = {0x969E49C3L,0x969E49C3L,0x969E49C3L,0x969E49C3L,0x969E49C3L,0x969E49C3L,0x969E49C3L,0x969E49C3L,0x969E49C3L,0x969E49C3L};
            float ***l_753 = &l_750;
            int32_t *l_755 = &l_744[1];
            int32_t **l_781 = &l_754;
            int32_t ****l_784 = (void*)0;
            int32_t *****l_783 = &l_784;
            int i;
        }
        if (((((!((int16_t)(*l_754) << (int16_t)((uint16_t)(0L != 0x145603A9L) << (uint16_t)5))) ^ (((l_791 == (*l_754)) <= (~((uint16_t)l_795 - (uint16_t)(**l_780)))) && ((uint32_t)(*l_754) + (uint32_t)0xDFF3497DL))) & (*l_754)) > (*l_754)))
        { /* block id: 725 */
            uint16_t l_800 = 0xDC56L;
            float ***l_807 = &l_750;
            int32_t **l_849 = &l_754;
            for (l_771 = (-7); (l_771 >= (-9)); l_771 -= 6)
            { /* block id: 728 */
                int32_t l_812 = 0x5CAAC037L;
                const struct S0 *l_829 = (void*)0;
                const struct S0 **l_828 = &l_829;
                struct S0 **l_830 = &l_772;
            }
            (**l_750) = (-0x2.9p+1);
        }
        else
        { /* block id: 753 */
            float l_862[6] = {0x0.305B12p-50,0xD.3816D0p+53,0x0.305B12p-50,0x0.305B12p-50,0xD.3816D0p+53,0x0.305B12p-50};
            int32_t l_863 = 0x89A6525BL;
            const float l_876 = 0x2.8FB236p+20;
            struct S0 l_890 = {2871,-2634,1630,1452,768,1UL};
            struct S0 l_904 = {23492,-52,-6496,16819,1161,0UL};
            struct S0 *l_903 = &l_904;
            int i;
            (*l_754) = ((int32_t)1L + (int32_t)l_855[0]);
            for (l_734 = 29; (l_734 > (-18)); --l_734)
            { /* block id: 757 */
                const int32_t *l_860 = &l_791;
                int32_t *l_864[7][7] = {{&l_791,&l_30[3][1],&l_734,&l_734,&l_30[3][1],&l_791,(void*)0},{&l_33,(void*)0,(void*)0,&l_33,&l_33,(void*)0,(void*)0},{&l_30[3][1],(void*)0,&l_791,&l_30[3][1],&l_734,&l_734,&l_30[3][1]},{&l_33,(void*)0,&l_33,(void*)0,(void*)0,&l_791,&l_791},{&l_33,&l_30[3][1],&l_791,&l_30[3][1],&l_33,&l_791,&l_771},{&l_33,&l_791,(void*)0,&l_33,(void*)0,&l_791,&l_33},{&l_791,&l_771,(void*)0,&l_734,&l_771,&l_734,(void*)0}};
                int32_t ***l_867 = &l_780;
                uint32_t l_875 = 0xD80037AAL;
                struct S0 *l_878 = &l_773;
                uint32_t l_891[2];
                int i, j;
                for (i = 0; i < 2; i = i + 1)
                    l_891[i] = 18446744073709551610UL;
                for (l_33 = 0; (l_33 > 17); l_33 += 2)
                { /* block id: 760 */
                    int32_t **l_861 = &l_754;
                    if ((**l_780))
                        break;
                    (*l_861) = l_860;
                    /* statement id: 762 */
                    assert (l_754 == &l_791);
                }
                /* facts after for loop */
                assert (l_754 == &l_791 || l_754 == &l_863 || l_754 == &l_734);
                if ((l_863 ^ __builtin_clzl((*l_754))))
                { /* block id: 764 */
                    uint32_t l_870 = 0x43C43410L;
                    const int32_t *l_887 = &l_33;
                    struct S0 *l_901 = (void*)0;
                    l_863 = ((-7L) | (((uint32_t)((l_867 != &l_780) != func_36(((((int32_t)(func_36(func_77((*l_772)), l_870, l_870, __builtin_ia32_crc32qi((((int16_t)(**l_780) >> (int16_t)12) ^ ((int16_t)l_870 >> (int16_t)l_863)), l_863), (**l_780)) == l_875) % (int32_t)l_870) <= l_863) ^ l_863), (*l_860), (***l_867), l_863, (**l_780))) - (uint32_t)0x509B2C48L) && l_863));
                    if ((l_870 > l_870))
                    { /* block id: 766 */
                        int32_t *l_877 = &l_734;
                        struct S0 **l_879 = &l_878;
                        int32_t ****l_881 = (void*)0;
                        int32_t *****l_880 = &l_881;
                        (*l_780) = l_877;
                        /* statement id: 767 */
                        assert (l_754 == &l_734);
                        (*l_879) = l_878;
                        (*l_880) = (void*)0;
                    }
                    else
                    { /* block id: 770 */
                        int32_t ****l_886 = &l_711[0];
                        int32_t *****l_885 = &l_886;
                        int32_t **l_888 = &l_864[5][1];
                        l_863 = ((((l_870 < (__builtin_popcount((__builtin_parityl((**l_780)) < ((int16_t)func_48(((((**l_780) >= (***l_867)) < ((-(float)(l_863 >= (**l_780))) <= ((((void*)0 == l_885) > l_870) >= (*l_754)))) == 0xF.DD9D14p+8)) << (int16_t)l_870))) > l_870)) < (**l_780)) >= (*l_754)) == (*l_754));
                        (*l_780) = &l_863;
                        /* statement id: 772 */
                        assert (l_754 == &l_863);
                        (*l_888) = l_887;
                        l_863 = l_889;
                    }
                    /* facts after branching */
                    assert (l_754 == &l_863 || l_754 == &l_734);
                    if ((**l_780))
                    { /* block id: 776 */
                        uint32_t l_892 = 1UL;
                        int32_t l_898[2][8][1];
                        int i, j, k;
                        for (i = 0; i < 2; i = i + 1)
                        {
                            for (j = 0; j < 8; j = j + 1)
                            {
                                for (k = 0; k < 1; k = k + 1)
                                    l_898[i][j][k] = 0xF445B9AEL;
                            }
                        }
                        (**l_750) = (**l_780);
                        if (l_863)
                            continue;
                        l_791 = ((((((*l_887) <= (*l_754)) && func_42(((*l_887) ^ func_77(l_890)), l_891[0], l_890.f4)) < l_892) ^ 0x541C6AEDL) <= (*l_860));
                        l_898[1][7][0] = (__builtin_parity(((*l_750) == (void*)0)) ^ ((((int32_t)((*l_887) && (-1L)) - (int32_t)func_89((**l_867))) > (~((uint16_t)(*l_887) + (uint16_t)l_892))) & 4294967288UL));
                    }
                    else
                    { /* block id: 781 */
                        int16_t l_900 = (-6L);
                        struct S0 **l_902[9] = {(void*)0,(void*)0,&l_772,(void*)0,(void*)0,&l_772,(void*)0,(void*)0,&l_772};
                        int i;
                        l_900 = (-(int32_t)0x60952283L);
                        l_903 = l_901;
                        /* statement id: 783 */
                        assert (l_903 == 0);
                    }
                }
                else
                { /* block id: 785 */
                    int16_t l_910 = 0L;
                    for (l_33 = 21; (l_33 != 20); --l_33)
                    { /* block id: 788 */
                        struct S0 **l_907 = &l_878;
                        struct S0 ***l_908 = &l_907;
                        int32_t l_909 = (-1L);
                        const uint32_t l_913 = 0x9B4147E7L;
                        (*l_908) = l_907;
                        l_909 = 0x0176CCBEL;
                    }
                    return l_904.f2;
                }
                /* facts after branching */
                assert (l_754 == &l_863 || l_754 == &l_734);
                for (l_791 = 6; (l_791 != (-21)); l_791 -= 9)
                { /* block id: 797 */
                    uint32_t l_921 = 0xE554EDD6L;
                    float **l_932[9] = {&l_751,&l_751,&l_805,&l_751,&l_751,&l_805,&l_751,&l_751,&l_805};
                    int i;
                    for (l_904.f5 = 0; (l_904.f5 >= 7); l_904.f5 += 6)
                    { /* block id: 800 */
                        return l_918[2][0][5];
                    }
                }
                l_904.f2 = 0xAB26BB8AL;
            }
            /* facts after for loop */
            assert (l_754 == &l_863 || l_754 == &l_734);
            assert (l_903 == 0 || l_903 == &l_904);
        }
        /* facts after branching */
        //assert (l_754 == dangling || l_754 == &l_734);
        (*l_780) = func_69((__builtin_popcountl((((uint16_t)65535UL << (uint16_t)4) <= ((uint16_t)l_734 >> (uint16_t)12))) ^ (!__builtin_clz(l_791))));
        /* statement id: 816 */
        assert (l_754 == 0);
    }
    for (l_889 = 14; (l_889 > 49); ++l_889)
    { /* block id: 820 */
        int32_t *****l_948 = &l_947;
        int32_t l_949 = 0x9FED198FL;
        uint32_t l_950 = 0x41243B46L;
        float ****l_951 = &l_803;
        l_948 = l_946[7];
        l_949 = (((l_949 ^ ((void*)0 != (**l_947))) != l_950) && (&l_803 == l_951));
        if (l_949)
            continue;
    }
    return l_953[0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_36(const int16_t  p_37, uint32_t  p_38, uint16_t  p_39, const uint32_t  p_40, int16_t  p_41)
{ /* block id: 643 */
    int32_t l_691 = 0x6E0961FBL;
    int32_t *l_690 = &l_691;
    float *****l_702 = (void*)0;
    if (p_38)
    { /* block id: 644 */
        const int16_t l_686 = (-5L);
        float *l_687 = (void*)0;
        float l_689 = 0x2.A072F3p-40;
        float *l_688 = &l_689;
        int32_t **l_692 = &l_690;
        (*l_688) = func_48(__builtin_clzl(((uint16_t)l_686 + (uint16_t)l_686)));
        (*l_692) = l_690;
    }
    else
    { /* block id: 647 */
        struct S0 l_696 = {830,51,-4995,22188,1053,0xB75AL};
        float ***l_701 = (void*)0;
        float ****l_700 = &l_701;
        float *****l_699[6][9] = {{(void*)0,&l_700,&l_700,&l_700,(void*)0,&l_700,&l_700,&l_700,(void*)0},{&l_700,(void*)0,&l_700,(void*)0,&l_700,&l_700,(void*)0,&l_700,(void*)0},{&l_700,&l_700,(void*)0,&l_700,&l_700,&l_700,&l_700,&l_700,(void*)0},{(void*)0,(void*)0,(void*)0,&l_700,(void*)0,(void*)0,(void*)0,(void*)0,&l_700},{&l_700,&l_700,&l_700,&l_700,(void*)0,&l_700,&l_700,&l_700,(void*)0},{&l_700,(void*)0,(void*)0,&l_700,&l_700,&l_700,(void*)0,(void*)0,&l_700}};
        struct S0 *l_704[10][4] = {{&l_696,(void*)0,&l_696,(void*)0},{(void*)0,&l_696,&l_696,&l_696},{&l_696,&l_696,(void*)0,&l_696},{(void*)0,&l_696,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{&l_696,(void*)0,&l_696,(void*)0},{(void*)0,&l_696,&l_696,&l_696},{&l_696,&l_696,(void*)0,&l_696},{(void*)0,&l_696,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0}};
        struct S0 **l_703 = &l_704[0][1];
        int32_t **l_705 = &l_690;
        int i, j;
        l_696.f2 = ((((float)((!(func_77(l_696) >= (((float)((void*)0 != l_699[2][6]) + (float)(__builtin_clzll(p_38) != (((void*)0 != l_702) == p_40))) >= p_41))) == l_696.f0) - (float)0x9.E1B164p+72) > (-0x1.7p-1)) != l_696.f3);
        (*l_703) = &l_696;
        (*l_705) = (void*)0;
        /* statement id: 650 */
        assert (l_690 == 0);
    }
    /* facts after branching */
    assert (l_690 == 0 || l_690 == &l_691);
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_42(int32_t  p_43, uint32_t  p_44, uint32_t  p_45)
{ /* block id: 638 */
    int32_t *l_675 = (void*)0;
    int32_t **l_674 = &l_675;
    int32_t l_676[8][6][5] = {{{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)}},{{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)}},{{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)}},{{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)}},{{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)}},{{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)}},{{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)}},{{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)},{0L,0x26B42DBFL,0L,0x26B42DBFL,0L},{(-6L),(-6L),(-6L),(-6L),(-6L)}}};
    int32_t *l_681 = (void*)0;
    int32_t l_683 = 0L;
    int32_t *l_682 = &l_683;
    int i, j, k;
    (*l_674) = func_69((0x32E1L <= 0x2B06L));
    for (p_43 = 0; p_43 < 8; p_43 += 1)
    {
        for (p_45 = 0; p_45 < 6; p_45 += 1)
        {
            for (p_44 = 0; p_44 < 5; p_44 += 1)
            {
                l_676[p_43][p_45][p_44] = 0L;
            }
        }
    }
    (*l_682) = (6L & ((((int16_t)(-2L) << (int16_t)l_676[4][1][1]) && __builtin_ia32_crc32qi(p_45, (0x68EAF7ABL >= p_44))) < (p_43 & 0x54CBL)));
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_48(float  p_49)
{ /* block id: 539 */
    int32_t l_533 = (-7L);
    int32_t *l_532 = &l_533;
    int32_t **l_534[8][3] = {{&l_532,&l_532,&l_532},{&l_532,&l_532,&l_532},{&l_532,&l_532,&l_532},{&l_532,&l_532,&l_532},{&l_532,&l_532,&l_532},{&l_532,&l_532,&l_532},{&l_532,&l_532,&l_532},{&l_532,&l_532,&l_532}};
    int32_t *l_535 = (void*)0;
    int32_t ***l_548 = &l_534[6][1];
    uint32_t l_560 = 0x9C1325FCL;
    float l_572 = 0x0.072B64p+58;
    float *l_571[10][8][3] = {{{&l_572,&l_572,(void*)0},{&l_572,&l_572,&l_572},{(void*)0,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,(void*)0,&l_572},{(void*)0,&l_572,(void*)0},{&l_572,&l_572,(void*)0},{(void*)0,&l_572,&l_572}},{{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,(void*)0,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{(void*)0,&l_572,&l_572},{&l_572,(void*)0,&l_572}},{{&l_572,&l_572,&l_572},{(void*)0,(void*)0,&l_572},{(void*)0,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,(void*)0,(void*)0},{&l_572,&l_572,&l_572},{(void*)0,(void*)0,&l_572},{(void*)0,&l_572,&l_572}},{{&l_572,&l_572,(void*)0},{(void*)0,&l_572,&l_572},{(void*)0,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,(void*)0,(void*)0},{&l_572,&l_572,&l_572},{(void*)0,(void*)0,&l_572},{&l_572,&l_572,&l_572}},{{&l_572,&l_572,&l_572},{&l_572,&l_572,(void*)0},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,(void*)0},{&l_572,&l_572,&l_572}},{{&l_572,(void*)0,&l_572},{&l_572,&l_572,&l_572},{(void*)0,&l_572,(void*)0},{&l_572,&l_572,&l_572},{(void*)0,(void*)0,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,(void*)0},{&l_572,&l_572,&l_572}},{{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{(void*)0,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{(void*)0,&l_572,&l_572},{&l_572,(void*)0,(void*)0}},{{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,(void*)0},{&l_572,(void*)0,&l_572},{(void*)0,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572}},{{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,(void*)0},{&l_572,&l_572,&l_572},{&l_572,(void*)0,&l_572},{&l_572,&l_572,&l_572},{&l_572,(void*)0,&l_572}},{{(void*)0,&l_572,&l_572},{&l_572,&l_572,(void*)0},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,&l_572,&l_572},{&l_572,(void*)0,&l_572},{&l_572,(void*)0,&l_572},{&l_572,&l_572,&l_572}}};
    float **l_570 = &l_571[2][6][0];
    float ***l_590 = &l_570;
    float ****l_589 = &l_590;
    int32_t **l_667[4][7];
    int32_t l_673 = (-1L);
    int i, j, k;
    for (i = 0; i < 4; i = i + 1)
    {
        for (j = 0; j < 7; j = j + 1)
            l_667[i][j] = &l_532;
    }
    (*l_532) = ((uint16_t)func_89(l_532) + (uint16_t)(*l_532));
    l_535 = &l_533;
    /* statement id: 541 */
    assert (l_535 == &l_533);
    if ((*l_535))
    { /* block id: 542 */
        int32_t l_546 = 0x52A5FCEDL;
        int32_t *l_550 = (void*)0;
        float ****l_566 = (void*)0;
        for (l_533 = 5; (l_533 != 5); l_533 += 8)
        { /* block id: 545 */
            int32_t l_538 = 0x09130DBBL;
            int32_t l_549[9] = {9L,9L,9L,9L,9L,9L,9L,9L,9L};
            float *l_556 = (void*)0;
            float l_557 = (-0x1.Fp-1);
            int i;
            for (l_538 = 0; (l_538 == (-3)); l_538 -= 1)
            { /* block id: 548 */
                int32_t l_541 = 0xADC1CC4BL;
            }
        }
    }
    else
    { /* block id: 574 */
        int16_t l_577[7] = {1L,(-1L),(-1L),1L,(-1L),(-1L),1L};
        float *l_600 = &l_572;
        int32_t l_618[10][6][2] = {{{(-2L),6L},{6L,0x1545A6CFL},{0x13A64C0EL,0xE98CAB80L},{(-2L),0x13A64C0EL},{0xE98CAB80L,0x1545A6CFL},{0xE98CAB80L,0x13A64C0EL}},{{(-2L),0xE98CAB80L},{0x13A64C0EL,0x1545A6CFL},{6L,6L},{(-2L),6L},{6L,0x1545A6CFL},{0x13A64C0EL,0xE98CAB80L}},{{(-2L),0x13A64C0EL},{0xE98CAB80L,0x1545A6CFL},{0xE98CAB80L,0x13A64C0EL},{(-2L),0xE98CAB80L},{0x13A64C0EL,0x1545A6CFL},{6L,6L}},{{(-2L),6L},{6L,0x1545A6CFL},{0x13A64C0EL,0xE98CAB80L},{(-2L),0x13A64C0EL},{0xE98CAB80L,0x1545A6CFL},{0xE98CAB80L,0x13A64C0EL}},{{(-2L),0xE98CAB80L},{0x13A64C0EL,0x1545A6CFL},{6L,6L},{(-2L),6L},{6L,0x1545A6CFL},{0x13A64C0EL,0xE98CAB80L}},{{(-2L),0x13A64C0EL},{0xE98CAB80L,0x1545A6CFL},{0xE98CAB80L,0x13A64C0EL},{(-2L),0xE98CAB80L},{0x13A64C0EL,0x1545A6CFL},{6L,6L}},{{(-2L),6L},{6L,0x1545A6CFL},{0x13A64C0EL,0xE98CAB80L},{(-2L),0x13A64C0EL},{0xE98CAB80L,0x1545A6CFL},{0xE98CAB80L,0x13A64C0EL}},{{(-2L),0xE98CAB80L},{0x13A64C0EL,0x1545A6CFL},{6L,6L},{(-2L),6L},{6L,0x1545A6CFL},{0x13A64C0EL,0xE98CAB80L}},{{(-2L),0x13A64C0EL},{0xE98CAB80L,0x1545A6CFL},{0xE98CAB80L,0x13A64C0EL},{(-2L),0xE98CAB80L},{0x13A64C0EL,0x1545A6CFL},{6L,6L}},{{(-2L),6L},{6L,0x1545A6CFL},{0x13A64C0EL,0xE98CAB80L},{(-2L),0x13A64C0EL},{0xE98CAB80L,0x1545A6CFL},{0xE98CAB80L,0x13A64C0EL}}};
        uint16_t l_659 = 0xD321L;
        float ****l_663 = &l_590;
        int32_t **l_668 = (void*)0;
        float *****l_672 = &l_589;
        int i, j, k;
        if ((l_570 == (void*)0))
        { /* block id: 575 */
            const float l_575 = 0x1.9C105Fp-11;
            int32_t l_576 = (-1L);
            for (l_560 = 0; (l_560 <= 2); l_560 += 1)
            { /* block id: 578 */
                int32_t l_578 = 1L;
                p_49 = ((float)((***l_548) > l_575) + (float)((p_49 < ((l_576 != p_49) < p_49)) >= l_577[0]));
                for (l_576 = 0; (l_576 <= 2); l_576 += 1)
                { /* block id: 582 */
                    return l_578;
                }
            }
        }
        else
        { /* block id: 586 */
            float *l_579 = &l_572;
            int32_t l_580 = (-10L);
            const float ****l_646 = (void*)0;
            const float *****l_645 = &l_646;
            uint16_t l_669 = 0xB5E0L;
            int32_t *l_670 = &l_618[7][3][1];
            if (((l_579 == (void*)0) > l_580))
            { /* block id: 587 */
                uint32_t l_608 = 1UL;
                int32_t ****l_619 = &l_548;
                struct S0 l_634 = {35400,-2748,807,30299,1268,0x9B48L};
                struct S0 *l_633 = &l_634;
                (**l_548) = &l_580;
                /* statement id: 588 */
                assert (l_532 == &l_580);
                if (l_577[0])
                { /* block id: 589 */
                    uint32_t l_595 = 0xE44AEC55L;
                    if (l_580)
                    { /* block id: 590 */
                        return l_577[6];
                    }
                    else
                    { /* block id: 592 */
                        uint32_t l_592[1][6][7] = {{{0x664106C4L,4294967295UL,0xF89094ADL,0xF89094ADL,4294967295UL,0x664106C4L,0xE45CA51BL},{4294967295UL,0x88E8F2B1L,0x63EF4C22L,1UL,1UL,0x63EF4C22L,0x88E8F2B1L},{4294967295UL,0xE45CA51BL,0x664106C4L,4294967295UL,0xF89094ADL,0xF89094ADL,4294967295UL},{0x664106C4L,0x88E8F2B1L,0x664106C4L,0xF89094ADL,0x88E8F2B1L,0xE45CA51BL,0xE45CA51BL},{0x88E8F2B1L,4294967295UL,0x63EF4C22L,4294967295UL,0x88E8F2B1L,0x63EF4C22L,1UL},{1UL,0xE45CA51BL,0xF89094ADL,1UL,0xF89094ADL,0xE45CA51BL,1UL}}};
                        int i, j, k;
                        (*l_579) = ((float)(((float)((float)((float)(l_589 != (void*)0) - (float)(l_580 >= (-(float)l_592[0][0][4]))) - (float)p_49) - (float)((float)p_49 - (float)0x1.0p+1)) < p_49) - (float)l_595);
                        (*l_535) = ((uint16_t)l_580 >> (uint16_t)4);
                    }
                }
                else
                { /* block id: 596 */
                    float *l_599 = &l_572;
                    int32_t l_603 = 0x8D0893A1L;
                    for (l_580 = 2; (l_580 >= 0); l_580 -= 1)
                    { /* block id: 599 */
                        const int32_t *l_598 = (void*)0;
                        l_598 = l_598;
                        (*l_579) = ((*l_532) >= ((l_599 != l_600) == (p_49 <= l_577[0])));
                    }
                    for (l_580 = 20; (l_580 <= 17); l_580 -= 1)
                    { /* block id: 605 */
                        int16_t l_613[4] = {1L,1L,1L,1L};
                        int i;
                        l_603 = (*l_535);
                        l_618[8][1][0] = ((-1L) & ((-8L) && ((uint16_t)((uint16_t)(*l_532) - (uint16_t)(((***l_548) ^ l_608) && (((int16_t)((int16_t)0xC828L + (int16_t)((l_613[0] <= ((int16_t)((int16_t)(func_65(l_603, l_577[0], l_613[0]) <= 1L) << (int16_t)14) << (int16_t)1)) <= l_603)) % (int16_t)(*l_535)) != l_613[0]))) << (uint16_t)7)));
                    }
                }
                if (((__builtin_ctz(l_608) < ((l_619 == l_619) <= (__builtin_ctzl((+((int32_t)((uint32_t)(((int16_t)((uint16_t)l_580 >> (uint16_t)8) + (int16_t)65526UL) >= (****l_619)) - (uint32_t)l_580) - (int32_t)l_580))) < (*l_535)))) <= l_618[3][0][0]))
                { /* block id: 610 */
                    int32_t **l_642[5];
                    uint32_t l_660 = 1UL;
                    int i;
                    for (i = 0; i < 5; i = i + 1)
                        l_642[i] = &l_532;
                    (**l_548) = func_69((0xC444E598L || ((int32_t)0xD649ECFAL - (int32_t)((int32_t)((void*)0 != l_633) % (int32_t)(-(int16_t)(-1L))))));
                    /* statement id: 611 */
                    assert (l_532 == 0);
                    (*l_579) = (((float)((float)p_49 + (float)p_49) - (float)(p_49 > (((float)(l_642[0] == (void*)0) + (float)((float)((l_645 != (void*)0) != (-0x4.Cp-1)) - (float)l_618[8][1][0])) > p_49))) == p_49);
                    (*l_600) = (func_59(l_580, l_634.f2, (((-1L) ^ l_580) == ((uint32_t)(0x873EEF3FL > ((-1L) ^ ((int16_t)((l_580 != ((uint16_t)((uint16_t)((int16_t)l_618[8][1][0] << (int16_t)8) << (uint16_t)__builtin_parityll(((int16_t)l_580 % (int16_t)l_618[8][1][0]))) - (uint16_t)l_659)) >= l_580) - (int16_t)65535UL))) + (uint32_t)0xD1EF6A0BL)), l_660, l_580) > p_49);
                    for (l_660 = 0; (l_660 > 16); ++l_660)
                    { /* block id: 616 */
                        (**l_548) = func_69(((((void*)0 != l_663) <= (l_577[6] || ((*l_590) == (void*)0))) ^ (((int16_t)((+(l_580 || (l_667[1][0] == l_668))) != l_580) << (int16_t)(*l_535)) != l_669)));
                        l_670 = func_69(l_580);
                        /* statement id: 618 */
                        assert (l_670 == 0);
                    }
                    /* facts after for loop */
                    assert (l_670 == 0 || (l_670 >= &l_618[0][0][0] && l_670 <= &l_618[9][5][1]));
                }
                else
                { /* block id: 620 */
                    (*l_670) = 1L;
                }
                /* facts after branching */
                assert (l_532 == &l_580 || l_532 == 0);
                assert (l_670 == 0 || (l_670 >= &l_618[0][0][0] && l_670 <= &l_618[9][5][1]));
            }
            else
            { /* block id: 623 */
                uint16_t l_671 = 0xFDCFL;
                for (l_669 = 0; (l_669 <= 3); l_669 += 1)
                { /* block id: 626 */
                    return l_671;
                }
                (*l_600) = (((p_49 < (*l_670)) >= 0x2.Dp+1) != p_49);
                return l_577[1];
            }
            /* facts after branching */
            assert (l_532 == &l_580 || l_532 == 0);
            assert (l_670 == 0 || (l_670 >= &l_618[0][0][0] && l_670 <= &l_618[9][5][1]));
        }
        /* facts after branching */
        //assert (l_532 == dangling || l_532 == 0 || l_532 == &l_533);
        (**l_548) = func_69(l_618[6][4][1]);
        /* statement id: 633 */
        assert (l_532 == 0);
        (**l_548) = func_69(l_659);
        (*l_672) = l_663;
    }
    /* facts after branching */
    assert (l_532 == 0 || l_532 == &l_533);
    return l_673;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_59(uint32_t  p_60, int32_t  p_61, int32_t  p_62, int32_t  p_63, int32_t  p_64)
{ /* block id: 450 */
    struct S0 l_439 = {14174,3721,-4556,27225,162,5UL};
    const int32_t l_443 = 0x4D085F9AL;
    const int32_t *l_442 = &l_443;
    const int32_t **l_446 = &l_442;
    const int32_t ***l_445 = &l_446;
    const int32_t ****l_444 = &l_445;
    int32_t l_479 = 0xD6D7691CL;
    int32_t *l_478 = &l_479;
    int16_t l_486 = 0xE400L;
    if (((uint16_t)(func_77(func_79(p_64, (((uint16_t)0xE5FCL - (uint16_t)(func_77(l_439) | ((uint16_t)(p_61 & p_62) >> (uint16_t)(0L != __builtin_parity(l_439.f1))))) | p_60), l_439.f0, l_439.f4, l_442)) ^ p_61) >> (uint16_t)p_62))
    { /* block id: 451 */
        int32_t l_452 = 0L;
        int32_t *l_451[1][3][9] = {{{&l_452,&l_452,&l_452,(void*)0,&l_452,&l_452,&l_452,&l_452,&l_452},{&l_452,(void*)0,&l_452,(void*)0,&l_452,&l_452,&l_452,&l_452,&l_452},{&l_452,(void*)0,&l_452,(void*)0,&l_452,&l_452,&l_452,&l_452,&l_452}}};
        int32_t **l_450 = &l_451[0][0][0];
        int32_t ***l_449 = &l_450;
        int32_t ****l_448 = &l_449;
        int32_t *****l_447 = &l_448;
        struct S0 l_496 = {33632,386,4948,11536,419,0x05DAL};
        struct S0 *l_495 = &l_496;
        struct S0 **l_502 = &l_495;
        int i, j, k;
        (*l_447) = l_444;
        /* statement id: 452 */
        assert (l_448 == &l_445);
        if (((****l_444) != p_64))
        { /* block id: 453 */
            uint16_t l_455 = 0x0D81L;
            float *l_458 = (void*)0;
            float *l_459 = (void*)0;
            float l_461 = 0x1.01CEABp-53;
            float *l_460 = &l_461;
            int32_t ****l_469 = &l_449;
            float **l_491 = &l_458;
            float ***l_490 = &l_491;
            for (p_63 = 0; (p_63 <= 0); p_63 += 1)
            { /* block id: 456 */
                int32_t *l_453 = (void*)0;
                l_453 = (***l_448);
                /* statement id: 457 */
                assert (l_453 == &l_443);
                for (l_452 = 0; (l_452 <= 0); l_452 += 1)
                { /* block id: 460 */
                    uint16_t l_454 = 0UL;
                    for (p_60 = 0; (p_60 <= 0); p_60 += 1)
                    { /* block id: 463 */
                        int i, j, k;
                        l_451[p_60][(p_60 + 1)][(l_452 + 3)] = l_451[p_60][(l_452 + 2)][(p_60 + 2)];
                    }
                    l_454 = (-0x1.Ep-1);
                    (*l_446) = l_453;
                    return l_455;
                }
                for (p_61 = 20; (p_61 == (-2)); p_61 -= 2)
                { /* block id: 472 */
                    return p_61;
                }
            }
            (*l_450) = func_69(p_64);
            (*l_460) = (p_62 == (****l_444));
            if (((uint16_t)(((p_62 || __builtin_ctzl(p_64)) | (((int16_t)(*****l_447) >> (int16_t)0) | (__builtin_ctzl((__builtin_clzl((0xB093L || (0x3C9576F6L ^ __builtin_popcount((((!((int32_t)((&l_445 != l_469) ^ ((int32_t)0xD12CA628L - (int32_t)0L)) - (int32_t)(*l_442))) < (*l_442)) && 0x1C95L))))) | p_62)) | 0x4D52L))) < p_61) - (uint16_t)0x5083L))
            { /* block id: 478 */
                (**l_449) = &p_61;
                /* statement id: 479 */
                //assert (l_451[0][0][0] == &p_61 || l_451[0][0][0] == 0 || l_451[0][0][0] == &l_452);
                for (l_439.f5 = 0; (l_439.f5 < 32); ++l_439.f5)
                { /* block id: 482 */
                    int32_t ****l_474 = &l_449;
                    (*l_460) = (l_474 != &l_445);
                    p_61 = p_61;
                    (*l_460) = ((+(**l_446)) <= p_64);
                    for (p_64 = 0; (p_64 != (-18)); p_64 -= 6)
                    { /* block id: 488 */
                        uint16_t l_482 = 0x4E31L;
                        int32_t l_485 = 0x6FE5E8F9L;
                        l_485 = (((&p_61 != l_478) <= ((-0x1.1p+1) >= (0xD.E189DCp+90 != 0xF.875B53p+97))) > (((float)__builtin_ia32_crc32qi(p_60, ((l_482 || p_62) && (((int16_t)(*****l_447) >> (int16_t)p_62) | 0x1194L))) + (float)0xF.2F91B9p-98) < p_64));
                        if (p_64)
                            break;
                    }
                }
                (*l_446) = func_69((__builtin_ffsll((****l_444)) == l_486));
                /* statement id: 493 */
                assert (l_442 == 0);
            }
            else
            { /* block id: 494 */
                float *l_493 = &l_461;
                int32_t l_509 = (-10L);
                for (l_439.f5 = 8; (l_439.f5 < 27); l_439.f5 += 1)
                { /* block id: 497 */
                    struct S0 *l_494 = &l_439;
                    int32_t l_510[4] = {0x4A9ECE52L,0x4A9ECE52L,0x4A9ECE52L,0x4A9ECE52L};
                    int i;
                    if (p_61)
                        break;
                    for (l_455 = 0; (l_455 <= 0); l_455 += 1)
                    { /* block id: 501 */
                        int32_t *l_489 = &l_452;
                        (*l_450) = l_489;
                        (*l_446) = (***l_444);
                        (*l_489) = 0x3.3113D8p+53;
                        (*l_478) = p_62;
                    }
                    for (p_63 = 0; (p_63 >= 0); p_63 -= 1)
                    { /* block id: 509 */
                        float ****l_492 = &l_490;
                        (*l_446) = (*l_446);
                        (*l_478) = p_63;
                        (*l_492) = l_490;
                        (*l_460) = ((*l_447) == l_469);
                    }
                    if (((void*)0 != l_493))
                    { /* block id: 515 */
                        struct S0 **l_501 = &l_494;
                        l_495 = l_494;
                        /* statement id: 516 */
                        assert (l_495 == &l_439);
                        (*l_493) = ((float)__builtin_ffsll(((int16_t)1L - (int16_t)(l_501 == l_502))) + (float)0x4.33D278p+7);
                        (**l_445) = func_69((((int32_t)0x7BC4216EL - (int32_t)((((int32_t)p_62 % (int32_t)(((int16_t)(p_62 <= (l_509 >= p_60)) << (int16_t)((*l_478) != l_510[3])) & ((int16_t)((l_509 == ((uint32_t)p_64 + (uint32_t)l_510[0])) <= p_61) << (int16_t)p_62))) && 0UL) && 1UL)) > (-1L)));
                        /* statement id: 518 */
                        assert (l_442 == 0);
                        return p_60;
                    }
                    else
                    { /* block id: 520 */
                        const uint16_t l_523 = 65535UL;
                        (*l_478) = 0xEDB57A5AL;
                        l_510[3] = (((int16_t)(0x921DC29AL >= (((int16_t)(((int16_t)__builtin_parity((1UL | ((((p_62 ^ (p_63 ^ (p_60 >= p_62))) == ((int32_t)p_64 - (int32_t)(l_510[3] == p_62))) <= p_62) | 0x5B05L))) >> (int16_t)0) & p_62) + (int16_t)l_523) != l_509)) >> (int16_t)l_509) > p_60);
                    }
                }
            }
            /* facts after branching */
            assert (l_442 == &l_443 || l_442 == 0);
            //assert (l_451[0][0][0] == &p_61 || l_451[0][0][0] == 0 || l_451[0][0][0] == &l_452);
        }
        else
        { /* block id: 526 */
            int32_t l_527[3];
            int i;
            for (i = 0; i < 3; i = i + 1)
                l_527[i] = 1L;
            if ((((-(uint32_t)(*l_442)) & ((***l_445) & (&l_448 == &l_448))) >= l_527[2]))
            { /* block id: 527 */
                return p_64;
            }
            else
            { /* block id: 529 */
                float l_529 = 0xE.F797D1p-3;
                float *l_528 = &l_529;
                (*l_528) = p_63;
            }
            (*l_450) = func_69(p_60);
        }
        /* facts after branching */
        assert (l_442 == &l_443 || l_442 == 0);
        //assert (l_451[0][0][0] == &p_61 || l_451[0][0][0] == 0 || l_451[0][0][0] == &l_452);
        return p_62;
    }
    else
    { /* block id: 535 */
        (**l_445) = (void*)0;
        /* statement id: 536 */
        assert (l_442 == 0);
        return p_61;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_65(uint16_t  p_66, uint32_t  p_67, const int16_t  p_68)
{ /* block id: 43 */
    int32_t **l_369 = (void*)0;
    int32_t l_372 = 0x59546844L;
    int32_t *l_371 = &l_372;
    int32_t **l_370 = &l_371;
    float l_373[9] = {0x9.16DD6Ap-64,0x9.16DD6Ap-64,0x9.16DD6Ap-64,0x9.16DD6Ap-64,0x9.16DD6Ap-64,0x9.16DD6Ap-64,0x9.16DD6Ap-64,0x9.16DD6Ap-64,0x9.16DD6Ap-64};
    float *l_384 = &l_373[6];
    float **l_383 = &l_384;
    int32_t l_388 = 0x3EA298D6L;
    int i;
    (*l_370) = func_69(p_68);
    /* statement id: 385 */
    assert (l_371 == 0);
    for (l_372 = 3; (l_372 <= 8); l_372 += 1)
    { /* block id: 388 */
        int32_t l_378 = 0x154E1770L;
        float *l_382 = &l_373[2];
        float **l_381 = &l_382;
        int32_t *l_387[5][2] = {{(void*)0,&l_372},{(void*)0,(void*)0},{(void*)0,&l_372},{(void*)0,&l_372},{&l_372,&l_372}};
        int32_t ***l_426 = &l_370;
        int i, j;
        l_388 = ((int16_t)((int16_t)((l_378 < (((uint32_t)(((-2L) <= (l_381 != l_383)) == (l_378 ^ (p_68 && ((void*)0 == &l_371)))) + (uint32_t)((((int32_t)((void*)0 != (*l_381)) + (int32_t)p_67) <= p_68) && 4UL)) && 0x2D519988L)) || p_68) % (int16_t)l_378) >> (int16_t)l_378);
        for (p_66 = 0; (p_66 <= 8); p_66 += 1)
        { /* block id: 392 */
            int16_t l_400 = 5L;
            int32_t l_403 = 0x845AB86FL;
            uint32_t l_429 = 0x2B030C26L;
            for (l_378 = 1; (l_378 >= 0); l_378 -= 1)
            { /* block id: 395 */
                uint32_t l_397 = 1UL;
                l_403 = ((int16_t)(((uint32_t)(((int16_t)(-2L) << (int16_t)11) < ((uint32_t)l_397 % (uint32_t)((int16_t)l_400 % (int16_t)l_397))) + (uint32_t)__builtin_ctzll((p_66 ^ l_400))) || (((uint16_t)p_68 << (uint16_t)l_400) & 0xFA33L)) << (int16_t)p_68);
            }
            for (l_388 = 0; (l_388 <= 8); l_388 += 1)
            { /* block id: 400 */
                float ***l_407 = (void*)0;
                float ****l_406 = &l_407;
                int32_t l_408 = (-6L);
                uint32_t l_410 = 0x4C82FF22L;
                for (l_378 = 8; (l_378 >= 2); l_378 -= 1)
                { /* block id: 403 */
                    float l_409[3];
                    int i;
                    for (i = 0; i < 3; i = i + 1)
                        l_409[i] = (-0x8.5p+1);
                    l_408 = ((uint32_t)((l_406 == (void*)0) >= __builtin_parityl(p_68)) - (uint32_t)(l_408 >= p_68));
                    return l_410;
                }
                if ((0xFA0D4CE7L & l_400))
                { /* block id: 407 */
                    int16_t l_411[10] = {0xCD48L,0x6A2FL,0x6A2FL,0xCD48L,0x38F4L,0xCD48L,0x6A2FL,0x6A2FL,0xCD48L,0x38F4L};
                    int i;
                    if (p_67)
                    { /* block id: 408 */
                        l_408 = l_411[4];
                    }
                    else
                    { /* block id: 410 */
                        if (p_68)
                            break;
                        return p_67;
                    }
                    l_387[0][1] = func_69(p_67);
                }
                else
                { /* block id: 415 */
                    (*l_370) = &l_408;
                    /* statement id: 416 */
                    assert (l_371 == &l_408);
                    if (p_67)
                        continue;
                    //assert (l_371 == dangling);
                    if (l_403)
                        break;
                    //assert (l_371 == dangling);
                }
                /* facts after branching */
                //assert (l_371 == &l_408 || l_371 == dangling || l_371 == 0);
                if (p_66)
                    continue;
                //assert (l_371 == dangling || l_371 == 0);
            }
            for (l_388 = 8; (l_388 >= 1); l_388 -= 1)
            { /* block id: 424 */
                int32_t l_414 = 0L;
                int32_t l_423 = 0L;
                int32_t *l_428 = &l_414;
                if (p_66)
                { /* block id: 425 */
                    (*l_370) = func_69(p_66);
                    /* statement id: 426 */
                    assert (l_371 == 0);
                    for (l_400 = 0; (l_400 <= 1); l_400 += 1)
                    { /* block id: 429 */
                        int32_t l_412 = 0x17A2AB3DL;
                        int i, j;
                        l_414 = (__builtin_clzll(l_412) == (!(p_66 >= p_67)));
                        return l_403;
                    }
                    for (l_378 = 0; l_378 < 5; l_378 += 1)
                    {
                        for (l_403 = 0; l_403 < 2; l_403 += 1)
                        {
                            l_387[l_378][l_403] = &l_388;
                        }
                    }
                }
                else
                { /* block id: 434 */
                    uint16_t l_427 = 0x8199L;
                    for (p_67 = 0; (p_67 <= 1); p_67 += 1)
                    { /* block id: 437 */
                        const uint16_t l_421 = 0x45E5L;
                        const int16_t l_422 = 1L;
                        l_427 = (((uint16_t)(((uint32_t)((int16_t)(l_414 | p_68) * (int16_t)(0x5256L != p_66)) - (uint32_t)l_421) > (l_423 & ((uint16_t)((l_426 == &l_369) ^ (-3L)) % (uint16_t)p_68))) >> (uint16_t)l_403) <= 0xFE09L);
                        return l_427;
                    }
                    l_428 = &l_414;
                    if (p_68)
                        continue;
                }
            }
            if (l_429)
                continue;
        }
        /* facts after for loop */
        //assert (l_371 == dangling || l_371 == 0);
        //assert (l_387[0][0] == &l_388 || l_387[0][0] == &l_372 || l_387[0][0] == 0);
        (*l_370) = func_69(((func_89(l_382) & ((int32_t)(p_68 | p_67) - (int32_t)((int16_t)p_67 << (int16_t)2))) <= p_67));
        /* statement id: 447 */
        assert (l_371 == 0);
    }
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(const int16_t  p_70)
{ /* block id: 44 */
    int32_t l_71 = (-1L);
    int32_t l_299[9];
    int32_t *l_298[10][4][6] = {{{&l_71,&l_71,&l_299[0],&l_299[0],(void*)0,&l_299[2]},{&l_299[2],&l_299[0],&l_71,&l_71,&l_71,&l_299[0]},{&l_299[3],&l_299[2],&l_71,(void*)0,&l_71,&l_299[2]},{&l_299[0],(void*)0,&l_299[0],&l_299[8],&l_71,&l_299[0]}},{{&l_299[8],&l_71,&l_299[0],&l_71,&l_299[1],(void*)0},{&l_299[0],&l_71,(void*)0,(void*)0,&l_71,&l_299[0]},{&l_71,(void*)0,&l_299[2],&l_299[0],&l_71,&l_71},{(void*)0,&l_299[2],&l_299[1],&l_299[3],&l_71,&l_299[0]}},{{(void*)0,&l_299[0],&l_299[3],&l_299[0],(void*)0,&l_71},{&l_71,&l_71,&l_71,(void*)0,&l_299[0],&l_299[0]},{&l_299[0],&l_71,&l_299[0],&l_71,&l_299[0],&l_299[0]},{&l_299[8],&l_71,&l_71,&l_299[8],(void*)0,&l_71}},{{&l_299[0],&l_299[0],&l_299[3],(void*)0,&l_299[0],&l_299[0]},{&l_299[3],&l_299[0],&l_299[1],&l_71,&l_299[0],&l_71},{&l_299[2],&l_299[0],&l_299[2],&l_299[0],(void*)0,&l_299[0]},{&l_71,&l_71,(void*)0,&l_299[0],&l_299[0],(void*)0}},{{(void*)0,&l_71,&l_299[0],&l_299[0],&l_299[0],&l_299[0]},{&l_71,&l_71,&l_299[0],&l_299[0],(void*)0,&l_299[2]},{&l_299[2],&l_299[0],&l_71,&l_71,&l_71,&l_299[0]},{&l_299[3],&l_299[2],&l_71,(void*)0,&l_71,&l_299[2]}},{{&l_299[0],(void*)0,&l_299[0],&l_299[8],&l_71,&l_299[0]},{&l_299[8],&l_71,&l_299[0],&l_71,&l_299[1],(void*)0},{&l_299[0],&l_71,&l_299[2],&l_299[2],&l_71,&l_299[0]},{&l_71,&l_299[8],(void*)0,&l_71,&l_299[3],&l_299[0]}},{{&l_299[2],(void*)0,&l_299[0],(void*)0,&l_299[1],(void*)0},{&l_299[2],&l_71,(void*)0,&l_71,&l_299[2],&l_299[3]},{&l_71,&l_299[3],&l_299[1],&l_299[2],(void*)0,&l_299[0]},{&l_299[0],&l_299[0],(void*)0,&l_299[3],&l_299[0],&l_299[0]}},{{&l_299[0],&l_299[1],&l_299[1],&l_299[0],&l_299[0],&l_299[3]},{&l_299[0],&l_71,(void*)0,&l_299[8],&l_71,(void*)0},{(void*)0,&l_299[0],&l_299[0],&l_299[0],&l_71,&l_299[0]},{(void*)0,&l_71,(void*)0,&l_71,&l_299[0],&l_299[0]}},{{&l_299[3],&l_299[1],&l_299[2],(void*)0,&l_299[0],&l_299[0]},{&l_299[8],&l_299[0],&l_71,(void*)0,(void*)0,&l_71},{&l_299[3],&l_299[3],&l_71,&l_71,&l_299[2],(void*)0},{(void*)0,&l_71,&l_299[3],&l_299[0],&l_299[1],&l_71}},{{(void*)0,(void*)0,&l_299[3],&l_299[8],&l_299[3],(void*)0},{&l_299[0],&l_299[8],&l_71,&l_299[0],&l_71,&l_71},{&l_299[0],&l_71,&l_71,&l_299[3],&l_299[0],&l_299[0]},{&l_299[0],&l_71,&l_299[2],&l_299[2],&l_71,&l_299[0]}}};
    int32_t *l_302 = &l_299[0];
    float **l_306 = (void*)0;
    float ***l_305 = &l_306;
    int32_t l_313 = (-1L);
    uint32_t l_314 = 0xD2189067L;
    int32_t **l_332 = &l_302;
    int32_t ***l_331 = &l_332;
    int32_t *l_365 = &l_71;
    int32_t *l_366[6][1];
    int32_t *l_367 = &l_299[0];
    int32_t *l_368 = (void*)0;
    int i, j, k;
    for (i = 0; i < 9; i = i + 1)
        l_299[i] = 0L;
    for (i = 0; i < 6; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
            l_366[i][j] = &l_71;
    }
    for (l_71 = (-16); (l_71 == 21); ++l_71)
    { /* block id: 47 */
        int32_t *l_74 = &l_71;
        const int32_t *l_97 = (void*)0;
        int32_t *l_301 = &l_299[7];
        int32_t *l_304 = (void*)0;
        float ****l_307 = &l_305;
        int32_t **l_308 = &l_301;
        if ((((void*)0 != l_74) || ((__builtin_popcountll((((uint32_t)(func_77(func_79(((*l_74) == ((-5L) > ((int16_t)((int16_t)(p_70 && func_89(l_74)) + (int16_t)((&l_71 != &l_71) | (*l_74))) - (int16_t)p_70))), (*l_74), (*l_74), p_70, l_97)) >= (*l_74)) % (uint32_t)l_71) <= 0xD0C4F649L)) && (*l_74)) && p_70)))
        { /* block id: 329 */
            int32_t *l_297[9][6][1] = {{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}},{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}},{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}},{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}},{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}},{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}},{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}},{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}},{{&l_71},{&l_71},{&l_71},{&l_71},{&l_71},{&l_71}}};
            int i, j, k;
            l_298[4][1][1] = l_297[7][2][0];
        }
        else
        { /* block id: 331 */
            int32_t *l_300 = &l_71;
            int32_t *l_303 = &l_299[0];
            return l_304;
            /* statement id: 332 */
            //assert (func_69_rv == 0);
        }
        (*l_307) = l_305;
        (*l_308) = &l_299[0];
        if (p_70)
            break;
    }
    l_314 = ((float)p_70 + (float)(((__builtin_bswap64((*l_302)) > p_70) < ((__builtin_ia32_crc32qi(((int32_t)(*l_302) - (int32_t)0x8874FEF3L), (p_70 || (&l_306 != (void*)0))) <= 0x8.Cp-1) != l_313)) == 0x2.20E9E2p-11));
    for (l_313 = 22; (l_313 < 9); l_313 -= 1)
    { /* block id: 341 */
        int32_t *l_319 = &l_313;
        int32_t l_326 = (-8L);
        struct S0 l_362 = {8500,-4010,-4390,8034,361,65535UL};
        int32_t ***l_364 = &l_332;
    }
    return l_368;
    /* statement id: 384 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_77(struct S0  p_78)
{ /* block id: 258 */
    int32_t l_256[5][9] = {{(-9L),1L,0x7D9377ECL,(-9L),0xA63B41C2L,0x6AF6D611L,0xA63B41C2L,(-9L),0x7D9377ECL},{0xA63B41C2L,0xA63B41C2L,0x2B01615AL,0x0861D2B5L,(-1L),0x6AF6D611L,0x7F022DFCL,0xA63B41C2L,(-3L)},{1L,(-9L),(-3L),0x0861D2B5L,0xA63B41C2L,0xE04E4066L,1L,1L,0xE04E4066L},{0x0861D2B5L,(-9L),0x2B01615AL,0xCAE83776L,0xE331D999L,0x7F022DFCL,(-1L),0xE331D999L,1L},{0L,1L,0x0861D2B5L,(-1L),0L,0xA63B41C2L,(-1L),0L,(-1L)}};
    float l_262[5][3] = {{0xC.9ADE88p-76,0x6.7350B0p+32,0x5.9p+1},{0x6.C5B780p+9,0x7.Bp-1,0x1.10FCA9p-27},{0xC.9ADE88p-76,0xC.9ADE88p-76,0x1.10FCA9p-27},{0x7.Bp-1,0x6.C5B780p+9,0x5.9p+1},{0x6.7350B0p+32,0xC.9ADE88p-76,0x6.7350B0p+32}};
    float *l_261[1][5];
    float **l_260 = &l_261[0][4];
    float ***l_259[7] = {&l_260,&l_260,&l_260,&l_260,&l_260,&l_260,&l_260};
    float ****l_258 = &l_259[3];
    float *****l_257 = &l_258;
    int i, j;
    for (i = 0; i < 1; i = i + 1)
    {
        for (j = 0; j < 5; j = j + 1)
            l_261[i][j] = &l_262[2][1];
    }
    for (p_78.f5 = 0; (p_78.f5 < 46); p_78.f5 += 7)
    { /* block id: 261 */
        return p_78.f5;
    }
    p_78.f2 = ((uint16_t)p_78.f5 << (uint16_t)((uint32_t)0x0C9BAA3EL + (uint32_t)((uint16_t)1UL + (uint16_t)l_256[0][0])));
    if (((65531UL <= ((void*)0 == l_257)) == l_256[0][0]))
    { /* block id: 265 */
        return l_256[3][8];
    }
    else
    { /* block id: 267 */
        int32_t *l_263[7] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
        int32_t **l_264 = &l_263[1];
        int i;
        (*l_264) = l_263[1];
        for (p_78.f5 = 0; (p_78.f5 <= 2); p_78.f5 += 1)
        { /* block id: 271 */
            int32_t *l_265 = &l_256[1][3];
            float ***l_272 = &l_260;
            int32_t l_290[8][1][5] = {{{1L,0L,(-5L),0x58E96002L,0x52647545L}},{{0x3EAB69EBL,0x58E96002L,0xB828BC55L,(-2L),6L}},{{(-2L),0L,0x0F7A7959L,0x0F7A7959L,0L}},{{0x52647545L,0xB828BC55L,0xF58000DDL,0x0F7A7959L,0xD72D5A0CL}},{{0xAED80145L,0xD72D5A0CL,0x3B5AC016L,(-2L),0x58E96002L}},{{0x7A763460L,(-5L),6L,0x58E96002L,1L}},{{0xAED80145L,0x7A763460L,1L,0x7A763460L,0xAED80145L}},{{0x52647545L,0x4A286409L,1L,6L,0xB828BC55L}}};
            float ****l_292 = &l_259[1];
            int i, j, k;
            l_263[(p_78.f5 + 1)] = l_265;
        }
    }
    return p_78.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_79(uint32_t  p_80, int32_t  p_81, int32_t  p_82, int32_t  p_83, const int32_t * p_84)
{ /* block id: 52 */
    struct S0 l_102 = {39640,2740,5363,27366,583,65533UL};
    float l_104 = 0xC.86757Ap+65;
    float *l_103 = &l_104;
    int16_t l_105[3][3][1];
    int32_t l_115 = (-1L);
    int32_t *l_114 = &l_115;
    int32_t l_116 = 1L;
    int32_t l_193 = 0x9DBB52D6L;
    float **l_216 = (void*)0;
    float ***l_215 = &l_216;
    float ****l_214[4][4][7] = {{{&l_215,(void*)0,&l_215,&l_215,&l_215,&l_215,&l_215},{&l_215,&l_215,&l_215,&l_215,&l_215,&l_215,&l_215},{&l_215,(void*)0,&l_215,(void*)0,(void*)0,(void*)0,&l_215},{&l_215,&l_215,&l_215,&l_215,&l_215,&l_215,&l_215}},{{&l_215,&l_215,&l_215,(void*)0,&l_215,&l_215,&l_215},{&l_215,&l_215,&l_215,&l_215,&l_215,&l_215,&l_215},{(void*)0,&l_215,(void*)0,&l_215,(void*)0,&l_215,&l_215},{&l_215,&l_215,&l_215,&l_215,&l_215,(void*)0,&l_215}},{{&l_215,(void*)0,&l_215,&l_215,&l_215,(void*)0,&l_215},{&l_215,&l_215,&l_215,&l_215,&l_215,&l_215,&l_215},{(void*)0,(void*)0,&l_215,(void*)0,&l_215,(void*)0,&l_215},{&l_215,&l_215,&l_215,&l_215,&l_215,(void*)0,&l_215}},{{&l_215,&l_215,&l_215,(void*)0,&l_215,&l_215,&l_215},{&l_215,&l_215,&l_215,&l_215,(void*)0,&l_215,&l_215},{&l_215,&l_215,&l_215,&l_215,(void*)0,&l_215,&l_215},{&l_215,&l_215,&l_215,&l_215,&l_215,&l_215,&l_215}}};
    float *****l_213[2];
    int32_t **l_228 = (void*)0;
    int32_t ***l_227 = &l_228;
    int i, j, k;
    for (i = 0; i < 3; i = i + 1)
    {
        for (j = 0; j < 3; j = j + 1)
        {
            for (k = 0; k < 1; k = k + 1)
                l_105[i][j][k] = 0x36A5L;
        }
    }
    for (i = 0; i < 2; i = i + 1)
        l_213[i] = &l_214[0][1][0];
    for (p_81 = 0; (p_81 >= 3); p_81 += 1)
    { /* block id: 55 */
        int32_t l_101 = 0xAD2D1E56L;
        int32_t *l_100 = &l_101;
        (*l_100) = ((void*)0 == &p_82);
        return l_102;
    }
    (*l_103) = l_102.f2;
    for (p_83 = 0; (p_83 <= 0); p_83 += 1)
    { /* block id: 62 */
        int32_t **l_110 = (void*)0;
        int32_t *l_142 = &l_115;
        float ****l_217 = &l_215;
    }
    return l_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_89(int32_t * p_90)
{ /* block id: 48 */
    int32_t l_91 = (-9L);
    float l_93 = (-0x1.4p-1);
    float *l_92 = &l_93;
    int32_t l_96[10][7] = {{0xF33464EBL,0x5C78859BL,0xF33464EBL,0x460EE42AL,3L,0x6A9E5FAFL,(-1L)},{0x5C78859BL,0xB5DF1D97L,0xF33464EBL,1L,0x388B32A1L,1L,0xF33464EBL},{3L,3L,1L,1L,0x96AAE11EL,0x6A9E5FAFL,0x5C78859BL},{1L,3L,0xF0427242L,0x6A9E5FAFL,0x6A9E5FAFL,0xF0427242L,3L},{0xF0427242L,0xB5DF1D97L,3L,0xF33464EBL,0x96AAE11EL,0x460EE42AL,1L},{0xF0427242L,0x5C78859BL,0x388B32A1L,3L,0x388B32A1L,0x5C78859BL,0xF0427242L},{1L,0x460EE42AL,0x96AAE11EL,0xF33464EBL,3L,0xB5DF1D97L,0xF0427242L},{3L,0xF0427242L,0x6A9E5FAFL,0x6A9E5FAFL,0xF0427242L,3L,1L},{0x5C78859BL,0x6A9E5FAFL,0x96AAE11EL,1L,1L,3L,3L},{0xF33464EBL,1L,0x388B32A1L,1L,0xF33464EBL,0xB5DF1D97L,0x5C78859BL}};
    int32_t *l_95 = &l_96[9][2];
    int32_t **l_94 = &l_95;
    int i, j;
    (*l_92) = l_91;
    l_94 = &p_90;
    /* statement id: 50 */
    assert (l_94 == &p_90);
    return (**l_94);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 273
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 10
   indirect level: 2, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 33

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 204
   depth: 2, occurrence: 60
   depth: 3, occurrence: 4
   depth: 4, occurrence: 6
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 4
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 238

XXX times a variable address is taken: 478
XXX times a pointer is dereferenced on RHS: 164
breakdown:
   depth: 1, occurrence: 120
   depth: 2, occurrence: 24
   depth: 3, occurrence: 14
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 138
breakdown:
   depth: 1, occurrence: 116
   depth: 2, occurrence: 19
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 36
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 15
XXX times a pointer is qualified to be dereferenced: 1184

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 384
   level: 2, occurrence: 124
   level: 3, occurrence: 47
   level: 4, occurrence: 31
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 129
XXX number of pointers point to scalars: 97
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 28.2
XXX average alias set size: 1.41

XXX times a non-volatile is read: 1198
XXX times a non-volatile is write: 476
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 205
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 34
   depth: 2, occurrence: 20
   depth: 3, occurrence: 26
   depth: 4, occurrence: 44
   depth: 5, occurrence: 49

XXX percentage a fresh-made variable is used: 20.7
XXX percentage an existing variable is used: 79.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

