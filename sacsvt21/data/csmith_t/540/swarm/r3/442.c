/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1523840244
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   uint32_t  f1;
   uint16_t  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint16_t g_3 = 1UL;
static int32_t g_41 = (-1L);
static const int32_t *g_40 = &g_41;
static int32_t *g_95 = &g_41;
static int32_t ** volatile g_94 = &g_95;/* VOLATILE GLOBAL g_94 */
static int32_t g_108 = 8L;
static int32_t * volatile g_107 = &g_108;/* VOLATILE GLOBAL g_107 */
static int32_t * volatile g_109 = &g_108;/* VOLATILE GLOBAL g_109 */
static struct S0 g_119 = {-1L,18446744073709551606UL,0x3843L};
static struct S0 * volatile g_118 = &g_119;/* VOLATILE GLOBAL g_118 */
static int32_t ** volatile g_129 = &g_95;/* VOLATILE GLOBAL g_129 */
static int32_t ***g_134 = (void*)0;
static int32_t **** volatile g_133 = &g_134;/* VOLATILE GLOBAL g_133 */
static int32_t g_150 = 0L;
static struct S0 * volatile g_157 = &g_119;/* VOLATILE GLOBAL g_157 */
static int32_t * volatile g_168 = &g_119.f0;/* VOLATILE GLOBAL g_168 */
static volatile struct S0 g_172 = {0x6570B7C7L,0x066171E0L,0x7CFBL};/* VOLATILE GLOBAL g_172 */
static volatile struct S0 *g_171 = &g_172;
static volatile struct S0 * volatile *g_170 = &g_171;
static int32_t * volatile g_187 = &g_150;/* VOLATILE GLOBAL g_187 */
static int32_t * volatile g_189 = &g_119.f0;/* VOLATILE GLOBAL g_189 */
static volatile int32_t *** volatile **g_212 = (void*)0;
static int32_t ** volatile g_216 = &g_95;/* VOLATILE GLOBAL g_216 */
static const uint32_t g_229 = 0xF5FF9935L;
static struct S0 *g_254 = &g_119;
static struct S0 ** volatile g_253 = &g_254;/* VOLATILE GLOBAL g_253 */
static volatile int32_t *g_297 = (void*)0;
static int32_t ****g_382 = &g_134;
static int32_t ***** volatile g_381 = &g_382;/* VOLATILE GLOBAL g_381 */
static struct S0 * volatile *g_519 = &g_254;
static struct S0 * volatile * volatile * volatile g_518 = &g_519;/* VOLATILE GLOBAL g_518 */
static struct S0 * volatile * volatile * volatile *g_517 = &g_518;
static int32_t * volatile g_542 = (void*)0;/* VOLATILE GLOBAL g_542 */
static int32_t * volatile g_543 = &g_150;/* VOLATILE GLOBAL g_543 */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_30(void);
static int16_t  func_31(int8_t  p_32);
static int32_t * func_34(int32_t  p_35, const int32_t * p_36, int32_t  p_37, int32_t * p_38, int32_t  p_39);
static int32_t * func_42(int8_t  p_43, const uint32_t  p_44, int32_t  p_45, int32_t  p_46, int8_t  p_47);
static const uint32_t  func_48(int32_t * p_49, int32_t  p_50, int16_t  p_51);
static int32_t * func_52(int32_t * p_53, const int32_t * p_54);
static int32_t * func_55(const int32_t  p_56, struct S0  p_57, int32_t * p_58, int16_t  p_59, int32_t * p_60);
static struct S0  func_61(int32_t * p_62, int32_t  p_63, uint32_t  p_64, int32_t  p_65, uint16_t  p_66);
static int32_t  func_67(int32_t  p_68, int32_t * p_69, const int8_t  p_70, int32_t  p_71, int32_t * p_72);
static uint16_t  func_87(int32_t * p_88, const uint32_t  p_89, int8_t  p_90, uint32_t  p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_40 g_3 g_41 g_94 g_95 g_107 g_108 g_109 g_118 g_129 g_133 g_119 g_150 g_157 g_168 g_170 g_187 g_189 g_172.f2 g_171 g_212 g_216 g_172.f0 g_229 g_253 g_254 g_172 g_381 g_382 g_517 g_543
 * writes: g_41 g_95 g_108 g_119 g_134 g_150 g_170 g_3 g_172 g_254 g_157 g_118 g_382
 */
static int16_t  func_30(void)
{ /* block id: 36 */
    uint16_t l_33 = 0xB27FL;
    int32_t **l_541 = (void*)0;
    int32_t ***l_540 = &l_541;
    int32_t *l_544 = &g_150;
    int32_t *l_545 = (void*)0;
    (*g_543) = ((func_31(l_33) || l_33) > ((uint16_t)l_33 + (uint16_t)(l_540 != (void*)0)));
    l_545 = l_544;
    return g_172.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_40 g_3 g_41 g_94 g_95 g_107 g_108 g_109 g_118 g_129 g_133 g_119 g_150 g_157 g_168 g_170 g_187 g_189 g_172.f2 g_171 g_212 g_216 g_172.f0 g_229 g_253 g_254 g_172 g_381 g_382 g_517
 * writes: g_41 g_95 g_108 g_119 g_134 g_150 g_170 g_3 g_172 g_254 g_157 g_118 g_382
 */
static int16_t  func_31(int8_t  p_32)
{ /* block id: 37 */
    uint32_t l_83 = 0x038991F3L;
    int32_t *l_84 = &g_41;
    int32_t *l_149 = &g_150;
    int32_t **l_448 = (void*)0;
    int32_t **l_449 = &l_84;
    uint16_t l_450 = 0x5D93L;
    struct S0 **l_455 = &g_254;
    struct S0 ***l_454 = &l_455;
    int16_t l_487 = 1L;
    int32_t ****l_507 = &g_134;
    const uint32_t l_534 = 18446744073709551610UL;
    (*l_449) = func_34(p_32, g_40, p_32, func_42(((void*)0 != &g_41), func_48(func_52(func_55(g_3, func_61(&g_41, func_67(((uint16_t)((int16_t)p_32 - (int16_t)(((int16_t)((uint16_t)((uint32_t)5UL % (uint32_t)0x8F57F54AL) - (uint16_t)g_3) >> (int16_t)l_83) >= l_83)) << (uint16_t)p_32), &g_41, g_41, l_83, l_84), g_3, p_32, g_3), l_149, p_32, &g_150), l_84), p_32, g_3), g_3, l_83, g_3), p_32);
    (*l_449) = (void*)0;
    if (l_450)
    { /* block id: 331 */
        int32_t *l_451 = &g_119.f0;
        uint32_t l_462 = 4294967295UL;
        struct S0 l_478 = {0L,0x24934287L,0x7CF8L};
        int32_t l_511 = 0x2810DE2CL;
        struct S0 ***l_530 = &l_455;
        struct S0 ****l_531 = &l_530;
        if ((((65527UL < 1UL) && (func_48(l_451, p_32, g_108) & (*g_40))) < (((int16_t)(&g_170 != l_454) >> (int16_t)11) > 0xD11894E5L)))
        { /* block id: 332 */
            int32_t ***l_463 = &l_448;
            int32_t *l_477 = &g_108;
            struct S0 ***l_500 = &l_455;
            int32_t l_510 = (-2L);
            uint16_t l_512 = 1UL;
            (*l_451) = ((uint16_t)(((*l_451) | g_172.f0) & ((uint32_t)p_32 - (uint32_t)(((((*l_149) && (*l_149)) != (0xCD8BL || p_32)) ^ g_119.f1) && (((int32_t)((g_150 || p_32) == 65527UL) % (int32_t)(*l_149)) == 0x7A56B2E2L)))) % (uint16_t)l_462);
            if (((void*)0 != l_463))
            { /* block id: 334 */
                int32_t *l_471 = &g_119.f0;
                int32_t l_489 = 0x8BD340B4L;
                (*g_168) = p_32;
                if (p_32)
                { /* block id: 336 */
                    const int32_t **l_469 = &g_40;
                    const int32_t ***l_468 = &l_469;
                    int32_t ***l_470 = (void*)0;
                    struct S0 l_476 = {0x366C97C4L,8UL,0x9AC6L};
                    (*l_451) = ((int32_t)__builtin_ia32_crc32qi(((*l_451) ^ p_32), (0UL < 0xFC4DCCAAL)) - (int32_t)4294967292UL);
                    (*l_149) = (((int16_t)((l_468 == l_470) < (func_48(l_471, ((void*)0 != &l_149), func_48((*l_449), (*l_477), g_229)) <= g_229)) >> (int16_t)1) != g_108);
                    (*g_171) = l_476;
                    (*g_171) = l_478;
                }
                else
                { /* block id: 341 */
                    const uint32_t l_488 = 0xCC50CA02L;
                    int32_t *l_490 = &g_41;
                    struct S0 l_513 = {0x7F39B09FL,1UL,0x7E15L};
                    if (p_32)
                    { /* block id: 342 */
                        struct S0 ****l_479 = (void*)0;
                        struct S0 ****l_480 = (void*)0;
                        struct S0 ****l_481 = &l_454;
                        int32_t l_484 = 0x28267DA7L;
                        (*l_481) = (void*)0;
                        l_484 = ((uint16_t)((g_172.f1 == l_484) & 0xACCBL) % (uint16_t)((int16_t)(&g_119 != (void*)0) >> (int16_t)14));
                        (*l_477) = l_487;
                        (*l_149) = (*l_477);
                    }
                    else
                    { /* block id: 347 */
                        (*l_449) = l_490;
                    }
                    (*l_477) = ((uint16_t)0x9A8CL << (uint16_t)8);
                    for (g_119.f0 = 0; (g_119.f0 != (-20)); --g_119.f0)
                    { /* block id: 353 */
                        uint32_t l_495 = 0x0BBAF738L;
                        int32_t *l_514 = &l_513.f0;
                        l_495 = (*l_451);
                        (*l_490) = p_32;
                        (*l_449) = func_34(((((uint16_t)(((l_495 >= (*l_477)) >= ((((void*)0 == l_500) < (((((uint32_t)(((int32_t)(((int16_t)(l_507 != &g_134) >> (int16_t)((*l_471) & g_119.f1)) | ((int16_t)(((((void*)0 == &l_451) != (-1L)) != g_172.f0) <= (*l_451)) << (int16_t)0)) % (int32_t)p_32) || l_510) + (uint32_t)l_511) || l_512) & g_150) && p_32)) <= (*l_149))) >= p_32) + (uint16_t)0UL) || p_32) && (*l_471)), (*l_449), (*l_451), l_490, p_32);
                        (*l_449) = l_490;
                    }
                }
            }
            else
            { /* block id: 360 */
                for (l_462 = 0; (l_462 <= 54); l_462++)
                { /* block id: 363 */
                    (*l_449) = &l_511;
                }
            }
            return g_119.f1;
        }
        else
        { /* block id: 368 */
            (*g_189) = ((g_517 != (void*)0) == ((int32_t)(((void*)0 == &l_511) && g_41) + (int32_t)((int32_t)(p_32 == ((uint32_t)(((uint32_t)__builtin_ffsl(((p_32 ^ (g_172.f0 == ((((uint16_t)(((g_150 & p_32) | p_32) && (*g_40)) + (uint16_t)65535UL) > g_150) || 0x4130L))) || (-8L))) % (uint32_t)0xC7A17804L) & 0xD10AL) - (uint32_t)0xD28105E0L)) - (int32_t)1UL)));
        }
        (*l_451) = 0x2659E05DL;
        (*l_531) = l_530;
    }
    else
    { /* block id: 373 */
        struct S0 l_535 = {-6L,0x61C70C22L,0x5F7FL};
        int32_t *l_537 = &l_535.f0;
        for (g_119.f0 = (-5); (g_119.f0 == 4); g_119.f0 += 6)
        { /* block id: 376 */
            int32_t *l_536 = &g_150;
            l_537 = l_537;
        }
    }
    return g_172.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_170 g_171
 * writes: g_172
 */
static int32_t * func_34(int32_t  p_35, const int32_t * p_36, int32_t  p_37, int32_t * p_38, int32_t  p_39)
{ /* block id: 326 */
    int32_t *****l_442 = &g_382;
    int32_t *l_443 = &g_41;
    int32_t *l_444 = (void*)0;
    uint16_t l_445 = 0xAD99L;
    struct S0 l_446 = {0xBC0D3886L,0x1C0B45EBL,65535UL};
    int32_t *l_447 = &g_41;
    (**g_170) = l_446;
    return l_447;
}


/* ------------------------------------------ */
/* 
 * reads : g_168 g_119.f0 g_170 g_3 g_94 g_95 g_40 g_41 g_187 g_189 g_172.f2 g_108 g_107 g_109 g_118 g_129 g_133 g_150 g_119 g_171 g_212 g_216 g_157 g_172.f0 g_229 g_253 g_254 g_172 g_381 g_382
 * writes: g_170 g_3 g_108 g_150 g_119.f0 g_41 g_95 g_119 g_134 g_172 g_254 g_157 g_118 g_382
 */
static int32_t * func_42(int8_t  p_43, const uint32_t  p_44, int32_t  p_45, int32_t  p_46, int8_t  p_47)
{ /* block id: 124 */
    int32_t ****l_179 = &g_134;
    struct S0 *l_196 = &g_119;
    int32_t *l_246 = &g_119.f0;
    const uint32_t l_271 = 0UL;
    int32_t **l_280 = &g_95;
    int32_t ***l_279 = &l_280;
    int32_t l_324 = (-4L);
    uint32_t l_433 = 0UL;
    int32_t *l_435 = &g_150;
    if ((*g_168))
    { /* block id: 125 */
        volatile struct S0 * volatile **l_173 = (void*)0;
        volatile struct S0 * volatile **l_174 = &g_170;
        int32_t ****l_180 = &g_134;
        (*l_174) = g_170;
        for (g_3 = 0; (g_3 != 36); g_3++)
        { /* block id: 129 */
            const struct S0 *l_183 = &g_119;
            const struct S0 **l_182 = &l_183;
            const struct S0 ***l_181 = &l_182;
            int32_t *l_184 = &g_108;
            int32_t **l_185 = &l_184;
            (*l_184) = (((int16_t)__builtin_bswap64(p_46) << (int16_t)(l_179 == l_180)) | (l_181 == (void*)0));
            (*l_185) = (*g_94);
        }
    }
    else
    { /* block id: 133 */
        uint16_t l_186 = 0x0302L;
        int32_t *l_199 = &g_108;
        int32_t ****l_202 = &g_134;
        struct S0 *l_243 = &g_119;
        uint16_t l_302 = 0xF9F5L;
        int32_t l_398 = (-1L);
        if (l_186)
        { /* block id: 134 */
            (*g_187) = (*g_40);
        }
        else
        { /* block id: 136 */
            int32_t l_194 = (-1L);
            int32_t *****l_213 = &l_202;
            int32_t *l_227 = &g_108;
            struct S0 l_255 = {0xD9387172L,0x58A08477L,0x48CBL};
            uint32_t l_263 = 0x1950191FL;
            struct S0 * volatile *l_305 = &g_118;
            const int32_t l_350 = 0x45276D52L;
            if (p_46)
            { /* block id: 137 */
                int32_t *l_197 = &l_194;
                uint32_t l_198 = 4294967290UL;
                int32_t *****l_252 = (void*)0;
                (*g_189) = (~g_3);
                if (((int16_t)__builtin_ia32_crc32qi(p_44, (p_44 <= func_67(g_172.f2, l_197, l_194, (*l_199), l_199))) << (int16_t)4))
                { /* block id: 139 */
                    (**g_170) = func_61(l_197, p_46, g_41, ((*g_187) & 0x05891831L), p_47);
                }
                else
                { /* block id: 141 */
                    struct S0 l_218 = {1L,18446744073709551610UL,0x96E2L};
                    int32_t *l_222 = &l_218.f0;
                    int32_t *l_223 = &l_218.f0;
                    int32_t *l_224 = (void*)0;
                    struct S0 **l_225 = (void*)0;
                    int32_t **l_233 = &l_227;
                    if (((int16_t)p_46 >> (int16_t)10))
                    { /* block id: 142 */
                        uint16_t l_205 = 1UL;
                        const int16_t l_214 = (-1L);
                        int32_t *l_215 = &g_41;
                        l_205 = (*g_168);
                        (*l_197) = (g_41 ^ ((int16_t)p_44 % (int16_t)(p_46 | (1UL ^ ((*l_197) >= 0x83F8AD03L)))));
                        (*g_216) = func_55(p_46, func_61((*g_94), ((((int16_t)g_119.f0 - (int16_t)(+(~(-7L)))) ^ ((l_194 | p_45) ^ (g_212 == l_213))) == l_214), g_119.f1, p_43, (*l_197)), l_215, p_46, l_197);
                    }
                    else
                    { /* block id: 146 */
                        int32_t *l_217 = &g_41;
                        int32_t *l_219 = &g_108;
                        (*g_129) = func_52(l_217, (*g_216));
                        l_199 = func_55(p_43, l_218, l_219, ((uint16_t)4UL << (uint16_t)g_41), l_222);
                        return l_224;
                    }
                    if (__builtin_ia32_crc32qi(p_46, (&l_196 == l_225)))
                    { /* block id: 151 */
                        int32_t **l_226 = &l_199;
                        (*l_226) = (*g_94);
                        l_227 = l_223;
                    }
                    else
                    { /* block id: 154 */
                        int32_t *l_228 = &g_108;
                        struct S0 l_231 = {4L,1UL,65532UL};
                        int32_t **l_232 = &l_223;
                        (*g_216) = l_228;
                        (*l_232) = func_52(func_55(p_46, l_231, l_197, g_119.f1, func_55(p_43, (*l_196), l_224, g_172.f0, l_197)), &g_150);
                        (*l_227) = ((__builtin_ctzll(p_45) != (*l_197)) && (__builtin_bswap32((0UL & (4294967295UL ^ (*l_228)))) && (&l_179 != &g_133)));
                    }
                    (*l_233) = l_197;
                    (*l_222) = ((!((int16_t)(g_229 != (p_44 >= ((uint32_t)((int32_t)((&g_133 == (void*)0) > ((0UL | g_172.f0) || (g_172.f2 || ((int32_t)(*g_189) - (int32_t)(p_47 && 1UL))))) % (int32_t)p_46) % (uint32_t)0xA1C93EE8L))) + (int16_t)g_229)) ^ p_45);
                }
                if (((l_243 != (*g_170)) == ((int16_t)(l_246 == (*g_94)) + (int16_t)((((uint32_t)0xA8AAFD5AL - (uint32_t)((g_119.f0 == ((uint32_t)((*l_197) | g_41) % (uint32_t)(-(uint32_t)((void*)0 != l_252)))) == p_46)) > 7L) < g_108))))
                { /* block id: 162 */
                    (*g_94) = (*g_129);
                    (*g_171) = (*g_118);
                    return (*g_216);
                }
                else
                { /* block id: 166 */
                    (*g_168) = p_47;
                    (*g_253) = l_196;
                    l_255 = l_255;
                }
            }
            else
            { /* block id: 171 */
                struct S0 l_261 = {0x1C156C5BL,0UL,0xD3CCL};
                int32_t *l_270 = &g_41;
                int8_t l_298 = 0L;
                if (((uint16_t)65526UL >> (uint16_t)3))
                { /* block id: 172 */
                    for (p_43 = (-8); (p_43 < 9); p_43 += 1)
                    { /* block id: 175 */
                        struct S0 l_260 = {0x97FE0C69L,18446744073709551614UL,0UL};
                        l_261 = l_260;
                    }
                    (*l_227) = ((*l_199) >= p_46);
                }
                else
                { /* block id: 179 */
                    int32_t *l_262 = &g_41;
                    (**g_170) = func_61(l_262, (0L < l_263), ((((int32_t)((uint16_t)g_41 >> (uint16_t)12) + (int32_t)l_261.f0) != p_44) & func_48(l_262, (((void*)0 == (*l_213)) < 0x34FBL), l_261.f0)), (*l_262), l_261.f2);
                    return (*g_216);
                }
                (*l_270) = ((uint32_t)(func_87(l_270, p_44, (g_119.f1 >= g_229), g_119.f2) < (g_41 && ((0x8F840392L == (p_45 & l_271)) && 0x3C32L))) + (uint32_t)0xC5ECF491L);
                for (g_119.f0 = 23; (g_119.f0 == 9); g_119.f0 -= 6)
                { /* block id: 186 */
                    int32_t *l_276 = (void*)0;
                    (*g_94) = l_270;
                    for (l_261.f1 = (-23); (l_261.f1 <= 26); l_261.f1++)
                    { /* block id: 190 */
                        (*l_227) = (p_43 && (&l_243 != &g_171));
                        (*l_199) = ((void*)0 != &l_276);
                    }
                    (*g_95) = (p_47 > p_43);
                    (*l_179) = l_279;
                }
                (*l_227) = (*g_109);
            }
            if ((((__builtin_popcount(((uint32_t)0x6334DF25L + (uint32_t)0x7EB5314AL)) | p_44) ^ (&g_134 != (*l_213))) != (((-(int16_t)__builtin_clzl(g_3)) != (l_302 | g_108)) <= p_44)))
            { /* block id: 199 */
                int32_t *l_306 = &g_41;
                int32_t ***l_312 = &l_280;
                struct S0 *l_331 = &l_255;
                for (l_255.f0 = 0; (l_255.f0 != 0); l_255.f0 += 7)
                { /* block id: 202 */
                    struct S0 **l_313 = &l_243;
                    int32_t l_314 = (-8L);
                    if ((g_150 == g_172.f0))
                    { /* block id: 203 */
                        int32_t ***l_307 = &l_280;
                        l_305 = &g_157;
                        (*l_280) = l_306;
                        l_307 = (void*)0;
                        if ((*l_306))
                            break;
                    }
                    else
                    { /* block id: 208 */
                        int32_t *l_308 = &l_255.f0;
                        return (*g_216);
                    }
                    (*l_280) = func_52(func_55((((p_43 | g_119.f1) && p_43) & (p_46 != __builtin_clz((*l_227)))), (**l_305), &g_41, p_44, (**l_279)), l_306);
                    if (((uint16_t)((**g_94) != ((*g_40) & (g_3 < __builtin_clz(g_150)))) >> (uint16_t)13))
                    { /* block id: 212 */
                        int32_t l_325 = (-3L);
                        struct S0 l_326 = {0x07FCD342L,18446744073709551615UL,0x6D65L};
                        (**l_313) = func_61(l_306, ((((-(uint32_t)(((void*)0 == l_312) >= ((void*)0 == l_313))) ^ g_119.f0) <= g_41) > 2UL), g_119.f1, p_46, g_172.f2);
                        (**g_170) = func_61((**l_312), l_314, ((-(uint16_t)(((int16_t)((int16_t)l_314 >> (int16_t)p_47) << (int16_t)9) <= func_48((*g_94), (((uint32_t)g_119.f1 % (uint32_t)g_229) < ((int16_t)(*l_227) - (int16_t)(1UL & g_119.f2))), p_44))) | l_324), l_325, g_108);
                        (*g_254) = l_326;
                    }
                    else
                    { /* block id: 216 */
                        return (*g_216);
                    }
                }
                for (g_108 = 0; (g_108 != 8); g_108 += 8)
                { /* block id: 222 */
                    int32_t *l_332 = &g_108;
                    (*l_306) = p_44;
                    for (g_119.f1 = 0; (g_119.f1 > 44); g_119.f1++)
                    { /* block id: 226 */
                        (*l_305) = l_331;
                        return (**l_312);
                    }
                    (*l_280) = (**l_312);
                    (**g_170) = func_61(func_52(l_332, l_332), (g_41 ^ (*g_40)), g_229, (*g_40), (g_41 ^ 0xBADDL));
                }
            }
            else
            { /* block id: 233 */
                int32_t l_359 = 0x5FEBDA90L;
                struct S0 *l_363 = (void*)0;
                int32_t *l_372 = &l_194;
                for (l_255.f1 = 12; (l_255.f1 >= 16); l_255.f1++)
                { /* block id: 236 */
                    uint32_t l_335 = 18446744073709551611UL;
                    int32_t ***l_349 = &l_280;
                    const uint32_t l_351 = 0x5DF848EFL;
                    (**l_279) = (void*)0;
                    if (p_47)
                        break;
                    if (l_335)
                    { /* block id: 239 */
                        int32_t **l_342 = (void*)0;
                        (*l_227) = ((int16_t)((uint32_t)(((((uint16_t)(((void*)0 == &l_280) > (l_342 != &g_297)) >> (uint16_t)((int32_t)((int16_t)__builtin_popcount(((uint32_t)((p_45 >= 0L) || g_108) % (uint32_t)4294967295UL)) << (int16_t)15) % (int32_t)p_45)) == l_350) >= g_150) == g_119.f2) % (uint32_t)g_41) << (int16_t)12);
                        (*l_246) = l_351;
                    }
                    else
                    { /* block id: 242 */
                        struct S0 *l_352 = &g_119;
                        l_352 = (*g_253);
                        return (**l_349);
                    }
                }
                (*g_253) = (void*)0;
                for (g_150 = 0; (g_150 <= (-19)); --g_150)
                { /* block id: 250 */
                    int16_t l_360 = (-1L);
                    int16_t l_364 = (-1L);
                    (**g_170) = func_61(func_52((*g_129), &g_108), p_47, g_229, ((&l_255 != (void*)0) > ((int32_t)((((uint32_t)((((__builtin_ctzll(((-8L) || l_359)) | 0xA7AA2B66L) | g_150) | p_45) ^ (*g_40)) + (uint32_t)l_360) && g_108) != 1L) - (int32_t)4294967292UL)), p_46);
                    if (((int16_t)l_360 << (int16_t)1))
                    { /* block id: 252 */
                        (*g_171) = (**g_170);
                    }
                    else
                    { /* block id: 254 */
                        int32_t *l_365 = &g_150;
                        l_364 = ((void*)0 == l_363);
                        (*l_243) = (*g_118);
                        (**l_279) = l_365;
                    }
                }
                (*l_246) = ((0x7AD5L != (+p_47)) != ((int16_t)((int16_t)(func_87(func_52(&l_359, func_55((p_44 ^ (__builtin_ffs((g_119.f0 | p_44)) < (((!((*l_227) || p_47)) != (*l_246)) <= p_45))), (*l_243), (*g_129), g_150, l_372)), g_229, p_43, p_44) > 0x76B666AEL) << (int16_t)13) + (int16_t)65535UL));
            }
        }
        if (((uint32_t)(~(((__builtin_bswap32(((void*)0 == l_243)) | ((+(p_46 ^ (&l_179 == &l_179))) <= 65526UL)) <= g_229) <= ((((uint16_t)0xF896L + (uint16_t)0x639DL) == p_46) ^ p_46))) % (uint32_t)p_45))
        { /* block id: 263 */
            int32_t *l_379 = &g_150;
            (**l_279) = func_52(l_379, l_379);
        }
        else
        { /* block id: 265 */
            int32_t ****l_380 = &l_279;
            struct S0 l_401 = {0x3191E1A1L,0x6C9B00F3L,0x2DFCL};
            (*g_381) = l_380;
            (*l_196) = (*l_243);
            for (g_108 = 12; (g_108 != (-30)); --g_108)
            { /* block id: 270 */
                int32_t *l_389 = (void*)0;
                (*l_196) = (*l_243);
                (*l_246) = (0UL || ((((uint32_t)((*g_170) != l_243) - (uint32_t)g_172.f0) || (p_43 && ((int16_t)(func_48(l_389, ((uint16_t)(((int16_t)(((int16_t)((int16_t)(0x13B58B0DL || p_44) >> (int16_t)3) >> (int16_t)p_46) & l_398) % (int16_t)p_43) > 5UL) + (uint16_t)p_45), p_45) == g_3) >> (int16_t)2))) == p_46));
            }
            for (g_41 = 0; (g_41 == (-16)); g_41 -= 1)
            { /* block id: 276 */
                int32_t *l_402 = &g_119.f0;
                (*l_243) = l_401;
                (***g_382) = func_52(func_52(l_402, l_402), &g_41);
            }
        }
        for (l_398 = 0; (l_398 >= 18); l_398++)
        { /* block id: 283 */
            int32_t *l_409 = &g_41;
            int32_t *l_432 = (void*)0;
            struct S0 l_434 = {-6L,0xEA31AFB0L,8UL};
            for (g_41 = 0; (g_41 >= (-4)); --g_41)
            { /* block id: 286 */
                int32_t *l_411 = &g_108;
                for (g_150 = 0; (g_150 >= 17); g_150 += 7)
                { /* block id: 289 */
                    int32_t *l_410 = &g_108;
                    (*l_280) = func_52(func_52(l_409, func_52(l_410, func_52(func_52(l_411, l_409), &g_150))), l_410);
                    (*l_410) = p_43;
                }
                (*l_280) = func_52(l_411, l_411);
                if ((**g_216))
                    continue;
                (*g_171) = (*l_196);
            }
            for (g_119.f2 = 12; (g_119.f2 > 52); ++g_119.f2)
            { /* block id: 299 */
                int32_t *l_422 = &g_150;
                struct S0 **l_428 = &l_243;
                if ((-(int16_t)((uint16_t)((void*)0 == &l_202) >> (uint16_t)14)))
                { /* block id: 300 */
                    uint32_t l_419 = 1UL;
                    int32_t *l_429 = &g_41;
                    if (((uint16_t)l_419 - (uint16_t)(((((void*)0 == &l_243) && ((uint16_t)p_45 + (uint16_t)func_48(l_422, (*l_422), ((uint16_t)g_41 >> (uint16_t)11)))) && (+(((*l_409) | (*l_422)) < 65535UL))) ^ 0x16F8L)))
                    { /* block id: 301 */
                        (*l_246) = ((void*)0 != &l_199);
                    }
                    else
                    { /* block id: 303 */
                        uint16_t l_426 = 0x9D7DL;
                        l_426 = p_43;
                        (*l_280) = l_409;
                        (**l_280) = (+((void*)0 == l_428));
                    }
                    (*l_409) = func_48(l_429, ((&g_253 == (void*)0) <= p_43), p_43);
                    for (p_43 = 0; (p_43 > (-23)); --p_43)
                    { /* block id: 311 */
                        return l_422;
                    }
                }
                else
                { /* block id: 314 */
                    if (p_45)
                        break;
                }
            }
            (*l_246) = p_43;
            l_434 = func_61(func_52(l_432, func_52(l_409, l_199)), l_433, g_3, p_44, p_45);
        }
        (*g_171) = func_61(l_246, p_44, p_43, p_44, p_44);
    }
    (*l_246) = (func_87(l_435, (g_229 || (((uint16_t)__builtin_ffsll((0x76A8L == 0x7910L)) + (uint16_t)p_46) != ((p_43 ^ ((p_47 != 65529UL) >= 0x7B7643B9L)) ^ g_41))), p_45, g_119.f2) && p_45);
    (**l_279) = (*l_280);
    return (*l_280);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_108 g_168
 * writes: g_119.f0
 */
static const uint32_t  func_48(int32_t * p_49, int32_t  p_50, int16_t  p_51)
{ /* block id: 120 */
    int32_t l_158 = 0L;
    struct S0 *l_159 = &g_119;
    int32_t ****l_164 = &g_134;
    int8_t l_167 = 0x13L;
    struct S0 **l_169 = &l_159;
    (*g_168) = (p_51 & (l_158 >= ((&g_119 == l_159) ^ ((uint32_t)((uint32_t)g_3 - (uint32_t)((l_158 < ((void*)0 != l_164)) && ((((((int16_t)0xADCAL >> (int16_t)l_158) ^ p_50) < g_108) > p_50) != l_167))) % (uint32_t)0x8BCBAD6AL))));
    (*l_169) = l_159;
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_150 g_157
 * writes: g_119
 */
static int32_t * func_52(int32_t * p_53, const int32_t * p_54)
{ /* block id: 113 */
    const struct S0 l_156 = {-10L,1UL,0xD5AEL};
    if ((g_150 && g_150))
    { /* block id: 114 */
        (*g_157) = l_156;
    }
    else
    { /* block id: 116 */
        return p_53;
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_41 g_94 g_95
 * writes: g_41 g_150 g_108
 */
static int32_t * func_55(const int32_t  p_56, struct S0  p_57, int32_t * p_58, int16_t  p_59, int32_t * p_60)
{ /* block id: 103 */
    int32_t **l_151 = &g_95;
    int32_t ****l_155 = &g_134;
    int32_t *****l_154 = &l_155;
    l_151 = l_151;
    for (g_41 = (-22); (g_41 < 25); g_41 += 6)
    { /* block id: 107 */
        return (*g_94);
    }
    (*p_60) = 0xF915BDEDL;
    (*l_154) = (void*)0;
    return (*l_151);
}


/* ------------------------------------------ */
/* 
 * reads : g_94 g_118 g_119
 * writes: g_95
 */
static struct S0  func_61(int32_t * p_62, int32_t  p_63, uint32_t  p_64, int32_t  p_65, uint16_t  p_66)
{ /* block id: 99 */
    (*g_94) = (void*)0;
    p_62 = &p_63;
    return (*g_118);
}


/* ------------------------------------------ */
/* 
 * reads : g_41 g_3 g_40 g_94 g_95 g_107 g_108 g_109 g_118 g_129 g_133
 * writes: g_41 g_95 g_108 g_119 g_134
 */
static int32_t  func_67(int32_t  p_68, int32_t * p_69, const int8_t  p_70, int32_t  p_71, int32_t * p_72)
{ /* block id: 38 */
    int8_t l_93 = (-5L);
    for (g_41 = 0; (g_41 != 7); g_41++)
    { /* block id: 41 */
        int32_t *l_92 = &g_41;
        int32_t l_148 = 1L;
        l_148 = (0L | func_87(l_92, p_70, g_3, (l_93 >= (*g_40))));
        return (*l_92);
    }
    return (*p_69);
}


/* ------------------------------------------ */
/* 
 * reads : g_94 g_40 g_41 g_95 g_3 g_107 g_108 g_109 g_118 g_129 g_133 g_150
 * writes: g_95 g_108 g_119 g_134
 */
static uint16_t  func_87(int32_t * p_88, const uint32_t  p_89, int8_t  p_90, uint32_t  p_91)
{ /* block id: 42 */
    int32_t *l_99 = &g_41;
    struct S0 l_117 = {0x35F52D29L,0x891F928DL,0x5E26L};
    int32_t **l_145 = &g_95;
    int32_t ***l_144 = &l_145;
    (*g_94) = p_88;
    if ((*g_40))
    { /* block id: 44 */
        int16_t l_98 = 0L;
        uint32_t l_106 = 1UL;
        (*g_107) = ((uint32_t)(l_98 == ((((*g_94) == l_99) & (g_41 >= ((((1UL == __builtin_parity(((p_89 < (((((*p_88) || ((int32_t)((((int32_t)((int16_t)((*l_99) | (*p_88)) << (int16_t)(*l_99)) - (int32_t)l_106) | 1UL) ^ 0xF898L) + (int32_t)4294967295UL)) > 1UL) ^ (*g_40)) <= g_3)) > (*l_99)))) < (*l_99)) & 0xFDB9L) != g_3))) < (-1L))) + (uint32_t)0x4C26B3FAL);
        (*g_109) = (0UL | g_108);
    }
    else
    { /* block id: 47 */
        uint32_t l_146 = 0UL;
        int32_t *l_147 = &g_119.f0;
        for (p_91 = (-22); (p_91 >= 38); p_91++)
        { /* block id: 50 */
            int32_t *l_135 = &g_108;
            int32_t ****l_143 = &g_134;
            for (p_90 = 0; (p_90 != 0); p_90 += 4)
            { /* block id: 53 */
                uint32_t l_125 = 1UL;
                int32_t **l_131 = &g_95;
                int32_t ***l_130 = &l_131;
                struct S0 *l_138 = &l_117;
                if ((*p_88))
                { /* block id: 54 */
                    int8_t l_124 = (-1L);
                    for (g_108 = 0; (g_108 == (-13)); --g_108)
                    { /* block id: 57 */
                        int32_t **l_116 = &g_95;
                        (*l_116) = (*g_94);
                        (*l_116) = (void*)0;
                        (*g_118) = l_117;
                    }
                    (*g_107) = ((int16_t)(0x64D7EEACL == 0L) >> (int16_t)((int16_t)5L + (int16_t)((l_124 != (65535UL < l_125)) ^ ((int16_t)((&l_117 != (void*)0) && ((0x2D270846L == 1UL) | (*p_88))) - (int16_t)p_89))));
                }
                else
                { /* block id: 63 */
                    int32_t l_128 = 9L;
                    struct S0 l_139 = {0xE316ED27L,0x7F92971DL,1UL};
                    if (l_128)
                    { /* block id: 64 */
                        if ((*g_40))
                            break;
                        (*g_107) = (*p_88);
                    }
                    else
                    { /* block id: 67 */
                        int32_t ****l_132 = (void*)0;
                        (*g_129) = p_88;
                        (*g_133) = l_130;
                        if ((*l_99))
                            continue;
                        (*l_131) = l_135;
                    }
                    for (g_119.f2 = 0; (g_119.f2 == 21); g_119.f2 += 2)
                    { /* block id: 75 */
                        l_128 = (l_138 != &l_117);
                        l_139 = l_139;
                    }
                }
                if (__builtin_popcount(((uint32_t)(!((0x1802L <= ((l_143 != (void*)0) == 1UL)) ^ g_41)) - (uint32_t)(*g_107))))
                { /* block id: 80 */
                    (*l_143) = l_144;
                }
                else
                { /* block id: 82 */
                    (*l_131) = p_88;
                    (**l_130) = (*l_145);
                    (*l_138) = (*l_138);
                }
                (*l_135) = 0x35B3985EL;
            }
            if (l_146)
                break;
        }
        (*l_147) = 0xBC952145L;
        (*l_145) = (*l_145);
    }
    return g_41;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_41, "g_41", print_hash_value);
    transparent_crc(g_108, "g_108", print_hash_value);
    transparent_crc(g_119.f0, "g_119.f0", print_hash_value);
    transparent_crc(g_119.f1, "g_119.f1", print_hash_value);
    transparent_crc(g_119.f2, "g_119.f2", print_hash_value);
    transparent_crc(g_150, "g_150", print_hash_value);
    transparent_crc(g_172.f0, "g_172.f0", print_hash_value);
    transparent_crc(g_172.f1, "g_172.f1", print_hash_value);
    transparent_crc(g_172.f2, "g_172.f2", print_hash_value);
    transparent_crc(g_229, "g_229", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 145
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 252
   depth: 2, occurrence: 40
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 8
   depth: 7, occurrence: 4
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 11, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 6
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 2
   depth: 30, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 151

XXX times a variable address is taken: 165
XXX times a pointer is dereferenced on RHS: 130
breakdown:
   depth: 1, occurrence: 117
   depth: 2, occurrence: 13
XXX times a pointer is dereferenced on LHS: 111
breakdown:
   depth: 1, occurrence: 97
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 810

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 732
   level: 2, occurrence: 86
   level: 3, occurrence: 96
   level: 4, occurrence: 78
   level: 5, occurrence: 11
XXX number of pointers point to pointers: 67
XXX number of pointers point to scalars: 72
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 25.8
XXX average alias set size: 1.5

XXX times a non-volatile is read: 745
XXX times a non-volatile is write: 238
XXX times a volatile is read: 54
XXX    times read thru a pointer: 7
XXX times a volatile is write: 44
XXX    times written thru a pointer: 19
XXX times a volatile is available for access: 328
XXX percentage of non-volatile access: 90.9

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 211
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 20
   depth: 2, occurrence: 21
   depth: 3, occurrence: 28
   depth: 4, occurrence: 53
   depth: 5, occurrence: 58

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
********************* end of statistics **********************/

