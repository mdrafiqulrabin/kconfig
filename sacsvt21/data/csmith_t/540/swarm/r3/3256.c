/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      1433248986
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 27;
   unsigned f1 : 4;
};

struct S1 {
   unsigned f0 : 11;
   signed f1 : 18;
   unsigned f2 : 12;
   signed f3 : 1;
   uint32_t  f4;
   unsigned f5 : 11;
   unsigned f6 : 24;
   signed f7 : 7;
   unsigned f8 : 8;
   unsigned f9 : 19;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static struct S1  func_1(void);
static int16_t  func_4(int32_t  p_5, int8_t  p_6);
inline static struct S0  func_8(struct S0  p_9);
static int8_t  func_18(struct S1  p_19, uint32_t  p_20, uint8_t  p_21, uint32_t  p_22);
inline static int32_t  func_24(uint32_t  p_25);
inline static uint16_t  func_26(int16_t  p_27);
inline static uint32_t  func_35(uint32_t  p_36, uint32_t  p_37);
inline static struct S0  func_40(int32_t  p_41, uint16_t  p_42, int8_t  p_43, int32_t  p_44, struct S1  p_45);
inline static struct S0  func_51(int32_t  p_52, uint32_t  p_53, uint16_t  p_54, uint32_t  p_55);
static uint8_t  func_64(uint32_t  p_65, uint32_t  p_66, struct S0  p_67);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_1(void)
{ /* block id: 0 */
    uint16_t l_7 = 0x79B6;
    struct S0 l_714 = {7736,3};
    struct S0 *l_713 = &l_714;
    struct S0 **l_712 = &l_713;
    struct S0 ***l_711 = &l_712;
    struct S0 ****l_710 = &l_711;
    struct S1 l_720 = {25,266,19,0,0xE8303B74,42,1501,1,7,474};
    struct S1 *l_719 = &l_720;
    uint32_t l_735 = 0xC26333A5;
    struct S1 ****l_738 = (void*)0;
    struct S0 **l_780 = &l_713;
    uint32_t l_794 = 0x7D1C3543;
    int32_t *l_839 = (void*)0;
    int32_t **l_838 = &l_839;
    int32_t ***l_837 = &l_838;
    struct S1 l_847 = {18,480,14,0,4294967286U,8,2866,-0,11,181};
    int32_t *l_848 = (void*)0;
    int32_t *l_849 = (void*)0;
    struct S0 *****l_856 = (void*)0;
    struct S0 *****l_857 = (void*)0;
    struct S1 l_858 = {15,-143,40,0,4294967291U,21,15,8,11,136};
    if ((((safe_div_func_uint16_t_u_u((func_4(l_7, l_7) && (safe_lshift_func_int16_t_s_s(((l_7 , (safe_add_func_int32_t_s_s(((((l_710 == &l_711) ^ l_714.f0) , (((((safe_rshift_func_uint8_t_u_s(l_714.f1, ((safe_mod_func_uint32_t_u_u(4294967293U, l_7)) || l_714.f0))) && (-9)) >= 0xD9F2) ^ l_714.f0) , l_719)) == &l_720), l_720.f0))) , l_720.f2), 1))), l_714.f0)) && 255U) , 0xBF9764AF))
    { /* block id: 287 */
        int32_t l_726 = (-1);
        struct S0 *l_729 = &l_714;
        struct S1 l_734 = {23,-308,48,-0,0xB74F6348,26,4091,9,2,630};
        uint16_t l_746 = 0x2FF4;
        struct S0 ***l_762 = &l_712;
        struct S1 ****l_765 = (void*)0;
        uint32_t l_795 = 4294967290U;
        uint16_t l_800 = 0x5D0D;
        struct S1 **l_807 = &l_719;
        struct S1 ***l_806 = &l_807;
        uint32_t l_840 = 0U;
        int8_t l_841 = 0x58;
lbl_747:
        (*l_713) = (***l_711);
        for (l_720.f4 = (-25); (l_720.f4 < 47); ++l_720.f4)
        { /* block id: 291 */
            int32_t *l_723 = (void*)0;
            int32_t **l_724 = &l_723;
            int32_t l_725 = 0x341830C2;
            struct S1 l_736 = {3,-82,7,0,0U,2,2494,-4,2,325};
            struct S0 ****l_779 = &l_762;
            (*l_724) = l_723;
            (*l_713) = func_40(l_725, ((*l_719) , l_720.f4), l_726, (((l_729 != (***l_710)) != ((safe_rshift_func_int8_t_s_u(((safe_div_func_int8_t_s_s(((l_726 || ((7 > l_714.f1) , l_720.f5)) && l_720.f3), 0xDA)) | l_720.f9), 2)) >= 0x3D3C)) , l_720.f0), l_734);
            if (((l_735 & (l_736 , l_734.f4)) , (~((l_738 != l_738) == (((&l_726 == &l_726) | (safe_sub_func_uint16_t_u_u((((safe_add_func_int16_t_s_s(((((safe_mod_func_int16_t_s_s(((!((void*)0 != (***l_710))) ^ l_734.f8), (-1))) | l_720.f7) >= 255U) ^ l_720.f6), l_734.f0)) , 4294967295U) && l_746), l_720.f6))) | 0xC670D08E)))))
            { /* block id: 294 */
                int32_t *l_750 = &l_726;
                uint16_t l_783 = 0xB94C;
                if (l_720.f4)
                    goto lbl_747;
                for (l_735 = 0; (l_735 >= 60); l_735++)
                { /* block id: 298 */
                    int32_t **l_753 = &l_723;
                    int32_t *l_755 = &l_725;
                    uint32_t l_777 = 0x1503F3B1;
                    struct S0 **l_785 = &l_729;
                    (*l_724) = l_750;
                    /* statement id: 299 */
                    assert (l_723 == &l_726);
                    for (l_734.f4 = 0; (l_734.f4 < 44); l_734.f4 = safe_add_func_int32_t_s_s(l_734.f4, 1))
                    { /* block id: 302 */
                        int32_t ***l_754 = &l_724;
                        (*l_754) = l_753;
                        (**l_754) = l_755;
                        /* statement id: 304 */
                        assert (l_723 == &l_725);
                    }
                    /* facts after for loop */
                    assert (l_723 == &l_725 || l_723 == &l_726);
                    (****l_710) = (l_734 , (*l_729));
                    if ((safe_sub_func_uint32_t_u_u((((safe_add_func_uint32_t_u_u(((*l_750) | ((void*)0 != l_762)), 0x06F6B222)) ^ (l_734.f8 , (0x006A && (*l_723)))) > (((safe_add_func_int16_t_s_s(l_734.f7, (((l_720.f2 || 4294967295U) | l_734.f2) ^ (*l_750)))) || (*l_723)) , (*l_723))), (**l_724))))
                    { /* block id: 307 */
                        struct S1 *****l_766 = &l_765;
                        (*l_766) = l_765;
                        (*l_750) = 0x2EE47EB8;
                    }
                    else
                    { /* block id: 310 */
                        struct S0 ****l_778 = &l_762;
                        int32_t l_784 = 0xE1C94F13;
                        uint8_t l_786 = 0x7D;
                        l_786 = (l_735 <= (((safe_sub_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((safe_mod_func_int8_t_s_s(((safe_add_func_int32_t_s_s(l_720.f9, ((l_736 , (safe_div_func_int16_t_s_s(l_777, (*l_750)))) ^ (l_778 != l_779)))) > (l_780 == (func_51(((safe_add_func_int8_t_s_s((*l_755), l_714.f0)) , (*l_755)), l_720.f2, l_783, l_784) , l_785))), 0xB3)), 0x093E43C4)), 0xD41E)) || 65527U) | l_734.f9));
                        (*l_753) = l_750;
                        /* statement id: 312 */
                        assert (l_723 == &l_726);
                    }
                }
                /* facts after for loop */
                assert (l_723 == &l_725 || l_723 == &l_726 || l_723 == 0);
            }
            else
            { /* block id: 315 */
                uint32_t l_787 = 0xDF6208CA;
                struct S0 **l_802 = &l_729;
                struct S1 l_804 = {33,476,57,-0,1U,6,93,2,7,523};
                int32_t *l_811 = &l_725;
                if (((****l_779) , l_787))
                { /* block id: 316 */
                    struct S1 **l_788 = (void*)0;
                    struct S1 **l_789 = &l_719;
                    int32_t l_792 = (-4);
                    uint32_t l_801 = 0x635198F2;
                    struct S0 **l_803 = &l_713;
                    (*l_789) = &l_734;
                    /* statement id: 317 */
                    assert (l_719 == &l_734);
                    if ((safe_lshift_func_int16_t_s_s(l_792, ((((safe_unary_minus_func_uint16_t_u(0U)) <= (((l_794 > (((l_795 & ((l_720.f9 , ((safe_add_func_uint8_t_u_u(((void*)0 == &l_711), ((safe_add_func_uint32_t_u_u((l_800 & (((void*)0 == l_765) || l_801)), l_734.f0)) > 255U))) , l_787)) == 0xA8)) != 0) , l_734.f2)) , l_720.f6) <= l_720.f4)) & l_720.f7) , 0xB495))))
                    { /* block id: 318 */
                        (*l_724) = &l_726;
                        /* statement id: 319 */
                        assert (l_723 == &l_726);
                        l_803 = ((*l_719) , l_802);
                        /* statement id: 320 */
                        assert (l_803 == &l_729);
                        l_804 = l_804;
                        return l_736;
                    }
                    else
                    { /* block id: 323 */
                        return l_736;
                    }
                }
                else
                { /* block id: 326 */
                    struct S1 ****l_808 = &l_806;
                    if (l_734.f3)
                    { /* block id: 327 */
                        return l_804;
                    }
                    else
                    { /* block id: 329 */
                        struct S1 *****l_805 = &l_738;
                        if (l_804.f5)
                            break;
                        (*l_805) = l_738;
                        if (l_720.f8)
                            continue;
                    }
                    (*l_808) = l_806;
                    for (l_787 = 2; (l_787 != 60); l_787 = safe_add_func_int16_t_s_s(l_787, 1))
                    { /* block id: 337 */
                        (***l_762) = (***l_762);
                        return l_804;
                    }
                }
                (*l_724) = l_811;
                /* statement id: 342 */
                assert (l_723 == &l_725);
            }
            /* facts after branching */
            assert (l_723 == &l_725 || l_723 == &l_726 || l_723 == 0);
            return l_736;
        }
        (**l_712) = func_8((****l_710));
        if ((safe_add_func_int32_t_s_s((l_720.f4 , (-4)), (safe_unary_minus_func_int8_t_s((safe_sub_func_uint8_t_u_u(((l_720.f7 > (safe_div_func_uint16_t_u_u((((0x34F6 || (l_735 ^ (safe_unary_minus_func_int8_t_s(((safe_sub_func_int16_t_s_s((((safe_lshift_func_int8_t_s_s(((~(safe_add_func_int16_t_s_s(((((safe_lshift_func_uint16_t_u_u(((l_734.f7 & (((safe_add_func_int16_t_s_s((((safe_mod_func_int8_t_s_s(((l_720.f9 ^ (((safe_sub_func_int32_t_s_s(l_714.f1, (safe_add_func_int16_t_s_s((l_800 , 0xB55A), 0x2339)))) < l_734.f7) | 1)) == l_795), l_795)) || 0x6A) | 1), (-1))) | 0U) , 1U)) < (-7)), 6)) , (void*)0) != l_837) >= 0xC56D), 9U))) > l_734.f7), 5)) >= (-4)) == l_840), l_734.f9)) || l_734.f7))))) ^ 5U) ^ l_841), 0x9885))) == l_734.f3), 255U)))))))
        { /* block id: 347 */
            uint32_t l_842 = 0U;
            (**l_837) = &l_726;
            /* statement id: 348 */
            assert (l_839 == &l_726);
            (**l_837) = (void*)0;
            /* statement id: 349 */
            assert (l_839 == 0);
            l_842 = ((-10) >= (-6));
        }
        else
        { /* block id: 351 */
            uint16_t l_843 = 0xA1A0;
            int32_t *l_844 = &l_726;
            (*l_844) = l_843;
            (**l_837) = l_844;
            /* statement id: 353 */
            assert (l_839 == &l_726);
            (*l_838) = (l_734.f5 , l_844);
        }
        /* facts after branching */
        assert (l_839 == &l_726 || l_839 == 0);
    }
    else
    { /* block id: 356 */
        int32_t l_846 = 0x890C4707;
        int32_t *l_845 = &l_846;
        (*l_845) = 0;
        (**l_837) = (void*)0;
        (*l_719) = l_847;
    }
    /* facts after branching */
    //assert (l_839 == dangling || l_839 == 0);
    l_720.f1 = 0;
    for (l_847.f4 = 0; (l_847.f4 < 10); l_847.f4++)
    { /* block id: 364 */
        int32_t l_853 = 0xB0B09A62;
        int32_t *l_852 = &l_853;
        struct S1 *l_854 = &l_720;
        struct S0 l_855 = {1100,3};
        (**l_837) = l_852;
        /* statement id: 365 */
        assert (l_839 == &l_853);
        l_854 = l_854;
        (*l_838) = (l_855 , &l_853);
    }
    l_710 = &l_711;
    return l_858;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_4(int32_t  p_5, int8_t  p_6)
{ /* block id: 1 */
    struct S0 l_10 = {2587,0};
    struct S0 *l_705 = &l_10;
    (*l_705) = func_8(l_10);
    return p_6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_8(struct S0  p_9)
{ /* block id: 2 */
    int32_t l_11 = 0x6EC7E434;
    struct S1 l_570 = {26,303,60,0,4294967295U,44,2217,-10,13,634};
    struct S0 **l_604 = (void*)0;
    struct S1 *l_684 = &l_570;
    struct S1 **l_683 = &l_684;
    struct S1 ***l_682 = &l_683;
    struct S0 l_704 = {7281,2};
    for (l_11 = (-25); (l_11 <= 16); l_11 = safe_add_func_int32_t_s_s(l_11, 2))
    { /* block id: 5 */
        struct S1 l_23 = {10,-280,40,0,6U,33,223,6,6,289};
        int32_t l_567 = (-6);
        int32_t *l_665 = (void*)0;
        int32_t **l_664 = &l_665;
        int16_t l_670 = 7;
        if ((safe_rshift_func_uint16_t_u_u((safe_add_func_int8_t_s_s(func_18(l_23, l_23.f5, l_23.f4, (func_24(p_9.f1) == (safe_rshift_func_int16_t_s_s((((l_11 && (l_23.f8 <= 0x0C98A87C)) | ((l_11 > l_11) , 0x9A)) ^ l_11), l_23.f2)))), p_9.f0)), l_567)))
        { /* block id: 220 */
            int16_t l_588 = 0x0DC1;
            struct S1 l_592 = {27,126,49,0,4294967295U,33,4061,-2,13,345};
            struct S1 **l_644 = (void*)0;
            struct S1 ***l_643 = &l_644;
            int32_t *l_648 = &l_11;
            int32_t **l_649 = &l_648;
            if (((p_9.f0 & (safe_add_func_uint16_t_u_u(((l_570 , (p_9.f0 && (safe_add_func_int16_t_s_s(((((safe_mod_func_int16_t_s_s(((p_9.f0 , ((safe_add_func_int8_t_s_s(l_570.f7, ((safe_add_func_uint32_t_u_u((safe_sub_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_u((safe_unary_minus_func_uint32_t_u(1U)), 15)), ((safe_div_func_uint8_t_u_u((safe_mod_func_int32_t_s_s(((l_588 , p_9.f0) >= (safe_add_func_uint16_t_u_u(((!(l_592 , 65535U)) & p_9.f0), l_570.f4))), l_23.f3)), l_592.f1)) > 0x91D9))), l_592.f6)) , l_588))) ^ p_9.f0)) , (-6)), p_9.f1)) , p_9.f0) | l_23.f5) && p_9.f0), p_9.f0)))) <= l_23.f7), p_9.f0))) <= p_9.f1))
            { /* block id: 221 */
                struct S1 l_601 = {2,-142,15,-0,0x100AE7E5,36,1459,-8,15,681};
                int32_t *l_607 = &l_11;
                struct S0 *l_635 = (void*)0;
                struct S1 **l_640 = (void*)0;
                for (l_567 = 0; (l_567 <= 16); ++l_567)
                { /* block id: 224 */
                    struct S1 l_602 = {12,-423,42,-0,1U,8,2058,-6,8,221};
                    struct S0 **l_603 = (void*)0;
                    struct S1 *l_620 = &l_602;
                    struct S1 **l_619 = &l_620;
                }
            }
            else
            { /* block id: 243 */
                struct S0 ***l_647 = &l_604;
                struct S0 ****l_646 = &l_647;
                (*l_646) = &l_604;
            }
            if (p_9.f0)
                continue;
            (*l_649) = l_648;
            (*l_649) = (*l_649);
        }
        else
        { /* block id: 249 */
            struct S1 *l_650 = &l_23;
            int32_t *l_653 = &l_11;
            struct S0 ****l_679 = (void*)0;
            struct S1 ***l_699 = &l_683;
            (*l_650) = l_570;
            for (l_567 = 0; (l_567 > 8); l_567 = safe_add_func_uint8_t_u_u(l_567, 6))
            { /* block id: 253 */
                int32_t **l_654 = &l_653;
                struct S0 l_669 = {4940,2};
                struct S0 *l_668 = &l_669;
                struct S1 *l_678 = (void*)0;
                struct S1 ****l_693 = &l_682;
                struct S1 l_703 = {0,485,52,-0,1U,44,4042,5,0,696};
                (*l_654) = l_653;
            }
            if (p_9.f1)
                continue;
        }
    }
    l_704 = l_704;
    return l_704;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_18(struct S1  p_19, uint32_t  p_20, uint8_t  p_21, uint32_t  p_22)
{ /* block id: 217 */
    int32_t l_566 = 0x565A875E;
    int32_t *l_565 = &l_566;
    int32_t **l_564 = &l_565;
    (*l_565) = (l_564 != &l_565);
    return p_21;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_24(uint32_t  p_25)
{ /* block id: 6 */
    uint32_t l_34 = 0xB4EE00B4;
    int32_t l_559 = 0x533807A9;
    int32_t *l_558 = &l_559;
    (*l_558) = ((p_25 , (func_26((safe_add_func_uint8_t_u_u((safe_add_func_int8_t_s_s(0x05, (((p_25 , (0xD0863E87 != (safe_rshift_func_int8_t_s_u((0xABE719C2 & p_25), ((l_34 , l_34) && func_35(((safe_mod_func_int32_t_s_s((5U && l_34), p_25)) > p_25), l_34)))))) <= 0xB7) & l_34))), 0xE7))) ^ p_25)) && 0x84);
    return p_25;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_26(int16_t  p_27)
{ /* block id: 168 */
    struct S0 l_441 = {3232,1};
    struct S0 *l_443 = (void*)0;
    struct S0 **l_442 = &l_443;
    struct S1 l_444 = {13,113,26,0,0x93E2F61A,41,3744,-5,0,426};
    struct S1 *l_445 = &l_444;
    int8_t l_454 = 0xC7;
    int32_t l_461 = 0xFC550BE4;
    int32_t *l_460 = &l_461;
    int32_t **l_459 = &l_460;
    int32_t ***l_458 = &l_459;
    uint32_t l_516 = 0x4A1F350A;
    (*l_442) = (l_441 , &l_441);
    /* statement id: 169 */
    assert (l_443 == &l_441);
    (*l_445) = l_444;
    if ((l_441.f0 <= ((l_444.f4 != (safe_mod_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(l_444.f8, (safe_rshift_func_int8_t_s_u((((&l_445 == &l_445) && (((safe_sub_func_int16_t_s_s(l_454, p_27)) , ((safe_sub_func_int16_t_s_s((((((~(l_458 != ((*l_443) , (void*)0))) , 7U) & 1) , (void*)0) == (void*)0), p_27)) != (*l_460))) , p_27)) > (*l_460)), (**l_459))))), (**l_459)))) < (***l_458))))
    { /* block id: 171 */
        struct S0 **l_465 = &l_443;
        int32_t l_472 = 0xA894548E;
        struct S1 l_473 = {41,367,39,0,4294967287U,10,3573,8,0,581};
        int32_t l_482 = 1;
        (**l_459) = (safe_sub_func_int32_t_s_s(((***l_458) < ((*l_445) , (0x3639 | (~((*l_445) , (&l_443 != l_465)))))), (func_40(((safe_sub_func_uint8_t_u_u((((safe_mod_func_uint16_t_u_u(0x36B2, (safe_rshift_func_uint16_t_u_u(p_27, 0)))) & (***l_458)) & p_27), 255U)) , l_472), l_472, p_27, p_27, l_473) , l_473.f0)));
        (**l_459) = (((((safe_add_func_int8_t_s_s((((((safe_lshift_func_uint8_t_u_u((0x804D7E87 & (((((((safe_sub_func_int32_t_s_s((safe_div_func_int16_t_s_s(((((p_27 & ((((void*)0 == l_465) , &l_472) == (**l_458))) > (l_473 , ((void*)0 == l_465))) >= 0x84) == (**l_459)), (**l_459))), p_27)) , (***l_458)) , l_473.f0) > p_27) || l_482) , l_473.f8) >= 0x498AD122)), l_473.f7)) == l_473.f1) , p_27) < 1U) , 0), l_473.f7)) != 0U) || l_473.f2) || 3U) > (**l_459));
    }
    else
    { /* block id: 174 */
        int32_t *l_483 = &l_461;
        struct S1 l_502 = {22,-265,39,-0,0x3FE9FF89,1,375,0,14,395};
        struct S0 *l_513 = &l_441;
        (*l_459) = l_483;
        for (l_454 = (-21); (l_454 == (-14)); l_454 = safe_add_func_uint16_t_u_u(l_454, 3))
        { /* block id: 178 */
            uint8_t l_491 = 0U;
            (***l_458) = ((safe_div_func_uint16_t_u_u((*l_483), ((safe_rshift_func_uint8_t_u_u((safe_unary_minus_func_uint16_t_u(((((l_491 | ((safe_mod_func_uint16_t_u_u((safe_div_func_uint8_t_u_u((((((p_27 , (*l_483)) != (p_27 < l_491)) && 4294967293U) , (func_40(((safe_lshift_func_int8_t_s_u(p_27, 3)) | (safe_lshift_func_uint8_t_u_u((safe_mod_func_uint8_t_u_u((***l_458), p_27)), 6))), (*l_483), p_27, p_27, l_502) , p_27)) , 4U), 255U)), p_27)) , (***l_458))) ^ (***l_458)) > p_27) && p_27))), 2)) , 65528U))) || (**l_459));
        }
        (**l_459) = 0xD6C550F1;
        (*l_460) = (safe_mod_func_int8_t_s_s((**l_459), ((*l_483) ^ (246U | ((p_27 != (((safe_rshift_func_int16_t_s_u(((((*l_483) ^ (safe_rshift_func_uint16_t_u_u((safe_div_func_uint32_t_u_u(((***l_458) >= ((safe_rshift_func_uint8_t_u_s(((void*)0 == l_513), (***l_458))) >= p_27)), p_27)), 14))) , p_27) || 5), 13)) && (*l_460)) , 0x8C)) , p_27)))));
    }
    if (((p_27 > ((safe_div_func_uint8_t_u_u(((((l_516 , (*l_458)) != (*l_458)) < (((((-1) < (***l_458)) | ((((**l_459) && (safe_add_func_uint16_t_u_u(((!(((((((((((((safe_sub_func_int8_t_s_s((((*l_445) , &l_459) != &l_459), (*l_460))) , (*l_460)) < (***l_458)) , (void*)0) != (void*)0) & 4294967295U) > (*l_460)) != (*l_460)) && (***l_458)) > (*l_460)) <= (***l_458)) , (**l_458)) == (*l_459))) , p_27), 0x15F0))) , &l_459) == (void*)0)) != p_27) <= 0x084EBBEE)) >= (*l_460)), (**l_459))) | 0xA3)) , (***l_458)))
    { /* block id: 184 */
        struct S0 l_524 = {1066,0};
        uint8_t l_525 = 0U;
        for (l_444.f4 = 0; (l_444.f4 == 31); ++l_444.f4)
        { /* block id: 187 */
            if (p_27)
                break;
            return p_27;
        }
        (*l_459) = (l_524 , (p_27 , (**l_458)));
        return l_525;
    }
    else
    { /* block id: 193 */
        int8_t l_541 = 0x6C;
        struct S1 *l_548 = &l_444;
        for (l_516 = 2; (l_516 <= 45); l_516 = safe_add_func_int8_t_s_s(l_516, 1))
        { /* block id: 196 */
            int32_t l_543 = 0xED09C11E;
            int32_t *l_549 = &l_461;
            uint32_t l_557 = 4294967287U;
            for (l_454 = 0; (l_454 > (-27)); --l_454)
            { /* block id: 199 */
                int32_t l_533 = (-1);
                struct S0 l_534 = {5179,3};
                for (p_27 = (-12); (p_27 >= 13); p_27 = safe_add_func_uint8_t_u_u(p_27, 4))
                { /* block id: 202 */
                    struct S1 l_532 = {23,169,39,-0,1U,21,2425,-0,0,132};
                    (*l_445) = l_532;
                    if (l_533)
                        break;
                }
                if (p_27)
                    continue;
                (*l_443) = l_534;
                (**l_442) = (*l_443);
            }
            (**l_458) = (((((safe_lshift_func_uint8_t_u_u((((p_27 >= ((*l_460) < (safe_mod_func_uint16_t_u_u((safe_div_func_int8_t_s_s((l_541 == ((!p_27) != (l_543 > (safe_sub_func_uint32_t_u_u((((((safe_div_func_uint8_t_u_u(l_543, 0x46)) == l_541) < ((l_548 == (void*)0) != p_27)) >= p_27) <= (*l_460)), 1))))), p_27)), 9)))) , p_27) && p_27), 0)) , 0x60) < l_541) , (*l_445)) , l_549);
            (*l_549) = (safe_add_func_int16_t_s_s((((*l_549) != ((((l_541 && (*l_549)) | (safe_div_func_int32_t_s_s(((*l_460) , ((-1) >= (safe_unary_minus_func_int8_t_s((safe_div_func_uint16_t_u_u((p_27 , p_27), l_557)))))), ((0xD79FBAA5 == (*l_549)) , p_27)))) > (*l_549)) , (*l_549))) , 0), (**l_459)));
        }
    }
    return p_27;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_35(uint32_t  p_36, uint32_t  p_37)
{ /* block id: 7 */
    int32_t l_50 = (-2);
    struct S0 l_70 = {252,0};
    struct S1 l_246 = {2,-298,34,0,0xEBE3635E,31,3499,6,14,294};
    struct S0 *l_437 = &l_70;
    struct S0 **l_438 = &l_437;
    int32_t *l_439 = (void*)0;
    int8_t l_440 = 0;
    (*l_437) = func_40((safe_rshift_func_uint16_t_u_s(((safe_lshift_func_uint16_t_u_u(l_50, 1)) || 5), ((func_51((!l_50), (safe_rshift_func_uint8_t_u_u(((0xB6BD && (0x5971 < (((safe_sub_func_int8_t_s_s((safe_rshift_func_uint16_t_u_u((((safe_unary_minus_func_uint32_t_u(0xDDA102F3)) <= func_64(p_36, (((safe_add_func_int16_t_s_s((l_50 < 0xC99C), p_37)) ^ p_37) && 0x95), l_70)) < p_37), 9)), l_50)) & l_70.f1) >= l_70.f1))) != p_36), 3)), p_37, p_36) , 1U) <= 0x3E40))), l_70.f0, l_50, p_36, l_246);
    (*l_438) = &l_70;
    l_439 = l_439;
    return l_440;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_40(int32_t  p_41, uint16_t  p_42, int8_t  p_43, int32_t  p_44, struct S1  p_45)
{ /* block id: 88 */
    uint8_t l_262 = 0x89;
    struct S0 l_278 = {8266,0};
    struct S0 *l_277 = &l_278;
    uint32_t l_290 = 4294967295U;
    int32_t l_391 = 0;
    int32_t *l_390 = &l_391;
    int32_t **l_389 = &l_390;
    int32_t ***l_388 = &l_389;
    int32_t l_430 = 0x156E42DA;
    int32_t l_434 = (-1);
    struct S0 **l_435 = &l_277;
    struct S0 l_436 = {292,0};
lbl_400:
    for (p_42 = 28; (p_42 == 23); p_42 = safe_sub_func_uint32_t_u_u(p_42, 5))
    { /* block id: 91 */
        struct S0 *l_249 = (void*)0;
        struct S0 **l_250 = &l_249;
        int32_t l_280 = 0xC5C242C3;
        int32_t *l_283 = &l_280;
        int32_t **l_282 = &l_283;
        int32_t ***l_281 = &l_282;
        struct S1 l_317 = {41,274,41,-0,0x3395F33A,38,3101,9,10,151};
        uint32_t l_368 = 0xD2F3632F;
        (*l_250) = l_249;
        if ((safe_unary_minus_func_uint16_t_u(0xB1EE)))
        { /* block id: 93 */
            int8_t l_261 = 0x4D;
            struct S0 l_276 = {876,2};
            struct S0 *l_275 = &l_276;
            int32_t l_279 = 0xD520F136;
            if (((-1) >= (safe_div_func_uint16_t_u_u((((safe_add_func_int8_t_s_s(((~p_45.f4) < (safe_lshift_func_int8_t_s_s((safe_sub_func_int8_t_s_s(((l_261 <= (((l_262 ^ (safe_div_func_uint32_t_u_u((((((safe_mod_func_uint32_t_u_u((safe_sub_func_int8_t_s_s(0x24, p_45.f5)), (safe_lshift_func_uint8_t_u_s(0x73, ((safe_add_func_uint16_t_u_u((safe_add_func_uint16_t_u_u((p_41 >= (l_275 == l_277)), p_41)), 0x2AEE)) , p_45.f0))))) || p_45.f1) | l_279) && p_45.f0) , l_280), l_262))) , (-1)) && p_42)) > p_45.f1), 1)), l_280))), 3)) , l_281) == &l_282), p_45.f6))))
            { /* block id: 94 */
                int32_t **l_305 = (void*)0;
                int32_t l_306 = 8;
                struct S0 ***l_307 = &l_250;
                (*l_283) = ((safe_rshift_func_uint16_t_u_s(((safe_rshift_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u(l_290, p_45.f8)), (**l_282))) & ((safe_div_func_uint16_t_u_u(((func_51((((safe_add_func_uint32_t_u_u(0x1BD345BA, (((safe_rshift_func_int8_t_s_s((safe_lshift_func_int16_t_s_u(((safe_sub_func_uint16_t_u_u(p_45.f7, (safe_sub_func_int32_t_s_s((safe_rshift_func_uint8_t_u_u((l_305 == (void*)0), ((void*)0 != (*l_250)))), 0x311B5572)))) & l_276.f0), l_278.f1)), (**l_282))) | l_306) <= l_278.f0))) < p_42) < l_276.f0), p_45.f0, p_45.f5, (*l_283)) , p_45.f2) < l_276.f1), p_44)) < p_45.f4)), 14)) & l_278.f1);
                (*l_283) = ((((((void*)0 != &l_282) || p_45.f0) , (((l_307 != &l_250) > p_45.f5) , (safe_rshift_func_int8_t_s_u(((((safe_sub_func_uint16_t_u_u((~(4 == (safe_rshift_func_int8_t_s_s(9, ((((safe_lshift_func_uint16_t_u_s(((***l_281) == p_45.f6), p_44)) & 0) , 0x69) | p_43))))), l_279)) >= (***l_281)) <= 0x563A) | p_45.f4), 2)))) ^ (***l_281)) & 0x7CD2);
            }
            else
            { /* block id: 97 */
                struct S1 *l_318 = &l_317;
                int32_t *l_321 = (void*)0;
                struct S0 **l_348 = &l_277;
                int32_t l_354 = 0x811E5ADB;
                (*l_318) = l_317;
                for (l_279 = 28; (l_279 < 20); --l_279)
                { /* block id: 101 */
                    int32_t l_342 = 0x7983931C;
                    uint8_t l_344 = 255U;
                    l_321 = &p_44;
                    /* statement id: 102 */
                    assert (l_321 == &p_44);
                    (**l_281) = &l_279;
                    /* statement id: 103 */
                    assert (l_283 == &l_279);
                    for (l_280 = (-14); (l_280 <= (-20)); l_280 = safe_sub_func_uint8_t_u_u(l_280, 1))
                    { /* block id: 106 */
                        struct S0 l_343 = {11362,1};
                        (*l_321) = (safe_mod_func_uint16_t_u_u(((safe_lshift_func_int8_t_s_s((safe_lshift_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u((safe_lshift_func_uint8_t_u_u(((-1) || ((void*)0 != &l_249)), 1)), ((safe_rshift_func_int8_t_s_u((((~((void*)0 == &p_45)) & (((p_44 >= p_45.f4) >= (((((((~(safe_lshift_func_int8_t_s_u((safe_sub_func_int8_t_s_s((*l_321), (((1U == l_261) == l_342) ^ 0xF4CB1A89))), 6))) != l_278.f1) , l_343) , 0x65) < 0xBE) > 1U) ^ p_45.f4)) > 0x5570)) >= l_342), 0)) > l_344))) ^ p_45.f0), l_344)), (*l_321))) || p_44), p_45.f5));
                        (*l_282) = &p_41;
                        /* statement id: 108 */
                        assert (l_283 == &p_41);
                        (*l_282) = (void*)0;
                        /* statement id: 109 */
                        assert (l_283 == 0);
                    }
                    /* facts after for loop */
                    assert (l_283 == 0 || l_283 == &l_279);
                }
                /* facts after for loop */
                assert (l_283 == 0 || l_283 == &l_279 || l_283 == &l_280);
                assert (l_321 == &p_44 || l_321 == 0);
                for (p_43 = (-20); (p_43 == (-10)); p_43 = safe_add_func_int16_t_s_s(p_43, 4))
                { /* block id: 114 */
                    struct S1 l_347 = {16,270,11,-0,0xC74FFF7F,11,1131,7,14,479};
                    struct S0 **l_349 = &l_249;
                    (*l_282) = &l_279;
                    /* statement id: 115 */
                    assert (l_283 == &l_279);
                    l_347 = l_317;
                    p_45.f1 = (l_347.f1 && (l_348 != l_349));
                    (**l_282) = (safe_sub_func_int8_t_s_s((p_45.f1 == (safe_mod_func_uint32_t_u_u((l_354 | (&p_41 == ((*l_277) , (void*)0))), ((safe_add_func_uint32_t_u_u((safe_div_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u(((((safe_mod_func_int16_t_s_s((safe_add_func_int16_t_s_s(((**l_348) , (((l_276.f1 , (~(0x0B8C9EB1 || (safe_mod_func_uint32_t_u_u(l_279, (*l_283)))))) ^ 0x6E039D82) <= p_45.f9)), p_45.f2)), p_45.f8)) || (*l_283)) == l_347.f9) == (-9)), 5)), 0x5FADD72D)), p_45.f9)) && p_45.f6)))), l_368));
                }
            }
            /* facts after branching */
            assert (l_283 == 0 || l_283 == &l_279 || l_283 == &l_280);
            p_45.f3 = p_45.f1;
        }
        else
        { /* block id: 122 */
            struct S0 ***l_383 = &l_250;
            int32_t *l_397 = &l_391;
            for (p_43 = 0; (p_43 == (-30)); p_43 = safe_sub_func_uint8_t_u_u(p_43, 3))
            { /* block id: 125 */
                int32_t ***l_386 = (void*)0;
                int32_t l_387 = (-1);
                (**l_282) = (safe_rshift_func_uint8_t_u_u((safe_lshift_func_int16_t_s_u(l_262, 9)), 3));
                if ((((1U || (!(safe_lshift_func_uint8_t_u_s(((*l_283) , ((void*)0 != &p_44)), (0 != (***l_281)))))) && 0) != ((p_42 & (safe_rshift_func_int8_t_s_s(p_43, 7))) | 0xD8280D7D)))
                { /* block id: 127 */
                    struct S0 ***l_382 = &l_250;
                    (**l_281) = (func_51(((p_45.f5 ^ (l_382 == l_383)) <= ((void*)0 == (*l_281))), (safe_add_func_int16_t_s_s((p_45.f6 >= (((((*l_277) , l_386) != ((0U & l_387) , l_388)) > (***l_388)) ^ (**l_389))), p_45.f2)), p_44, p_45.f4) , &p_41);
                    /* statement id: 128 */
                    assert (l_283 == &p_41);
                }
                else
                { /* block id: 129 */
                    struct S1 l_392 = {4,-201,8,0,7U,9,2596,-3,12,511};
                    struct S1 *l_393 = (void*)0;
                    struct S1 *l_394 = (void*)0;
                    struct S1 *l_395 = (void*)0;
                    struct S1 *l_396 = &l_392;
                    (*l_396) = l_392;
                }
            }
            /* facts after for loop */
            assert (l_283 == &l_280 || l_283 == &p_41);
            (*l_389) = l_397;
            l_397 = &p_41;
            /* statement id: 134 */
            assert (l_397 == &p_41);
        }
        /* facts after branching */
        //assert (l_283 == &l_280 || l_283 == &p_41 || l_283 == 0 || l_283 == dangling);
        (**l_388) = (*l_389);
    }
    for (l_391 = 22; (l_391 != (-18)); l_391 = safe_sub_func_uint16_t_u_u(l_391, 2))
    { /* block id: 140 */
        uint16_t l_421 = 0U;
        struct S0 **l_432 = (void*)0;
        int32_t **l_433 = &l_390;
        if (p_45.f5)
            goto lbl_400;
        for (p_44 = 0; (p_44 <= 14); p_44 = safe_add_func_uint16_t_u_u(p_44, 2))
        { /* block id: 144 */
            uint32_t l_403 = 0U;
            struct S0 **l_420 = &l_277;
            int32_t *l_427 = (void*)0;
        }
        for (l_290 = 0; (l_290 > 53); ++l_290)
        { /* block id: 157 */
            int32_t l_431 = 0x24988E6E;
            l_431 = l_430;
        }
    }
    (*l_435) = &l_278;
    return l_436;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_51(int32_t  p_52, uint32_t  p_53, uint16_t  p_54, uint32_t  p_55)
{ /* block id: 13 */
    int32_t l_77 = 1;
    int32_t *l_76 = &l_77;
    int16_t l_102 = 0x176A;
    int32_t l_103 = 0x618A8B4E;
    int32_t l_105 = 0x381BC374;
    struct S1 l_109 = {33,-248,47,-0,0x0B92564D,41,1075,10,11,688};
    struct S1 *l_108 = &l_109;
    struct S0 l_143 = {6726,0};
    struct S0 *l_239 = &l_143;
    int32_t *l_244 = &l_77;
    struct S0 l_245 = {2087,3};
    return l_245;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_64(uint32_t  p_65, uint32_t  p_66, struct S0  p_67)
{ /* block id: 8 */
    int32_t l_72 = 0xEEAEFF69;
    int32_t *l_71 = &l_72;
    int32_t **l_73 = &l_71;
    struct S1 l_74 = {15,93,37,0,1U,0,558,-10,9,349};
    struct S1 *l_75 = &l_74;
    l_71 = l_71;
    (*l_73) = &l_72;
    (*l_75) = l_74;
    return p_65;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 153
   depth: 1, occurrence: 40
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 11
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 85
breakdown:
   indirect level: 0, occurrence: 40
   indirect level: 1, occurrence: 13
   indirect level: 2, occurrence: 15
   indirect level: 3, occurrence: 9
   indirect level: 4, occurrence: 8
XXX full-bitfields structs in the program: 16
breakdown:
   indirect level: 0, occurrence: 16
XXX times a bitfields struct's address is taken: 36
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 78
XXX times a single bitfield on LHS: 5
XXX times a single bitfield on RHS: 162

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 171
   depth: 2, occurrence: 31
   depth: 3, occurrence: 3
   depth: 11, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 4
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 27, occurrence: 2
   depth: 28, occurrence: 2
   depth: 29, occurrence: 2
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 156

XXX times a variable address is taken: 177
XXX times a pointer is dereferenced on RHS: 150
breakdown:
   depth: 1, occurrence: 92
   depth: 2, occurrence: 25
   depth: 3, occurrence: 31
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 106
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 18
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 410

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 196
   level: 2, occurrence: 76
   level: 3, occurrence: 56
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 39
XXX number of pointers point to structs: 32
XXX percent of pointers has null in alias set: 25
XXX average alias set size: 1.15

XXX times a non-volatile is read: 1047
XXX times a non-volatile is write: 293
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 146
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 27
   depth: 2, occurrence: 29
   depth: 3, occurrence: 18
   depth: 4, occurrence: 20
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 20.7
XXX percentage an existing variable is used: 79.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

