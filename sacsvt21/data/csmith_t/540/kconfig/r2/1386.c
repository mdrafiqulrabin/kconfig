/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3608698421
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
   unsigned f1 : 14;
   uint32_t  f2;
   signed f3 : 2;
};

union U1 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_29(void);
static uint16_t  func_45(uint32_t  p_46, uint32_t  p_47, int32_t  p_48, uint32_t  p_49, int16_t  p_50);
static uint32_t  func_51(struct S0  p_52, int8_t  p_53, uint32_t  p_54);
static struct S0  func_55(uint32_t  p_56);
static int16_t  func_63(int32_t  p_64);
inline static int16_t  func_68(uint16_t  p_69, int32_t  p_70);
inline static uint16_t  func_71(int8_t  p_72);
static int8_t  func_73(struct S0  p_74, uint32_t  p_75, int32_t  p_76, uint16_t  p_77);
inline static uint16_t  func_85(int8_t  p_86, int32_t  p_87, int32_t  p_88, uint32_t  p_89);
inline static uint16_t  func_94(uint32_t  p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_32 = 0xD9A2B82C;
    union U1 l_37 = {9U};
    int32_t l_40 = 0x487223B1;
    struct S0 l_307 = {0xA59A,18,0x7C537019,0};
    int32_t l_317 = (-1);
    int32_t l_355 = 2;
    uint32_t l_397 = 0xAFC3802B;
    uint16_t l_444 = 0x98D0;
    int8_t l_533 = (-1);
    struct S0 l_584 = {8U,36,1U,-1};
    int32_t l_725 = (-1);
    uint32_t l_741 = 1U;
    if ((((int16_t)(((-5) <= ((l_32 < ((uint32_t)((uint32_t)(l_37 , ((int16_t)l_40 * (int16_t)((l_355 = ((uint16_t)((((((uint16_t)0x1AC7 * (uint16_t)0x2367) >= (func_45((l_317 = (((func_51((l_307 = func_55(l_40)), ((int16_t)(-1) << (int16_t)9), l_37.f0) , l_307.f0) < l_37.f0) ^ l_40)), l_40, l_37.f0, l_40, l_32) , l_32)) <= l_32) | l_37.f0) != l_40) + (uint16_t)l_37.f0)) || l_37.f0))) % (uint32_t)l_37.f0) + (uint32_t)l_32)) , 0x8F051323)) == l_40) >> (int16_t)11) & l_40))
    { /* block id: 204 */
        int32_t l_364 = 0;
        int32_t l_369 = 0x23D9EDB6;
        struct S0 l_398 = {0U,6,0x16A43F5A,0};
        union U1 l_434 = {4294967295U};
        int32_t l_437 = 0xFF35FAD9;
        int32_t l_467 = 5;
        uint32_t l_490 = 0x52934889;
        for (l_317 = 16; (l_317 == 0); l_317 -= 3)
        { /* block id: 207 */
            union U1 l_367 = {4294967289U};
            int32_t l_368 = (-7);
            struct S0 l_377 = {0x739E,13,4U,-1};
            uint16_t l_402 = 0xA19E;
            int32_t l_403 = (-2);
            uint16_t l_413 = 6U;
            int8_t l_425 = 0;
            int32_t l_426 = 0x5CB5B313;
            uint32_t l_512 = 0x3ED8251A;
            uint16_t l_520 = 65530U;
            if (((l_307.f3 != (((uint32_t)0xA1230C36 + (uint32_t)((l_369 = ((uint16_t)(l_307.f0 , __builtin_clzl((0U == ((l_364 = ((((int16_t)((l_364 || ((int16_t)7 << (int16_t)((l_367 , l_364) || (l_368 ^= (l_364 > 1U))))) >= l_367.f0) - (int16_t)l_367.f0) < l_364) && l_307.f0)) & l_369)))) >> (uint16_t)1)) & l_307.f1)) && l_307.f3)) ^ l_307.f0))
            { /* block id: 211 */
                int8_t l_386 = 0x6D;
                struct S0 l_391 = {0x4887,74,4294967295U,1};
                int32_t l_401 = 0x20136B55;
                if ((l_317 & l_355))
                { /* block id: 212 */
                    int32_t l_387 = (-10);
                    uint16_t l_388 = 0x0258;
                    if ((((uint16_t)l_364 + (uint16_t)(((((l_317 , (-(uint16_t)((int16_t)((int16_t)func_73(l_377, ((uint16_t)((uint32_t)((int16_t)0 - (int16_t)(((int16_t)(l_307.f3 , __builtin_parityll(l_386)) * (int16_t)(l_387 == l_307.f1)) == l_368)) % (uint32_t)0xB0CFE398) << (uint16_t)l_369), l_364, l_388) + (int16_t)0xFC07) >> (int16_t)l_387))) > 4294967290U) | l_388) && l_386) & l_368)) != l_377.f1))
                    { /* block id: 213 */
                        int8_t l_390 = 0x3D;
                        l_390 = (!3U);
                        return l_369;
                    }
                    else
                    { /* block id: 216 */
                        uint32_t l_392 = 0xC8A921B7;
                        if (l_307.f3)
                            break;
                        l_307 = l_391;
                        l_392 &= (l_37.f0 | l_387);
                        return l_392;
                    }
                }
                else
                { /* block id: 222 */
                    int16_t l_396 = 1;
                    for (l_391.f2 = 0; (l_391.f2 == 9); l_391.f2 += 5)
                    { /* block id: 225 */
                        int8_t l_395 = 0xB7;
                        l_377.f3 = func_71(l_377.f2);
                        if (l_395)
                            continue;
                        l_396 = l_369;
                    }
                }
                l_398 = func_55((l_355 < l_397));
                l_403 = ((int16_t)0x9119 * (int16_t)(((l_391.f3 = 5U) >= (((l_355 = ((((l_40 , ((__builtin_bswap64((l_401 |= l_386)) ^ (l_368 = l_377.f1)) & (l_377.f3 = 9))) | 0x70C5) > l_369) == 0x9DD9)) && l_386) < l_402)) , l_377.f2));
                if ((-(int32_t)(((l_413 = ((uint16_t)(((int16_t)0x5889 << (int16_t)(l_398.f3 && (__builtin_ffs(l_355) >= func_73(l_391, l_391.f3, l_377.f1, ((uint16_t)((uint16_t)l_398.f3 << (uint16_t)l_369) * (uint16_t)l_391.f3))))) != 0xBA03) << (uint16_t)3)) <= l_398.f1) <= l_367.f0)))
                { /* block id: 239 */
                    uint32_t l_420 = 0xD2D1F035;
                    int32_t l_423 = 0xE1B6C5D4;
                    l_423 = (l_307.f0 ^ ((int32_t)((int16_t)0x6A5D - (int16_t)((uint32_t)0x216A5DE5 - (uint32_t)(l_391.f0 && (l_369 , (l_420 , ((int16_t)l_391.f3 << (int16_t)l_420)))))) + (int32_t)(-9)));
                }
                else
                { /* block id: 241 */
                    uint32_t l_424 = 4294967295U;
                    l_425 = l_424;
                    if (l_426)
                        continue;
                }
            }
            else
            { /* block id: 245 */
                int32_t l_427 = (-7);
                int32_t l_428 = (-1);
                if (l_377.f0)
                    break;
                l_403 = (-1);
                l_428 |= l_427;
                l_398 = l_307;
            }
            if (l_398.f0)
            { /* block id: 251 */
                int32_t l_431 = (-1);
                union U1 l_443 = {0x66F60658};
                int32_t l_445 = 1;
                int32_t l_446 = 0x4D7C8FA3;
                l_364 = ((l_355 = (l_369 = ((((int16_t)(l_431 == l_431) + (int16_t)(l_307.f3 &= ((int16_t)(l_434 , l_317) >> (int16_t)((4294967293U ^ l_431) | l_355)))) == l_307.f2) , ((int32_t)(l_431 >= l_398.f2) + (int32_t)l_398.f3)))) ^ l_437);
                l_364 ^= ((uint32_t)(l_446 = (-(int16_t)((((uint32_t)((l_445 &= ((l_355 ^ (func_55(l_398.f2) , (l_307.f3 = ((((l_367 = l_367) , (((((l_443 , (((l_426 = l_437) <= (__builtin_clzll(l_444) <= (l_443.f0 , 2))) && l_307.f2)) , 4U) <= 0x0C0B) == l_413) <= (-1))) , l_307.f2) , (-9))))) > 8U)) | l_425) % (uint32_t)l_403) <= l_307.f0) <= 0U))) % (uint32_t)l_431);
                l_398 = l_377;
            }
            else
            { /* block id: 263 */
                int32_t l_464 = 0xCD7813B1;
                int32_t l_465 = 0x8EFC058D;
                for (l_367.f0 = (-28); (l_367.f0 > 43); l_367.f0 += 1)
                { /* block id: 266 */
                    int32_t l_469 = 0x41AE8198;
                    int32_t l_500 = (-1);
                    int32_t l_527 = 0xC34F0112;
                    uint32_t l_529 = 0xEEDB4034;
                    for (l_364 = 0; (l_364 > (-19)); l_364 -= 1)
                    { /* block id: 269 */
                        uint32_t l_463 = 0x54403C0C;
                        struct S0 l_468 = {0xA97B,25,4294967289U,1};
                        union U1 l_470 = {0x4DA77586};
                        int32_t l_471 = 0x83A40949;
                        uint16_t l_472 = 1U;
                        l_468 = func_55(((uint32_t)(func_73(l_377, ((!((int16_t)(-6) - (int16_t)__builtin_ctzl(l_32))) ^ ((uint16_t)((-(uint32_t)(func_85((((int32_t)l_403 - (int32_t)(l_465 = (l_464 |= ((uint16_t)l_463 - (uint16_t)9U)))) ^ (!(l_463 ^ l_398.f2))), l_467, l_402, l_463) == l_355)) >= l_369) % (uint16_t)l_307.f1)), l_402, l_368) || 0xF0EE) % (uint32_t)l_368));
                        l_465 = ((((((l_468.f0 , ((l_307.f3 = ((((l_444 , (l_469 & func_45((l_425 <= (l_377.f3 = l_468.f0)), (3U & (l_470 , func_68(l_437, l_465))), l_367.f0, l_471, l_472))) >= l_469) <= l_469) | l_468.f0)) && 1)) > 0x9278F959) >= l_364) || l_468.f3) , l_465) < 0x33AD);
                        l_471 |= (0x47B9 > ((((int16_t)__builtin_bswap64((l_369 = (((~((int16_t)l_398.f2 % (int16_t)__builtin_ctz((l_426 | (l_500 = (((uint32_t)((uint16_t)((((uint16_t)(l_307.f3 = ((int16_t)l_464 >> (int16_t)(((int32_t)(l_398.f1 && (l_469 < (l_465 , ((l_368 = ((l_398.f3 &= (func_45(((uint16_t)l_490 % (uint16_t)((uint32_t)((uint16_t)(((int16_t)(~(0x3FCE031F | 0x95BD41BE)) % (int16_t)l_465) > 0) * (uint16_t)l_468.f1) + (uint32_t)l_398.f0)), l_437, l_398.f2, l_469, l_377.f1) || l_368)) < l_469)) ^ (-4))))) % (int32_t)l_369) , 1U))) - (uint16_t)l_472) , l_434) , l_470.f0) >> (uint16_t)l_490) + (uint32_t)(-8)) & l_437)))))) & 0xB42C3CD6) == l_468.f0))) << (int16_t)3) >= l_377.f1) != l_397));
                        l_500 = (l_355 = ((uint16_t)((__builtin_clz(l_434.f0) ^ (l_490 != (l_377.f2 >= l_437))) , (((uint16_t)l_468.f3 * (uint16_t)l_468.f3) & ((uint16_t)l_437 << (uint16_t)(l_398.f2 , 0x8E2D)))) >> (uint16_t)1));
                    }
                    if (l_464)
                    { /* block id: 285 */
                        int16_t l_513 = 4;
                        l_369 = (-(uint16_t)l_307.f2);
                        if (l_377.f1)
                            continue;
                        l_364 = 0;
                        l_398 = func_55(((uint16_t)(((uint16_t)l_398.f0 << (uint16_t)8) != l_398.f3) * (uint16_t)(l_512 <= ((l_513 && __builtin_popcount(l_513)) , ((uint16_t)l_377.f0 * (uint16_t)(l_464 || (((l_307.f3 &= (!l_513)) != l_37.f0) || l_513)))))));
                    }
                    else
                    { /* block id: 291 */
                        uint32_t l_517 = 4294967288U;
                        struct S0 l_530 = {8U,18,1U,-0};
                        l_355 ^= ((((l_426 = l_517) | ((int16_t)((l_364 = l_520) ^ l_464) >> (int16_t)((l_307 , func_51((((int32_t)(l_529 = (l_469 , ((int16_t)((uint16_t)__builtin_ia32_crc32qi(l_307.f3, ((l_527 ^ (-(int32_t)l_490)) , (l_465 || l_398.f3))) % (uint16_t)l_517) % (int16_t)l_517))) + (int32_t)l_517) , l_530), l_464, l_530.f2)) > 1U))) & l_37.f0) != l_469);
                    }
                }
            }
        }
        l_467 ^= (((uint16_t)(l_364 ^ (l_307.f0 , __builtin_popcountll(l_533))) << (uint16_t)((uint16_t)((l_307 , ((int16_t)l_307.f2 << (int16_t)15)) | ((uint16_t)(((__builtin_parityl(((uint32_t)(((int16_t)(l_369 > 0x62D1C109) >> (int16_t)l_398.f0) <= l_37.f0) + (uint32_t)(-9))) >= l_444) && 0x6A1447BB) , 0xD530) >> (uint16_t)9)) >> (uint16_t)8)) || l_398.f0);
    }
    else
    { /* block id: 301 */
        int32_t l_544 = (-1);
        l_544 ^= l_397;
    }
    if ((l_307 , ((((uint16_t)(!l_307.f1) - (uint16_t)(-1)) > (l_317 &= (l_307.f1 ^ (l_397 , l_355)))) == ((0U ^ l_307.f3) , ((uint16_t)(func_68(l_37.f0, l_397) || l_307.f2) << (uint16_t)l_444)))))
    { /* block id: 305 */
        int32_t l_550 = (-1);
        struct S0 l_555 = {0xAD05,97,1U,0};
        l_550 = l_550;
        for (l_32 = 0; (l_32 == 17); l_32 += 1)
        { /* block id: 309 */
            int8_t l_553 = 0;
            uint32_t l_554 = 0xE6A3EB75;
            l_554 ^= l_553;
        }
        l_555 = l_555;
    }
    else
    { /* block id: 313 */
        int32_t l_556 = 0;
        l_556 = l_556;
    }
    for (l_307.f0 = (-8); (l_307.f0 == 34); l_307.f0 += 1)
    { /* block id: 318 */
        int8_t l_572 = 1;
        int8_t l_582 = 0;
        struct S0 l_585 = {2U,54,0xA0B29B6B,1};
        int8_t l_625 = 3;
        union U1 l_695 = {0U};
        int32_t l_707 = 0;
        uint16_t l_708 = 1U;
        int32_t l_738 = 0xEA6D4330;
        int32_t l_773 = 0xF8723C8C;
        int8_t l_774 = 0x5F;
        for (l_397 = (-17); (l_397 >= 48); l_397 += 9)
        { /* block id: 321 */
            uint32_t l_562 = 4294967288U;
            uint16_t l_600 = 0x0173;
            struct S0 l_635 = {0xE2C9,63,0xF0EFAF62,1};
            int16_t l_676 = 0xC2B5;
            int32_t l_677 = 0xBFC7337A;
            uint16_t l_709 = 0xAFB3;
            if (((!0xDD1C) <= (l_355 |= func_94(l_562))))
            { /* block id: 323 */
                int16_t l_567 = 0xD2B2;
                uint32_t l_575 = 0x324FC591;
                int32_t l_595 = (-3);
                uint16_t l_601 = 0x3D8A;
                struct S0 l_608 = {0x8E36,3,4294967289U,1};
                for (l_307.f2 = 19; (l_307.f2 >= 39); l_307.f2 += 1)
                { /* block id: 326 */
                    for (l_562 = (-4); (l_562 >= 25); l_562 += 3)
                    { /* block id: 329 */
                        return l_567;
                    }
                }
                for (l_444 = 0; (l_444 <= 12); l_444 += 7)
                { /* block id: 335 */
                    uint32_t l_574 = 0x808EF368;
                    int32_t l_583 = (-1);
                    int8_t l_626 = 1;
                    l_307.f3 = (((l_444 >= (l_307.f3 > (((uint16_t)((l_572 = l_562) ^ ((l_575 = (~l_574)) == (func_63((((((int32_t)(__builtin_popcountll(((((((__builtin_parityl((l_574 & ((int16_t)(((uint16_t)l_567 - (uint16_t)0x9FEA) > l_574) << (int16_t)l_582))) || l_562) <= l_574) , l_317) , 0x615A6BB1) < 0x70A7C3BA) >= l_582)) & l_567) - (int32_t)l_574) < l_582) || 0xA656) , l_583)) | 0))) >> (uint16_t)13) && 1U))) && l_562) , 1);
                    l_585 = l_584;
                    for (l_572 = 24; (l_572 >= (-8)); l_572 -= 1)
                    { /* block id: 342 */
                        uint32_t l_588 = 0x69D28AE8;
                        int32_t l_624 = 0;
                        int32_t l_627 = 0x703E248D;
                        l_583 = l_562;
                        l_588 = 0x16C9BECA;
                        l_585.f3 = ((l_40 && ((uint32_t)((((l_37 , ((uint16_t)((((uint16_t)(__builtin_popcountl((l_595 = __builtin_popcount(l_585.f3))) || ((((((int16_t)(l_562 > l_595) << (int16_t)7) > ((uint16_t)((l_588 | (l_595 < 0xC389A51E)) >= 0xA63A) % (uint16_t)l_600)) , l_584) , (-1)) < l_601)) << (uint16_t)12) & l_574) != l_40) >> (uint16_t)l_575)) & l_574) & l_600) > l_562) - (uint32_t)l_562)) < 0x51BF);
                        l_627 ^= ((((uint32_t)(~((-(uint16_t)l_584.f1) >= (0xE633 >= (1 | (((int32_t)(l_307.f3 = (((l_608 = func_55((l_567 == l_588))) , (((uint32_t)(((int16_t)l_307.f2 << (int16_t)13) && (l_624 ^= ((uint16_t)((int32_t)((-(uint16_t)((uint32_t)(__builtin_parity(((int16_t)0 * (int16_t)((int16_t)(l_600 , l_562) >> (int16_t)2))) ^ l_588) - (uint32_t)l_588)) <= l_585.f0) + (int32_t)l_588) * (uint16_t)(-1)))) % (uint32_t)l_625) != l_595)) > l_626)) % (int32_t)l_626) , l_588))))) + (uint32_t)l_567) && l_32) | l_444);
                    }
                    for (l_582 = 0; (l_582 <= 2); l_582 += 7)
                    { /* block id: 354 */
                        l_585.f3 = l_562;
                        l_585.f3 = (!0x03F2);
                        if (l_626)
                            continue;
                    }
                }
            }
            else
            { /* block id: 360 */
                int32_t l_634 = 1;
                int32_t l_670 = 0x822606D6;
                struct S0 l_675 = {0x1A83,11,4294967293U,-0};
                uint16_t l_686 = 2U;
                for (l_584.f0 = (-25); (l_584.f0 > 5); l_584.f0 += 1)
                { /* block id: 363 */
                    int8_t l_636 = 9;
                    int32_t l_651 = 0x51184ACF;
                    int32_t l_663 = 0;
                    uint32_t l_664 = 0xDADFDC2C;
                    if ((!((l_562 , (func_45(l_634, l_562, l_625, l_584.f2, __builtin_clzl(l_585.f0)) | ((l_635 = func_55((l_355 = 0x4D0C40E6))) , 0x89BB32BB))) , 4294967291U)))
                    { /* block id: 366 */
                        uint32_t l_637 = 0x48613FE6;
                        int32_t l_647 = (-1);
                        int32_t l_648 = 0xFD517046;
                        l_355 ^= l_636;
                        l_637 &= (l_634 || l_584.f0);
                        l_648 |= (func_55(((uint32_t)(l_584.f1 , (func_85(l_582, l_634, (((l_585.f3 == l_637) || (((~((((uint16_t)((l_585.f3 = ((uint16_t)((int32_t)(((((((4294967295U & (func_94(__builtin_ffsl((l_647 = 0))) , l_634)) , 0xE03D9AAB) && l_636) < 4294967290U) != 1) != 3) , l_635.f0) % (int32_t)l_635.f0) % (uint16_t)0x6D89)) , l_635.f3) + (uint16_t)l_397) , l_584.f2) > l_634)) | l_637) & l_637)) , (-1)), l_635.f3) ^ l_635.f0)) + (uint32_t)l_634)) , 0x27E6332F);
                    }
                    else
                    { /* block id: 372 */
                        int32_t l_654 = 0;
                        uint32_t l_665 = 0xE68DF770;
                        l_585 = l_585;
                        l_665 = (((int16_t)(0x10CF > (l_317 = ((l_651 |= 0x209B1B18) >= (func_71(l_585.f1) <= ((l_654 == ((int32_t)(l_663 = ((((int16_t)((uint16_t)(func_55(l_582) , (l_355 |= l_585.f0)) >> (uint16_t)((uint32_t)(0x3664 <= l_307.f3) - (uint32_t)l_40)) % (int16_t)1) , 1U) < l_636)) - (int32_t)l_664)) == l_654))))) % (int16_t)0xBCC0) != 0x0440);
                        if (l_665)
                            continue;
                    }
                    l_585.f3 = (__builtin_popcount(((((((int32_t)(__builtin_popcount(l_635.f2) , 1) + (int32_t)((int16_t)1 * (int16_t)l_670)) , ((((((((int16_t)__builtin_bswap64(((uint16_t)(l_676 = (l_635.f1 , ((__builtin_parity((l_675 , l_675.f2)) & l_625) > l_585.f0))) * (uint16_t)l_675.f1)) << (int16_t)2) && l_584.f3) > l_664) & l_585.f3) < 0x32F4B994) != l_625) , 0xDB7D6BE6)) & l_677) & l_675.f3) > l_635.f3)) <= 0xD674DFE6);
                    if (l_675.f1)
                        continue;
                    return l_307.f0;
                }
                l_317 ^= ((int32_t)((int16_t)(l_585.f1 > l_670) - (int16_t)(((uint16_t)(l_562 | l_533) >> (uint16_t)9) <= (((l_677 , (0U >= (((l_635.f3 < l_635.f0) < ((((int16_t)0x009E % (int16_t)0xEE06) , l_670) != 0xAB71)) >= l_585.f0))) ^ l_686) || l_675.f1))) + (int32_t)l_635.f3);
                for (l_572 = 28; (l_572 < (-13)); l_572 -= 1)
                { /* block id: 389 */
                    return l_585.f1;
                }
            }
            for (l_40 = 0; (l_40 < (-22)); l_40 -= 1)
            { /* block id: 395 */
                union U1 l_696 = {3U};
                int32_t l_702 = 2;
                int32_t l_703 = 0xBF5186B3;
                int32_t l_706 = 0x94A236D9;
                l_703 = (((uint16_t)((int16_t)0 * (int16_t)((l_585.f3 &= l_572) <= (((((l_696 = l_695) , l_584.f2) , (-(int16_t)__builtin_ffsll(l_600))) | ((uint16_t)(((l_635.f3 = ((uint16_t)(l_707 = ((((l_702 = 4294967295U) != l_703) == ((uint32_t)(l_706 |= (((0x3CFB <= l_562) , l_703) == 0xF8EE)) - (uint32_t)l_584.f3)) > l_533)) << (uint16_t)12)) , 0x41D2) >= l_703) << (uint16_t)l_708)) != l_703))) * (uint16_t)0x50CB) | l_585.f2);
                l_706 = l_709;
            }
            l_355 = l_635.f0;
        }
        if (__builtin_popcountll(l_582))
        { /* block id: 407 */
            uint32_t l_714 = 4294967286U;
            int32_t l_723 = 0xCB495893;
            struct S0 l_724 = {1U,33,4294967295U,-1};
            l_584.f3 = (l_585.f3 = (((uint16_t)((uint16_t)((l_714 ^= l_625) != ((((int32_t)((uint16_t)((int32_t)(((l_585.f3 <= (((uint16_t)__builtin_bswap32(l_723) >> (uint16_t)l_585.f1) < (func_73(l_724, (l_723 != (l_317 |= ((l_572 > l_724.f2) , l_584.f3))), l_397, l_584.f3) & l_725))) , 0x25F9) ^ l_37.f0) % (int32_t)l_724.f2) << (uint16_t)l_584.f0) % (int32_t)0x33CF4F4B) & 0x25195F9E) , 0)) << (uint16_t)3) << (uint16_t)13) < l_708));
            for (l_582 = 0; (l_582 > (-17)); l_582 -= 1)
            { /* block id: 414 */
                l_585 = l_724;
            }
        }
        else
        { /* block id: 417 */
            union U1 l_737 = {0xBC1450C9};
            int32_t l_739 = 0xB8FAC5BA;
            int32_t l_740 = 1;
            int32_t l_754 = 0x3943FBA6;
            int32_t l_772 = 0x50B53F12;
            int32_t l_775 = (-10);
            l_740 &= ((int16_t)(l_739 &= (__builtin_ctzll(func_85(l_707, ((l_585.f1 > ((uint32_t)(l_585.f3 = 0x8CB4DF63) + (uint32_t)((uint16_t)((l_738 &= ((-(uint32_t)__builtin_ffsl(((((int16_t)(l_737 , l_737.f0) * (int16_t)l_737.f0) && (__builtin_parity(l_695.f0) != l_585.f0)) == 65530U))) | (-1))) , l_582) - (uint16_t)0x2E2D))) && 0xAAAC), l_37.f0, l_737.f0)) , 0x97A1)) % (int16_t)l_585.f0);
            l_307.f3 |= (l_707 , l_741);
            for (l_444 = 0; (l_444 != 24); l_444 += 6)
            { /* block id: 425 */
                uint16_t l_747 = 0xBA6F;
                uint32_t l_756 = 0x6882FA7A;
                int32_t l_777 = 0x77FA5084;
                for (l_739 = 0; (l_739 >= (-28)); l_739 -= 1)
                { /* block id: 428 */
                    uint32_t l_755 = 1U;
                    union U1 l_757 = {0xE732C784};
                    int32_t l_776 = (-1);
                    l_738 = (l_707 ^= func_85(l_585.f3, ((-(uint32_t)(l_747 < ((uint16_t)((int16_t)((-1) <= func_51(func_55(l_739), (((l_584.f3 &= l_307.f0) | (__builtin_ffs(((((uint16_t)(l_754 & (l_307.f3 ^= 1U)) - (uint16_t)l_747) | l_747) | 0xF4C107BD)) > l_755)) >= l_756), l_755)) * (int16_t)65534U) >> (uint16_t)9))) , l_582), l_754, l_755));
                    l_776 = (l_757 , (((uint16_t)((l_738 >= (l_585.f3 > (((-(int16_t)(((int16_t)((!l_307.f0) , ((int16_t)l_754 * (int16_t)((l_772 ^= (((int32_t)(0x2E98AF7B > ((uint32_t)l_747 % (uint32_t)((int16_t)(l_584.f1 | (l_584.f3 ^= l_740)) - (int16_t)65530U))) + (int32_t)0x7D2BB988) , l_584.f2)) & l_747))) + (int16_t)l_747) , l_397)) , 0x51B6) && l_773))) || l_774) >> (uint16_t)l_775) || l_755));
                }
                if (l_584.f0)
                    continue;
                l_777 |= (-7);
            }
            l_317 = l_772;
        }
        l_707 = 0;
    }
    return l_355;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(uint32_t  p_46, uint32_t  p_47, int32_t  p_48, uint32_t  p_49, int16_t  p_50)
{ /* block id: 186 */
    int16_t l_326 = 0xB203;
    uint32_t l_327 = 4294967295U;
    struct S0 l_328 = {1U,115,5U,1};
    int32_t l_333 = 0x1EBF98C9;
    int32_t l_335 = (-6);
    uint32_t l_340 = 0x3C999DDE;
    for (p_49 = 0; (p_49 <= 16); p_49 += 6)
    { /* block id: 189 */
        uint32_t l_329 = 0xA39E1C82;
        union U1 l_332 = {0x62F1771A};
        int32_t l_334 = (-8);
        int32_t l_336 = (-3);
        uint32_t l_347 = 0U;
        uint16_t l_352 = 0x7643;
        int32_t l_353 = 9;
        int16_t l_354 = (-1);
        l_328.f3 = ((uint32_t)(l_336 = (func_63(((l_335 |= (((int16_t)(l_327 = ((uint16_t)p_49 + (uint16_t)l_326)) + (int16_t)func_51(l_328, ((l_334 = (((1 || ((l_329 | (l_329 < ((l_333 = ((uint16_t)(l_332 , p_46) << (uint16_t)15)) < l_328.f3))) == p_46)) > l_328.f0) | p_47)) <= l_329), p_46)) , p_49)) , l_332.f0)) , p_50)) % (uint32_t)l_328.f3);
        l_354 = ((p_50 , ((~__builtin_clzll(((uint16_t)l_340 * (uint16_t)(p_50 = (((uint16_t)(__builtin_parityl((l_347 = ((int16_t)((int16_t)l_328.f1 >> (int16_t)15) >> (int16_t)9))) <= p_50) >> (uint16_t)p_50) != ((65535U && (((int16_t)__builtin_bswap32(((int16_t)__builtin_clzl((l_335 = l_328.f1)) << (int16_t)l_328.f0)) + (int16_t)l_352) ^ l_353)) > l_352)))))) != l_328.f0)) , l_352);
        l_336 = __builtin_bswap64(l_352);
    }
    return l_328.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_51(struct S0  p_52, int8_t  p_53, uint32_t  p_54)
{ /* block id: 182 */
    union U1 l_313 = {0U};
    int32_t l_316 = (-1);
    l_316 = ((~p_52.f3) && ((uint32_t)((l_313 , (((p_52.f0 <= (l_313 , l_313.f0)) == (l_313 , (((int16_t)l_313.f0 << (int16_t)0) <= ((l_313 , (func_85((((func_71(l_313.f0) & l_313.f0) ^ 0xA30916D7) <= l_313.f0), l_313.f0, p_52.f2, l_313.f0) , 0xEF03)) <= p_52.f2)))) || l_313.f0)) , l_313.f0) - (uint32_t)0x36CFAED5));
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_55(uint32_t  p_56)
{ /* block id: 37 */
    uint32_t l_57 = 0x3922CBD4;
    struct S0 l_58 = {0xAE26,46,4294967287U,1};
    int32_t l_292 = 0;
    int8_t l_297 = 0xA0;
    int32_t l_300 = 0x3D19DE9F;
    uint16_t l_301 = 0U;
    int32_t l_302 = 1;
    union U1 l_303 = {1U};
    struct S0 l_306 = {65535U,67,8U,-1};
    l_57 = p_56;
    l_58 = l_58;
    l_302 ^= ((((l_58.f3 = (-(uint16_t)(!p_56))) && ((-10) != ((((0x8A746C20 ^ ((uint32_t)__builtin_popcount(((l_58.f0 >= (l_292 = func_63(l_58.f2))) , ((uint16_t)((int16_t)l_297 - (int16_t)((int16_t)0 * (int16_t)(l_58.f1 && l_300))) * (uint16_t)l_58.f2))) % (uint32_t)l_57)) ^ 0x69161BFE) | l_301) ^ p_56))) , 8U) == 65530U);
    l_302 = ((((l_302 > (l_58.f3 = l_301)) | p_56) , l_303) , ((uint16_t)(0xFC59 > __builtin_popcountl(l_300)) - (uint16_t)(p_56 > (0U && 65535U))));
    return l_306;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_63(int32_t  p_64)
{ /* block id: 41 */
    uint16_t l_65 = 65535U;
    int32_t l_66 = 0x747EAB1A;
    uint32_t l_67 = 3U;
    struct S0 l_78 = {0x5BC6,24,0U,1};
    int32_t l_291 = 0x1D663A1C;
    l_66 = l_65;
    l_66 ^= p_64;
    l_66 = p_64;
    l_291 &= (l_67 <= (func_68(func_71((l_78.f3 = func_73(l_78, ((uint32_t)l_67 - (uint32_t)((int16_t)((uint16_t)func_85((((uint32_t)((l_66 = (1 && ((((int16_t)0x9EEB >> (int16_t)func_94(((l_78.f2 , 0x5D954113) , l_78.f3))) | l_65) < l_65))) || p_64) - (uint32_t)0x5B9120BB) >= p_64), l_78.f0, l_78.f1, l_78.f0) * (uint16_t)l_65) + (int16_t)6U)), p_64, p_64))), l_65) != l_67));
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_68(uint16_t  p_69, int32_t  p_70)
{ /* block id: 171 */
    struct S0 l_289 = {65534U,37,0x96FBF67A,0};
    uint16_t l_290 = 65535U;
    l_289 = l_289;
    return l_290;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_71(int8_t  p_72)
{ /* block id: 163 */
    int16_t l_275 = 5;
    int32_t l_283 = (-1);
    int16_t l_285 = 1;
    int32_t l_286 = 1;
    int32_t l_287 = 0x30D105BB;
    int32_t l_288 = 0;
    l_275 &= p_72;
    l_288 |= (l_287 &= ((!(p_72 | ((uint16_t)p_72 * (uint16_t)(l_286 = (p_72 , ((((((int16_t)((int16_t)(((l_275 , l_275) , p_72) & (l_283 = func_94(p_72))) >> (int16_t)5) << (int16_t)10) >= (l_285 = (!p_72))) , l_285) & l_275) < 1U)))))) <= l_275));
    return l_288;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_73(struct S0  p_74, uint32_t  p_75, int32_t  p_76, uint16_t  p_77)
{ /* block id: 153 */
    int32_t l_273 = 0xC160B9AC;
    for (p_74.f0 = 0; (p_74.f0 == 10); p_74.f0 += 1)
    { /* block id: 156 */
        struct S0 l_274 = {0x824C,53,0xFFC1A0B6,-1};
        if (l_273)
            break;
        if (p_77)
            break;
        l_274 = p_74;
    }
    return l_273;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_85(int8_t  p_86, int32_t  p_87, int32_t  p_88, uint32_t  p_89)
{ /* block id: 125 */
    int32_t l_228 = 6;
    union U1 l_231 = {0xF6BDF937};
    struct S0 l_232 = {5U,38,4U,-1};
    int32_t l_239 = 5;
    int32_t l_240 = (-10);
    int32_t l_241 = 0x79218DC8;
    int16_t l_246 = 2;
    int32_t l_256 = 0x444C74A6;
    int16_t l_257 = 5;
    int32_t l_258 = 1;
    l_241 |= ((uint16_t)(l_228 = 0xEC94) >> (uint16_t)(l_232.f3 = (0x9DA1 ^ (0x34ED | ((uint16_t)(l_231 , ((l_232 , l_231.f0) & (l_240 = ((uint16_t)p_88 - (uint16_t)(l_239 = (((uint32_t)((int16_t)__builtin_bswap64(p_88) >> (int16_t)8) - (uint32_t)p_87) || l_231.f0)))))) % (uint16_t)0xDF23)))));
    l_232.f3 &= ((p_86 & (l_241 ^= l_228)) <= (l_240 &= (p_88 || ((((int16_t)(p_86 <= p_89) + (int16_t)((uint16_t)l_246 << (uint16_t)4)) && l_239) , 1U))));
    p_88 = ((func_94((((l_232.f3 = ((int32_t)__builtin_ffsl((((uint16_t)l_231.f0 + (uint16_t)((l_256 = (((int32_t)((p_89 = ((p_88 , ((0x5B20C799 || (p_89 < ((-(uint32_t)((uint16_t)p_86 - (uint16_t)(-1))) || __builtin_ffsl(l_241)))) <= 0x0889)) <= l_256)) & l_241) + (int32_t)p_86) == 0)) & l_257)) , l_232.f3)) % (int32_t)l_258)) , l_232.f3) , 0x3AAD8979)) || l_258) , 0xA87C478B);
    for (l_231.f0 = 0; (l_231.f0 <= 36); l_231.f0 += 1)
    { /* block id: 140 */
        uint16_t l_261 = 0x2209;
        if ((l_261 , (p_88 = 0)))
        { /* block id: 142 */
            struct S0 l_262 = {0xC5C2,96,0xD044DB8E,-0};
            l_262 = l_262;
        }
        else
        { /* block id: 144 */
            int32_t l_268 = 7;
            l_268 &= ((int16_t)func_94((-(int32_t)((int16_t)p_87 >> (int16_t)2))) * (int16_t)(((1U | (l_232.f0 , (l_231 , l_256))) && 0xD6297384) ^ (p_88 < p_87)));
            p_88 = l_232.f2;
            p_88 &= (l_261 & (l_268 <= ((p_89 , p_86) ^ (-6))));
            p_87 = ((l_256 = l_268) && ((uint16_t)65535U >> (uint16_t)12));
        }
    }
    return p_88;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_94(uint32_t  p_95)
{ /* block id: 45 */
    uint32_t l_97 = 0x47622B46;
    int32_t l_98 = 0;
    uint16_t l_101 = 0x7801;
    int32_t l_102 = 0xEC2B408D;
    struct S0 l_103 = {0x3489,80,4U,0};
    int32_t l_110 = 0xAD075F43;
    int32_t l_111 = 0xD74E5B04;
    union U1 l_118 = {0U};
    struct S0 l_124 = {6U,95,0x872A0FD7,0};
    uint32_t l_137 = 1U;
    l_111 &= (!((l_103.f3 = (((l_102 = ((l_98 ^= ((p_95 , l_97) >= l_97)) != ((int16_t)l_101 >> (int16_t)p_95))) || ((l_110 &= ((l_103 , ((uint32_t)0xE38F49DA - (uint32_t)(((uint16_t)((uint16_t)((l_102 ^= l_103.f3) > ((l_97 <= 0x239C2B51) , l_101)) << (uint16_t)4) >> (uint16_t)p_95) == l_98))) ^ p_95)) == p_95)) , l_103.f0)) , l_103.f2));
    l_102 = (((uint16_t)p_95 << (uint16_t)p_95) & (p_95 != ((int16_t)(((uint16_t)(l_118 , (l_111 = (((l_98 |= ((uint16_t)(-(int32_t)p_95) << (uint16_t)15)) ^ p_95) != (__builtin_parity(p_95) || (l_102 , p_95))))) << (uint16_t)13) | 0xA9F0D2B7) * (int16_t)p_95)));
    l_111 &= (p_95 && p_95);
    for (l_103.f0 = 22; (l_103.f0 != 58); l_103.f0 += 1)
    { /* block id: 58 */
        int32_t l_125 = 0x417BD45E;
        struct S0 l_155 = {65535U,73,0xC9911E24,-1};
        l_124 = l_103;
        if ((l_125 ^ ((((uint16_t)(0xA0D0 != l_110) << (uint16_t)l_111) , p_95) >= ((l_103.f3 |= p_95) < 0x2693CE43))))
        { /* block id: 61 */
            uint32_t l_130 = 4294967287U;
            union U1 l_135 = {4294967295U};
            int8_t l_139 = 0xF2;
            int8_t l_146 = (-1);
            int8_t l_151 = (-1);
            int32_t l_166 = 0;
            uint16_t l_209 = 0x3C79;
            struct S0 l_217 = {0xC9D8,36,3U,-0};
            for (l_98 = (-10); (l_98 != (-27)); l_98 -= 1)
            { /* block id: 64 */
                union U1 l_136 = {1U};
                int32_t l_138 = 8;
                l_130 = l_125;
                for (l_124.f0 = 0; (l_124.f0 != 30); l_124.f0 += 1)
                { /* block id: 68 */
                    l_138 &= (((p_95 >= l_130) < ((1 > ((uint16_t)p_95 - (uint16_t)(l_130 , l_130))) , ((((((l_136 = l_135) , p_95) && (__builtin_clz(l_137) < 0xD86AEC8E)) ^ p_95) > l_124.f3) != p_95))) , 1);
                }
                l_139 ^= ((l_135.f0 && __builtin_parityll(p_95)) | 1);
            }
            if (((uint16_t)((((((uint32_t)p_95 - (uint32_t)l_125) <= l_103.f2) != ((int16_t)p_95 % (int16_t)l_118.f0)) < l_146) < 0x7504BC89) << (uint16_t)((int16_t)p_95 - (int16_t)((((int16_t)l_130 >> (int16_t)14) || l_130) , l_139))))
            { /* block id: 74 */
                uint16_t l_152 = 0U;
                l_152 = (l_151 , 8);
                for (l_151 = (-7); (l_151 == 6); l_151 += 1)
                { /* block id: 78 */
                    int32_t l_158 = (-5);
                    l_125 = (((l_155 , (((int32_t)l_158 % (int32_t)l_152) , 0x455F)) & (((l_102 |= ((int16_t)(((p_95 && p_95) , (0xEE08D729 & 0xAA45E959)) < p_95) << (int16_t)l_158)) < l_152) == l_152)) || 0x7B649564);
                }
                if (p_95)
                    continue;
            }
            else
            { /* block id: 83 */
                uint16_t l_163 = 65527U;
                int32_t l_169 = 0xFC580C8C;
                uint32_t l_174 = 0xE5BB3944;
                int32_t l_175 = 0xAB705B54;
                int32_t l_176 = 0x64651C79;
                union U1 l_224 = {0x98444E19};
                for (l_137 = (-3); (l_137 != 33); l_137 += 1)
                { /* block id: 86 */
                    l_163 = p_95;
                    l_166 = (1 ^ ((int16_t)l_125 >> (int16_t)13));
                    for (l_101 = 0; (l_101 != 2); l_101 += 2)
                    { /* block id: 91 */
                        l_169 ^= 0xD1579E77;
                    }
                }
                l_110 = 0xA7769A13;
                if ((((uint16_t)(((((int16_t)((l_155.f3 &= (l_166 = 8)) ^ (p_95 & (p_95 == (((((p_95 != (l_174 = (p_95 & p_95))) ^ (p_95 | (l_176 = (l_175 || (l_169 ^= 65530U))))) && l_125) , 7U) || l_151)))) >> (int16_t)2) , l_155.f3) && p_95) ^ p_95) - (uint16_t)(-9)) <= p_95))
                { /* block id: 101 */
                    uint32_t l_185 = 1U;
                    int32_t l_195 = 0xCF4E5FD2;
                    l_155.f3 ^= ((int16_t)((int32_t)l_155.f2 - (int32_t)0x9CB312F1) << (int16_t)((uint16_t)l_175 >> (uint16_t)p_95));
                    l_155.f3 = (((int32_t)l_185 + (int32_t)((((uint16_t)(0xA5956BBA < __builtin_clz(l_185)) >> (uint16_t)((uint16_t)l_151 * (uint16_t)l_155.f0)) != ((uint16_t)(0xF7AE06B2 || l_185) >> (uint16_t)(!(((int32_t)(l_195 = (l_146 > l_185)) % (int32_t)p_95) , 0)))) | 4294967290U)) & l_185);
                }
                else
                { /* block id: 105 */
                    struct S0 l_198 = {0xBAB5,113,0U,0};
                    for (l_151 = (-8); (l_151 >= 8); l_151 += 1)
                    { /* block id: 108 */
                        struct S0 l_199 = {65529U,54,0xD32DC010,-1};
                        int32_t l_216 = (-4);
                        l_199 = l_198;
                        l_198.f3 = ((int16_t)((int32_t)((!l_198.f3) | p_95) % (int32_t)((l_155.f2 >= ((int32_t)((uint16_t)(4294967295U == (((((l_155.f2 | (__builtin_popcountll(l_209) && ((((uint16_t)p_95 * (uint16_t)((((7 & 0x751DF647) && l_198.f3) & l_176) , 4U)) <= l_166) & l_174))) && l_125) | l_155.f1) <= 0) < 0x22A31682)) << (uint16_t)p_95) - (int32_t)l_166)) & p_95)) >> (int16_t)p_95);
                        l_169 = (((int16_t)((((int16_t)l_216 >> (int16_t)(((l_217 , ((((int16_t)(l_199.f3 = l_102) >> (int16_t)((l_163 == (l_155.f3 > ((uint16_t)((l_176 = ((int32_t)(l_224 , (-6)) + (int32_t)((__builtin_ctz(l_199.f0) >= l_146) < p_95))) > 0x2280) * (uint16_t)0))) & p_95)) >= l_155.f0) >= l_198.f3)) == l_155.f3) | 0x5214)) >= p_95) != l_198.f1) << (int16_t)8) == l_199.f2);
                    }
                }
            }
        }
        else
        { /* block id: 117 */
            uint32_t l_225 = 3U;
            l_155.f3 ^= l_97;
            l_225 = l_155.f2;
            if (l_155.f3)
                break;
        }
    }
    return l_137;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 197
   depth: 1, occurrence: 27
XXX total union variables: 17

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 27
breakdown:
   indirect level: 0, occurrence: 27
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 19
XXX times a bitfields struct on RHS: 30
XXX times a single bitfield on LHS: 41
XXX times a single bitfield on RHS: 82

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 176
   depth: 2, occurrence: 37
   depth: 3, occurrence: 3
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 14, occurrence: 4
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 22, occurrence: 4
   depth: 23, occurrence: 5
   depth: 24, occurrence: 4
   depth: 25, occurrence: 3
   depth: 26, occurrence: 3
   depth: 27, occurrence: 2
   depth: 28, occurrence: 1
   depth: 29, occurrence: 2
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 773
XXX times a non-volatile is write: 242
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 171
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 19
   depth: 2, occurrence: 22
   depth: 3, occurrence: 32
   depth: 4, occurrence: 27
   depth: 5, occurrence: 36

XXX percentage a fresh-made variable is used: 23.1
XXX percentage an existing variable is used: 76.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

