/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1639507271
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   uint32_t  f1;
   unsigned f2 : 1;
   float  f3;
};

union U1 {
   unsigned f0 : 8;
   const uint32_t  f1;
   const uint16_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_29(void);
static int32_t * func_30(union U1  p_31, uint16_t  p_32, int32_t * p_33, union U1  p_34, int32_t * p_35);
inline static union U1  func_36(float  p_37, float  p_38, float  p_39);
static float  func_41(int32_t  p_42, int32_t * p_43, uint16_t  p_44);
inline static int16_t  func_47(union U0  p_48);
static union U0  func_49(int32_t * p_50, int16_t  p_51, int32_t  p_52, int32_t * p_53);
static uint16_t  func_57(union U1  p_58, int32_t  p_59);
static int32_t  func_63(float  p_64, int32_t * p_65, int32_t * p_66, int32_t * p_67);
inline static int32_t * func_70(int32_t * p_71, int32_t * p_72, float  p_73);
static int32_t * func_74(union U0  p_75);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_40 = 0x9B504DBF;
    int32_t *l_54 = (void*)0;
    union U1 l_60 = {1U};
    int32_t l_485 = 0xC13ECC06;
    int32_t **l_488 = &l_54;
    (*l_488) = func_30(func_36(l_40, l_40, func_41(((-1) ^ ((int16_t)func_47(func_49(l_54, __builtin_ctzl(l_40), ((uint16_t)((l_54 != (void*)0) < (func_57(l_60, l_60.f0) >= 1U)) % (uint16_t)l_60.f0), l_54)) + (int16_t)0x1503)), l_54, l_60.f0)), l_485, l_54, l_60, l_54);
    return l_485;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(union U1  p_31, uint16_t  p_32, int32_t * p_33, union U1  p_34, int32_t * p_35)
{ /* block id: 323 */
    int32_t l_487 = 0;
    int32_t *l_486 = &l_487;
    return p_35;
    /* statement id: 324 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_36(float  p_37, float  p_38, float  p_39)
{ /* block id: 304 */
    union U0 l_469 = {4};
    union U0 *l_468 = &l_469;
    union U0 **l_467 = &l_468;
    int32_t *l_478 = (void*)0;
    union U1 l_481 = {4294967294U};
    uint16_t l_482 = 0U;
    int32_t l_483 = 0x677D8023;
    float *l_484 = &l_469.f3;
    if ((l_467 == (void*)0))
    { /* block id: 305 */
        int32_t *l_471 = (void*)0;
        int32_t **l_470 = &l_471;
        (*l_470) = func_74((*l_468));
    }
    else
    { /* block id: 307 */
        union U0 l_472 = {0x411D8708};
        int32_t l_475 = 0x580A802C;
        int32_t *l_474 = &l_475;
        int32_t **l_473 = &l_474;
        union U1 l_480 = {0xDBB99963};
        (*l_473) = func_74(l_472);
        /* statement id: 308 */
        assert (l_474 == 0);
        if (l_469.f2)
        { /* block id: 309 */
            union U1 l_479 = {0x91972728};
            for (l_472.f0 = 0; (l_472.f0 <= (-5)); --l_472.f0)
            { /* block id: 312 */
                (*l_473) = l_478;
                return l_479;
                /* statement id: 314 */
                            }
        }
        else
        { /* block id: 316 */
            return l_480;
            /* statement id: 317 */
                    }
        return l_481;
        /* statement id: 319 */
            }
    (*l_484) = ((((&l_478 == &l_478) == l_482) > p_39) == ((p_39 > 0x1.0p+1) < (__builtin_parityll(l_483) == p_37)));
    /* statement id: 321 */
        return l_481;
    /* statement id: 322 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_41(int32_t  p_42, int32_t * p_43, uint16_t  p_44)
{ /* block id: 137 */
    int32_t l_227 = 0xA4C91E03;
    int32_t *l_226 = &l_227;
    const union U0 l_233 = {0};
    const union U0 *l_232 = &l_233;
    const union U1 *l_276 = (void*)0;
    int32_t l_282 = (-1);
    union U1 l_310 = {0U};
    union U1 *l_309 = &l_310;
    union U1 **l_308 = &l_309;
    union U1 ***l_307 = &l_308;
    union U1 ****l_306 = &l_307;
    int16_t l_347 = 0x3E7A;
    int32_t ** const **l_402 = (void*)0;
    int32_t ** const *** const l_401 = &l_402;
    int32_t *****l_452 = (void*)0;
    int16_t l_463 = 1;
    float *l_464 = (void*)0;
    float l_466 = 0x5.6C7761p-7;
    float *l_465 = &l_466;
    (*l_226) = 0xDC146C1E;
    if ((*l_226))
    { /* block id: 139 */
        int16_t l_231 = 0x2BB2;
        union U0 l_235 = {6};
        union U0 * const l_234 = &l_235;
        int32_t *l_240 = (void*)0;
        union U1 l_260 = {0x8A3C79E3};
        union U1 *l_277 = &l_260;
        int32_t *l_369 = &l_227;
lbl_400:
        if (((!((int32_t)l_231 % (int32_t)(((-3) > (l_232 == l_234)) | (-1)))) >= ((int32_t)(((void*)0 == &p_43) && func_63((((float)((0x0.0764D1p+64 < p_42) != 0x9.Bp-1) - (float)0x8.2p+1) >= p_44), &l_227, &l_227, l_240)) + (int32_t)(-1))))
        { /* block id: 140 */
            int32_t l_241 = 1;
            p_42 = l_241;
            for (p_42 = 0; (p_42 <= 27); p_42 += 5)
            { /* block id: 144 */
                p_43 = &l_227;
                /* statement id: 145 */
                assert (p_43 == &l_227);
            }
            /* facts after for loop */
            assert (p_43 == &l_227 || p_43 == 0);
            for (l_235.f1 = 0; (l_235.f1 != 6); l_235.f1 += 3)
            { /* block id: 149 */
                return p_42;
            }
            /* facts after for loop */
                        for (p_42 = 0; (p_42 <= 29); p_42++)
            { /* block id: 154 */
                return p_44;
            }
        }
        else
        { /* block id: 157 */
            int32_t **l_272 = &l_226;
            int32_t *** const * const l_280 = (void*)0;
            union U0 *l_289 = &l_235;
            union U1 * const l_366 = &l_310;
        }
        /* facts after branching */
        assert (p_43 == &l_227 || p_43 == 0);
                p_43 = l_240;
        /* statement id: 266 */
        assert (p_43 == 0);
        if (p_44)
            goto lbl_400;
    }
    else
    { /* block id: 268 */
        int32_t *l_405 = (void*)0;
        int32_t l_416 = 0x512F6BAC;
        union U1 **l_460 = &l_309;
        (*l_306) = (*l_306);
        if (((l_401 != (void*)0) && (((p_42 & ((int32_t)(l_405 != (void*)0) % (int32_t)((int16_t)(0xAA2BD485 ^ ((uint16_t)(((uint16_t)((int32_t)(((int16_t)p_42 - (int16_t)p_42) && p_44) % (int32_t)l_416) << (uint16_t)p_42) && (*l_226)) >> (uint16_t)5)) << (int16_t)p_44))) && 0) ^ 0U)))
        { /* block id: 270 */
            uint16_t l_417 = 3U;
            union U0 **l_427 = (void*)0;
            union U1 l_448 = {0x7F85FFCD};
            int32_t **l_451 = &l_405;
            int32_t ***l_450 = &l_451;
            int32_t ****l_449 = &l_450;
            l_417 = p_42;
            for (l_416 = 16; (l_416 <= (-13)); l_416 -= 1)
            { /* block id: 274 */
                float l_430 = 0x5.0700F1p+93;
                int32_t l_431 = (-7);
                union U1 ****l_440 = &l_307;
                union U0 l_457 = {2};
                union U0 *l_456 = &l_457;
                for (p_42 = 0; (p_42 > 1); p_42++)
                { /* block id: 277 */
                    int32_t *l_422 = &l_227;
                    int32_t **l_423 = (void*)0;
                    union U0 **l_428 = (void*)0;
                    p_43 = l_422;
                    /* statement id: 278 */
                    assert (p_43 == &l_227);
                    if (__builtin_bswap32((((uint16_t)((!(l_427 != l_428)) && (!(p_44 ^ 0xF672))) % (uint16_t)l_417) == p_44)))
                    { /* block id: 279 */
                        int32_t **l_441 = (void*)0;
                        int32_t **l_442 = &l_422;
                        if (l_431)
                            break;
                        (*l_442) = func_70(&l_431, func_74(func_49(&l_416, l_431, (((int16_t)0x3EBF - (int16_t)l_431) ^ ((0 & 9) >= ((uint16_t)((int32_t)((uint16_t)((l_440 != &l_307) & l_417) % (uint16_t)0x84BB) + (int32_t)p_42) + (uint16_t)1))), &l_416)), p_42);
                        /* statement id: 281 */
                        assert (l_422 == 0);
                    }
                    else
                    { /* block id: 282 */
                        int32_t l_445 = 0;
                        (*l_226) = (p_42 > ((*p_43) ^ ((int16_t)(0x19CB918F >= (__builtin_ffs(l_445) | __builtin_popcountl(__builtin_parity((((int32_t)func_57(l_448, (l_449 == &l_450)) % (int32_t)p_44) && (*p_43)))))) + (int16_t)0x1E9E)));
                        l_452 = (void*)0;
                    }
                    /* facts after branching */
                    assert (l_422 == &l_227 || l_422 == 0);
                }
                if (p_42)
                    break;
                for (p_44 = 0; (p_44 == 21); ++p_44)
                { /* block id: 290 */
                    int32_t *l_455 = &l_431;
                    union U0 **l_458 = &l_456;
                    (**l_450) = l_455;
                    /* statement id: 291 */
                    assert (l_405 == &l_431);
                    (*l_455) = (*l_405);
                    (*l_458) = l_456;
                }
                /* facts after for loop */
                //assert (l_405 == &l_431 || l_405 == dangling || l_405 == 0);
            }
            /* facts after for loop */
            assert (p_43 == &l_227 || p_43 == 0);
            //assert (l_405 == dangling || l_405 == 0);
        }
        else
        { /* block id: 296 */
            int32_t *l_459 = &l_227;
            (*l_226) = p_44;
            p_43 = l_459;
            /* statement id: 298 */
            assert (p_43 == &l_227);
            (**l_306) = l_460;
        }
        /* facts after branching */
        assert (p_43 == &l_227 || p_43 == 0);
        //assert (l_405 == dangling || l_405 == 0);
    }
    /* facts after branching */
    assert (p_43 == &l_227 || p_43 == 0);
    (*l_465) = ((p_42 < p_42) > func_63(p_42, func_70(&l_227, &l_227, ((float)(l_463 <= (((((func_57((*l_309), p_44) != (*l_226)) <= 0x5.A23366p+25) > p_42) < 0xC.46499Ep+53) > p_44)) + (float)(*l_226))), &l_227, &l_227));
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_47(union U0  p_48)
{ /* block id: 134 */
    uint32_t l_223 = 4294967291U;
    int32_t l_225 = 0x5F277EB8;
    int32_t *l_224 = &l_225;
    (*l_224) = (l_223 >= l_223);
    return p_48.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_49(int32_t * p_50, int16_t  p_51, int32_t  p_52, int32_t * p_53)
{ /* block id: 78 */
    float l_142 = 0x8.794E54p-37;
    uint16_t l_145 = 0xF68D;
    float l_146 = 0x8.79906Cp+74;
    int32_t l_157 = (-2);
    union U1 l_161 = {0x43A31542};
    union U1 *l_160 = &l_161;
    union U0 l_194 = {0x28F77E60};
    union U0 *l_193 = &l_194;
    int32_t *l_208 = &l_157;
    int32_t **l_207 = &l_208;
    int32_t *** const l_206 = &l_207;
    union U0 l_222 = {1};
    if ((1 || (1 ^ (p_51 | ((uint16_t)l_145 + (uint16_t)l_145)))))
    { /* block id: 79 */
        union U1 **l_162 = &l_160;
        for (l_145 = 0; (l_145 < 32); l_145 += 1)
        { /* block id: 82 */
            int32_t l_158 = 0x8E08A2E4;
            for (p_51 = 0; (p_51 >= 3); p_51 += 7)
            { /* block id: 85 */
                int32_t **l_151 = (void*)0;
                int32_t l_154 = (-1);
                int32_t *l_153 = &l_154;
                int32_t **l_152 = &l_153;
                float *l_159 = &l_146;
                (*l_152) = &p_52;
                /* statement id: 86 */
                assert (l_153 == &p_52);
                l_157 = ((int16_t)(__builtin_parityll(p_51) > l_145) >> (int16_t)2);
                (*l_152) = &p_52;
                (*l_159) = l_158;
            }
        }
        (*l_162) = l_160;
    }
    else
    { /* block id: 93 */
        float l_176 = 0x1.3p-1;
        int32_t l_177 = 3;
        union U1 *l_205 = &l_161;
        union U0 l_221 = {0x2A784F90};
        for (p_52 = (-29); (p_52 <= (-29)); p_52 += 8)
        { /* block id: 96 */
            int32_t *l_165 = &l_157;
            union U1 l_172 = {0xA4B5A347};
            union U0 l_197 = {1};
            if (((void*)0 != l_165))
            { /* block id: 97 */
                int32_t **l_175 = (void*)0;
                union U0 l_178 = {1};
                union U1 **l_183 = &l_160;
                int32_t l_185 = 0x9D108F37;
                if (((uint16_t)(p_51 && ((int16_t)p_51 << (int16_t)((uint32_t)(func_57(l_172, ((uint16_t)(((((l_175 == &p_50) && (*l_165)) >= (1U >= __builtin_parityll(((*l_165) < l_145)))) > l_145) ^ p_52) % (uint16_t)0xAD62)) >= l_177) - (uint32_t)(-1)))) << (uint16_t)7))
                { /* block id: 98 */
                    int32_t **l_179 = &l_165;
                    float *l_180 = &l_146;
                    (*l_179) = func_74(l_178);
                    /* statement id: 99 */
                    assert (l_165 == 0);
                    (*l_180) = l_145;
                    if (l_145)
                        continue;
                }
                else
                { /* block id: 102 */
                    union U0 *l_182 = &l_178;
                    union U0 **l_181 = &l_182;
                    union U1 ***l_184 = &l_183;
                    (*l_181) = &l_178;
                    (*l_184) = l_183;
                }
                /* facts after branching */
                assert (l_165 == &l_157 || l_165 == 0);
                l_185 = l_145;
            }
            else
            { /* block id: 107 */
                union U1 *l_192 = &l_161;
                union U0 * const l_195 = &l_194;
                float *l_196 = &l_176;
                int32_t **l_198 = &l_165;
                (*l_196) = ((float)(*l_165) - (float)((p_51 >= ((float)l_145 - (float)((float)(l_192 == &l_161) - (float)p_52))) < (l_193 != l_195)));
                (*l_198) = func_74(l_197);
                /* statement id: 109 */
                assert (l_165 == 0);
                if (((int16_t)p_51 << (int16_t)4))
                { /* block id: 110 */
                    if (l_177)
                        break;
                }
                else
                { /* block id: 112 */
                    float l_202 = 0xE.686351p-73;
                    int32_t l_209 = 0;
                    int32_t *l_210 = &l_209;
                    if ((~(__builtin_parity((4294967286U == (l_157 < (p_52 != ((int32_t)(l_205 != (void*)0) % (int32_t)(p_52 ^ (l_206 == (void*)0))))))) <= l_209)))
                    { /* block id: 113 */
                        int32_t l_213 = (-1);
                        p_50 = func_70(&p_52, l_210, (((float)(*l_210) - (float)(-0x1.1p-1)) > p_52));
                        /* statement id: 114 */
                        assert (p_50 == &l_209);
                        if (l_213)
                            break;
                        //assert (p_50 == dangling);
                        (**l_206) = (*l_198);
                        /* statement id: 116 */
                        assert (l_208 == 0);
                    }
                    else
                    { /* block id: 117 */
                        return l_197;
                        /* statement id: 118 */
                                            }
                    /* facts after branching */
                    assert (p_50 == &l_209);
                    assert (l_208 == 0);
                    for (l_177 = 0; (l_177 == (-24)); --l_177)
                    { /* block id: 122 */
                        p_53 = &p_52;
                        /* statement id: 123 */
                        assert (p_53 == &p_52);
                    }
                }
                (*l_196) = ((float)(((0x0.Ep-1 <= (((-0x1.6p-1) != __builtin_bswap64(p_52)) == (!0x9.9p+1))) >= p_52) >= ((float)p_52 + (float)(&l_192 != &l_205))) + (float)0x5.0AB2CFp-75);
            }
            /* facts after branching */
            assert (l_165 == &l_157 || l_165 == 0);
            (**l_206) = l_165;
        }
        /* facts after for loop */
        //assert (p_50 == dangling || p_50 == 0 || p_50 == &l_227 || p_50 == &l_416);
        //assert (p_53 == &p_52 || p_53 == 0 || p_53 == &l_227 || p_53 == &l_416);
        assert (l_208 == 0 || l_208 == &l_157);
        return l_221;
        /* statement id: 130 */
            }
    (*l_207) = (void*)0;
    /* statement id: 132 */
    assert (l_208 == 0);
    return l_222;
    /* statement id: 133 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_57(union U1  p_58, int32_t  p_59)
{ /* block id: 37 */
    float l_68 = 0xC.1C760Fp-46;
    int32_t l_69 = (-5);
    union U0 l_76 = {0};
    int32_t *l_108 = &l_69;
    float *l_111 = &l_68;
    float *l_112 = (void*)0;
    int32_t *****l_141 = (void*)0;
    (*l_108) = ((int16_t)((func_63((l_68 <= l_69), &l_69, &l_69, func_70(&l_69, func_74(l_76), (p_58.f0 >= ((float)((float)l_76.f1 + (float)0x1.8F5E69p-99) + (float)l_76.f0)))) || l_76.f1) < 0) - (int16_t)l_76.f1);
    if ((((int16_t)p_58.f0 << (int16_t)__builtin_parityll((*l_108))) == (7 & (l_111 != l_112))))
    { /* block id: 55 */
        int32_t ** const l_120 = (void*)0;
        int32_t ** const l_121 = &l_108;
        int32_t *l_122 = &l_69;
        int32_t *l_125 = &l_69;
        for (l_76.f0 = 0; (l_76.f0 == (-30)); l_76.f0--)
        { /* block id: 58 */
            int32_t **l_127 = &l_125;
            int32_t ***l_126 = &l_127;
            if ((((int16_t)((int32_t)(-(uint32_t)1U) - (int32_t)0xBC2A5DE2) % (int16_t)p_58.f0) >= (func_63((l_120 != l_121), &p_59, l_122, &l_69) < (-1))))
            { /* block id: 59 */
                (**l_121) = ((uint16_t)(l_125 != &p_59) << (uint16_t)p_59);
            }
            else
            { /* block id: 61 */
                int32_t ****l_128 = &l_126;
                (*l_128) = l_126;
                return p_58.f0;
            }
            (*l_121) = &p_59;
            /* statement id: 65 */
            assert (l_108 == &p_59);
        }
        /* facts after for loop */
        assert (l_108 == &p_59 || l_108 == &l_69);
    }
    else
    { /* block id: 67 */
        int32_t *l_129 = &l_69;
        int32_t **l_134 = &l_108;
        (*l_134) = func_70(l_129, &l_69, ((float)((float)p_59 + (float)((p_58.f0 < p_59) <= p_59)) - (float)(-0x9.Dp+1)));
        for (l_76.f0 = 0; (l_76.f0 < 6); l_76.f0++)
        { /* block id: 71 */
            (*l_108) = ((uint32_t)p_58.f0 + (uint32_t)((int16_t)p_59 - (int16_t)(*l_129)));
        }
    }
    /* facts after branching */
    assert (l_108 == &p_59 || l_108 == &l_69);
    l_141 = l_141;
    p_59 = p_59;
    return p_58.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_63(float  p_64, int32_t * p_65, int32_t * p_66, int32_t * p_67)
{ /* block id: 47 */
    int32_t *l_98 = (void*)0;
    int32_t l_100 = 0x3C00EEBE;
    int32_t *l_99 = &l_100;
    int32_t **l_101 = (void*)0;
    const int32_t *l_103 = (void*)0;
    const int32_t **l_102 = &l_103;
    float *l_105 = (void*)0;
    float l_107 = 0xB.4F738Dp+33;
    float *l_106 = &l_107;
    (*l_102) = func_70(l_99, p_66, (*l_99));
    /* statement id: 48 */
    //assert (l_103 == &l_69 || l_103 == &l_227 || l_103 == &l_355);
    if (l_100)
        goto lbl_104;
    (*p_65) = (*p_65);
lbl_104:
    (*l_102) = (*l_102);
    (*l_106) = (0x5.A59A11p+39 >= (*l_99));
    return (*p_66);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_70(int32_t * p_71, int32_t * p_72, float  p_73)
{ /* block id: 41 */
    union U0 l_88 = {0x500C330E};
    int32_t **l_89 = (void*)0;
    int32_t *l_91 = (void*)0;
    int32_t **l_90 = &l_91;
    int32_t l_96 = 0xA82E93B6;
    int32_t *l_95 = &l_96;
    float *l_97 = &l_88.f3;
    (*l_90) = func_74(l_88);
    (*l_95) = (((int32_t)(*p_71) % (int32_t)l_88.f2) | (!(l_88.f0 <= (-10))));
    (*l_97) = p_73;
    /* statement id: 44 */
        (*l_90) = (*l_90);
    return p_72;
    /* statement id: 46 */
    //assert (func_70_rv == 0 || func_70_rv == &l_69 || func_70_rv == &l_209 || func_70_rv == &l_227 || func_70_rv == &l_355);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_74(union U0  p_75)
{ /* block id: 38 */
    int32_t l_78 = 3;
    int32_t *l_77 = &l_78;
    int32_t **l_79 = &l_77;
    int32_t *l_80 = &l_78;
    int32_t *l_81 = &l_78;
    int32_t *l_82 = &l_78;
    int32_t *l_83 = (void*)0;
    (*l_79) = l_77;
    return l_83;
    /* statement id: 40 */
    //assert (func_74_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 131
XXX total union variables: 15

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 42
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 15
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 21
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 13

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 121
   depth: 2, occurrence: 23
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 14, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 143

XXX times a variable address is taken: 151
XXX times a pointer is dereferenced on RHS: 53
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 3
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 79
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 10
   depth: 3, occurrence: 0
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 322

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 325
   level: 2, occurrence: 32
   level: 3, occurrence: 3
   level: 4, occurrence: 11
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.1
XXX average alias set size: 1.29

XXX times a non-volatile is read: 462
XXX times a non-volatile is write: 215
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 109
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 16
   depth: 2, occurrence: 17
   depth: 3, occurrence: 21
   depth: 4, occurrence: 13
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 19.1
XXX percentage an existing variable is used: 80.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

