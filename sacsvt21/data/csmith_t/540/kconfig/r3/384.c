/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2086309754
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   signed f0 : 11;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_32(void);
inline static int32_t * const  func_33(int32_t * const  p_34);
inline static int32_t * const  func_35(int32_t * p_36, int64_t  p_37);
static const int32_t * func_41(const union U0  p_42, uint32_t  p_43, int32_t  p_44);
inline static const union U0  func_45(float  p_46, int32_t  p_47, const int64_t  p_48);
inline static uint16_t  func_51(const uint8_t  p_52, int32_t * p_53, int32_t * p_54);
static int32_t * func_57(int32_t * p_58, uint8_t  p_59, int32_t * p_60);
inline static int32_t  func_63(int32_t * p_64, int32_t  p_65, float  p_66, int32_t * p_67, uint16_t  p_68);
static int32_t * func_69(const union U0  p_70, int32_t  p_71);
inline static const union U0  func_72(const int32_t * p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_32(void)
{ /* block id: 36 */
    int32_t *l_38 = (void*)0;
    int32_t l_39 = 0xA652065CL;
    int32_t **l_566 = &l_38;
    int32_t l_567 = 0x720E440DL;
    int32_t **l_568 = &l_38;
    uint32_t l_569 = 1UL;
    (*l_566) = func_33(func_35(l_38, l_39));
    (*l_568) = func_35((*l_566), l_567);
    return l_569;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_33(int32_t * const  p_34)
{ /* block id: 245 */
    int32_t l_416 = 2L;
    int32_t *l_415 = &l_416;
    int32_t **l_414 = &l_415;
    const union U0 l_420 = {0x6B9D081BL};
    float l_423 = 0x0.7p+1;
    int32_t *l_427 = &l_416;
    float **l_443 = (void*)0;
    float ** const *l_442 = &l_443;
    int32_t l_528 = 0x0620EE0EL;
    int16_t l_533 = 0L;
    int32_t **** const *l_557 = (void*)0;
    int32_t *l_564 = &l_416;
    int32_t * const l_565 = &l_416;
    (*l_414) = p_34;
    /* statement id: 246 */
    assert (l_415 == 0);
    for (l_416 = 12; (l_416 != (-12)); l_416 -= 3)
    { /* block id: 249 */
        uint16_t l_419 = 0UL;
        int32_t *l_424 = &l_416;
        union U0 l_471 = {1L};
        union U0 *l_470 = &l_471;
        int32_t *l_475 = &l_416;
        int32_t l_563 = 0xC1804D7EL;
        int32_t *l_562 = &l_563;
    }
    (*l_414) = l_564;
    /* statement id: 327 */
    assert (l_415 == &l_416);
    (*l_564) = ((*l_564) || (*l_564));
    return p_34;
    /* statement id: 329 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_35(int32_t * p_36, int64_t  p_37)
{ /* block id: 37 */
    uint16_t l_40 = 0x520EL;
    int32_t l_56 = (-1L);
    int32_t *l_55 = &l_56;
    const union U0 l_309 = {1L};
    float l_334 = 0x2.33E0D8p+16;
    float *l_333 = &l_334;
    float **l_332 = &l_333;
    int32_t **l_344 = &l_55;
    int32_t ***l_343 = &l_344;
    int32_t ****l_342 = &l_343;
    int32_t * const l_411 = &l_56;
    int32_t * const l_412 = &l_56;
    int32_t * const l_413 = (void*)0;
    if (l_40)
    { /* block id: 38 */
        int64_t l_62 = (-1L);
        const int32_t *l_74 = &l_56;
        int32_t l_169 = 0xF88CBA7AL;
        int32_t *l_168 = &l_169;
        union U0 l_331 = {0x83A3E19EL};
        union U0 *l_330 = &l_331;
        const int32_t ****l_345 = (void*)0;
        float **l_383 = &l_333;
        if (l_40)
        { /* block id: 39 */
            int32_t *l_61 = &l_56;
            int32_t l_301 = 0x39D5ECBEL;
            int32_t **l_308 = &l_61;
            const int16_t l_321 = 0L;
            const int32_t *l_322 = &l_56;
            (*l_308) = func_41(func_45(__builtin_parity(((0xF7D1649BC00EADD5LL && p_37) & (((uint16_t)func_51(p_37, l_55, func_57(l_61, (l_62 || func_63(func_69(func_72(l_74), p_37), p_37, p_37, l_168, p_37)), p_36)) + (uint16_t)p_37) <= 1UL))), p_37, p_37), l_301, p_37);
            /* statement id: 172 */
            assert (l_61 == 0);
            l_322 = func_41(l_309, ((uint32_t)(+(p_37 | (*l_74))) - (uint32_t)(*l_55)), (*l_55));
            /* statement id: 173 */
            assert (l_322 == 0);
            return p_36;
            /* statement id: 174 */
            //assert (func_35_rv == 0 || func_35_rv == &l_416);
        }
        else
        { /* block id: 175 */
            const union U0 l_325 = {0xDBE4E106L};
            int16_t l_329 = (-2L);
            int32_t *l_339 = &l_169;
            int32_t l_371 = (-9L);
            for (p_37 = 0; (p_37 != (-18)); p_37 -= 2)
            { /* block id: 178 */
                int32_t **l_326 = &l_168;
                (*l_326) = func_69(l_325, l_325.f0);
                /* statement id: 179 */
                assert (l_168 == 0);
                for (l_62 = 0; (l_62 > (-15)); l_62 -= 6)
                { /* block id: 182 */
                    (*l_55) = 0x8F8759F2L;
                }
                if ((*l_74))
                    continue;
            }
            /* facts after for loop */
            assert (l_168 == 0 || l_168 == &l_169);
            if ((l_329 != 0xEBA6L))
            { /* block id: 187 */
                uint16_t l_340 = 0x8560L;
                l_330 = l_330;
                if (((void*)0 != l_332))
                { /* block id: 189 */
                    int32_t l_337 = 0x3A3C8148L;
                    (*l_55) = ((int16_t)p_37 >> (int16_t)p_37);
                    (*l_55) = (1UL | p_37);
                    (*l_333) = p_37;
                }
                else
                { /* block id: 193 */
                    const union U0 l_341 = {4L};
                    (**l_343) = func_57(&l_169, l_340, p_36);
                    /* statement id: 194 */
                    //assert (l_55 == 0 || l_55 == &l_416);
                }
                /* facts after branching */
                //assert (l_55 == 0 || l_55 == &l_56 || l_55 == &l_416);
                for (l_169 = (-14); (l_169 < 29); ++l_169)
                { /* block id: 198 */
                    (***l_342) = p_36;
                    /* statement id: 199 */
                    //assert (l_55 == 0 || l_55 == &l_416);
                    if (l_340)
                        continue;
                }
            }
            else
            { /* block id: 202 */
                uint8_t l_370 = 0x11L;
                uint16_t l_373 = 0x907FL;
                int32_t *l_378 = &l_169;
                if ((p_37 < (0xC5C242C3L ^ ((((int64_t)p_37 - (int64_t)func_51(p_37, l_339, (**l_343))) || (((uint64_t)__builtin_bswap32(__builtin_popcount(p_37)) / (uint64_t)0xB4A2E4717275740ALL) & (*l_339))) & (-10L)))))
                { /* block id: 203 */
                    return p_36;
                    /* statement id: 204 */
                    //assert (func_35_rv == 0 || func_35_rv == &l_416);
                }
                else
                { /* block id: 205 */
                    float **l_364 = &l_333;
                    int32_t l_365 = 0x220364D1L;
                    union U0 *l_381 = &l_331;
                    for (l_331.f1 = 0; (l_331.f1 != 28); l_331.f1 += 4)
                    { /* block id: 208 */
                        const int16_t l_372 = 0x4925L;
                        int32_t **l_374 = &l_339;
                    }
                    /* facts after for loop */
                                        for (l_329 = (-5); (l_329 > (-20)); l_329 -= 8)
                    { /* block id: 214 */
                        const union U0 l_377 = {0x3864E8FAL};
                        union U0 **l_382 = &l_381;
                        (*l_339) = func_63(func_69(l_377, ((*l_342) == (*l_342))), (**l_344), l_370, l_378, ((uint32_t)p_37 - (uint32_t)(((*l_378) <= l_365) >= 0x5C3AA3BE4C5A7F0FLL)));
                        (*l_382) = l_381;
                    }
                }
                /* facts after branching */
                            }
            /* facts after branching */
            //assert (l_55 == 0 || l_55 == &l_56 || l_55 == &l_416);
        }
        /* facts after branching */
        //assert (l_55 == 0 || l_55 == &l_56 || l_55 == &l_416);
        assert (l_168 == 0 || l_168 == &l_169);
        p_36 = (***l_342);
        /* statement id: 221 */
        //assert (p_36 == 0 || p_36 == &l_56 || p_36 == &l_416);
        (**l_343) = func_69((*l_330), ((__builtin_popcountl(p_37) || (l_383 == (void*)0)) < ((void*)0 != p_36)));
        /* statement id: 222 */
        assert (l_55 == 0);
    }
    else
    { /* block id: 223 */
        int32_t *l_390 = &l_56;
        int32_t ***l_396 = &l_344;
        if (((((int16_t)p_37 << (int16_t)5) & ((int64_t)((**l_344) < (p_37 <= (p_37 || (*l_390)))) / (int64_t)(***l_343))) >= (*l_390)))
        { /* block id: 224 */
            uint32_t l_395 = 0x06600605L;
            (*l_55) = (((*l_390) || ((int32_t)((uint16_t)p_37 - (uint16_t)l_395) - (int32_t)p_37)) < (*l_390));
            (*l_55) = p_37;
        }
        else
        { /* block id: 227 */
            int32_t *l_397 = &l_56;
            (**l_332) = (*l_55);
            (*l_342) = l_396;
            (*l_344) = func_57(l_397, (**l_344), (**l_396));
            if (p_37)
            { /* block id: 231 */
                int32_t **** const * const l_400 = (void*)0;
                int32_t **** const *l_401 = &l_342;
                if ((((int16_t)p_37 >> (int16_t)14) || p_37))
                { /* block id: 232 */
                    l_401 = l_400;
                    /* statement id: 233 */
                    assert (l_401 == 0);
                    (***l_342) = (***l_342);
                    (**l_343) = p_36;
                    /* statement id: 235 */
                    //assert (l_55 == 0 || l_55 == &l_416);
                }
                else
                { /* block id: 236 */
                    int32_t *l_410 = &l_56;
                    (*l_397) = ((uint16_t)((&l_396 != (*l_401)) == ((int32_t)((((void*)0 == l_397) != (((int16_t)((int16_t)((**l_396) == l_410) / (int16_t)(*l_397)) + (int16_t)0xEF41L) > p_37)) == 4294967288UL) - (int32_t)(*l_390))) >> (uint16_t)8);
                }
                /* facts after branching */
                //assert (l_55 == &l_56 || l_55 == 0 || l_55 == &l_416);
                assert (l_401 == &l_342 || l_401 == 0);
            }
            else
            { /* block id: 239 */
                (*l_333) = (**l_344);
            }
            /* facts after branching */
            //assert (l_55 == &l_56 || l_55 == 0 || l_55 == &l_416);
        }
        /* facts after branching */
        //assert (l_55 == &l_56 || l_55 == 0 || l_55 == &l_416);
    }
    /* facts after branching */
    //assert (p_36 == 0 || p_36 == &l_56 || p_36 == &l_416);
    //assert (l_55 == &l_56 || l_55 == 0 || l_55 == &l_416);
    return l_413;
    /* statement id: 244 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_41(const union U0  p_42, uint32_t  p_43, int32_t  p_44)
{ /* block id: 168 */
    int32_t l_303 = (-4L);
    int32_t *l_302 = &l_303;
    int32_t **l_304 = &l_302;
    const int32_t *l_305 = &l_303;
    const int32_t *l_306 = &l_303;
    const int32_t *l_307 = (void*)0;
    (*l_304) = l_302;
    (**l_304) = p_42.f0;
    return l_307;
    /* statement id: 171 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const union U0  func_45(float  p_46, int32_t  p_47, const int64_t  p_48)
{ /* block id: 166 */
    const union U0 l_300 = {0xC452CB20L};
    return l_300;
    /* statement id: 167 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_51(const uint8_t  p_52, int32_t * p_53, int32_t * p_54)
{ /* block id: 160 */
    float l_290 = 0xA.DEAF15p-39;
    float *l_289 = &l_290;
    float **l_288 = &l_289;
    float ***l_291 = &l_288;
    int32_t l_292 = 0L;
    (*l_291) = l_288;
    (*l_289) = 0x9.049A3Fp+90;
    l_292 = (p_52 < p_52);
    (*p_53) = func_63(&l_292, p_52, ((float)((((func_63(p_53, (p_52 && ((uint16_t)(+((*p_53) | l_292)) << (uint16_t)6)), (((float)__builtin_ctzll(p_52) / (float)p_52) < l_292), &l_292, l_292) != 0x4.1p+1) < p_52) >= p_52) == l_292) / (float)p_52), &l_292, l_292);
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_57(int32_t * p_58, uint8_t  p_59, int32_t * p_60)
{ /* block id: 111 */
    float l_187 = 0x3.5C2835p+62;
    const int32_t l_188 = 0x39C8B3FFL;
    union U0 l_192 = {-3L};
    union U0 *l_191 = &l_192;
    int32_t l_197 = (-1L);
    int32_t *l_196 = &l_197;
    uint64_t l_200 = 8UL;
    int32_t **l_242 = &l_196;
    int32_t ***l_241 = &l_242;
    uint64_t l_286 = 18446744073709551610UL;
    float *l_287 = &l_187;
    (*p_58) = (*p_58);
    return p_60;
    /* statement id: 159 */
    //assert (func_57_rv == 0 || func_57_rv == &l_56 || func_57_rv == &l_416 || func_57_rv == &l_459);
}


/* ------------------------------------------ */
/* 
 * reads : l_56
 * writes:
 */
inline static int32_t  func_63(int32_t * p_64, int32_t  p_65, float  p_66, int32_t * p_67, uint16_t  p_68)
{ /* block id: 101 */
    int32_t l_171 = 0L;
    int32_t * const l_170 = &l_171;
    int32_t *l_173 = (void*)0;
    int32_t **l_172 = &l_173;
    int32_t ***l_175 = &l_172;
    int32_t ****l_174 = &l_175;
    float l_186 = 0xD.0D747Cp-90;
    float *l_185 = &l_186;
    (*l_172) = l_170;
    /* statement id: 102 */
    assert (l_173 == &l_171);
    (*l_173) = ((l_174 == &l_175) >= ((p_65 == (*l_173)) >= ((uint16_t)p_68 + (uint16_t)(*l_173))));
    for (l_171 = 6; (l_171 != (-30)); l_171 -= 6)
    { /* block id: 106 */
        uint64_t l_180 = 2UL;
        return l_180;
    }
    (*l_185) = (((float)0xA.58BFB5p-3 - (float)((float)(***l_175) / (float)0x9.C4F713p-90)) < (****l_174));
    return (*p_67);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(const union U0  p_70, int32_t  p_71)
{ /* block id: 98 */
    uint64_t l_163 = 1UL;
    int32_t l_165 = (-3L);
    int32_t *l_164 = &l_165;
    int32_t *l_166 = &l_165;
    int32_t *l_167 = (void*)0;
    (*l_164) = (l_163 == p_70.f0);
    return l_167;
    /* statement id: 100 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_56
 * writes: l_56
 */
inline static const union U0  func_72(const int32_t * p_73)
{ /* block id: 40 */
    int32_t l_77 = 9L;
    int32_t *l_76 = &l_77;
    int32_t **l_75 = &l_76;
    int32_t ***l_78 = (void*)0;
    int32_t ***l_79 = &l_75;
    const float l_86 = 0x0.1p+1;
    uint64_t l_87 = 1UL;
    const union U0 l_162 = {0x564D233DL};
    (*l_79) = l_75;
    (***l_79) = ((int16_t)(**l_75) << (int16_t)((int16_t)(&l_75 != (void*)0) + (int16_t)((**l_75) == (**l_75))));
    if (((((int16_t)((((**l_75) & (0x98A9A26275F98A97LL != (**l_75))) && (**l_75)) >= (__builtin_ctz((**l_75)) & ((**l_79) != (void*)0))) / (int16_t)l_87) <= (**l_75)) ^ (**l_75)))
    { /* block id: 43 */
        float l_88 = 0x7.FD40FDp-89;
        int32_t * const l_101 = &l_77;
        (***l_79) = (*p_73);
lbl_121:
        for (l_87 = (-25); (l_87 == 57); l_87++)
        { /* block id: 47 */
            int32_t * const *l_97 = &l_76;
            int32_t * const **l_96 = &l_97;
            const int32_t **l_117 = (void*)0;
            int32_t **l_118 = &l_76;
            for (l_77 = 0; (l_77 >= 19); l_77++)
            { /* block id: 50 */
                int32_t l_93 = (-10L);
                float *l_102 = &l_88;
                for (l_93 = 7; (l_93 > (-15)); l_93 -= 8)
                { /* block id: 53 */
                    int32_t ****l_98 = &l_78;
                    (*l_98) = l_96;
                    /* statement id: 54 */
                    assert (l_78 == &l_97);
                }
                (*l_102) = ((float)(l_101 == p_73) / (float)(**l_97));
                l_93 = ((float)((l_93 < (l_93 < (***l_96))) >= (***l_96)) / (float)((float)((float)(*l_101) + (float)(**l_97)) + (float)(((float)(**l_75) + (float)((float)(((float)((l_93 != ((float)(-0x6.Ap-1) - (float)(**l_97))) <= l_93) / (float)(*l_101)) >= 0xD.C4DB73p+93) + (float)(*l_101))) <= (**l_75))));
            }
            /* facts after for loop */
            //assert (l_78 == &l_97 || l_78 == 0 || l_78 == dangling);
            (*l_118) = p_73;
        }
        for (l_87 = 0; (l_87 >= 2); l_87 += 5)
        { /* block id: 63 */
            if (l_77)
                goto lbl_121;
            if ((*p_73))
                continue;
            (**l_75) = ((*l_76) || ((**l_75) < (4UL < ((*l_101) && __builtin_ffsll((*l_76))))));
            p_73 = l_101;
            /* statement id: 67 */
            assert (p_73 == &l_77);
        }
    }
    else
    { /* block id: 69 */
        const int32_t *l_126 = &l_77;
        const int32_t **l_125 = &l_126;
        const int32_t ** const *l_124 = &l_125;
        const union U0 l_135 = {0x3D7FDF8BL};
        int32_t l_136 = (-5L);
        (*l_76) = (((float)(l_124 == (void*)0) / (float)(***l_79)) != ((float)(**l_125) / (float)(**l_125)));
        for (l_87 = 4; (l_87 != 49); l_87 += 1)
        { /* block id: 73 */
            int64_t l_132 = 0x1E100AA352EE06DCLL;
            (***l_79) = ((+(l_132 <= ((*l_76) && (*l_126)))) <= ((int16_t)l_132 >> (int16_t)4));
            return l_135;
            /* statement id: 75 */
                    }
        (**l_79) = (*l_75);
        l_136 = (*p_73);
    }
    /* facts after branching */
    //assert (p_73 == &l_77 || p_73 == &l_56);
    //assert (l_76 == &l_56 || l_76 == &l_77);
    //assert (l_78 == dangling || l_78 == 0);
    if (((**l_75) >= (**l_75)))
    { /* block id: 80 */
        uint32_t l_137 = 0x48400EC8L;
        float *l_138 = (void*)0;
        float l_140 = 0x0.9p-1;
        float *l_139 = &l_140;
        int32_t *l_156 = &l_77;
        int32_t **l_157 = (void*)0;
        const int32_t *l_158 = &l_77;
        (*l_139) = ((**l_75) != l_137);
        for (l_87 = 0; (l_87 >= 3); l_87 += 4)
        { /* block id: 84 */
            float *l_150 = &l_140;
            int32_t l_153 = (-9L);
            l_153 = ((-(float)((**l_75) == (**l_75))) > ((((&l_79 != (void*)0) < __builtin_popcount(((*l_76) | (((int16_t)0x85A4L - (int16_t)(((int16_t)(((((int16_t)(((void*)0 != l_150) ^ (((int32_t)(l_137 == 4L) - (int32_t)l_137) || 0UL)) << (int16_t)9) || 2UL) | l_137) & l_153) >> (int16_t)7) ^ l_153)) < l_153)))) != 0x9.194E89p+15) < (**l_75)));
            for (l_137 = 10; (l_137 < 55); l_137++)
            { /* block id: 88 */
                (**l_79) = l_156;
                /* statement id: 89 */
                assert (l_76 == &l_77);
                (*l_156) = (*p_73);
            }
        }
        l_158 = p_73;
        /* statement id: 93 */
        //assert (l_158 == &l_77 || l_158 == &l_56);
    }
    else
    { /* block id: 94 */
        uint32_t l_159 = 1UL;
        float l_161 = 0x0.Bp+1;
        float *l_160 = &l_161;
        (*l_160) = __builtin_ctzl(l_159);
    }
    return l_162;
    /* statement id: 97 */
    }




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 149
XXX total union variables: 14

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 14
   indirect level: 1, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 9
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 26
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 19

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 111
   depth: 2, occurrence: 24
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 4
   depth: 6, occurrence: 3
   depth: 8, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 22, occurrence: 2
   depth: 27, occurrence: 1

XXX total number of pointers: 139

XXX times a variable address is taken: 129
XXX times a pointer is dereferenced on RHS: 156
breakdown:
   depth: 1, occurrence: 112
   depth: 2, occurrence: 32
   depth: 3, occurrence: 8
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 79
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 9
   depth: 3, occurrence: 5
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 473

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 590
   level: 2, occurrence: 106
   level: 3, occurrence: 71
   level: 4, occurrence: 42
XXX number of pointers point to pointers: 55
XXX number of pointers point to scalars: 78
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.9
XXX average alias set size: 1.35

XXX times a non-volatile is read: 808
XXX times a non-volatile is write: 222
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 101
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 16
   depth: 2, occurrence: 21
   depth: 3, occurrence: 14
   depth: 4, occurrence: 15
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

