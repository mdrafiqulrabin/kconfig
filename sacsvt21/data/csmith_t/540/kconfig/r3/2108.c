/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2847608622
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 5;
   int64_t  f1;
   unsigned f2 : 14;
   signed f3 : 24;
};

struct S1 {
   struct S0  f0;
   signed f1 : 9;
   signed f2 : 27;
   unsigned f3 : 13;
   signed f4 : 18;
   unsigned f5 : 25;
   const uint16_t  f6;
   signed f7 : 1;
   signed f8 : 5;
   signed f9 : 10;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_1(void);
static struct S0  func_6(int32_t  p_7, struct S0 * p_8, struct S0 * p_9);
static struct S0 * func_10(struct S0 * p_11, struct S0 * p_12, uint8_t  p_13);
static struct S0 * func_16(struct S0 * p_17, struct S0 * p_18, struct S0 * p_19);
inline static struct S0 * func_20(struct S0  p_21);
inline static struct S0  func_22(struct S0 * p_23, uint8_t  p_24, const uint8_t  p_25);
inline static uint64_t  func_26(int64_t  p_27);
inline static struct S0  func_30(uint32_t  p_31, struct S0 * const  p_32, struct S0 * p_33);
static struct S0 * const  func_35(struct S0 * p_36, struct S0 * p_37, int32_t  p_38);
inline static struct S0 * func_39(uint64_t  p_40, struct S0 * p_41, int16_t  p_42);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x60A22152L;
    struct S0 *l_5 = (void*)0;
    int32_t * const l_1448 = &l_2;
    int32_t l_1450 = (-2L);
    int32_t *l_1449 = &l_1450;
    struct S1 l_1451 = {{0,0xD72A112135007D0CLL,85,-304},10,3230,9,118,2660,65531UL,-0,3,20};
    for (l_2 = 0; (l_2 == (-4)); l_2 = safe_sub_func_uint8_t_u_u(l_2, 1))
    { /* block id: 3 */
        struct S0 l_15 = {4,0x2324015FB26C4F32LL,43,-231};
        struct S0 *l_14 = &l_15;
        l_5 = (void*)0;
        if (l_2)
            continue;
        (*l_14) = func_6(l_2, l_5, func_10(l_14, func_16(&l_15, func_20(func_22(l_5, l_15.f0, ((func_26((((l_15.f1 & l_2) == (((l_2 || l_15.f3) ^ l_2) == l_15.f0)) != l_15.f0)) > 0x69C088FB3B7070A0LL) <= l_15.f1))), l_5), l_15.f3));
        l_1449 = l_1448;
        /* statement id: 910 */
        assert (l_1449 == &l_2);
    }
    /* facts after for loop */
    assert (l_1449 == &l_2 || l_1449 == &l_1450);
    return l_1451;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_6(int32_t  p_7, struct S0 * p_8, struct S0 * p_9)
{ /* block id: 824 */
    uint32_t l_1259[10] = {4294967295UL,4294967295UL,4294967295UL,4294967295UL,4294967295UL,4294967295UL,4294967295UL,4294967295UL,4294967295UL,4294967295UL};
    float ***l_1271 = (void*)0;
    float ****l_1270 = &l_1271;
    float *****l_1269 = &l_1270;
    int32_t l_1301 = 0x13CC3926L;
    struct S0 l_1320 = {1,0x7B9FB4BBB7E5A656LL,98,-140};
    struct S0 *l_1319 = &l_1320;
    struct S0 **l_1318 = &l_1319;
    struct S0 ***l_1317 = &l_1318;
    int32_t *l_1352 = (void*)0;
    int32_t * const *l_1364[6];
    int32_t * const **l_1363[3][5][3] = {{{&l_1364[3],&l_1364[3],&l_1364[3]},{&l_1364[3],&l_1364[1],&l_1364[3]},{&l_1364[3],&l_1364[3],&l_1364[3]},{&l_1364[3],&l_1364[1],&l_1364[3]},{&l_1364[3],&l_1364[3],&l_1364[3]}},{{&l_1364[3],&l_1364[1],&l_1364[3]},{&l_1364[3],&l_1364[3],&l_1364[3]},{&l_1364[3],&l_1364[1],&l_1364[3]},{&l_1364[3],&l_1364[3],&l_1364[3]},{&l_1364[3],&l_1364[1],&l_1364[3]}},{{&l_1364[3],&l_1364[3],&l_1364[3]},{&l_1364[3],&l_1364[1],&l_1364[3]},{&l_1364[3],&l_1364[3],&l_1364[3]},{&l_1364[3],&l_1364[1],&l_1364[3]},{&l_1364[3],&l_1364[3],&l_1364[3]}}};
    int32_t * const ***l_1362 = &l_1363[0][4][1];
    int32_t * const ****l_1361 = &l_1362;
    float l_1435 = 0x7.96B9DDp+57;
    int32_t **l_1446 = &l_1352;
    struct S0 l_1447 = {4,-1L,34,3392};
    int i, j, k;
    for (i = 0; i < 6; i++)
        l_1364[i] = &l_1352;
    for (p_7 = 3; (p_7 <= 9); p_7 += 1)
    { /* block id: 827 */
        int32_t l_1260[4] = {0xE901DFE1L,0xE901DFE1L,0xE901DFE1L,0xE901DFE1L};
        int32_t *l_1331[7][3][7] = {{{&l_1260[1],&l_1260[1],&l_1301,(void*)0,(void*)0,&l_1260[1],&l_1260[1]},{(void*)0,&l_1260[1],&l_1260[1],&l_1260[1],&l_1260[1],&l_1260[1],(void*)0},{&l_1260[1],&l_1260[1],&l_1260[1],&l_1260[1],&l_1260[1],(void*)0,&l_1260[1]}},{{(void*)0,(void*)0,(void*)0,&l_1260[1],(void*)0,(void*)0,&l_1260[1]},{&l_1260[1],(void*)0,&l_1260[1],&l_1301,&l_1260[1],(void*)0,(void*)0},{&l_1260[1],&l_1260[1],&l_1260[1],(void*)0,&l_1260[1],(void*)0,(void*)0}},{{(void*)0,&l_1260[1],&l_1301,&l_1301,&l_1260[1],(void*)0,&l_1301},{&l_1260[1],&l_1260[1],&l_1260[1],&l_1301,(void*)0,(void*)0,&l_1260[1]},{(void*)0,(void*)0,&l_1260[3],(void*)0,&l_1260[1],(void*)0,&l_1260[3]}},{{&l_1260[1],&l_1260[1],(void*)0,&l_1301,&l_1301,&l_1260[1],&l_1260[3]},{&l_1301,&l_1260[1],&l_1301,&l_1260[1],&l_1260[3],&l_1260[1],&l_1260[1]},{&l_1301,&l_1260[1],(void*)0,&l_1260[1],&l_1301,&l_1260[1],&l_1301}},{{(void*)0,(void*)0,(void*)0,&l_1260[1],&l_1260[1],(void*)0,(void*)0},{&l_1260[1],(void*)0,&l_1301,(void*)0,(void*)0,&l_1301,(void*)0},{(void*)0,&l_1260[1],(void*)0,&l_1301,&l_1260[1],&l_1301,&l_1260[1]}},{{&l_1301,&l_1260[1],&l_1260[3],(void*)0,&l_1260[1],(void*)0,&l_1260[1]},{&l_1301,&l_1260[1],&l_1260[1],&l_1301,&l_1260[1],&l_1260[1],(void*)0},{&l_1260[1],&l_1260[1],&l_1301,(void*)0,(void*)0,&l_1260[1],&l_1260[1]}},{{(void*)0,&l_1260[1],&l_1260[1],&l_1260[1],&l_1260[1],&l_1260[1],(void*)0},{&l_1260[1],&l_1260[1],&l_1260[1],&l_1260[1],&l_1260[1],(void*)0,&l_1260[1]},{(void*)0,(void*)0,(void*)0,&l_1260[1],(void*)0,(void*)0,&l_1260[1]}}};
        float l_1349[3];
        float * const l_1348 = &l_1349[0];
        float * const *l_1347[4] = {&l_1348,&l_1348,&l_1348,&l_1348};
        float * const **l_1346 = &l_1347[2];
        float * const ***l_1345 = &l_1346;
        float * const ****l_1344[5][5] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_1345,&l_1345,&l_1345,&l_1345,&l_1345},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_1345,&l_1345,&l_1345,&l_1345,&l_1345},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
        uint32_t l_1360[3];
        struct S0 ****l_1374 = &l_1317;
        struct S0 *****l_1373 = &l_1374;
        float *****l_1406 = (void*)0;
        struct S1 **l_1432 = (void*)0;
        int16_t l_1442 = (-1L);
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_1349[i] = 0x0.0p+1;
        for (i = 0; i < 3; i++)
            l_1360[i] = 0x13E05A97L;
        for (l_1260[1] = 9; (l_1260[1] >= 2); l_1260[1] -= 1)
        { /* block id: 830 */
            int32_t l_1300 = 0x8714854BL;
            int32_t **l_1328 = (void*)0;
            int32_t *l_1330 = &l_1260[1];
            int32_t **l_1329[10][7][3] = {{{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{(void*)0,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{(void*)0,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330}},{{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330}},{{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,(void*)0},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,(void*)0},{&l_1330,&l_1330,&l_1330}},{{&l_1330,&l_1330,&l_1330},{&l_1330,(void*)0,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{(void*)0,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{(void*)0,&l_1330,&l_1330}},{{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330}},{{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,(void*)0},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,(void*)0}},{{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,(void*)0,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{(void*)0,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330}},{{(void*)0,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330}},{{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330},{&l_1330,&l_1330,(void*)0},{&l_1330,&l_1330,&l_1330}},{{&l_1330,&l_1330,(void*)0},{&l_1330,&l_1330,(void*)0},{&l_1330,&l_1330,&l_1330},{&l_1330,(void*)0,&l_1330},{&l_1330,&l_1330,&l_1330},{(void*)0,&l_1330,&l_1330},{&l_1330,&l_1330,&l_1330}}};
            struct S0 l_1334 = {0,2L,70,3963};
            int8_t l_1369[2][7][4] = {{{0x6FL,0xC3L,0x34L,0x2CL},{0xD2L,0x1BL,1L,0x2CL},{0x8AL,0xC3L,0x8AL,1L},{0x51L,0x6FL,0xA7L,0x51L},{0xD2L,1L,1L,0x6FL},{1L,0xC3L,1L,1L},{0xD2L,0xD2L,0xA7L,0x2CL}},{{0x51L,0xFBL,0x8AL,0x6FL},{0x8AL,0x6FL,1L,0x8AL},{0xD2L,0x6FL,0x34L,0x6FL},{0x6FL,0xFBL,1L,0x2CL},{0x1BL,0xD2L,1L,1L},{0x51L,0xC3L,(-1L),0x6FL},{0x51L,1L,1L,0x51L}}};
            int32_t l_1396[9][4][1] = {{{1L},{0x79A93FF6L},{0xB34E6162L},{1L}},{{3L},{0L},{(-1L)},{0L}},{{3L},{1L},{0xB34E6162L},{0x79A93FF6L}},{{1L},{0xED7086F8L},{0xED388729L},{0xED388729L}},{{0xED7086F8L},{1L},{0x79A93FF6L},{0xB34E6162L}},{{1L},{3L},{0L},{(-1L)}},{{0L},{3L},{1L},{0xB34E6162L}},{{0x79A93FF6L},{1L},{0xED7086F8L},{0xED388729L}},{{0xED388729L},{0xED7086F8L},{1L},{0x79A93FF6L}}};
            float ***** const l_1405 = &l_1270;
            struct S0 ***l_1421 = (void*)0;
            int i, j, k;
            if (l_1259[l_1260[1]])
            { /* block id: 831 */
                int32_t l_1261[10];
                uint32_t l_1290 = 0x6EA77962L;
                int i;
                for (i = 0; i < 10; i++)
                    l_1261[i] = 6L;
                for (l_1261[0] = 9; (l_1261[0] >= 0); l_1261[0] -= 1)
                { /* block id: 834 */
                    struct S1 ***l_1266 = (void*)0;
                    struct S1 ****l_1265[4] = {&l_1266,&l_1266,&l_1266,&l_1266};
                    float l_1292 = (-0x1.Ap-1);
                    float *l_1291 = &l_1292;
                    int i;
                    (*l_1291) = (safe_sub_func_float_f_f(((l_1259[l_1260[1]] > (!(l_1265[0] == (void*)0))) < ((((safe_div_func_float_f_f(((((l_1269 != (void*)0) == 0x4.1p+1) <= (((safe_add_func_float_f_f((0x4.2p-1 < ((((!(safe_add_func_float_f_f((p_7 != ((safe_div_func_float_f_f((!(safe_add_func_float_f_f(((safe_add_func_float_f_f((((safe_div_func_float_f_f((safe_div_func_float_f_f((safe_div_func_float_f_f((-0x3.Fp-1), l_1261[0])), p_7)), p_7)) == l_1259[l_1260[1]]) <= l_1259[7]), p_7)) <= l_1260[2]), p_7))), l_1260[2])) < l_1290)), p_7))) != 0x0.884FABp-42) < p_7) < l_1259[l_1260[1]])), p_7)) == 0xE.51AF82p+72) != (-0x1.2p-1))) >= p_7), p_7)) <= l_1259[6]) <= l_1259[2]) <= l_1260[1])), (-0x10.6p+1)));
                }
                for (l_1290 = 1; (l_1290 <= 9); l_1290 += 1)
                { /* block id: 839 */
                    int i;
                    if (l_1259[p_7])
                        break;
                }
            }
            else
            { /* block id: 842 */
                int32_t l_1293[1];
                struct S1 l_1303 = {{0,1L,14,-3049},16,4859,41,254,5157,65535UL,0,3,24};
                struct S1 *l_1302 = &l_1303;
                int i;
                for (i = 0; i < 1; i++)
                    l_1293[i] = (-1L);
                for (l_1293[0] = 0; (l_1293[0] >= 21); l_1293[0] = safe_add_func_uint8_t_u_u(l_1293[0], 6))
                { /* block id: 845 */
                    int32_t l_1296[8][7] = {{0L,0L,0L,0L,0L,0L,0L},{0xC92F1AC9L,0x1B5131B1L,0x1B5131B1L,0xC92F1AC9L,0x1B5131B1L,0x1B5131B1L,0xC92F1AC9L},{0x180AB261L,0L,0x180AB261L,0x180AB261L,0L,0x180AB261L,0x180AB261L},{0xC92F1AC9L,0xC92F1AC9L,0xD1E5BAA8L,0xC92F1AC9L,0xC92F1AC9L,0xD1E5BAA8L,0xC92F1AC9L},{0L,0x180AB261L,0x180AB261L,0L,0x180AB261L,0x180AB261L,0L},{0x1B5131B1L,0xC92F1AC9L,0x1B5131B1L,0x1B5131B1L,0xC92F1AC9L,0x1B5131B1L,0x1B5131B1L},{0L,0L,0L,0L,0L,0L,0L},{0xC92F1AC9L,0x1B5131B1L,0x1B5131B1L,0xC92F1AC9L,0x1B5131B1L,0x1B5131B1L,0xC92F1AC9L}};
                    int32_t *l_1299[6];
                    int i, j;
                    for (i = 0; i < 6; i++)
                        l_1299[i] = (void*)0;
                    for (l_1296[6][1] = 3; (l_1296[6][1] <= 9); l_1296[6][1] += 1)
                    { /* block id: 848 */
                        int32_t *l_1298 = &l_1260[3];
                        int32_t **l_1297 = &l_1298;
                        (*l_1297) = &l_1296[6][1];
                        /* statement id: 849 */
                        assert ((l_1298 >= &l_1296[0][0] && l_1298 <= &l_1296[7][6]));
                    }
                    l_1300 = p_7;
                    if (p_7)
                        continue;
                }
                l_1301 = l_1259[l_1260[1]];
                if (p_7)
                { /* block id: 855 */
                    struct S1 **l_1304 = &l_1302;
                    (*l_1304) = l_1302;
                }
                else
                { /* block id: 857 */
                    float l_1326 = 0x0.6A8079p-93;
                    float *l_1325[5];
                    int32_t l_1327 = 3L;
                    int i;
                    for (i = 0; i < 5; i++)
                        l_1325[i] = &l_1326;
                    l_1327 = (((void*)0 == &p_7) == (l_1303.f0.f1 <= ((((safe_div_func_float_f_f(((safe_add_func_float_f_f((safe_add_func_float_f_f((safe_sub_func_float_f_f(((safe_add_func_float_f_f(((safe_div_func_float_f_f(p_7, ((((void*)0 != l_1317) >= (safe_add_func_float_f_f(((safe_div_func_float_f_f(0xC.D29664p-53, ((p_9 == p_9) <= 0xA.0646DEp+79))) < 0x7.DC4810p+50), p_7))) > p_7))) != l_1301), l_1303.f6)) >= l_1260[2]), 0x1.3p-1)), l_1301)), p_7)) != 0x7.8p+1), p_7)) > p_7) <= l_1260[1]) <= (-0x10.5p+1))));
                }
            }
            l_1331[0][0][2] = &p_7;
            for (l_1301 = (-30); (l_1301 >= (-2)); l_1301 = safe_add_func_uint16_t_u_u(l_1301, 9))
            { /* block id: 864 */
                int32_t ***l_1351 = (void*)0;
                int32_t **** const l_1350 = &l_1351;
                struct S1 l_1404 = {{1,6L,15,-1365},-6,-8312,81,-205,1617,0xF331L,0,2,20};
                struct S1 *l_1403 = &l_1404;
                float **l_1418[1][2][1];
                int32_t *l_1444 = &l_1300;
                int i, j, k;
                for (i = 0; i < 1; i++)
                {
                    for (j = 0; j < 2; j++)
                    {
                        for (k = 0; k < 1; k++)
                            l_1418[i][j][k] = (void*)0;
                    }
                }
                for (l_1300 = 9; (l_1300 >= 0); l_1300 -= 1)
                { /* block id: 867 */
                    if (p_7)
                        break;
                    return l_1334;
                }
                if (((safe_add_func_int8_t_s_s(((p_7 <= (safe_lshift_func_uint8_t_u_u((safe_sub_func_int64_t_s_s(((+(p_8 == (void*)0)) != (1UL | (safe_div_func_uint64_t_u_u(p_7, l_1320.f3)))), (l_1344[2][3] != (void*)0))), (((void*)0 == l_1350) && p_7)))) | (-1L)), p_7)) != p_7))
                { /* block id: 871 */
                    uint32_t l_1372 = 0x5D4E429CL;
                    int32_t *l_1381 = &l_1300;
                    l_1352 = &p_7;
                    /* statement id: 872 */
                    assert (l_1352 == &p_7);
                    if ((safe_mod_func_int8_t_s_s((safe_unary_minus_func_int64_t_s(p_7)), 0x32L)))
                    { /* block id: 873 */
                        int32_t l_1368 = 0x917C885CL;
                        if ((*l_1352))
                            break;
                        l_1369[1][5][0] = (((((safe_add_func_int16_t_s_s((p_7 & p_7), l_1360[1])) && ((((((l_1361 == (void*)0) ^ (safe_unary_minus_func_uint64_t_u((safe_sub_func_int8_t_s_s(0x1AL, l_1368))))) == (&p_7 != (void*)0)) < p_7) >= (*****l_1361)) < p_7)) > p_7) == p_7) > 0L);
                    }
                    else
                    { /* block id: 876 */
                        struct S0 ** const *l_1377 = &l_1318;
                        int32_t l_1378[2][3][2] = {{{0xDF756E69L,0x10A24EDDL},{0x10A24EDDL,0xDF756E69L},{0x10A24EDDL,0x10A24EDDL}},{{0xDF756E69L,0x10A24EDDL},{0x10A24EDDL,0xDF756E69L},{0x10A24EDDL,0x10A24EDDL}}};
                        int i, j, k;
                        l_1378[1][2][0] = ((safe_sub_func_float_f_f((-0x1.0p-1), (l_1372 > (l_1373 == (void*)0)))) >= (safe_sub_func_float_f_f((l_1377 != &l_1318), p_7)));
                    }
                    for (l_1300 = 0; (l_1300 != (-20)); l_1300 = safe_sub_func_int64_t_s_s(l_1300, 1))
                    { /* block id: 881 */
                        l_1381 = l_1381;
                    }
                }
                else
                { /* block id: 884 */
                    struct S1 l_1385[8][5][5] = {{{{{0,0L,67,566},-21,3451,40,-31,117,65533UL,-0,1,-18},{{3,-1L,61,3180},-2,8328,36,-389,5724,5UL,-0,0,20},{{1,0xEAEF8E9E69793709LL,70,311},13,4731,86,210,3549,65531UL,0,1,-8},{{4,0x3ED760145373AB34LL,1,4081},-4,-11484,6,226,458,0x7F6DL,-0,3,-12},{{0,-1L,22,3476},-19,9229,19,140,2105,0xEBDCL,-0,4,-4}},{{{3,-1L,90,-535},-14,7220,80,-221,1888,0x89EDL,0,2,-30},{{1,7L,35,2579},-5,-930,49,-176,1479,0xC2C4L,0,0,-14},{{0,0L,49,-1197},-12,-729,83,-75,153,1UL,-0,-0,28},{{1,0x6222016ECCE5127DLL,101,-3234},-19,-2803,1,-75,193,0x7617L,-0,-3,-21},{{0,0x32610ACB504B33BFLL,127,3315},8,6138,33,-32,4994,0x4B8EL,-0,-1,-4}},{{{1,0xEAEF8E9E69793709LL,70,311},13,4731,86,210,3549,65531UL,0,1,-8},{{1,0L,66,-949},-4,-8087,77,-395,5085,0x54D3L,-0,4,14},{{3,3L,103,2528},-1,4449,67,-240,5375,0UL,-0,4,-8},{{4,-1L,68,-3485},-6,-3935,20,-51,2066,8UL,0,-0,15},{{1,-1L,112,-1286},-17,-4384,78,474,813,65532UL,-0,-3,-13}},{{{2,0xF02D2A7EE1E204E3LL,74,-2574},16,-7623,64,-108,5685,1UL,0,3,4},{{3,3L,103,2528},-1,4449,67,-240,5375,0UL,-0,4,-8},{{3,0L,18,1122},-16,-8199,53,444,5208,0UL,-0,-2,-12},{{4,-1L,21,-3830},5,8421,51,427,3981,0xA650L,0,-4,30},{{0,1L,14,1406},20,-7280,48,25,2902,1UL,0,1,-13}},{{{4,0xC386D84B9EE6B29DLL,56,-1158},20,3779,34,476,4860,0x635AL,0,1,29},{{3,3L,103,2528},-1,4449,67,-240,5375,0UL,-0,4,-8},{{3,-1L,90,-535},-14,7220,80,-221,1888,0x89EDL,0,2,-30},{{3,0L,120,397},18,-10004,16,222,1452,0xAE7CL,0,-3,-20},{{4,0x5FC5197A094BC7B1LL,89,-1057},14,-10443,53,384,897,1UL,0,3,4}}},{{{{2,1L,103,-3775},20,-6167,84,445,1726,0xC066L,0,-2,-12},{{1,0L,66,-949},-4,-8087,77,-395,5085,0x54D3L,-0,4,14},{{1,-1L,112,-1286},-17,-4384,78,474,813,65532UL,-0,-3,-13},{{0,4L,127,3829},-11,-9160,15,-57,1818,0x4662L,0,-3,-17},{{0,0x229A31D8C77FC141LL,57,1132},-16,-1663,88,-130,4050,0x97C1L,0,-2,-2}},{{{3,0xA54F0045359C16E2LL,70,1315},14,416,54,470,1296,0xACC6L,0,1,-13},{{3,4L,105,3224},-11,-539,1,263,303,0x7605L,-0,0,-0},{{0,0L,95,600},-20,-6142,44,79,809,0x396DL,0,2,7},{{3,0L,40,-1366},-13,-5314,70,-6,283,1UL,0,-1,23},{{0,4L,127,3829},-11,-9160,15,-57,1818,0x4662L,0,-3,-17}},{{{3,1L,77,-1641},18,312,40,43,2373,1UL,-0,4,-10},{{0,-1L,50,1895},15,7689,46,16,1316,0xF3EFL,0,-2,8},{{0,-1L,50,1895},15,7689,46,16,1316,0xF3EFL,0,-2,8},{{3,1L,77,-1641},18,312,40,43,2373,1UL,-0,4,-10},{{0,0x018A55F3BACDA8DALL,28,-3733},14,-3131,22,-206,2223,0x8741L,-0,4,-28}},{{{0,0L,95,600},-20,-6142,44,79,809,0x396DL,0,2,7},{{4,-1L,65,-423},-0,-6362,81,142,1217,0x8873L,0,1,-8},{{4,0x3ED760145373AB34LL,1,4081},-4,-11484,6,226,458,0x7F6DL,-0,3,-12},{{1,0x2B8E7ACB49BF5437LL,9,-3903},2,6799,34,86,4339,65528UL,0,-4,29},{{1,0x72CCE15033744605LL,33,1647},8,1152,17,-248,2113,3UL,-0,-0,-22}},{{{1,0x6222016ECCE5127DLL,101,-3234},-19,-2803,1,-75,193,0x7617L,-0,-3,-21},{{4,-1L,21,-3830},5,8421,51,427,3981,0xA650L,0,-4,30},{{3,0L,120,397},18,-10004,16,222,1452,0xAE7CL,0,-3,-20},{{2,0x128A98C99325E04ALL,1,-3040},16,-7501,0,-359,5695,0xBE8BL,0,2,21},{{1,0x5252515BD4B6E28DLL,10,-918},11,-3612,49,100,1453,0x0BE1L,-0,1,-13}}},{{{{4,0x808D3D06DBF32126LL,25,-2335},12,6735,48,123,4136,0xD21FL,0,-3,29},{{3,0x9676FABF7CA609F0LL,86,-2420},15,-1030,71,-176,1021,0xE40DL,0,4,16},{{0,1L,123,-3412},-12,9625,10,31,533,0UL,-0,1,21},{{1,0x2B8E7ACB49BF5437LL,9,-3903},2,6799,34,86,4339,65528UL,0,-4,29},{{1,0x1F6DF55CAE5EDE47LL,21,-3961},-21,7085,10,-87,2256,65527UL,0,-1,-4}},{{{0,0x306D2CCB65C6217DLL,61,-2139},-9,-7959,84,-116,5523,5UL,-0,4,27},{{4,0x7CCBD3A9CF815969LL,109,-1812},16,-6874,44,-133,4020,1UL,0,-4,29},{{1,7L,35,2579},-5,-930,49,-176,1479,0xC2C4L,0,0,-14},{{3,1L,77,-1641},18,312,40,43,2373,1UL,-0,4,-10},{{3,0x5808D3F191A36A6FLL,75,-3130},-17,-3842,49,414,4194,65532UL,-0,3,-11}},{{{4,0x7CCBD3A9CF815969LL,109,-1812},16,-6874,44,-133,4020,1UL,0,-4,29},{{1,-1L,112,-1286},-17,-4384,78,474,813,65532UL,-0,-3,-13},{{4,0x808D3D06DBF32126LL,25,-2335},12,6735,48,123,4136,0xD21FL,0,-3,29},{{3,0L,40,-1366},-13,-5314,70,-6,283,1UL,0,-1,23},{{2,1L,103,-3775},20,-6167,84,445,1726,0xC066L,0,-2,-12}},{{{1,0x72CCE15033744605LL,33,1647},8,1152,17,-248,2113,3UL,-0,-0,-22},{{1,0x1EF27CF6F55AF009LL,101,-1465},4,-9112,3,506,1402,65530UL,-0,-3,16},{{3,1L,77,-1641},18,312,40,43,2373,1UL,-0,4,-10},{{0,4L,127,3829},-11,-9160,15,-57,1818,0x4662L,0,-3,-17},{{0,0L,49,-1197},-12,-729,83,-75,153,1UL,-0,-0,28}},{{{3,-1L,90,-535},-14,7220,80,-221,1888,0x89EDL,0,2,-30},{{4,0L,53,3238},-19,-2512,50,50,4079,0UL,-0,4,-11},{{3,0x9676FABF7CA609F0LL,86,-2420},15,-1030,71,-176,1021,0xE40DL,0,4,16},{{3,0L,120,397},18,-10004,16,222,1452,0xAE7CL,0,-3,-20},{{0,0L,95,600},-20,-6142,44,79,809,0x396DL,0,2,7}}},{{{{4,0x3ED760145373AB34LL,1,4081},-4,-11484,6,226,458,0x7F6DL,-0,3,-12},{{1,0x5252515BD4B6E28DLL,10,-918},11,-3612,49,100,1453,0x0BE1L,-0,1,-13},{{0,0x018A55F3BACDA8DALL,28,-3733},14,-3131,22,-206,2223,0x8741L,-0,4,-28},{{4,-1L,21,-3830},5,8421,51,427,3981,0xA650L,0,-4,30},{{0,0L,67,566},-21,3451,40,-31,117,65533UL,-0,1,-18}},{{{4,0x3ED760145373AB34LL,1,4081},-4,-11484,6,226,458,0x7F6DL,-0,3,-12},{{1,0xBB1EC85C954591EBLL,13,-2733},-11,-7810,72,99,2381,65529UL,-0,3,5},{{4,1L,69,2374},9,9833,54,-82,318,0x5C1CL,0,-3,22},{{4,-1L,68,-3485},-6,-3935,20,-51,2066,8UL,0,-0,15},{{1,0x2B8E7ACB49BF5437LL,9,-3903},2,6799,34,86,4339,65528UL,0,-4,29}},{{{3,-1L,90,-535},-14,7220,80,-221,1888,0x89EDL,0,2,-30},{{0,0x306D2CCB65C6217DLL,61,-2139},-9,-7959,84,-116,5523,5UL,-0,4,27},{{4,0x7DD04EE9E71A624ALL,56,2635},-21,4492,67,-392,2412,65535UL,0,2,-17},{{4,0xC386D84B9EE6B29DLL,56,-1158},20,3779,34,476,4860,0x635AL,0,1,29},{{1,7L,35,2579},-5,-930,49,-176,1479,0xC2C4L,0,0,-14}},{{{1,0x72CCE15033744605LL,33,1647},8,1152,17,-248,2113,3UL,-0,-0,-22},{{3,0xC38D7FB887A1C100LL,86,-2736},-7,10984,63,-426,4145,0x5424L,0,3,-8},{{1,0L,66,-949},-4,-8087,77,-395,5085,0x54D3L,-0,4,14},{{3,0xA54F0045359C16E2LL,70,1315},14,416,54,470,1296,0xACC6L,0,1,-13},{{3,0xA54F0045359C16E2LL,70,1315},14,416,54,470,1296,0xACC6L,0,1,-13}},{{{4,0x7CCBD3A9CF815969LL,109,-1812},16,-6874,44,-133,4020,1UL,0,-4,29},{{0,0x32610ACB504B33BFLL,127,3315},8,6138,33,-32,4994,0x4B8EL,-0,-1,-4},{{4,0x7CCBD3A9CF815969LL,109,-1812},16,-6874,44,-133,4020,1UL,0,-4,29},{{2,0L,84,-1538},7,8594,43,317,4060,0x48CDL,0,-3,-7},{{3,3L,103,2528},-1,4449,67,-240,5375,0UL,-0,4,-8}}},{{{{0,0x306D2CCB65C6217DLL,61,-2139},-9,-7959,84,-116,5523,5UL,-0,4,27},{{2,1L,103,-3775},20,-6167,84,445,1726,0xC066L,0,-2,-12},{{2,0x128A98C99325E04ALL,1,-3040},16,-7501,0,-359,5695,0xBE8BL,0,2,21},{{4,0x7CCBD3A9CF815969LL,109,-1812},16,-6874,44,-133,4020,1UL,0,-4,29},{{1,-4L,70,-3557},-20,-4325,36,-53,488,0x04FBL,-0,0,-21}},{{{4,0x808D3D06DBF32126LL,25,-2335},12,6735,48,123,4136,0xD21FL,0,-3,29},{{2,0x28B591624045E0F0LL,58,3093},-17,8177,0,-425,65,0x6B2FL,0,1,-25},{{0,0x229A31D8C77FC141LL,57,1132},-16,-1663,88,-130,4050,0x97C1L,0,-2,-2},{{4,-1L,65,-423},-0,-6362,81,142,1217,0x8873L,0,1,-8},{{3,0xC38D7FB887A1C100LL,86,-2736},-7,10984,63,-426,4145,0x5424L,0,3,-8}},{{{1,0x6222016ECCE5127DLL,101,-3234},-19,-2803,1,-75,193,0x7617L,-0,-3,-21},{{3,0xC0E8F06E0473ADE1LL,15,-2874},6,-106,26,74,5165,65534UL,0,-3,-3},{{2,0x128A98C99325E04ALL,1,-3040},16,-7501,0,-359,5695,0xBE8BL,0,2,21},{{1,-4L,70,-3557},-20,-4325,36,-53,488,0x04FBL,-0,0,-21},{{2,0xF02D2A7EE1E204E3LL,74,-2574},16,-7623,64,-108,5685,1UL,0,3,4}},{{{0,0L,95,600},-20,-6142,44,79,809,0x396DL,0,2,7},{{1,0xA4BA0CF5DA76B8BBLL,49,-3140},11,-7392,0,-63,528,1UL,-0,3,-16},{{4,0x7CCBD3A9CF815969LL,109,-1812},16,-6874,44,-133,4020,1UL,0,-4,29},{{1,-1L,112,-1286},-17,-4384,78,474,813,65532UL,-0,-3,-13},{{4,0x808D3D06DBF32126LL,25,-2335},12,6735,48,123,4136,0xD21FL,0,-3,29}},{{{3,1L,77,-1641},18,312,40,43,2373,1UL,-0,4,-10},{{3,0x5808D3F191A36A6FLL,75,-3130},-17,-3842,49,414,4194,65532UL,-0,3,-11},{{1,0L,66,-949},-4,-8087,77,-395,5085,0x54D3L,-0,4,14},{{3,0x9676FABF7CA609F0LL,86,-2420},15,-1030,71,-176,1021,0xE40DL,0,4,16},{{4,0x7DD04EE9E71A624ALL,56,2635},-21,4492,67,-392,2412,65535UL,0,2,-17}}},{{{{3,0xA54F0045359C16E2LL,70,1315},14,416,54,470,1296,0xACC6L,0,1,-13},{{1,0xEAEF8E9E69793709LL,70,311},13,4731,86,210,3549,65531UL,0,1,-8},{{4,0x7DD04EE9E71A624ALL,56,2635},-21,4492,67,-392,2412,65535UL,0,2,-17},{{1,0x5252515BD4B6E28DLL,10,-918},11,-3612,49,100,1453,0x0BE1L,-0,1,-13},{{0,0x306D2CCB65C6217DLL,61,-2139},-9,-7959,84,-116,5523,5UL,-0,4,27}},{{{2,1L,103,-3775},20,-6167,84,445,1726,0xC066L,0,-2,-12},{{1,7L,35,2579},-5,-930,49,-176,1479,0xC2C4L,0,0,-14},{{4,1L,69,2374},9,9833,54,-82,318,0x5C1CL,0,-3,22},{{3,0xC0E8F06E0473ADE1LL,15,-2874},6,-106,26,74,5165,65534UL,0,-3,-3},{{3,0L,40,-1366},-13,-5314,70,-6,283,1UL,0,-1,23}},{{{4,0xC386D84B9EE6B29DLL,56,-1158},20,3779,34,476,4860,0x635AL,0,1,29},{{4,0x2C052DF99FD5D272LL,117,-175},21,-11126,81,35,2454,65535UL,-0,-4,-24},{{0,0x018A55F3BACDA8DALL,28,-3733},14,-3131,22,-206,2223,0x8741L,-0,4,-28},{{2,0xF02D2A7EE1E204E3LL,74,-2574},16,-7623,64,-108,5685,1UL,0,3,4},{{3,0L,40,-1366},-13,-5314,70,-6,283,1UL,0,-1,23}},{{{2,0xF02D2A7EE1E204E3LL,74,-2574},16,-7623,64,-108,5685,1UL,0,3,4},{{0,4L,127,3829},-11,-9160,15,-57,1818,0x4662L,0,-3,-17},{{3,0x9676FABF7CA609F0LL,86,-2420},15,-1030,71,-176,1021,0xE40DL,0,4,16},{{3,0L,87,241},0,-9354,84,323,4594,0x74A2L,0,-4,7},{{0,0x306D2CCB65C6217DLL,61,-2139},-9,-7959,84,-116,5523,5UL,-0,4,27}},{{{1,0xEAEF8E9E69793709LL,70,311},13,4731,86,210,3549,65531UL,0,1,-8},{{3,0L,87,241},0,-9354,84,323,4594,0x74A2L,0,-4,7},{{3,1L,77,-1641},18,312,40,43,2373,1UL,-0,4,-10},{{3,-1L,61,3180},-2,8328,36,-389,5724,5UL,-0,0,20},{{4,0x7DD04EE9E71A624ALL,56,2635},-21,4492,67,-392,2412,65535UL,0,2,-17}}},{{{{4,1L,69,2374},9,9833,54,-82,318,0x5C1CL,0,-3,22},{{2,0x128A98C99325E04ALL,1,-3040},16,-7501,0,-359,5695,0xBE8BL,0,2,21},{{4,0x808D3D06DBF32126LL,25,-2335},12,6735,48,123,4136,0xD21FL,0,-3,29},{{3,0L,18,1122},-16,-8199,53,444,5208,0UL,-0,-2,-12},{{4,0x808D3D06DBF32126LL,25,-2335},12,6735,48,123,4136,0xD21FL,0,-3,29}},{{{0,0x0AEDC64EE9B59A4BLL,70,-1475},-15,6305,25,-238,402,0x2A74L,-0,3,-31},{{0,0x0AEDC64EE9B59A4BLL,70,-1475},-15,6305,25,-238,402,0x2A74L,-0,3,-31},{{1,7L,35,2579},-5,-930,49,-176,1479,0xC2C4L,0,0,-14},{{3,4L,105,3224},-11,-539,1,263,303,0x7605L,-0,0,-0},{{2,0xF02D2A7EE1E204E3LL,74,-2574},16,-7623,64,-108,5685,1UL,0,3,4}},{{{4,0x2C052DF99FD5D272LL,117,-175},21,-11126,81,35,2454,65535UL,-0,-4,-24},{{1,-4L,70,-3557},-20,-4325,36,-53,488,0x04FBL,-0,0,-21},{{0,1L,123,-3412},-12,9625,10,31,533,0UL,-0,1,21},{{4,0L,53,3238},-19,-2512,50,50,4079,0UL,-0,4,-11},{{3,0xC38D7FB887A1C100LL,86,-2736},-7,10984,63,-426,4145,0x5424L,0,3,-8}},{{{0,1L,123,-3412},-12,9625,10,31,533,0UL,-0,1,21},{{4,0x3ED760145373AB34LL,1,4081},-4,-11484,6,226,458,0x7F6DL,-0,3,-12},{{3,0L,120,397},18,-10004,16,222,1452,0xAE7CL,0,-3,-20},{{1,0x1F6DF55CAE5EDE47LL,21,-3961},-21,7085,10,-87,2256,65527UL,0,-1,-4},{{1,-4L,70,-3557},-20,-4325,36,-53,488,0x04FBL,-0,0,-21}},{{{2,0x8737243F1EAE545CLL,116,-1665},-14,-11051,50,-277,3802,9UL,0,-0,-29},{{1,-4L,70,-3557},-20,-4325,36,-53,488,0x04FBL,-0,0,-21},{{4,0x3ED760145373AB34LL,1,4081},-4,-11484,6,226,458,0x7F6DL,-0,3,-12},{{0,0x018A55F3BACDA8DALL,28,-3733},14,-3131,22,-206,2223,0x8741L,-0,4,-28},{{3,3L,103,2528},-1,4449,67,-240,5375,0UL,-0,4,-8}}},{{{{2,0x28B591624045E0F0LL,58,3093},-17,8177,0,-425,65,0x6B2FL,0,1,-25},{{0,0x0AEDC64EE9B59A4BLL,70,-1475},-15,6305,25,-238,402,0x2A74L,-0,3,-31},{{0,-1L,50,1895},15,7689,46,16,1316,0xF3EFL,0,-2,8},{{4,0x2C052DF99FD5D272LL,117,-175},21,-11126,81,35,2454,65535UL,-0,-4,-24},{{3,0xA54F0045359C16E2LL,70,1315},14,416,54,470,1296,0xACC6L,0,1,-13}},{{{4,0L,53,3238},-19,-2512,50,50,4079,0UL,-0,4,-11},{{2,0x128A98C99325E04ALL,1,-3040},16,-7501,0,-359,5695,0xBE8BL,0,2,21},{{0,0L,95,600},-20,-6142,44,79,809,0x396DL,0,2,7},{{4,0x808D3D06DBF32126LL,25,-2335},12,6735,48,123,4136,0xD21FL,0,-3,29},{{1,7L,35,2579},-5,-930,49,-176,1479,0xC2C4L,0,0,-14}},{{{1,7L,35,2579},-5,-930,49,-176,1479,0xC2C4L,0,0,-14},{{3,0L,87,241},0,-9354,84,323,4594,0x74A2L,0,-4,7},{{1,-1L,112,-1286},-17,-4384,78,474,813,65532UL,-0,-3,-13},{{2,0x28B591624045E0F0LL,58,3093},-17,8177,0,-425,65,0x6B2FL,0,1,-25},{{1,0x2B8E7ACB49BF5437LL,9,-3903},2,6799,34,86,4339,65528UL,0,-4,29}},{{{3,0L,120,397},18,-10004,16,222,1452,0xAE7CL,0,-3,-20},{{0,4L,127,3829},-11,-9160,15,-57,1818,0x4662L,0,-3,-17},{{3,-1L,90,-535},-14,7220,80,-221,1888,0x89EDL,0,2,-30},{{4,0x7DD04EE9E71A624ALL,56,2635},-21,4492,67,-392,2412,65535UL,0,2,-17},{{0,0L,67,566},-21,3451,40,-31,117,65533UL,-0,1,-18}},{{{3,4L,105,3224},-11,-539,1,263,303,0x7605L,-0,0,-0},{{4,0x2C052DF99FD5D272LL,117,-175},21,-11126,81,35,2454,65535UL,-0,-4,-24},{{3,0L,18,1122},-16,-8199,53,444,5208,0UL,-0,-2,-12},{{4,0x7DD04EE9E71A624ALL,56,2635},-21,4492,67,-392,2412,65535UL,0,2,-17},{{0,0L,95,600},-20,-6142,44,79,809,0x396DL,0,2,7}}}};
                    struct S1 *l_1384[1];
                    int i, j, k;
                    for (i = 0; i < 1; i++)
                        l_1384[i] = &l_1385[7][0][2];
                    for (l_1300 = (-13); (l_1300 == (-18)); --l_1300)
                    { /* block id: 887 */
                        const struct S1 *l_1387 = &l_1385[7][0][2];
                        const struct S1 **l_1386 = &l_1387;
                        int32_t l_1401 = 0L;
                        struct S0 *l_1402 = &l_1320;
                        (*l_1386) = l_1384[0];
                        l_1385[7][0][2].f0 = l_1385[7][0][2].f0;
                        (*l_1386) = l_1403;
                        /* statement id: 890 */
                        assert (l_1387 == &l_1404);
                    }
                    l_1406 = l_1405;
                    /* statement id: 892 */
                    assert (l_1406 == &l_1270);
                }
                if (((((((safe_unary_minus_func_int64_t_s((safe_rshift_func_int8_t_s_u((safe_add_func_int8_t_s_s((safe_lshift_func_int16_t_s_s((safe_rshift_func_int8_t_s_u((((p_7 ^ (0x94B9DA60L < (safe_rshift_func_int8_t_s_u((l_1418[0][1][0] != (void*)0), 5)))) > (safe_add_func_uint16_t_u_u(((p_7 < (l_1421 != (void*)0)) == p_7), (safe_div_func_uint8_t_u_u((((safe_div_func_int64_t_s_s(((0xBCA134B3EA1EBA4ELL >= p_7) >= 65529UL), p_7)) || (*l_1330)) != p_7), (*l_1330)))))) != p_7), p_7)), (*l_1330))), p_7)), 7)))) & p_7) ^ p_7) != p_7) < p_7) & (-8L)))
                { /* block id: 894 */
                    int8_t l_1441 = 0x6FL;
                    int32_t l_1443 = 5L;
                    l_1443 = ((safe_lshift_func_uint16_t_u_u((safe_mod_func_uint8_t_u_u((4294967295UL & 4294967286UL), (safe_add_func_int16_t_s_s((((((l_1432 == (void*)0) <= (safe_div_func_int64_t_s_s(p_7, (p_7 && ((-1L) | ((((+((safe_add_func_uint32_t_u_u((safe_add_func_int32_t_s_s(((-1L) && p_7), 0x6E1932DAL)), p_7)) > l_1441)) || p_7) == 1UL) & p_7)))))) >= 0xA445163E8E839565LL) && p_7) > 65530UL), l_1441)))), 8)) < l_1442);
                    l_1444 = &p_7;
                    /* statement id: 896 */
                    assert (l_1444 == &p_7);
                }
                else
                { /* block id: 897 */
                    struct S0 l_1445 = {3,0L,119,-152};
                    l_1352 = (void*)0;
                    /* statement id: 898 */
                    assert (l_1352 == 0);
                    if (p_7)
                        break;
                    (*l_1319) = l_1445;
                    l_1331[3][1][0] = &l_1260[3];
                }
                /* facts after branching */
                assert (l_1444 == &l_1300 || l_1444 == &p_7);
            }
            l_1352 = &p_7;
            /* statement id: 904 */
            assert (l_1352 == &p_7);
        }
        /* facts after for loop */
        //assert (l_1331[0][0][0] == &p_7 || (l_1331[0][0][0] >= &l_1260[0] && l_1331[0][0][0] <= &l_1260[3]) || l_1331[0][0][0] == 0 || l_1331[0][0][0] == &l_1301);
        assert (l_1406 == &l_1270 || l_1406 == 0);
    }
    /* facts after for loop */
    assert (l_1352 == &p_7 || l_1352 == 0);
    (*l_1446) = &p_7;
    /* statement id: 907 */
    assert (l_1352 == &p_7);
    return l_1447;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_10(struct S0 * p_11, struct S0 * p_12, uint8_t  p_13)
{ /* block id: 820 */
    int32_t l_1238 = 0x67AFCA27L;
    int32_t *l_1237[10] = {&l_1238,(void*)0,&l_1238,(void*)0,&l_1238,(void*)0,&l_1238,(void*)0,&l_1238,(void*)0};
    int32_t **l_1239[8] = {&l_1237[9],(void*)0,&l_1237[9],&l_1237[9],(void*)0,&l_1237[9],&l_1237[9],(void*)0};
    int32_t *l_1240[2];
    uint8_t l_1256 = 0xEBL;
    uint32_t l_1257 = 6UL;
    struct S0 *l_1258 = (void*)0;
    int i;
    for (i = 0; i < 2; i++)
        l_1240[i] = (void*)0;
    l_1240[0] = l_1237[9];
    /* statement id: 821 */
    //assert (l_1240[0] == &l_1238 || l_1240[0] == 0);
    l_1257 = (+((safe_rshift_func_uint8_t_u_s(p_13, ((safe_lshift_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s((((0xA10EL | p_13) < (p_13 | (safe_rshift_func_uint16_t_u_u((((safe_add_func_uint64_t_u_u(0xA5E4789536D3A171LL, (safe_rshift_func_int16_t_s_s(6L, 4)))) <= p_13) == (safe_add_func_uint8_t_u_u((((p_13 > 0UL) > 0UL) && p_13), p_13))), 4)))) < p_13), 1)) < 65535UL), 13)) && p_13))) <= l_1256));
    return l_1258;
    /* statement id: 823 */
    //assert (func_10_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_16(struct S0 * p_17, struct S0 * p_18, struct S0 * p_19)
{ /* block id: 572 */
    int16_t l_964[10];
    int32_t l_965[7] = {0L,0x8FBEFA39L,0x8FBEFA39L,0L,0x8FBEFA39L,0x8FBEFA39L,0L};
    int32_t l_971 = 7L;
    int32_t *l_970 = &l_971;
    float l_975 = (-0x8.2p-1);
    float *l_974 = &l_975;
    float **l_973 = &l_974;
    int32_t **l_984 = &l_970;
    int32_t ***l_983[4] = {&l_984,&l_984,&l_984,&l_984};
    uint8_t l_998 = 0x3CL;
    struct S1 l_1068[6] = {{{2,0x4D992687E478C822LL,17,-2658},-16,7293,65,366,249,0x91A6L,-0,-4,-18},{{2,0x4D992687E478C822LL,17,-2658},-16,7293,65,366,249,0x91A6L,-0,-4,-18},{{2,0x4D992687E478C822LL,17,-2658},-16,7293,65,366,249,0x91A6L,-0,-4,-18},{{2,0x4D992687E478C822LL,17,-2658},-16,7293,65,366,249,0x91A6L,-0,-4,-18},{{2,0x4D992687E478C822LL,17,-2658},-16,7293,65,366,249,0x91A6L,-0,-4,-18},{{2,0x4D992687E478C822LL,17,-2658},-16,7293,65,366,249,0x91A6L,-0,-4,-18}};
    struct S1 *l_1067 = &l_1068[4];
    struct S1 ** const l_1066 = &l_1067;
    struct S1 **l_1069 = &l_1067;
    float l_1087 = 0x1.2p+1;
    struct S0 *l_1112 = &l_1068[4].f0;
    const int32_t *l_1200 = &l_965[0];
    int32_t ****l_1235 = &l_983[2];
    int32_t *l_1236 = &l_965[2];
    int i;
    for (i = 0; i < 10; i++)
        l_964[i] = (-1L);
    for (l_965[0] = 0; (l_965[0] <= 9); l_965[0] += 1)
    { /* block id: 575 */
        int32_t l_966 = 0L;
        float **l_976 = &l_974;
        int32_t l_978[6][9][4] = {{{0x5E6FB53AL,0x6433C65BL,1L,0L},{0L,0xB3F872D4L,(-1L),(-7L)},{(-1L),(-7L),0x85ECC07AL,0x85ECC07AL},{0x991B84D7L,0x991B84D7L,0x2027B05DL,0xDE9C0A38L},{(-1L),(-1L),0x24EAD01DL,0xA401D891L},{(-1L),0xDE9C0A38L,(-1L),0x24EAD01DL},{(-7L),0xDE9C0A38L,1L,0xA401D891L},{0xDE9C0A38L,(-1L),(-2L),0xDE9C0A38L},{0xD1DF0299L,0x991B84D7L,(-1L),0x85ECC07AL}},{{0L,(-7L),1L,(-7L)},{0x6433C65BL,0xB3F872D4L,0xD1DF0299L,0L},{(-1L),0x6433C65BL,(-1L),0x85ECC07AL},{0xA401D891L,(-1L),0x2027B05DL,0x5E6FB53AL},{0xA401D891L,(-1L),(-1L),0x991B84D7L},{(-1L),0x5E6FB53AL,0xD1DF0299L,0x24EAD01DL},{0x6433C65BL,0L,1L,(-1L)},{0L,(-1L),(-1L),0L},{0xD1DF0299L,0xA401D891L,(-2L),0x85ECC07AL}},{{0xDE9C0A38L,0L,1L,0x6433C65BL},{(-7L),0xB3F872D4L,(-1L),0x6433C65BL},{(-1L),0L,0x24EAD01DL,0x85ECC07AL},{(-1L),0xA401D891L,0x2027B05DL,0L},{0x991B84D7L,(-1L),0x85ECC07AL,(-1L)},{(-1L),0L,(-1L),0x24EAD01DL},{0L,0x5E6FB53AL,1L,0x991B84D7L},{0x5E6FB53AL,(-1L),0xB3F872D4L,0x5E6FB53AL},{0xD1DF0299L,(-1L),0xB3F872D4L,0x85ECC07AL}},{{0x5E6FB53AL,0x6433C65BL,1L,0L},{0L,0xB3F872D4L,(-1L),(-7L)},{(-1L),(-7L),0x85ECC07AL,0x85ECC07AL},{0x991B84D7L,0x991B84D7L,0x2027B05DL,0xDE9C0A38L},{(-1L),(-1L),0x24EAD01DL,0xA401D891L},{(-1L),0xDE9C0A38L,(-1L),0x24EAD01DL},{(-7L),0xDE9C0A38L,1L,0xA401D891L},{0xDE9C0A38L,(-1L),(-2L),0xDE9C0A38L},{0xD1DF0299L,0x991B84D7L,(-1L),0x85ECC07AL}},{{0L,(-7L),1L,(-7L)},{0x6433C65BL,0xB3F872D4L,0xD1DF0299L,0L},{(-1L),0x6433C65BL,(-1L),0x85ECC07AL},{(-1L),0xD1DF0299L,(-1L),0xB3F872D4L},{(-1L),1L,0x466683F9L,(-1L)},{(-1L),0xB3F872D4L,1L,0x5CDE1377L},{0x85ECC07AL,(-2L),0xA401D891L,0xD1DF0299L},{(-2L),1L,1L,(-2L)},{1L,(-1L),0x2027B05DL,0x86999B32L}},{{(-1L),0x24EAD01DL,0xA401D891L,0x85ECC07AL},{(-1L),1L,0L,0x85ECC07AL},{(-1L),0x24EAD01DL,0x5CDE1377L,0x86999B32L},{0xD1DF0299L,(-1L),(-1L),(-2L)},{(-1L),1L,0x86999B32L,0xD1DF0299L},{(-1L),(-2L),(-1L),0x5CDE1377L},{0x24EAD01DL,0xB3F872D4L,0xA401D891L,(-1L)},{0xB3F872D4L,1L,1L,0xB3F872D4L},{1L,0xD1DF0299L,1L,0x86999B32L}}};
        int32_t *l_977 = &l_978[0][0][2];
        struct S0 l_1001[2] = {{2,-5L,71,-3567},{2,-5L,71,-3567}};
        float ****l_1044 = (void*)0;
        float *****l_1043 = &l_1044;
        struct S1 ** const *l_1125 = (void*)0;
        struct S0 * const l_1161 = &l_1001[0];
        struct S0 *l_1162 = &l_1068[4].f0;
        struct S0 *l_1163 = &l_1001[0];
        int i, j, k;
        for (l_966 = 7; (l_966 >= 1); l_966 -= 1)
        { /* block id: 578 */
            int32_t *l_967 = &l_965[0];
            int32_t **l_968 = (void*)0;
            int32_t **l_969[7];
            uint8_t l_997[3];
            int i;
            for (i = 0; i < 7; i++)
                l_969[i] = &l_967;
            for (i = 0; i < 3; i++)
                l_997[i] = 254UL;
            l_970 = l_967;
            /* statement id: 579 */
            assert ((l_970 >= &l_965[0] && l_970 <= &l_965[6]));
            for (l_971 = 0; (l_971 <= 9); l_971 += 1)
            { /* block id: 582 */
                int32_t *l_972 = &l_971;
                int i;
                l_970 = &l_965[0];
                /* statement id: 583 */
                assert ((l_970 >= &l_965[0] && l_970 <= &l_965[6]));
                l_970 = l_972;
                /* statement id: 584 */
                assert (l_970 == &l_971);
                (**l_973) = (l_973 != l_976);
                if (l_964[l_965[0]])
                    continue;
            }
            /* facts after for loop */
            assert (l_970 == &l_971 || (l_970 >= &l_965[0] && l_970 <= &l_965[6]));
            if (l_966)
                continue;
            for (l_971 = 0; (l_971 <= 9); l_971 += 1)
            { /* block id: 591 */
                int32_t l_979[1][6] = {{0xAD72FF03L,0xAD72FF03L,0xAD72FF03L,0xAD72FF03L,0xAD72FF03L,0xAD72FF03L}};
                int32_t ***l_985[8][9] = {{&l_968,&l_969[1],&l_969[4],(void*)0,(void*)0,&l_969[4],&l_969[1],&l_968,&l_969[2]},{&l_969[1],&l_969[6],&l_984,&l_968,&l_984,&l_969[6],&l_969[6],(void*)0,(void*)0},{&l_969[4],&l_969[6],&l_969[6],&l_968,&l_969[6],&l_969[6],&l_969[4],&l_969[6],&l_969[2]},{&l_969[6],&l_969[4],&l_969[6],&l_969[1],(void*)0,&l_984,&l_968,&l_969[6],&l_968},{&l_984,&l_968,&l_969[4],&l_969[4],&l_968,&l_984,&l_969[2],&l_969[6],&l_969[4]},{&l_969[6],&l_984,&l_968,&l_984,&l_969[6],&l_969[6],(void*)0,(void*)0,&l_969[6]},{&l_969[4],&l_984,&l_969[4],&l_984,&l_969[4],&l_969[6],&l_969[2],&l_968,&l_969[1]},{&l_968,(void*)0,&l_969[6],(void*)0,&l_984,&l_969[4],&l_968,&l_969[4],&l_984}};
                int i, j;
                l_977 = &l_965[2];
                /* statement id: 592 */
                assert ((l_977 >= &l_965[0] && l_977 <= &l_965[6]));
                for (l_979[0][1] = 5; (l_979[0][1] >= 0); l_979[0][1] -= 1)
                { /* block id: 595 */
                    int32_t l_980 = 0x08722AFCL;
                    int32_t l_999 = 0x123BA6BCL;
                    int i;
                    for (l_980 = 2; (l_980 <= 6); l_980 += 1)
                    { /* block id: 598 */
                        int32_t l_986 = 0xCDFB45D7L;
                        int i;
                        if (l_979[0][1])
                            break;
                        if (l_971)
                            goto lbl_1234;
                        l_977 = &l_979[0][1];
                        /* statement id: 600 */
                        assert ((l_977 >= &l_979[0][0] && l_977 <= &l_979[0][5]));
                        l_999 = ((safe_mod_func_uint16_t_u_u((8L < ((l_983[2] != l_985[1][3]) <= ((l_986 || (safe_div_func_uint16_t_u_u(((((((*l_977) && ((((safe_add_func_int16_t_s_s((**l_984), ((safe_lshift_func_uint8_t_u_u((((255UL || (**l_984)) == ((((safe_mod_func_uint8_t_u_u((safe_div_func_uint64_t_u_u(5UL, 0x74401888D4BC82CBLL)), (*l_977))) == (*l_977)) >= l_997[1]) | l_998)) != 0L), l_980)) | 0x953CB3ACL))) == l_980) == l_980) >= (*l_977))) > (*l_977)) | (*l_967)) ^ (*l_967)) == l_980), (*l_970)))) >= l_986))), (*l_977))) >= (-9L));
                    }
                    if (l_980)
                        break;
                    if ((*l_977))
                        continue;
                }
                /* facts after for loop */
                assert ((l_977 >= &l_979[0][0] && l_977 <= &l_979[0][5]) || (l_977 >= &l_965[0] && l_977 <= &l_965[6]));
            }
        }
        /* facts after for loop */
        //assert (l_977 == dangling || (l_977 >= &l_965[0] && l_977 <= &l_965[6]) || (l_977 >= &l_978[0][0][0] && l_977 <= &l_978[5][8][3]));
    }
    /* facts after for loop */
    assert (l_970 == &l_971 || (l_970 >= &l_965[0] && l_970 <= &l_965[6]));
lbl_1234:
    for (l_971 = 0; (l_971 == (-8)); --l_971)
    { /* block id: 753 */
        struct S0 l_1170[9][1][7] = {{{{4,1L,79,-1309},{4,0x107BB928DF89BC44LL,63,1345},{0,-1L,12,3361},{0,0L,35,4008},{4,9L,45,-167},{3,-6L,107,811},{4,9L,45,-167}}},{{{1,0xE7ACE104D8877436LL,127,-3048},{4,0x4B4508339FE00777LL,92,1249},{4,0x4B4508339FE00777LL,92,1249},{1,0xE7ACE104D8877436LL,127,-3048},{4,1L,13,-3484},{2,8L,93,1104},{1,-7L,58,-773}}},{{{4,1L,79,-1309},{0,0L,35,4008},{1,1L,6,3236},{0,1L,36,-1675},{1,0x507E5A08D4E719D0LL,18,3023},{1,0x507E5A08D4E719D0LL,18,3023},{0,1L,36,-1675}}},{{{4,1L,15,-923},{4,0x7283AE6076625CAFLL,40,-1489},{4,1L,15,-923},{2,8L,93,1104},{4,0x04AF797949C1C2BFLL,0,-3232},{4,0x29438073D67142D0LL,105,2197},{1,-7L,58,-773}}},{{{3,-6L,107,811},{4,0xB1D139035003BD41LL,67,3897},{4,9L,45,-167},{1,1L,6,3236},{0,0L,11,-14},{1,1L,6,3236},{4,9L,45,-167}}},{{{4,0x04AF797949C1C2BFLL,0,-3232},{4,0x04AF797949C1C2BFLL,0,-3232},{4,1L,13,-3484},{4,4L,56,-1923},{2,0x39E92BF4A4A3A82BLL,4,758},{4,0x29438073D67142D0LL,105,2197},{4,0x7283AE6076625CAFLL,40,-1489}}},{{{1,4L,108,-1023},{0,-1L,12,3361},{1,0x507E5A08D4E719D0LL,18,3023},{4,0x107BB928DF89BC44LL,63,1345},{4,0x107BB928DF89BC44LL,63,1345},{1,0x507E5A08D4E719D0LL,18,3023},{0,-1L,12,3361}}},{{{4,0x4B4508339FE00777LL,92,1249},{2,0x39E92BF4A4A3A82BLL,4,758},{4,1L,13,-3484},{4,0x29438073D67142D0LL,105,2197},{3,0x94658C82FE4D4B27LL,13,3391},{3,-1L,125,-3199},{2,8L,93,1104}}},{{{0,1L,36,-1675},{1,4L,108,-1023},{4,1L,79,-1309},{1,1L,6,3236},{4,1L,79,-1309},{1,4L,108,-1023},{0,1L,36,-1675}}}};
        float ***l_1185 = &l_973;
        float ****l_1184 = &l_1185;
        const struct S1 *l_1186[8][2];
        const uint16_t l_1198 = 0x4104L;
        const int32_t *l_1199[8][7] = {{&l_965[2],&l_971,&l_965[2],&l_971,&l_965[0],&l_971,&l_965[2]},{&l_965[0],&l_965[0],&l_965[1],&l_965[0],&l_965[0],&l_965[1],&l_965[0]},{&l_965[0],&l_971,&l_965[2],&l_971,&l_965[2],&l_971,&l_965[0]},{&l_965[0],&l_965[0],&l_965[0],&l_965[0],&l_965[0],&l_965[0],&l_965[0]},{&l_965[0],&l_971,&l_965[0],&l_971,&l_965[0],&l_965[0],&l_965[0]},{&l_965[0],&l_965[0],&l_965[0],&l_965[0],&l_965[0],&l_965[0],&l_965[0]},{&l_965[2],&l_971,&l_965[2],&l_971,&l_965[0],&l_971,&l_965[2]},{&l_965[0],&l_965[0],&l_965[1],&l_965[0],&l_965[0],&l_965[1],&l_965[0]}};
        struct S0 **l_1217 = (void*)0;
        struct S0 *** const l_1216 = &l_1217;
        struct S0 *** const *l_1215 = &l_1216;
        struct S0 *** const **l_1214[10][10][2] = {{{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{(void*)0,&l_1215},{&l_1215,(void*)0},{(void*)0,&l_1215},{(void*)0,(void*)0},{&l_1215,&l_1215},{(void*)0,&l_1215},{(void*)0,&l_1215}},{{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215}},{{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,(void*)0},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215}},{{&l_1215,(void*)0},{(void*)0,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{(void*)0,(void*)0},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,(void*)0}},{{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215}},{{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{(void*)0,&l_1215},{&l_1215,(void*)0}},{{(void*)0,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,(void*)0},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215}},{{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,(void*)0},{&l_1215,&l_1215},{&l_1215,&l_1215}},{{&l_1215,&l_1215},{&l_1215,&l_1215},{(void*)0,&l_1215},{(void*)0,&l_1215},{(void*)0,&l_1215},{&l_1215,(void*)0},{&l_1215,(void*)0},{&l_1215,(void*)0},{&l_1215,(void*)0},{&l_1215,(void*)0}},{{&l_1215,(void*)0},{&l_1215,&l_1215},{(void*)0,&l_1215},{(void*)0,&l_1215},{(void*)0,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,&l_1215},{&l_1215,(void*)0},{(void*)0,&l_1215}}};
        int i, j, k;
        for (i = 0; i < 8; i++)
        {
            for (j = 0; j < 2; j++)
                l_1186[i][j] = &l_1068[4];
        }
    }
    (*l_1235) = &l_984;
    (*l_984) = l_1236;
    /* statement id: 818 */
    assert ((l_970 >= &l_965[0] && l_970 <= &l_965[6]));
    return p_19;
    /* statement id: 819 */
    //assert (func_16_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_20(struct S0  p_21)
{ /* block id: 467 */
    struct S0 l_704 = {3,0x55D4A9CED94427F6LL,74,-545};
    struct S0 *l_703 = &l_704;
    struct S0 * const *l_702 = &l_703;
    int32_t l_735 = 0xBC3169FBL;
    int32_t *l_734 = &l_735;
    int32_t **l_733 = &l_734;
    int32_t l_756 = 0xBBE1CDCFL;
    int16_t l_883 = 1L;
    struct S0 ** const l_926[1][5] = {{&l_703,&l_703,&l_703,&l_703,&l_703}};
    struct S1 * const l_934 = (void*)0;
    struct S1 l_936 = {{0,1L,53,2066},8,-3652,28,-450,1396,0x4FF0L,-0,4,-27};
    struct S1 *l_935 = &l_936;
    const struct S1 *l_950 = &l_936;
    struct S0 *l_961 = &l_936.f0;
    struct S0 *l_962 = &l_936.f0;
    struct S0 *l_963 = (void*)0;
    int i, j;
    for (p_21.f1 = 29; (p_21.f1 == (-6)); p_21.f1 = safe_sub_func_int8_t_s_s(p_21.f1, 3))
    { /* block id: 470 */
        int32_t l_692 = (-1L);
        int32_t *l_691 = &l_692;
        int32_t **l_690 = &l_691;
        int32_t ***l_689 = &l_690;
        int32_t ****l_688 = &l_689;
        const int32_t *l_739 = (void*)0;
        struct S0 *l_745[4][3] = {{&l_704,&l_704,(void*)0},{&l_704,(void*)0,(void*)0},{(void*)0,&l_704,&l_704},{&l_704,&l_704,&l_704}};
        struct S0 **l_750 = &l_703;
        struct S0 ***l_749 = &l_750;
        struct S0 ****l_748[7][4][2] = {{{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749}},{{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749}},{{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749}},{{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749}},{{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749}},{{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749}},{{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749},{&l_749,&l_749}}};
        const int8_t l_755[6][6] = {{0x76L,0xA7L,0xA7L,0x76L,0x8CL,0x48L},{0L,0x48L,(-7L),0xB2L,(-1L),0xB2L},{0x8CL,3L,0x8CL,0x50L,(-1L),(-5L)},{(-7L),0x48L,0L,0x8CL,0x8CL,0L},{0xA7L,0xA7L,0x76L,0x8CL,0x48L,0x50L},{(-7L),0x76L,(-5L),0x50L,(-5L),0x76L}};
        struct S1 l_784 = {{2,0L,96,1768},-10,626,59,-82,4980,0UL,-0,-4,-31};
        struct S1 *l_783 = &l_784;
        struct S1 **l_782[9][8] = {{&l_783,&l_783,&l_783,&l_783,&l_783,&l_783,(void*)0,&l_783},{(void*)0,(void*)0,&l_783,&l_783,&l_783,&l_783,&l_783,(void*)0},{&l_783,(void*)0,&l_783,&l_783,(void*)0,&l_783,&l_783,(void*)0},{(void*)0,&l_783,&l_783,&l_783,&l_783,&l_783,(void*)0,&l_783},{(void*)0,&l_783,&l_783,(void*)0,(void*)0,&l_783,(void*)0,(void*)0},{&l_783,(void*)0,&l_783,&l_783,(void*)0,&l_783,&l_783,&l_783},{(void*)0,&l_783,&l_783,&l_783,&l_783,&l_783,&l_783,&l_783},{&l_783,(void*)0,&l_783,&l_783,(void*)0,&l_783,(void*)0,&l_783},{&l_783,(void*)0,&l_783,&l_783,&l_783,&l_783,&l_783,(void*)0}};
        struct S1 *** const l_781 = &l_782[2][1];
        uint64_t l_884 = 0x892705AC96A8DED0LL;
        int16_t l_893 = 5L;
        int64_t l_903 = 1L;
        struct S0 *l_920 = (void*)0;
        float l_960 = (-0x1.6p-1);
        float *l_959 = &l_960;
        int i, j, k;
        (*l_688) = (void*)0;
        /* statement id: 471 */
        assert (l_689 == 0);
        for (l_692 = 23; (l_692 == 27); l_692++)
        { /* block id: 474 */
            struct S0 l_696 = {1,0L,42,-668};
            struct S0 *l_695 = &l_696;
            const int32_t *l_699[8];
            const int32_t * const **l_711 = (void*)0;
            uint64_t l_714 = 0xE780621DB0C38BC8LL;
            struct S0 ****l_747 = (void*)0;
            const uint16_t l_852 = 0x9038L;
            struct S1 **l_879[4];
            int32_t l_882 = 0x462F367CL;
            struct S0 *l_908 = &l_704;
            struct S0 *l_909 = &l_784.f0;
            struct S0 *l_914 = &l_696;
            struct S0 *l_916[2][2] = {{&l_784.f0,&l_784.f0},{&l_784.f0,&l_784.f0}};
            struct S0 *l_917 = &l_784.f0;
            uint16_t l_923 = 65535UL;
            float l_948 = 0x1.0p-1;
            float *l_947 = &l_948;
            float * const *l_946 = &l_947;
            int i, j;
            for (i = 0; i < 8; i++)
                l_699[i] = &l_692;
            for (i = 0; i < 4; i++)
                l_879[i] = &l_783;
            (*l_695) = p_21;
        }
        (*l_959) = ((safe_div_func_float_f_f((-0x9.2p+1), p_21.f1)) >= (safe_div_func_float_f_f((*l_734), p_21.f2)));
    }
    (*l_733) = (*l_733);
    return l_963;
    /* statement id: 571 */
    //assert (func_20_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_22(struct S0 * p_23, uint8_t  p_24, const uint8_t  p_25)
{ /* block id: 311 */
    int32_t l_511 = 0L;
    struct S0 l_523 = {3,0xF02EBDF4C10918B7LL,98,1626};
    uint8_t l_524[2];
    struct S1 l_550 = {{1,0xFA9952A2233D9DEDLL,7,-736},-19,10328,32,-20,723,0xDDAAL,-0,-0,30};
    struct S1 *l_549 = &l_550;
    float l_568[4][9] = {{(-0x2.6p+1),(-0x2.6p+1),0xF.D6B7D9p+22,0xC.1E359Fp+4,0x8.Fp-1,0xA.C84A35p+55,(-0x1.4p+1),0xA.C84A35p+55,0x8.Fp-1},{0xF.D6B7D9p+22,(-0x2.6p+1),(-0x2.6p+1),0xF.D6B7D9p+22,0xC.1E359Fp+4,0x8.Fp-1,0xA.C84A35p+55,(-0x1.4p+1),0xA.C84A35p+55},{(-0x1.4p+1),0x4.Ep-1,0xF.D6B7D9p+22,0xF.D6B7D9p+22,0x4.Ep-1,(-0x1.4p+1),(-0x1.Bp+1),(-0x2.6p+1),0xB.13F037p-67},{0x5.216889p+52,0x8.Fp-1,(-0x1.4p+1),0xC.1E359Fp+4,0xC.1E359Fp+4,(-0x1.4p+1),0x8.Fp-1,0x5.216889p+52,0x4.Ep-1}};
    float *l_567 = &l_568[2][6];
    float **l_566 = &l_567;
    float ***l_565 = &l_566;
    float ****l_564[8];
    float *****l_563 = &l_564[0];
    struct S0 *l_598 = &l_550.f0;
    struct S0 **l_597 = &l_598;
    struct S0 ***l_596 = &l_597;
    struct S0 l_644[1][4] = {{{3,1L,124,23},{3,1L,124,23},{3,1L,124,23},{3,1L,124,23}}};
    int32_t l_654[4][1] = {{0xB87971FDL},{0xC6D1C196L},{0xB87971FDL},{0xC6D1C196L}};
    int32_t l_684 = 0L;
    int32_t *l_683 = &l_684;
    struct S0 l_685 = {3,5L,8,1365};
    int i, j;
    for (i = 0; i < 2; i++)
        l_524[i] = 0UL;
    for (i = 0; i < 8; i++)
        l_564[i] = &l_565;
lbl_585:
    if (p_25)
    { /* block id: 312 */
        float *l_474 = (void*)0;
        float l_476 = (-0x1.9p-1);
        float *l_475 = &l_476;
        (*l_475) = p_25;
    }
    else
    { /* block id: 314 */
        uint64_t l_484 = 0x66BEFD690A078F3FLL;
        float l_498[8];
        const float *l_497 = &l_498[0];
        const float **l_496 = &l_497;
        const float ***l_495 = &l_496;
        int64_t l_499[4] = {(-10L),(-10L),(-10L),(-10L)};
        struct S0 l_503 = {3,0x8A6B2575C291767ALL,127,2787};
        struct S0 *l_502[1][6] = {{&l_503,&l_503,&l_503,&l_503,&l_503,&l_503}};
        struct S0 **l_501 = &l_502[0][1];
        struct S0 *** const l_500 = &l_501;
        struct S0 l_508 = {1,0L,72,-3252};
        int32_t l_520 = 0L;
        int i, j;
        for (i = 0; i < 8; i++)
            l_498[i] = 0xA.4D92C1p-27;
        for (p_24 = (-18); (p_24 == 52); p_24 = safe_add_func_uint16_t_u_u(p_24, 2))
        { /* block id: 317 */
            struct S0 l_479[2] = {{1,7L,37,-2233},{1,7L,37,-2233}};
            int32_t l_480[3];
            int32_t *l_521 = (void*)0;
            int32_t *l_522 = &l_520;
            int i;
            for (i = 0; i < 3; i++)
                l_480[i] = 0x9F6374DBL;
            for (l_480[0] = 0; (l_480[0] <= 1); l_480[0] += 1)
            { /* block id: 320 */
                int32_t l_481 = 0xB9DCE845L;
                float **l_494 = (void*)0;
                float ***l_493 = &l_494;
                for (l_481 = 0; (l_481 <= 1); l_481 += 1)
                { /* block id: 323 */
                    int32_t *l_483 = &l_481;
                    int32_t **l_482 = &l_483;
                    (*l_482) = &l_480[0];
                    /* statement id: 324 */
                    assert ((l_483 >= &l_480[0] && l_483 <= &l_480[2]));
                    l_499[0] = ((l_484 >= ((safe_sub_func_float_f_f(l_481, 0x1.7p-1)) <= ((safe_sub_func_float_f_f((safe_div_func_float_f_f(((l_484 >= p_24) == ((safe_add_func_float_f_f(0x5.BBF36Cp+6, ((l_493 != l_495) == p_25))) > p_24)), l_484)), (**l_482))) < p_25))) > p_25);
                    for (l_484 = 0; (l_484 <= 1); l_484 += 1)
                    { /* block id: 328 */
                        struct S0 ***l_505 = &l_501;
                        struct S0 ****l_504[5] = {&l_505,&l_505,&l_505,&l_505,&l_505};
                        struct S0 ****l_506[1][10] = {{&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505,&l_505}};
                        struct S0 ****l_507 = &l_505;
                        int i, j;
                        l_479[l_484] = l_479[l_484];
                        (*l_507) = l_500;
                        l_479[l_480[0]] = l_508;
                    }
                }
            }
            (*l_522) = (((l_503.f1 > (((safe_lshift_func_uint8_t_u_s(l_511, (((((safe_unary_minus_func_uint16_t_u(l_511)) >= (l_480[1] == (+l_480[0]))) && ((safe_sub_func_uint32_t_u_u(((((p_24 & (l_511 > p_24)) | (safe_sub_func_int32_t_s_s(2L, 4294967289UL))) <= l_511) > (-2L)), 0x7A8454A5L)) >= 0xC42EL)) ^ l_520) != 0x3BL))) == p_24) <= l_480[0])) && l_480[2]) && p_25);
            return l_523;
        }
    }
    for (p_24 = 0; (p_24 <= 1); p_24 += 1)
    { /* block id: 341 */
        struct S0 l_525 = {1,0xF02EA2263B3CED3FLL,46,936};
        return l_525;
    }
    if (p_24)
    { /* block id: 344 */
        uint32_t l_539 = 0x8267D7C4L;
        struct S0 * const l_542[1] = {(void*)0};
        float l_556 = 0xF.DE5882p+92;
        float *l_555[4] = {&l_556,&l_556,&l_556,&l_556};
        float ** const l_554 = &l_555[2];
        float **l_557 = (void*)0;
        float *****l_569 = &l_564[0];
        int32_t l_576 = 0x4809D645L;
        int32_t *l_575 = &l_576;
        int32_t **l_574[6] = {&l_575,&l_575,(void*)0,&l_575,&l_575,(void*)0};
        int32_t ***l_573[2][6][8] = {{{&l_574[0],&l_574[0],&l_574[0],&l_574[0],&l_574[0],&l_574[0],&l_574[0],&l_574[0]},{&l_574[4],&l_574[0],&l_574[4],&l_574[4],&l_574[0],&l_574[4],&l_574[4],&l_574[0]},{&l_574[0],&l_574[4],&l_574[4],&l_574[0],&l_574[4],&l_574[4],&l_574[0],&l_574[4]},{&l_574[0],&l_574[0],&l_574[0],&l_574[0],&l_574[0],&l_574[0],&l_574[0],&l_574[0]},{&l_574[4],&l_574[0],&l_574[4],&l_574[4],&l_574[4],&l_574[0],&l_574[0],&l_574[4]},{&l_574[4],&l_574[0],&l_574[0],&l_574[4],&l_574[0],&l_574[0],&l_574[4],&l_574[0]}},{{&l_574[4],&l_574[4],&l_574[0],&l_574[4],&l_574[4],&l_574[0],&l_574[4],&l_574[4]},{&l_574[0],&l_574[4],&l_574[0],&l_574[0],&l_574[4],&l_574[0],&l_574[0],&l_574[4]},{&l_574[4],&l_574[0],&l_574[0],&l_574[4],&l_574[0],&l_574[0],&l_574[4],&l_574[0]},{&l_574[4],&l_574[4],&l_574[0],&l_574[4],&l_574[4],&l_574[0],&l_574[4],&l_574[4]},{&l_574[0],&l_574[4],&l_574[0],&l_574[0],&l_574[4],&l_574[0],&l_574[0],&l_574[4]},{&l_574[4],&l_574[0],&l_574[0],&l_574[4],&l_574[0],&l_574[0],&l_574[4],&l_574[0]}}};
        int i, j, k;
        for (l_523.f1 = 0; (l_523.f1 <= 1); l_523.f1 += 1)
        { /* block id: 347 */
            const float *l_528 = (void*)0;
            const float ** const l_527 = &l_528;
            const float ** const * const l_526 = &l_527;
            int32_t *l_532 = (void*)0;
            int32_t *l_533 = (void*)0;
            int32_t l_535 = 0xC660428EL;
            int32_t *l_534 = &l_535;
            int i;
            for (l_511 = 1; (l_511 >= 0); l_511 -= 1)
            { /* block id: 350 */
                float **l_531 = (void*)0;
                float ***l_530 = &l_531;
                float ****l_529 = &l_530;
                (*l_529) = l_526;
                /* statement id: 351 */
                assert (l_530 == &l_527);
            }
            (*l_534) = l_524[l_523.f1];
        }
        l_523 = l_523;
        for (l_539 = 29; (l_539 <= 5); l_539--)
        { /* block id: 358 */
            struct S0 l_562 = {0,0x07D44712E1480AFCLL,9,181};
            for (l_511 = 0; (l_511 < (-27)); l_511 = safe_sub_func_uint16_t_u_u(l_511, 6))
            { /* block id: 361 */
                struct S0 l_553 = {0,-1L,102,-1861};
                int32_t l_559 = 0xE924FB46L;
                int32_t *l_558 = &l_559;
                for (l_523.f1 = 4; (l_523.f1 > 23); l_523.f1 = safe_add_func_uint16_t_u_u(l_523.f1, 5))
                { /* block id: 364 */
                    struct S1 **l_551 = &l_549;
                    const struct S0 l_552 = {3,0xB07EB745F4A5F867LL,120,3669};
                    (*l_551) = l_549;
                    l_553 = l_552;
                    l_557 = l_554;
                    /* statement id: 367 */
                    assert ((l_557 >= &l_555[0] && l_557 <= &l_555[3]));
                }
                (*l_558) = 0x5E670D3CL;
            }
            for (l_523.f1 = (-16); (l_523.f1 > (-2)); l_523.f1 = safe_add_func_int16_t_s_s(l_523.f1, 6))
            { /* block id: 373 */
                return l_562;
            }
            l_569 = l_563;
            if (p_25)
                break;
        }
        /* facts after for loop */
        assert ((l_557 >= &l_555[0] && l_557 <= &l_555[3]) || l_557 == 0);
        if (((***l_569) == (void*)0))
        { /* block id: 379 */
            int32_t l_572[3];
            int32_t *l_571 = &l_572[1];
            int32_t **l_570 = &l_571;
            int32_t ****l_577 = &l_573[1][3][1];
            struct S0 l_586 = {0,0x6694D432449769F1LL,54,1303};
            float ****l_593[5] = {&l_565,&l_565,&l_565,&l_565,&l_565};
            int i;
            for (i = 0; i < 3; i++)
                l_572[i] = 1L;
            (*l_570) = l_567;
            /* statement id: 380 */
            assert ((l_571 >= &l_568[0][0] && l_571 <= &l_568[3][8]));
            (*l_577) = l_573[1][3][1];
            for (l_523.f1 = 0; (l_523.f1 >= (-23)); l_523.f1 = safe_sub_func_int8_t_s_s(l_523.f1, 4))
            { /* block id: 384 */
                int32_t *l_584 = &l_576;
                struct S0 l_587 = {3,0x5FDB95095C499B9BLL,67,-2841};
                for (l_539 = 23; (l_539 != 23); l_539 = safe_add_func_uint16_t_u_u(l_539, 6))
                { /* block id: 387 */
                    for (l_576 = 0; (l_576 < 12); l_576 = safe_add_func_int8_t_s_s(l_576, 5))
                    { /* block id: 390 */
                        l_584 = l_584;
                        if (p_25)
                            continue;
                    }
                    if (l_523.f0)
                        goto lbl_585;
                }
                l_587 = l_586;
            }
        }
        else
        { /* block id: 416 */
            int32_t l_601 = 0xDE50F10CL;
            struct S0 l_621 = {1,-7L,42,-3185};
            for (l_576 = 1; (l_576 >= 0); l_576 -= 1)
            { /* block id: 419 */
                float **l_620[7];
                int i;
                for (i = 0; i < 7; i++)
                    l_620[i] = &l_567;
                l_601 = ((((safe_rshift_func_int16_t_s_u((0x0C90F4476BFC4CF9LL < (l_524[l_576] > (1L != (l_596 == &l_597)))), (p_25 <= (&l_549 == &l_549)))) > l_550.f5) && 4294967292UL) ^ p_25);
                for (p_24 = 0; (p_24 <= 1); p_24 += 1)
                { /* block id: 423 */
                    int32_t *l_602 = &l_601;
                    int i;
                    l_602 = l_555[(p_24 + 1)];
                    /* statement id: 424 */
                    assert (l_602 == &l_556);
                    (**l_566) = ((safe_div_func_float_f_f(((p_25 == (safe_sub_func_float_f_f(l_601, (((safe_div_func_float_f_f(((safe_div_func_float_f_f(((!(safe_add_func_float_f_f((*l_602), ((safe_div_func_float_f_f(p_25, l_601)) >= (safe_div_func_float_f_f((p_24 >= (safe_div_func_float_f_f((-0x1.2p-1), (-0x5.Cp-1)))), (l_620[6] != (void*)0))))))) < p_24), (-0x1.7p-1))) != (*l_602)), 0xF.79115Fp-7)) < l_601) <= l_601)))) == 0x6.DBE569p-36), 0xA.599BFFp-6)) == 0x6.F2B9ADp+65);
                }
            }
            return l_621;
        }
    }
    else
    { /* block id: 430 */
        float l_626 = (-0x4.4p-1);
        int32_t l_642 = 0x00A0FCB6L;
        struct S0 *l_643 = &l_550.f0;
        struct S1 **l_658 = (void*)0;
        struct S0 ***l_664 = &l_597;
        const float *l_667 = (void*)0;
        const float **l_666 = &l_667;
        l_550.f7 = (safe_lshift_func_uint8_t_u_s((safe_lshift_func_int8_t_s_u(((void*)0 == &l_597), 3)), p_24));
        if (p_25)
            goto lbl_585;
        for (l_511 = 0; (l_511 <= 3); l_511 += 1)
        { /* block id: 435 */
            int32_t l_628 = 0x30651D0CL;
            int32_t *l_627 = &l_628;
            int32_t **l_629 = &l_627;
            const int32_t ****l_630[6];
            struct S0 *** const *l_634 = &l_596;
            float **l_646 = &l_567;
            int32_t *l_655 = &l_628;
            float *** const *l_663 = &l_565;
            int i;
            for (i = 0; i < 6; i++)
                l_630[i] = (void*)0;
            (*l_629) = l_627;
            for (l_523.f1 = 7; (l_523.f1 >= 1); l_523.f1 -= 1)
            { /* block id: 439 */
                struct S0 ****l_633[8] = {&l_596,&l_596,&l_596,&l_596,&l_596,&l_596,&l_596,&l_596};
                int32_t l_641 = 0xC612C24DL;
                float **l_645 = &l_567;
                uint32_t l_653 = 4294967295UL;
                int i;
            }
        }
    }
    return l_685;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_26(int64_t  p_27)
{ /* block id: 6 */
    struct S0 l_44 = {0,0x7C3167647CF2842CLL,37,-1866};
    struct S0 *l_43 = &l_44;
    int32_t l_383 = 0xF9CEBAA6L;
    for (p_27 = 0; (p_27 == 17); ++p_27)
    { /* block id: 9 */
        int32_t l_34 = 3L;
        struct S0 l_380 = {4,-1L,102,3864};
        struct S0 *l_379 = &l_380;
        struct S1 l_382 = {{0,0L,40,-222},-8,6153,89,-358,3305,65534UL,0,2,24};
        struct S1 *l_381 = &l_382;
        (*l_379) = func_30(l_34, func_35(func_39(p_27, l_43, l_34), l_379, (((((((l_381 != (void*)0) && l_382.f0.f0) > 0x0330L) < l_383) > l_383) > l_380.f3) != p_27)), l_43);
    }
    return l_383;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_30(uint32_t  p_31, struct S0 * const  p_32, struct S0 * p_33)
{ /* block id: 253 */
    int8_t l_405 = 0xB7L;
    float ***l_406 = (void*)0;
    uint8_t l_407 = 0UL;
    struct S0 l_408[10] = {{0,-1L,99,233},{0,0x98998222518352B9LL,37,-663},{0,-1L,99,233},{0,0x98998222518352B9LL,37,-663},{0,-1L,99,233},{0,0x98998222518352B9LL,37,-663},{0,-1L,99,233},{0,0x98998222518352B9LL,37,-663},{0,-1L,99,233},{0,0x98998222518352B9LL,37,-663}};
    int32_t l_413 = 1L;
    int32_t *l_412 = &l_413;
    int32_t **l_414 = &l_412;
    struct S1 l_441 = {{4,0x3A341F3C436CD701LL,49,-1746},-8,-1476,38,-404,4081,65532UL,-0,-0,-18};
    struct S1 *l_440 = &l_441;
    int8_t l_471 = 1L;
    int i;
    if ((((p_31 ^ 0xFCL) <= (safe_add_func_uint8_t_u_u((((-8L) != (safe_add_func_uint16_t_u_u((safe_add_func_uint8_t_u_u((safe_add_func_int32_t_s_s((safe_sub_func_int16_t_s_s((((p_31 || 0xC615AB4ACBCA5A9FLL) || 248UL) & l_405), l_405)), ((l_406 != l_406) ^ p_31))), 0x14L)), 0UL))) != l_405), p_31))) && l_407))
    { /* block id: 254 */
        return l_408[2];
    }
    else
    { /* block id: 256 */
        int32_t l_411 = (-9L);
        int32_t *l_410 = &l_411;
        int32_t **l_409 = &l_410;
        (*l_409) = (void*)0;
        /* statement id: 257 */
        assert (l_410 == 0);
    }
    (*l_414) = l_412;
    if ((**l_414))
    { /* block id: 260 */
        return l_408[8];
    }
    else
    { /* block id: 262 */
        uint8_t l_417 = 0xEFL;
        float l_419 = 0x3.6DE2AFp-60;
        float *l_418[2][9] = {{&l_419,&l_419,&l_419,&l_419,&l_419,&l_419,&l_419,&l_419,&l_419},{&l_419,&l_419,&l_419,&l_419,&l_419,&l_419,&l_419,&l_419,&l_419}};
        struct S0 l_424 = {1,0xEF01581CB3595651LL,97,-704};
        int32_t **l_442 = (void*)0;
        int i, j;
        (*p_33) = l_408[8];
        (**l_414) = ((safe_add_func_float_f_f(p_31, 0x1.3p-1)) < l_417);
        for (l_405 = 15; (l_405 == (-18)); l_405 = safe_sub_func_int16_t_s_s(l_405, 2))
        { /* block id: 267 */
            int32_t l_427 = 1L;
            struct S1 l_438 = {{1,0x03A4CB792CD1A2B1LL,98,495},7,1642,36,-150,4461,0x0859L,-0,-2,-7};
            struct S1 *l_437 = &l_438;
            struct S1 **l_439[8];
            int i;
            for (i = 0; i < 8; i++)
                l_439[i] = &l_437;
            for (l_407 = 0; (l_407 <= 29); l_407 = safe_add_func_uint64_t_u_u(l_407, 5))
            { /* block id: 270 */
                if (p_31)
                    break;
                (*p_32) = l_424;
                if (p_31)
                    continue;
            }
            for (l_407 = 0; (l_407 <= 1); l_407 += 1)
            { /* block id: 277 */
                int32_t l_434[8] = {0x467A1F8DL,0x467A1F8DL,0x467A1F8DL,0x467A1F8DL,0x467A1F8DL,0x467A1F8DL,0x467A1F8DL,0x467A1F8DL};
                int i;
            }
            l_440 = l_437;
            /* statement id: 284 */
            assert (l_440 == &l_438);
            for (l_441.f0.f1 = 0; (l_441.f0.f1 <= 9); l_441.f0.f1 += 1)
            { /* block id: 287 */
                struct S0 *l_444 = &l_408[2];
                struct S0 **l_443 = &l_444;
                (*l_412) = ((void*)0 == l_442);
                (*l_443) = (void*)0;
                /* statement id: 289 */
                assert (l_444 == 0);
            }
        }
        /* facts after for loop */
        //assert (l_440 == dangling || l_440 == &l_441);
        for (l_424.f1 = (-7); (l_424.f1 == (-27)); l_424.f1 = safe_sub_func_int64_t_s_s(l_424.f1, 1))
        { /* block id: 294 */
            uint32_t l_459 = 0x1BD1B441L;
            for (l_417 = 0; (l_417 <= 16); l_417++)
            { /* block id: 297 */
                int16_t l_455 = 0x50FAL;
                float **l_456 = &l_418[0][1];
                (*l_412) = (safe_mod_func_int32_t_s_s(p_31, ((safe_add_func_uint8_t_u_u(0xCBL, ((safe_rshift_func_uint8_t_u_s((**l_414), l_455)) == ((-2L) != (l_456 == (void*)0))))) | (p_31 <= (((safe_mod_func_uint64_t_u_u((p_32 == &l_424), p_31)) | p_31) < l_459)))));
            }
        }
    }
    /* facts after branching */
    //assert (l_440 == dangling || l_440 == &l_441);
    for (l_413 = 9; (l_413 >= 1); l_413 -= 1)
    { /* block id: 304 */
        uint64_t l_460[1][6];
        int32_t l_473 = 0x38B8B6F6L;
        int32_t *l_472 = &l_473;
        int i, j;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 6; j++)
                l_460[i][j] = 0UL;
        }
        (*l_472) = (((l_460[0][1] >= (((((safe_unary_minus_func_int32_t_s(((safe_sub_func_int8_t_s_s(((p_31 == 0x7C5DAA343B23D90ELL) == (p_31 > (((p_31 & p_31) < (!0x98B6L)) ^ (safe_add_func_int8_t_s_s((safe_lshift_func_int16_t_s_u(((p_31 | ((l_471 == l_460[0][1]) != l_460[0][1])) <= (**l_414)), 12)), p_31))))), 0x2AL)) & l_460[0][4]))) & p_31) < 9L) == p_31) <= p_31)) < (**l_414)) & p_31);
    }
    return l_408[8];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * const  func_35(struct S0 * p_36, struct S0 * p_37, int32_t  p_38)
{ /* block id: 244 */
    int32_t l_385 = 0L;
    int32_t *l_384 = &l_385;
    int32_t **l_386 = &l_384;
    (*l_386) = l_384;
    for (l_385 = 0; (l_385 >= 18); l_385++)
    { /* block id: 248 */
        const int32_t *l_390 = (void*)0;
        float l_392[10] = {0x5.3p-1,0x1.Dp-1,0x1.Dp-1,0x5.3p-1,0x1.Dp-1,0x1.Dp-1,0x5.3p-1,0x1.Dp-1,0x1.Dp-1,0x5.3p-1};
        float *l_391 = &l_392[2];
        int32_t l_393 = (-5L);
        int32_t *l_394 = &l_393;
        int i;
        (*l_391) = ((!((void*)0 == l_390)) < ((void*)0 == p_37));
        (*l_394) = l_393;
    }
    return p_37;
    /* statement id: 252 */
    //assert (func_35_rv == &l_380 || (func_35_rv >= &l_760[0] && func_35_rv <= &l_760[1]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_39(uint64_t  p_40, struct S0 * p_41, int16_t  p_42)
{ /* block id: 10 */
    uint64_t l_49 = 0x71D1BA0576189EFALL;
    int32_t l_163 = (-9L);
    int32_t *l_162 = &l_163;
    struct S0 l_188 = {2,0x42FEC1ED602CC8EELL,77,1413};
    struct S1 l_226 = {{1,0x9FA13DB782676FA9LL,72,2764},9,-10667,38,179,2283,0x5C6AL,-0,3,-6};
    struct S1 *l_225 = &l_226;
    struct S1 * const *l_224[9] = {&l_225,(void*)0,&l_225,&l_225,(void*)0,&l_225,&l_225,(void*)0,&l_225};
    float **l_255 = (void*)0;
    float ***l_254 = &l_255;
    int32_t *l_271[6];
    const int32_t *l_273[8][9] = {{&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163},{&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163},{&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163},{&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163},{&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163},{&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163},{&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163},{&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163}};
    int i, j;
    for (i = 0; i < 6; i++)
        l_271[i] = (void*)0;
    for (p_40 = 0; (p_40 > 37); p_40 = safe_add_func_int8_t_s_s(p_40, 1))
    { /* block id: 13 */
        int8_t l_50 = 0x4AL;
        int32_t l_136 = 0xC4AF5C04L;
        int32_t **l_165[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
        struct S1 *l_187 = (void*)0;
        struct S1 **l_186 = &l_187;
        int i;
        if ((0UL && (((p_42 ^ (((0x5A1B5826CCE71C9ELL || (safe_sub_func_uint64_t_u_u((l_49 <= l_50), p_40))) >= (safe_add_func_uint8_t_u_u(((l_49 && (safe_sub_func_int16_t_s_s((((l_50 < (safe_lshift_func_uint8_t_u_u(((((void*)0 == p_41) >= p_42) && 0x0C94L), p_40))) < 65535UL) == p_40), l_50))) ^ p_40), l_50))) | l_50)) | l_50) < p_42)))
        { /* block id: 14 */
            uint16_t l_60 = 0xB8B7L;
            float l_119 = 0x1.6p-1;
            uint64_t l_161[4][10] = {{9UL,1UL,2UL,1UL,9UL,0x0F8655CF958245BBLL,0x8CA683B8F37F1D82LL,0x025DD51201156ABELL,18446744073709551612UL,0x132D04EE4DB16BE7LL},{0x8CA683B8F37F1D82LL,18446744073709551613UL,0x132D04EE4DB16BE7LL,0x0F8655CF958245BBLL,0xF37CF8FE10705393LL,8UL,8UL,0xF37CF8FE10705393LL,0x0F8655CF958245BBLL,0x132D04EE4DB16BE7LL},{0x0F8655CF958245BBLL,0x0F8655CF958245BBLL,2UL,0x132D04EE4DB16BE7LL,9UL,0xE99574A338B79B9ALL,0xF37CF8FE10705393LL,2UL,0x7B0D86458D21332ALL,18446744073709551615UL},{2UL,0xDF0F64EF15C959C0LL,0xF37CF8FE10705393LL,18446744073709551612UL,1UL,18446744073709551612UL,0xF37CF8FE10705393LL,0xDF0F64EF15C959C0LL,2UL,0x0F8655CF958245BBLL}};
            int32_t *l_167 = &l_163;
            int i, j;
            if (((safe_sub_func_uint8_t_u_u((!(p_41 != p_41)), l_49)) <= (0x45BDL < l_60)))
            { /* block id: 15 */
                struct S0 l_69 = {0,0xD6BBB2392579B7B7LL,58,-3748};
                struct S0 *l_68 = &l_69;
                int32_t l_93 = 0x4EF3EF0BL;
                int32_t *l_92 = &l_93;
                for (p_42 = 0; (p_42 < 24); p_42 = safe_add_func_uint16_t_u_u(p_42, 6))
                { /* block id: 18 */
                    struct S0 l_81 = {3,2L,59,106};
                    if ((~(safe_mod_func_int64_t_s_s((safe_add_func_int64_t_s_s(0xE2BB11FE8BE9C2C5LL, ((p_42 | (((((l_68 == p_41) > l_60) < p_42) >= ((safe_lshift_func_uint8_t_u_s(((safe_rshift_func_int8_t_s_u(0xFDL, 3)) ^ (safe_add_func_uint8_t_u_u((((((p_40 <= (safe_div_func_uint32_t_u_u((0x1CL > p_40), p_40))) & 3L) && 0xD792L) < 4294967295UL) & l_50), 246UL))), l_49)) && 7L)) | l_60)) || p_42))), p_42))))
                    { /* block id: 19 */
                        int32_t l_80 = 0L;
                        int32_t *l_79[3][1][8] = {{{&l_80,&l_80,&l_80,&l_80,&l_80,&l_80,&l_80,&l_80}},{{&l_80,&l_80,&l_80,&l_80,&l_80,&l_80,&l_80,&l_80}},{{&l_80,&l_80,&l_80,&l_80,&l_80,&l_80,&l_80,&l_80}}};
                        int32_t **l_78 = &l_79[0][0][5];
                        float *l_103 = (void*)0;
                        float l_105 = (-0x6.4p-1);
                        float *l_104 = &l_105;
                        int i, j, k;
                        (*l_78) = (void*)0;
                        /* statement id: 20 */
                        //assert (l_79[0][0][0] == 0 || l_79[0][0][0] == &l_80);
                        (*p_41) = l_81;
                        (*l_104) = (safe_div_func_float_f_f((safe_div_func_float_f_f((p_42 != p_42), 0x4.2p+1)), (safe_div_func_float_f_f((safe_div_func_float_f_f((((((((safe_add_func_float_f_f(((void*)0 != l_92), l_49)) == ((safe_div_func_float_f_f(((safe_sub_func_float_f_f((((!(((0x7.5310EEp-74 <= l_60) <= (safe_sub_func_float_f_f((safe_add_func_float_f_f((0xC.986B1Ep+0 != p_40), p_42)), 0x7.1p-1))) < l_50)) <= p_40) != l_49), l_60)) > 0x2.DDBBE0p+65), l_49)) > 0xA.A7570Bp+10)) >= p_40) <= l_81.f3) != l_49) <= p_40) >= l_81.f0), l_60)), p_40))));
                    }
                    else
                    { /* block id: 23 */
                        return p_41;
                        /* statement id: 24 */
                        //assert (func_39_rv == &l_44 || func_39_rv == &l_550.f0 || func_39_rv == &l_704 || (func_39_rv >= &l_760[0] && func_39_rv <= &l_760[1]));
                    }
                }
            }
            else
            { /* block id: 27 */
                uint8_t l_120 = 0xB4L;
                for (l_60 = 0; (l_60 != 24); l_60 = safe_add_func_int64_t_s_s(l_60, 6))
                { /* block id: 30 */
                    int64_t l_118[10][1] = {{0x2F16C98A27618441LL},{0x6C92F557AD609A04LL},{0x2F16C98A27618441LL},{0x6C92F557AD609A04LL},{0x2F16C98A27618441LL},{0x6C92F557AD609A04LL},{0x2F16C98A27618441LL},{0x6C92F557AD609A04LL},{0x2F16C98A27618441LL},{0x6C92F557AD609A04LL}};
                    float *l_121 = &l_119;
                    int16_t l_132 = 0L;
                    int32_t *l_137 = &l_136;
                    int i, j;
                    (*l_121) = ((safe_div_func_float_f_f((((0xB.192873p-93 < ((safe_add_func_float_f_f(0xF.C15673p+13, ((safe_div_func_float_f_f(p_42, (p_42 <= (((((((-0x9.3p+1) >= 0x6.5p-1) != (safe_div_func_float_f_f((safe_add_func_float_f_f((p_42 < l_118[2][0]), (p_40 == p_40))), 0x5.8A08A7p-94))) >= (-0x9.7p+1)) < 0x1.3p+1) <= p_40) < l_49)))) < l_50))) != l_49)) != l_119) >= l_120), l_50)) <= 0x4.FA5157p-9);
                    (*l_121) = ((((((p_40 != (+(p_42 == 0x2.F28764p+49))) >= (((0x2.A8B53Ep+21 >= ((0x3.4D0585p+3 <= 0x0.Ep+1) <= (!(-(((void*)0 == p_41) != (0x2.F7C879p+31 >= p_42)))))) >= l_49) <= (-0x2.0p-1))) <= p_42) != 0x1.Dp-1) > l_50) < l_120);
                    (*l_137) = (safe_rshift_func_uint16_t_u_u(l_118[3][0], (+(safe_sub_func_uint8_t_u_u(((safe_add_func_uint8_t_u_u(p_40, l_49)) == (((0x3F75E0FD2558CD6ALL & l_132) || ((safe_unary_minus_func_int8_t_s((safe_lshift_func_uint8_t_u_s(((0x4E2FL < 0L) <= (l_132 ^ l_120)), l_50)))) && p_40)) <= p_40)), l_136)))));
                }
                for (l_120 = 0; (l_120 >= 13); l_120 = safe_add_func_uint64_t_u_u(l_120, 1))
                { /* block id: 37 */
                    const int16_t l_148 = 5L;
                    int32_t l_155 = 4L;
                    for (l_60 = 0; (l_60 != 31); l_60 = safe_add_func_int16_t_s_s(l_60, 1))
                    { /* block id: 40 */
                        uint32_t l_151[7][7] = {{0x34C43CD8L,0xC4F2F6EFL,0x34C43CD8L,0x34C43CD8L,0xC4F2F6EFL,0x34C43CD8L,0x34C43CD8L},{0x531F22FFL,0x531F22FFL,0x3B096275L,0x531F22FFL,0x531F22FFL,0x3B096275L,0x531F22FFL},{0xC4F2F6EFL,0x34C43CD8L,0x34C43CD8L,0xC4F2F6EFL,0x34C43CD8L,0x34C43CD8L,0xC4F2F6EFL},{0x91ADE1D7L,0x531F22FFL,0x91ADE1D7L,0x91ADE1D7L,0x531F22FFL,0x91ADE1D7L,0x91ADE1D7L},{0xC4F2F6EFL,0xC4F2F6EFL,0UL,0xC4F2F6EFL,0xC4F2F6EFL,0UL,0xC4F2F6EFL},{0x531F22FFL,0x91ADE1D7L,0x91ADE1D7L,0x531F22FFL,0x91ADE1D7L,0x91ADE1D7L,0x531F22FFL},{0x34C43CD8L,0xC4F2F6EFL,0x34C43CD8L,0x34C43CD8L,0xC4F2F6EFL,0x34C43CD8L,0x34C43CD8L}};
                        float *l_154[5][7][5] = {{{(void*)0,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,(void*)0,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119}},{{&l_119,(void*)0,&l_119,&l_119,&l_119},{(void*)0,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{(void*)0,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,(void*)0,&l_119}},{{&l_119,(void*)0,&l_119,&l_119,(void*)0},{&l_119,&l_119,&l_119,&l_119,(void*)0},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119}},{{(void*)0,&l_119,&l_119,&l_119,(void*)0},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,(void*)0},{&l_119,(void*)0,&l_119,(void*)0,&l_119},{(void*)0,&l_119,(void*)0,&l_119,&l_119},{&l_119,&l_119,(void*)0,&l_119,&l_119},{&l_119,&l_119,(void*)0,&l_119,&l_119}},{{&l_119,&l_119,&l_119,(void*)0,&l_119},{&l_119,&l_119,&l_119,(void*)0,(void*)0},{&l_119,&l_119,(void*)0,&l_119,&l_119},{&l_119,&l_119,&l_119,(void*)0,(void*)0},{&l_119,&l_119,&l_119,(void*)0,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119},{&l_119,&l_119,&l_119,&l_119,&l_119}}};
                        int i, j, k;
                        l_155 = (safe_add_func_float_f_f((0x1.4p-1 <= ((l_49 == ((((safe_sub_func_float_f_f(l_49, ((safe_div_func_float_f_f(p_42, l_148)) > l_148))) >= (l_148 >= ((safe_sub_func_float_f_f(l_151[3][2], (((safe_sub_func_float_f_f(0x7.4A0B4Bp+20, l_151[3][2])) <= (-0x1.4p-1)) == l_50))) != p_42))) < l_151[3][2]) == l_120)) > l_120)), p_40));
                    }
                    for (p_42 = 0; (p_42 == 15); p_42 = safe_add_func_uint8_t_u_u(p_42, 6))
                    { /* block id: 45 */
                        struct S0 l_160 = {1,1L,49,-1457};
                        struct S0 *l_159 = &l_160;
                        struct S0 **l_158 = &l_159;
                        (*l_158) = (void*)0;
                        /* statement id: 46 */
                        assert (l_159 == 0);
                    }
                }
            }
            for (l_136 = 3; (l_136 >= 0); l_136 -= 1)
            { /* block id: 52 */
                int32_t **l_166 = &l_162;
                float *l_179 = (void*)0;
                float *l_180 = (void*)0;
                float *l_181 = &l_119;
                int i, j;
                for (l_50 = 3; (l_50 >= 0); l_50 -= 1)
                { /* block id: 55 */
                    int32_t **l_164 = &l_162;
                    (*l_164) = l_162;
                    for (l_60 = 0; (l_60 <= 3); l_60 += 1)
                    { /* block id: 59 */
                        (**l_164) = (l_165[0] == l_166);
                    }
                    for (p_42 = 0; (p_42 <= 3); p_42 += 1)
                    { /* block id: 64 */
                        (*l_164) = l_167;
                    }
                }
                (*l_181) = ((((safe_div_func_float_f_f((l_161[l_136][(l_136 + 5)] < (safe_sub_func_float_f_f((((p_40 != (((*l_167) >= (-(-0x4.Fp+1))) < (safe_add_func_float_f_f(0xC.755C12p+69, p_42)))) < (safe_div_func_float_f_f((safe_sub_func_float_f_f(p_40, (((p_42 > p_40) <= p_40) == p_42))), p_40))) > (*l_162)), p_40))), p_42)) <= 0x8.FEA722p+69) > p_42) > (**l_166));
            }
            l_167 = (void*)0;
            /* statement id: 70 */
            assert (l_167 == 0);
        }
        else
        { /* block id: 71 */
            int32_t l_182 = 0xBACE08CDL;
            if (l_182)
                break;
            if (p_42)
                break;
            (*l_162) = 0x475D44B9L;
        }
        for (l_49 = 7; (l_49 != 7); l_49 = safe_add_func_uint16_t_u_u(l_49, 3))
        { /* block id: 78 */
            const int8_t l_185[2] = {0x53L,0x53L};
            int i;
            (*l_162) = (l_185[0] | l_185[0]);
        }
        (*l_186) = (void*)0;
    }
    (*p_41) = l_188;
    if ((safe_sub_func_int8_t_s_s((((((safe_add_func_uint16_t_u_u(((safe_lshift_func_int8_t_s_u((((safe_rshift_func_int16_t_s_u(((safe_rshift_func_uint8_t_u_u((((0x9C605374L && p_40) > p_40) < ((p_40 < (*l_162)) > ((((*l_162) == ((0x95CEBA1A22EDFD8ELL || ((*l_162) && 6L)) | 18446744073709551615UL)) < 3L) == 0L))), 4)) == (*l_162)), 1)) <= (*l_162)) != (-6L)), 4)) <= 7UL), (*l_162))) > p_40) ^ (*l_162)) == p_40) && 0L), 0UL)))
    { /* block id: 84 */
        int32_t *l_203 = &l_163;
        float *l_216 = (void*)0;
        float l_218 = 0x3.CC439Ep+89;
        float *l_217 = &l_218;
        struct S0 *l_247 = &l_188;
        struct S1 *l_297 = (void*)0;
        int16_t l_301 = 0x5253L;
        struct S0 **l_324 = &l_247;
        if ((*l_162))
        { /* block id: 85 */
            l_203 = l_203;
            (*l_203) = p_42;
        }
        else
        { /* block id: 88 */
            int32_t *l_204 = &l_163;
            l_203 = l_204;
        }
        (*l_217) = (safe_sub_func_float_f_f(((safe_add_func_float_f_f((-0x1.3p+1), (safe_add_func_float_f_f(0x7.3p+1, ((safe_sub_func_float_f_f((p_40 >= p_42), (+0x1.Ap-1))) == (*l_162)))))) <= 0x1.4p-1), (0x3.4C83CDp-90 == (safe_div_func_float_f_f(((l_203 != (void*)0) > 0xE.4A1A27p-60), 0xB.9B034Dp+21)))));
        if ((((+0xB863AF97BA1A1ADFLL) ^ ((*l_203) & (((*l_203) || p_42) && ((p_42 & ((*l_162) != ((safe_mod_func_int8_t_s_s(p_40, (((*l_162) <= ((safe_add_func_int16_t_s_s(((((void*)0 != l_224[0]) <= p_42) == 0xDF4B60E2L), 7UL)) && (*l_203))) && p_40))) > p_42))) == (*l_162))))) || 1UL))
        { /* block id: 92 */
            (*l_203) = p_40;
        }
        else
        { /* block id: 94 */
            int32_t *l_236 = (void*)0;
            struct S0 *l_245 = (void*)0;
            struct S0 **l_244 = &l_245;
            int32_t l_257 = 0x98C1127AL;
            struct S1 *l_261 = &l_226;
            float **l_289 = &l_217;
            const int32_t *l_318 = &l_163;
            uint32_t l_342 = 0xEB18DA39L;
            struct S0 l_343 = {0,1L,97,-4037};
            for (l_226.f0.f1 = 8; (l_226.f0.f1 >= 0); l_226.f0.f1 -= 1)
            { /* block id: 97 */
                const int32_t *l_227 = &l_163;
                int32_t **l_228 = &l_203;
                int32_t *l_229[10] = {&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163,&l_163};
                int i;
                (*l_228) = l_227;
                /* statement id: 98 */
                assert (l_203 == &l_163);
                if ((p_41 != p_41))
                { /* block id: 99 */
                    int32_t *l_230[10][1] = {{&l_163},{&l_163},{(void*)0},{(void*)0},{(void*)0},{&l_163},{&l_163},{(void*)0},{(void*)0},{(void*)0}};
                    int i, j;
                    for (p_40 = 0; (p_40 <= 8); p_40 += 1)
                    { /* block id: 102 */
                        (*l_228) = &l_163;
                        /* statement id: 103 */
                        assert (l_203 == &l_163);
                        if ((*l_162))
                            continue;
                        (*l_228) = l_229[8];
                        (*l_228) = l_216;
                        /* statement id: 106 */
                        assert (l_203 == 0);
                    }
                    /* facts after for loop */
                    assert (l_203 == 0 || l_203 == &l_163);
                    (*l_217) = ((void*)0 == &l_163);
                    for (l_49 = 0; (l_49 <= 8); l_49 += 1)
                    { /* block id: 111 */
                        (*l_228) = l_230[5][0];
                        (*l_162) = 8L;
                    }
                }
                else
                { /* block id: 115 */
                    (*l_217) = (*l_203);
                }
                /* facts after branching */
                assert (l_203 == 0 || l_203 == &l_163);
            }
            /* facts after for loop */
            assert (l_203 == 0 || l_203 == &l_163);
            for (l_188.f1 = 2; (l_188.f1 > (-20)); l_188.f1--)
            { /* block id: 121 */
                float l_239 = 0x3.7ABC46p-22;
                int32_t *l_240 = &l_163;
                struct S1 **l_286 = &l_261;
                struct S0 **l_287 = &l_247;
            }
            (*l_162) = ((0xFBL || (safe_rshift_func_uint16_t_u_u(((((l_301 | ((!(safe_div_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_s((p_40 >= (safe_div_func_int16_t_s_s(((&l_297 != &l_261) ^ p_42), p_40))), (safe_lshift_func_int16_t_s_u((safe_sub_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u(p_40, 0UL)), l_342)), p_42)))) && l_301), 0x8A96B655L))) || (-2L))) & (*l_318)) <= 0xA3BDL) ^ p_40), p_40))) < p_40);
            (*p_41) = l_343;
        }
        /* facts after branching */
        assert (l_203 == 0 || l_203 == &l_163);
        l_273[5][8] = &l_163;
    }
    else
    { /* block id: 202 */
        int32_t *l_344 = &l_163;
        int32_t **l_345 = (void*)0;
        int32_t **l_346 = &l_162;
        struct S0 *l_354[10][9][2] = {{{&l_188,(void*)0},{&l_188,&l_226.f0},{&l_188,&l_188},{&l_226.f0,&l_188},{(void*)0,&l_188},{&l_188,(void*)0},{&l_188,&l_188},{&l_188,&l_226.f0},{&l_188,(void*)0}},{{&l_188,&l_188},{(void*)0,&l_188},{&l_188,(void*)0},{&l_188,&l_226.f0},{&l_188,&l_188},{&l_188,(void*)0},{&l_188,&l_188},{(void*)0,&l_188},{&l_226.f0,&l_188}},{{&l_188,&l_226.f0},{&l_188,(void*)0},{&l_188,&l_188},{(void*)0,(void*)0},{&l_226.f0,&l_226.f0},{&l_226.f0,&l_188},{(void*)0,&l_188},{&l_226.f0,&l_188},{(void*)0,&l_188}},{{(void*)0,&l_226.f0},{(void*)0,&l_188},{&l_188,&l_188},{&l_188,&l_226.f0},{(void*)0,&l_188},{&l_188,&l_188},{&l_188,&l_188},{(void*)0,&l_188},{&l_188,&l_188}},{{&l_188,&l_188},{&l_188,&l_226.f0},{&l_188,&l_226.f0},{&l_188,(void*)0},{&l_188,&l_188},{&l_188,&l_188},{&l_188,&l_188},{&l_188,&l_188},{&l_188,&l_188}},{{&l_188,&l_188},{&l_188,(void*)0},{(void*)0,(void*)0},{&l_226.f0,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0},{&l_226.f0,(void*)0},{(void*)0,(void*)0},{&l_188,&l_188}},{{&l_188,&l_188},{&l_188,&l_188},{&l_188,&l_188},{&l_188,&l_188},{&l_188,&l_188},{&l_188,(void*)0},{&l_188,&l_226.f0},{&l_188,&l_226.f0},{&l_188,&l_188}},{{&l_188,&l_188},{&l_188,&l_188},{(void*)0,&l_188},{&l_188,&l_188},{&l_188,&l_188},{(void*)0,&l_226.f0},{&l_188,&l_188},{&l_188,&l_188},{(void*)0,&l_226.f0}},{{(void*)0,&l_188},{(void*)0,&l_188},{&l_226.f0,&l_188},{(void*)0,&l_188},{&l_226.f0,&l_226.f0},{&l_226.f0,(void*)0},{(void*)0,&l_188},{&l_188,&l_188},{&l_226.f0,(void*)0}},{{&l_226.f0,&l_226.f0},{&l_188,(void*)0},{&l_188,&l_188},{(void*)0,&l_226.f0},{&l_226.f0,&l_188},{(void*)0,&l_188},{&l_188,&l_226.f0},{&l_188,&l_188},{&l_226.f0,&l_188}}};
        struct S0 **l_353[5] = {&l_354[0][3][0],&l_354[0][3][0],&l_354[0][3][0],&l_354[0][3][0],&l_354[0][3][0]};
        struct S0 ***l_352 = &l_353[0];
        int i, j, k;
        (*l_346) = l_344;
        (*l_162) = (safe_mod_func_uint8_t_u_u(p_40, (safe_rshift_func_int8_t_s_u(7L, p_42))));
        for (l_226.f0.f1 = 0; (l_226.f0.f1 <= 5); l_226.f0.f1 += 1)
        { /* block id: 207 */
            struct S0 *l_351 = (void*)0;
            struct S0 ***l_355 = &l_353[0];
            float ***l_364[6] = {&l_255,&l_255,&l_255,&l_255,&l_255,&l_255};
            struct S1 *l_376 = (void*)0;
            int i;
            for (l_163 = 4; (l_163 >= 1); l_163 -= 1)
            { /* block id: 210 */
                return l_351;
                /* statement id: 211 */
                //assert (func_39_rv == 0);
            }
            l_271[l_226.f0.f1] = l_271[l_226.f0.f1];
            for (p_42 = 0; (p_42 <= 7); p_42 += 1)
            { /* block id: 216 */
                int32_t l_359[10] = {0x0075ED17L,0xFD78E882L,0x0075ED17L,0xFD78E882L,0x0075ED17L,0xFD78E882L,0x0075ED17L,0xFD78E882L,0x0075ED17L,0xFD78E882L};
                struct S0 l_360[9] = {{1,0x745967417D791A89LL,109,3868},{2,-1L,19,-738},{1,0x745967417D791A89LL,109,3868},{2,-1L,19,-738},{1,0x745967417D791A89LL,109,3868},{2,-1L,19,-738},{1,0x745967417D791A89LL,109,3868},{2,-1L,19,-738},{1,0x745967417D791A89LL,109,3868}};
                struct S1 *l_367 = (void*)0;
                int i;
            }
            (*l_344) = ((0x7A2345CDD01D6342LL <= (safe_mod_func_int16_t_s_s((-7L), ((((p_42 < ((safe_lshift_func_uint8_t_u_u(p_42, 6)) | (((safe_div_func_uint64_t_u_u(((((+(p_40 ^ (**l_346))) | 9L) | (((void*)0 == l_376) != p_42)) < 0UL), 0x8D15717C87887CB6LL)) && (-6L)) > p_42))) <= p_40) & p_42) & p_42)))) ^ 1L);
        }
        for (l_49 = 1; (l_49 <= 8); l_49 += 1)
        { /* block id: 239 */
            struct S1 *l_377 = &l_226;
            struct S1 **l_378 = &l_225;
            int i;
            (*l_378) = l_377;
        }
    }
    return p_41;
    /* statement id: 243 */
    //assert (func_39_rv == &l_44 || func_39_rv == &l_550.f0 || func_39_rv == &l_704 || (func_39_rv >= &l_760[0] && func_39_rv <= &l_760[1]));
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 331
   depth: 1, occurrence: 34
   depth: 2, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 11
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 143
breakdown:
   indirect level: 0, occurrence: 35
   indirect level: 1, occurrence: 64
   indirect level: 2, occurrence: 16
   indirect level: 3, occurrence: 14
   indirect level: 4, occurrence: 10
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 206
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 69
XXX times a single bitfield on LHS: 5
XXX times a single bitfield on RHS: 85

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 244
   depth: 2, occurrence: 74
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 3
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 423

XXX times a variable address is taken: 808
XXX times a pointer is dereferenced on RHS: 132
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 35
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 163
breakdown:
   depth: 1, occurrence: 144
   depth: 2, occurrence: 16
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 63
XXX times a pointer is compared with address of another variable: 20
XXX times a pointer is compared with another pointer: 26
XXX times a pointer is qualified to be dereferenced: 1088

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 585
   level: 2, occurrence: 129
   level: 3, occurrence: 26
   level: 4, occurrence: 22
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 217
XXX number of pointers point to scalars: 107
XXX number of pointers point to structs: 99
XXX percent of pointers has null in alias set: 33.3
XXX average alias set size: 1.28

XXX times a non-volatile is read: 1457
XXX times a non-volatile is write: 542
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 239
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 41
   depth: 2, occurrence: 50
   depth: 3, occurrence: 37
   depth: 4, occurrence: 46
   depth: 5, occurrence: 31

XXX percentage a fresh-made variable is used: 19.9
XXX percentage an existing variable is used: 80.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

