/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3618688390
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = 1;
static struct S0 g_72 = {6U,1U};
static uint32_t g_130 = 0U;
static uint32_t g_138 = 2U;
static struct S0 g_154 = {0U,1U};
static int32_t g_225 = (-1);
static int32_t g_237 = (-1);
static uint32_t g_238 = 0xD3830011;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_28(void);
static struct S0  func_29(struct S0  p_30, struct S0  p_31, int32_t  p_32);
static struct S0  func_33(struct S0  p_34);
static uint32_t  func_39(int16_t  p_40);
static int32_t  func_42(int16_t  p_43, int32_t  p_44, int16_t  p_45, int32_t  p_46);
static int64_t  func_51(int32_t  p_52, uint32_t  p_53);
static uint32_t  func_59(uint16_t  p_60, int32_t  p_61);
static uint32_t  func_66(int16_t  p_67, uint16_t  p_68);
static uint16_t  func_70(struct S0  p_71);
static int16_t  func_76(uint32_t  p_77, int32_t  p_78, struct S0  p_79, int32_t  p_80, int32_t  p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_72 g_154 g_130 g_138 g_225 g_237 g_238
 * writes: g_3 g_72 g_130 g_138 g_154
 */
static int32_t  func_28(void)
{ /* block id: 36 */
    struct S0 l_35 = {0U,8U};
    l_35 = func_29(func_33(l_35), g_154, g_154.f0);
    for (g_130 = 9; (g_130 != 38); g_130 += 1)
    { /* block id: 114 */
        int32_t l_175 = 0;
        int32_t l_182 = 1;
        struct S0 l_214 = {0xBB6E,2U};
        l_182 = ((((int32_t)((uint32_t)__builtin_clz(l_175) % (uint32_t)((int32_t)((-1) || ((int16_t)((0U <= g_3) && (-1)) + (int16_t)((int16_t)l_175 << (int16_t)(l_175 <= 0U)))) % (int32_t)0x52E31AC3)) % (int32_t)0x5B248B13) <= l_35.f1) == l_175);
        for (l_175 = 0; (l_175 < 17); l_175 += 7)
        { /* block id: 118 */
            int16_t l_203 = 3;
            int32_t l_212 = 1;
            g_3 = (0x6C4CAD9D ^ l_175);
            for (g_72.f0 = (-25); (g_72.f0 >= 3); g_72.f0 += 1)
            { /* block id: 122 */
                int32_t l_194 = 6;
                struct S0 l_217 = {0x68AC,4294967291U};
                if (__builtin_popcountl((((g_72.f0 < l_175) ^ __builtin_clzll((((uint16_t)g_154.f0 + (uint16_t)(-(int16_t)func_51(l_35.f0, ((uint16_t)((uint16_t)(l_194 && g_130) % (uint16_t)l_194) >> (uint16_t)12)))) >= func_59(g_72.f0, l_35.f1)))) <= 0xF38B)))
                { /* block id: 123 */
                    uint32_t l_211 = 4294967295U;
                    struct S0 l_213 = {0xA63E,0x4706FC58};
                    if ((~l_194))
                    { /* block id: 124 */
                        uint32_t l_196 = 4294967295U;
                        l_211 = ((l_196 && (((int16_t)(-9) << (int16_t)1) && 0x6FF47357)) ^ (((((int16_t)((int32_t)(l_203 != ((int32_t)(g_154.f1 < __builtin_bswap32(((~((((((((5 | 0xC303B9D0) == func_59(((int16_t)((0xAFCBF960 && ((uint32_t)g_130 - (uint32_t)0x1BE58EEB)) | g_154.f1) >> (int16_t)10), g_138)) && (-9)) && 65527U) < 0x49E2) != 0xABE429C8) || 0x1E2E) > (-3))) <= l_196))) % (int32_t)l_182)) % (int32_t)l_203) >> (int16_t)15) || l_196) || g_3) ^ g_138));
                        g_3 = l_203;
                        l_212 = 1;
                    }
                    else
                    { /* block id: 128 */
                        uint32_t l_216 = 1U;
                        g_3 = g_130;
                        l_217 = func_29(l_213, l_214, (!l_216));
                        l_217 = l_35;
                    }
                }
                else
                { /* block id: 133 */
                    uint32_t l_219 = 0x9B8F6F59;
                    int32_t l_220 = 0;
                    int32_t l_239 = (-8);
                    if ((((g_154.f1 & l_182) || func_66(l_35.f0, __builtin_parityll(__builtin_ctzl(g_72.f0)))) | ((g_3 & ((((((4294967293U == g_154.f0) && g_154.f1) | l_35.f1) >= l_203) != g_138) | l_217.f0)) <= g_154.f0)))
                    { /* block id: 134 */
                        g_3 = (!g_72.f0);
                        g_154 = l_214;
                        l_212 = g_130;
                    }
                    else
                    { /* block id: 138 */
                        uint32_t l_236 = 0x7EA332A1;
                        l_220 = (((-1) != l_203) || __builtin_clzl(l_219));
                        l_220 = (((int32_t)((int16_t)g_138 >> (int16_t)13) % (int32_t)(g_225 & ((uint16_t)(((uint16_t)func_42(((int16_t)func_42(((uint16_t)g_154.f0 + (uint16_t)((int16_t)g_72.f1 + (int16_t)((l_236 || l_203) | __builtin_bswap64(g_237)))), g_238, l_212, l_212) + (int16_t)(-1)), l_212, g_72.f0, l_217.f1) >> (uint16_t)5) & l_212) + (uint16_t)0x70B1))) ^ l_239);
                        l_239 = ((int16_t)((uint16_t)(l_239 ^ (0x321409A7 <= l_212)) >> (uint16_t)((uint32_t)g_154.f1 + (uint32_t)0x5376D6D6)) + (int16_t)(func_42(g_237, (((uint16_t)((0 & (((int16_t)0x290A >> (int16_t)1) & l_35.f0)) >= g_72.f1) << (uint16_t)l_35.f0) <= 65534U), g_138, g_237) & 65535U));
                    }
                }
                g_3 = l_214.f1;
                g_3 = func_42(((int32_t)g_154.f0 - (int32_t)(((g_238 >= (l_217.f1 != l_194)) != l_203) || g_237)), g_237, ((int16_t)((((int16_t)0xC265 >> (int16_t)(l_214.f1 >= g_154.f1)) ^ 0x89B6) < 0U) >> (int16_t)l_35.f1), g_138);
            }
        }
    }
    g_3 = ((g_154.f1 <= (l_35.f1 | func_59(l_35.f1, (l_35.f0 == l_35.f0)))) > (l_35.f1 < (65527U & l_35.f0)));
    return l_35.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_154.f1 g_130 g_3 g_72
 * writes: g_3
 */
static struct S0  func_29(struct S0  p_30, struct S0  p_31, int32_t  p_32)
{ /* block id: 103 */
    int32_t l_165 = (-5);
    for (p_31.f0 = 5; (p_31.f0 == 17); p_31.f0 += 1)
    { /* block id: 106 */
        int32_t l_168 = 5;
        g_3 = ((int16_t)(((((uint16_t)((int32_t)g_154.f1 + (int32_t)((uint16_t)__builtin_clz((l_165 | ((int16_t)g_130 << (int16_t)8))) + (uint16_t)g_154.f1)) - (uint16_t)func_51(((g_3 >= p_32) || 0x0010), ((0xA04B != 0x667A) <= l_168))) == g_130) == p_30.f0) && p_31.f0) << (int16_t)p_30.f1);
        return g_72;
    }
    return g_72;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_72
 * writes: g_3 g_72 g_130 g_138
 */
static struct S0  func_33(struct S0  p_34)
{ /* block id: 37 */
    struct S0 l_135 = {1U,4294967295U};
    int32_t l_153 = 0x1FE13ADA;
    for (g_3 = (-6); (g_3 >= 24); g_3 += 5)
    { /* block id: 40 */
        int32_t l_38 = 0x6E74A6E8;
        int32_t l_131 = 1;
        struct S0 l_137 = {0x0D3B,4294967295U};
        l_131 = ((l_38 < ((func_39((-(int32_t)g_3)) > l_38) > g_3)) >= 0x1CE2);
        if (((int16_t)(~65535U) << (int16_t)12))
        { /* block id: 84 */
            uint32_t l_136 = 0U;
            l_135 = g_72;
            l_136 = l_135.f1;
        }
        else
        { /* block id: 87 */
            uint32_t l_150 = 0xC04404CF;
            l_137 = p_34;
            if (g_3)
            { /* block id: 89 */
                uint32_t l_149 = 4294967288U;
                g_138 = l_38;
                for (l_131 = (-6); (l_131 >= 5); l_131 += 8)
                { /* block id: 93 */
                    l_150 = (((int16_t)((int16_t)(0x74A6A36E > 0x13CF271E) << (int16_t)((int16_t)(-4) - (int16_t)(p_34.f1 | g_72.f0))) << (int16_t)14) >= ((int16_t)((func_51(l_149, g_72.f0) == p_34.f1) || 0x0920) + (int16_t)0xBE43));
                }
            }
            else
            { /* block id: 96 */
                l_153 = (l_150 < ((int16_t)l_135.f0 >> (int16_t)15));
                l_131 = (p_34.f0 && p_34.f0);
            }
        }
    }
    return l_135;
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_3
 * writes: g_72 g_130
 */
static uint32_t  func_39(int16_t  p_40)
{ /* block id: 41 */
    int16_t l_69 = 0x4B0F;
    int32_t l_106 = (-1);
    g_130 = func_42((((uint16_t)(((int16_t)(__builtin_ffsll(func_51(((int32_t)(((((int16_t)(!func_59((((uint16_t)((((func_66(((l_69 <= func_70(g_72)) || 0xDAEE), (__builtin_parityl(g_3) | (((uint16_t)(0xE287B835 && 0) + (uint16_t)p_40) & 0xDDBA))) && l_69) == g_3) != g_3) && 0) << (uint16_t)g_3) > g_3), l_69)) - (int16_t)g_3) & p_40) ^ g_3) != g_3) % (int32_t)l_106), g_3)) < p_40) % (int16_t)l_106) > p_40) % (uint16_t)p_40) || 1U), l_69, l_69, g_3);
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_72.f1 g_72.f0 g_72
 * writes:
 */
static int32_t  func_42(int16_t  p_43, int32_t  p_44, int16_t  p_45, int32_t  p_46)
{ /* block id: 72 */
    int32_t l_121 = 0;
    struct S0 l_129 = {5U,0x78960E8A};
    for (p_45 = 11; (p_45 >= (-10)); p_45 -= 3)
    { /* block id: 75 */
        int32_t l_125 = 0x8A5E38B9;
        int32_t l_128 = (-4);
        p_44 = ((((int32_t)(((uint16_t)(g_3 != ((!(((uint16_t)(((int16_t)l_121 >> (int16_t)(l_121 >= ((!g_72.f1) != ((int32_t)func_51(g_72.f0, g_72.f1) % (int32_t)4294967295U)))) > ((g_3 | l_121) < p_44)) >> (uint16_t)12) ^ l_125)) <= 0U)) << (uint16_t)l_125) < g_3) % (int32_t)l_121) < l_125) & g_3);
        l_128 = ((int16_t)l_125 << (int16_t)10);
    }
    l_129 = g_72;
    return g_72.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_51(int32_t  p_52, uint32_t  p_53)
{ /* block id: 69 */
    struct S0 l_107 = {65528U,0xCF7F8006};
    l_107 = l_107;
    return l_107.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_72.f0
 * writes:
 */
static uint32_t  func_59(uint16_t  p_60, int32_t  p_61)
{ /* block id: 54 */
    struct S0 l_95 = {0xBB92,0x586CE7EF};
    l_95 = l_95;
    if (l_95.f0)
    { /* block id: 56 */
        return g_3;
    }
    else
    { /* block id: 58 */
        uint32_t l_98 = 0xB91F40AC;
        struct S0 l_105 = {1U,0x8F18CA9A};
        for (p_61 = 14; (p_61 <= (-11)); p_61 -= 1)
        { /* block id: 61 */
            if (g_72.f0)
                break;
        }
        l_98 = p_60;
        p_61 = ((1U && (((p_60 >= g_3) < __builtin_ctz(p_60)) > g_72.f0)) || (g_72.f0 | ((int32_t)((int16_t)((2U >= ((int16_t)0xC5B3 >> (int16_t)9)) >= 0x91FC) + (int16_t)(-1)) % (int32_t)5)));
        l_95 = l_105;
    }
    return l_95.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_72.f1
 * writes:
 */
static uint32_t  func_66(int16_t  p_67, uint16_t  p_68)
{ /* block id: 52 */
    return g_72.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_72.f0 g_72.f1 g_72 g_3
 * writes: g_72
 */
static uint16_t  func_70(struct S0  p_71)
{ /* block id: 42 */
    int32_t l_73 = 0xC076A5D0;
    struct S0 l_83 = {0x326D,0U};
    l_73 = __builtin_ctz(p_71.f1);
    l_73 = (0xF607 & ((((int16_t)func_76(l_73, (-(uint16_t)(g_72.f0 == l_73)), l_83, g_72.f1, ((1U > p_71.f0) || l_83.f1)) << (int16_t)4) <= g_72.f1) >= 0));
    g_72 = g_72;
    return p_71.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_3
 * writes:
 */
static int16_t  func_76(uint32_t  p_77, int32_t  p_78, struct S0  p_79, int32_t  p_80, int32_t  p_81)
{ /* block id: 44 */
    struct S0 l_84 = {0xBC07,4294967289U};
    int32_t l_91 = 0x37692AFB;
    p_81 = p_80;
    l_84 = g_72;
    p_81 = (p_77 >= ((int16_t)((uint16_t)(g_72.f0 || p_79.f1) % (uint16_t)(((uint16_t)p_80 % (uint16_t)l_84.f1) | l_91)) >> (int16_t)(!(p_81 & (((((l_91 >= l_84.f0) || l_91) ^ g_3) <= 0xD72F) | (-1))))));
    return l_91;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_72.f0, "g_72.f0", print_hash_value);
    transparent_crc(g_72.f1, "g_72.f1", print_hash_value);
    transparent_crc(g_130, "g_130", print_hash_value);
    transparent_crc(g_138, "g_138", print_hash_value);
    transparent_crc(g_154.f0, "g_154.f0", print_hash_value);
    transparent_crc(g_154.f1, "g_154.f1", print_hash_value);
    transparent_crc(g_225, "g_225", print_hash_value);
    transparent_crc(g_237, "g_237", print_hash_value);
    transparent_crc(g_238, "g_238", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 41
   depth: 1, occurrence: 14
XXX total union variables: 0

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 4
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 29, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 239
XXX times a non-volatile is write: 50
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 69
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 13
   depth: 2, occurrence: 7
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 20.1
XXX percentage an existing variable is used: 79.9
********************* end of statistics **********************/

