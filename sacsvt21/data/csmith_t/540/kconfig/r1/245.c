/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3973780759
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const float  f0;
};

union U1 {
   struct S0  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_33(void);
static const uint16_t  func_43(struct S0  p_44, uint32_t  p_45, int16_t  p_46);
inline static int32_t  func_63(float  p_64, int16_t  p_65);
inline static float  func_66(int16_t  p_67, int16_t  p_68);
inline static int16_t  func_69(uint16_t  p_70, uint32_t  p_71);
inline static uint32_t  func_78(union U1  p_79, uint32_t  p_80, int32_t  p_81);
static union U1  func_82(int16_t  p_83, int16_t  p_84, int16_t  p_85, int32_t  p_86);
inline static uint16_t  func_90(const int32_t  p_91, struct S0  p_92, float  p_93, const int32_t  p_94);
inline static uint32_t  func_98(uint32_t  p_99, uint32_t  p_100, const uint32_t  p_101);
inline static uint32_t  func_102(int32_t  p_103, struct S0  p_104, const uint16_t  p_105, uint32_t  p_106, union U1  p_107);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_33(void)
{ /* block id: 36 */
    int32_t l_38 = (-1);
    struct S0 l_47 = {0xD.C51938p-18};
    uint32_t l_56 = 0xA4D2C643;
    int32_t l_57 = 0;
    uint32_t l_701 = 4294967295U;
    int32_t l_702 = 0x08B27AF8;
    int32_t l_704 = 0;
    int32_t *l_703 = &l_704;
    l_702 = (((((uint32_t)(((uint16_t)l_38 >> (uint16_t)(((((int32_t)(((((int16_t)((func_43(l_47, (l_38 > ((int16_t)l_38 % (int16_t)((int32_t)__builtin_clzll((((((l_38 != 0xA788AFB1) && ((int16_t)l_38 - (int16_t)((uint16_t)(l_38 < __builtin_popcount(l_56)) << (uint16_t)l_38))) ^ l_57) == l_38) | l_56)) % (int32_t)l_56))), l_56) != l_38) != l_57) >> (int16_t)4) <= l_38) && 0x9CEF) & l_57) % (int32_t)l_57) < 6) || l_701) ^ l_57)) || l_38) + (uint32_t)0x75D71700) & 0) || l_56) == 0xC736);
    l_703 = l_703;
    return l_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_43(struct S0  p_44, uint32_t  p_45, int16_t  p_46)
{ /* block id: 37 */
    int32_t l_87 = 0;
    const uint32_t l_122 = 0x87F0BBFF;
    const int16_t l_324 = 0;
    uint32_t l_325 = 0x6E66161C;
    int16_t l_616 = (-7);
    float l_620 = (-0x8.8p+1);
    struct S0 l_642 = {0x1.Bp+1};
    struct S0 *l_641 = &l_642;
    union U1 l_645 = {{0xF.3A5651p+87}};
    union U1 *l_644 = &l_645;
    int32_t l_660 = 1;
lbl_700:
    for (p_45 = 0; (p_45 < 46); p_45 += 7)
    { /* block id: 40 */
        uint32_t l_97 = 0xF0ED5C0E;
        union U1 l_110 = {{0x1.Dp+1}};
        int32_t l_593 = 0x80D47D5A;
        int32_t *l_592 = &l_593;
        float *l_675 = &l_620;
        (*l_592) = (0 && (~(((int32_t)func_63(func_66(func_69((((int16_t)((0x56CDAA93 < ((uint16_t)(((uint32_t)func_78(func_82(p_46, l_87, l_87, (__builtin_popcount(p_46) & ((uint32_t)(func_90((((uint32_t)(l_97 >= __builtin_parityl(func_98(func_102(((int16_t)(((p_46 == p_46) || p_46) | p_45) + (int16_t)l_97), p_44, l_87, l_87, l_110), p_46, l_122))) + (uint32_t)l_97) || l_122), l_110.f0, l_97, l_97) || p_45) - (uint32_t)l_122))), p_46, l_97) + (uint32_t)0) & p_45) >> (uint16_t)p_46)) < l_324) << (int16_t)p_45) && p_45), l_325), l_97), l_97) % (int32_t)p_46) >= l_325)));
        for (l_97 = 0; (l_97 >= 49); ++l_97)
        { /* block id: 332 */
            float ***l_596 = (void*)0;
            int32_t l_609 = 0xDF16E1E9;
            struct S0 l_613 = {0x8.ADF634p-29};
            struct S0 *l_612 = &l_613;
            union U1 **l_622 = (void*)0;
            union U1 ***l_621 = &l_622;
            struct S0 **l_634 = &l_612;
            struct S0 ***l_633 = &l_634;
            struct S0 ****l_632 = &l_633;
            const uint32_t l_639 = 0xC35432E4;
            int32_t l_655 = 0x86F265DF;
            float l_656 = (-0x1.Bp-1);
        }
        (*l_675) = (((void*)0 != l_592) >= (0x1.26B86Ap+26 >= (((((float)(p_44.f0 >= ((float)p_44.f0 + (float)(p_45 < ((*l_592) >= 0x6.F6A21Ep+0)))) + (float)(*l_592)) == 0xF.5D6209p-30) < l_324) <= p_44.f0)));
    }
    if (((uint16_t)((uint16_t)p_45 % (uint16_t)l_660) >> (uint16_t)1))
    { /* block id: 378 */
        int32_t *l_680 = &l_660;
        int32_t **l_681 = &l_680;
        union U1 **l_687 = &l_644;
        float *l_688 = &l_620;
        (*l_681) = l_680;
        (*l_688) = ((float)(((**l_681) > p_45) <= (!(((float)((((&l_644 != l_687) >= p_45) != p_46) != p_45) - (float)(*l_680)) == (p_44.f0 > 0x7.887DC5p-62)))) - (float)p_44.f0);
        for (l_87 = (-21); (l_87 >= (-8)); l_87++)
        { /* block id: 383 */
            (*l_681) = (void*)0;
            /* statement id: 384 */
            assert (l_680 == 0);
        }
        /* facts after for loop */
        assert (l_680 == 0 || l_680 == &l_660);
    }
    else
    { /* block id: 386 */
        float *l_691 = &l_620;
        int32_t *l_693 = &l_660;
        int32_t **l_692 = &l_693;
        (*l_691) = (-0x1.5p+1);
        (*l_692) = l_691;
        /* statement id: 388 */
        assert (l_693 == &l_620);
        for (p_45 = 4; (p_45 != 30); ++p_45)
        { /* block id: 391 */
            struct S0 *l_696 = &l_642;
            struct S0 **l_697 = &l_696;
            int32_t ***l_698 = &l_692;
            int32_t ****l_699 = &l_698;
            (*l_697) = l_696;
            (*l_699) = l_698;
            if ((***l_698))
                continue;
            (*l_691) = (*l_693);
        }
    }
    if (l_324)
        goto lbl_700;
    return l_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_63(float  p_64, int16_t  p_65)
{ /* block id: 191 */
    int32_t l_367 = 0x1C258296;
    struct S0 l_375 = {0xE.B6F2C5p-70};
    struct S0 *l_374 = &l_375;
    struct S0 **l_373 = &l_374;
    struct S0 ***l_372 = &l_373;
    union U1 l_378 = {{0x1.7p+1}};
    union U1 *l_383 = (void*)0;
    int32_t **l_399 = (void*)0;
    union U1 **l_468 = &l_383;
    union U1 ***l_467 = &l_468;
    union U1 ****l_466 = &l_467;
    float *l_470 = (void*)0;
    float **l_469 = &l_470;
    const float *l_508 = &l_375.f0;
    int32_t l_511 = 0x2BCA56F5;
    int32_t *l_510 = &l_511;
    float ***l_514 = &l_469;
    int32_t l_567 = 0xD12AEA4F;
    uint16_t l_581 = 0xF731;
lbl_574:
    if (((((65531U == ((int16_t)l_367 >> (int16_t)10)) < l_367) <= l_367) & (((int16_t)func_102((((void*)0 == l_372) != (0xDE8A > ((((((int16_t)p_65 << (int16_t)((*l_372) == (*l_372))) != p_65) != p_65) || p_65) <= p_65))), (**l_373), l_367, p_65, l_378) % (int16_t)0x1FE9) && l_367)))
    { /* block id: 192 */
        int32_t l_380 = 0x94971777;
        int32_t *l_379 = &l_380;
        struct S0 ***l_381 = &l_373;
        (*l_379) = l_367;
        l_381 = &l_373;
        (*l_379) = p_65;
    }
    else
    { /* block id: 196 */
        union U1 *l_382 = &l_378;
        int32_t l_384 = 0x0B89F9E0;
        int32_t *l_398 = (void*)0;
        int32_t **l_397 = &l_398;
        float l_429 = 0x4.Dp-1;
        uint16_t l_539 = 1U;
        l_383 = l_382;
        /* statement id: 197 */
        assert (l_383 == &l_378);
        if (l_384)
        { /* block id: 198 */
            int32_t l_387 = 0;
            uint32_t l_405 = 0U;
            union U1 *l_418 = &l_378;
            if (((uint16_t)(0x7CD7A234 > l_387) + (uint16_t)(((uint16_t)(((((((l_387 ^ (0x7D261BF6 > (p_65 <= l_387))) ^ 0x9E4DF3D4) != l_387) == ((int16_t)((int16_t)l_387 + (int16_t)p_65) << (int16_t)14)) & 0xF0431196) < l_387) != l_384) + (uint16_t)0) <= p_65)))
            { /* block id: 199 */
                const int32_t **l_396 = (void*)0;
                union U1 **l_410 = &l_382;
                union U1 ***l_409 = &l_410;
                int32_t *l_421 = &l_387;
                for (p_65 = (-27); (p_65 <= (-12)); p_65 += 2)
                { /* block id: 202 */
                    int32_t l_402 = 3;
                    struct S0 ****l_406 = &l_372;
                    if (((p_65 || ((((void*)0 == l_396) & (l_387 != l_387)) >= ((p_65 >= (l_397 != l_399)) ^ (__builtin_ffs((p_65 | l_387)) && (-3))))) >= p_65))
                    { /* block id: 203 */
                        float l_404 = 0x8.433EE4p-56;
                        float *l_403 = &l_404;
                        (*l_403) = ((float)l_402 + (float)0x0.Ap-1);
                        if (l_387)
                            continue;
                        (*l_403) = 0x0.Fp+1;
                        if (l_405)
                            continue;
                    }
                    else
                    { /* block id: 208 */
                        struct S0 *** const *l_408 = &l_372;
                        struct S0 *** const **l_407 = &l_408;
                        union U1 ** const *l_412 = &l_410;
                        union U1 ** const **l_411 = &l_412;
                        int32_t l_413 = (-1);
                        (*l_407) = l_406;
                        (*l_411) = l_409;
                        return l_413;
                    }
                }
                (*l_421) = ((uint16_t)((int16_t)(p_65 && func_98(((l_418 != l_418) || l_387), p_65, l_387)) - (int16_t)l_367) + (uint16_t)((int16_t)p_65 << (int16_t)p_65));
                (*l_421) = 0xE0B885B4;
            }
            else
            { /* block id: 216 */
                union U1 **l_424 = &l_418;
                union U1 ***l_423 = &l_424;
                union U1 ****l_422 = &l_423;
                (*l_422) = (void*)0;
                /* statement id: 217 */
                assert (l_423 == 0);
            }
            return l_405;
        }
        else
        { /* block id: 220 */
            float l_428 = 0x2.5p-1;
            int32_t l_435 = 0x6DD006A1;
            (*l_397) = (*l_397);
            p_64 = (((float)(+p_65) - (float)(func_66((p_65 ^ p_65), ((p_65 != __builtin_ffs(((((-1) == (((uint32_t)p_65 - (uint32_t)(-(int32_t)(((int16_t)(&l_383 == &l_382) % (int16_t)p_65) > 0xD6D2EC17))) != p_65)) || l_435) || 0x92D7))) > l_367)) <= 0x1.Dp+1)) == p_65);
        }
    }
    for (l_367 = 21; (l_367 != 25); l_367 += 1)
    { /* block id: 303 */
        int32_t l_550 = 0xC967DBF7;
        struct S0 ***l_556 = (void*)0;
        uint32_t l_566 = 0x4F078E50;
        int32_t **l_572 = (void*)0;
        int32_t **l_573 = &l_510;
    }
    if (l_367)
        goto lbl_574;
    if (p_65)
    { /* block id: 316 */
        (*l_510) = 0xCDACD089;
    }
    else
    { /* block id: 318 */
        const float l_584 = 0xE.92DCAAp+60;
        struct S0 l_585 = {0x0.Dp-1};
        const int32_t l_588 = 0xDB5E339E;
        float l_590 = (-0x1.Ap+1);
        float *l_589 = &l_590;
        int32_t **l_591 = &l_510;
        for (l_511 = 21; (l_511 <= (-9)); l_511--)
        { /* block id: 321 */
            p_64 = p_64;
            return p_65;
        }
        (*l_589) = ((float)(0x1.9p+1 < ((*l_510) != ((float)l_581 - (float)((0xE.643BA1p-60 >= ((((float)func_90(p_65, l_585, p_64, ((uint16_t)p_65 + (uint16_t)l_588)) + (float)l_588) <= l_588) >= (*l_510))) <= p_65)))) + (float)(*l_510));
        (*l_591) = &l_588;
        /* statement id: 326 */
        assert (l_510 == &l_588);
    }
    /* facts after branching */
    //assert (l_510 == dangling || l_510 == &l_511);
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_66(int16_t  p_67, int16_t  p_68)
{ /* block id: 175 */
    int32_t l_344 = 0x1D02CFC9;
    float l_346 = 0xA.A7E32Ep+23;
    float *l_345 = &l_346;
lbl_349:
    (*l_345) = l_344;
    for (p_67 = (-6); (p_67 != 3); ++p_67)
    { /* block id: 179 */
        int16_t l_359 = (-5);
        union U1 ***l_360 = (void*)0;
        int32_t l_363 = 1;
        int32_t *l_362 = &l_363;
        if (p_67)
            goto lbl_349;
        if (((int16_t)l_344 >> (int16_t)((int16_t)(p_68 == ((0x1DD5 != (+(p_67 && ((int16_t)func_98((p_68 >= p_67), ((int32_t)(l_344 > l_359) - (int32_t)((l_359 == 4294967290U) != p_67)), p_67) >> (int16_t)3)))) || p_67)) << (int16_t)15)))
        { /* block id: 181 */
            union U1 ****l_361 = &l_360;
            int32_t **l_364 = &l_362;
            (*l_361) = l_360;
            (*l_364) = l_362;
        }
        else
        { /* block id: 184 */
            if ((*l_362))
                break;
            return l_344;
        }
        if (p_67)
            continue;
    }
    return l_344;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_69(uint16_t  p_70, uint32_t  p_71)
{ /* block id: 162 */
    int32_t l_327 = 0xF546179B;
    float l_333 = 0x8.FD3D76p+48;
    float *l_332 = &l_333;
    struct S0 l_342 = {0x6.2C45D2p+79};
    struct S0 *l_341 = &l_342;
    struct S0 **l_343 = &l_341;
    if ((((~p_70) > (__builtin_ffsl(l_327) | p_71)) ^ ((uint16_t)l_327 - (uint16_t)l_327)))
    { /* block id: 163 */
        int32_t l_335 = 2;
        int32_t *l_334 = &l_335;
        struct S0 l_339 = {0x0.Cp+1};
        struct S0 *l_338 = &l_339;
        (*l_334) = ((uint16_t)(l_327 > p_71) << (uint16_t)((void*)0 != l_332));
        for (p_71 = (-6); (p_71 < 16); p_71 += 6)
        { /* block id: 167 */
            struct S0 **l_340 = &l_338;
            (*l_340) = l_338;
        }
    }
    else
    { /* block id: 170 */
        return p_70;
    }
    (*l_343) = l_341;
    return l_327;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_78(union U1  p_79, uint32_t  p_80, int32_t  p_81)
{ /* block id: 155 */
    float l_323 = 0x7.6p+1;
    for (p_81 = (-25); (p_81 >= 2); p_81 += 9)
    { /* block id: 158 */
        float l_322 = 0x0.388FD2p+7;
        float *l_321 = &l_322;
        (*l_321) = (p_79.f0.f0 >= (-(float)p_79.f0.f0));
    }
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_82(int16_t  p_83, int16_t  p_84, int16_t  p_85, int32_t  p_86)
{ /* block id: 150 */
    struct S0 l_309 = {0x0.7p+1};
    int32_t l_310 = 0xB438F1E3;
    float l_314 = (-0x1.2p-1);
    float *l_313 = &l_314;
    int32_t *l_316 = &l_310;
    int32_t **l_315 = &l_316;
    union U1 l_317 = {{0x9.5p+1}};
    (*l_313) = (func_90(p_86, l_309, l_310, ((int16_t)l_310 >> (int16_t)(((l_310 != (__builtin_ia32_crc32qi(l_310, (l_310 && (l_310 | (__builtin_clzll(l_310) == l_310)))) || l_310)) & p_84) != p_85))) <= l_310);
    l_310 = 0x5.AFD968p-65;
    (**l_315) = ((l_310 ^ (p_84 == p_86)) == (l_315 == &l_316));
    return l_317;
    /* statement id: 154 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_90(const int32_t  p_91, struct S0  p_92, float  p_93, const int32_t  p_94)
{ /* block id: 55 */
    const int32_t l_128 = 0x9B07D9F9;
    const int32_t *l_127 = &l_128;
    struct S0 l_151 = {0x8.3B3785p+33};
    struct S0 *l_150 = &l_151;
    struct S0 **l_149 = &l_150;
    struct S0 ***l_148 = &l_149;
    struct S0 ****l_147 = &l_148;
    uint32_t l_159 = 4294967294U;
    int32_t l_177 = (-3);
    struct S0 ***l_211 = (void*)0;
    union U1 l_251 = {{-0x1.6p+1}};
    union U1 *l_250 = &l_251;
    union U1 **l_249 = &l_250;
    union U1 ***l_248 = &l_249;
    if (p_91)
    { /* block id: 56 */
        int32_t l_131 = (-3);
        int32_t *l_130 = &l_131;
        int32_t **l_129 = &l_130;
lbl_187:
        (*l_129) = l_127;
        /* statement id: 57 */
        assert (l_130 == &l_128);
lbl_188:
        for (l_131 = 1; (l_131 <= (-6)); l_131 -= 6)
        { /* block id: 60 */
            float l_135 = 0x0.Ap-1;
            float *l_134 = &l_135;
            int32_t l_137 = 6;
            int32_t *l_136 = &l_137;
            struct S0 **l_138 = (void*)0;
            struct S0 **l_139 = (void*)0;
            struct S0 l_142 = {0x1.Bp-1};
            struct S0 *l_141 = &l_142;
            struct S0 **l_140 = &l_141;
            struct S0 ***l_144 = &l_138;
            struct S0 ****l_143 = &l_144;
            (*l_134) = p_92.f0;
            (*l_136) = 0x2B137499;
            (*l_140) = &p_92;
            /* statement id: 63 */
            assert (l_141 == &p_92);
            (*l_143) = &l_140;
            /* statement id: 64 */
            assert (l_144 == &l_140);
        }
        if (func_98(((uint32_t)(0 & (l_147 != &l_148)) + (uint32_t)((int16_t)((int16_t)(!((uint16_t)((**l_129) ^ (((**l_129) > (**l_129)) || (*l_130))) >> (uint16_t)1)) >> (int16_t)12) + (int16_t)0U)), ((**l_129) && l_159), (*l_127)))
        { /* block id: 66 */
            float l_161 = 0xD.B2DC29p-74;
            int32_t l_163 = 2;
            float *l_164 = &l_161;
            int32_t **l_182 = &l_130;
            (*l_164) = ((((__builtin_ctz((__builtin_popcount(__builtin_clzl(((*l_127) != (*l_130)))) <= p_91)) <= ((-(float)p_94) > ((l_161 <= (!p_94)) > p_91))) > l_163) < (*l_130)) >= 0xB.945A0Fp+86);
            if (p_94)
            { /* block id: 68 */
                int16_t l_176 = (-10);
                (*l_129) = &l_163;
                /* statement id: 69 */
                assert (l_130 == &l_163);
                (*l_164) = p_93;
                l_177 = (p_94 ^ (((*l_127) <= (p_94 >= 0x07892551)) != ((uint16_t)((+((((__builtin_ffsll(((uint16_t)65526U % (uint16_t)(p_94 ^ ((int16_t)0xAD3C << (int16_t)((int16_t)__builtin_popcount((((uint16_t)__builtin_ctz(p_91) - (uint16_t)p_94) < (*l_127))) >> (int16_t)1))))) ^ p_91) & 0x2DD1) < l_176) != (*l_130))) == 1) << (uint16_t)l_176)));
            }
            else
            { /* block id: 72 */
                int32_t *l_180 = (void*)0;
                int32_t *l_181 = &l_163;
                (*l_181) = (((int32_t)(__builtin_bswap32((**l_129)) == l_163) + (int32_t)0xEAEA3312) == (**l_129));
            }
            /* facts after branching */
            assert (l_130 == &l_128 || l_130 == &l_163);
            (*l_182) = &p_94;
            /* statement id: 75 */
            assert (l_130 == &p_94);
            (*l_129) = (*l_182);
        }
        else
        { /* block id: 77 */
            const int32_t **l_189 = &l_127;
            for (l_177 = 3; (l_177 == (-21)); l_177--)
            { /* block id: 80 */
                float l_186 = 0xA.5459D1p+63;
                float *l_185 = &l_186;
                (*l_185) = (*l_127);
                if (l_177)
                    goto lbl_187;
                return p_94;
            }
            if (l_131)
                goto lbl_188;
            (*l_189) = &l_128;
            l_127 = (void*)0;
            /* statement id: 87 */
            assert (l_127 == 0);
        }
        /* facts after branching */
        assert (l_127 == 0 || l_127 == &l_128);
        assert (l_130 == &l_128 || l_130 == &p_94);
    }
    else
    { /* block id: 89 */
        const int16_t l_192 = 0x8BD4;
        int32_t l_205 = (-4);
        union U1 l_247 = {{-0x8.8p-1}};
        union U1 *l_246 = &l_247;
        union U1 **l_245 = &l_246;
        union U1 ***l_244 = &l_245;
        if (((uint32_t)1U - (uint32_t)(l_192 < (*l_127))))
        { /* block id: 90 */
            uint32_t l_206 = 4294967295U;
            int32_t *l_209 = &l_205;
            int32_t **l_210 = &l_209;
            union U1 ***l_240 = (void*)0;
            union U1 ****l_239 = &l_240;
            const int32_t *l_255 = (void*)0;
            (*l_209) = (p_94 < (p_91 == (((((uint32_t)(((*l_127) >= (~l_192)) > (l_192 || ((uint16_t)((int32_t)((~((uint32_t)(p_94 != ((uint16_t)(func_98(l_205, l_206, (((int32_t)l_206 + (int32_t)5U) || l_192)) | 0xE818DDB1) >> (uint16_t)13)) + (uint32_t)0x3E5AF596)) >= (*l_127)) - (int32_t)p_94) >> (uint16_t)15))) - (uint32_t)(*l_127)) ^ l_205) ^ p_94) || l_192)));
            (*l_210) = &l_205;
            if ((0x581D == (((void*)0 == l_211) <= p_94)))
            { /* block id: 93 */
                union U1 l_217 = {{0x8.8p+1}};
                union U1 *l_216 = &l_217;
                union U1 **l_215 = &l_216;
                union U1 *** const l_214 = &l_215;
                union U1 ***l_219 = &l_215;
                int32_t *l_221 = &l_177;
                (**l_148) = &p_92;
                /* statement id: 94 */
                assert (l_150 == &p_92);
                for (l_205 = (-18); (l_205 == (-12)); l_205 += 6)
                { /* block id: 97 */
                    union U1 ****l_218 = (void*)0;
                    int32_t *l_220 = &l_177;
                    l_219 = l_214;
                    (*l_220) = (*l_127);
                    (*l_210) = l_221;
                    /* statement id: 100 */
                    assert (l_209 == &l_177);
                }
                /* facts after for loop */
                assert (l_209 == &l_177 || l_209 == &l_205);
            }
            else
            { /* block id: 102 */
                const uint16_t l_236 = 0x3DDA;
                union U1 ****l_241 = &l_240;
                (*l_210) = &l_205;
                for (l_205 = 0; (l_205 > 28); ++l_205)
                { /* block id: 106 */
                    if ((p_91 | (((0xD3C6725D || __builtin_clz((((int16_t)(!((*l_127) == p_91)) << (int16_t)2) ^ ((uint32_t)(((int16_t)(-(uint32_t)((((uint16_t)((uint16_t)l_236 + (uint16_t)((uint32_t)(l_239 != l_241) + (uint32_t)((uint32_t)p_91 % (uint32_t)__builtin_ffs((l_244 == l_248))))) + (uint16_t)0xD89C) & p_91) >= 4U)) << (int16_t)(**l_210)) != p_91) + (uint32_t)p_94)))) < (*l_209)) ^ l_236)))
                    { /* block id: 107 */
                        const int32_t **l_252 = &l_127;
                        (*l_252) = &p_94;
                        /* statement id: 108 */
                        assert (l_127 == &p_94);
                        if (p_94)
                            continue;
                    }
                    else
                    { /* block id: 110 */
                        float l_254 = 0x5.4F28CAp+1;
                        float *l_253 = &l_254;
                        (*l_253) = (**l_210);
                        (***l_147) = (void*)0;
                        /* statement id: 112 */
                        assert (l_150 == 0);
                    }
                }
                /* facts after for loop */
                assert (l_127 == &p_94 || l_127 == &l_128);
                assert (l_150 == 0 || l_150 == &l_151);
            }
            /* facts after branching */
            assert (l_127 == &p_94 || l_127 == &l_128);
            assert (l_150 == 0 || l_150 == &l_151 || l_150 == &p_92);
            assert (l_209 == &l_177 || l_209 == &l_205);
            l_255 = &p_94;
            /* statement id: 116 */
            assert (l_255 == &p_94);
        }
        else
        { /* block id: 117 */
            int32_t *l_303 = &l_177;
            float l_308 = 0x9.479EB2p-22;
            float *l_307 = &l_308;
            if ((l_192 & (((uint16_t)(((*l_127) <= (((int16_t)((uint16_t)p_94 << (uint16_t)6) << (int16_t)1) || p_94)) ^ 0xD35FC118) >> (uint16_t)1) || (*l_127))))
            { /* block id: 118 */
                int32_t l_262 = 0x435B6E95;
                float l_264 = 0x5.CF9800p+74;
                float *l_263 = &l_264;
                (*l_263) = l_262;
            }
            else
            { /* block id: 120 */
                const uint32_t l_267 = 4294967289U;
                struct S0 l_283 = {0x9.1p+1};
                int32_t *l_295 = &l_205;
                struct S0 ***l_301 = &l_149;
                int32_t **l_302 = &l_295;
                if (p_94)
                { /* block id: 121 */
                    int32_t *l_268 = &l_205;
lbl_298:
                    (*l_268) = ((int16_t)((func_98(l_205, p_91, p_94) || 0x4849B7B0) && 0x9F43FFAE) << (int16_t)l_267);
                    (*l_268) = p_91;
                    if (((uint16_t)1U >> (uint16_t)(func_98(p_94, p_94, p_94) < ((int32_t)((!((int16_t)func_102(((0x22B3 | (!((uint32_t)(p_94 | ((uint16_t)((*l_127) == (((uint16_t)((((*l_127) | 7U) >= 4) & (-1)) >> (uint16_t)p_94) && l_205)) << (uint16_t)l_192)) + (uint32_t)(*l_268)))) ^ 0x2F50), l_283, l_267, (*l_268), (***l_244)) + (int16_t)p_91)) >= 8U) + (int32_t)p_94))))
                    { /* block id: 124 */
                        float l_294 = (-0x8.2p-1);
                        float *l_293 = &l_294;
                        int32_t **l_296 = &l_268;
                        (*l_293) = (-(float)((float)((float)l_205 + (float)(func_98((*l_268), (((p_94 || (p_91 & ((uint16_t)(0x0519 != ((uint32_t)0xB6397410 - (uint32_t)4294967288U)) >> (uint16_t)7))) > (l_267 ^ (&p_92 == &p_92))) || (*l_127)), p_94) != p_93)) + (float)0x0.4p-1));
                        (*l_268) = (p_91 > p_91);
                        (*l_293) = 0x0.7p+1;
                        (*l_296) = l_295;
                    }
                    else
                    { /* block id: 129 */
                        const int32_t *l_297 = &l_205;
                        l_297 = &p_94;
                        /* statement id: 130 */
                        assert (l_297 == &p_94);
                    }
                    if (l_192)
                        goto lbl_298;
                }
                else
                { /* block id: 133 */
                    (*l_295) = (((int16_t)0x447D >> (int16_t)0) & 0xE336);
                    (*l_295) = (*l_295);
                    (*l_147) = l_301;
                }
                (*l_302) = &p_94;
                /* statement id: 138 */
                assert (l_295 == &p_94);
            }
            (*l_303) = (*l_127);
            for (l_205 = (-18); (l_205 > (-11)); l_205 += 4)
            { /* block id: 143 */
                return p_94;
            }
            (*l_307) = (-(float)(*l_303));
        }
        /* facts after branching */
        assert (l_127 == &p_94 || l_127 == &l_128);
        assert (l_150 == 0 || l_150 == &l_151 || l_150 == &p_92);
    }
    /* facts after branching */
    assert (l_127 == &p_94 || l_127 == &l_128 || l_127 == 0);
    assert (l_150 == 0 || l_150 == &l_151 || l_150 == &p_92);
    return p_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_98(uint32_t  p_99, uint32_t  p_100, const uint32_t  p_101)
{ /* block id: 51 */
    const int32_t l_123 = 3;
    float l_125 = 0x3.8p-1;
    float *l_124 = &l_125;
    uint32_t l_126 = 0x4734A2D5;
    (*l_124) = ((0xC.3E652Fp-9 >= 0x1.Dp-1) == (l_123 >= (&l_123 == &l_123)));
    (*l_124) = 0x1.9p+1;
    return l_126;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_102(int32_t  p_103, struct S0  p_104, const uint16_t  p_105, uint32_t  p_106, union U1  p_107)
{ /* block id: 41 */
    int32_t l_116 = 1;
    int32_t l_117 = 0xEF6A07EB;
    union U1 l_119 = {{-0x1.6p+1}};
    const union U1 *l_118 = &l_119;
    union U1 *l_121 = &l_119;
    union U1 **l_120 = &l_121;
    for (p_103 = 0; (p_103 == 27); p_103 += 1)
    { /* block id: 44 */
        int32_t *l_113 = (void*)0;
        l_113 = l_113;
    }
    l_117 = (((float)l_116 + (float)l_116) == p_107.f0.f0);
    (*l_120) = l_118;
    (*l_120) = (*l_120);
    return l_116;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 149
   depth: 1, occurrence: 5
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 48
breakdown:
   depth: 1, occurrence: 182
   depth: 2, occurrence: 19
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 25, occurrence: 1
   depth: 33, occurrence: 1
   depth: 48, occurrence: 1

XXX total number of pointers: 158

XXX times a variable address is taken: 173
XXX times a pointer is dereferenced on RHS: 79
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 108
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 245

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 257
   level: 2, occurrence: 44
   level: 3, occurrence: 7
XXX number of pointers point to pointers: 86
XXX number of pointers point to scalars: 51
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 17.7
XXX average alias set size: 1.22

XXX times a non-volatile is read: 755
XXX times a non-volatile is write: 274
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 8

XXX stmts: 147
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 30
   depth: 2, occurrence: 36
   depth: 3, occurrence: 19
   depth: 4, occurrence: 12
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 22.3
XXX percentage an existing variable is used: 77.7
********************* end of statistics **********************/

