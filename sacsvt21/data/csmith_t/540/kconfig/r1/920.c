/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2754490382
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 21;
   unsigned f1 : 22;
   signed : 0;
   unsigned f2 : 12;
   signed f3 : 11;
   unsigned f4 : 22;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_28(void);
static struct S0  func_29(const int32_t  p_30);
static struct S0  func_32(uint32_t  p_33, uint8_t  p_34);
inline static uint32_t  func_35(int32_t  p_36, int64_t  p_37, uint32_t  p_38);
inline static uint16_t  func_44(uint8_t  p_45, int64_t  p_46, int32_t  p_47);
static uint32_t  func_48(int64_t  p_49, uint64_t  p_50, uint32_t  p_51);
inline static struct S0  func_66(uint32_t  p_67, uint16_t  p_68, int32_t * p_69, const struct S0 ** p_70);
inline static int32_t * func_93(uint8_t  p_94, int32_t  p_95);
static uint8_t  func_96(struct S0 ** p_97, const int32_t  p_98, float  p_99, int64_t  p_100);
inline static const int16_t  func_102(const uint32_t  p_103, struct S0  p_104, int32_t  p_105, int32_t * const * p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_28(void)
{ /* block id: 36 */
    const uint32_t l_31 = 0x4307A329L;
    struct S0 l_722 = {1191,1061,52,-37,1459};
    struct S0 *l_721 = &l_722;
    int32_t l_724 = 0x86562BBEL;
    int32_t * const l_723 = &l_724;
    int32_t *l_726 = (void*)0;
    int32_t **l_725 = &l_726;
    int16_t l_730 = 1L;
    uint8_t l_733 = 0x05L;
    (*l_721) = func_29(l_31);
    (*l_721) = (*l_721);
    (*l_725) = l_723;
    /* statement id: 456 */
    assert (l_726 == &l_724);
    for (l_724 = 0; (l_724 != 0); ++l_724)
    { /* block id: 459 */
        uint8_t l_729 = 0UL;
        int32_t l_732 = 0L;
        int32_t *l_731 = &l_732;
        (*l_725) = (*l_725);
        (*l_731) = (l_729 > l_730);
    }
    return l_733;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_29(const int32_t  p_30)
{ /* block id: 37 */
    uint64_t l_41 = 0UL;
    struct S0 l_552 = {414,2003,18,-41,860};
    int32_t l_568 = (-1L);
    int32_t *l_567 = &l_568;
    const struct S0 *l_570 = &l_552;
    const struct S0 **l_569 = &l_570;
    int32_t *l_642 = &l_568;
    float l_652 = (-0x1.6p+1);
    const float *l_651 = &l_652;
    struct S0 l_720 = {829,918,32,-33,491};
    l_552 = func_32(func_35(((p_30 >= ((int16_t)(1L <= (-6L)) >> (int16_t)p_30)) <= l_41), (l_41 || ((uint16_t)func_44(p_30, ((func_48(((((int16_t)(((-(uint16_t)(p_30 == (((l_41 ^ p_30) && 1L) <= 0x66B3883FL))) < 6L) || l_41) + (int16_t)p_30) == l_41) <= 0xF438L), p_30, p_30) | 7UL) != p_30), l_41) % (uint16_t)l_41)), l_41), p_30);
lbl_572:
    if (l_552.f4)
    { /* block id: 338 */
        int64_t l_557 = 1L;
        int32_t l_563 = 0x3FB1D8F5L;
        int32_t *l_562 = &l_563;
        int32_t **l_561 = &l_562;
        int32_t ***l_560 = &l_561;
        int32_t ****l_559 = &l_560;
        int32_t ***** const l_558 = &l_559;
        (*l_562) = ((uint16_t)((int64_t)(l_557 < ((void*)0 != l_558)) + (int64_t)(p_30 < p_30)) + (uint16_t)0xB340L);
    }
    else
    { /* block id: 340 */
        float l_565 = 0x5.3p+1;
        float *l_564 = &l_565;
        int32_t l_566 = 0L;
        struct S0 *l_571 = &l_552;
        (*l_564) = p_30;
        (*l_571) = func_66(p_30, l_566, l_567, l_569);
    }
    if (p_30)
    { /* block id: 344 */
        int32_t *l_590 = &l_568;
        float l_596 = 0xD.BBA088p+29;
        float *l_595 = &l_596;
        float **l_594 = &l_595;
        float ***l_593 = &l_594;
        float ****l_592 = &l_593;
        int32_t **l_599 = (void*)0;
        int32_t ***l_598 = &l_599;
        struct S0 l_607 = {1090,896,7,17,283};
        if (p_30)
            goto lbl_572;
        for (l_41 = 0; (l_41 < 45); l_41 += 1)
        { /* block id: 348 */
            for (l_568 = 0; (l_568 <= (-18)); --l_568)
            { /* block id: 351 */
                int32_t l_577 = 0x3BD5E898L;
                for (l_577 = 11; (l_577 < 2); l_577 -= 8)
                { /* block id: 354 */
                    float *l_580 = (void*)0;
                    float *l_581 = (void*)0;
                    float *l_582 = (void*)0;
                    float l_584 = 0x2.6p-1;
                    float *l_583 = &l_584;
                    int32_t **l_585 = (void*)0;
                    int32_t **l_586 = (void*)0;
                    int32_t **l_587 = &l_567;
                    (*l_583) = p_30;
                    (*l_587) = &l_577;
                    /* statement id: 356 */
                    assert (l_567 == &l_577);
                }
                /* facts after for loop */
                //assert (l_567 == &l_577 || l_567 == dangling || l_567 == &l_568);
                for (l_577 = 2; (l_577 >= (-9)); l_577 -= 8)
                { /* block id: 360 */
                    int32_t **l_591 = &l_590;
                    float *****l_597 = &l_592;
                    (*l_591) = l_590;
                    (*l_597) = l_592;
                }
            }
            (*l_595) = ((l_598 != (void*)0) <= p_30);
        }
        /* facts after for loop */
        //assert (l_567 == dangling || l_567 == &l_568);
        for (l_41 = 0; (l_41 == 7); l_41 += 8)
        { /* block id: 369 */
            struct S0 l_604 = {1234,548,15,-12,1884};
            int64_t l_605 = 0xAF1305BE39B7CD2BLL;
            uint32_t l_608 = 0xF0EA038CL;
            float * const *l_611 = (void*)0;
            float * const **l_610 = &l_611;
            float * const ***l_609 = &l_610;
            const struct S0 **l_612 = &l_570;
            for (l_568 = 28; (l_568 < 27); l_568 -= 4)
            { /* block id: 372 */
                return l_604;
            }
            if (((0xE3B4L <= 3L) && (__builtin_clz((0L & ((__builtin_ffsl(func_44((p_30 >= func_102((0xF8173595L < ((p_30 > l_605) > (p_30 || (!p_30)))), l_607, p_30, &l_567)), (*l_590), l_604.f1)) != p_30) != l_608))) & 0x034AL)))
            { /* block id: 375 */
                uint32_t l_615 = 0xC44D9D80L;
                int32_t *l_616 = &l_568;
                l_604 = func_66(p_30, (p_30 > (l_609 != (void*)0)), &l_568, l_612);
                for (l_608 = 8; (l_608 == 33); ++l_608)
                { /* block id: 379 */
                    l_616 = func_93(l_615, p_30);
                    /* statement id: 380 */
                    assert (l_616 == 0);
                }
                /* facts after for loop */
                assert (l_616 == 0 || l_616 == &l_568);
                return l_607;
            }
            else
            { /* block id: 383 */
                struct S0 l_617 = {1071,276,31,33,848};
                struct S0 *l_618 = (void*)0;
                struct S0 *l_619 = (void*)0;
                l_617 = l_617;
                l_567 = func_93(l_617.f3, ((uint16_t)(&l_569 != (void*)0) >> (uint16_t)5));
                /* statement id: 385 */
                assert (l_567 == 0);
                (*l_590) = ((int16_t)l_617.f2 << (int16_t)12);
                if (p_30)
                    break;
            }
            /* facts after branching */
            assert (l_567 == 0);
            return l_607;
        }
        /* facts after for loop */
        //assert (l_567 == 0 || l_567 == dangling || l_567 == &l_568);
    }
    else
    { /* block id: 391 */
        int32_t **l_626 = &l_567;
        float l_683 = (-0x7.Fp-1);
        const uint32_t l_704 = 0x26312D90L;
        struct S0 ** const *l_708 = (void*)0;
        struct S0 ** const **l_707 = &l_708;
        (*l_626) = func_93((*l_567), ((uint16_t)(*l_567) << (uint16_t)8));
        /* statement id: 392 */
        assert (l_567 == 0);
        if (p_30)
        { /* block id: 393 */
            float *l_629 = (void*)0;
            float l_631 = 0xD.3C436Cp+11;
            float *l_630 = &l_631;
            int32_t l_634 = 0xE1EBB0A2L;
            struct S0 *l_639 = &l_552;
            int32_t l_670 = (-1L);
            int32_t **l_675 = &l_642;
            (*l_626) = func_93(p_30, p_30);
            (*l_630) = ((float)p_30 - (float)p_30);
            for (l_568 = 0; (l_568 >= (-16)); l_568--)
            { /* block id: 398 */
                struct S0 l_637 = {952,1289,57,24,211};
                int32_t * const *l_656 = &l_567;
                int32_t *l_659 = &l_634;
                int32_t *l_674 = &l_670;
                if (l_634)
                { /* block id: 399 */
                    uint32_t l_635 = 0x7892C705L;
                    const struct S0 **l_636 = (void*)0;
                    struct S0 *l_638 = &l_552;
                    (*l_638) = l_637;
                    (*l_626) = func_93(l_635, p_30);
                    /* statement id: 401 */
                    assert (l_567 == 0);
                    (*l_569) = l_639;
                }
                else
                { /* block id: 403 */
                    float *l_653 = &l_631;
                    for (l_41 = 0; (l_41 > 14); ++l_41)
                    { /* block id: 406 */
                        if (p_30)
                            break;
                        if (p_30)
                            continue;
                    }
                    (*l_626) = l_642;
                    /* statement id: 410 */
                    assert (l_567 == &l_568);
                    l_637.f3 = (((uint16_t)((int16_t)(*l_567) + (int16_t)(*l_642)) - (uint16_t)p_30) < ((func_102((((int64_t)p_30 % (int64_t)(*l_567)) <= ((int16_t)(l_651 != l_653) >> (int16_t)((int32_t)p_30 / (int32_t)(**l_626)))), (*l_570), p_30, l_656) <= p_30) <= 1UL));
                    (*l_569) = (*l_569);
                }
                (*l_630) = l_634;
                for (l_41 = 0; (l_41 < 18); ++l_41)
                { /* block id: 417 */
                    uint16_t l_662 = 0x10B5L;
                    float *l_671 = &l_631;
                    (*l_639) = (*l_639);
                    l_659 = func_93(p_30, p_30);
                    /* statement id: 419 */
                    assert (l_659 == 0);
                    for (l_634 = 19; (l_634 == 10); l_634--)
                    { /* block id: 422 */
                        struct S0 **l_663 = (void*)0;
                        int32_t l_669 = 0xA343B23DL;
                        int32_t *l_672 = (void*)0;
                        int32_t *l_673 = &l_670;
                        l_662 = p_30;
                        l_670 = func_96(l_663, ((uint32_t)(p_30 || ((-(int16_t)(func_44(p_30, ((int16_t)__builtin_ffsll(((l_634 || l_669) | __builtin_ffsl(p_30))) >> (int16_t)11), (p_30 >= p_30)) || p_30)) < (*l_642))) + (uint32_t)p_30), l_669, l_669);
                        (*l_673) = ((void*)0 != l_671);
                        if (p_30)
                            break;
                    }
                }
                /* facts after for loop */
                assert (l_659 == 0 || l_659 == &l_634);
                (*l_674) = p_30;
            }
            /* facts after for loop */
            assert (l_567 == &l_568 || l_567 == 0);
            (*l_642) = (l_675 == (void*)0);
        }
        else
        { /* block id: 432 */
            int32_t l_676 = 2L;
            int32_t * const *l_690 = &l_567;
            struct S0 l_715 = {1021,811,8,-18,1438};
            int32_t *l_719 = &l_676;
            if ((((((l_676 <= (((((((int16_t)1L + (int16_t)(&l_567 == l_626)) < 0xB01595E7L) != ((uint32_t)((uint16_t)(*l_642) << (uint16_t)4) / (uint32_t)(p_30 ^ 5UL))) ^ ((uint16_t)((int64_t)((uint16_t)l_676 >> (uint16_t)12) / (int64_t)18446744073709551615UL) >> (uint16_t)l_676)) & p_30) || p_30)) == l_676) || (-1L)) <= p_30) || l_676))
            { /* block id: 433 */
                (*l_642) = (l_690 == (void*)0);
            }
            else
            { /* block id: 435 */
                int32_t **l_703 = (void*)0;
                const struct S0 **l_705 = &l_570;
                if (__builtin_ctzll(p_30))
                { /* block id: 436 */
                    uint32_t l_702 = 0xD8EDF34DL;
                    struct S0 *l_706 = &l_552;
                    (*l_706) = func_66((((uint16_t)((int16_t)(*l_642) << (int16_t)(((p_30 ^ ((int16_t)((int64_t)4L - (int64_t)((*l_626) == (*l_626))) + (int16_t)(0x81B8L && (+l_702)))) != p_30) > (((void*)0 == l_703) <= l_704))) % (uint16_t)0xD53EL) >= (-10L)), p_30, &l_568, l_705);
                }
                else
                { /* block id: 438 */
                    struct S0 *****l_709 = (void*)0;
                    struct S0 *l_714 = (void*)0;
                    struct S0 **l_713 = &l_714;
                    struct S0 ***l_712 = &l_713;
                    struct S0 ****l_711 = &l_712;
                    struct S0 *****l_710 = &l_711;
                    int32_t l_716 = 3L;
                    (*l_710) = l_707;
                    /* statement id: 439 */
                    assert (l_711 == &l_708);
                    l_552 = l_715;
                    (*l_642) = l_716;
                }
                for (l_41 = 0; (l_41 == 24); l_41 += 3)
                { /* block id: 445 */
                    (*l_626) = l_719;
                    /* statement id: 446 */
                    assert (l_567 == &l_676);
                    return l_715;
                }
            }
            l_567 = &l_568;
            /* statement id: 450 */
            assert (l_567 == &l_568);
        }
        /* facts after branching */
        assert (l_567 == &l_568 || l_567 == 0);
    }
    /* facts after branching */
    //assert (l_567 == 0 || l_567 == dangling || l_567 == &l_568);
    return l_720;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_32(uint32_t  p_33, uint8_t  p_34)
{ /* block id: 330 */
    struct S0 l_551 = {688,498,30,-37,1221};
    for (p_33 = 0; (p_33 >= 10); ++p_33)
    { /* block id: 333 */
        return l_551;
    }
    return l_551;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_35(int32_t  p_36, int64_t  p_37, uint32_t  p_38)
{ /* block id: 145 */
    uint32_t l_221 = 0xBCE40628L;
    struct S0 l_226 = {143,457,26,4,22};
    struct S0 *l_225 = &l_226;
    struct S0 **l_224 = &l_225;
    float l_230 = 0x9.CFE17Ap+58;
    float *l_229 = &l_230;
    int32_t ***l_244 = (void*)0;
    int32_t l_286 = 0xD78F5A50L;
    int32_t * const l_285 = &l_286;
    int32_t * const *l_284 = &l_285;
    int32_t *l_292 = &l_286;
    int32_t **l_291 = &l_292;
    float **l_300 = &l_229;
    const int32_t **l_320 = (void*)0;
    const int32_t ***l_319 = &l_320;
    const int32_t ****l_318 = &l_319;
    const int32_t ***** const l_317 = &l_318;
    struct S0 ***l_394 = (void*)0;
    struct S0 **** const l_393 = &l_394;
    const struct S0 *l_424 = &l_226;
    const struct S0 **l_423 = &l_424;
    uint32_t l_476 = 0x3F769CEDL;
    const int32_t *l_489 = &l_286;
    int64_t l_498 = (-7L);
    uint32_t l_533 = 4UL;
    const float l_537 = 0x1.Ap+1;
    (*l_229) = (((l_221 != ((l_221 == ((float)(l_221 <= (l_224 != &l_225)) / (float)p_37)) < l_226.f2)) == p_37) != ((float)l_226.f2 / (float)p_36));
    if ((((int64_t)((*l_224) != (void*)0) + (int64_t)(+l_221)) && ((0xEAFE74C3FBF1EE3ALL >= p_36) | (&p_36 == &p_36))))
    { /* block id: 147 */
        int16_t l_243 = 2L;
        struct S0 l_255 = {239,233,17,-39,386};
        const int32_t l_260 = (-1L);
        const int32_t *l_259 = &l_260;
        int32_t l_264 = 0x79115ADDL;
        int32_t *l_263 = &l_264;
        for (l_221 = (-10); (l_221 >= 5); l_221 += 1)
        { /* block id: 150 */
            uint8_t l_256 = 5UL;
            const struct S0 *l_266 = &l_226;
            const struct S0 **l_265 = &l_266;
            for (p_36 = 14; (p_36 != (-17)); p_36--)
            { /* block id: 153 */
                uint64_t l_240 = 0x696A6714CD73731CLL;
                int32_t l_248 = 0x956AC2A1L;
                int32_t *l_247 = &l_248;
                (*l_247) = ((int64_t)(func_44(((l_240 && p_36) != (((uint16_t)l_243 + (uint16_t)l_226.f3) > (l_244 != l_244))), l_240, ((uint16_t)0x3F69L << (uint16_t)l_240)) ^ 0xC4A1L) / (int64_t)(-1L));
            }
            for (p_36 = 0; (p_36 <= (-17)); p_36 -= 2)
            { /* block id: 158 */
                float l_251 = 0x1.AF97BAp-63;
                int32_t *l_252 = (void*)0;
                int32_t l_254 = 0xDBE5E4B7L;
                int32_t *l_253 = &l_254;
                int32_t **l_262 = &l_252;
                int32_t ***l_261 = &l_262;
                (*l_253) = (p_37 < p_38);
                l_255 = l_255;
                (*l_225) = func_66(l_256, func_48((((9UL >= 0x544C11F17EFCA105LL) != (((int16_t)(func_44(((void*)0 == l_259), ((void*)0 == l_261), (p_36 & 0xEE4FC8B5L)) > p_38) << (int16_t)p_38) > p_38)) & p_38), l_256, p_37), l_263, l_265);
            }
        }
    }
    else
    { /* block id: 164 */
        const int16_t l_267 = 0xC627L;
        struct S0 l_268 = {323,1046,31,-34,1747};
        int32_t ****l_275 = &l_244;
        int32_t *l_279 = (void*)0;
        int32_t * const * const l_278 = &l_279;
        const struct S0 *l_309 = &l_268;
        const struct S0 **l_308 = &l_309;
        const struct S0 ** const *l_307 = &l_308;
        uint32_t l_346 = 0UL;
        int32_t l_455 = 1L;
        float l_525 = 0xD.ADF17Ap-85;
        if ((func_102(l_267, l_268, ((int64_t)(((int32_t)((uint16_t)(((void*)0 != l_275) || (l_268.f3 > ((int16_t)((void*)0 == l_278) << (int16_t)__builtin_ctzl((((uint16_t)((uint64_t)p_36 + (uint64_t)0x06967E034972C2B5LL) >> (uint16_t)p_37) || 0UL))))) / (uint16_t)p_37) + (int32_t)0x006CAC7DL) >= p_36) % (int64_t)0xA1E260467133BA4ALL), l_284) >= p_37))
        { /* block id: 165 */
            int32_t **l_289 = &l_279;
            int32_t l_311 = 0x2F53F702L;
            const struct S0 **l_376 = (void*)0;
            int32_t *l_380 = &l_286;
            int16_t l_392 = (-5L);
            if (((uint16_t)(((l_289 == (void*)0) && p_37) <= (!((p_37 < __builtin_ctzl(p_36)) < (((p_36 > (**l_284)) || (((l_291 != (void*)0) && (*l_292)) <= 4294967295UL)) || p_38)))) >> (uint16_t)10))
            { /* block id: 166 */
                float ** const l_299 = &l_229;
                int32_t *l_301 = &l_286;
                const struct S0 *l_304 = &l_226;
                const struct S0 **l_303 = &l_304;
                const struct S0 ** const *l_302 = &l_303;
                int32_t **l_337 = &l_279;
                for (p_36 = (-4); (p_36 < 5); p_36 += 7)
                { /* block id: 169 */
                    struct S0 ****l_305 = (void*)0;
                    struct S0 ****l_306 = (void*)0;
                    int32_t l_310 = 0x57D04D9EL;
                    for (p_37 = 0; (p_37 <= 27); p_37 += 1)
                    { /* block id: 172 */
                        uint32_t l_297 = 0xCD65A0D8L;
                        int32_t *****l_298 = &l_275;
                        if (l_297)
                            break;
                        (*l_298) = &l_244;
                        l_300 = l_299;
                        if (p_37)
                            continue;
                    }
                    (*l_289) = l_301;
                    /* statement id: 178 */
                    assert (l_279 == &l_286);
                    l_307 = l_302;
                    /* statement id: 179 */
                    assert (l_307 == &l_303);
                    if (p_36)
                    { /* block id: 180 */
                        (*l_279) = 0L;
                    }
                    else
                    { /* block id: 182 */
                        (*l_225) = (**l_308);
                        (*l_301) = l_310;
                        (*l_291) = &p_36;
                        /* statement id: 185 */
                        assert (l_292 == &p_36);
                    }
                }
                /* facts after for loop */
                assert (l_279 == &l_286 || l_279 == 0);
                assert (l_292 == &p_36 || l_292 == &l_286);
                assert (l_307 == &l_303 || l_307 == &l_308);
lbl_348:
                (**l_299) = (p_37 == l_311);
                for (l_286 = (-22); (l_286 <= (-22)); l_286++)
                { /* block id: 191 */
                    const int64_t l_325 = 1L;
                    (*l_289) = func_93(p_37, l_311);
                    /* statement id: 192 */
                    assert (l_279 == 0);
                    for (p_37 = 6; (p_37 < 11); p_37 += 3)
                    { /* block id: 195 */
                        int32_t *****l_316 = (void*)0;
                        struct S0 * const * const l_328 = &l_225;
                        struct S0 * const * const *l_327 = &l_328;
                        struct S0 * const * const **l_326 = &l_327;
                        l_311 = (l_316 == l_317);
                        (*l_229) = ((float)((float)l_325 + (float)(p_36 <= (p_37 == (p_38 == (*l_301))))) - (float)(l_326 == &l_327));
                    }
                    if ((&l_318 != &l_275))
                    { /* block id: 199 */
                        int16_t l_347 = 0L;
                        p_36 = __builtin_bswap64((p_38 || ((uint32_t)((p_37 | (!p_38)) < (p_37 >= ((uint32_t)((((int16_t)(-(int32_t)__builtin_clz((((&l_301 == l_337) || (*l_301)) | ((int16_t)(1UL < ((int16_t)((int64_t)((uint16_t)((((p_37 <= p_36) ^ 1L) <= p_36) <= 0x6AF9089C4C44AEB9LL) % (uint16_t)0x8E14L) % (int64_t)p_36) >> (int16_t)l_346)) << (int16_t)0)))) >> (int16_t)4) || 0x8543L) <= p_37) + (uint32_t)0x5CE0B114L))) / (uint32_t)l_347)));
                    }
                    else
                    { /* block id: 201 */
                        if (l_268.f3)
                            goto lbl_348;
                    }
                }
                (*l_285) = p_36;
            }
            else
            { /* block id: 206 */
                const uint8_t l_373 = 0x27L;
                int32_t *l_375 = &l_311;
                const struct S0 **l_381 = (void*)0;
                for (l_346 = 0; (l_346 != 32); l_346 += 8)
                { /* block id: 209 */
                    int32_t l_367 = 0xD664D865L;
                    struct S0 **l_372 = &l_225;
                    int32_t l_374 = (-1L);
                    for (l_311 = 12; (l_311 != 14); l_311++)
                    { /* block id: 212 */
                        int32_t l_377 = 0L;
                        struct S0 l_378 = {1103,151,29,-40,980};
                        (*l_229) = ((float)((float)0x8.3F7F71p+53 - (float)((float)((float)0x0.BC73D2p+88 + (float)p_37) + (float)func_102(((uint32_t)((int16_t)p_36 << (int16_t)((uint32_t)(&l_289 == (*l_275)) % (uint32_t)l_367)) / (uint32_t)(**l_284)), (**l_308), p_37, l_289))) - (float)l_377);
                        l_268 = l_378;
                        (*l_285) = l_311;
                        (**l_224) = func_66((!0x21DDFA2FL), (*l_375), &l_377, &l_309);
                    }
                }
                (**l_224) = (*l_225);
            }
            /* facts after branching */
            assert (l_279 == &l_286 || l_279 == 0);
            assert (l_292 == &p_36 || l_292 == &l_286);
            //assert (l_307 == dangling || l_307 == &l_308);
            (*l_292) = (((int16_t)((void*)0 != (*l_308)) >> (int16_t)(p_38 | (((uint32_t)p_36 + (uint32_t)(p_36 < (((uint16_t)p_37 % (uint16_t)0x84CFL) != p_36))) > ((*l_380) != p_36)))) & p_36);
            (*l_289) = &p_36;
            /* statement id: 222 */
            assert (l_279 == &p_36);
            if ((*l_279))
            { /* block id: 223 */
                (**l_284) = p_36;
            }
            else
            { /* block id: 225 */
                float l_395 = 0x3.576BE4p-73;
                int32_t l_396 = 0L;
                (**l_278) = (((int32_t)func_44(((p_37 | p_37) > (l_392 ^ (l_393 == (void*)0))), p_36, l_396) + (int32_t)((int32_t)0xDCA199E2L - (int32_t)4294967294UL)) && (*l_285));
                for (l_311 = 0; (l_311 <= 12); l_311++)
                { /* block id: 229 */
                    for (p_38 = (-13); (p_38 >= 13); p_38 += 7)
                    { /* block id: 232 */
                        float ****l_403 = (void*)0;
                        float ***l_405 = &l_300;
                        float ****l_404 = &l_405;
                        int32_t l_410 = 0x117E6388L;
                        (*l_404) = &l_300;
                        (*l_289) = func_93(func_48(func_48(l_396, p_36, l_396), __builtin_popcount(((int16_t)(~((+(p_38 >= ((*l_292) & l_410))) == (**l_284))) - (int16_t)p_38)), l_410), p_38);
                        /* statement id: 234 */
                        assert (l_279 == 0);
                        (***l_405) = p_37;
                        (*l_291) = &p_36;
                        /* statement id: 236 */
                        assert (l_292 == &p_36);
                    }
                }
                /* facts after for loop */
                assert (l_279 == 0 || l_279 == &p_36);
            }
            /* facts after branching */
            assert (l_279 == 0 || l_279 == &p_36);
        }
        else
        { /* block id: 240 */
            uint64_t l_420 = 1UL;
            const int32_t *l_471 = &l_286;
            struct S0 *l_479 = &l_226;
            int32_t l_501 = 0x4EFD52D6L;
            float *l_504 = &l_230;
            int32_t l_511 = 0xAE204A08L;
            const struct S0 **l_524 = &l_309;
            uint16_t l_536 = 65532UL;
            if (p_37)
            { /* block id: 241 */
                uint64_t l_411 = 0x0AD2DAEC199B82E7LL;
                uint8_t l_421 = 1UL;
                int32_t *l_422 = &l_286;
                int64_t l_442 = 1L;
                if (func_102(p_38, func_66(l_411, func_48(((int16_t)(1L == __builtin_ffsll(p_37)) >> (int16_t)p_36), (__builtin_parity(p_38) & (((uint16_t)func_48(((func_44(((((int64_t)l_420 % (int64_t)0xA9ACF57F94C00EDCLL) != p_38) <= p_38), p_36, l_411) > p_38) & 0L), l_421, l_411) >> (uint16_t)p_37) & p_38)), p_38), l_422, l_423), p_36, &l_422))
                { /* block id: 242 */
                    struct S0 *****l_425 = (void*)0;
                    struct S0 ****l_427 = &l_394;
                    struct S0 *****l_426 = &l_427;
                    const int32_t l_437 = 1L;
                    (*l_426) = &l_307;
                    /* statement id: 243 */
                    assert (l_427 == &l_307);
                    for (l_286 = 0; (l_286 >= (-25)); l_286--)
                    { /* block id: 246 */
                        const uint8_t l_450 = 1UL;
                        if ((**l_284))
                            break;
                        p_36 = ((+((uint16_t)((*l_422) < (((int16_t)((int16_t)p_36 >> (int16_t)func_102(l_437, (**l_308), (((int64_t)(__builtin_clz((0xAF7EL || p_36)) <= ((uint32_t)((&p_36 == l_422) >= l_442) + (uint32_t)p_37)) / (int64_t)0x94C1EBE15FA46FF5LL) > p_38), &l_422)) << (int16_t)10) <= l_420)) % (uint16_t)0xBBA3L)) >= 8L);
                        p_36 = ((uint16_t)((((6UL && l_420) != p_36) == ((uint64_t)((int16_t)p_38 << (int16_t)3) / (uint64_t)(+l_450))) || 0xC98CL) >> (uint16_t)2);
                    }
lbl_453:
                    (*l_225) = (****l_427);
                    for (l_346 = 0; (l_346 < 6); l_346 += 3)
                    { /* block id: 254 */
                        int32_t *l_454 = &l_286;
                        if (l_268.f3)
                            goto lbl_453;
                        l_454 = (void*)0;
                        /* statement id: 256 */
                        assert (l_454 == 0);
                        (*l_229) = ((l_455 == ((float)(-(float)(**l_284)) + (float)((float)((float)p_36 + (float)0xC.4E6D25p+15) / (float)((float)p_38 / (float)((float)((float)(((float)0xD.F58C2Dp-57 - (float)l_420) > l_420) + (float)p_38) + (float)p_37))))) >= p_37);
                        l_471 = &l_437;
                        /* statement id: 258 */
                        assert (l_471 == &l_437);
                    }
                }
                else
                { /* block id: 260 */
                    struct S0 ****l_473 = &l_394;
                    struct S0 ***** const l_472 = &l_473;
                    p_36 = (&l_393 != l_472);
                }
                /* facts after branching */
                //assert (l_471 == dangling || l_471 == &l_286);
                for (p_38 = 0; (p_38 <= 21); p_38 += 2)
                { /* block id: 265 */
                    return l_476;
                }
                (*l_285) = ((*l_292) | 1UL);
            }
            else
            { /* block id: 269 */
                int64_t l_480 = 0x15FCD975478798FFLL;
                float ***l_487 = &l_300;
                float ****l_486 = &l_487;
                float ***** const l_485 = &l_486;
                int32_t *l_493 = (void*)0;
                l_480 = (((float)(l_479 != l_479) + (float)p_36) > p_38);
                if (((uint32_t)p_38 - (uint32_t)((int64_t)p_36 - (int64_t)p_37)))
                { /* block id: 271 */
                    float *****l_488 = &l_486;
                    l_488 = l_485;
                }
                else
                { /* block id: 273 */
                    struct S0 l_492 = {115,821,14,10,1321};
                    l_471 = l_489;
                    (*l_393) = (void*)0;
                    for (l_420 = (-2); (l_420 < 5); l_420++)
                    { /* block id: 278 */
                        (*l_291) = &p_36;
                        /* statement id: 279 */
                        assert (l_292 == &p_36);
                        (*l_285) = (*l_285);
                        (*l_479) = l_492;
                    }
                    /* facts after for loop */
                    assert (l_292 == &p_36 || l_292 == &l_286);
                    l_471 = &p_36;
                    /* statement id: 283 */
                    assert (l_471 == &p_36);
                }
                /* facts after branching */
                assert (l_292 == &p_36 || l_292 == &l_286);
                assert (l_471 == &p_36 || l_471 == &l_286);
                l_493 = &p_36;
                /* statement id: 285 */
                assert (l_493 == &p_36);
                for (l_480 = 20; (l_480 == (-17)); l_480--)
                { /* block id: 288 */
                    float ****l_496 = &l_487;
                    struct S0 **l_497 = &l_225;
                    l_501 = ((((void*)0 != l_496) == func_96(l_497, p_38, l_498, p_38)) > ((p_37 == ((float)(p_36 >= p_38) / (float)(*l_471))) > p_36));
                }
            }
            /* facts after branching */
            assert (l_292 == &p_36 || l_292 == &l_286);
            //assert (l_471 == &p_36 || l_471 == &l_286 || l_471 == dangling);
            (**l_300) = p_38;
            for (p_36 = (-9); (p_36 < 18); p_36 += 7)
            { /* block id: 295 */
                float l_518 = (-0x1.8p+1);
                int32_t l_522 = 0xF69D9B00L;
                if ((l_504 != (void*)0))
                { /* block id: 296 */
                    int32_t *l_523 = &l_522;
                    for (l_501 = 0; (l_501 != 8); l_501 += 8)
                    { /* block id: 299 */
                        uint32_t l_519 = 18446744073709551615UL;
                        l_268 = func_66(((uint32_t)1UL - (uint32_t)((uint64_t)l_511 + (uint64_t)p_38)), ((int16_t)((int16_t)__builtin_ffsll((((p_37 <= ((uint32_t)(l_519 ^ ((l_279 != (*l_300)) | ((p_38 || p_36) >= p_38))) + (uint32_t)4294967289UL)) ^ p_38) ^ p_38)) << (int16_t)l_522) >> (int16_t)l_519), l_523, l_524);
                    }
                    if (p_38)
                        continue;
                }
                else
                { /* block id: 303 */
                    uint32_t l_526 = 0x6B108838L;
                    (*l_291) = func_93(l_526, l_526);
                    /* statement id: 304 */
                    assert (l_292 == 0);
                    (*l_524) = (**l_307);
                }
            }
            /* facts after for loop */
            assert (l_292 == 0 || l_292 == &p_36 || l_292 == &l_286);
            if ((((uint16_t)(*l_489) >> (uint16_t)15) < ((p_38 != 18446744073709551606UL) > (((int32_t)((uint16_t)(func_44(l_533, p_36, ((uint32_t)((p_38 <= ((-10L) && (l_536 ^ ((&l_308 == &l_524) == 0x34A36F62L)))) == p_38) - (uint32_t)p_37)) == p_36) >> (uint16_t)0) - (int32_t)1UL) < l_511))))
            { /* block id: 308 */
                int32_t *l_538 = &l_286;
                l_538 = (void*)0;
                /* statement id: 309 */
                assert (l_538 == 0);
            }
            else
            { /* block id: 310 */
                int32_t *l_539 = (void*)0;
                (*l_225) = (**l_524);
                (*l_291) = l_539;
                /* statement id: 312 */
                assert (l_292 == 0);
            }
        }
        /* facts after branching */
        assert (l_279 == 0 || l_279 == &p_36);
        assert (l_292 == 0 || l_292 == &p_36 || l_292 == &l_286);
        //assert (l_307 == dangling || l_307 == &l_308);
    }
    /* facts after branching */
    assert (l_292 == 0 || l_292 == &p_36 || l_292 == &l_286);
    for (p_37 = (-10); (p_37 != (-18)); p_37 -= 4)
    { /* block id: 318 */
        struct S0 * const **l_543 = (void*)0;
        struct S0 * const ***l_542 = &l_543;
        const float **l_547 = (void*)0;
        const float ***l_546 = &l_547;
        const float ****l_545 = &l_546;
        const float *****l_544 = &l_545;
        p_36 = __builtin_bswap64((*l_285));
        (*l_229) = 0x9.Fp-1;
        if (((*l_489) > (l_542 != &l_394)))
        { /* block id: 321 */
            uint32_t l_548 = 4UL;
            l_548 = ((void*)0 == l_544);
            return p_38;
        }
        else
        { /* block id: 324 */
            (*l_291) = &p_36;
            /* statement id: 325 */
            assert (l_292 == &p_36);
            (**l_300) = p_38;
        }
        /* facts after branching */
        assert (l_292 == &p_36);
    }
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_44(uint8_t  p_45, int64_t  p_46, int32_t  p_47)
{ /* block id: 46 */
    struct S0 *l_63 = (void*)0;
    struct S0 **l_64 = (void*)0;
    struct S0 **l_65 = &l_63;
    int32_t l_71 = 0x513E67DCL;
    struct S0 l_80 = {211,1311,57,-21,1900};
    const struct S0 *l_79 = &l_80;
    const struct S0 **l_78 = &l_79;
    struct S0 *l_81 = &l_80;
    uint64_t l_112 = 0UL;
    int32_t * const *l_113 = (void*)0;
    int32_t l_206 = 1L;
    int32_t *l_213 = &l_71;
    int32_t **l_212 = &l_213;
    int32_t ***l_211 = &l_212;
    int32_t **** const l_210 = &l_211;
    int32_t *l_219 = (void*)0;
    uint16_t l_220 = 65535UL;
    (*l_65) = l_63;
    (*l_81) = func_66(l_71, (__builtin_clzll(p_47) && (l_71 != (~(p_45 ^ ((((((void*)0 != (*l_65)) > ((uint16_t)(-(int32_t)0x6DFF6173L) >> (uint16_t)11)) > p_47) && l_71) == 0x0F1D91A4AC155EA0LL))))), &l_71, l_78);
    if (((((l_80.f4 == l_80.f3) >= (p_45 <= ((uint64_t)(l_71 <= ((((int16_t)(+(-(int32_t)(((uint32_t)(0xD6318E2BB11FE8BELL || l_80.f3) + (uint32_t)__builtin_ctz((0x59FEL < ((int16_t)p_46 >> (int16_t)1)))) | 0xC662L))) % (int16_t)p_45) > l_80.f1) < l_80.f0)) - (uint64_t)p_47))) && 0x56D6BBB2L) & p_46))
    { /* block id: 51 */
        int32_t *l_92 = &l_71;
        struct S0 **l_101 = &l_81;
        const int32_t l_107 = (-5L);
        int32_t **l_199 = &l_92;
        (*l_92) = 0L;
        (*l_199) = func_93(func_96(l_101, (*l_92), p_46, ((*l_92) && ((p_47 >= func_102(l_107, (**l_101), ((uint64_t)((int64_t)(l_112 ^ (p_47 < p_46)) - (int64_t)l_80.f4) - (uint64_t)0xD0BAECBAC114349BLL), l_113)) != p_46))), l_80.f4);
        /* statement id: 137 */
        assert (l_92 == 0);
    }
    else
    { /* block id: 138 */
        int32_t *l_200 = &l_71;
        int32_t **l_201 = &l_200;
        const struct S0 **l_207 = &l_79;
        float l_218 = 0x6.FEC1EDp-70;
        float *l_217 = &l_218;
        (*l_201) = l_200;
        (*l_81) = func_66(p_46, (((uint32_t)l_80.f1 % (uint32_t)((uint16_t)(p_47 ^ ((**l_201) ^ __builtin_popcountl(p_46))) << (uint16_t)(((((*l_201) != &p_47) ^ p_46) < (**l_201)) || l_206))) != p_45), &l_71, l_207);
        (*l_217) = ((((float)(((void*)0 == l_210) > p_45) / (float)(***l_211)) <= (+(p_45 == (((float)((&l_210 == (void*)0) > func_102(p_46, (**l_207), (**l_201), (*l_211))) - (float)(*l_200)) <= (*l_213))))) >= p_47);
        (***l_210) = l_219;
        /* statement id: 142 */
        assert (l_213 == 0);
    }
    /* facts after branching */
    assert (l_213 == 0 || l_213 == &l_71);
    return l_220;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_48(int64_t  p_49, uint64_t  p_50, uint32_t  p_51)
{ /* block id: 38 */
    uint8_t l_55 = 0UL;
    int32_t l_62 = 7L;
    int32_t *l_61 = &l_62;
    int32_t **l_60 = &l_61;
    if (l_55)
    { /* block id: 39 */
        int32_t l_57 = 1L;
        const int32_t *l_56 = &l_57;
        int32_t *l_59 = &l_57;
        int32_t **l_58 = &l_59;
        (*l_58) = l_56;
    }
    else
    { /* block id: 41 */
        return p_50;
    }
    l_60 = l_60;
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_66(uint32_t  p_67, uint16_t  p_68, int32_t * p_69, const struct S0 ** p_70)
{ /* block id: 48 */
    return (**p_70);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_93(uint8_t  p_94, int32_t  p_95)
{ /* block id: 60 */
    uint16_t l_122 = 3UL;
    const struct S0 l_134 = {1323,129,49,9,1746};
    const struct S0 *l_133 = &l_134;
    const struct S0 **l_132 = &l_133;
    int32_t l_138 = 0xCED7563FL;
    int32_t *l_137 = &l_138;
    uint32_t l_178 = 0UL;
    int32_t l_183 = 0L;
    int32_t *l_192 = &l_138;
    int32_t *l_193 = &l_138;
    int32_t *l_194 = &l_138;
    int32_t *l_195 = &l_138;
    int32_t *l_196 = &l_138;
    int32_t *l_197 = &l_138;
    int32_t *l_198 = (void*)0;
    for (p_94 = 22; (p_94 < 27); p_94++)
    { /* block id: 63 */
        uint16_t l_121 = 0xF3EFL;
        const int32_t *l_125 = (void*)0;
        int32_t l_136 = 0x19192873L;
        int32_t *l_135 = &l_136;
        struct S0 l_143 = {1179,1878,44,-34,991};
        const struct S0 **l_163 = &l_133;
        uint32_t l_168 = 0xACD93D51L;
        int32_t l_177 = 9L;
        int32_t **l_190 = &l_137;
        int32_t ** const *l_189 = &l_190;
        int32_t ** const **l_188 = &l_189;
        if ((l_121 > p_94))
        { /* block id: 64 */
            if (l_122)
                break;
        }
        else
        { /* block id: 66 */
            struct S0 l_128 = {571,873,9,41,680};
            struct S0 * const l_127 = &l_128;
            struct S0 * const * const l_126 = &l_127;
            int32_t *l_131 = (void*)0;
            struct S0 l_142 = {889,869,26,-28,1295};
            uint8_t l_158 = 1UL;
            for (p_95 = (-7); (p_95 >= 4); p_95++)
            { /* block id: 69 */
                float l_129 = (-0x1.9p+1);
                int32_t *l_139 = &l_138;
                struct S0 *l_141 = &l_128;
                struct S0 **l_140 = &l_141;
                int32_t **l_149 = &l_139;
                if (((p_95 <= (((void*)0 != l_125) <= p_94)) != (l_126 != (void*)0)))
                { /* block id: 70 */
                    uint32_t l_130 = 1UL;
                    if (l_130)
                    { /* block id: 71 */
                        (*l_127) = func_66(l_122, l_128.f3, l_131, l_132);
                        (**l_126) = (**l_132);
                    }
                    else
                    { /* block id: 74 */
                        return l_131;
                        /* statement id: 75 */
                        //assert (func_93_rv == 0);
                    }
                    if (p_95)
                        break;
                    (*l_135) = func_96(l_140, ((*l_139) & (*l_139)), (*l_139), p_94);
                }
                else
                { /* block id: 79 */
                    int32_t ***l_146 = (void*)0;
                    int32_t **l_148 = (void*)0;
                    int32_t ***l_147 = &l_148;
                    l_143 = l_142;
                    (*l_139) = (p_95 <= ((float)p_94 + (float)((void*)0 != &l_141)));
                    (*l_147) = &l_139;
                    /* statement id: 82 */
                    assert (l_148 == &l_139);
                    (*l_148) = &l_138;
                }
                (*l_149) = &l_136;
                /* statement id: 85 */
                assert (l_139 == &l_136);
            }
            if (((*l_135) ^ (*l_137)))
            { /* block id: 87 */
                return l_131;
                /* statement id: 88 */
                //assert (func_93_rv == 0);
            }
            else
            { /* block id: 89 */
                for (l_138 = (-24); (l_138 != (-2)); ++l_138)
                { /* block id: 92 */
                    int32_t *l_154 = &l_136;
                    for (l_121 = 0; (l_121 <= 45); l_121 += 6)
                    { /* block id: 95 */
                        int32_t **l_155 = &l_154;
                        (*l_155) = l_154;
                    }
                }
                for (l_121 = 0; (l_121 >= 36); l_121 += 4)
                { /* block id: 101 */
                    struct S0 l_160 = {554,1812,22,-18,1117};
                    int32_t **l_164 = (void*)0;
                    int32_t **l_165 = &l_137;
                    if (l_158)
                    { /* block id: 102 */
                        int32_t *l_159 = &l_138;
                        return l_131;
                        /* statement id: 103 */
                        //assert (func_93_rv == 0);
                    }
                    else
                    { /* block id: 104 */
                        int32_t *l_161 = (void*)0;
                        const int32_t **l_162 = &l_125;
                        (**l_126) = l_160;
                        (*l_162) = l_161;
                        (**l_126) = func_66(((void*)0 != l_131), (*l_137), l_131, l_163);
                    }
                    (*l_165) = &l_138;
                }
                (*l_127) = (**l_163);
            }
            for (l_136 = 0; (l_136 < 17); ++l_136)
            { /* block id: 115 */
                const struct S0 **l_179 = &l_133;
                int32_t l_187 = 0x80E1D116L;
                (*l_137) = l_168;
                (**l_126) = func_66(((uint16_t)(((uint16_t)6UL >> (uint16_t)2) & (((uint32_t)((*l_135) < ((int16_t)p_94 << (int16_t)l_177)) % (uint32_t)l_178) == p_95)) >> (uint16_t)(*l_135)), (__builtin_popcountll((*l_135)) | (*l_137)), &l_136, l_179);
                if (p_95)
                { /* block id: 118 */
                    int32_t *l_180 = (void*)0;
                    return l_180;
                    /* statement id: 119 */
                    //assert (func_93_rv == 0);
                }
                else
                { /* block id: 120 */
                    uint16_t l_186 = 0xB7B0L;
                    if ((func_102((((0xE0054F3BA64CE0CALL ^ l_183) == (((p_95 <= (l_131 == &l_136)) >= ((l_186 & func_102(p_94, (**l_126), (p_95 == p_94), &l_135)) != l_187)) <= (*l_135))) == 0x1EFC347C869DD984LL), (*l_133), p_95, &l_131) > p_95))
                    { /* block id: 121 */
                        (*l_127) = (**l_163);
                        (*l_137) = 1L;
                    }
                    else
                    { /* block id: 124 */
                        int32_t ** const ***l_191 = &l_188;
                        (*l_191) = l_188;
                        (**l_126) = (*l_133);
                        l_137 = (****l_191);
                    }
                    (*l_127) = (**l_179);
                }
                (*l_190) = (**l_189);
            }
        }
        (**l_189) = &l_138;
    }
    return l_198;
    /* statement id: 136 */
    //assert (func_93_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_96(struct S0 ** p_97, const int32_t  p_98, float  p_99, int64_t  p_100)
{ /* block id: 58 */
    return p_100;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_102(const uint32_t  p_103, struct S0  p_104, int32_t  p_105, int32_t * const * p_106)
{ /* block id: 53 */
    float l_115 = (-0x1.4p-1);
    float *l_114 = &l_115;
    int32_t l_116 = 0x9DA5FDE2L;
    int32_t *l_117 = &l_116;
    int32_t **l_118 = &l_117;
    (*l_114) = (p_104.f1 < (-0x1.1p-1));
    (*l_117) = l_116;
    (*l_118) = &l_116;
    return p_105;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 189
   depth: 1, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 46
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 21
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 15
breakdown:
   indirect level: 0, occurrence: 15
XXX times a bitfields struct's address is taken: 17
XXX times a bitfields struct on LHS: 8
XXX times a bitfields struct on RHS: 22
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 18

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 276
   depth: 2, occurrence: 59
   depth: 3, occurrence: 9
   depth: 4, occurrence: 3
   depth: 5, occurrence: 4
   depth: 6, occurrence: 4
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 4
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 5
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 213

XXX times a variable address is taken: 218
XXX times a pointer is dereferenced on RHS: 82
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 23
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 108
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 470

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 208
   level: 2, occurrence: 98
   level: 3, occurrence: 21
   level: 4, occurrence: 24
XXX number of pointers point to pointers: 122
XXX number of pointers point to scalars: 70
XXX number of pointers point to structs: 21
XXX percent of pointers has null in alias set: 25.8
XXX average alias set size: 1.13

XXX times a non-volatile is read: 792
XXX times a non-volatile is write: 307
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 245
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 26
   depth: 2, occurrence: 29
   depth: 3, occurrence: 51
   depth: 4, occurrence: 59
   depth: 5, occurrence: 50

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

