/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3657173965
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 5;
   const unsigned f1 : 8;
   const uint8_t  f2;
   const signed f3 : 12;
   signed f4 : 3;
   unsigned f5 : 5;
   signed f6 : 20;
   int64_t  f7;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint8_t  func_33(void);
inline static uint32_t  func_34(const int64_t  p_35, int32_t  p_36, int32_t  p_37, uint8_t  p_38);
static int32_t  func_40(uint64_t  p_41);
static uint8_t  func_44(const float  p_45, uint32_t  p_46, int16_t  p_47, const uint32_t  p_48);
static float  func_53(uint32_t  p_54);
static uint64_t  func_59(int8_t  p_60, int32_t  p_61);
static const uint8_t  func_66(uint64_t  p_67, int8_t  p_68, float  p_69, int16_t  p_70);
static uint16_t  func_75(uint32_t  p_76, uint8_t  p_77, uint32_t  p_78, uint32_t  p_79, uint32_t  p_80);
inline static struct S0  func_82(const int32_t  p_83);
static const uint64_t  func_85(int16_t  p_86, const uint32_t  p_87, int16_t  p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_33(void)
{ /* block id: 36 */
    const uint64_t l_39 = 0xA1CF04157736D0C1LL;
    uint16_t l_721 = 0xD327L;
    float **l_755 = (void*)0;
    int32_t l_761 = 3L;
    const int32_t *l_760 = &l_761;
    int32_t **** const l_791 = (void*)0;
    int32_t **** const *l_790 = &l_791;
    uint64_t l_860 = 0xC9AA60B38A169DF4LL;
    float l_958 = 0x9.Ap-1;
    uint64_t l_959 = 7UL;
    int32_t l_964 = 0xDC70D8A6L;
    uint8_t l_976 = 0xB0L;
    uint32_t l_977 = 0xB1F54B37L;
    int32_t *l_978 = &l_761;
    float ***l_980 = (void*)0;
    float ****l_979 = &l_980;
    int8_t l_1000 = 0x7CL;
    uint16_t l_1015 = 0xB318L;
    uint32_t l_1018 = 1UL;
    struct S0 l_1035 = {-2,0,251UL,47,0,0,642,6L};
    struct S0 *l_1034 = &l_1035;
    uint8_t l_1040 = 0x19L;
    if ((func_34(l_39, func_40(((safe_div_func_int32_t_s_s(((((((__builtin_bswap64(l_39) <= 0xC9L) >= func_44((safe_add_func_float_f_f((((safe_div_func_float_f_f(l_39, (func_53((safe_mod_func_uint8_t_u_u((safe_sub_func_uint32_t_u_u((0x694AL != ((func_59((safe_rshift_func_int8_t_s_s((safe_mod_func_uint32_t_u_u(((func_66(l_39, l_39, (safe_add_func_float_f_f(l_39, l_39)), l_39) >= l_39) | l_39), l_39)), 2)), l_39) > l_39) , l_39)), l_39)), l_39))) != l_39))) >= 0x3.D57003p-76) < l_39), l_39)), l_39, l_39, l_39)) & l_39) > 0xA6DDL) , l_39) && l_39), l_721)) , l_721)), l_39, l_721) , 0x71B637AFL))
    { /* block id: 399 */
        struct S0 **l_745 = (void*)0;
        int32_t l_759 = 1L;
        const uint32_t l_771 = 0xFAE0491BL;
        int32_t *l_796 = (void*)0;
        int32_t **l_795 = &l_796;
        int32_t ***l_794 = &l_795;
        int32_t ****l_793 = &l_794;
        int32_t *****l_792 = &l_793;
        float l_800 = 0x5.6127ECp-42;
        float *l_801 = (void*)0;
        float *l_802 = &l_800;
        l_745 = l_745;
        for (l_721 = (-28); (l_721 > 24); l_721 = safe_add_func_uint64_t_u_u(l_721, 9))
        { /* block id: 403 */
            int32_t l_748 = 7L;
            const int32_t **l_762 = &l_760;
            uint32_t l_798 = 0x7E0C540FL;
            int32_t l_799 = 2L;
            for (l_748 = 0; (l_748 == (-4)); l_748 = safe_sub_func_int16_t_s_s(l_748, 1))
            { /* block id: 406 */
                float *l_751 = (void*)0;
                float *l_752 = (void*)0;
                float l_754 = (-0x5.3p-1);
                float *l_753 = &l_754;
                float ***l_756 = (void*)0;
                int32_t *l_758 = (void*)0;
                int32_t **l_757 = &l_758;
                (*l_753) = l_748;
                l_755 = l_755;
                (*l_757) = (void*)0;
                l_759 = (func_82(l_721) , l_759);
            }
            (*l_762) = l_760;
            for (l_748 = 0; (l_748 <= 29); l_748 = safe_add_func_int64_t_s_s(l_748, 6))
            { /* block id: 415 */
                uint32_t l_768 = 0x00852E20L;
                int32_t *l_776 = (void*)0;
                uint16_t l_779 = 1UL;
                int8_t l_785 = 1L;
                float l_797 = 0x8.6B8D11p-74;
            }
        }
        (*l_802) = ((*l_760) , ((l_760 == l_796) , l_800));
    }
    else
    { /* block id: 434 */
        int32_t *l_803 = &l_761;
        int32_t **l_804 = &l_803;
        struct S0 l_807 = {2,15,0xADL,-42,-1,1,-605,-1L};
        struct S0 *l_806 = &l_807;
        struct S0 **l_805 = &l_806;
        float ****l_812 = (void*)0;
        int32_t l_829 = 0x3A6C9D3FL;
        int16_t l_845 = 0xD357L;
        int32_t l_870 = 0x4CE94970L;
        const int32_t l_879 = 0xD0773A0EL;
        uint32_t l_884 = 0xB0B07FFCL;
        int32_t l_902 = 0x00747E76L;
        int32_t *l_910 = &l_761;
        int32_t ***l_920 = &l_804;
        int16_t l_940 = (-1L);
        uint32_t l_968 = 0xD7FC76E4L;
        const int32_t **l_975 = &l_760;
        (*l_804) = l_803;
        if ((l_805 == &l_806))
        { /* block id: 436 */
            int32_t ***l_808 = &l_804;
            (*l_808) = (void*)0;
            /* statement id: 437 */
            assert (l_804 == 0);
        }
        else
        { /* block id: 438 */
            int32_t *l_809 = &l_761;
            float l_827 = 0x2.0FA2B6p-94;
            float *l_826 = &l_827;
            float **l_825 = &l_826;
            int32_t l_882 = 0x8A72D1DDL;
            uint16_t l_901 = 0x9A67L;
            int32_t ***l_921 = &l_804;
            if ((**l_804))
            { /* block id: 439 */
                uint32_t l_821 = 1UL;
                struct S0 l_828 = {-2,11,0xEEL,-50,-0,1,986,1L};
                int32_t * const *l_833 = &l_803;
                int32_t * const ** const l_832 = &l_833;
                float ** const l_841 = &l_826;
                if (((void*)0 == l_809))
                { /* block id: 440 */
                    for (l_807.f7 = 21; (l_807.f7 <= 23); l_807.f7 = safe_add_func_int64_t_s_s(l_807.f7, 1))
                    { /* block id: 443 */
                        float *** const *l_814 = (void*)0;
                        float *** const **l_813 = &l_814;
                        (*l_804) = (void*)0;
                        /* statement id: 444 */
                        assert (l_803 == 0);
                        (*l_809) = (-1L);
                        (*l_813) = l_812;
                    }
                    /* facts after for loop */
                    assert (l_803 == 0 || l_803 == &l_761);
                    (*l_805) = (void*)0;
                    /* statement id: 448 */
                    assert (l_806 == 0);
                }
                else
                { /* block id: 449 */
                    int32_t l_824 = 9L;
                    (**l_804) = (safe_rshift_func_int16_t_s_s(((safe_add_func_uint32_t_u_u(((safe_div_func_uint8_t_u_u(func_59((*l_803), (*l_803)), l_821)) | (safe_add_func_uint32_t_u_u(l_824, ((((*l_809) || ((void*)0 != l_825)) , __builtin_clz(l_821)) > 0x90L)))), 4L)) == (*l_809)), l_821));
                }
                /* facts after branching */
                assert (l_803 == 0 || l_803 == &l_761);
                assert (l_806 == &l_807 || l_806 == 0);
                (*l_804) = (l_828 , l_809);
                /* statement id: 452 */
                assert (l_803 == &l_761);
                (*l_809) = l_829;
                if (__builtin_ffsll(((safe_add_func_int8_t_s_s((*l_809), (*l_803))) < (*l_809))))
                { /* block id: 454 */
                    int32_t ****l_834 = (void*)0;
                    int32_t ***l_836 = &l_804;
                    int32_t ****l_835 = &l_836;
                    int32_t **l_837 = &l_803;
                    struct S0 l_843 = {-4,3,0UL,-6,-0,4,371,8L};
                    struct S0 *l_842 = &l_843;
                    (*l_835) = l_832;
                    /* statement id: 455 */
                    assert (l_836 == &l_833);
                    (*l_837) = (*l_833);
                    (*l_809) = __builtin_parity((safe_mod_func_int64_t_s_s((~((0x7A25FA1641CC77B8LL <= (&l_826 == ((*l_809) , l_841))) , (*l_803))), (l_828 , __builtin_parity((*l_760))))));
                    l_842 = (void*)0;
                    /* statement id: 458 */
                    assert (l_842 == 0);
                }
                else
                { /* block id: 459 */
                    int32_t *l_844 = &l_761;
                    l_844 = (*l_804);
                    return l_845;
                }
            }
            else
            { /* block id: 463 */
                int32_t *l_851 = &l_761;
                int32_t ** const *l_861 = &l_804;
                const float l_864 = 0x5.8734ACp-98;
                float ***l_868 = &l_825;
                float l_883 = 0x3.811329p+54;
                float *l_903 = &l_883;
                int8_t l_935 = 0xF9L;
                uint32_t l_948 = 4294967292UL;
                for (l_807.f7 = (-23); (l_807.f7 == 7); l_807.f7++)
                { /* block id: 466 */
                    int32_t *l_852 = (void*)0;
                    struct S0 *l_857 = &l_807;
                    int32_t l_890 = 0x48C036CDL;
                }
                (*l_804) = (*l_804);
                (*l_851) = ((*l_851) < ((safe_add_func_uint8_t_u_u((safe_mod_func_uint8_t_u_u((*l_809), (***l_861))), (safe_lshift_func_int8_t_s_u((safe_mod_func_uint8_t_u_u((((func_40(func_34((0xBA6290FFCA65305ELL ^ ((((**l_804) > (safe_add_func_int64_t_s_s((((l_901 , (*l_851)) && ((*l_803) < (((*l_805) != (*l_805)) && (*l_851)))) && (*l_851)), (*l_809)))) & 5L) < (**l_804))), (**l_804), l_902, (*l_851))) || (*l_851)) , (***l_861)) , (*l_760)), (***l_861))), (***l_861))))) & 0UL));
                if (((void*)0 != l_903))
                { /* block id: 485 */
                    uint64_t l_914 = 18446744073709551608UL;
                    int32_t * const l_937 = &l_761;
                    float ****l_945 = &l_868;
                    uint16_t l_946 = 65534UL;
                    struct S0 **l_965 = &l_806;
                    if ((!(**l_804)))
                    { /* block id: 486 */
                        int16_t l_911 = 0xF51EL;
                        int16_t l_936 = 0xB33EL;
                        const int32_t **l_938 = &l_760;
                        (*l_826) = __builtin_popcountll((+(safe_add_func_int32_t_s_s((func_59((safe_rshift_func_uint8_t_u_u((*l_760), 0)), ((l_910 == (void*)0) < (**l_804))) , (0x6491B2B08DC3795ALL < ((((0x362F67A0L < l_911) > ((safe_mod_func_uint32_t_u_u(((1UL != l_914) | 0xAC22FD72L), l_911)) != (*l_851))) , l_911) < l_911))), l_914))));
                        (*l_804) = (*l_804);
                        (*l_910) = ((+(((safe_add_func_int64_t_s_s((safe_lshift_func_uint16_t_u_u((l_920 != l_921), (l_914 > (safe_mod_func_int8_t_s_s(func_34((((((((l_911 , ((safe_add_func_int32_t_s_s((((func_75(((safe_unary_minus_func_uint64_t_u((0x7AE4L <= 0x0B43L))) >= (***l_861)), (safe_sub_func_uint8_t_u_u((safe_add_func_int32_t_s_s(l_911, (safe_lshift_func_uint8_t_u_u((safe_lshift_func_int16_t_s_s(((((*l_809) , (***l_921)) , (*l_851)) || l_911), 4)), 1)))), l_935)), l_911, (*l_910), (***l_921)) | l_914) , (*l_760)) <= l_914), 0xB6A2B552L)) ^ l_911)) | l_911) >= l_936) >= 0x53B48794066C48FBLL) , (***l_861)) , 18446744073709551615UL) | (***l_921)), (*l_803), (***l_921), (*l_851)), l_911))))), 18446744073709551608UL)) > 0x70924043L) > (***l_921))) && 0x9905L);
                        (*l_938) = l_937;
                    }
                    else
                    { /* block id: 491 */
                        int32_t l_939 = (-8L);
                        (*l_803) = l_939;
                        (**l_920) = (**l_861);
                        (*l_803) = l_940;
                    }
                    (*l_803) = (safe_rshift_func_uint16_t_u_u((((((0x0EA4C4FE8095E9CFLL > (***l_861)) < ((safe_sub_func_int16_t_s_s((((*l_760) , l_945) == l_812), (*l_937))) , (***l_920))) & (*l_851)) , (*l_945)) == l_868), l_946));
                    if (((void*)0 == (*l_825)))
                    { /* block id: 497 */
                        (**l_921) = (**l_921);
                    }
                    else
                    { /* block id: 499 */
                        float l_947 = 0x3.D8FD53p+21;
                        (*l_945) = (*l_945);
                        (*l_945) = &l_825;
                        (*l_803) = (***l_921);
                    }
                    if ((l_948 || (((*l_937) || (safe_lshift_func_int8_t_s_s(((*l_921) != ((!__builtin_popcountll((((~((~(*l_937)) , (((safe_sub_func_uint32_t_u_u((*l_851), ((*l_760) > (safe_lshift_func_uint16_t_u_u(l_959, func_85(func_44(((**l_804) , (safe_sub_func_float_f_f((safe_div_func_float_f_f(__builtin_clzll((***l_861)), 0x2.29DD16p-15)), (*l_851)))), l_964, (*l_851), (***l_861)), (*l_910), (*l_803))))))) & (*l_803)) , (*l_937)))) , 4L) , 18446744073709551610UL))) , &l_937)), 1))) ^ (*l_760))))
                    { /* block id: 504 */
                        struct S0 * const *l_967 = &l_806;
                        struct S0 * const **l_966 = &l_967;
                        (*l_966) = l_965;
                    }
                    else
                    { /* block id: 506 */
                        return l_968;
                    }
                }
                else
                { /* block id: 509 */
                    int32_t *l_971 = &l_761;
                    int32_t *l_974 = &l_761;
                    for (l_935 = 0; (l_935 == 11); l_935++)
                    { /* block id: 512 */
                        (**l_921) = l_971;
                        (*l_804) = (((((safe_add_func_int32_t_s_s((*l_809), (*l_809))) , (*l_910)) & 2UL) && 0xD2C2L) , l_974);
                    }
                }
            }
            /* facts after branching */
            assert (l_806 == &l_807 || l_806 == 0);
            (**l_825) = ((void*)0 == (*l_921));
            (**l_921) = (**l_920);
        }
        /* facts after branching */
        assert (l_804 == &l_803 || l_804 == 0);
        assert (l_806 == &l_807 || l_806 == 0);
        (*l_975) = &l_761;
    }
    (*l_978) = ((*l_760) >= ((l_976 <= (((func_85((*l_760), (*l_760), l_977) , __builtin_ffs((*l_760))) && (((*l_760) & (*l_760)) | (*l_760))) , (*l_760))) && 0UL));
    (*l_979) = &l_755;
    /* statement id: 524 */
    assert (l_980 == &l_755);
    for (l_976 = 0; (l_976 <= 33); l_976++)
    { /* block id: 527 */
        uint32_t l_1003 = 1UL;
        int32_t l_1011 = 0x88054BA0L;
        float *l_1021 = &l_958;
        struct S0 ***l_1022 = (void*)0;
        struct S0 l_1028 = {4,14,0x43L,28,-0,3,-60,0xB4062AE0224F565BLL};
        float l_1039 = 0x0.8p+1;
        for (l_977 = 0; (l_977 > 4); l_977 = safe_add_func_int64_t_s_s(l_977, 1))
        { /* block id: 530 */
            int16_t l_985 = (-3L);
            int16_t l_986 = (-1L);
            float *l_1007 = (void*)0;
            float **l_1006 = &l_1007;
            l_986 = l_985;
            for (l_985 = 0; (l_985 <= 27); l_985++)
            { /* block id: 534 */
                int32_t l_993 = 0x06BAF2D0L;
                int32_t * const l_1013 = &l_761;
                for (l_986 = 0; (l_986 == 4); l_986 = safe_add_func_uint16_t_u_u(l_986, 1))
                { /* block id: 537 */
                    int32_t *l_991 = &l_761;
                    l_993 = (((void*)0 != l_991) <= (!(0x920C1ADC1767305CLL && 1L)));
                }
                if (__builtin_ffsl(l_993))
                { /* block id: 540 */
                    int16_t l_1008 = (-1L);
                    l_1011 = ((safe_lshift_func_int16_t_s_u((__builtin_clzll((((safe_rshift_func_int8_t_s_u((((safe_add_func_uint64_t_u_u((l_1000 , (safe_rshift_func_int16_t_s_u(0x22B0L, l_1003))), l_1003)) & (safe_div_func_int32_t_s_s((((((((l_986 >= (l_1006 == &l_1007)) > l_1008) || (safe_lshift_func_uint16_t_u_u(l_1008, l_986))) == 0xA98EB6A1L) != 0L) , (void*)0) == (void*)0), l_1003))) | l_993), 3)) , l_1008) ^ l_993)) , 1L), l_985)) , l_986);
                }
                else
                { /* block id: 542 */
                    int32_t **l_1012 = &l_978;
                    int32_t **l_1014 = &l_978;
                    (*l_1012) = l_1007;
                    /* statement id: 543 */
                    assert (l_978 == 0);
                    (*l_1014) = l_1013;
                    /* statement id: 544 */
                    assert (l_978 == &l_761);
                }
                (*l_1013) = func_59((*l_1013), ((func_85(l_1015, (*l_760), (*l_1013)) && l_986) , (*l_1013)));
                (*l_1013) = ((safe_lshift_func_int8_t_s_s(l_1003, func_59((*l_1013), (*l_1013)))) , (l_985 , l_1018));
            }
        }
        (*l_1021) = (safe_div_func_float_f_f(l_1003, l_1003));
        (*l_978) = (((void*)0 == l_1022) , (((*l_978) >= ((1L & (*l_760)) , l_1011)) & ((0xC99F3BAE18DAA9F2LL == (l_1011 && (safe_lshift_func_uint8_t_u_u(((safe_mod_func_int16_t_s_s((~(((void*)0 == (*l_979)) && (*l_760))), l_1003)) ^ 0xD1CEL), 2)))) & (*l_760))));
        (*l_978) = ((((l_1028 , l_1028.f1) | func_59(((((safe_add_func_float_f_f((safe_add_func_float_f_f((*l_978), (-(0x0.2p-1 != (((void*)0 == l_1034) >= (+(l_1003 == (safe_sub_func_float_f_f(l_1028.f3, (((l_1028.f5 || 0L) & l_1003) , l_1003)))))))))), 0x5.24126Bp-75)) <= l_1028.f0) >= 0x1.3p+1) , (*l_978)), l_1028.f3)) , (*l_1034)) , 1L);
    }
    return l_1040;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_34(const int64_t  p_35, int32_t  p_36, int32_t  p_37, uint8_t  p_38)
{ /* block id: 394 */
    int32_t *****l_730 = (void*)0;
    int32_t l_735 = 0x08F28484L;
    const struct S0 l_736 = {4,14,0x55L,-35,-0,3,-996,0x3A60B364640CEBCFLL};
    int32_t *l_737 = &l_735;
    float l_740 = 0x4.3FF78Fp+77;
    int64_t l_741 = 0x64AE2819FACD3F07LL;
    uint64_t l_744 = 1UL;
    (*l_737) = (safe_div_func_int16_t_s_s(((safe_sub_func_float_f_f(0x8.5p-1, p_38)) , 0x0E07L), func_75((((void*)0 == l_730) && (safe_add_func_uint32_t_u_u((p_38 , 0xA4237127L), ((safe_add_func_float_f_f((l_735 <= ((((((((p_37 & 0xE46AL) , 0x6D039B72L) , l_736) , (-0x1.Dp+1)) == 0xB.7F69FEp-16) < 0x0.3p-1) != p_38) >= p_35)), p_38)) , 0x78DEEFCAL)))), p_35, p_36, l_735, p_38)));
    (*l_737) = (safe_sub_func_uint16_t_u_u((*l_737), (p_36 > l_741)));
    (*l_737) = (safe_add_func_int16_t_s_s(0x8155L, ((((func_40(((l_736 , (*l_737)) , (((__builtin_parityll((__builtin_bswap32(((*l_737) , p_35)) , 4UL)) , ((p_36 <= p_36) , 0xFD5FL)) | 6L) , p_35))) != 0xA6293B7DF9A4DB7ALL) == (*l_737)) != (-1L)) && l_744)));
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_40(uint64_t  p_41)
{ /* block id: 388 */
    int32_t l_723 = (-7L);
    const int32_t *l_722 = &l_723;
    int32_t *l_725 = (void*)0;
    int32_t **l_724 = &l_725;
    (*l_724) = l_722;
    /* statement id: 389 */
    assert (l_725 == &l_723);
    (**l_724) = (p_41 != (**l_724));
    (**l_724) = p_41;
    (*l_724) = (void*)0;
    /* statement id: 392 */
    assert (l_725 == 0);
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_44(const float  p_45, uint32_t  p_46, int16_t  p_47, const uint32_t  p_48)
{ /* block id: 335 */
    uint16_t l_624 = 0UL;
    int32_t l_626 = 0x5456EE9DL;
    int32_t *l_625 = &l_626;
    uint32_t l_689 = 0x8A56F931L;
    const int32_t **l_707 = (void*)0;
    const int32_t ***l_706 = &l_707;
    int32_t **l_718 = &l_625;
    const int32_t ****l_719 = (void*)0;
    int32_t ***l_720 = &l_718;
    if (l_624)
    { /* block id: 336 */
        int32_t **l_627 = &l_625;
        struct S0 **l_683 = (void*)0;
        uint32_t l_684 = 18446744073709551615UL;
        (*l_627) = l_625;
        for (l_624 = (-11); (l_624 < 27); l_624 = safe_add_func_int8_t_s_s(l_624, 1))
        { /* block id: 340 */
            int32_t *l_632 = &l_626;
            for (l_626 = 0; (l_626 >= (-6)); l_626 = safe_sub_func_uint32_t_u_u(l_626, 4))
            { /* block id: 343 */
                (*l_627) = l_632;
            }
            if (p_47)
                break;
            (*l_632) = (safe_lshift_func_int8_t_s_u(((safe_add_func_int32_t_s_s(p_46, (p_46 <= ((safe_add_func_int64_t_s_s((safe_div_func_uint8_t_u_u(((*l_625) , p_47), p_48)), (safe_div_func_int32_t_s_s((*l_625), p_47)))) == (__builtin_popcountl((safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_u(p_48, (safe_sub_func_int64_t_s_s(p_46, 1UL)))), 13))) >= (*l_632)))))) || p_46), (*l_632)));
            (*l_627) = (*l_627);
        }
        for (p_46 = 19; (p_46 <= 48); p_46++)
        { /* block id: 352 */
            const int32_t l_653 = 0L;
            int32_t *l_678 = &l_626;
            float l_686 = 0xA.107220p+74;
            float *l_685 = &l_686;
            for (l_624 = 0; (l_624 == 46); l_624++)
            { /* block id: 355 */
                int32_t *l_671 = (void*)0;
                (**l_627) = l_653;
                for (l_626 = 0; (l_626 < (-28)); l_626 = safe_sub_func_int64_t_s_s(l_626, 1))
                { /* block id: 359 */
                    float *l_656 = (void*)0;
                    float l_658 = 0xE.78B865p+36;
                    float *l_657 = &l_658;
                    int32_t l_674 = 0x022BD2BBL;
                    (*l_657) = __builtin_clz((*l_625));
                    for (p_47 = (-16); (p_47 == (-14)); p_47++)
                    { /* block id: 363 */
                        uint32_t l_675 = 0xBE3175C0L;
                        int32_t l_676 = 0L;
                        l_676 = (safe_add_func_float_f_f(((((-0x1.7p+1) >= (((safe_div_func_int16_t_s_s(((safe_add_func_uint32_t_u_u((safe_div_func_uint64_t_u_u(0x4C470BCABC32EE87LL, ((-1L) && ((safe_sub_func_int16_t_s_s(((*l_627) == l_671), (safe_rshift_func_uint16_t_u_u((((func_59(p_48, (__builtin_clzll(p_47) , (p_47 <= 255UL))) <= (-5L)) <= (**l_627)) || 0x9D42BEFAL), 9)))) && p_47)))), 0x5F51F6E3L)) >= l_674), l_674)) , (**l_627)) <= l_675)) > p_46) < p_46), p_47));
                        (*l_657) = ((((func_59(p_46, (1UL == l_674)) != ((p_48 < (l_676 != p_48)) , p_46)) > (((((!(**l_627)) != p_45) > (-0x1.7p-1)) >= l_653) >= (**l_627))) != p_47) <= 0x4.27A9D8p+76);
                    }
                }
                if ((*l_625))
                    break;
            }
            (*l_627) = l_678;
            (*l_685) = (safe_add_func_float_f_f(((0x0.Dp+1 == (safe_div_func_float_f_f(((void*)0 == l_683), p_47))) > l_684), ((*l_678) , ((*l_678) >= ((p_48 != ((*l_678) > (*l_625))) == (*l_678))))));
        }
        (**l_627) = (**l_627);
    }
    else
    { /* block id: 374 */
        int32_t **l_695 = &l_625;
        int32_t ***l_694 = &l_695;
        int32_t ****l_693 = &l_694;
        int32_t *****l_692 = &l_693;
        const struct S0 **l_717 = (void*)0;
        (*****l_692) = ((safe_add_func_int32_t_s_s(func_75((p_48 , (p_46 , ((l_689 , p_47) < (((safe_div_func_uint64_t_u_u(((void*)0 == l_692), func_66(((!((*l_625) | (((safe_div_func_float_f_f(((*l_625) <= (0x0.Dp-1 <= 0xD.8F3944p+68)), p_45)) == (*l_625)) , 0xE841L))) | p_47), (*****l_692), p_47, p_47))) <= (*****l_692)) >= 0L)))), p_48, (*l_625), (**l_695), (*l_625)), p_46)) <= p_47);
        for (l_624 = 0; (l_624 != 16); l_624 = safe_add_func_int64_t_s_s(l_624, 1))
        { /* block id: 378 */
            int16_t l_701 = (-1L);
            int32_t ** const *l_708 = (void*)0;
            if (l_701)
                break;
            (*l_695) = &l_626;
            (*****l_692) = func_75(l_701, p_48, (*l_625), p_48, (safe_mod_func_uint16_t_u_u(((safe_mod_func_int8_t_s_s((l_706 != ((****l_693) , l_708)), (safe_sub_func_uint8_t_u_u(p_47, (safe_sub_func_int8_t_s_s((p_48 && (****l_693)), (*l_625))))))) , 65535UL), p_47)));
            (***l_694) = (safe_add_func_uint64_t_u_u(((*****l_692) , (((p_46 | ((safe_add_func_int32_t_s_s(((****l_693) >= 4294967288UL), p_48)) < p_47)) , l_717) != l_717)), p_48));
        }
    }
    (*l_718) = &l_626;
    l_720 = &l_718;
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_53(uint32_t  p_54)
{ /* block id: 331 */
    int32_t *l_619 = (void*)0;
    int32_t **l_620 = &l_619;
    int32_t l_623 = 4L;
    (*l_620) = l_619;
    l_623 = (safe_lshift_func_uint16_t_u_u(p_54, 8));
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_59(int8_t  p_60, int32_t  p_61)
{ /* block id: 328 */
    struct S0 l_617 = {-1,1,0xD3L,-31,-1,1,-717,-9L};
    struct S0 *l_616 = &l_617;
    struct S0 **l_618 = &l_616;
    (*l_618) = l_616;
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint8_t  func_66(uint64_t  p_67, int8_t  p_68, float  p_69, int16_t  p_70)
{ /* block id: 37 */
    float l_81 = (-0x1.9p-1);
    int32_t l_89 = (-1L);
    uint32_t l_127 = 0x2A6FDD69L;
    const int32_t *l_298 = (void*)0;
    const int32_t **l_297 = &l_298;
    uint16_t l_335 = 0UL;
    const float *l_344 = &l_81;
    const float **l_343 = &l_344;
    uint8_t l_348 = 0x17L;
    int32_t ****l_358 = (void*)0;
    int32_t *****l_357 = &l_358;
    const int32_t *l_385 = (void*)0;
    int8_t l_406 = 0x4AL;
    int32_t l_466 = (-1L);
    int32_t **l_470 = (void*)0;
    int32_t ** const *l_469 = &l_470;
    int32_t ** const ** const l_468 = &l_469;
    int64_t l_521 = 0x26D260FB1646E88CLL;
    int16_t l_527 = 0x8E7AL;
    float l_530 = (-0x1.2p-1);
    uint16_t l_544 = 0xB132L;
    int8_t l_567 = 9L;
    if (((safe_sub_func_uint32_t_u_u((func_75((((l_81 , ((((func_82((((!func_85(l_89, l_89, (p_70 > (((safe_add_func_int16_t_s_s(p_68, (((65532UL < (__builtin_clz((p_70 != __builtin_parity(p_67))) || l_89)) == 0xFAD6770D28CDD501LL) , l_89))) && (-1L)) >= l_89)))) == p_70) != l_127)) , 0xE733L) <= p_70) ^ l_127) | 1L)) > l_89) , 0xD7CE17D6L), l_127, p_68, l_89, l_127) <= (-1L)), 0x9023DF18L)) && l_127))
    { /* block id: 153 */
        int64_t l_289 = (-1L);
        int32_t *l_299 = &l_89;
        struct S0 l_322 = {-2,7,2UL,35,-1,0,-496,0xA9C4ECCF1789042DLL};
        int32_t *****l_379 = &l_358;
        int64_t l_399 = (-7L);
        for (p_70 = 0; (p_70 > 12); p_70 = safe_add_func_uint16_t_u_u(p_70, 6))
        { /* block id: 156 */
            int32_t *l_276 = &l_89;
            (*l_276) = 8L;
            l_89 = 1L;
            (*l_276) = (safe_rshift_func_uint8_t_u_u(__builtin_ctzl(l_127), 0));
        }
        for (p_67 = (-22); (p_67 < 16); p_67++)
        { /* block id: 163 */
            int32_t l_313 = 0x841971EBL;
            uint32_t l_332 = 7UL;
            const float *l_342 = (void*)0;
            const float **l_341 = &l_342;
            for (l_89 = 0; (l_89 >= 10); l_89 = safe_add_func_uint16_t_u_u(l_89, 9))
            { /* block id: 166 */
                uint32_t l_290 = 3UL;
                int32_t l_292 = (-7L);
                int32_t *l_291 = &l_292;
                int64_t l_306 = 4L;
                struct S0 l_325 = {-1,3,0x0BL,16,-0,0,-62,-1L};
                int32_t **l_338 = &l_291;
                int32_t ***l_337 = &l_338;
                int32_t ****l_336 = &l_337;
                (*l_291) = (p_67 != (safe_lshift_func_uint8_t_u_u((safe_div_func_uint16_t_u_u(((247UL >= (safe_div_func_uint8_t_u_u((p_67 , l_289), p_70))) >= 0xC1L), (l_289 , __builtin_ffsll(l_290)))), 5)));
                for (p_68 = 0; (p_68 == 5); p_68 = safe_add_func_int8_t_s_s(p_68, 7))
                { /* block id: 170 */
                    uint32_t l_303 = 9UL;
                    int32_t ****l_339 = (void*)0;
                    float *l_340 = (void*)0;
                    (*l_291) = (safe_div_func_int64_t_s_s((&l_291 != l_297), ((l_289 ^ p_67) ^ 0x698BB56BL)));
                    (*l_297) = l_299;
                    /* statement id: 172 */
                    assert (l_298 == &l_89);
                    if (((+((safe_sub_func_int64_t_s_s(l_303, (__builtin_ffsll(p_70) >= __builtin_ctz(l_303)))) >= (safe_rshift_func_int16_t_s_u(((l_306 , (*l_299)) || (safe_add_func_int32_t_s_s((((safe_add_func_int32_t_s_s((((safe_div_func_int8_t_s_s((1L > p_68), l_303)) >= l_313) & (-8L)), (*l_298))) , (*l_291)) < 0xE9F2L), 0x909AFE77L))), 11)))) < (*l_299)))
                    { /* block id: 173 */
                        (*l_291) = p_67;
                        (*l_291) = p_70;
                        (*l_297) = (*l_297);
                    }
                    else
                    { /* block id: 177 */
                        float l_320 = 0x0.1p+1;
                        const int32_t l_321 = 0x6889F079L;
                        uint16_t l_331 = 65535UL;
                        uint8_t l_333 = 254UL;
                        float *l_334 = &l_320;
                        (*l_291) = ((safe_add_func_int64_t_s_s((func_85((safe_sub_func_int8_t_s_s((safe_add_func_uint8_t_u_u((*l_291), (func_85((*l_291), l_321, ((l_322 , (p_67 | (((l_325 , (((((((safe_lshift_func_int8_t_s_u(((safe_rshift_func_uint16_t_u_u((~((0xA1L < ((p_67 , l_313) & p_68)) ^ (*l_299))), p_70)) , l_331), p_68)) , (*l_299)) ^ 6L) ^ l_313) | 0UL) <= (*l_298)) > (*l_299))) , 9UL) == p_68))) , (**l_297))) > l_332))), l_333)), p_70, p_70) != 1L), p_70)) , (-1L));
                        (*l_334) = p_69;
                        if (l_335)
                            continue;
                    }
                    p_69 = ((l_336 != l_339) , p_67);
                }
                (*l_336) = (*l_336);
                (**l_338) = p_70;
            }
            /* facts after for loop */
            assert (l_298 == &l_89 || l_298 == 0);
            (*l_297) = (void*)0;
            /* statement id: 187 */
            assert (l_298 == 0);
            l_343 = l_341;
            /* statement id: 188 */
            assert (l_343 == &l_342);
        }
        /* facts after for loop */
        //assert (l_343 == dangling || l_343 == &l_344);
        if (((~(-1L)) != (((*l_299) || (safe_add_func_int16_t_s_s(p_68, l_348))) || (0x8DL != __builtin_bswap64((+p_67))))))
        { /* block id: 190 */
            float *l_356 = &l_81;
            for (l_89 = (-25); (l_89 > 23); l_89++)
            { /* block id: 193 */
                int64_t l_352 = (-9L);
                float *l_353 = &l_81;
                int32_t l_355 = 1L;
                int32_t *l_354 = &l_355;
                (*l_353) = l_352;
                (*l_354) = 0x91552FA5L;
            }
            (*l_356) = p_67;
            l_357 = l_357;
        }
        else
        { /* block id: 199 */
            float l_365 = 0x5.6499F2p-48;
            int32_t l_367 = 0x22C635EDL;
            int32_t **l_371 = (void*)0;
            int32_t *****l_386 = (void*)0;
            if (((safe_rshift_func_int8_t_s_s((safe_lshift_func_int16_t_s_s((safe_div_func_uint32_t_u_u((((5L == func_75((__builtin_popcountl((*l_299)) && (!p_67)), ((((l_367 , &l_299) == (__builtin_clzl((safe_mod_func_uint64_t_u_u((((+((((p_68 , l_367) == (l_299 == l_299)) , (*l_299)) == p_68)) <= p_70) >= p_67), (*l_299)))) , l_371)) , (*l_299)) && p_70), p_70, p_68, p_70)) && p_70) <= (*l_299)), p_68)), 5)), 5)) < p_68))
            { /* block id: 200 */
                int32_t *l_374 = &l_367;
                float *l_384 = &l_81;
                for (l_322.f7 = 0; (l_322.f7 == 12); l_322.f7 = safe_add_func_uint16_t_u_u(l_322.f7, 1))
                { /* block id: 203 */
                    p_69 = p_67;
                    (*l_297) = l_374;
                    /* statement id: 205 */
                    assert (l_298 == &l_367);
                }
                /* facts after for loop */
                assert (l_298 == &l_367 || l_298 == 0);
                (*l_374) = 0xB3721D3AL;
                (*l_384) = (safe_add_func_float_f_f((safe_sub_func_float_f_f(((0xF.A25EC3p-12 != (&l_358 != l_379)) <= ((safe_sub_func_float_f_f(p_67, 0x9.FBBC76p+31)) == (-0x6.52BABFp-7))), (-(p_69 == ((void*)0 == &l_367))))), 0x7.0p+1));
            }
            else
            { /* block id: 209 */
                (*l_297) = l_385;
            }
            /* facts after branching */
            assert (l_298 == &l_367 || l_298 == 0);
            (*l_299) = (func_82(((((void*)0 != l_386) , ((safe_sub_func_int64_t_s_s(p_68, ((0xF.724EE0p+91 <= p_69) , (safe_rshift_func_uint16_t_u_u((safe_add_func_uint32_t_u_u(0x91654FE5L, p_70)), (((safe_sub_func_int32_t_s_s((safe_add_func_uint16_t_u_u((safe_add_func_uint64_t_u_u((l_399 != ((p_69 < l_367) , 0L)), 0UL)), 0L)), 0xE9EDABCFL)) , 0x6723L) && 65535UL)))))) | p_67)) , p_70)) , (-1L));
        }
        /* facts after branching */
        //assert (l_298 == dangling || l_298 == 0);
        (*l_299) = (safe_lshift_func_uint8_t_u_u(248UL, p_68));
    }
    else
    { /* block id: 215 */
        uint32_t l_411 = 4294967295UL;
        int32_t *****l_428 = &l_358;
        const int64_t l_431 = 0xD40DCABA12FF2C9FLL;
        uint16_t l_467 = 3UL;
        int64_t l_471 = 0x3FD392B0C70AD77ELL;
        int32_t *l_472 = &l_89;
        int32_t l_513 = (-1L);
        struct S0 l_528 = {-0,5,0x5AL,-40,0,2,-1012,-1L};
        int32_t ** const l_589 = &l_472;
        if (((safe_rshift_func_uint8_t_u_u((((safe_rshift_func_int16_t_s_u(__builtin_ia32_crc32qi((l_406 < (((safe_rshift_func_int8_t_s_s((func_85((safe_mod_func_uint32_t_u_u((l_411 == (safe_rshift_func_int8_t_s_s(0xC6L, (safe_unary_minus_func_uint64_t_u((p_68 , (safe_add_func_int8_t_s_s(((safe_rshift_func_int16_t_s_u((p_70 , (0x719CF51B75F4EF1CLL == (safe_rshift_func_uint8_t_u_s((safe_rshift_func_uint8_t_u_u(((((!((safe_rshift_func_int8_t_s_u(l_411, 1)) , ((p_67 <= ((safe_lshift_func_uint8_t_u_s(__builtin_ffs((1L < 0xA7B5485DCA04AF34LL)), 0)) | 0x48E38710527B90E3LL)) < 0x2EL))) , p_68) >= l_411) ^ p_67), 4)), 4)))), 14)) > 4L), 250UL)))))))), p_67)), l_411, p_67) != 18446744073709551612UL), 0)) <= 9L) == p_68)), p_68), 3)) , l_428) != (void*)0), 3)) >= 0x099B4E54L))
        { /* block id: 216 */
            for (l_406 = (-3); (l_406 != (-3)); l_406 = safe_add_func_int8_t_s_s(l_406, 1))
            { /* block id: 219 */
                return l_431;
            }
            return p_70;
        }
        else
        { /* block id: 223 */
            float *l_434 = &l_81;
            float **l_433 = &l_434;
            float ***l_432 = &l_433;
            (*l_432) = &l_344;
            /* statement id: 224 */
            assert (l_433 == &l_344);
        }
        (*l_297) = ((safe_mod_func_int16_t_s_s(((~(safe_sub_func_int64_t_s_s(((safe_rshift_func_int16_t_s_u((p_67 & p_70), 0)) < ((safe_rshift_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_u((p_68 , (safe_add_func_int8_t_s_s((safe_mod_func_uint8_t_u_u((safe_mod_func_uint32_t_u_u((safe_mod_func_int16_t_s_s(((((safe_div_func_uint8_t_u_u((safe_div_func_int16_t_s_s(p_67, (safe_lshift_func_uint8_t_u_s((((7UL >= (safe_lshift_func_int8_t_s_s((-3L), 4))) && (((l_466 == ((p_70 < (l_467 , p_68)) >= p_68)) , (*l_428)) == l_468)) >= p_70), p_67)))), p_68)) < p_67) , (void*)0) == (void*)0), 1UL)), p_68)), l_467)), (-1L)))), p_70)), l_471)) != p_70)), p_68))) < p_68), 0x30AEL)) , l_472);
        /* statement id: 226 */
        assert (l_298 == &l_89);
        for (p_67 = 0; (p_67 != 45); p_67 = safe_add_func_uint32_t_u_u(p_67, 5))
        { /* block id: 229 */
            int8_t l_477 = 0x80L;
            int32_t l_478 = (-9L);
            uint32_t l_502 = 3UL;
            const float **l_512 = &l_344;
            int32_t *l_522 = &l_478;
            int32_t *****l_529 = &l_358;
            const int8_t l_541 = (-1L);
            const int32_t *l_591 = &l_478;
            p_69 = 0x9.7AB59Ep-10;
        }
    }
    /* facts after branching */
    //assert (l_298 == &l_89 || l_298 == dangling || l_298 == 0);
    //assert (l_343 == dangling || l_343 == &l_344);
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_75(uint32_t  p_76, uint8_t  p_77, uint32_t  p_78, uint32_t  p_79, uint32_t  p_80)
{ /* block id: 73 */
    int32_t *l_133 = (void*)0;
    int32_t **l_134 = &l_133;
    int32_t l_137 = 0xAB47FCA7L;
    uint32_t l_139 = 0x9C462E65L;
    int64_t l_141 = 0x20E24C2F892C2D3CLL;
    int32_t ** const *l_206 = (void*)0;
    int32_t ** const **l_205 = &l_206;
    int32_t ** const ***l_204 = &l_205;
    (*l_134) = l_133;
    (*l_134) = (*l_134);
    if ((p_80 && func_85((safe_mod_func_uint8_t_u_u(p_77, l_137)), (+l_139), p_77)))
    { /* block id: 76 */
        float l_140 = 0x4.0FD8B3p-34;
        int32_t **l_142 = &l_133;
        int32_t *l_143 = (void*)0;
        int32_t *l_144 = &l_137;
        int32_t ** const ***l_207 = &l_205;
        uint16_t l_208 = 0x1667L;
        (*l_144) = ((l_141 , ((void*)0 != l_142)) == p_78);
        if ((*l_144))
        { /* block id: 78 */
            uint8_t l_150 = 0xDEL;
            uint16_t l_160 = 0xE08BL;
            float *l_161 = &l_140;
            (*l_134) = (*l_134);
            (*l_161) = (+((safe_div_func_float_f_f((safe_add_func_float_f_f(p_76, l_150)), (p_78 <= (safe_sub_func_float_f_f(p_77, (safe_add_func_float_f_f(p_78, (-0x1.2p+1)))))))) == ((safe_add_func_float_f_f(p_77, ((-p_78) <= (safe_add_func_float_f_f(p_79, p_77))))) < l_160)));
        }
        else
        { /* block id: 81 */
            int32_t l_163 = 0x33383FD2L;
            int32_t **l_168 = &l_133;
            uint16_t l_177 = 5UL;
            if (p_76)
            { /* block id: 82 */
                const uint64_t l_171 = 4UL;
                if (p_77)
                { /* block id: 83 */
                    uint16_t l_162 = 9UL;
                    (*l_144) = ((l_162 > l_163) && (safe_lshift_func_uint8_t_u_s((__builtin_ffsl(p_80) < 0x5FL), ((((safe_sub_func_uint16_t_u_u((l_168 != &l_143), func_85((p_78 == (safe_add_func_uint32_t_u_u((l_171 > p_80), 0x3B3E5AADL))), l_162, l_162))) | (-2L)) , 9L) | p_80))));
                }
                else
                { /* block id: 85 */
                    uint32_t l_172 = 9UL;
                    int16_t l_202 = 7L;
                    uint8_t l_203 = 0x1BL;
                    if ((func_85(p_80, p_77, l_172) , func_85((((void*)0 != &l_168) || (safe_rshift_func_uint8_t_u_u((((*l_144) ^ ((safe_add_func_int8_t_s_s(0x66L, 0x04L)) , 0x9F8BL)) <= p_77), l_171))), l_171, l_177)))
                    { /* block id: 86 */
                        float *l_178 = &l_140;
                        (*l_178) = p_80;
                        (*l_144) = (safe_lshift_func_int16_t_s_s(((p_76 , (p_76 != (((((void*)0 != (*l_134)) , ((safe_rshift_func_int16_t_s_u((safe_div_func_int8_t_s_s((safe_rshift_func_int16_t_s_s((l_171 == (safe_rshift_func_int8_t_s_u(((safe_rshift_func_int16_t_s_u(((safe_div_func_int8_t_s_s((safe_div_func_int32_t_s_s((+((safe_lshift_func_uint8_t_u_s(246UL, 4)) || 1L)), (safe_sub_func_uint64_t_u_u((func_85(p_76, p_78, p_80) < p_78), l_202)))), l_171)) , 9L), p_78)) < 0x2926A71AB2586FDALL), p_80))), 13)), p_78)), p_78)) >= p_77)) , l_172) == p_78))) , 0x8018L), 8));
                        (*l_134) = (*l_168);
                    }
                    else
                    { /* block id: 90 */
                        (*l_144) = l_203;
                    }
                }
            }
            else
            { /* block id: 94 */
                (*l_144) = p_77;
                return p_79;
            }
        }
        l_207 = (p_79 , l_204);
        return l_208;
    }
    else
    { /* block id: 101 */
        float l_238 = 0x4.3DF78Fp-44;
        const int32_t l_239 = 0x149DF445L;
        if (p_79)
        { /* block id: 102 */
            int32_t *l_211 = &l_137;
            (*l_211) = (safe_sub_func_uint16_t_u_u(0UL, p_80));
            for (p_77 = 0; (p_77 != 33); p_77++)
            { /* block id: 106 */
                (*l_134) = l_211;
                /* statement id: 107 */
                assert (l_133 == &l_137);
            }
            /* facts after for loop */
            assert (l_133 == &l_137 || l_133 == 0);
        }
        else
        { /* block id: 109 */
            int32_t *l_218 = &l_137;
            int8_t l_234 = 0x43L;
            int32_t *l_268 = &l_137;
            if ((0xE2L | p_77))
            { /* block id: 110 */
                const int16_t l_232 = (-1L);
                for (p_76 = 0; (p_76 != 50); p_76++)
                { /* block id: 113 */
                    uint32_t l_221 = 0xFA4D0A6DL;
                    int32_t l_266 = 1L;
                    if ((safe_mod_func_int16_t_s_s(1L, 65535UL)))
                    { /* block id: 114 */
                        (*l_134) = l_218;
                        /* statement id: 115 */
                        assert (l_133 == &l_137);
                    }
                    else
                    { /* block id: 116 */
                        int32_t l_233 = (-5L);
                        (*l_218) = ((safe_sub_func_int32_t_s_s(l_221, ((safe_unary_minus_func_uint16_t_u((safe_lshift_func_uint16_t_u_s((safe_rshift_func_int8_t_s_u((__builtin_parityll(p_78) < (((safe_rshift_func_uint8_t_u_s(p_76, 1)) && p_76) , ((safe_unary_minus_func_int64_t_s((((*l_218) & 65535UL) & (((safe_add_func_uint32_t_u_u((((((-1L) >= (l_232 <= l_233)) < p_80) , 0x76L) | p_78), 4294967289UL)) && l_221) , l_234)))) >= 2L))), 6)), p_77)))) || 65535UL))) != 0x6AL);
                        (*l_218) = (((!(safe_div_func_uint16_t_u_u((p_79 >= func_85(func_85((*l_218), l_239, p_77), (safe_mod_func_uint8_t_u_u(p_78, p_77)), ((safe_add_func_uint32_t_u_u(0xB8516656L, (safe_div_func_uint64_t_u_u((safe_add_func_int16_t_s_s((p_80 != 1L), p_77)), p_76)))) , p_80))), p_79))) == 255UL) >= 0UL);
                    }
                    for (p_77 = 0; (p_77 < 31); p_77++)
                    { /* block id: 122 */
                        uint32_t l_252 = 4294967290UL;
                        uint16_t l_259 = 65532UL;
                        (*l_218) = ((0xBD1F0D1286CDD36ELL > ((safe_lshift_func_int8_t_s_s(l_252, 7)) , (((safe_lshift_func_uint16_t_u_s(((safe_add_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(((__builtin_clzll(l_239) , (l_239 , ((*l_218) , (*l_204)))) == (void*)0), 14)), ((0x6.0955FAp+15 != l_259) , 0x968DL))) ^ 0x24L), p_77)) , (*l_218)) == p_79))) , p_80);
                        if (l_221)
                            break;
                    }
                    (*l_134) = l_218;
                    /* statement id: 126 */
                    assert (l_133 == &l_137);
                    for (l_137 = 0; (l_137 < (-18)); l_137 = safe_sub_func_int64_t_s_s(l_137, 3))
                    { /* block id: 129 */
                        float l_262 = 0x1.5p-1;
                        int32_t *l_263 = (void*)0;
                        int32_t l_265 = 1L;
                        int32_t *l_264 = &l_265;
                        (*l_264) = l_232;
                        l_266 = (*l_218);
                    }
                }
                /* facts after for loop */
                assert (l_133 == &l_137 || l_133 == 0);
                l_218 = l_218;
                (*l_218) = p_78;
                return p_79;
            }
            else
            { /* block id: 137 */
                int32_t *l_267 = &l_137;
                l_268 = l_267;
                (*l_134) = l_267;
                /* statement id: 139 */
                assert (l_133 == &l_137);
            }
            /* facts after branching */
            assert (l_133 == &l_137);
            for (p_79 = 2; (p_79 == 46); p_79 = safe_add_func_int8_t_s_s(p_79, 1))
            { /* block id: 143 */
                for (l_137 = 12; (l_137 < 19); l_137 = safe_add_func_int32_t_s_s(l_137, 9))
                { /* block id: 146 */
                    int8_t l_273 = (-3L);
                    return l_273;
                }
            }
        }
        /* facts after branching */
        assert (l_133 == &l_137 || l_133 == 0);
    }
    /* facts after branching */
    assert (l_133 == &l_137 || l_133 == 0);
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_82(const int32_t  p_83)
{ /* block id: 70 */
    int32_t **l_130 = (void*)0;
    int32_t ***l_129 = &l_130;
    int32_t ****l_128 = &l_129;
    int32_t *****l_131 = &l_128;
    struct S0 l_132 = {3,15,1UL,57,-1,0,-21,-5L};
    (*l_131) = l_128;
    return l_132;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint64_t  func_85(int16_t  p_86, const uint32_t  p_87, int16_t  p_88)
{ /* block id: 38 */
    const int16_t l_98 = (-1L);
    int32_t l_111 = 0xB0596E72L;
    int32_t * const l_110 = &l_111;
    if (((safe_add_func_int8_t_s_s(9L, (p_88 ^ p_88))) > p_88))
    { /* block id: 39 */
        int32_t l_95 = (-1L);
        int32_t *l_94 = &l_95;
        const int32_t *l_97 = &l_95;
        const int32_t **l_96 = &l_97;
        (*l_96) = l_94;
        return l_98;
    }
    else
    { /* block id: 42 */
        int32_t l_106 = 0x2B77DEECL;
        int32_t *l_105 = &l_106;
        int32_t **l_112 = (void*)0;
        const int32_t *l_114 = &l_106;
        const int32_t **l_113 = &l_114;
        for (p_86 = (-3); (p_86 == (-21)); --p_86)
        { /* block id: 45 */
            int32_t **l_107 = &l_105;
            (**l_107) = ((1UL | ((safe_add_func_int8_t_s_s((0x019510DDF4F35DDBLL ^ p_87), p_87)) && (safe_rshift_func_int8_t_s_s(((((p_87 > (0UL | ((void*)0 != l_105))) , &l_105) != l_107) ^ (**l_107)), (*l_105))))) == (*l_105));
            for (l_106 = 0; (l_106 <= (-18)); l_106 = safe_sub_func_int16_t_s_s(l_106, 1))
            { /* block id: 49 */
                return p_88;
            }
        }
        (*l_105) = p_87;
        (*l_113) = l_110;
        /* statement id: 54 */
        assert (l_114 == &l_111);
        for (l_111 = (-23); (l_111 != 6); l_111 = safe_add_func_uint64_t_u_u(l_111, 1))
        { /* block id: 57 */
            int32_t ***l_124 = &l_112;
            int32_t l_126 = (-5L);
            if (p_88)
            { /* block id: 58 */
                int32_t *l_117 = &l_106;
                l_117 = (void*)0;
                /* statement id: 59 */
                assert (l_117 == 0);
            }
            else
            { /* block id: 60 */
                int16_t l_122 = (-4L);
                int32_t l_123 = (-1L);
                int32_t ****l_125 = &l_124;
                l_123 = (safe_sub_func_int32_t_s_s((safe_mod_func_uint32_t_u_u((p_87 > l_122), p_87)), (0L >= 249UL)));
                (*l_125) = l_124;
                (*l_113) = &l_111;
                if (l_126)
                    break;
            }
            (*l_113) = &l_111;
        }
    }
    return p_88;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 251
   depth: 1, occurrence: 7
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 7
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 5
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 13
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 5

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 272
   depth: 2, occurrence: 50
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 17, occurrence: 2
   depth: 18, occurrence: 4
   depth: 20, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 3
   depth: 29, occurrence: 1
   depth: 32, occurrence: 2
   depth: 33, occurrence: 1
   depth: 38, occurrence: 1
   depth: 39, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 197

XXX times a variable address is taken: 176
XXX times a pointer is dereferenced on RHS: 246
breakdown:
   depth: 1, occurrence: 182
   depth: 2, occurrence: 39
   depth: 3, occurrence: 19
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 159
breakdown:
   depth: 1, occurrence: 140
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 793

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 387
   level: 2, occurrence: 102
   level: 3, occurrence: 46
   level: 4, occurrence: 44
   level: 5, occurrence: 69
XXX number of pointers point to pointers: 106
XXX number of pointers point to scalars: 86
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 27.4
XXX average alias set size: 1.14

XXX times a non-volatile is read: 1383
XXX times a non-volatile is write: 421
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 231
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 34
   depth: 2, occurrence: 46
   depth: 3, occurrence: 48
   depth: 4, occurrence: 33
   depth: 5, occurrence: 37

XXX percentage a fresh-made variable is used: 20.7
XXX percentage an existing variable is used: 79.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

