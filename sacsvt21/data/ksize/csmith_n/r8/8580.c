/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1337032466
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const float  f0;
   float  f1;
   uint16_t  f2;
   int8_t  f3;
   uint8_t  f4;
};

union U1 {
   int32_t  f0;
};

union U2 {
   uint64_t  f0;
   int8_t * f1;
};

union U3 {
   int8_t * f0;
   int8_t  f1;
   const uint32_t  f2;
   int8_t * f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U0  func_33(void);
inline static int16_t  func_39(uint32_t  p_40, const uint32_t  p_41);
static uint16_t  func_51(float  p_52, int8_t * p_53, uint32_t  p_54, union U2  p_55);
static union U1  func_57(union U0  p_58);
inline static uint32_t  func_63(union U1  p_64, float * p_65, union U1  p_66, int32_t  p_67, uint32_t  p_68);
inline static float * func_70(const float * p_71, int32_t  p_72, float * p_73, const uint8_t  p_74);
static uint32_t  func_75(float * p_76, uint32_t  p_77, int8_t * p_78);
inline static int8_t * func_79(int32_t * p_80, union U3  p_81, int32_t * p_82);
inline static int32_t * func_83(uint8_t  p_84, union U3  p_85, int8_t  p_86, float  p_87, int8_t  p_88);
static union U0  func_90(int32_t * p_91, float * p_92, uint32_t  p_93, float * p_94);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_33(void)
{ /* block id: 36 */
    int32_t l_38 = 0xCEDB7758L;
    int64_t l_43 = (-1L);
    int8_t l_45 = 4L;
    int8_t *l_44 = &l_45;
    int32_t l_384 = 0x555CEA67L;
    int32_t *l_383 = &l_384;
    union U2 l_391 = {0xAC7AB0D69629B2AELL};
    int32_t l_393 = 0xF62609A0L;
    union U3 l_394 = {0};
    union U0 l_395 = {0x0.Ep-1};
    union U3 **l_396 = (void*)0;
    union U3 *l_398 = &l_394;
    union U3 **l_397 = &l_398;
    if (__builtin_ffs((safe_lshift_func_uint16_t_u_s((safe_div_func_int8_t_s_s(l_38, 0x9DL)), func_39(l_38, (+(l_38 > ((__builtin_ffsl(__builtin_popcountl(l_43)) , l_44) == &l_45))))))))
    { /* block id: 163 */
        uint64_t l_378 = 0xA94D3F08EF28FBD8LL;
        float l_380 = 0x4.125600p-4;
        float *l_379 = &l_380;
        l_378 = l_43;
        (*l_379) = l_38;
    }
    else
    { /* block id: 166 */
        float l_381 = 0xD.A85100p-36;
        int32_t l_382 = 0x689C20EAL;
        const int8_t *l_387 = &l_45;
        int32_t l_392 = 0xB94E045BL;
        l_381 = 0x5.A32A49p+18;
        if ((__builtin_ctzll(l_43) | l_382))
        { /* block id: 168 */
            l_383 = &l_382;
            /* statement id: 169 */
            assert (l_383 == &l_382);
        }
        else
        { /* block id: 170 */
            int32_t *l_385 = &l_382;
            int32_t **l_386 = &l_385;
            (*l_386) = l_385;
        }
        /* facts after branching */
        assert (l_383 == &l_384 || l_383 == &l_382);
        (*l_383) = (((void*)0 == l_387) , (safe_mod_func_uint32_t_u_u((l_395 , (*l_383)), 4294967295UL)));
        l_383 = &l_382;
        /* statement id: 174 */
        assert (l_383 == &l_382);
    }
    /* facts after branching */
    //assert (l_383 == dangling || l_383 == &l_384);
    //assert (l_394.f0 == dangling || l_394.f0 == 0);
    //assert (l_394.f3 == dangling || l_394.f3 == 0);
    (*l_397) = &l_394;
    return l_395;
    /* statement id: 177 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_39(uint32_t  p_40, const uint32_t  p_41)
{ /* block id: 37 */
    int32_t l_56 = 0xF69A0165L;
    union U0 l_59 = {0x3.C42FA4p+41};
    const float *l_337 = &l_59.f0;
    int32_t l_341 = 0x22AEDDACL;
    float *l_342 = &l_59.f1;
    union U3 l_343 = {0};
    union U2 l_344 = {18446744073709551609UL};
    for (p_40 = 0; (p_40 < 44); p_40 = safe_add_func_int64_t_s_s(p_40, 2))
    { /* block id: 40 */
        float l_48 = 0x4.E67E78p-95;
        float *l_49 = &l_48;
        int32_t l_50 = 0x3E70D28EL;
        union U1 l_336 = {0x32F107A5L};
        union U2 l_340 = {0x3166C8D2CA16ACC4LL};
        int32_t *l_377 = &l_50;
        (*l_49) = l_48;
        if (l_50)
            break;
        (*l_377) = (((l_50 , p_40) , (l_50 >= func_51(l_56, ((func_57(l_59) , l_336) , func_79(&l_341, l_343, &l_341)), p_41, l_344))) ^ 0xC91545B19DE6B234LL);
        /* statement id: 160 */
        assert (l_343.f0 == 0);
        assert (l_343.f3 == 0);
    }
    /* facts after for loop */
    assert (l_343.f0 == 0);
    assert (l_343.f3 == 0);
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_51(float  p_52, int8_t * p_53, uint32_t  p_54, union U2  p_55)
{ /* block id: 145 */
    int32_t **l_345 = (void*)0;
    int32_t l_348 = 0xA9FF0F2CL;
    int32_t *l_347 = &l_348;
    int32_t **l_346 = &l_347;
    int32_t *l_349 = (void*)0;
    int32_t *l_350 = &l_348;
    uint32_t l_351 = 4294967294UL;
    const int32_t l_356 = 0xE306D411L;
    int32_t l_374 = 2L;
    union U3 l_376 = {0};
    (*l_346) = (void*)0;
    /* statement id: 146 */
    assert (l_347 == 0);
    (*l_350) = p_55.f0;
    if (l_351)
    { /* block id: 148 */
        float l_353 = (-0x4.Ep+1);
        const float *l_352 = &l_353;
        int32_t l_354 = 0xB41102A6L;
        float *l_355 = &l_353;
        (*l_346) = func_70(l_352, l_354, l_355, l_356);
        /* statement id: 149 */
        assert (l_347 == &l_353);
    }
    else
    { /* block id: 150 */
        int32_t l_360 = (-6L);
        const int32_t l_369 = 0x3C6F0771L;
        float *l_375 = (void*)0;
        for (p_54 = 0; (p_54 >= 60); p_54++)
        { /* block id: 153 */
            int16_t l_359 = 1L;
            return l_359;
        }
        p_52 = (((((l_360 < (safe_sub_func_uint64_t_u_u((safe_add_func_uint64_t_u_u((0xA4C65C70L != ((safe_add_func_int8_t_s_s((safe_add_func_int32_t_s_s((*l_350), (p_54 , (*l_350)))), (l_369 , ((1UL & (safe_mod_func_int16_t_s_s((safe_add_func_uint32_t_u_u(l_374, (l_369 | 0L))), p_54))) , p_55.f0)))) <= (-5L))), p_54)), l_369))) && p_54) || 250UL) , 0x389E9D286BB95111LL) , p_52);
        (*l_346) = func_83(__builtin_ctzl(l_360), l_376, l_360, l_369, (*l_350));
        /* statement id: 157 */
        assert (l_376.f0 == 0);
        assert (l_376.f3 == 0);
    }
    /* facts after branching */
    //assert (l_347 == 0 || l_347 == dangling);
    assert (l_376.f0 == 0);
    assert (l_376.f3 == 0);
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_57(union U0  p_58)
{ /* block id: 43 */
    int64_t l_60 = 0xA96DAD8BE776E9F8LL;
    int32_t l_62 = 0xC702B5BDL;
    int32_t *l_61 = &l_62;
    union U1 l_69 = {0x2FB38A83L};
    union U3 l_103 = {0};
    int8_t l_329 = 0x23L;
    int8_t *l_328 = &l_329;
    float l_335 = 0x7.F6269Ep+39;
    float *l_334 = &l_335;
    (*l_61) = (__builtin_ffsll(p_58.f2) && l_60);
    if (((((func_63(l_69, func_70(l_61, (0xCEL ^ ((((1UL || func_75(l_61, p_58.f2, func_79(func_83(((((safe_unary_minus_func_uint8_t_u((func_90(&l_62, l_61, (p_58.f3 != 0x60F91031L), l_61) , (*l_61)))) , (*l_61)) , &l_62) == l_61), l_103, p_58.f2, l_69.f0, p_58.f4), l_103, l_61))) && (*l_61)) == p_58.f3) & p_58.f3)), l_61, p_58.f3), l_69, p_58.f4, l_60) > l_69.f0) < 0x41154D9BL) , (void*)0) == l_328))
    { /* block id: 134 */
        for (p_58.f2 = 22; (p_58.f2 < 3); --p_58.f2)
        { /* block id: 137 */
            return l_69;
            /* statement id: 138 */
                    }
        /* facts after for loop */
            }
    else
    { /* block id: 140 */
        int8_t **l_333 = &l_328;
        int8_t ***l_332 = &l_333;
        (*l_332) = &l_328;
    }
    /* facts after branching */
        //assert (l_103.f0 == dangling || l_103.f0 == 0);
    //assert (l_103.f3 == dangling || l_103.f3 == 0);
    (*l_334) = 0xC.007D99p+8;
    return l_69;
    /* statement id: 144 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_63(union U1  p_64, float * p_65, union U1  p_66, int32_t  p_67, uint32_t  p_68)
{ /* block id: 131 */
    int32_t l_327 = 0x60364838L;
    l_327 = 0x6.815AF1p-99;
    return p_64.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_70(const float * p_71, int32_t  p_72, float * p_73, const uint8_t  p_74)
{ /* block id: 65 */
    int8_t l_149 = 1L;
    uint32_t l_153 = 0UL;
    float l_163 = 0x7.CAB448p-20;
    float *l_162 = &l_163;
    union U0 l_171 = {0xE.C864E9p+45};
    float *l_192 = &l_163;
    int32_t l_193 = 0x9E87E310L;
    int32_t l_194 = 0x2652A429L;
    union U1 l_195 = {0x078DF31DL};
    union U3 l_196 = {0};
    int32_t *l_199 = &l_194;
    int8_t ***l_258 = (void*)0;
    union U2 l_316 = {0xAB2C1C6760B6CA20LL};
    if (((l_149 >= (l_149 | ((~(safe_sub_func_int64_t_s_s(l_149, (l_149 ^ l_153)))) & __builtin_clzll(l_153)))) , (safe_rshift_func_int16_t_s_s(((safe_mod_func_uint64_t_u_u(((safe_lshift_func_uint8_t_u_s(((l_153 , (safe_mod_func_uint32_t_u_u(func_75(l_162, p_74, &l_149), l_149))) , 1UL), 6)) != l_149), l_153)) , l_149), 6))))
    { /* block id: 66 */
        int8_t l_166 = 0xCAL;
        union U3 l_172 = {0};
        int32_t l_174 = 0xA727D4F9L;
        int32_t *l_173 = &l_174;
        (*l_173) = ((safe_lshift_func_uint16_t_u_u(5UL, l_166)) && (safe_div_func_int8_t_s_s((safe_div_func_uint16_t_u_u((((((l_166 || l_166) && func_75((l_171 , func_83(p_74, l_172, (l_171.f4 < __builtin_popcountll((((l_149 != p_74) >= 0xA5L) == p_72))), (*p_71), l_166)), l_153, &l_149)) != l_149) && l_166) , 0xC2DFL), p_74)), p_74)));
    }
    else
    { /* block id: 68 */
        int32_t l_183 = 0xBA3B5982L;
        float l_191 = 0x3.CD3D85p+31;
        for (p_72 = (-22); (p_72 > 17); p_72 = safe_add_func_uint8_t_u_u(p_72, 7))
        { /* block id: 71 */
            uint32_t l_184 = 0xE613B00EL;
            int32_t l_190 = 0xE8C5F53CL;
            int32_t *l_189 = &l_190;
            (*p_73) = (*p_71);
            l_194 = ((((((((*p_71) < (0x1.4p+1 <= (((safe_lshift_func_int16_t_s_u(((1L >= (((safe_rshift_func_uint8_t_u_s(l_171.f2, 3)) >= ((&l_149 != (((__builtin_ffsll((l_183 , (l_184 , ((((((safe_add_func_int64_t_s_s((safe_div_func_int32_t_s_s((((func_90(l_189, l_189, (*l_189), l_192) , (-9L)) | p_72) <= l_171.f3), l_183)), (-1L))) > 6UL) > 0x69L) | p_72) >= l_183) > l_171.f4)))) <= p_74) <= 0xD666DE7AL) , &l_149)) != l_184)) != p_72)) | l_183), p_72)) , l_193) >= 0x4.F905A6p-53))) != (*p_73)) != l_184) < (-0x4.Dp+1)) <= 0x1.Cp+1) , p_72) == l_149);
            if (p_72)
                break;
        }
    }
    (*l_199) = ((((func_75(p_73, p_74, (l_195 , (l_196 , &l_149))) < (((l_153 & l_171.f4) != (safe_lshift_func_uint16_t_u_s((((p_71 == p_71) , l_193) ^ l_193), 9))) >= l_171.f4)) || 0xE33AE951E9A90B21LL) <= l_149) || 252UL);
    /* statement id: 77 */
    assert (l_196.f0 == 0);
    assert (l_196.f3 == 0);
    for (l_149 = 1; (l_149 > 17); l_149 = safe_add_func_int64_t_s_s(l_149, 1))
    { /* block id: 80 */
        int32_t *l_202 = &l_194;
        const float l_212 = 0x0.Ap+1;
        union U3 l_230 = {0};
        union U2 l_234 = {18446744073709551607UL};
        union U2 *l_233 = &l_234;
        int8_t *l_268 = &l_149;
        union U1 l_299 = {1L};
        uint32_t l_324 = 0x827412C7L;
        union U3 *l_326 = &l_230;
        union U3 **l_325 = &l_326;
        l_202 = &p_72;
        /* statement id: 81 */
        assert (l_202 == &p_72);
        if (p_72)
        { /* block id: 82 */
            int16_t l_203 = 0xEA23L;
            int8_t *l_231 = &l_149;
            if (l_203)
                break;
            for (l_153 = 0; (l_153 <= 48); l_153 = safe_add_func_uint16_t_u_u(l_153, 3))
            { /* block id: 86 */
                const int32_t *l_214 = &l_194;
                const int32_t **l_213 = &l_214;
                union U3 l_223 = {0};
                union U3 *l_222 = &l_223;
                if ((safe_div_func_uint16_t_u_u((safe_add_func_uint64_t_u_u((safe_rshift_func_int16_t_s_s(((*l_202) != l_203), 0)), p_72)), ((*l_199) , (*l_199)))))
                { /* block id: 87 */
                    int8_t *l_219 = &l_149;
                    int8_t **l_218 = &l_219;
                    int8_t ***l_220 = (void*)0;
                    int8_t ***l_221 = &l_218;
                    int32_t l_232 = (-1L);
                    union U2 **l_235 = &l_233;
                    (*l_221) = ((((((((void*)0 != l_213) ^ 0x9F1CB05EL) | p_72) == ((void*)0 != p_73)) && ((safe_rshift_func_int16_t_s_u((safe_unary_minus_func_uint32_t_u((*l_202))), 8)) != 0L)) && (((l_203 , p_74) && p_74) || (**l_213))) , l_218);
                    l_222 = (p_72 , &l_196);
                    /* statement id: 89 */
                    assert (l_222 == &l_196);
                    (*l_192) = ((safe_add_func_int64_t_s_s((func_75(func_83((safe_sub_func_int32_t_s_s((safe_div_func_int32_t_s_s((*l_199), p_74)), ((void*)0 == l_214))), l_230, func_75(p_73, p_74, l_231), (*l_202), p_74), p_72, &l_149) , l_232), 0x2DECD23E7C5B9951LL)) , l_203);
                    (*l_235) = l_233;
                }
                else
                { /* block id: 92 */
                    if (p_74)
                        break;
                }
                /* facts after branching */
                assert (l_222 == &l_223 || l_222 == &l_196);
                (*l_202) = (*l_199);
                (*l_202) = ((0x776ED3A1L > (p_74 , ((((safe_sub_func_uint8_t_u_u((safe_div_func_int64_t_s_s((((safe_div_func_uint8_t_u_u((l_196 , ((!(*l_214)) , p_72)), 0xE4L)) , p_72) | (*l_214)), (safe_rshift_func_int16_t_s_s((safe_div_func_int32_t_s_s((-1L), (*l_202))), p_72)))), p_72)) , p_74) != (*l_202)) || p_74))) <= p_72);
                (*l_199) = (((safe_sub_func_uint64_t_u_u(p_74, ((*l_199) < (+((safe_lshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((*l_199), 2)), (*l_214))) , (safe_lshift_func_int8_t_s_s((__builtin_ffsl((*l_202)) ^ (*l_199)), 2))))))) | (l_258 == l_258)) != 1UL);
            }
            return p_73;
            /* statement id: 99 */
            //assert (func_70_rv == &l_62 || func_70_rv == &l_353);
        }
        else
        { /* block id: 100 */
            union U1 l_260 = {-6L};
            int8_t *l_267 = &l_149;
            union U3 l_273 = {0};
            float *l_302 = &l_163;
            float l_309 = 0x0.Dp+1;
            (*p_73) = (p_72 , (-((*p_71) > func_75(p_73, (((l_260 , p_74) | ((*l_199) , (+(((safe_sub_func_int32_t_s_s((+func_75((((safe_div_func_uint64_t_u_u(0x97C7D5AEE717A6D3LL, p_74)) ^ 0x199E9942L) , (void*)0), p_72, l_267)), p_74)) <= p_72) | p_72)))) , (*l_202)), l_268))));
            for (l_194 = (-28); (l_194 >= 28); l_194++)
            { /* block id: 104 */
                const int8_t l_280 = (-1L);
                union U1 l_285 = {0xA828AA00L};
                int8_t **l_296 = &l_267;
                union U3 l_300 = {0};
                float *l_301 = &l_171.f1;
                const int32_t **l_310 = (void*)0;
                int32_t **l_311 = &l_199;
            }
            (*l_192) = (*p_73);
        }
        for (l_171.f2 = 0; (l_171.f2 != 50); l_171.f2 = safe_add_func_int32_t_s_s(l_171.f2, 5))
        { /* block id: 125 */
            int32_t *l_317 = (void*)0;
            int8_t *l_322 = &l_171.f3;
            union U2 *l_323 = &l_234;
            (*p_73) = ((((safe_div_func_float_f_f(((l_171 , 0x0.1p+1) >= func_75(p_73, (safe_div_func_int16_t_s_s((((safe_div_func_int64_t_s_s(func_75(p_73, (*l_202), l_322), 0x530DF6F84D04E999LL)) , (void*)0) != l_323), (*l_202))), l_322)), (*p_71))) , 0x3.39746Cp-31) > l_324) <= (*p_73));
        }
        (*l_325) = &l_196;
        /* statement id: 128 */
        assert (l_326 == &l_196);
    }
    /* facts after for loop */
        return p_73;
    /* statement id: 130 */
    //assert (func_70_rv == &l_62 || func_70_rv == &l_353);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_75(float * p_76, uint32_t  p_77, int8_t * p_78)
{ /* block id: 62 */
    int32_t l_146 = 0L;
    const int32_t *l_145 = &l_146;
    int32_t *l_148 = &l_146;
    int32_t **l_147 = &l_148;
    (*l_147) = l_145;
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t * func_79(int32_t * p_80, union U3  p_81, int32_t * p_82)
{ /* block id: 58 */
    int64_t l_113 = 0x06E2AFE588526770LL;
    int8_t l_129 = (-9L);
    int8_t *l_128 = &l_129;
    int32_t l_132 = 0xCE3A63A6L;
    const int32_t *l_131 = &l_132;
    const int32_t **l_130 = &l_131;
    uint16_t l_135 = 7UL;
    float l_142 = 0x4.B33E2Dp-90;
    int8_t *l_143 = &l_129;
    int8_t *l_144 = (void*)0;
    (*l_130) = func_83(l_113, p_81, l_113, (safe_sub_func_float_f_f((safe_div_func_float_f_f((safe_add_func_float_f_f((safe_add_func_float_f_f(((((safe_sub_func_float_f_f(l_113, (safe_sub_func_float_f_f(l_113, (safe_sub_func_float_f_f((l_113 > (l_128 != (void*)0)), l_129)))))) != l_129) != 0x1.50E62Fp-30) >= l_113), l_113)), l_129)), l_129)), (-0x6.Cp+1))), l_129);
    /* statement id: 59 */
    assert (l_131 == 0);
    (*p_82) = ((l_113 == (safe_mod_func_uint32_t_u_u(l_135, (safe_add_func_uint64_t_u_u((l_132 <= (safe_add_func_int8_t_s_s((0xA1E7967B2D6F4160LL != (l_135 , ((void*)0 != &p_82))), ((safe_mod_func_int8_t_s_s(l_113, l_129)) & l_113)))), l_132))))) , l_132);
    return l_144;
    /* statement id: 61 */
    //assert (func_79_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_83(uint8_t  p_84, union U3  p_85, int8_t  p_86, float  p_87, int8_t  p_88)
{ /* block id: 54 */
    int32_t * const l_104 = (void*)0;
    int32_t *l_105 = (void*)0;
    int32_t **l_106 = &l_105;
    int32_t l_108 = (-2L);
    int32_t *l_107 = &l_108;
    int32_t *l_109 = &l_108;
    int32_t *l_110 = &l_108;
    int32_t *l_111 = &l_108;
    int32_t *l_112 = (void*)0;
    l_105 = l_104;
    (*l_106) = l_104;
    return l_112;
    /* statement id: 57 */
    //assert (func_83_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_90(int32_t * p_91, float * p_92, uint32_t  p_93, float * p_94)
{ /* block id: 45 */
    int32_t l_96 = (-6L);
    int32_t *l_95 = &l_96;
    int32_t **l_97 = &l_95;
    union U0 l_102 = {0xF.D8654Ep+3};
    (*l_97) = l_95;
    for (l_96 = 0; (l_96 < 10); l_96 = safe_add_func_int8_t_s_s(l_96, 1))
    { /* block id: 49 */
        uint32_t l_101 = 0x5CC6C9DBL;
        (*p_92) = (*p_92);
        (*p_94) = (0xA.CEBFDCp-89 >= (-((((*p_91) , (void*)0) != (void*)0) , l_101)));
    }
    return l_102;
    /* statement id: 53 */
    }




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 117
XXX total union variables: 24

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 24, occurrence: 1
   depth: 39, occurrence: 2

XXX total number of pointers: 119

XXX times a variable address is taken: 82
XXX times a pointer is dereferenced on RHS: 68
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 40
breakdown:
   depth: 1, occurrence: 40
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 234

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 252
   level: 2, occurrence: 15
XXX number of pointers point to pointers: 23
XXX number of pointers point to scalars: 91
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 38.7
XXX average alias set size: 1.22

XXX times a non-volatile is read: 486
XXX times a non-volatile is write: 99
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 76
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 23
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5

XXX percentage a fresh-made variable is used: 19.9
XXX percentage an existing variable is used: 80.1
********************* end of statistics **********************/

