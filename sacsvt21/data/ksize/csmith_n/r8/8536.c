/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2796741668
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int8_t  f0;
   uint16_t  f1;
   uint8_t  f2;
   const float  f3;
   uint32_t  f4;
};
#pragma pack(pop)

union U1 {
   uint16_t  f0;
   uint16_t  f1;
   float  f2;
   uint64_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_34(void);
static union U1 * func_35(const int32_t  p_36, int16_t  p_37);
inline static const uint8_t  func_44(uint16_t  p_45);
static uint32_t  func_46(uint64_t  p_47);
inline static int32_t * func_55(uint64_t  p_56, union U1 * p_57, uint32_t  p_58, struct S0  p_59, int16_t  p_60);
inline static uint16_t  func_65(int8_t  p_66, int32_t * p_67, uint32_t  p_68, int8_t  p_69);
static int64_t  func_76(union U1  p_77, uint32_t  p_78);
inline static union U1  func_79(uint16_t  p_80);
inline static const int32_t * func_81(uint64_t  p_82);
static int32_t * func_85(int32_t  p_86, union U1 * p_87, uint16_t  p_88, struct S0  p_89, int64_t  p_90);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_34(void)
{ /* block id: 36 */
    const uint32_t l_38 = 6UL;
    union U1 **l_756 = (void*)0;
    union U1 l_759 = {0xEC22L};
    union U1 *l_758 = &l_759;
    union U1 **l_757 = &l_758;
    struct S0 l_766 = {6L,1UL,0xC9L,0x0.Ap+1,0x189A1F58L};
    struct S0 *l_765 = &l_766;
    struct S0 **l_764 = &l_765;
    struct S0 ***l_763 = &l_764;
    int32_t l_768 = 0x5CBE7584L;
    int32_t *l_767 = &l_768;
    uint64_t l_769 = 18446744073709551615UL;
    (*l_757) = func_35(l_38, l_38);
    /* statement id: 391 */
    assert (l_758 == 0);
    (*l_767) = (l_759.f1 < ((((safe_sub_func_int64_t_s_s(l_759.f1, (safe_unary_minus_func_int32_t_s(0L)))) | ((((0xF4L & ((0x91L | (__builtin_ctzll((l_763 == (void*)0)) , (l_38 != l_759.f0))) < l_766.f0)) == l_759.f0) <= 0xEC5194E8L) < l_766.f1)) ^ 0L) > l_766.f4));
    return l_769;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1 * func_35(const int32_t  p_36, int16_t  p_37)
{ /* block id: 37 */
    int64_t l_52 = 0x11ECBFCF419C2B2ELL;
    uint16_t l_538 = 65529UL;
    union U1 *l_755 = (void*)0;
    if (((safe_rshift_func_uint16_t_u_u(p_37, p_37)) == (~(p_36 || (((safe_div_func_uint32_t_u_u((func_44(((func_46(__builtin_parity((safe_lshift_func_int16_t_s_u((safe_sub_func_uint16_t_u_u(0UL, ((((l_52 || l_52) > l_52) > p_36) != 0x8D67L))), 11)))) > l_52) , l_538)) , l_538), p_36)) , 0x41L) , l_538)))))
    { /* block id: 385 */
        uint64_t l_748 = 0x61336CDD67612959LL;
        l_748 = p_37;
    }
    else
    { /* block id: 387 */
        union U1 l_753 = {0x1DEDL};
        union U1 *l_752 = &l_753;
        union U1 **l_751 = &l_752;
        union U1 ***l_750 = &l_751;
        union U1 ****l_749 = &l_750;
        union U1 *****l_754 = &l_749;
        (*l_754) = l_749;
    }
    return l_755;
    /* statement id: 390 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint8_t  func_44(uint16_t  p_45)
{ /* block id: 272 */
    const int8_t l_541 = 0x93L;
    union U1 l_542 = {0x3475L};
    struct S0 l_563 = {0x93L,0xCF11L,0x2FL,0x5.6C44F9p+82,1UL};
    struct S0 *l_573 = &l_563;
    struct S0 **l_572 = &l_573;
    int32_t l_577 = 0L;
    int32_t *l_576 = &l_577;
    uint32_t l_580 = 18446744073709551610UL;
    float l_581 = 0x4.B40FBCp+13;
    float *l_626 = (void*)0;
    float **l_625 = &l_626;
    float ***l_624 = &l_625;
    int8_t l_676 = 0x97L;
    float l_677 = (-0x9.6p+1);
    const int32_t *l_727 = &l_577;
    const int32_t ** const l_726 = &l_727;
    const int32_t ** const *l_725 = &l_726;
    uint32_t l_734 = 4294967295UL;
    union U1 * const *l_739 = (void*)0;
    union U1 * const **l_738 = &l_739;
    uint8_t l_745 = 0xDAL;
    if (((safe_sub_func_float_f_f((l_541 , l_541), func_76(l_542, l_542.f0))) , (__builtin_popcount(p_45) != ((!(l_541 , ((safe_div_func_int8_t_s_s(l_542.f0, p_45)) | 3UL))) || l_541))))
    { /* block id: 273 */
        float **l_557 = (void*)0;
        float ***l_556 = &l_557;
        int32_t l_562 = 0x1744BD78L;
        struct S0 l_574 = {0xE0L,0x9B8DL,247UL,0x1.Fp-1,0x7A8B9234L};
        uint32_t l_575 = 1UL;
        int32_t l_644 = 0xF4EA0DA7L;
        int32_t l_645 = 0x6C43D06EL;
        union U1 *l_664 = &l_542;
        int32_t *l_666 = &l_577;
        for (p_45 = (-18); (p_45 >= 14); p_45 = safe_add_func_int16_t_s_s(p_45, 1))
        { /* block id: 276 */
            int8_t l_548 = 2L;
            union U1 *l_549 = &l_542;
            float l_561 = 0x4.F15AE4p-17;
            const float *l_560 = &l_561;
            const float * const *l_559 = &l_560;
            const float * const ** const l_558 = &l_559;
            int32_t **l_564 = (void*)0;
            int32_t **l_565 = (void*)0;
            int32_t *l_567 = (void*)0;
            int32_t **l_566 = &l_567;
            (*l_566) = func_85(l_548, l_549, (((safe_mod_func_int32_t_s_s((((l_548 , (safe_mod_func_int64_t_s_s((((p_45 < (func_46(((9L == p_45) | p_45)) , (((((safe_rshift_func_int8_t_s_u(((l_556 != l_558) , 0x3AL), 7)) , p_45) || p_45) && 0xF4L) < 0x48BCL))) || p_45) == l_562), 0x3BF2DE3A6A89D7B6LL))) ^ 0x74L) && p_45), p_45)) && l_548) , p_45), l_563, p_45);
            (*l_566) = func_55((p_45 <= func_76((*l_549), (safe_rshift_func_uint8_t_u_u((l_541 >= l_542.f0), 4)))), &l_542, (safe_sub_func_int16_t_s_s((((void*)0 != l_572) || (l_562 || 1UL)), l_562)), l_574, p_45);
        }
        if (l_575)
        { /* block id: 280 */
            (*l_576) = (func_65(l_563.f0, l_576, l_574.f2, (safe_div_func_int64_t_s_s(((l_580 , (void*)0) != (void*)0), l_575))) || l_574.f2);
        }
        else
        { /* block id: 282 */
            struct S0 l_588 = {0L,8UL,248UL,0x1.6p+1,4UL};
            (*l_572) = &l_574;
            /* statement id: 283 */
            assert (l_573 == &l_574);
            (*l_576) = (*l_576);
            (*l_576) = (safe_lshift_func_int16_t_s_u(((0x0276L && (p_45 | 0L)) >= ((*l_576) ^ (((safe_mod_func_uint8_t_u_u(((__builtin_parityll((safe_rshift_func_uint8_t_u_s((func_46((l_588 , (safe_mod_func_int8_t_s_s(((((p_45 , (l_588.f4 < ((safe_sub_func_int16_t_s_s(0x24ACL, ((!0x44L) <= (-6L)))) ^ p_45))) <= 0x67L) & 0x93L) >= l_574.f4), l_588.f2)))) < l_574.f2), 5))) , 9L) , l_562), p_45)) ^ l_588.f0) <= p_45))), (*l_576)));
            (*l_576) = (*l_576);
        }
        /* facts after branching */
        assert (l_573 == &l_574 || l_573 == &l_563);
        if ((safe_sub_func_int16_t_s_s(0x0A15L, (safe_div_func_uint64_t_u_u((*l_576), p_45)))))
        { /* block id: 288 */
            int16_t l_620 = 0x5A88L;
            struct S0 *l_658 = (void*)0;
            if ((safe_lshift_func_int8_t_s_s(0x68L, 1)))
            { /* block id: 289 */
                uint16_t l_607 = 0x45E4L;
                struct S0 *l_612 = (void*)0;
                for (l_574.f2 = 0; (l_574.f2 >= 2); l_574.f2 = safe_add_func_int64_t_s_s(l_574.f2, 1))
                { /* block id: 292 */
                    float *l_608 = &l_581;
                    const int32_t l_609 = 0xC12A8316L;
                    (*l_576) = (!p_45);
                    if (p_45)
                        continue;
                    (*l_608) = ((safe_div_func_float_f_f(0x0.6p-1, l_607)) <= ((-0x1.Cp+1) == (*l_576)));
                    return l_609;
                }
                for (l_562 = 0; (l_562 == 9); l_562 = safe_add_func_int8_t_s_s(l_562, 4))
                { /* block id: 300 */
                    (*l_572) = l_612;
                    /* statement id: 301 */
                    assert (l_573 == 0);
                }
                /* facts after for loop */
                assert (l_573 == 0 || l_573 == &l_574 || l_573 == &l_563);
            }
            else
            { /* block id: 303 */
                int32_t *l_613 = &l_562;
                int32_t **l_621 = &l_613;
                (*l_621) = func_85(func_65(p_45, l_613, ((((safe_div_func_uint8_t_u_u((&l_562 == l_613), 0x40L)) , (safe_sub_func_int32_t_s_s(((safe_add_func_uint64_t_u_u(p_45, p_45)) != 0x34L), p_45))) != l_562) == l_574.f1), p_45), &l_542, l_620, (**l_572), l_620);
                /* statement id: 304 */
                assert (l_613 == 0);
                (*l_576) = (&l_576 != &l_576);
                (*l_576) = (((safe_rshift_func_int16_t_s_u(((void*)0 != l_624), 7)) && ((*l_573) , __builtin_popcount((safe_rshift_func_int16_t_s_u((__builtin_ia32_crc32qi(l_620, (((p_45 , (*l_576)) & p_45) , p_45)) >= 0xA0B12DCA3AB21E9BLL), p_45))))) == (*l_576));
            }
            /* facts after branching */
            assert (l_573 == 0 || l_573 == &l_574 || l_573 == &l_563);
            l_576 = (((__builtin_clzl((((safe_sub_func_uint32_t_u_u(func_46(l_620), func_65((safe_lshift_func_int16_t_s_u(((0x65C86B15C5185B2FLL >= (safe_rshift_func_int8_t_s_s((safe_div_func_int16_t_s_s((~(safe_sub_func_int32_t_s_s(func_65((l_542 , (((*l_576) && 0UL) && (safe_sub_func_int64_t_s_s((p_45 & (((safe_div_func_int64_t_s_s((0x8CL >= __builtin_ctz((0xD29A65FE579572A9LL >= 18446744073709551606UL))), l_574.f4)) < (*l_576)) <= 0x929E0D4FL)), p_45)))), &l_577, l_620, l_620), l_620))), (*l_576))), p_45))) == l_620), 8)), &l_562, l_574.f2, l_644))) || 0xDA1F746BE0977423LL) >= p_45)) | l_645) ^ l_645) , &l_562);
            /* statement id: 308 */
            assert (l_576 == &l_562);
            for (l_580 = (-25); (l_580 < 23); l_580 = safe_add_func_int32_t_s_s(l_580, 5))
            { /* block id: 311 */
                uint16_t l_652 = 6UL;
                for (l_542.f1 = 0; (l_542.f1 < 36); l_542.f1++)
                { /* block id: 314 */
                    struct S0 l_654 = {0xF4L,0x6549L,1UL,0x0.Dp+1,0x50DAF559L};
                    float *l_660 = &l_581;
                    for (l_574.f4 = 0; (l_574.f4 == 5); l_574.f4 = safe_add_func_uint32_t_u_u(l_574.f4, 1))
                    { /* block id: 317 */
                        union U1 *l_653 = &l_542;
                        int32_t **l_659 = &l_576;
                    }
                    (*l_660) = l_574.f0;
                    (*l_660) = l_644;
                }
                /* facts after for loop */
                            }
        }
        else
        { /* block id: 324 */
            uint8_t l_663 = 0UL;
            struct S0 l_665 = {0x56L,65535UL,7UL,-0x4.1p-1,4294967292UL};
            (*l_576) = (*l_576);
            l_666 = func_55((*l_576), (((p_45 != (0L == ((safe_add_func_int64_t_s_s((((func_76(l_542, ((p_45 != p_45) > 6L)) || (*l_576)) && 0xE980L) , p_45), l_663)) & p_45))) & 9UL) , l_664), p_45, l_665, p_45);
            /* statement id: 326 */
            assert (l_666 == 0);
            (*l_576) = (l_575 ^ 0xDA17L);
        }
        /* facts after branching */
        assert (l_573 == 0 || l_573 == &l_574 || l_573 == &l_563);
        assert (l_576 == &l_577 || l_576 == &l_562);
        assert (l_666 == 0 || l_666 == &l_577);
        (*l_576) = p_45;
    }
    else
    { /* block id: 330 */
        uint64_t l_672 = 18446744073709551607UL;
        struct S0 l_709 = {0x1FL,8UL,255UL,0x0.Ap+1,6UL};
        int32_t **l_717 = &l_576;
        for (l_580 = 5; (l_580 < 45); l_580 = safe_add_func_uint64_t_u_u(l_580, 1))
        { /* block id: 333 */
            float l_683 = 0x8.85319Ep+5;
            struct S0 *l_704 = &l_563;
            union U1 *l_707 = &l_542;
            int32_t l_708 = 0L;
        }
        (*l_717) = &l_577;
    }
    /* facts after branching */
    //assert (l_573 == 0 || l_573 == dangling || l_573 == &l_563);
    //assert (l_576 == &l_577 || l_576 == dangling);
    if (((4L ^ __builtin_popcountl(p_45)) > 0xB3FC4138B69AA1C8LL))
    { /* block id: 367 */
        struct S0 ***l_718 = &l_572;
        (*l_718) = &l_573;
    }
    else
    { /* block id: 369 */
        int32_t *l_719 = &l_577;
        int32_t **l_720 = &l_576;
        union U1 **l_741 = (void*)0;
        union U1 ***l_740 = &l_741;
        struct S0 *l_744 = &l_563;
        (*l_720) = l_719;
        /* statement id: 370 */
        assert (l_576 == &l_577);
        for (l_542.f1 = 6; (l_542.f1 >= 30); l_542.f1 = safe_add_func_int32_t_s_s(l_542.f1, 1))
        { /* block id: 373 */
            int32_t l_733 = 0L;
            for (l_577 = 0; (l_577 < 6); l_577 = safe_add_func_int64_t_s_s(l_577, 9))
            { /* block id: 376 */
                int32_t * const *l_730 = (void*)0;
                int32_t * const **l_729 = &l_730;
                int32_t * const ***l_728 = &l_729;
                (*l_728) = l_725;
                /* statement id: 377 */
                assert (l_729 == &l_726);
                (*l_726) = func_81((safe_mod_func_uint32_t_u_u(l_733, p_45)));
                /* statement id: 378 */
                assert (l_727 == 0);
            }
        }
        /* facts after for loop */
                assert (l_727 == 0 || l_727 == &l_577);
        (*l_719) = (l_734 & (safe_sub_func_int32_t_s_s((((*l_719) && (**l_720)) ^ p_45), ((((+(*l_576)) && (((((*l_625) == (*l_625)) , l_738) == l_740) != 0x886FD04442956D67LL)) || (**l_720)) & (*l_576)))));
        (**l_720) = (safe_add_func_uint32_t_u_u((p_45 && ((void*)0 == l_744)), (((l_745 > (func_46((p_45 , ((l_744 != (void*)0) < (safe_lshift_func_int16_t_s_s(((**l_720) ^ p_45), 2))))) > 0xB2L)) , (*l_576)) >= 1UL)));
    }
    /* facts after branching */
    assert (l_727 == 0 || l_727 == &l_577);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_46(uint64_t  p_47)
{ /* block id: 38 */
    int32_t l_71 = 0xBA27438EL;
    int32_t *l_70 = &l_71;
    int32_t l_75 = 0xEC53312AL;
    union U1 l_421 = {0x075FL};
    union U1 *l_420 = &l_421;
    struct S0 *l_456 = (void*)0;
    struct S0 **l_455 = &l_456;
    float l_492 = 0x1.4p-1;
    uint16_t l_537 = 0x83D0L;
    for (p_47 = 0; (p_47 >= 7); p_47 = safe_add_func_uint16_t_u_u(p_47, 2))
    { /* block id: 41 */
        uint32_t l_72 = 0xF4ACA62EL;
        union U1 **l_398 = (void*)0;
        struct S0 l_422 = {0xCDL,6UL,0x06L,-0x1.2p-1,4294967295UL};
        int32_t **l_451 = &l_70;
        int32_t l_454 = (-1L);
        float *l_512 = &l_492;
        float **l_511 = &l_512;
        float ***l_510 = &l_511;
        const int32_t l_535 = 1L;
    }
    (*l_70) = (*l_70);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_55(uint64_t  p_56, union U1 * p_57, uint32_t  p_58, struct S0  p_59, int16_t  p_60)
{ /* block id: 228 */
    int64_t l_425 = 0x8C7AA07E235D7C60LL;
    union U1 * const l_427 = (void*)0;
    union U1 * const *l_426 = &l_427;
    int64_t l_438 = 0xF62C58C6798C4C04LL;
    struct S0 *l_445 = (void*)0;
    int32_t l_447 = 5L;
    int32_t *l_446 = &l_447;
    int32_t *l_448 = &l_447;
    int32_t *l_449 = &l_447;
    int32_t *l_450 = (void*)0;
    (*l_446) = (((safe_sub_func_uint32_t_u_u(((l_425 && (((l_426 != &p_57) , ((((((safe_add_func_uint16_t_u_u(((safe_sub_func_int16_t_s_s(((((&l_427 == (void*)0) == (((((safe_lshift_func_int16_t_s_s((safe_lshift_func_int8_t_s_s((safe_lshift_func_int8_t_s_s(l_438, (safe_div_func_int16_t_s_s(((((safe_sub_func_int64_t_s_s((safe_rshift_func_int8_t_s_s(l_438, 4)), (&p_59 != l_445))) , p_58) >= p_59.f4) != l_425), p_59.f1)))), 4)), l_438)) , l_425) , p_56) < 0xB2EDL) | 1L)) < l_438) ^ p_60), p_59.f4)) | p_60), l_425)) == 0x60D2L) ^ l_438) , l_425) & p_60) , l_438)) > l_425)) < l_425), l_425)) == p_59.f4) >= l_425);
    return l_450;
    /* statement id: 230 */
    //assert (func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_65(int8_t  p_66, int32_t * p_67, uint32_t  p_68, int8_t  p_69)
{ /* block id: 223 */
    int32_t *l_413 = (void*)0;
    const int32_t *l_415 = (void*)0;
    const int32_t **l_414 = &l_415;
    float l_418 = 0x3.190992p-96;
    const float *l_417 = &l_418;
    const float **l_416 = &l_417;
    float ***l_419 = (void*)0;
    (*l_414) = ((*p_67) , l_413);
    l_416 = l_416;
    (*l_414) = p_67;
    /* statement id: 226 */
    //assert (l_415 == &l_71 || l_415 == &l_75 || l_415 == &l_454 || l_415 == &l_577 || l_415 == &l_562);
    return (**l_414);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_76(union U1  p_77, uint32_t  p_78)
{ /* block id: 217 */
    float l_400 = 0xA.0A01DEp+39;
    float *l_399 = &l_400;
    struct S0 * const l_402 = (void*)0;
    struct S0 * const *l_401 = &l_402;
    struct S0 l_403 = {0L,0UL,1UL,0x6.29F065p-1,0xBA8E6F8EL};
    uint8_t l_408 = 0UL;
    int32_t l_409 = 0x0350C091L;
    int32_t *l_411 = &l_409;
    int32_t **l_410 = &l_411;
    int16_t l_412 = 0xF1ACL;
    (*l_399) = ((((void*)0 == l_399) >= (-0x7.4p+1)) <= (((void*)0 != l_401) >= (l_403 , (__builtin_parity(((safe_lshift_func_uint16_t_u_s((safe_add_func_int64_t_s_s((p_77.f1 >= p_77.f1), l_403.f4)), l_403.f1)) , 0x1C1DF3BDL)) > p_77.f1))));
    l_409 = (65535UL <= l_408);
    (*l_399) = 0x1.2p+1;
    (**l_410) = ((l_410 == (l_412 , &l_411)) , ((*l_410) == (void*)0));
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_79(uint16_t  p_80)
{ /* block id: 42 */
    int32_t l_285 = (-1L);
    const int32_t *l_284 = &l_285;
    union U1 l_294 = {65535UL};
    uint32_t l_307 = 0x9EE913CBL;
    const uint32_t l_315 = 0xD95DDA20L;
    struct S0 l_323 = {-1L,0x9343L,0xE8L,0x9.4ACA79p-19,0xB943A5B3L};
    struct S0 *l_322 = &l_323;
    uint64_t l_370 = 18446744073709551606UL;
    int8_t l_383 = 0x32L;
    int32_t *l_392 = &l_285;
    int32_t **l_391 = &l_392;
    int32_t ***l_390 = &l_391;
    l_284 = func_81(p_80);
    /* statement id: 175 */
    assert (l_284 == 0);
    for (l_285 = 0; (l_285 == (-10)); l_285 = safe_sub_func_int64_t_s_s(l_285, 2))
    { /* block id: 178 */
        for (p_80 = 13; (p_80 != 27); p_80 = safe_add_func_int64_t_s_s(p_80, 2))
        { /* block id: 181 */
            int32_t *l_291 = &l_285;
            int32_t **l_290 = &l_291;
            (*l_290) = &l_285;
        }
    }
    for (l_285 = (-25); (l_285 > 19); l_285 = safe_add_func_uint16_t_u_u(l_285, 2))
    { /* block id: 187 */
        return l_294;
        /* statement id: 188 */
            }
    if ((safe_sub_func_uint32_t_u_u((9UL ^ (((safe_lshift_func_int8_t_s_u((safe_mod_func_int32_t_s_s((((((safe_lshift_func_int8_t_s_u(((safe_div_func_uint64_t_u_u(p_80, (p_80 , (safe_sub_func_int32_t_s_s((l_307 == p_80), (safe_lshift_func_int8_t_s_s(((safe_lshift_func_int8_t_s_u(p_80, p_80)) || (p_80 , ((safe_mod_func_uint64_t_u_u((safe_unary_minus_func_uint64_t_u(((((l_294 , l_315) != p_80) != l_285) , 1UL))), 0x616D2739A248FCCALL)) , 18446744073709551615UL))), 4))))))) | p_80), p_80)) != p_80) != l_285) != 0UL) || p_80), p_80)), 3)) | p_80) > p_80)), l_315)))
    { /* block id: 190 */
        int32_t *l_317 = &l_285;
        int32_t **l_316 = &l_317;
        union U1 **l_334 = (void*)0;
        union U1 **l_335 = (void*)0;
        union U1 *l_337 = &l_294;
        union U1 **l_336 = &l_337;
        (*l_316) = &l_285;
        for (l_285 = 0; (l_285 == 25); l_285 = safe_add_func_uint64_t_u_u(l_285, 1))
        { /* block id: 194 */
            l_284 = (((safe_mod_func_uint32_t_u_u((l_322 == (void*)0), (*l_317))) , 0x2.00CF65p-95) , func_81(l_315));
        }
        if ((safe_sub_func_uint8_t_u_u(((void*)0 != &l_317), p_80)))
        { /* block id: 197 */
            int16_t l_328 = 0x575FL;
            float *l_331 = (void*)0;
            float *l_332 = &l_294.f2;
            (*l_316) = (*l_316);
            (*l_332) = (p_80 == ((p_80 < (safe_add_func_float_f_f(((p_80 <= p_80) != l_328), ((safe_div_func_float_f_f(p_80, p_80)) == 0x9.AAAC5Dp+17)))) < l_328));
            /* statement id: 199 */
                    }
        else
        { /* block id: 200 */
            union U1 l_333 = {7UL};
            return l_333;
            /* statement id: 201 */
                    }
        /* facts after branching */
                (*l_336) = &l_294;
    }
    else
    { /* block id: 204 */
        struct S0 *l_341 = &l_323;
        const union U1 *l_344 = &l_294;
        int32_t l_345 = (-5L);
        const int32_t ** const l_351 = (void*)0;
        uint64_t l_358 = 0UL;
        if (((!(safe_lshift_func_int16_t_s_s(3L, 1))) , __builtin_ia32_crc32qi((__builtin_parityll(p_80) >= ((((void*)0 != l_341) > (safe_sub_func_uint16_t_u_u((&l_294 == l_344), l_294.f0))) && (p_80 , l_345))), l_345)))
        { /* block id: 205 */
            const int16_t l_350 = 3L;
            float *l_352 = (void*)0;
            float *l_353 = &l_294.f2;
            int32_t *l_371 = &l_285;
            (*l_353) = (p_80 != __builtin_popcountl((((l_345 || (safe_sub_func_uint64_t_u_u((safe_mod_func_int32_t_s_s((l_350 <= l_350), p_80)), p_80))) , l_351) != l_351)));
            /* statement id: 206 */
                        (*l_371) = __builtin_ctzl((safe_mod_func_int32_t_s_s((l_345 ^ (l_350 != (safe_div_func_uint8_t_u_u(((l_358 > (safe_div_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_s((safe_unary_minus_func_uint8_t_u(((safe_add_func_uint16_t_u_u(p_80, ((((*l_341) , (((safe_add_func_int8_t_s_s((safe_mod_func_int64_t_s_s((l_350 || ((p_80 >= l_370) == (p_80 > 18446744073709551615UL))), 18446744073709551615UL)), 0xE8L)) , l_351) == l_351)) == 1L) <= p_80))) ^ l_350))), p_80)), 0x91BB1884F5BA48F3LL))) ^ p_80), l_285)))), l_350)));
            l_344 = &l_294;
        }
        else
        { /* block id: 209 */
            int32_t *l_373 = &l_285;
            int32_t **l_372 = &l_373;
            const int32_t * const *l_375 = &l_284;
            const int32_t * const **l_374 = &l_375;
            float *l_384 = &l_294.f2;
            struct S0 * const l_389 = &l_323;
            const int32_t * const * const *l_393 = &l_375;
            (*l_374) = l_372;
            /* statement id: 210 */
            assert (l_375 == &l_373);
            (*l_384) = (safe_add_func_float_f_f((((0L && 0xA327664DF74A3EB6LL) , (*l_373)) , p_80), ((-((safe_div_func_float_f_f(((safe_div_func_float_f_f(p_80, (p_80 == 0x0.680D13p-17))) > 0x5.A189BCp-92), l_383)) < p_80)) >= 0x3.D9D738p-17)));
            /* statement id: 211 */
                        (**l_391) = (l_294.f0 ^ (safe_lshift_func_int16_t_s_s((((((~(!(l_389 == l_341))) > ((p_80 , &l_322) != &l_341)) > (l_390 == l_393)) >= p_80) ^ p_80), p_80)));
            (*l_384) = p_80;
        }
        /* facts after branching */
            }
    /* facts after branching */
        return l_294;
    /* statement id: 216 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_81(uint64_t  p_82)
{ /* block id: 43 */
    uint16_t l_91 = 0UL;
    struct S0 l_93 = {0x07L,65534UL,0UL,0x5.B6EB5Cp-15,4294967295UL};
    const int32_t l_249 = 0L;
    const int32_t *l_248 = &l_249;
    union U1 l_260 = {0xBED7L};
    union U1 *l_259 = &l_260;
    int32_t l_264 = 0L;
    const int32_t *l_283 = (void*)0;
    for (p_82 = 0; (p_82 > 48); p_82++)
    { /* block id: 46 */
        union U1 *l_92 = (void*)0;
        int32_t l_94 = 0L;
        int32_t *l_244 = (void*)0;
        int32_t **l_243 = &l_244;
        const int32_t *l_252 = &l_94;
        const int32_t *l_253 = &l_249;
        const int32_t *l_254 = &l_249;
        struct S0 l_261 = {0x65L,0x60ACL,0x22L,0x3.DD6967p+61,4294967288UL};
        (*l_243) = func_85(__builtin_bswap32(l_91), l_92, p_82, l_93, l_94);
        for (l_93.f2 = 0; (l_93.f2 == 11); l_93.f2 = safe_add_func_uint8_t_u_u(l_93.f2, 2))
        { /* block id: 157 */
            const int32_t *l_247 = &l_94;
            const int32_t *l_250 = &l_94;
            const int32_t *l_251 = &l_249;
            const int32_t *l_255 = (void*)0;
            return l_255;
            /* statement id: 158 */
            //assert (func_81_rv == 0);
        }
        for (l_94 = (-3); (l_94 != (-3)); l_94 = safe_add_func_uint32_t_u_u(l_94, 6))
        { /* block id: 162 */
            int64_t l_258 = 9L;
            int32_t *l_265 = &l_264;
            (*l_243) = func_85(l_258, l_259, (*l_248), l_261, p_82);
            l_264 = (safe_mod_func_uint8_t_u_u((*l_254), p_82));
            l_265 = &l_264;
        }
        (*l_243) = &l_264;
        /* statement id: 167 */
        assert (l_244 == &l_264);
    }
    if (((safe_lshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(((*l_248) || ((*l_248) > (l_93 , (p_82 >= 0x86L)))), 11)), (*l_248))), (p_82 , 0x0D55L))) & (+__builtin_bswap32(__builtin_ctzl((*l_248))))))
    { /* block id: 169 */
        const int32_t *l_273 = &l_249;
        const int32_t *l_274 = (void*)0;
        return l_274;
        /* statement id: 170 */
        //assert (func_81_rv == 0);
    }
    else
    { /* block id: 171 */
        uint32_t l_280 = 0x821C2022L;
        int32_t *l_282 = &l_264;
        int32_t **l_281 = &l_282;
        (*l_281) = func_85(((safe_div_func_uint64_t_u_u(0x6FA72F8FBE7E2172LL, (-9L))) > (safe_div_func_int8_t_s_s((7L <= ((((p_82 >= ((0x3BL && (p_82 && 0x9E8DL)) >= 0x59D7E22B2D8C64F5LL)) || ((+(4UL != 5UL)) , (*l_248))) < l_280) == p_82)), 6UL))), &l_260, p_82, l_93, p_82);
        /* statement id: 172 */
        assert (l_282 == 0);
    }
    return l_283;
    /* statement id: 174 */
    //assert (func_81_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_85(int32_t  p_86, union U1 * p_87, uint16_t  p_88, struct S0  p_89, int64_t  p_90)
{ /* block id: 47 */
    uint16_t l_97 = 0UL;
    union U1 l_104 = {0x690DL};
    union U1 *l_103 = &l_104;
    float *l_105 = &l_104.f2;
    const int32_t *l_107 = (void*)0;
    const int32_t **l_106 = &l_107;
    int32_t l_154 = 4L;
    int32_t *l_153 = &l_154;
    int32_t *l_238 = &l_154;
    int32_t *l_239 = &l_154;
    int32_t *l_240 = &l_154;
    int32_t *l_241 = &l_154;
    int32_t *l_242 = (void*)0;
    (*l_105) = (safe_add_func_float_f_f(l_97, ((safe_div_func_float_f_f((safe_add_func_float_f_f(((!__builtin_ctzl(l_97)) <= l_97), __builtin_popcountl(p_89.f4))), p_89.f2)) >= ((l_103 == &l_104) <= p_89.f0))));
    /* statement id: 48 */
        (*l_106) = l_105;
    /* statement id: 49 */
    assert (l_107 == &l_104.f2);
    for (l_104.f1 = 0; (l_104.f1 >= 10); l_104.f1 = safe_add_func_int8_t_s_s(l_104.f1, 1))
    { /* block id: 52 */
        uint8_t l_114 = 0xD5L;
        float l_121 = 0xD.9C4BD7p+16;
        float *l_120 = &l_121;
        union U1 l_125 = {0x6490L};
        int32_t l_128 = 7L;
        int32_t *l_155 = &l_128;
        p_86 = ((safe_rshift_func_uint16_t_u_s((safe_mod_func_uint16_t_u_u((__builtin_popcountll((p_87 == &l_104)) != 0xAE3B72CDL), 0xE668L)), (l_114 <= __builtin_clz((safe_sub_func_int64_t_s_s((safe_lshift_func_uint8_t_u_s((safe_unary_minus_func_int64_t_s((((l_114 == p_90) , (void*)0) != &p_86))), 0)), p_89.f2)))))) , 0xD228C8C4L);
        (*l_120) = (p_86 >= l_114);
        if ((((__builtin_ia32_crc32qi((safe_div_func_int8_t_s_s(((0x15L > p_89.f2) > ((void*)0 != &l_107)), (l_114 ^ ((!0x88L) , ((l_125 , ((((0xB275L ^ (safe_div_func_int16_t_s_s((l_125.f1 || 65535UL), 0xFFA9L))) > 1UL) , &p_86) != (void*)0)) && 0x5AF80CEFL))))), p_88) || p_86) ^ p_89.f2) , l_128))
        { /* block id: 55 */
            int32_t *l_137 = &l_128;
            const float l_151 = 0x2.991E3Cp+98;
            int32_t *l_152 = &l_128;
            int32_t *l_156 = &l_154;
            int32_t *l_157 = (void*)0;
            for (l_97 = (-10); (l_97 >= 4); l_97++)
            { /* block id: 58 */
                int8_t l_135 = 1L;
                int32_t *l_136 = &l_128;
                for (p_90 = (-27); (p_90 <= 28); p_90 = safe_add_func_int32_t_s_s(p_90, 5))
                { /* block id: 61 */
                    int32_t l_134 = 0xB5CEFCB9L;
                    union U1 l_144 = {65531UL};
                    if ((+l_134))
                    { /* block id: 62 */
                        if (l_135)
                            break;
                        l_137 = l_136;
                    }
                    else
                    { /* block id: 65 */
                        (*l_120) = p_86;
                        if (p_89.f0)
                            continue;
                        if (p_89.f4)
                            break;
                        (*l_120) = 0xF.CD07D1p-92;
                    }
                    if (l_128)
                        continue;
                    (*l_120) = (p_86 > ((safe_div_func_uint32_t_u_u(p_89.f1, (p_86 , (safe_add_func_uint8_t_u_u((*l_137), 255UL))))) , (safe_div_func_float_f_f(((((l_144 , l_125.f1) ^ ((safe_lshift_func_int8_t_s_u((*l_136), (safe_div_func_int64_t_s_s((((safe_add_func_uint32_t_u_u(0xE908AE34L, p_89.f0)) | (*l_137)) , p_88), 0x68046A17DA69EDF7LL)))) , 0xA6L)) > l_144.f1) , 0xA.5DDBF1p+82), p_90))));
                    (*l_120) = __builtin_clzl(l_128);
                }
                (*l_106) = &p_86;
                /* statement id: 75 */
                assert (l_107 == &p_86);
            }
            /* facts after for loop */
            assert (l_107 == &p_86 || l_107 == &l_104.f2);
            return l_157;
            /* statement id: 77 */
            //assert (func_85_rv == 0);
        }
        else
        { /* block id: 78 */
            int32_t *l_158 = &l_154;
            l_155 = l_158;
            /* statement id: 79 */
            assert (l_155 == &l_154);
        }
        /* facts after branching */
        assert (l_155 == &l_154);
        for (l_97 = 0; (l_97 >= 59); l_97 = safe_add_func_uint64_t_u_u(l_97, 1))
        { /* block id: 83 */
            struct S0 l_163 = {0x0AL,65535UL,0x19L,-0x1.6p+1,0UL};
            struct S0 *l_162 = &l_163;
            struct S0 **l_161 = &l_162;
            (*l_161) = &p_89;
            /* statement id: 84 */
            assert (l_162 == &p_89);
        }
    }
    /* facts after for loop */
        for (l_104.f1 = 0; (l_104.f1 <= 25); l_104.f1 = safe_add_func_uint16_t_u_u(l_104.f1, 8))
    { /* block id: 89 */
        uint32_t l_176 = 1UL;
        float l_185 = 0x5.9p-1;
        float *l_184 = &l_185;
        struct S0 l_190 = {0x29L,0xDA39L,0x38L,-0x6.3p-1,0xE2F7FA05L};
        struct S0 *l_189 = &l_190;
        float *l_216 = &l_185;
        (*l_184) = (((safe_add_func_float_f_f((safe_sub_func_float_f_f(p_88, (safe_sub_func_float_f_f(((safe_sub_func_float_f_f((safe_sub_func_float_f_f(p_89.f2, l_176)), (l_176 != (safe_sub_func_float_f_f(((+(safe_add_func_float_f_f((safe_div_func_float_f_f((((p_89.f4 > p_86) > p_88) != (l_176 >= p_89.f0)), 0xB.429369p-54)), l_176))) > p_86), l_176))))) , 0x2.Dp-1), p_89.f2)))), p_89.f2)) <= l_176) == l_176);
        for (p_90 = 14; (p_90 == (-17)); --p_90)
        { /* block id: 93 */
            int32_t l_188 = (-4L);
            const int32_t *l_200 = &l_188;
            if (((0x0DE80311F254279CLL < (l_188 ^ 65533UL)) < ((void*)0 == l_189)))
            { /* block id: 94 */
                int32_t l_195 = 0xF3A8CD93L;
                (*l_184) = (safe_sub_func_float_f_f((safe_sub_func_float_f_f((l_190.f2 , l_188), (l_188 < ((void*)0 != &l_188)))), (0xF.DF83F4p-38 != p_89.f3)));
                if (l_195)
                { /* block id: 96 */
                    const union U1 **l_196 = (void*)0;
                    union U1 **l_197 = &l_103;
                    (*l_153) = 0x8D7FAAE3L;
                    (*l_197) = p_87;
                    /* statement id: 98 */
                    //assert (l_103 == 0 || l_103 == &l_260 || l_103 == &l_542);
                }
                else
                { /* block id: 99 */
                    union U1 **l_205 = &l_103;
                    for (l_97 = 17; (l_97 <= 24); l_97 = safe_add_func_int16_t_s_s(l_97, 1))
                    { /* block id: 102 */
                        l_200 = (*l_106);
                        /* statement id: 103 */
                        assert (l_200 == &p_86 || l_200 == 0 || l_200 == &l_104.f2);
                    }
                    /* facts after for loop */
                    assert (l_200 == &p_86 || l_200 == 0 || l_200 == &l_104.f2 || l_200 == &l_188);
                    for (p_86 = 0; (p_86 >= (-3)); p_86 = safe_sub_func_int64_t_s_s(p_86, 6))
                    { /* block id: 107 */
                        uint64_t l_206 = 0xADDFB1779622336ELL;
                        int32_t l_207 = 8L;
                        (*l_153) = p_89.f0;
                        l_207 = __builtin_popcountl(((((&p_87 != l_205) >= (l_206 < l_195)) , p_87) == p_87));
                        (*l_106) = (*l_106);
                    }
                }
                /* facts after branching */
                assert (l_200 == &p_86 || l_200 == 0 || l_200 == &l_104.f2 || l_200 == &l_188);
            }
            else
            { /* block id: 113 */
                union U1 l_215 = {65535UL};
                int64_t l_231 = (-4L);
                union U1 *l_236 = (void*)0;
                for (p_89.f0 = (-20); (p_89.f0 >= 1); p_89.f0 = safe_add_func_uint32_t_u_u(p_89.f0, 1))
                { /* block id: 116 */
                    const int32_t l_212 = (-1L);
                    int32_t *l_219 = (void*)0;
                    for (l_190.f0 = (-13); (l_190.f0 < (-8)); l_190.f0 = safe_add_func_int32_t_s_s(l_190.f0, 5))
                    { /* block id: 119 */
                        const uint16_t l_213 = 7UL;
                        if (l_212)
                            break;
                        if (l_213)
                            break;
                    }
                    (*l_106) = (void*)0;
                    /* statement id: 123 */
                    assert (l_107 == 0);
                    if (((~(((l_153 != (l_215 , l_216)) , (void*)0) != (void*)0)) && 0x4D6C3E8AL))
                    { /* block id: 124 */
                        (*l_153) = (l_212 >= (safe_sub_func_uint64_t_u_u(p_89.f1, (*l_200))));
                        (*l_106) = l_219;
                        (*l_106) = l_219;
                        (*l_106) = &p_86;
                        /* statement id: 128 */
                        assert (l_107 == &p_86);
                    }
                    else
                    { /* block id: 129 */
                        int8_t l_232 = 0xACL;
                        int32_t *l_233 = &l_154;
                        (*l_153) = ((0x22FAL < p_89.f4) || (((*l_153) ^ p_90) | (p_90 || (safe_rshift_func_int8_t_s_u(p_89.f1, ((*l_153) > (0xA79CL == ((((safe_div_func_int8_t_s_s(((safe_add_func_int8_t_s_s((safe_mod_func_int64_t_s_s((~((l_215.f0 ^ l_231) ^ (-10L))), p_88)), p_89.f1)) != p_90), (*l_200))) & l_215.f1) < 1UL) != l_232))))))));
                        return l_219;
                        /* statement id: 131 */
                        //assert (func_85_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_107 == &p_86);
                }
                for (p_89.f1 = 1; (p_89.f1 > 15); p_89.f1++)
                { /* block id: 136 */
                    l_236 = p_87;
                    if ((~0x29456BCAD55B1A04LL))
                    { /* block id: 138 */
                        (*l_216) = 0xB.DADB20p-67;
                        if ((*l_200))
                            break;
                    }
                    else
                    { /* block id: 141 */
                        (*l_153) = p_86;
                    }
                }
                /* facts after for loop */
                //assert (l_236 == 0 || l_236 == &l_260 || l_236 == &l_542);
            }
            /* facts after branching */
            assert (l_200 == &p_86 || l_200 == 0 || l_200 == &l_104.f2 || l_200 == &l_188);
            if (p_86)
                break;
            if (p_89.f2)
                break;
            (*l_106) = (void*)0;
            /* statement id: 148 */
            assert (l_107 == 0);
        }
        (*l_216) = 0x0.0p-1;
        if (l_190.f0)
            continue;
    }
    /* facts after for loop */
    //assert (l_103 == &l_104 || l_103 == 0 || l_103 == &l_260 || l_103 == &l_542);
    assert (l_107 == &p_86 || l_107 == 0 || l_107 == &l_104.f2);
    return l_242;
    /* statement id: 153 */
    //assert (func_85_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 190
   depth: 1, occurrence: 14
XXX total union variables: 7

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 172
   depth: 2, occurrence: 37
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 3
   depth: 9, occurrence: 3
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 2
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 188

XXX times a variable address is taken: 191
XXX times a pointer is dereferenced on RHS: 70
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 6
XXX times a pointer is dereferenced on LHS: 99
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 432

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 402
   level: 2, occurrence: 48
   level: 3, occurrence: 6
XXX number of pointers point to pointers: 73
XXX number of pointers point to scalars: 79
XXX number of pointers point to structs: 15
XXX percent of pointers has null in alias set: 29.8
XXX average alias set size: 1.2

XXX times a non-volatile is read: 817
XXX times a non-volatile is write: 253
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 163
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 34
   depth: 2, occurrence: 38
   depth: 3, occurrence: 14
   depth: 4, occurrence: 21
   depth: 5, occurrence: 21

XXX percentage a fresh-made variable is used: 16
XXX percentage an existing variable is used: 84
********************* end of statistics **********************/

