/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1530682461
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const signed f0 : 13;
   unsigned f1 : 16;
   unsigned f2 : 19;
   signed f3 : 18;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_28(void);
inline static uint8_t  func_33(int32_t * p_34);
static int32_t * func_35(uint32_t  p_36, const int16_t  p_37);
static int32_t  func_48(int32_t * p_49, int32_t  p_50);
static int16_t  func_60(int32_t  p_61, uint16_t  p_62);
inline static uint32_t  func_67(int64_t  p_68, uint16_t  p_69, uint32_t  p_70, const int64_t  p_71);
static uint64_t  func_76(float * p_77, int8_t  p_78, uint32_t  p_79, int32_t * p_80);
inline static int16_t  func_96(int8_t  p_97, int32_t * p_98);
inline static float ** func_102(int32_t ** const * p_103, int32_t * p_104, struct S0  p_105);
inline static uint32_t  func_108(int64_t  p_109, uint32_t  p_110, int64_t  p_111, uint32_t  p_112);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = 0x39C7C6F1L;
    int32_t *l_929 = &l_29;
    struct S0 l_941 = {53,211,565,-343};
    struct S0 *l_940 = &l_941;
    float * const **l_954 = (void*)0;
    const float ****l_960 = (void*)0;
    int32_t **l_961 = &l_929;
    uint8_t l_967 = 1UL;
    int64_t l_976 = 0xD211FA65427E7C23LL;
    int32_t *l_982 = (void*)0;
    int32_t l_988 = 0x641B2660L;
    uint8_t l_1006 = 0UL;
    uint32_t l_1007 = 6UL;
    if (l_29)
    { /* block id: 37 */
        int32_t l_30 = 0x44142B91L;
        int32_t *l_31 = &l_30;
        uint32_t l_927 = 0xF514122EL;
        struct S0 l_943 = {79,224,371,326};
        struct S0 *l_942 = &l_943;
lbl_935:
        (*l_31) = l_30;
        if ((+((void*)0 != &l_30)))
        { /* block id: 39 */
            int8_t l_38 = 0x0BL;
            (*l_31) = (func_33(func_35(l_38, (*l_31))) != (safe_add_func_uint32_t_u_u((safe_sub_func_uint8_t_u_u((safe_mod_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u(l_38, __builtin_popcountll(l_29))) || 251UL), ((safe_div_func_int8_t_s_s(0xDBL, 6L)) & (*l_31)))), l_29)), 0x601810E0L)));
            l_29 = (-((safe_mul_func_float_f_f((l_29 != ((safe_mul_func_float_f_f((safe_mul_func_float_f_f(__builtin_ctz((((void*)0 == &l_29) ^ ((safe_lshift_func_int16_t_s_u(l_29, 1)) ^ (__builtin_popcountll(l_927) < func_108(l_38, l_38, l_38, l_29))))), l_38)), (-0x1.4p-1))) < (*l_31))), l_29)) >= l_29));
        }
        else
        { /* block id: 456 */
            const int32_t **l_928 = (void*)0;
            float l_931 = 0x2.95CAF7p-23;
            float *l_930 = &l_931;
            l_929 = &l_29;
            (*l_930) = __builtin_ctzl((*l_929));
            for (l_29 = (-10); (l_29 <= 20); l_29 = safe_add_func_int32_t_s_s(l_29, 1))
            { /* block id: 461 */
                int32_t **l_934 = &l_929;
            }
            l_31 = &l_29;
            /* statement id: 464 */
            assert (l_31 == &l_29);
        }
        if (l_29)
            goto lbl_935;
        for (l_30 = 0; (l_30 == 0); l_30 = safe_add_func_uint32_t_u_u(l_30, 3))
        { /* block id: 469 */
            int32_t **l_938 = &l_31;
            (*l_938) = &l_30;
            /* statement id: 470 */
            assert (l_31 == &l_30);
            if (((func_33(&l_29) && (65527UL || (((*l_31) ^ 5L) != (**l_938)))) || (**l_938)))
            { /* block id: 471 */
                int32_t l_939 = 4L;
                return l_939;
            }
            else
            { /* block id: 473 */
                l_942 = l_940;
                /* statement id: 474 */
                assert (l_942 == &l_941);
                if ((*l_929))
                    break;
            }
            /* facts after branching */
            assert (l_942 == &l_941);
        }
        /* facts after for loop */
        assert (l_942 == &l_941 || l_942 == &l_943);
    }
    else
    { /* block id: 478 */
        float l_946 = 0x1.Ep+1;
        int32_t l_949 = 0L;
        int32_t **l_962 = (void*)0;
        if (__builtin_ctzl(((*l_929) == (((safe_sub_func_uint16_t_u_u((*l_929), (safe_mul_func_uint8_t_u_u((l_949 ^ (safe_div_func_int32_t_s_s((safe_mul_func_uint16_t_u_u(l_949, 65534UL)), (*l_929)))), ((void*)0 != l_954))))) > (*l_929)) <= l_949))))
        { /* block id: 479 */
            uint32_t l_955 = 0xC432F01FL;
            const float *l_959 = &l_946;
            const float **l_958 = &l_959;
            const float ***l_957 = &l_958;
            const float ****l_956 = &l_957;
            l_949 = l_949;
            (*l_929) = l_955;
            l_960 = l_956;
            /* statement id: 482 */
            assert (l_960 == &l_957);
            l_962 = l_961;
            /* statement id: 483 */
            assert (l_962 == &l_929);
        }
        else
        { /* block id: 484 */
            (*l_929) = (0x695D93D2466FFA20LL & (safe_rshift_func_int16_t_s_s((*l_929), 15)));
        }
        /* facts after branching */
        //assert (l_960 == 0 || l_960 == dangling);
        assert (l_962 == 0 || l_962 == &l_929);
    }
    /* facts after branching */
    //assert (l_960 == 0 || l_960 == dangling);
    if ((safe_rshift_func_uint8_t_u_u(l_967, (safe_add_func_uint32_t_u_u(((safe_div_func_uint8_t_u_u((safe_rshift_func_uint8_t_u_s(((*l_929) != l_976), 7)), (*l_929))) >= (((**l_961) ^ (safe_rshift_func_int8_t_s_u(0L, ((*l_929) <= (safe_rshift_func_uint16_t_u_u(65528UL, 13)))))) < ((((0x40D0L ^ 0xF82DL) == 0xED47C84273E10B51LL) || 0xC669L) < (*l_929)))), (*l_929))))))
    { /* block id: 488 */
        int32_t *l_981 = (void*)0;
        (*l_961) = l_981;
        /* statement id: 489 */
        assert (l_929 == 0);
        l_981 = (*l_961);
    }
    else
    { /* block id: 491 */
        int32_t l_987 = 0L;
        uint8_t l_992 = 9UL;
        struct S0 * const *l_998 = &l_940;
        int32_t l_1005 = 0x47B6EC19L;
        (*l_961) = func_35((**l_961), (**l_961));
        /* statement id: 492 */
        assert (l_929 == 0);
        (*l_961) = l_982;
        (*l_961) = func_35((safe_lshift_func_int8_t_s_s((safe_mul_func_uint8_t_u_u(0x7FL, l_987)), (0xB0L ^ l_988))), l_987);
        if ((!(safe_mod_func_int64_t_s_s(0L, l_987))))
        { /* block id: 495 */
            int16_t l_997 = (-10L);
            struct S0 **l_999 = &l_940;
            int32_t *l_1002 = (void*)0;
            int32_t l_1003 = 0x0A7D873FL;
            (*l_961) = func_35(l_992, ((((safe_lshift_func_int16_t_s_u(l_992, 11)) || (safe_lshift_func_uint8_t_u_s(l_997, 3))) >= (l_998 != l_999)) != (safe_lshift_func_uint16_t_u_u((l_987 >= l_997), 7))));
            l_1003 = l_992;
        }
        else
        { /* block id: 498 */
            l_1005 = (+0x8.6B8A09p+21);
            l_1007 = (l_1006 > l_992);
            return l_1005;
        }
    }
    /* facts after branching */
    assert (l_929 == 0);
    return l_941.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_33(int32_t * p_34)
{ /* block id: 43 */
    int16_t l_47 = 1L;
    const int32_t l_812 = 0x1021A53DL;
    const int32_t *l_811 = &l_812;
    const int32_t **l_810 = &l_811;
    const int32_t ***l_809 = &l_810;
    int32_t l_813 = (-9L);
    int32_t l_817 = 0x7F695413L;
    const int32_t l_858 = 0xC7E25209L;
    int16_t l_905 = 0xE059L;
    int32_t *l_906 = &l_817;
    uint64_t l_907 = 0x307146BA8B68D8ECLL;
    if (((p_34 != (void*)0) | l_47))
    { /* block id: 44 */
        uint8_t l_55 = 252UL;
        const uint8_t l_792 = 0xC1L;
        uint32_t l_794 = 1UL;
        int32_t l_801 = 0xC5895F3DL;
        struct S0 l_833 = {-25,164,587,-142};
        struct S0 *l_832 = &l_833;
        int32_t l_852 = 0xFD69CF70L;
        int32_t *l_904 = &l_801;
        int32_t **l_903 = &l_904;
        int32_t ***l_902 = &l_903;
        int32_t *** const *l_901 = &l_902;
        int32_t *** const **l_900 = &l_901;
        if (func_48(func_35(l_47, (safe_add_func_int16_t_s_s((safe_sub_func_int32_t_s_s(l_55, l_47)), (safe_rshift_func_int16_t_s_u(0x93CBL, 11))))), (safe_rshift_func_int16_t_s_s(func_60((((safe_mul_func_int8_t_s_s(l_55, ((safe_sub_func_uint32_t_u_u(((__builtin_ctzl((l_55 <= func_67(l_47, l_47, l_55, l_55))) >= l_47) ^ l_55), l_47)) ^ 9L))) >= 7L) == 0x4F2DA64149788E69LL), l_47), 5))))
        { /* block id: 376 */
            int32_t *** const l_771 = (void*)0;
            int32_t l_776 = 0L;
            int32_t *l_775 = &l_776;
            int32_t **l_774 = &l_775;
            int32_t ***l_773 = &l_774;
            int32_t ****l_772 = &l_773;
            (*l_772) = l_771;
            /* statement id: 377 */
            assert (l_773 == 0);
            l_774 = &p_34;
            /* statement id: 378 */
            assert (l_774 == &p_34);
        }
        else
        { /* block id: 379 */
            uint64_t l_777 = 0x1DE5444A55CB2507LL;
            float **l_793 = (void*)0;
            int32_t l_795 = 0x9B009DD5L;
            int32_t **l_796 = (void*)0;
            const int32_t *l_798 = &l_795;
            const int32_t **l_797 = &l_798;
            uint16_t l_802 = 0x8D68L;
            struct S0 l_804 = {-77,203,59,280};
            struct S0 *l_803 = &l_804;
            if (__builtin_popcount(l_777))
            { /* block id: 380 */
                int32_t l_779 = 6L;
                int32_t *l_778 = &l_779;
                (*l_778) = 0L;
                for (l_777 = 13; (l_777 < 46); ++l_777)
                { /* block id: 384 */
                    l_794 = ((0x9B28AA653F8B12B9LL <= l_47) > (((safe_add_func_uint64_t_u_u(l_777, (safe_mod_func_uint16_t_u_u(l_777, (safe_mod_func_int64_t_s_s((safe_rshift_func_int16_t_s_s(l_777, 9)), l_777)))))) ^ l_792) > ((void*)0 == l_793)));
                    if ((*l_778))
                        continue;
                    if (l_777)
                        continue;
                }
                l_795 = l_55;
            }
            else
            { /* block id: 390 */
                l_795 = l_795;
            }
            (*l_797) = (void*)0;
            /* statement id: 393 */
            assert (l_798 == 0);
            for (l_47 = 0; (l_47 > (-5)); l_47 = safe_sub_func_uint8_t_u_u(l_47, 1))
            { /* block id: 396 */
                uint32_t l_808 = 0x7FDE30B4L;
                float l_820 = (-0x4.0p-1);
                float *l_819 = &l_820;
                float **l_818 = &l_819;
                if ((l_801 > func_108(l_802, ((void*)0 != l_803), l_801, l_47)))
                { /* block id: 397 */
                    for (l_801 = 0; (l_801 != 21); l_801 = safe_add_func_uint32_t_u_u(l_801, 7))
                    { /* block id: 400 */
                        float ***l_807 = &l_793;
                        (*l_807) = (void*)0;
                        if (l_808)
                            break;
                        return l_801;
                    }
                    p_34 = func_35(l_801, l_47);
                    /* statement id: 405 */
                    assert (p_34 == 0);
                }
                else
                { /* block id: 406 */
                    l_813 = ((void*)0 != l_809);
                }
                if (l_808)
                    break;
            }
            (*l_797) = (**l_809);
            /* statement id: 433 */
            assert (l_798 == &l_812);
        }
        if ((safe_mod_func_uint16_t_u_u(0x64D7L, __builtin_clzll((safe_mul_func_uint8_t_u_u(l_833.f2, l_858))))))
        { /* block id: 435 */
            int32_t **l_861 = (void*)0;
            int32_t *** const l_860 = &l_861;
            int32_t ***l_869 = &l_861;
            int32_t ****l_868 = &l_869;
            (**l_809) = func_35(l_833.f3, (+func_67((l_860 == &l_861), (safe_add_func_uint32_t_u_u(0x5B966B89L, (255UL & l_833.f3))), (***l_809), ((safe_div_func_int32_t_s_s((safe_rshift_func_uint16_t_u_s(__builtin_parity(__builtin_clzl((***l_809))), 5)), (*l_811))) && l_801))));
            /* statement id: 436 */
            assert (l_811 == 0);
            (*l_868) = &l_810;
            /* statement id: 437 */
            assert (l_869 == &l_810);
            return l_833.f2;
        }
        else
        { /* block id: 439 */
            float l_873 = (-0x1.Bp-1);
            float *l_872 = &l_873;
            int32_t *l_891 = &l_813;
            int32_t **l_890 = &l_891;
            int32_t ***l_889 = &l_890;
            int32_t ****l_888 = &l_889;
            for (l_813 = 28; (l_813 < (-23)); --l_813)
            { /* block id: 442 */
                (*l_810) = &l_801;
                /* statement id: 443 */
                assert (l_811 == &l_801);
            }
            /* facts after for loop */
            assert (l_811 == &l_801 || l_811 == &l_812);
            (****l_888) = func_76(l_872, l_792, (((safe_rshift_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_s((((safe_lshift_func_uint8_t_u_s((safe_div_func_int64_t_s_s((((p_34 == (void*)0) & (safe_sub_func_int16_t_s_s((safe_add_func_int64_t_s_s((**l_810), ((safe_add_func_int8_t_s_s(((void*)0 == l_888), ((void*)0 != (*l_889)))) > 0x7C74L))), 0x3B48L))) <= (***l_889)), 0x75DB9EF530B2E415LL)), l_794)) > 65533UL) > l_852), 14)) && (****l_888)) & 0UL), (***l_809))) || l_833.f3) < l_794), (**l_889));
        }
        /* facts after branching */
        assert (l_811 == &l_801 || l_811 == &l_812);
        l_905 = (safe_mod_func_int8_t_s_s((((***l_809) | (&l_809 != (void*)0)) > (((safe_mul_func_uint16_t_u_u(0UL, (***l_809))) || (safe_add_func_int8_t_s_s(l_852, ((***l_809) != ((safe_rshift_func_int8_t_s_u((***l_809), ((void*)0 != l_900))) >= (****l_901)))))) || (****l_901))), (*l_811)));
        (*l_810) = l_906;
        /* statement id: 448 */
        assert (l_811 == &l_817);
    }
    else
    { /* block id: 449 */
        (*l_906) = (***l_809);
        (**l_809) = p_34;
        /* statement id: 451 */
        //assert (l_811 == 0 || l_811 == &l_29);
    }
    /* facts after branching */
    //assert (l_811 == 0 || l_811 == &l_817 || l_811 == &l_29);
    return l_907;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_35(uint32_t  p_36, const int16_t  p_37)
{ /* block id: 40 */
    uint16_t l_39 = 0x1E6EL;
    float l_41 = (-0x3.4p-1);
    float *l_40 = &l_41;
    int32_t l_43 = 1L;
    int32_t *l_42 = &l_43;
    int32_t *l_44 = &l_43;
    int32_t *l_45 = &l_43;
    int32_t *l_46 = (void*)0;
    (*l_40) = l_39;
    return l_46;
    /* statement id: 42 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_48(int32_t * p_49, int32_t  p_50)
{ /* block id: 302 */
    int64_t l_646 = (-7L);
    struct S0 l_648 = {-86,168,358,-364};
    const struct S0 *l_647 = &l_648;
    int32_t **l_675 = (void*)0;
    int32_t ***l_674 = &l_675;
    int32_t ****l_681 = &l_674;
    int32_t *****l_680 = &l_681;
    uint16_t l_690 = 0xA815L;
    int64_t l_710 = 0xF38A615054DA6279LL;
    float l_729 = (-0x1.0p-1);
    float *l_728 = &l_729;
    float **l_727 = &l_728;
    uint8_t l_766 = 0xDEL;
    int16_t l_767 = 1L;
    float *l_770 = (void*)0;
lbl_756:
    if (l_646)
    { /* block id: 303 */
        struct S0 *l_650 = &l_648;
        struct S0 **l_649 = &l_650;
        const int32_t l_653 = 0xD1FD5A2CL;
        int32_t **l_654 = (void*)0;
        int32_t *l_656 = (void*)0;
        int32_t **l_655 = &l_656;
        (*l_649) = l_647;
        l_648.f3 = ((safe_rshift_func_int16_t_s_s(l_648.f1, 2)) > l_653);
        (*l_655) = func_35(p_50, l_648.f1);
    }
    else
    { /* block id: 307 */
        int32_t l_679 = 0xF76C4CF8L;
        int32_t * const l_678 = &l_679;
        int32_t * const *l_677 = &l_678;
        int32_t * const **l_676 = &l_677;
        float **l_704 = (void*)0;
        float *** const l_703 = &l_704;
        float ***l_709 = (void*)0;
        float ****l_708 = &l_709;
        for (p_50 = 0; (p_50 <= (-29)); p_50 = safe_sub_func_uint64_t_u_u(p_50, 1))
        { /* block id: 310 */
            return p_50;
        }
        if ((safe_lshift_func_uint16_t_u_u(__builtin_ffs((!65528UL)), __builtin_popcountll(p_50))))
        { /* block id: 313 */
            for (p_50 = (-19); (p_50 == (-22)); --p_50)
            { /* block id: 316 */
                int32_t *l_665 = (void*)0;
                int32_t **l_664 = &l_665;
                (*l_664) = &p_50;
                /* statement id: 317 */
                assert (l_665 == &p_50);
            }
        }
        else
        { /* block id: 319 */
            int32_t l_669 = 0x5524F030L;
            int32_t *l_668 = &l_669;
            int32_t ** const ***l_682 = (void*)0;
            float *l_689 = (void*)0;
            float ** const l_688 = &l_689;
            float ***l_706 = (void*)0;
            float ****l_705 = &l_706;
            (*l_668) = (safe_sub_func_uint64_t_u_u(18446744073709551611UL, p_50));
            if ((safe_mod_func_int16_t_s_s((safe_sub_func_uint32_t_u_u((0x666494B753794C1ALL & (l_674 != l_676)), ((l_680 != l_682) < (safe_div_func_int16_t_s_s((safe_add_func_uint8_t_u_u(((!((void*)0 != l_688)) < p_50), ((p_50 > l_690) && (*l_678)))), p_50))))), p_50)))
            { /* block id: 321 */
                for (p_50 = 0; (p_50 == 9); p_50++)
                { /* block id: 324 */
                    int32_t **l_693 = (void*)0;
                    p_49 = &p_50;
                    /* statement id: 325 */
                    assert (p_49 == &p_50);
                }
                /* facts after for loop */
                assert (p_49 == &p_50 || p_49 == 0);
                (**l_677) = (safe_lshift_func_int8_t_s_u((safe_mul_func_int8_t_s_s(__builtin_parityll((safe_add_func_uint8_t_u_u(p_50, (**l_677)))), 0x2AL)), 3));
            }
            else
            { /* block id: 328 */
                int32_t l_700 = 0xE71D0E71L;
                float *l_701 = (void*)0;
                int32_t **l_702 = &l_668;
                (**l_677) = p_50;
                (*l_668) = l_700;
                (*l_702) = &p_50;
                /* statement id: 331 */
                assert (l_668 == &p_50);
            }
            /* facts after branching */
            assert (p_49 == &p_50 || p_49 == 0);
            assert (l_668 == &p_50 || l_668 == &l_669);
            (*l_705) = l_703;
            /* statement id: 333 */
            assert (l_706 == &l_704);
            (**l_677) = (~p_50);
        }
        /* facts after branching */
        assert (p_49 == &p_50 || p_49 == 0);
        (*l_708) = &l_704;
        /* statement id: 336 */
        assert (l_709 == &l_704);
        return l_710;
    }
    for (l_646 = 0; (l_646 < (-23)); l_646 = safe_sub_func_int32_t_s_s(l_646, 7))
    { /* block id: 341 */
        int8_t l_718 = (-1L);
        float *** const l_724 = (void*)0;
        float *** const *l_723 = &l_724;
        float *** const **l_722 = &l_723;
        int32_t l_764 = 0xFF522D7EL;
        for (l_690 = 0; (l_690 <= 7); l_690 = safe_add_func_uint32_t_u_u(l_690, 8))
        { /* block id: 344 */
            uint8_t l_717 = 0x49L;
            int16_t l_748 = 0x739DL;
            float ** const **l_754 = (void*)0;
            int32_t *l_765 = &l_764;
            for (l_710 = 0; (l_710 != (-24)); l_710 = safe_sub_func_uint32_t_u_u(l_710, 6))
            { /* block id: 347 */
                int32_t *l_719 = (void*)0;
                int32_t l_721 = 1L;
                int32_t *l_720 = &l_721;
                l_718 = l_717;
                (*l_720) = (0x4FL | 7UL);
            }
            l_722 = l_722;
            if ((safe_mul_func_uint16_t_u_u((l_727 != &l_728), (safe_add_func_uint16_t_u_u(func_108((safe_sub_func_uint64_t_u_u(func_67(p_50, (safe_lshift_func_int8_t_s_s(__builtin_ctz(__builtin_ffsll(p_50)), ((-10L) && (safe_add_func_int64_t_s_s((-1L), p_50))))), p_50, p_50), p_50)), p_50, p_50, p_50), l_718)))))
            { /* block id: 352 */
                const int8_t l_753 = (-10L);
                float *****l_760 = (void*)0;
                if ((0x17L | (p_50 & (func_108((safe_lshift_func_int8_t_s_s((+((((safe_rshift_func_int8_t_s_u(((safe_sub_func_int8_t_s_s(((((!p_50) | (&l_647 != &l_647)) == (((safe_lshift_func_int8_t_s_u(l_748, 6)) != (safe_sub_func_uint64_t_u_u((p_50 & p_50), (safe_mul_func_int16_t_s_s(l_753, 0UL))))) & 0x20A7B3CB56F7A7FCLL)) == l_748), l_718)) != l_718), l_748)) == p_50) & l_718) == 0xD8C1L)), 3)), p_50, p_50, p_50) || l_718))))
                { /* block id: 353 */
                    return l_718;
                }
                else
                { /* block id: 355 */
                    int32_t *l_755 = (void*)0;
                    float ****l_759 = (void*)0;
                    float ***** const l_758 = &l_759;
                    int32_t l_762 = 1L;
                    if ((func_96(((void*)0 != l_754), l_755) <= 0xA6L))
                    { /* block id: 356 */
                        if (l_648.f1)
                            goto lbl_756;
                    }
                    else
                    { /* block id: 358 */
                        int16_t l_757 = 0x90FBL;
                        int32_t l_761 = 0x5C6613F7L;
                        if (p_50)
                            break;
                        if (l_757)
                            break;
                        l_761 = (l_758 == l_760);
                        (**l_727) = ((p_50 >= p_50) > l_762);
                    }
                }
                return p_50;
            }
            else
            { /* block id: 366 */
                const uint16_t l_763 = 0x2AAEL;
                l_764 = (l_763 ^ 1UL);
                (*l_728) = l_748;
            }
            (*l_765) = l_717;
        }
        l_764 = __builtin_ffsll(p_50);
    }
    (*l_728) = (((p_50 != l_766) == (l_767 == (p_50 < ((-0x4.4p+1) >= p_50)))) >= (func_67((safe_rshift_func_uint16_t_u_u((p_49 == l_770), 15)), p_50, p_50, p_50) >= p_50));
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_60(int32_t  p_61, uint16_t  p_62)
{ /* block id: 290 */
    int32_t ***l_632 = (void*)0;
    int32_t ****l_631 = &l_632;
    int32_t *****l_630 = &l_631;
    int32_t l_645 = 9L;
    int32_t *l_644 = &l_645;
    int32_t **l_643 = &l_644;
    if (((7UL > (safe_sub_func_int8_t_s_s(1L, p_61))) > (safe_lshift_func_int16_t_s_s(p_61, ((safe_div_func_uint8_t_u_u((((__builtin_popcount((safe_sub_func_int16_t_s_s(0xA7BAL, (l_630 == &l_631)))) ^ p_62) >= p_62) | 4294967290UL), 7L)) != 0xEF63F7DBL)))))
    { /* block id: 291 */
        float *l_633 = (void*)0;
        float *l_634 = (void*)0;
        float l_636 = 0x0.8BB4B7p+96;
        float *l_635 = &l_636;
        (*l_635) = 0xB.D7B228p+56;
    }
    else
    { /* block id: 293 */
        const int32_t l_640 = 1L;
        for (p_62 = 0; (p_62 != 41); p_62++)
        { /* block id: 296 */
            int32_t **l_639 = (void*)0;
            int32_t *l_642 = (void*)0;
            int32_t **l_641 = &l_642;
            (*l_641) = func_35(((void*)0 != l_639), l_640);
        }
    }
    (*l_643) = &p_61;
    /* statement id: 300 */
    assert (l_644 == &p_61);
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_67(int64_t  p_68, uint16_t  p_69, uint32_t  p_70, const int64_t  p_71)
{ /* block id: 45 */
    int32_t l_75 = 0x2F109D40L;
    int32_t *l_74 = &l_75;
    struct S0 l_264 = {-65,27,565,180};
    struct S0 *l_263 = &l_264;
    float **l_285 = (void*)0;
    int8_t l_306 = 0xECL;
    uint64_t l_397 = 0xF6474447B22930BFLL;
    float ***l_407 = &l_285;
    float ****l_406 = &l_407;
    struct S0 ** const l_420 = (void*)0;
    uint32_t l_434 = 0xCA4E295CL;
    int32_t * const l_450 = &l_75;
    const uint8_t l_472 = 0x0DL;
    int32_t **l_513 = &l_74;
    int32_t ***l_512 = &l_513;
    int32_t ****l_511 = &l_512;
    int32_t ***** const l_510 = &l_511;
    const float l_589 = (-0x6.Cp-1);
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_76(float * p_77, int8_t  p_78, uint32_t  p_79, int32_t * p_80)
{ /* block id: 46 */
    uint32_t l_83 = 0xC4D35571L;
    float l_85 = 0xD.75542Ep+73;
    float *l_84 = &l_85;
    int32_t *l_139 = (void*)0;
    uint16_t l_145 = 0UL;
    int32_t l_146 = (-3L);
    int32_t **l_157 = (void*)0;
    int32_t ***l_156 = &l_157;
    int32_t ****l_155 = &l_156;
    int32_t *****l_154 = &l_155;
    struct S0 *l_182 = (void*)0;
    struct S0 **l_181 = &l_182;
    float **l_226 = &l_84;
    float ***l_225 = &l_226;
    int32_t l_234 = 0xC7D00A8CL;
    uint32_t l_237 = 0x1F430733L;
    int32_t **l_238 = (void*)0;
    int32_t **l_239 = &l_139;
lbl_165:
    (*l_84) = l_83;
    for (p_79 = 0; (p_79 < 3); p_79 = safe_add_func_uint8_t_u_u(p_79, 2))
    { /* block id: 50 */
        const int32_t l_91 = 0xF73439D6L;
        const int32_t *l_90 = &l_91;
        const int32_t **l_89 = &l_90;
        const int32_t ***l_88 = &l_89;
        int32_t *** const **l_136 = (void*)0;
        int32_t ****l_138 = (void*)0;
        int32_t *****l_137 = &l_138;
        (*l_88) = (void*)0;
        /* statement id: 51 */
        assert (l_89 == 0);
        (*l_84) = (p_79 != (l_83 == (((safe_sub_func_float_f_f(p_78, __builtin_bswap64((((void*)0 == &p_80) ^ __builtin_bswap64((0x08D8C4114487F17ELL & ((~(!__builtin_parity((*l_90)))) || func_96(p_78, p_77)))))))) > l_83) >= p_79)));
        (*l_137) = (void*)0;
        l_139 = (void*)0;
        /* statement id: 66 */
        assert (l_139 == 0);
    }
    if (func_96(p_78, l_139))
    { /* block id: 68 */
        struct S0 l_142 = {25,1,216,281};
        struct S0 *l_141 = &l_142;
        struct S0 **l_140 = &l_141;
        uint32_t l_198 = 0x433CC51AL;
        float **l_222 = (void*)0;
        float ***l_221 = &l_222;
        uint64_t l_227 = 1UL;
        int32_t ***l_230 = &l_157;
        (*l_140) = (void*)0;
        /* statement id: 69 */
        assert (l_141 == 0);
        for (p_79 = (-11); (p_79 >= 29); ++p_79)
        { /* block id: 72 */
            int32_t **l_147 = &l_139;
            int64_t l_178 = (-1L);
            l_146 = l_145;
            (*l_147) = &l_146;
            /* statement id: 74 */
            assert (l_139 == &l_146);
            if ((safe_lshift_func_uint16_t_u_s((((void*)0 != (*l_147)) < p_78), (**l_147))))
            { /* block id: 75 */
                int8_t l_164 = 1L;
                (*l_147) = func_35(func_108(func_96((func_96((**l_147), func_35((*l_139), (safe_mod_func_uint64_t_u_u((safe_sub_func_uint64_t_u_u(((void*)0 != l_154), __builtin_parity((safe_lshift_func_int16_t_s_s((p_78 != ((safe_rshift_func_int8_t_s_u(__builtin_ctzl((**l_147)), ((safe_sub_func_uint16_t_u_u(((((__builtin_ctzl(p_78) != 4294967290UL) ^ p_79) == l_142.f0) & l_142.f2), p_78)) != l_142.f0))) || l_142.f0)), p_79))))), p_79)))) <= 0x9086L), p_80), (*l_139), l_142.f3, l_164), l_164);
                /* statement id: 76 */
                assert (l_139 == 0);
            }
            else
            { /* block id: 77 */
                int16_t l_173 = (-5L);
                if (l_83)
                    goto lbl_165;
                l_142.f3 = ((l_142.f1 == (safe_add_func_int64_t_s_s(((((**l_147) != (safe_mul_func_uint16_t_u_u((((((safe_mod_func_uint32_t_u_u(((0x5F29L != (+(*l_139))) & (p_78 <= l_173)), p_79)) <= (safe_lshift_func_int8_t_s_s((0UL & ((safe_add_func_int8_t_s_s(p_78, 0x1BL)) > l_173)), p_79))) == 1UL) < l_142.f0) & p_79), l_178))) != l_173) == 18446744073709551611UL), p_78))) <= l_173);
            }
            /* facts after branching */
            assert (l_139 == &l_146 || l_139 == 0);
            (*l_84) = (((p_79 == 0x0.1p-1) <= (safe_sub_func_float_f_f(__builtin_ia32_crc32qi(p_78, p_79), l_178))) >= ((void*)0 != l_181));
        }
        p_80 = p_77;
        /* statement id: 83 */
        //assert (p_80 == 0 || p_80 == &l_268 || p_80 == &l_75 || p_80 == &l_873);
        if ((safe_mul_func_uint8_t_u_u((~__builtin_popcount(((safe_div_func_int64_t_s_s((safe_lshift_func_uint8_t_u_s(((((l_142.f2 ^ ((safe_mul_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_u((p_79 < (safe_lshift_func_int8_t_s_u(__builtin_ctzll(p_79), 7))), 3)) <= (safe_lshift_func_int16_t_s_s(__builtin_popcountl(p_78), 15))), ((-4L) > l_142.f2))) || (l_142.f1 && p_78))) > l_198) < p_79) || 0L), p_79)), p_79)) == p_78))), l_142.f1)))
        { /* block id: 84 */
            int32_t l_215 = 0x00D3CD37L;
lbl_231:
            for (l_145 = 29; (l_145 < 6); l_145 = safe_sub_func_int32_t_s_s(l_145, 1))
            { /* block id: 87 */
                int32_t l_210 = 0xFDBAA038L;
                int32_t *l_216 = &l_146;
                for (p_79 = (-6); (p_79 < 33); ++p_79)
                { /* block id: 90 */
                    uint32_t l_207 = 0x26C0DD84L;
                    int32_t *l_217 = &l_215;
                    const float ** const **l_223 = (void*)0;
                    float ****l_224 = (void*)0;
                    if (func_96((p_78 && ((safe_div_func_int16_t_s_s(func_96((safe_rshift_func_int8_t_s_s(0xF6L, (l_207 <= (p_79 ^ (safe_add_func_uint64_t_u_u((l_210 && (safe_add_func_int32_t_s_s((safe_sub_func_int16_t_s_s((&p_77 != (void*)0), 0x17EAL)), (-5L)))), l_215)))))), l_216), 4L)) != (*l_216))), l_217))
                    { /* block id: 91 */
                        int32_t *** const *l_218 = (void*)0;
                        int32_t *** const **l_219 = &l_218;
                        struct S0 *l_220 = &l_142;
                        (*l_219) = l_218;
                        (*l_216) = ((*l_140) == l_220);
                    }
                    else
                    { /* block id: 94 */
                        return p_78;
                    }
                    l_225 = l_221;
                    /* statement id: 97 */
                    assert (l_225 == &l_222);
                    if (l_227)
                        continue;
                }
                /* facts after for loop */
                assert (l_225 == &l_222 || l_225 == &l_226);
                return p_78;
            }
            p_80 = p_77;
            for (l_145 = 11; (l_145 != 41); l_145 = safe_add_func_int32_t_s_s(l_145, 6))
            { /* block id: 105 */
                (*l_155) = l_230;
                if (l_198)
                    goto lbl_231;
            }
        }
        else
        { /* block id: 109 */
            int32_t **l_232 = (void*)0;
            int32_t **l_233 = &l_139;
            (*l_233) = p_80;
            /* statement id: 110 */
            //assert (l_139 == 0 || l_139 == &l_268 || l_139 == &l_75 || l_139 == &l_873);
            (***l_225) = l_234;
            (*l_233) = func_35(p_79, p_79);
            /* statement id: 112 */
            assert (l_139 == 0);
        }
    }
    else
    { /* block id: 114 */
        (**l_226) = p_79;
    }
    /* facts after branching */
    //assert (p_80 == 0 || p_80 == &l_268 || p_80 == &l_75 || p_80 == &l_813 || p_80 == &l_873);
    (*l_239) = func_35(p_78, (safe_sub_func_int32_t_s_s((0UL <= p_79), __builtin_ctzl(l_237))));
    /* statement id: 117 */
    assert (l_139 == 0);
    return p_79;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_96(int8_t  p_97, int32_t * p_98)
{ /* block id: 52 */
    const uint64_t l_99 = 0xF29C70A1111CD9E9LL;
    int32_t l_101 = 4L;
    int32_t *l_100 = &l_101;
    int32_t ** const l_107 = &l_100;
    int32_t ** const *l_106 = &l_107;
    struct S0 l_118 = {-19,152,223,381};
    float *l_135 = (void*)0;
    float **l_134 = &l_135;
    (*l_100) = l_99;
    l_134 = func_102(l_106, func_35(func_108((**l_107), (***l_106), p_97, p_97), (0x5E6AD316L >= (((***l_106) >= 1L) ^ (*l_100)))), l_118);
    /* statement id: 62 */
    assert (l_134 == 0);
    return p_97;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float ** func_102(int32_t ** const * p_103, int32_t * p_104, struct S0  p_105)
{ /* block id: 59 */
    float l_119 = 0x0.8p+1;
    int32_t l_120 = 0x6BBCA57EL;
    uint32_t l_130 = 0UL;
    float *l_131 = &l_119;
    float **l_132 = &l_131;
    float **l_133 = (void*)0;
    (*l_131) = func_108(p_105.f0, p_105.f1, l_120, ((0xD53BL | ((safe_mul_func_uint16_t_u_u(p_105.f0, ((safe_mod_func_uint8_t_u_u(func_108(l_120, p_105.f2, (safe_add_func_int16_t_s_s(l_120, (((safe_div_func_uint64_t_u_u((~((p_105.f2 == p_105.f1) > p_105.f2)), l_120)) <= 0x91E6L) | 0x8EC6L))), l_120), p_105.f2)) || l_130))) <= p_105.f0)) && l_130));
    return l_133;
    /* statement id: 61 */
    //assert (func_102_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_108(int64_t  p_109, uint32_t  p_110, int64_t  p_111, uint32_t  p_112)
{ /* block id: 54 */
    int32_t l_114 = (-1L);
    int32_t *l_113 = &l_114;
    int32_t **l_115 = &l_113;
    float l_117 = 0xD.A2FD92p+80;
    float *l_116 = &l_117;
    l_113 = l_113;
    (*l_115) = func_35(p_110, p_110);
    /* statement id: 56 */
    assert (l_113 == 0);
    (*l_116) = 0x5.1p-1;
    return p_112;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 225
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 6
XXX full-bitfields structs in the program: 1
breakdown:
   indirect level: 0, occurrence: 1
XXX times a bitfields struct's address is taken: 9
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 31

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 191
   depth: 2, occurrence: 30
   depth: 3, occurrence: 10
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 13, occurrence: 5
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 264

XXX times a variable address is taken: 233
XXX times a pointer is dereferenced on RHS: 143
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 41
   depth: 3, occurrence: 15
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 132
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 19
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 43
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 18
XXX times a pointer is qualified to be dereferenced: 599

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 627
   level: 2, occurrence: 246
   level: 3, occurrence: 223
   level: 4, occurrence: 48
   level: 5, occurrence: 20
XXX number of pointers point to pointers: 165
XXX number of pointers point to scalars: 87
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 32.2
XXX average alias set size: 1.19

XXX times a non-volatile is read: 1105
XXX times a non-volatile is write: 377
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 7

XXX stmts: 168
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 37
   depth: 2, occurrence: 50
   depth: 3, occurrence: 29
   depth: 4, occurrence: 12
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 19.9
XXX percentage an existing variable is used: 80.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

