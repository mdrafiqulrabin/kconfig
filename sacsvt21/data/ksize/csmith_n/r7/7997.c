/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3326513858
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int64_t  f0;
   float  f1;
   int32_t  f2;
   uint16_t  f3;
   uint16_t  f4;
   uint16_t  f5;
   float  f6;
   const uint32_t  f7;
};

union U1 {
   uint32_t  f0;
   float  f1;
   struct S0  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_32(void);
static struct S0 * func_33(uint32_t  p_34, struct S0 * p_35, struct S0 * p_36, int64_t  p_37, int32_t  p_38);
static int16_t  func_48(float  p_49, uint32_t  p_50, struct S0 * p_51);
inline static const float  func_57(struct S0 * p_58, int32_t  p_59, struct S0 * p_60, int32_t  p_61, struct S0 * p_62);
inline static struct S0 * func_63(int32_t  p_64, int32_t  p_65);
inline static int32_t * func_68(uint8_t  p_69, struct S0 * p_70, struct S0 * const  p_71, uint32_t  p_72, union U1  p_73);
inline static uint64_t  func_76(const struct S0  p_77, uint64_t  p_78, const int32_t * p_79);
inline static struct S0  func_80(struct S0 * p_81);
static struct S0 * func_82(uint32_t  p_83, float  p_84, int16_t  p_85, struct S0 * p_86);
inline static uint32_t  func_87(struct S0 * p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_32(void)
{ /* block id: 36 */
    int32_t l_45 = 0xD03B15A8L;
    struct S0 *l_56 = (void*)0;
    struct S0 **l_1010 = &l_56;
    int32_t **l_1013 = (void*)0;
    int32_t ***l_1012 = &l_1013;
    int32_t ****l_1011 = &l_1012;
    float *l_1014 = (void*)0;
    float l_1016 = 0x0.Ap-1;
    float *l_1015 = &l_1016;
    (*l_1010) = func_33((safe_add_func_int8_t_s_s((safe_add_func_int32_t_s_s((safe_add_func_int32_t_s_s(l_45, (safe_mod_func_int16_t_s_s(func_48((((safe_add_func_float_f_f(__builtin_popcountll(l_45), l_45)) == (safe_sub_func_float_f_f(l_45, (l_45 >= (((l_56 != (void*)0) != (func_57(func_63(l_45, l_45), l_45, l_56, l_45, l_56) < l_45)) <= 0xE.8FEAC0p-13))))) != (-0x4.7p-1)), l_45, l_56), 0xA9BAL)))), l_45)), l_45)), l_56, l_56, l_45, l_45);
    (*l_1015) = ((void*)0 == l_1011);
    return l_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_33(uint32_t  p_34, struct S0 * p_35, struct S0 * p_36, int64_t  p_37, int32_t  p_38)
{ /* block id: 545 */
    int32_t l_987 = 0xE2818117L;
    union U1 l_996 = {0x008AAB26L};
    union U1 *l_995 = &l_996;
    union U1 **l_994 = &l_995;
    union U1 ***l_1007 = &l_994;
    struct S0 l_1009 = {0xB5D3342768C4D219LL,-0x8.Bp+1,-10L,0x7DB7L,65535UL,0x7C32L,-0x4.9p-1,0xD7D37819L};
    struct S0 *l_1008 = &l_1009;
    if (((l_987 > (safe_rshift_func_int16_t_s_u(1L, (safe_rshift_func_int8_t_s_u((-1L), 1))))) | (safe_add_func_uint64_t_u_u(l_987, (l_994 != &l_995)))))
    { /* block id: 546 */
        int32_t l_997 = (-1L);
        const int32_t *l_1000 = &l_987;
        struct S0 l_1003 = {0xCF4360B09C2FB268LL,-0x4.2p-1,9L,6UL,0x8CB2L,0UL,0x4.Cp-1,1UL};
        struct S0 *l_1002 = &l_1003;
        struct S0 **l_1001 = &l_1002;
        float *l_1004 = &l_996.f1;
        (*l_1001) = func_63((l_997 | (safe_lshift_func_uint8_t_u_u(((l_996.f0 >= ((p_37 <= l_997) & (l_997 & __builtin_parity(p_34)))) > (l_987 == ((((((l_1000 != &p_38) <= l_996.f3) > 1L) | (*l_1000)) ^ 0x0A0F9877L) ^ p_38))), l_987))), (*l_1000));
        /* statement id: 547 */
        assert (l_1002 == 0);
        (*l_1004) = 0x3.37CEB4p-72;
        /* statement id: 548 */
            }
    else
    { /* block id: 549 */
        int32_t *l_1005 = &l_987;
        int32_t **l_1006 = &l_1005;
        (*l_994) = (*l_994);
        (*l_1006) = l_1005;
    }
    /* facts after branching */
        (*l_1007) = &l_995;
    return p_35;
    /* statement id: 554 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_48(float  p_49, uint32_t  p_50, struct S0 * p_51)
{ /* block id: 535 */
    int32_t l_962 = (-1L);
    const int32_t * const l_961 = &l_962;
    const int32_t *l_964 = &l_962;
    const int32_t **l_963 = &l_964;
    struct S0 l_979 = {5L,0x6.E40599p-32,0L,0x9F1FL,0xEFD2L,0x76A2L,0x0.1225EAp+50,1UL};
    struct S0 *l_978 = &l_979;
    union U1 l_980 = {0UL};
    int32_t *l_986 = &l_962;
    (*l_963) = l_961;
    for (p_50 = 17; (p_50 >= 34); p_50 = safe_add_func_int16_t_s_s(p_50, 7))
    { /* block id: 539 */
        int32_t l_969 = (-4L);
        float *l_985 = (void*)0;
        float **l_984 = &l_985;
        float ***l_983 = &l_984;
        float ****l_982 = &l_983;
        float *****l_981 = &l_982;
        (*l_963) = (*l_963);
        (*l_981) = (void*)0;
        /* statement id: 541 */
        assert (l_982 == 0);
    }
    (*l_986) = p_50;
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const float  func_57(struct S0 * p_58, int32_t  p_59, struct S0 * p_60, int32_t  p_61, struct S0 * p_62)
{ /* block id: 530 */
    int64_t l_944 = 0xD64744DF4F4DEA61LL;
    struct S0 l_954 = {0xEC5EFF230660A0A0LL,0xE.F32C32p-22,0xC07FF9CEL,65532UL,3UL,65533UL,0xB.8E485Dp+78,4294967293UL};
    struct S0 *l_953 = &l_954;
    struct S0 **l_952 = &l_953;
    struct S0 ***l_951 = &l_952;
    float *l_957 = &l_954.f6;
    uint8_t l_958 = 0UL;
    int32_t l_960 = (-3L);
    int32_t *l_959 = &l_960;
    (*l_957) = ((safe_div_func_float_f_f((safe_mul_func_float_f_f(l_944, ((safe_sub_func_float_f_f(((safe_mul_func_float_f_f((((safe_sub_func_float_f_f(l_944, (l_951 != (void*)0))) > l_954.f0) == (((safe_sub_func_float_f_f(l_954.f2, __builtin_ffsl(__builtin_bswap32(p_61)))) < l_954.f3) != p_61)), 0x1.71715Bp-94)) != 0x5.01D554p+75), l_944)) >= l_944))), l_954.f3)) < 0x1.3p-1);
    (*l_957) = l_958;
    (*l_959) = l_954.f2;
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_63(int32_t  p_64, int32_t  p_65)
{ /* block id: 37 */
    struct S0 l_90 = {0xFBA349A2DD318431LL,-0x1.7p-1,0x3D0097E4L,0x0F71L,0x50D5L,1UL,0x2.30988Ap-62,0xEC743572L};
    struct S0 *l_89 = &l_90;
    int32_t l_103 = 0x3FF50EDCL;
    int32_t *l_102 = &l_103;
    struct S0 * const l_611 = &l_90;
    struct S0 *l_936 = &l_90;
    struct S0 *l_937 = &l_90;
    struct S0 *l_938 = &l_90;
    struct S0 *l_939 = (void*)0;
    for (p_64 = (-25); (p_64 < 24); p_64 = safe_add_func_uint32_t_u_u(p_64, 6))
    { /* block id: 40 */
        struct S0 * const l_99 = &l_90;
        int32_t l_101 = 0x3C758019L;
        int32_t *l_100 = &l_101;
        union U1 l_612 = {0UL};
        const int32_t *l_880 = &l_103;
        const int32_t **l_879 = &l_880;
        (*l_879) = func_68(((safe_div_func_uint64_t_u_u(func_76(func_80(func_82(func_87(l_89), l_90.f4, (p_65 | (safe_mul_func_uint8_t_u_u(0x2DL, __builtin_parity(((l_99 != l_99) || (l_100 == l_102)))))), &l_90)), (*l_100), &l_103), (*l_100))) & 0xFA7069FDL), &l_90, l_611, (*l_100), l_612);
        /* statement id: 495 */
        assert (l_880 == 0);
    }
    (*l_102) = p_65;
    if (func_76((*l_89), (*l_102), &l_103))
    { /* block id: 498 */
        const int32_t l_881 = (-5L);
        union U1 l_898 = {0xEBC93006L};
        const int32_t *l_900 = &l_103;
        int32_t **l_903 = &l_102;
        float *l_918 = &l_90.f1;
        float **l_917 = &l_918;
        float *** const l_916 = &l_917;
        float *** const * const l_915 = &l_916;
        float *** const * const *l_914 = &l_915;
        struct S0 *l_927 = &l_90;
        struct S0 *l_929 = (void*)0;
        (*l_102) = l_881;
        for (l_90.f2 = 3; (l_90.f2 < 28); ++l_90.f2)
        { /* block id: 502 */
            struct S0 *l_886 = &l_90;
            int32_t l_891 = 0x8FCDE178L;
            int32_t *l_930 = (void*)0;
            if ((safe_lshift_func_uint8_t_u_s(func_76((*l_611), func_87(l_886), &l_103), (safe_rshift_func_int8_t_s_u((1UL > (__builtin_ctzll(l_891) <= (+l_891))), l_881)))))
            { /* block id: 503 */
                struct S0 * const l_893 = (void*)0;
                int32_t ****l_897 = (void*)0;
                int32_t *****l_896 = &l_897;
                int32_t **l_899 = (void*)0;
                l_900 = &l_881;
                /* statement id: 504 */
                assert (l_900 == &l_881);
            }
            else
            { /* block id: 505 */
                uint8_t l_908 = 0x7DL;
                uint64_t l_922 = 0xE9F2777EF0639891LL;
                struct S0 *l_926 = &l_90;
                (*l_102) = (!((*l_102) | (!(&l_900 == l_903))));
                if (p_64)
                { /* block id: 507 */
                    float ** const ***l_919 = (void*)0;
                    int32_t l_924 = 0xA39B1151L;
                    if (p_64)
                        break;
                    for (l_90.f5 = 0; (l_90.f5 > 11); ++l_90.f5)
                    { /* block id: 511 */
                        struct S0 *l_923 = &l_90;
                        (*l_102) = (safe_mul_func_int8_t_s_s((**l_903), (l_908 >= p_64)));
                        (****l_915) = ((safe_mul_func_float_f_f(((safe_sub_func_float_f_f(__builtin_clzll(func_76(func_80(func_82((+(l_914 != l_919)), (safe_div_func_float_f_f(p_64, l_922)), (*l_900), l_923)), (0xA4C9L > (**l_903)), &l_103)), (*l_102))) > p_64), 0xE.7B4FD4p+98)) != l_924);
                        (**l_917) = l_891;
                        (**l_903) = (safe_unary_minus_func_int8_t_s(l_891));
                    }
                }
                else
                { /* block id: 517 */
                    struct S0 *l_928 = &l_90;
                    (*l_903) = (*l_903);
                    return l_929;
                    /* statement id: 519 */
                    //assert (func_63_rv == 0);
                }
            }
            l_930 = &l_103;
            /* statement id: 522 */
            assert (l_930 == &l_103);
        }
        /* facts after for loop */
        assert (l_900 == &l_103 || l_900 == &l_881);
    }
    else
    { /* block id: 524 */
        int32_t *l_931 = (void*)0;
        int32_t **l_932 = &l_102;
        float *l_933 = (void*)0;
        float *l_934 = (void*)0;
        float *l_935 = &l_90.f6;
        (*l_932) = l_931;
        /* statement id: 525 */
        assert (l_102 == 0);
        (*l_935) = p_65;
        l_103 = p_65;
    }
    /* facts after branching */
    assert (l_102 == 0 || l_102 == &l_103);
    return l_939;
    /* statement id: 529 */
    //assert (func_63_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_68(uint8_t  p_69, struct S0 * p_70, struct S0 * const  p_71, uint32_t  p_72, union U1  p_73)
{ /* block id: 343 */
    uint8_t l_615 = 253UL;
    int32_t l_619 = (-1L);
    int32_t *l_618 = &l_619;
    struct S0 l_631 = {0xDE84D4D3A3771D50LL,0xE.B492BCp-15,1L,65527UL,0x1617L,65532UL,0x2.B3D75Dp+54,0xEF5D37A5L};
    struct S0 *l_630 = &l_631;
    int32_t l_678 = 0L;
    float *l_701 = &l_631.f1;
    float **l_700 = &l_701;
    int32_t **l_706 = &l_618;
    int32_t ***l_705 = &l_706;
    int32_t **** const l_704 = &l_705;
    float *** const *l_746 = (void*)0;
    int32_t **** const l_837 = &l_705;
    int32_t **** const *l_836 = &l_837;
    int32_t *l_852 = &l_619;
    int32_t *l_853 = &l_619;
    int32_t *l_860 = &l_619;
    int32_t *l_861 = (void*)0;
    int32_t *l_877 = &l_619;
    int32_t *l_878 = (void*)0;
    for (p_73.f2.f2 = (-7); (p_73.f2.f2 > (-14)); p_73.f2.f2 = safe_sub_func_int8_t_s_s(p_73.f2.f2, 7))
    { /* block id: 346 */
        const int32_t l_617 = 0x9BDC2939L;
        const int32_t *l_616 = &l_617;
        int32_t *l_620 = &l_619;
        int32_t *l_622 = &l_619;
        const float *l_691 = (void*)0;
        const float **l_690 = &l_691;
        const struct S0 l_785 = {0L,0x5.9825B0p-72,1L,8UL,1UL,65535UL,0xB.76959Fp+6,4294967295UL};
        int32_t *l_812 = &l_619;
        int32_t **** const l_824 = &l_705;
        int32_t *** const *l_830 = &l_705;
        int32_t *l_838 = &l_619;
        struct S0 **l_840 = (void*)0;
        struct S0 ***l_839 = &l_840;
        if ((l_615 < func_76((*p_71), l_615, l_616)))
        { /* block id: 347 */
            int32_t *l_621 = &l_619;
            int32_t *l_623 = (void*)0;
            return l_623;
            /* statement id: 348 */
            //assert (func_68_rv == 0);
        }
        else
        { /* block id: 349 */
            const int32_t *l_629 = &l_619;
            uint16_t l_655 = 0x99DCL;
            int32_t **l_657 = &l_620;
            int32_t ***l_656 = &l_657;
            int32_t *l_660 = &l_619;
            int32_t *l_662 = (void*)0;
            float *l_694 = (void*)0;
            float **l_693 = &l_694;
            float ***l_692 = &l_693;
            for (p_69 = 0; (p_69 <= 26); p_69++)
            { /* block id: 352 */
                int32_t *l_626 = (void*)0;
                const int32_t **l_627 = (void*)0;
                const struct S0 l_628 = {0x86D2FA0D4CE72C01LL,0x0.Bp+1,0L,1UL,0x7D69L,0x5882L,0x8.2E31FDp-73,9UL};
                l_618 = l_626;
                /* statement id: 353 */
                assert (l_618 == 0);
                (*l_620) = (func_76(l_628, (*l_622), l_629) != p_73.f0);
                (*l_620) = ((*l_622) >= (l_626 != l_620));
            }
            if (func_76(func_80(l_630), (safe_mul_func_uint8_t_u_u(253UL, ((p_69 > p_73.f3) > (*l_616)))), l_629))
            { /* block id: 357 */
                int32_t **l_634 = &l_618;
                (*l_634) = &l_617;
                /* statement id: 358 */
                assert (l_618 == &l_617);
            }
            else
            { /* block id: 359 */
                int32_t l_652 = 0x93DA484EL;
                const int16_t l_653 = 0L;
                int32_t *l_661 = &l_619;
                const int32_t **l_671 = &l_629;
                int32_t *l_689 = (void*)0;
                if (p_73.f3)
                { /* block id: 360 */
                    for (p_72 = (-29); (p_72 > 8); p_72++)
                    { /* block id: 363 */
                        int32_t **l_651 = &l_618;
                        int32_t ***l_650 = &l_651;
                        int32_t ****l_649 = &l_650;
                        float *l_654 = &l_631.f6;
                        if (p_69)
                            break;
                        (*l_654) = (safe_div_func_float_f_f((p_69 == (*l_629)), (safe_div_func_float_f_f(((safe_mul_func_float_f_f((((safe_add_func_float_f_f((safe_mul_func_float_f_f((safe_sub_func_float_f_f(((void*)0 != &l_631), (l_649 != (void*)0))), l_652)), p_73.f1)) > l_652) >= 0x0.CB4130p+35), p_69)) == (-0x5.1p-1)), l_653))));
                        if (l_655)
                            continue;
                    }
                    if (p_72)
                        break;
                    if (l_653)
                    { /* block id: 369 */
                        int32_t ****l_658 = &l_656;
                        l_629 = &l_619;
                        (*l_658) = l_656;
                        p_70 = &l_631;
                        /* statement id: 372 */
                        assert (p_70 == &l_631);
                        if ((****l_658))
                            continue;
                    }
                    else
                    { /* block id: 374 */
                        const int32_t *l_659 = (void*)0;
                        l_659 = &l_617;
                        /* statement id: 375 */
                        assert (l_659 == &l_617);
                        if (l_653)
                            continue;
                    }
                }
                else
                { /* block id: 378 */
                    return l_662;
                    /* statement id: 379 */
                    //assert (func_68_rv == 0);
                }
                if (p_72)
                { /* block id: 381 */
                    int16_t l_665 = 0xFABCL;
                    struct S0 **l_666 = (void*)0;
                    const struct S0 *l_668 = &l_631;
                    const struct S0 **l_667 = &l_668;
                    (*l_667) = func_82((p_72 ^ (safe_lshift_func_int8_t_s_s(func_87(&l_631), p_73.f0))), p_72, l_665, &l_631);
                }
                else
                { /* block id: 383 */
                    const int32_t **l_669 = &l_616;
                    int32_t ***l_670 = (void*)0;
                    l_671 = l_669;
                    /* statement id: 384 */
                    assert (l_671 == &l_616);
                    for (p_69 = (-4); (p_69 != 33); p_69++)
                    { /* block id: 387 */
                        if (p_69)
                            break;
                    }
                    for (l_631.f0 = 0; (l_631.f0 >= 21); ++l_631.f0)
                    { /* block id: 392 */
                        struct S0 **l_677 = &l_630;
                        struct S0 ***l_676 = &l_677;
                        int32_t l_685 = 0xAEFA7F65L;
                        float *l_686 = (void*)0;
                        float *l_687 = (void*)0;
                        float *l_688 = &l_631.f6;
                        (*l_671) = &l_619;
                        /* statement id: 393 */
                        assert (l_616 == &l_619);
                        (*l_676) = &l_630;
                        (*l_688) = ((*l_661) != (__builtin_parity(((***l_656) == p_69)) < (l_678 < (safe_add_func_float_f_f((((p_72 > ((safe_sub_func_float_f_f(((safe_div_func_float_f_f(p_73.f3, 0x1.Ep-1)) != l_685), 0xD.94D0BBp-42)) != l_685)) <= 0x1.8p+1) != 0x0.Fp-1), 0x0.Fp+1)))));
                    }
                    /* facts after for loop */
                    assert (l_616 == &l_619 || l_616 == &l_617);
                }
                /* facts after branching */
                assert (l_616 == &l_619 || l_616 == &l_617);
                assert (l_671 == &l_616 || l_671 == &l_629);
                return l_689;
                /* statement id: 398 */
                //assert (func_68_rv == 0);
            }
            /* facts after branching */
            assert (l_618 == &l_617);
            (*l_692) = l_690;
            /* statement id: 400 */
            assert (l_693 == &l_691);
        }
        /* facts after branching */
        assert (l_618 == &l_617);
        l_622 = &l_619;
        if (func_87(func_82((*l_618), p_72, p_73.f3, &l_631)))
        { /* block id: 403 */
            uint32_t l_695 = 0x311BCDE5L;
            const struct S0 l_699 = {0L,0x3.Dp-1,-10L,1UL,5UL,4UL,0x0.8p+1,0x2309E625L};
            float **l_702 = &l_701;
            int32_t l_710 = 8L;
            int32_t l_711 = 0xF4B9BCF1L;
            int32_t *l_734 = (void*)0;
            if (l_695)
            { /* block id: 404 */
                uint8_t l_698 = 255UL;
                const int32_t *l_703 = &l_617;
                (*l_622) = (safe_mod_func_uint16_t_u_u(l_698, func_76(l_699, (l_700 != l_702), l_703)));
            }
            else
            { /* block id: 406 */
                uint32_t l_712 = 4294967288UL;
                float **l_722 = &l_701;
                int32_t *l_732 = &l_711;
                int32_t *l_733 = &l_619;
                int64_t l_735 = 0x0163384EF867AAE9LL;
                if ((p_72 >= (*l_618)))
                { /* block id: 407 */
                    float l_709 = 0x1.3EEB5Ep-64;
                    float ***l_717 = (void*)0;
                    int32_t l_730 = 0xD7ECFACDL;
                    l_710 = (__builtin_popcount((18446744073709551609UL || (1UL && (*l_618)))) >= (((void*)0 != l_704) & __builtin_clzl((p_69 <= (safe_lshift_func_int16_t_s_s(((*l_620) > ((*l_620) != p_73.f3)), p_73.f3))))));
                    if ((__builtin_popcount(((**l_706) & (1UL == ((l_711 >= 1UL) ^ l_712)))) < (((safe_mod_func_int8_t_s_s(((**l_706) & (safe_add_func_int16_t_s_s(func_76(l_699, (l_717 != &l_700), (*l_706)), p_73.f3))), p_69)) & 0x2E189DCD3B71875BLL) ^ 0x4D22L)))
                    { /* block id: 409 */
                        uint64_t l_725 = 0xC02960442D2853DDLL;
                        (**l_705) = &l_710;
                        /* statement id: 410 */
                        assert (l_618 == &l_710);
                        (**l_706) = ((safe_lshift_func_int16_t_s_u((4294967291UL && (l_702 == l_722)), p_72)) >= ((((safe_rshift_func_uint8_t_u_s(l_725, 7)) && l_695) == (safe_div_func_int8_t_s_s((0xEB6FD9C0L & (safe_mul_func_int8_t_s_s(func_87(&l_631), 0x96L))), p_73.f0))) == p_72));
                        if (l_730)
                            break;
                        //assert (l_618 == dangling);
                    }
                    else
                    { /* block id: 413 */
                        int32_t *l_731 = &l_730;
                        return l_734;
                        /* statement id: 414 */
                        //assert (func_68_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_618 == &l_710);
                    (*l_706) = l_733;
                    /* statement id: 416 */
                    assert (l_618 == &l_619);
                    (*l_733) = (((l_735 > 0xF.D51F31p+81) >= ((&l_734 != &l_732) == (safe_add_func_float_f_f((!(safe_mul_func_float_f_f((safe_div_func_float_f_f(((*l_732) < p_69), func_87(p_70))), l_730))), p_73.f1)))) > p_73.f3);
                }
                else
                { /* block id: 418 */
                    int32_t *l_745 = &l_619;
                    float ****l_748 = (void*)0;
                    float *****l_747 = &l_748;
                    for (l_631.f4 = 0; (l_631.f4 == 16); l_631.f4 = safe_add_func_int64_t_s_s(l_631.f4, 5))
                    { /* block id: 421 */
                        (**l_705) = l_745;
                        /* statement id: 422 */
                        assert (l_618 == &l_619);
                    }
                    /* facts after for loop */
                    assert (l_618 == &l_619 || l_618 == &l_617);
                    (*l_747) = l_746;
                }
                /* facts after branching */
                assert (l_618 == &l_619 || l_618 == &l_617);
                (*l_733) = 0x8F926854L;
            }
            /* facts after branching */
            assert (l_618 == &l_619 || l_618 == &l_617);
        }
        else
        { /* block id: 428 */
            const int32_t **l_749 = (void*)0;
            int32_t **l_750 = &l_620;
            int64_t l_797 = 0xB9754459D4F08367LL;
            const struct S0 *l_805 = (void*)0;
            int32_t *l_843 = (void*)0;
            (*l_750) = &l_617;
            /* statement id: 429 */
            assert (l_620 == &l_617);
            (**l_705) = (void*)0;
            /* statement id: 430 */
            assert (l_618 == 0);
            for (l_619 = 0; (l_619 <= (-22)); l_619 = safe_sub_func_uint8_t_u_u(l_619, 1))
            { /* block id: 433 */
                const int64_t l_772 = 0x4FEE1EEDBBD5C51FLL;
                int32_t *l_809 = &l_619;
                int32_t *l_814 = &l_619;
                int32_t *l_817 = (void*)0;
                int32_t ** const ** const l_825 = (void*)0;
                int32_t *l_842 = &l_619;
                (*l_701) = (safe_add_func_float_f_f(((safe_mul_func_float_f_f((((+(safe_div_func_float_f_f((safe_div_func_float_f_f((safe_add_func_float_f_f((safe_add_func_float_f_f(((((((safe_mul_func_float_f_f(((***l_704) == &l_617), (safe_mul_func_float_f_f((safe_sub_func_float_f_f(p_73.f1, p_69)), p_73.f3)))) == __builtin_ffs(p_72)) == p_69) >= (((**l_750) <= 0x5.178E5Ep+69) >= p_69)) <= 0x4.4862DEp-90) <= p_73.f1), p_73.f3)), l_772)), 0x7.7A5AA0p-1)), 0x5.55D7CDp-35))) > 0x4.2p-1) == (*l_616)), p_73.f0)) != (-0x10.2p+1)), p_72));
                (*l_701) = ((&p_73 != (void*)0) != (safe_div_func_float_f_f((safe_sub_func_float_f_f(0x9.6p+1, (-0x1.9p+1))), (safe_add_func_float_f_f(((safe_mul_func_float_f_f(l_772, (safe_mul_func_float_f_f(((((safe_div_func_float_f_f(func_76((*l_630), ((p_73.f0 <= 1L) ^ p_73.f0), (*l_750)), 0xC.0A448Bp-62)) <= p_72) == l_772) > (**l_750)), (**l_750))))) > (*l_620)), 0x4.A06588p+83)))));
                for (l_615 = 8; (l_615 == 8); l_615++)
                { /* block id: 438 */
                    union U1 l_790 = {0x27392E13L};
                    union U1 *l_789 = &l_790;
                    union U1 **l_788 = &l_789;
                    int32_t *l_811 = &l_619;
                    int32_t *l_815 = &l_619;
                    int32_t ****l_828 = &l_705;
                    int32_t ***** const l_827 = &l_828;
                    struct S0 ****l_841 = &l_839;
                    (*l_788) = &p_73;
                    /* statement id: 439 */
                    assert (l_789 == &p_73);
                    if (((((*l_616) & (__builtin_ffsl((**l_750)) && (p_72 < (safe_sub_func_uint32_t_u_u((safe_add_func_int32_t_s_s(((safe_sub_func_uint16_t_u_u(l_797, 0x4E63L)) > 0xB9309A9FCB4A5DAFLL), __builtin_popcountll((safe_mul_func_uint16_t_u_u((p_73.f3 <= p_69), p_69))))), p_73.f0))))) || 0x4F71C3AFL) > 0x37ABL))
                    { /* block id: 440 */
                        struct S0 **l_808 = &l_630;
                        int32_t *l_810 = &l_619;
                        int32_t *l_813 = &l_619;
                        int32_t *l_816 = &l_619;
                        (**l_700) = ((safe_sub_func_float_f_f((p_73.f1 >= (+((safe_sub_func_float_f_f((l_805 != l_805), ((safe_div_func_float_f_f((-0x1.4p-1), ((func_87(p_70) > (0x2.Ep+1 != 0x6.F86B17p-91)) > p_69))) != 0x2.2CFA40p-10))) == 0x5.F993F8p+73))), p_72)) <= p_69);
                        (*l_808) = l_805;
                        /* statement id: 442 */
                        assert (l_630 == 0);
                        return l_817;
                        /* statement id: 443 */
                        //assert (func_68_rv == 0);
                    }
                    else
                    { /* block id: 444 */
                        int32_t *** const **l_826 = (void*)0;
                        int32_t l_829 = 0x651DE543L;
                        (*l_750) = l_814;
                        /* statement id: 445 */
                        assert (l_620 == &l_619);
                        l_829 = (safe_div_func_uint16_t_u_u((safe_add_func_uint64_t_u_u((((void*)0 == &l_805) >= ((((safe_lshift_func_uint16_t_u_u((l_824 != l_825), (l_826 == l_827))) < p_73.f0) < 0x6DACL) <= (p_73.f3 & p_72))), p_69)), p_69));
                        l_830 = (void*)0;
                        /* statement id: 447 */
                        assert (l_830 == 0);
                        (*l_788) = &p_73;
                    }
                    /* facts after branching */
                    assert (l_620 == &l_619);
                    assert (l_830 == 0);
                    for (l_797 = (-27); (l_797 <= (-15)); ++l_797)
                    { /* block id: 452 */
                        int32_t l_835 = 0x1DE248BEL;
                        int32_t *l_834 = &l_835;
                        (*l_834) = (+p_72);
                        l_834 = (***l_824);
                        /* statement id: 454 */
                        assert (l_834 == &l_619 || l_834 == 0);
                        l_836 = &l_704;
                        /* statement id: 455 */
                        assert (l_836 == &l_704);
                        (***l_824) = l_838;
                        /* statement id: 456 */
                        assert (l_618 == &l_619);
                    }
                    (*l_841) = l_839;
                }
                /* facts after for loop */
                assert (l_618 == &l_619 || l_618 == 0);
                assert (l_836 == &l_704 || l_836 == &l_837);
                assert (l_620 == &l_619 || l_620 == &l_617);
                assert (l_830 == 0 || l_830 == &l_705);
                return l_843;
                /* statement id: 460 */
                //assert (func_68_rv == 0);
            }
            (*l_622) = (p_73.f0 > p_73.f3);
        }
        /* facts after branching */
        assert (l_618 == 0 || l_618 == &l_619 || l_618 == &l_617);
        assert (l_620 == &l_617 || l_620 == &l_619);
        (*l_838) = 0x8D00F893L;
    }
    /* facts after for loop */
    //assert (p_70 == &l_631 || p_70 == &l_90);
    //assert (l_618 == 0 || l_618 == &l_619 || l_618 == dangling);
lbl_876:
    if (p_73.f0)
    { /* block id: 466 */
        int32_t *l_846 = &l_619;
        int32_t *l_850 = &l_619;
        int32_t *l_855 = &l_619;
        int32_t *l_858 = &l_619;
        int32_t *l_859 = &l_619;
        for (l_631.f2 = 0; (l_631.f2 <= (-11)); l_631.f2 = safe_sub_func_int8_t_s_s(l_631.f2, 8))
        { /* block id: 469 */
            int32_t *l_847 = &l_619;
            int32_t *l_848 = &l_619;
            int32_t *l_849 = &l_619;
            int32_t *l_851 = &l_619;
            int32_t *l_854 = &l_619;
            int32_t *l_856 = &l_619;
            int32_t *l_857 = &l_619;
            (*l_701) = p_73.f3;
            return l_861;
            /* statement id: 471 */
            //assert (func_68_rv == 0);
        }
    }
    else
    { /* block id: 473 */
        uint32_t l_863 = 4294967286UL;
        const int32_t *l_864 = (void*)0;
        int32_t *l_865 = (void*)0;
        (*l_852) = (!l_863);
        if (((void*)0 == l_864))
        { /* block id: 475 */
            return l_865;
            /* statement id: 476 */
            //assert (func_68_rv == 0);
        }
        else
        { /* block id: 477 */
            int32_t *l_866 = &l_619;
            return l_865;
            /* statement id: 478 */
            //assert (func_68_rv == 0);
        }
    }
    for (l_678 = 0; (l_678 >= (-27)); --l_678)
    { /* block id: 483 */
        const int32_t *l_869 = (void*)0;
        int32_t **l_870 = (void*)0;
        int32_t **l_871 = (void*)0;
        int32_t **l_872 = &l_860;
        struct S0 l_874 = {-2L,0xE.76F852p-71,0L,0x8107L,0UL,0x09B6L,0x0.2p+1,0xC6BA9E48L};
        struct S0 *l_873 = &l_874;
        (*l_872) = l_869;
        /* statement id: 484 */
        assert (l_860 == 0);
        if (((*l_872) == (*l_872)))
        { /* block id: 485 */
            l_873 = p_71;
            /* statement id: 486 */
            //assert (l_873 == &l_90);
        }
        else
        { /* block id: 487 */
            const uint8_t l_875 = 0x9EL;
            if (l_875)
                break;
            (*l_852) = (-1L);
        }
        /* facts after branching */
        //assert (l_873 == &l_874 || l_873 == &l_90);
        if (p_69)
            continue;
        if (p_73.f0)
            goto lbl_876;
    }
    return l_878;
    /* statement id: 494 */
    //assert (func_68_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_76(const struct S0  p_77, uint64_t  p_78, const int32_t * p_79)
{ /* block id: 330 */
    int32_t l_584 = 0x7F144509L;
    int32_t *l_583 = &l_584;
    const int32_t *l_586 = &l_584;
    const int32_t **l_585 = &l_586;
    struct S0 *l_591 = (void*)0;
    float l_610 = 0x3.6p+1;
    float *l_609 = &l_610;
    (*l_585) = l_583;
    for (p_78 = 0; (p_78 != 56); p_78++)
    { /* block id: 334 */
        int32_t l_596 = (-8L);
        struct S0 *l_597 = (void*)0;
        float *l_606 = (void*)0;
        float l_608 = 0x9.2F658Dp-5;
        float *l_607 = &l_608;
        (*l_583) = (*l_583);
        (*l_583) = (*p_79);
        (*l_583) = ((0L && (safe_lshift_func_int16_t_s_s(p_77.f7, func_87(l_591)))) || (65532UL | (*l_586)));
        (*l_607) = (safe_div_func_float_f_f(((safe_div_func_float_f_f((l_596 > func_87(l_597)), (((safe_add_func_float_f_f(0x6.Ep+1, (safe_sub_func_float_f_f(0x0.0p+1, (safe_mul_func_float_f_f((-0x3.Dp-1), (*l_583))))))) == (safe_sub_func_float_f_f(p_77.f5, 0x0.1B66BDp-21))) == (**l_585)))) < (-0x5.5p+1)), l_596));
    }
    (*l_585) = p_79;
    /* statement id: 340 */
    //assert (l_586 == &l_103 || l_586 == &l_617 || l_586 == &l_619);
    (*l_609) = 0x0.Fp+1;
    return (**l_585);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_80(struct S0 * p_81)
{ /* block id: 150 */
    int32_t l_307 = 0xF62FEAE6L;
    int32_t *l_306 = &l_307;
    int32_t **l_305 = &l_306;
    uint32_t l_308 = 0UL;
    float l_309 = 0x7.42A8C7p+74;
    union U1 l_315 = {0UL};
    union U1 *l_314 = &l_315;
    union U1 **l_313 = &l_314;
    struct S0 *l_330 = (void*)0;
    uint64_t l_336 = 0x9B84EC6A1521089FLL;
    struct S0 l_425 = {0xCE3211752853B988LL,0x0.4p-1,0x1C63A18EL,0xAD8CL,65535UL,1UL,0x1.6A3311p+90,0xDAAF45E1L};
    uint32_t l_456 = 0xE52DD0C4L;
    struct S0 *l_496 = &l_425;
    union U1 *l_547 = &l_315;
    (*l_305) = (void*)0;
    /* statement id: 151 */
    assert (l_306 == 0);
    if ((l_307 && l_308))
    { /* block id: 152 */
        int32_t l_310 = (-3L);
        union U1 **l_316 = &l_314;
        struct S0 **l_331 = &l_330;
        (*l_331) = func_82((l_310 || (safe_lshift_func_int8_t_s_u((-1L), l_310))), l_310, ((l_313 != l_316) == ((safe_lshift_func_uint8_t_u_u(((safe_mod_func_uint64_t_u_u((((safe_add_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((safe_mul_func_uint8_t_u_u(l_310, __builtin_ffsl(((l_310 & (safe_unary_minus_func_int64_t_s(((safe_sub_func_uint64_t_u_u(l_310, l_310)) ^ l_310)))) & l_310)))), l_310)), 0UL)) && 0x96L) != l_310), 5L)) >= l_310), l_308)) > 6L)), l_330);
    }
    else
    { /* block id: 154 */
        int8_t l_334 = 0x03L;
        int32_t ***l_351 = (void*)0;
        struct S0 l_358 = {1L,0x2.6E9690p+2,0L,0x1648L,0x3C27L,9UL,0x7.82C3EBp+30,0x04C7E142L};
        struct S0 *l_357 = &l_358;
        union U1 **l_397 = &l_314;
        union U1 *l_437 = &l_315;
        int32_t *l_481 = &l_307;
        int32_t l_501 = 0x3C1C3E2FL;
        for (l_307 = 0; (l_307 == 13); l_307 = safe_add_func_int16_t_s_s(l_307, 2))
        { /* block id: 157 */
            float l_335 = 0x9.24E36Cp-77;
            int32_t l_345 = 4L;
            float l_400 = (-0x4.Ap+1);
            int32_t *l_419 = &l_345;
            struct S0 l_424 = {0L,0xA.C25AA0p+63,3L,7UL,65535UL,0UL,-0x3.Dp-1,0x1D766525L};
            struct S0 **l_426 = &l_330;
        }
        for (l_425.f3 = 11; (l_425.f3 < 48); l_425.f3 = safe_add_func_uint64_t_u_u(l_425.f3, 7))
        { /* block id: 216 */
            int64_t l_431 = 0L;
            int32_t **l_436 = &l_306;
            if ((safe_div_func_uint32_t_u_u(__builtin_parity(l_431), (safe_add_func_uint16_t_u_u((safe_sub_func_int64_t_s_s((&l_306 == l_436), ((*l_313) != l_437))), l_358.f4)))))
            { /* block id: 217 */
                float l_438 = 0xF.A80D7Bp+50;
                int32_t l_439 = 1L;
                l_307 = (l_439 == (safe_add_func_int8_t_s_s((safe_add_func_uint16_t_u_u((__builtin_popcount(l_358.f7) && l_439), ((+((safe_lshift_func_uint8_t_u_s(((!(safe_mod_func_int32_t_s_s((safe_mod_func_uint8_t_u_u(((void*)0 != &l_351), (safe_rshift_func_uint16_t_u_s((safe_add_func_int32_t_s_s(((l_358.f4 || l_456) || 0x4988L), l_439)), 0)))), 5UL))) ^ 0UL), l_439)) && l_439)) > l_439))), l_439)));
                (*l_436) = &l_439;
                /* statement id: 219 */
                assert (l_306 == &l_439);
            }
            else
            { /* block id: 220 */
                struct S0 l_464 = {0xFADA9A81F95636F1LL,0x3.25BEEEp+36,0L,1UL,0UL,65527UL,0x5.2E8481p-3,0x6235A723L};
                float *l_484 = &l_358.f1;
                int32_t l_485 = (-2L);
                for (l_315.f0 = (-19); (l_315.f0 != 35); l_315.f0++)
                { /* block id: 223 */
                    int8_t l_461 = 1L;
                    const int32_t *l_473 = &l_307;
                    const int32_t * const *l_472 = &l_473;
                    const int32_t * const **l_471 = &l_472;
                    const int32_t * const ***l_470 = &l_471;
                    const int32_t * const ****l_469 = &l_470;
                    (*l_436) = (*l_436);
                    for (l_425.f5 = (-6); (l_425.f5 < 36); l_425.f5++)
                    { /* block id: 227 */
                        int16_t l_462 = (-1L);
                        int32_t *l_463 = (void*)0;
                        l_461 = (-1L);
                        if (l_462)
                            break;
                        (*l_436) = l_463;
                        /* statement id: 230 */
                        assert (l_306 == 0);
                        (*l_436) = (*l_436);
                    }
                    if (l_461)
                    { /* block id: 233 */
                        return l_464;
                    }
                    else
                    { /* block id: 235 */
                        uint32_t l_474 = 18446744073709551612UL;
                        float *l_475 = &l_358.f6;
                        union U1 *l_476 = &l_315;
                        int32_t *l_477 = &l_307;
                        (*l_475) = (safe_add_func_float_f_f((safe_mul_func_float_f_f(((void*)0 != l_469), l_474)), l_464.f3));
                        (*l_397) = l_476;
                        (*l_477) = l_474;
                        (*l_477) = (!(safe_rshift_func_int8_t_s_s(0x05L, (*l_477))));
                    }
                    if (l_431)
                    { /* block id: 241 */
                        uint64_t l_482 = 18446744073709551615UL;
                        (*l_436) = l_481;
                        /* statement id: 242 */
                        assert (l_306 == &l_307);
                        l_482 = (-8L);
                        l_485 = ((**l_436) & (!(((void*)0 != l_484) <= (**l_305))));
                    }
                    else
                    { /* block id: 245 */
                        int32_t **l_486 = &l_306;
                        (*l_486) = (*l_472);
                        /* statement id: 246 */
                        assert (l_306 == &l_307);
                    }
                    /* facts after branching */
                    assert (l_306 == &l_307);
                }
                /* facts after for loop */
                assert (l_306 == &l_307 || l_306 == 0);
                (*l_481) = (!(*l_481));
            }
            /* facts after branching */
            //assert (l_306 == &l_307 || l_306 == 0 || l_306 == dangling);
            (*l_481) = ((*l_481) >= (*l_481));
            (*l_305) = (void*)0;
            /* statement id: 252 */
            assert (l_306 == 0);
            (*l_313) = (*l_397);
        }
        (*l_481) = (((safe_mod_func_int64_t_s_s(func_87(func_82((safe_add_func_int8_t_s_s((*l_481), (safe_mod_func_int64_t_s_s((safe_add_func_int32_t_s_s((*l_481), (__builtin_clz((l_496 != &l_425)) >= l_308))), (safe_sub_func_int8_t_s_s(((*l_481) && (*l_481)), func_87(func_82((safe_div_func_int32_t_s_s((*l_481), 0x054CF859L)), (*l_481), l_501, &l_425)))))))), l_315.f0, (*l_481), p_81)), 18446744073709551615UL)) != (*l_481)) > 65535UL);
    }
    if (((safe_mod_func_uint64_t_u_u(((0L < (&l_314 == &l_314)) ^ 1L), l_425.f0)) | l_425.f3))
    { /* block id: 257 */
        uint16_t l_504 = 0UL;
        int32_t l_515 = 0x891070F7L;
        int32_t ****l_517 = (void*)0;
        struct S0 l_546 = {1L,0xC.C481B2p+17,0xF27982AAL,0xF2E0L,0x3893L,1UL,0x4.2201CCp-40,4UL};
        union U1 *l_551 = &l_315;
        if (l_504)
        { /* block id: 258 */
            int32_t *l_505 = &l_307;
            l_505 = l_505;
            return (*p_81);
        }
        else
        { /* block id: 261 */
            float l_513 = 0x3.4BC4E4p-56;
            int32_t l_514 = (-7L);
            int32_t *****l_516 = (void*)0;
            if ((p_81 == p_81))
            { /* block id: 262 */
                const uint32_t l_506 = 0x1F1BBC2BL;
                uint32_t l_511 = 0x4BC582DDL;
                float *l_512 = &l_425.f6;
                (*l_512) = (l_506 != (safe_add_func_float_f_f((safe_mul_func_float_f_f(__builtin_popcountl(l_506), (l_506 > l_511))), l_506)));
                (*l_512) = l_513;
            }
            else
            { /* block id: 265 */
                l_515 = l_514;
            }
            l_515 = ((l_516 != l_516) != (-1L));
        }
        if (l_504)
        { /* block id: 270 */
            uint64_t l_526 = 6UL;
            int64_t l_537 = 0xF65CE011796C2D3CLL;
            int32_t *l_539 = &l_307;
            int64_t l_573 = 0xB4DE27B88BF53C40LL;
            l_517 = l_517;
            for (l_315.f2.f3 = (-23); (l_315.f2.f3 >= 8); l_315.f2.f3 = safe_add_func_uint16_t_u_u(l_315.f2.f3, 5))
            { /* block id: 274 */
                float l_525 = 0x2.541386p+15;
                int32_t l_529 = 0L;
                for (l_308 = 0; (l_308 > 2); l_308++)
                { /* block id: 277 */
                    int64_t l_530 = (-1L);
                    struct S0 *l_538 = &l_425;
                    for (l_425.f5 = (-2); (l_425.f5 > 46); l_425.f5++)
                    { /* block id: 280 */
                        int32_t l_524 = 0xBF6197B7L;
                        float *l_531 = &l_525;
                        int32_t *l_532 = &l_307;
                        (*l_305) = (void*)0;
                        /* statement id: 281 */
                        assert (l_306 == 0);
                        (*l_531) = (l_524 <= ((0x8.4D207Dp-71 != l_525) != (l_526 > (safe_sub_func_float_f_f(l_529, __builtin_popcountll(l_530))))));
                        (*l_532) = l_530;
                        (*l_531) = (((safe_mul_func_float_f_f(l_526, (safe_mul_func_float_f_f((l_336 != (l_529 != ((l_537 > (l_530 <= l_529)) != (0x2.E4C754p-23 < (l_538 == (void*)0))))), l_530)))) < l_529) != 0x5.9E515Fp-88);
                    }
                    if (l_537)
                        continue;
                    (*l_305) = l_539;
                    /* statement id: 287 */
                    assert (l_306 == &l_307);
                    (**l_305) = l_530;
                }
                /* facts after for loop */
                //assert (l_306 == &l_307 || l_306 == 0 || l_306 == dangling);
                (*l_305) = &l_529;
                /* statement id: 290 */
                assert (l_306 == &l_529);
                if ((*l_306))
                    continue;
                //assert (l_306 == dangling);
                l_529 = 1L;
            }
            /* facts after for loop */
            //assert (l_306 == dangling || l_306 == 0);
            for (l_336 = (-2); (l_336 <= 8); l_336 = safe_add_func_uint16_t_u_u(l_336, 6))
            { /* block id: 296 */
                int64_t l_544 = 0xBDA012C6015A3CE2LL;
                const int32_t *l_560 = &l_307;
                const int32_t **l_559 = &l_560;
                const int32_t ***l_558 = &l_559;
                struct S0 *l_571 = &l_425;
                if ((safe_div_func_int8_t_s_s(func_87(&l_425), (l_544 && ((-6L) != (*l_539))))))
                { /* block id: 297 */
                    struct S0 *l_545 = &l_425;
                    if (func_87(l_545))
                    { /* block id: 298 */
                        return l_546;
                    }
                    else
                    { /* block id: 300 */
                        float *l_548 = &l_425.f6;
                        const int32_t l_549 = (-2L);
                        int64_t l_550 = 0x1C87F479BC4A577ALL;
                        (*l_548) = (l_544 > ((void*)0 != l_547));
                        l_550 = l_549;
                    }
                    (*l_313) = l_551;
                }
                else
                { /* block id: 305 */
                    float l_565 = 0x5.1100D1p-13;
                    int32_t l_566 = 0x546844F8L;
                    uint8_t l_572 = 0xB1L;
                    if (((safe_mod_func_int32_t_s_s((safe_div_func_uint32_t_u_u((safe_add_func_int16_t_s_s((l_558 == (void*)0), ((safe_div_func_int8_t_s_s((safe_mod_func_uint32_t_u_u(l_566, ((safe_sub_func_uint64_t_u_u(l_566, (safe_div_func_int16_t_s_s(((**l_559) <= (***l_558)), (func_87(l_571) & (0x1843BA7CL >= l_572)))))) || (**l_559)))), 4L)) > l_566))), l_566)), (*l_539))) == l_573))
                    { /* block id: 306 */
                        (*l_539) = 0x770A3C31L;
                    }
                    else
                    { /* block id: 308 */
                        (*l_305) = &l_566;
                        /* statement id: 309 */
                        assert (l_306 == &l_566);
                        if ((**l_305))
                            continue;
                        //assert (l_306 == dangling);
                        (*l_559) = (*l_559);
                    }
                    /* facts after branching */
                    //assert (l_306 == &l_566 || l_306 == dangling || l_306 == 0);
                    return (*p_81);
                }
            }
        }
        else
        { /* block id: 316 */
            uint32_t l_574 = 8UL;
            int32_t *l_575 = &l_515;
            (*l_575) = l_574;
            (*l_575) = (*l_575);
        }
        /* facts after branching */
        //assert (l_306 == dangling || l_306 == 0);
        for (l_425.f5 = 0; (l_425.f5 != 56); ++l_425.f5)
        { /* block id: 322 */
            (*l_305) = &l_515;
            /* statement id: 323 */
            assert (l_306 == &l_515);
        }
        /* facts after for loop */
        //assert (l_306 == &l_515 || l_306 == dangling || l_306 == 0);
        l_307 = ((+(safe_lshift_func_uint8_t_u_u(l_515, 3))) == l_425.f5);
    }
    else
    { /* block id: 326 */
        uint32_t l_581 = 4294967288UL;
        int32_t l_582 = 0x6F2CCC6CL;
        l_582 = l_581;
    }
    /* facts after branching */
    //assert (l_306 == dangling || l_306 == 0);
    return (*p_81);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_82(uint32_t  p_83, float  p_84, int16_t  p_85, struct S0 * p_86)
{ /* block id: 45 */
    struct S0 *l_108 = (void*)0;
    uint16_t l_115 = 5UL;
    int32_t l_127 = 0xFF7B51EFL;
    int32_t *l_126 = &l_127;
    int32_t * const *l_125 = &l_126;
    float l_128 = 0x0.Cp-1;
    int64_t l_148 = 1L;
    const uint16_t l_194 = 65527UL;
    int32_t l_244 = 0x50B3776BL;
    uint64_t l_259 = 0x9D877C5E7DC01900LL;
    uint32_t l_277 = 0x4AD5F31AL;
    int32_t *l_300 = &l_127;
    struct S0 l_304 = {-7L,0x1.Bp+1,5L,65535UL,65529UL,0xF262L,0x3.28254Ap+15,0xEE2EE7ABL};
    struct S0 *l_303 = &l_304;
    (*l_126) = (((safe_mul_func_int8_t_s_s(((safe_mul_func_int16_t_s_s(((func_87(l_108) <= (safe_add_func_uint8_t_u_u((safe_sub_func_int64_t_s_s((safe_mod_func_int8_t_s_s(l_115, __builtin_ffsll((((safe_add_func_uint8_t_u_u(((!func_87(p_86)) | l_115), ((safe_sub_func_int8_t_s_s((safe_mod_func_int8_t_s_s((p_83 != (safe_div_func_int64_t_s_s((p_85 == (l_125 != &l_126)), p_83))), p_83)), 1L)) & p_85))) | (**l_125)) | (*l_126))))), 0xAEFF8EE8584DF831LL)), 0xE3L))) >= p_83), (**l_125))) > 8UL), (**l_125))) ^ (*l_126)) >= p_85);
    return p_86;
    /* statement id: 149 */
    //assert (func_82_rv == &l_90 || func_82_rv == 0 || func_82_rv == &l_358 || func_82_rv == &l_425 || func_82_rv == &l_631 || func_82_rv == &l_979);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_87(struct S0 * p_88)
{ /* block id: 41 */
    int32_t l_92 = (-6L);
    int32_t *l_91 = &l_92;
    int32_t **l_93 = &l_91;
    int64_t l_94 = 0L;
    (*l_93) = l_91;
    (*l_93) = (*l_93);
    return l_94;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 285
   depth: 1, occurrence: 7
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 275
   depth: 2, occurrence: 35
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 5
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 4
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 25, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 312

XXX times a variable address is taken: 290
XXX times a pointer is dereferenced on RHS: 135
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 35
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 153
breakdown:
   depth: 1, occurrence: 140
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 23
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 18
XXX times a pointer is qualified to be dereferenced: 1090

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 767
   level: 2, occurrence: 228
   level: 3, occurrence: 35
   level: 4, occurrence: 37
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 122
XXX number of pointers point to scalars: 131
XXX number of pointers point to structs: 51
XXX percent of pointers has null in alias set: 28.5
XXX average alias set size: 1.2

XXX times a non-volatile is read: 998
XXX times a non-volatile is write: 399
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 224
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 36
   depth: 2, occurrence: 32
   depth: 3, occurrence: 29
   depth: 4, occurrence: 34
   depth: 5, occurrence: 57

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
********************* end of statistics **********************/

