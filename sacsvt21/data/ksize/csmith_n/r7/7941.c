/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1630665009
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_28(void);
static const int32_t  func_36(int16_t  p_37, int32_t  p_38, int16_t  p_39, float  p_40);
static int64_t  func_44(uint8_t  p_45, uint64_t  p_46, uint32_t  p_47);
inline static uint16_t  func_58(int32_t  p_59);
inline static int64_t  func_62(int32_t  p_63, int64_t  p_64);
inline static int32_t * const * const * func_71(int8_t  p_72);
static int32_t * const  func_74(int32_t  p_75, int32_t * p_76, uint8_t  p_77, int64_t  p_78, int32_t ** const  p_79);
static int32_t  func_80(uint32_t  p_81, int32_t * const ** p_82, int8_t  p_83);
static int32_t * const ** func_85(float  p_86, uint8_t  p_87, int32_t * p_88, uint16_t  p_89);
static int32_t  func_97(uint64_t  p_98, int64_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = 1L;
    float l_839 = 0x8.C97E80p+76;
    float l_850 = 0xC.10BDF8p+36;
    int32_t *l_869 = &l_29;
    uint32_t l_875 = 7UL;
    int32_t **l_882 = (void*)0;
    int32_t **l_883 = &l_869;
    int16_t l_884 = 1L;
    for (l_29 = 0; (l_29 < (-15)); l_29 = safe_sub_func_uint64_t_u_u(l_29, 1))
    { /* block id: 39 */
        int32_t l_41 = (-1L);
        float *l_868 = &l_839;
        (*l_868) = (safe_sub_func_float_f_f(__builtin_popcountll((safe_div_func_uint32_t_u_u(1UL, (247UL & (func_36(l_41, ((safe_mod_func_int16_t_s_s((func_44((safe_lshift_func_uint8_t_u_s((safe_rshift_func_int8_t_s_u(l_29, 7)), (__builtin_bswap64(l_41) || (safe_mod_func_uint32_t_u_u((safe_lshift_func_int16_t_s_u((safe_lshift_func_uint8_t_u_u(1UL, (9UL == func_58(((safe_rshift_func_uint16_t_u_u(((func_62(l_29, l_29) == 0xF691283DDD84540ALL) && l_29), l_41)) == l_29))))), 7)), l_41))))), l_29, l_29) ^ l_41), l_29)) || l_41), l_41, l_29) | 1L))))), l_29));
    }
    l_869 = &l_29;
    for (l_29 = (-30); (l_29 > 10); l_29 = safe_add_func_uint8_t_u_u(l_29, 7))
    { /* block id: 546 */
        const uint32_t l_876 = 0xC5C8E9D3L;
        int32_t * const l_877 = (void*)0;
        if (((*l_869) == (*l_869)))
        { /* block id: 547 */
            int32_t l_874 = 1L;
            int32_t *l_878 = (void*)0;
            int32_t l_880 = 0x8DA9F7A1L;
            int32_t *l_879 = &l_880;
            (*l_879) = ((18446744073709551615UL & (((__builtin_parity((safe_sub_func_int32_t_s_s(__builtin_ffs((*l_869)), l_874))) == (l_875 || l_874)) || l_876) != (l_877 != l_878))) & (-1L));
            return l_876;
        }
        else
        { /* block id: 550 */
            int64_t l_881 = 0x6343E382B8F5825BLL;
            return l_881;
        }
    }
    (*l_883) = &l_29;
    return l_884;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_36(int16_t  p_37, int32_t  p_38, int16_t  p_39, float  p_40)
{ /* block id: 525 */
    uint32_t l_851 = 18446744073709551609UL;
    int32_t l_852 = 0x29C44F05L;
    int32_t *l_853 = (void*)0;
    int32_t *l_854 = &l_852;
    uint32_t l_855 = 18446744073709551612UL;
    int32_t **l_863 = &l_853;
    int32_t ***l_862 = &l_863;
    int32_t ****l_861 = &l_862;
    l_852 = l_851;
    (*l_854) = ((void*)0 != &l_852);
    (*l_854) = __builtin_parity(l_855);
    for (l_852 = 0; (l_852 <= (-15)); l_852 = safe_sub_func_int64_t_s_s(l_852, 3))
    { /* block id: 531 */
        int32_t *l_858 = &l_852;
        const int32_t *l_860 = (void*)0;
        const int32_t **l_859 = &l_860;
        int32_t l_864 = 0x29CCD04EL;
        (*l_859) = func_74(p_37, l_858, (*l_854), p_37, &l_858);
        /* statement id: 532 */
        assert (l_860 == &l_852);
        l_864 = (l_861 == &l_862);
        for (p_39 = 14; (p_39 == 15); p_39 = safe_add_func_uint16_t_u_u(p_39, 8))
        { /* block id: 536 */
            const uint32_t l_867 = 2UL;
            return l_867;
        }
    }
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_44(uint8_t  p_45, uint64_t  p_46, uint32_t  p_47)
{ /* block id: 522 */
    uint32_t l_846 = 0x35606793L;
    int32_t *l_847 = (void*)0;
    int32_t l_849 = (-1L);
    int32_t *l_848 = &l_849;
    (*l_848) = func_62(((((safe_add_func_uint8_t_u_u((((safe_lshift_func_int16_t_s_u((3L != (safe_rshift_func_uint16_t_u_u(((l_846 != l_846) < (l_846 >= 0x3223L)), l_846))), (l_846 || (0L < 0x16F0L)))) || 1UL) ^ 0xE250L), p_47)) | 0x6AL) || l_846) & l_846), p_45);
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_58(int32_t  p_59)
{ /* block id: 519 */
    int64_t l_838 = 0L;
    l_838 = (safe_sub_func_float_f_f(0x3.9p-1, 0xF.6710AEp+26));
    return l_838;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_62(int32_t  p_63, int64_t  p_64)
{ /* block id: 40 */
    int32_t l_66 = 0x68DD2AC3L;
    int32_t *l_65 = &l_66;
    int32_t **l_67 = &l_65;
    int32_t * const *l_736 = &l_65;
    int32_t * const **l_735 = &l_736;
    uint32_t l_829 = 0UL;
    int32_t ***l_834 = &l_67;
    int32_t ****l_833 = &l_834;
    int32_t *****l_832 = &l_833;
    (*l_67) = l_65;
    if ((((**l_67) || __builtin_ctz((**l_67))) >= __builtin_bswap64((safe_add_func_uint16_t_u_u((4294967295UL & (safe_unary_minus_func_int8_t_s(((&p_63 != (void*)0) & 1L)))), (**l_67))))))
    { /* block id: 42 */
lbl_725:
        (*l_67) = (void*)0;
        /* statement id: 43 */
        assert (l_65 == 0);
        return p_64;
    }
    else
    { /* block id: 45 */
        uint32_t l_73 = 0x1EC8E12BL;
        int32_t ***l_724 = &l_67;
        int32_t ****l_723 = &l_724;
        int32_t * const **l_754 = &l_736;
        uint32_t l_784 = 0xF5944913L;
        int64_t l_835 = 0L;
        (*l_723) = func_71(l_73);
        /* statement id: 460 */
        assert (l_724 == 0);
        (**l_67) = ((*l_65) & (*l_65));
        if (p_63)
        { /* block id: 462 */
            int64_t l_753 = 0x90E889D0D6631DE7LL;
            const int32_t l_755 = 0xBB6C0917L;
            int32_t ** const l_775 = &l_65;
            int32_t *l_787 = &l_66;
            if (p_63)
                goto lbl_725;
            for (l_73 = 0; (l_73 < 33); l_73 = safe_add_func_uint8_t_u_u(l_73, 1))
            { /* block id: 466 */
                uint8_t l_730 = 0x8BL;
                int32_t *****l_781 = &l_723;
                if (((((0x98L == p_64) > (~((safe_unary_minus_func_uint16_t_u(l_730)) & p_63))) || (safe_mul_func_uint8_t_u_u((safe_unary_minus_func_uint16_t_u(func_80((~p_64), l_735, (!((2UL >= 0xE0L) != p_64))))), (-9L)))) | 7L))
                { /* block id: 467 */
                    (**l_67) = __builtin_ia32_crc32qi((**l_67), ((l_730 > __builtin_clz((safe_lshift_func_int8_t_s_u(0x43L, 3)))) < ((safe_add_func_int32_t_s_s((**l_67), p_63)) ^ func_80((safe_mod_func_int64_t_s_s((safe_lshift_func_uint8_t_u_u(((+((safe_sub_func_int16_t_s_s((safe_sub_func_int8_t_s_s(p_63, p_63)), (safe_mod_func_int8_t_s_s(l_753, (**l_67))))) == p_64)) == p_63), 0)), 0x4E8D9863270545C5LL)), l_754, p_63))));
                    if (p_64)
                        continue;
                }
                else
                { /* block id: 470 */
                    int32_t *l_758 = &l_66;
                    (***l_754) = (p_63 ^ 1L);
                    if ((0x7026083F5EEDC58ELL || (1UL && 0x01L)))
                    { /* block id: 472 */
                        float l_757 = 0x8.6p+1;
                        float *l_756 = &l_757;
                        if ((**l_736))
                            break;
                        (**l_736) = 0L;
                        (*l_756) = l_755;
                    }
                    else
                    { /* block id: 476 */
                        int64_t l_772 = 0L;
                        int32_t **l_776 = &l_758;
                        float l_786 = (-0x3.5p+1);
                        float *l_785 = &l_786;
                        (*l_776) = func_74(p_64, l_758, __builtin_ctzl(((~(safe_lshift_func_int8_t_s_s(((((*l_65) || (safe_add_func_uint16_t_u_u((p_63 || (safe_div_func_int32_t_s_s(((safe_sub_func_uint32_t_u_u((safe_lshift_func_int8_t_s_s(0x1CL, 7)), (safe_rshift_func_uint8_t_u_s(l_730, ((l_772 | ((safe_lshift_func_int16_t_s_u((p_63 != p_64), p_63)) | p_64)) < p_63))))) && p_63), l_730))), 3L))) >= 0xE391393DL) & p_63), p_63))) && l_730)), p_63, l_775);
                        (*l_785) = (func_97(l_730, (safe_mod_func_uint8_t_u_u((safe_div_func_uint64_t_u_u(__builtin_popcountll((((void*)0 != l_781) == (*l_758))), (((__builtin_ctzl((((**l_775) || p_63) == (((safe_sub_func_uint16_t_u_u((0UL && (((**l_775) > (**l_775)) ^ (*l_65))), l_784)) ^ p_64) && (**l_776)))) ^ p_64) & p_64) && p_64))), p_64))) > 0x0.5p-1);
                    }
                    l_787 = &p_63;
                    /* statement id: 480 */
                    assert (l_787 == &p_63);
                }
                for (l_753 = 0; (l_753 == (-1)); --l_753)
                { /* block id: 484 */
                    float l_792 = 0xD.79C670p+37;
                    p_63 = (safe_lshift_func_uint16_t_u_s(p_64, 3));
                    if (p_64)
                        continue;
                }
                (**l_67) = p_64;
            }
            /* facts after for loop */
            assert (l_787 == &p_63 || l_787 == &l_66);
            return p_64;
        }
        else
        { /* block id: 491 */
            int32_t l_793 = 0x401478E0L;
            float l_795 = 0x0.Ap-1;
            float *l_794 = &l_795;
            (*l_794) = l_793;
            for (p_63 = 23; (p_63 != (-28)); --p_63)
            { /* block id: 495 */
                float l_807 = 0x3.5p-1;
                int32_t l_808 = 0xE68DCEC0L;
                int32_t * const **l_809 = (void*)0;
                if (p_63)
                    break;
                if (l_793)
                    break;
                if (p_63)
                    continue;
                if ((p_64 && func_97((**l_736), (safe_mod_func_uint8_t_u_u(__builtin_bswap64((p_63 || (**l_67))), 1L)))))
                { /* block id: 499 */
                    int32_t *l_802 = &l_66;
                    int32_t **l_810 = &l_802;
                    (*l_810) = func_74(__builtin_parityll(((safe_rshift_func_uint16_t_u_u(65534UL, (***l_735))) != p_64)), l_802, ((safe_mul_func_uint16_t_u_u(p_63, p_63)) < ((safe_div_func_uint16_t_u_u(((func_80(l_808, l_809, (*l_802)) || l_793) == p_64), p_64)) | l_793)), p_64, &l_65);
                    (**l_67) = (-1L);
                }
                else
                { /* block id: 502 */
                    int16_t l_811 = 0xDD81L;
                    int32_t *****l_822 = &l_723;
                    if ((l_811 == p_64))
                    { /* block id: 503 */
                        (*l_794) = (p_64 <= (p_63 == 0x1.Dp-1));
                    }
                    else
                    { /* block id: 505 */
                        int32_t **l_812 = &l_65;
                        (*l_812) = (*l_736);
                        (*l_794) = (safe_mul_func_float_f_f((safe_add_func_float_f_f(((safe_mul_func_float_f_f(l_793, p_63)) < (safe_add_func_float_f_f(p_63, (func_97(l_793, (safe_unary_minus_func_int8_t_s(((void*)0 == l_822)))) < (safe_sub_func_float_f_f((safe_sub_func_float_f_f((((((((safe_add_func_float_f_f(0xA.AA20B5p+43, l_793)) <= 0x8.44B6B7p-41) != (-0x10.4p+1)) > p_63) >= p_63) != (**l_812)) == l_829), (**l_812))), p_64)))))), (*l_65))), 0x1.41F9B2p+66));
                        return p_63;
                    }
                }
            }
            l_835 = ((safe_div_func_int16_t_s_s(0xF3A0L, p_63)) > (&l_723 == l_832));
            (**l_67) = 0x4DFB60CBL;
        }
    }
    (***l_833) = (**l_834);
    (**l_67) = (**l_67);
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const * const * func_71(int8_t  p_72)
{ /* block id: 46 */
    uint16_t l_84 = 65531UL;
    int32_t *l_90 = (void*)0;
    int32_t * const *l_712 = &l_90;
    int32_t * const * const *l_711 = &l_712;
    int32_t * const * const *l_713 = &l_712;
    int32_t * const * const *l_714 = &l_712;
    int32_t * const * const *l_715 = &l_712;
    int32_t * const * const *l_716 = &l_712;
    int32_t * const * const *l_717 = &l_712;
    int32_t * const * const *l_718 = &l_712;
    int32_t * const * const *l_719 = &l_712;
    int32_t * const * const *l_720 = &l_712;
    int32_t * const * const *l_721 = &l_712;
    int32_t * const * const *l_722 = (void*)0;
    l_90 = func_74(func_80(l_84, func_85(((void*)0 == l_90), (safe_div_func_int8_t_s_s(__builtin_ffsll(l_84), p_72)), l_90, p_72), p_72), l_90, p_72, p_72, &l_90);
    return l_722;
    /* statement id: 459 */
    //assert (func_71_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_74(int32_t  p_75, int32_t * p_76, uint8_t  p_77, int64_t  p_78, int32_t ** const  p_79)
{ /* block id: 455 */
    float l_709 = 0x1.Ap-1;
    float *l_708 = &l_709;
    float * const *l_707 = &l_708;
    float * const **l_706 = &l_707;
    float * const ***l_705 = &l_706;
    float * const **** const l_704 = &l_705;
    int32_t l_710 = 0L;
    l_710 = ((void*)0 != l_704);
    return (*p_79);
    /* statement id: 457 */
    //assert (func_74_rv == 0 || func_74_rv == &l_66 || func_74_rv == &l_852);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_80(uint32_t  p_81, int32_t * const ** p_82, int8_t  p_83)
{ /* block id: 448 */
    const uint64_t l_689 = 18446744073709551615UL;
    int32_t *l_694 = (void*)0;
    int32_t **l_693 = &l_694;
    int32_t ***l_692 = &l_693;
    int32_t ****l_691 = &l_692;
    int32_t *****l_690 = &l_691;
    int8_t l_700 = 0x3FL;
    if (((l_689 <= ((l_689 < ((void*)0 == l_690)) == (+(safe_mul_func_uint8_t_u_u(((**l_692) == (****l_690)), p_83))))) | (safe_div_func_int32_t_s_s(0x8FBAC872L, l_700))))
    { /* block id: 449 */
        int32_t l_702 = (-1L);
        int32_t * const l_701 = &l_702;
        int32_t **l_703 = &l_694;
        (*l_703) = l_701;
        /* statement id: 450 */
        assert (l_694 == &l_702);
    }
    else
    { /* block id: 451 */
        return p_81;
    }
    /* facts after branching */
    //assert (l_694 == dangling);
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const ** func_85(float  p_86, uint8_t  p_87, int32_t * p_88, uint16_t  p_89)
{ /* block id: 47 */
    int32_t l_96 = 0xB5BCDCECL;
    int32_t *l_95 = &l_96;
    int32_t **l_94 = &l_95;
    int32_t ***l_93 = &l_94;
    uint32_t l_269 = 0x86768D72L;
    float ** const **l_303 = (void*)0;
    float *l_343 = (void*)0;
    float **l_342 = &l_343;
    int32_t * const *l_348 = &l_95;
    int32_t * const **l_347 = &l_348;
    int16_t l_370 = 0x2A48L;
    uint32_t l_406 = 0xEAE7410EL;
    uint32_t l_420 = 0xCAF8924DL;
    const int8_t l_423 = 1L;
    int32_t *l_586 = &l_96;
    int32_t ****l_681 = &l_93;
    int32_t *****l_680 = &l_681;
    int32_t * const **l_684 = &l_348;
    int32_t * const **l_685 = &l_348;
    int32_t * const **l_686 = (void*)0;
    if ((l_93 != &l_94))
    { /* block id: 48 */
        int64_t l_110 = 0xFA8726ABE926F5D9LL;
        int32_t l_189 = 0L;
        int32_t *l_191 = &l_96;
        (**l_94) = func_97(p_87, (safe_add_func_uint16_t_u_u((((safe_mod_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s((safe_mul_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s(p_87, (***l_93))), p_89)), (l_110 <= (*l_95)))), ((safe_add_func_int8_t_s_s(__builtin_clzll(p_87), p_89)) | (***l_93)))) != (*l_95)) == l_110), 65534UL)));
        if ((***l_93))
        { /* block id: 84 */
            float l_179 = 0x9.F8B48Fp+50;
            int32_t l_180 = 0L;
            (***l_93) = (safe_div_func_float_f_f(func_97(l_110, l_110), (safe_div_func_float_f_f(l_179, l_180))));
        }
        else
        { /* block id: 86 */
            float l_182 = (-0x1.Dp-1);
            float *l_181 = &l_182;
            (*l_181) = (-0x1.6p+1);
            for (l_110 = 0; (l_110 > 10); l_110++)
            { /* block id: 90 */
                (*l_181) = 0x4.8p-1;
                for (l_96 = 0; (l_96 <= 29); ++l_96)
                { /* block id: 94 */
                    for (p_87 = 0; (p_87 == 55); p_87++)
                    { /* block id: 97 */
                        l_93 = &l_94;
                    }
                    (**l_93) = p_88;
                    /* statement id: 100 */
                    assert (l_95 == 0);
                    l_189 = p_87;
                }
                /* facts after for loop */
                assert (l_95 == 0 || l_95 == &l_182 || l_95 == &l_96);
                (*l_94) = l_181;
                /* statement id: 103 */
                assert (l_95 == &l_182);
            }
            /* facts after for loop */
            assert (l_95 == &l_182 || l_95 == &l_96);
            (**l_93) = p_88;
            /* statement id: 105 */
            assert (l_95 == 0);
        }
        /* facts after branching */
        assert (l_95 == 0 || l_95 == &l_96);
        (**l_93) = p_88;
        /* statement id: 107 */
        assert (l_95 == 0);
        (*l_191) = (safe_unary_minus_func_int32_t_s(p_89));
    }
    else
    { /* block id: 109 */
        int64_t l_206 = (-1L);
        const int32_t *l_221 = &l_96;
        const int32_t **l_220 = &l_221;
        const int32_t ***l_219 = &l_220;
        int32_t * const **l_225 = (void*)0;
        uint32_t l_257 = 1UL;
        float *l_260 = (void*)0;
        float **l_259 = &l_260;
        int32_t l_271 = (-1L);
        float ***l_300 = &l_259;
        float ****l_299 = &l_300;
        float *****l_298 = &l_299;
        int32_t * const **l_351 = &l_348;
        int32_t l_374 = 0x93FEBC82L;
        uint32_t l_623 = 1UL;
        int16_t l_637 = (-4L);
        int32_t *l_669 = &l_374;
        int32_t l_675 = 0L;
    }
    /* facts after branching */
    assert (l_95 == &l_96 || l_95 == 0);
    (*l_94) = (***l_681);
    (****l_680) = p_88;
    /* statement id: 446 */
    assert (l_95 == 0);
    return l_686;
    /* statement id: 447 */
    //assert (func_85_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_97(uint64_t  p_98, int64_t  p_99)
{ /* block id: 49 */
    uint32_t l_115 = 0x6FC49175L;
    int32_t l_127 = 3L;
    int32_t *l_126 = &l_127;
    int32_t **l_125 = &l_126;
    int32_t ***l_124 = &l_125;
    int8_t l_140 = (-1L);
    int32_t l_174 = 0x7677910AL;
    if (((safe_mod_func_int64_t_s_s((l_115 == (safe_div_func_int64_t_s_s(__builtin_parityl((((safe_mod_func_uint64_t_u_u((((safe_lshift_func_int8_t_s_u((safe_lshift_func_int16_t_s_s((l_124 != (void*)0), 11)), 1)) && 65527UL) > (safe_unary_minus_func_int16_t_s((safe_rshift_func_uint16_t_u_u((((**l_124) == (void*)0) ^ __builtin_popcountll((***l_124))), 3))))), (*l_126))) > (*l_126)) == (***l_124))), 2L))), (-8L))) || 1L))
    { /* block id: 50 */
        const int32_t l_135 = 6L;
        int32_t *l_158 = (void*)0;
        (*l_126) = ((safe_lshift_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u(l_135, __builtin_clzl((((safe_lshift_func_uint8_t_u_s(((*l_124) == (void*)0), (safe_rshift_func_uint8_t_u_s(p_99, ((p_98 != p_99) ^ l_135))))) > l_140) && p_98)))), p_98)) >= p_99);
        for (p_98 = 0; (p_98 < 39); p_98 = safe_add_func_int16_t_s_s(p_98, 1))
        { /* block id: 54 */
            int32_t *l_143 = &l_127;
            float *l_154 = (void*)0;
            float *l_155 = (void*)0;
            float l_157 = 0xA.831F07p+2;
            float *l_156 = &l_157;
            (*l_125) = (**l_124);
            (*l_125) = l_143;
            (*l_126) = (p_99 & (*l_126));
            (*l_156) = ((safe_add_func_float_f_f((safe_div_func_float_f_f(p_98, (((safe_add_func_float_f_f((safe_mul_func_float_f_f(0xF.C577B3p+42, (0x1.3p-1 != __builtin_parityl(((safe_div_func_int16_t_s_s(p_98, p_98)) == 0x88A7CC15BC693E63LL))))), 0x1.Ep-1)) != (***l_124)) <= l_135))), l_135)) <= (-0x1.Bp-1));
        }
        (*l_125) = l_158;
        /* statement id: 60 */
        assert (l_126 == 0);
        for (l_115 = 0; (l_115 != 26); l_115 = safe_add_func_int8_t_s_s(l_115, 1))
        { /* block id: 63 */
            int32_t *l_161 = &l_127;
            float l_163 = 0x4.3F082Fp+49;
            float *l_162 = &l_163;
            (**l_124) = l_161;
            /* statement id: 64 */
            assert (l_126 == &l_127);
            (*l_162) = (0x1.9p-1 > __builtin_ffsl((**l_125)));
            l_158 = (void*)0;
        }
        /* facts after for loop */
        assert (l_126 == &l_127 || l_126 == 0);
    }
    else
    { /* block id: 68 */
        (*l_126) = (***l_124);
    }
    /* facts after branching */
    assert (l_126 == &l_127 || l_126 == 0);
    for (l_127 = (-29); (l_127 == 10); ++l_127)
    { /* block id: 73 */
        int8_t l_170 = (-4L);
        int32_t l_173 = 9L;
        int32_t *l_172 = &l_173;
        if ((safe_rshift_func_int8_t_s_u((safe_add_func_uint8_t_u_u(p_99, l_170)), p_99)))
        { /* block id: 74 */
            int32_t *l_171 = (void*)0;
            (*l_125) = (*l_125);
            l_172 = l_171;
            /* statement id: 76 */
            assert (l_172 == 0);
            return p_98;
        }
        else
        { /* block id: 78 */
            return l_174;
        }
    }
    return p_99;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 243
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 125
   depth: 2, occurrence: 26
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 205

XXX times a variable address is taken: 189
XXX times a pointer is dereferenced on RHS: 124
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 42
   depth: 3, occurrence: 27
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 125
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 31
   depth: 3, occurrence: 12
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 29
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 776

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 158
   level: 2, occurrence: 145
   level: 3, occurrence: 137
   level: 4, occurrence: 26
   level: 5, occurrence: 18
XXX number of pointers point to pointers: 141
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.9
XXX average alias set size: 1.16

XXX times a non-volatile is read: 1011
XXX times a non-volatile is write: 397
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 6

XXX stmts: 113
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 22
   depth: 2, occurrence: 26
   depth: 3, occurrence: 10
   depth: 4, occurrence: 13
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 17
XXX percentage an existing variable is used: 83
********************* end of statistics **********************/

