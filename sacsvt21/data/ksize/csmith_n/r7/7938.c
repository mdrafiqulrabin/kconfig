/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2517968855
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const signed f0 : 10;
   const signed f1 : 25;
   unsigned f2 : 24;
   const unsigned f3 : 3;
   const int32_t  f4;
   signed f5 : 10;
   signed f6 : 5;
   unsigned f7 : 11;
   unsigned f8 : 14;
};
#pragma pack(pop)

union U1 {
   uint8_t  f0;
   uint32_t  f1;
   const int8_t * f2;
};

union U2 {
   int8_t  f0;
   int8_t * f1;
   uint8_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static union U1 * func_32(uint32_t  p_33, int32_t  p_34, int32_t ** p_35, union U2  p_36, const uint16_t  p_37);
inline static int32_t * func_41(int32_t * p_42);
static int32_t * func_43(int32_t ** p_44, float  p_45, int64_t  p_46, int32_t ** p_47, int32_t * p_48);
inline static const int32_t  func_52(const uint32_t  p_53);
static const int32_t  func_61(int32_t * p_62, const int32_t * const * p_63, int8_t * p_64);
inline static int32_t * func_65(int8_t * p_66, float  p_67, int32_t * p_68, uint16_t  p_69);
static int32_t * func_73(int32_t  p_74);
static uint8_t  func_82(union U1 * p_83);
inline static union U1 * func_84(int8_t  p_85, int8_t  p_86, uint32_t  p_87, uint8_t  p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    int32_t *l_30 = (void*)0;
    int32_t **l_31 = &l_30;
    int32_t l_38 = 0xBBD4AA41L;
    int32_t *l_39 = &l_38;
    union U2 l_40 = {0xF8L};
    const union U1 l_711 = {0x62L};
    const union U1 *l_710 = &l_711;
    const union U1 **l_709 = &l_710;
    uint32_t l_712 = 0x63F4B3FEL;
    (*l_31) = l_30;
    (*l_709) = func_32(l_38, ((l_39 == (*l_31)) ^ (3UL && 0UL)), &l_30, l_40, (*l_39));
    /* statement id: 400 */
    assert (l_710 == 0);
    return l_712;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1 * func_32(uint32_t  p_33, int32_t  p_34, int32_t ** p_35, union U2  p_36, const uint16_t  p_37)
{ /* block id: 38 */
    int32_t l_51 = 0xB3D925D3L;
    int32_t *l_50 = &l_51;
    int32_t **l_49 = &l_50;
    struct S0 l_624 = {13,-4863,1854,1,0L,-3,-4,33,90};
    struct S0 *l_623 = &l_624;
    struct S0 **l_622 = &l_623;
    struct S0 ***l_621 = &l_622;
    union U1 l_630 = {0xE8L};
    union U1 *l_629 = &l_630;
    union U1 *l_631 = &l_630;
    union U1 *l_636 = (void*)0;
    uint32_t l_671 = 0UL;
    float l_699 = 0x9.B78B71p+77;
    float *l_698 = &l_699;
    float **l_697 = &l_698;
    float ***l_696 = &l_697;
    int8_t l_705 = (-5L);
    int8_t *l_704 = &l_705;
    int8_t **l_703 = &l_704;
    int8_t ***l_702 = &l_703;
    int8_t ****l_701 = &l_702;
    int8_t *****l_700 = &l_701;
    union U1 *l_707 = &l_630;
    union U1 *l_708 = (void*)0;
    (*l_49) = func_41(func_43(l_49, (**l_49), (func_52(((p_34 <= (*l_50)) >= (**l_49))) >= __builtin_popcount((**l_49))), p_35, (*p_35)));
    return l_708;
    /* statement id: 399 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_41(int32_t * p_42)
{ /* block id: 307 */
    int32_t l_555 = 0xC33A5D2AL;
    const int32_t *l_571 = &l_555;
    const int32_t * const *l_570 = &l_571;
    int32_t *l_608 = &l_555;
    int32_t **l_607 = &l_608;
    for (l_555 = (-26); (l_555 == (-28)); l_555 = safe_sub_func_uint64_t_u_u(l_555, 1))
    { /* block id: 310 */
        int32_t l_558 = (-9L);
        struct S0 l_569 = {-11,2997,1845,0,-7L,-25,3,27,119};
        struct S0 *l_568 = &l_569;
        union U2 l_580 = {-2L};
        union U2 *l_579 = &l_580;
        struct S0 * const *l_593 = &l_568;
        struct S0 * const **l_592 = &l_593;
        union U1 l_618 = {0xDAL};
        union U1 *l_617 = &l_618;
        for (l_558 = 0; (l_558 >= 15); ++l_558)
        { /* block id: 313 */
            int32_t *l_562 = &l_555;
            int32_t **l_561 = &l_562;
            union U2 l_578 = {0x28L};
            union U2 *l_577 = &l_578;
            (*l_561) = p_42;
            /* statement id: 314 */
            //assert (l_562 == &l_51);
            (*l_562) = (l_558 < (*p_42));
            if ((*p_42))
            { /* block id: 316 */
                float l_566 = 0x4.EF29D0p-37;
                int32_t l_567 = 0x097564C0L;
                int8_t *l_572 = (void*)0;
                if ((safe_lshift_func_uint8_t_u_u(((8L == (+(*p_42))) > (*p_42)), __builtin_bswap64(l_567))))
                { /* block id: 317 */
                    const float l_573 = 0xD.2464B9p+18;
                    float *l_574 = &l_566;
                    (*l_562) = (-3L);
                    l_568 = (void*)0;
                    /* statement id: 319 */
                    assert (l_568 == 0);
                    (*l_574) = l_573;
                }
                else
                { /* block id: 321 */
                    int32_t l_583 = 0xD08E9AEBL;
                    float *l_584 = &l_566;
                    (*l_584) = (safe_sub_func_float_f_f((((*l_562) != (**l_570)) < (l_577 != l_579)), (safe_div_func_float_f_f(l_583, (-0x7.Ep+1)))));
                    (*l_561) = func_73(l_567);
                    /* statement id: 323 */
                    assert (l_562 == 0);
                    return p_42;
                    /* statement id: 324 */
                    //assert (func_41_rv == &l_51);
                }
                /* facts after branching */
                assert (l_568 == 0);
            }
            else
            { /* block id: 326 */
                int16_t l_585 = 0x3D7FL;
                struct S0 *l_598 = &l_569;
                int8_t **l_602 = (void*)0;
                int32_t **l_604 = &l_562;
                union U2 **l_609 = &l_577;
                if (((**l_570) & l_585))
                { /* block id: 327 */
                    float l_589 = (-0x3.5p-1);
                    float *l_588 = &l_589;
                    struct S0 * const *l_591 = &l_568;
                    struct S0 * const **l_590 = &l_591;
                    (*l_588) = (safe_mul_func_float_f_f((*l_571), l_585));
                    l_592 = l_590;
                    /* statement id: 329 */
                    assert (l_592 == &l_591);
                    (*p_42) = l_569.f6;
                    (*l_561) = func_73((*p_42));
                    /* statement id: 331 */
                    assert (l_562 == 0);
                }
                else
                { /* block id: 332 */
                    float l_595 = (-0x10.Ap+1);
                    float *l_594 = &l_595;
                    struct S0 l_600 = {31,-1039,1669,0,7L,-11,4,19,1};
                    struct S0 *l_599 = &l_600;
                    (*l_594) = 0x1.3p-1;
                    (*l_561) = p_42;
                    if ((safe_add_func_int64_t_s_s(((l_580.f0 ^ func_52((*l_571))) > l_580.f0), (*l_562))))
                    { /* block id: 335 */
                        uint32_t l_601 = 4294967287UL;
                        int8_t ***l_603 = &l_602;
                        l_599 = l_598;
                        /* statement id: 336 */
                        assert (l_599 == &l_569);
                        (*p_42) = __builtin_parity(l_600.f5);
                        if (l_601)
                            break;
                        (*l_603) = l_602;
                    }
                    else
                    { /* block id: 340 */
                        union U2 ***l_610 = (void*)0;
                        union U2 ***l_611 = (void*)0;
                        union U2 ***l_612 = &l_609;
                        (*l_607) = func_43(l_604, (safe_sub_func_float_f_f((-0x1.7p-1), (*l_571))), l_558, l_607, p_42);
                        /* statement id: 341 */
                        //assert (l_608 == &l_51);
                        (*l_612) = l_609;
                        if ((*p_42))
                            continue;
                    }
                    /* facts after branching */
                    assert (l_599 == &l_600 || l_599 == &l_569);
                }
                /* facts after branching */
                //assert (l_592 == &l_593 || l_592 == dangling);
                //assert (l_562 == &l_51 || l_562 == 0);
                return p_42;
                /* statement id: 346 */
                //assert (func_41_rv == &l_51);
            }
            /* facts after branching */
            assert (l_568 == 0);
        }
        /* facts after for loop */
        assert (l_568 == 0 || l_568 == &l_569);
        l_569.f6 = ((safe_mul_func_uint16_t_u_u(__builtin_ffs((safe_mod_func_uint32_t_u_u(((((*l_571) > 0xF361L) > 0UL) > 5L), func_82(l_617)))), (l_569.f1 ^ (safe_div_func_uint32_t_u_u(__builtin_clz(l_569.f0), (*l_571)))))) <= (*l_571));
    }
    /* facts after for loop */
    //assert (l_608 == &l_51 || l_608 == &l_555);
    (*p_42) = (**l_570);
    return p_42;
    /* statement id: 352 */
    //assert (func_41_rv == &l_51);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_43(int32_t ** p_44, float  p_45, int64_t  p_46, int32_t ** p_47, int32_t * p_48)
{ /* block id: 305 */
    return (*p_44);
    /* statement id: 306 */
    //assert (func_43_rv == &l_51);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t  func_52(const uint32_t  p_53)
{ /* block id: 39 */
    int32_t l_54 = 0x87662B0AL;
    int32_t *l_58 = &l_54;
    int8_t l_71 = (-1L);
    int8_t *l_70 = &l_71;
    const union U1 *l_72 = (void*)0;
    uint16_t l_79 = 0x46B3L;
    const int32_t *l_269 = &l_54;
    const int32_t * const *l_268 = &l_269;
    int8_t *l_270 = &l_71;
    uint16_t l_514 = 0x5351L;
    int8_t **l_529 = &l_70;
    int8_t ***l_528 = &l_529;
    struct S0 l_554 = {-19,3236,1744,0,-2L,-15,-4,3,11};
    struct S0 *l_553 = &l_554;
    for (l_54 = 0; (l_54 >= (-22)); l_54 = safe_sub_func_int8_t_s_s(l_54, 6))
    { /* block id: 42 */
        int64_t l_57 = 5L;
        if (l_57)
            break;
    }
lbl_491:
    (*l_58) = (-6L);
    for (l_54 = 0; (l_54 > (-7)); l_54 = safe_sub_func_int32_t_s_s(l_54, 4))
    { /* block id: 48 */
        int32_t l_90 = (-1L);
        int8_t *l_488 = &l_71;
        union U2 l_495 = {4L};
        union U2 *l_494 = &l_495;
        struct S0 l_535 = {-12,1699,1675,1,0xA9420591L,21,3,41,119};
        struct S0 *l_534 = &l_535;
        if (func_61(func_65(l_70, ((l_72 == l_72) != (-0x1.6p+1)), func_73(((safe_lshift_func_int16_t_s_s((safe_mod_func_int32_t_s_s((((*l_58) < ((3L > l_79) | (safe_add_func_uint8_t_u_u(func_82(func_84((1UL ^ (((!(p_53 ^ (*l_58))) & l_90) == 0x147DL)), l_90, p_53, (*l_58))), p_53)))) == 4294967287UL), (*l_58))), 11)) | p_53)), (*l_58)), l_268, l_270))
        { /* block id: 268 */
            int16_t l_485 = (-7L);
            int32_t *l_489 = (void*)0;
            int32_t *l_490 = &l_90;
            (*l_490) = (((l_485 || p_53) <= (safe_sub_func_int16_t_s_s(p_53, (**l_268)))) <= ((0L > func_61(&l_90, &l_269, l_488)) != l_485));
            if ((*l_490))
                break;
            if ((**l_268))
                break;
        }
        else
        { /* block id: 272 */
            union U2 l_493 = {0L};
            union U2 * const l_492 = &l_493;
            float l_497 = 0xF.34C1A4p+24;
            float *l_496 = &l_497;
            int32_t **l_510 = &l_58;
            if (l_54)
                goto lbl_491;
            (*l_496) = (l_492 != l_494);
            if ((p_53 >= (l_493.f2 == (((!(p_53 ^ (safe_add_func_int32_t_s_s(__builtin_popcountl((l_493.f2 && l_495.f2)), (((safe_sub_func_uint16_t_u_u((~p_53), ((safe_rshift_func_uint8_t_u_u((*l_58), 6)) && (~0xE084FBD8L)))) | p_53) != 0L))))) <= p_53) <= 0x58EBB66CL))))
            { /* block id: 275 */
                int32_t *l_511 = (void*)0;
                int32_t *l_512 = (void*)0;
                int32_t *l_513 = (void*)0;
                int8_t *** const l_527 = (void*)0;
                int8_t **l_540 = &l_70;
                int32_t l_544 = (-5L);
                l_514 = (safe_sub_func_uint8_t_u_u((+(l_510 != l_510)), (**l_268)));
                if ((safe_sub_func_uint64_t_u_u(((p_53 >= ((safe_rshift_func_int16_t_s_u((0x75D50403L <= p_53), (*l_58))) < p_53)) != l_495.f2), 2L)))
                { /* block id: 277 */
                    int16_t l_530 = (-7L);
                    int8_t l_531 = 0x60L;
                    struct S0 l_537 = {-6,4929,3935,1,6L,5,-2,40,95};
                    struct S0 *l_536 = &l_537;
                    int32_t *l_541 = &l_90;
                    l_90 = (safe_rshift_func_int8_t_s_s((5L || p_53), p_53));
                    for (l_90 = 0; (l_90 <= 20); ++l_90)
                    { /* block id: 281 */
                        l_531 = (safe_sub_func_int8_t_s_s((l_527 != l_528), l_530));
                        (*l_496) = 0x4.1C7AFCp-79;
                    }
                    for (l_71 = (-24); (l_71 == (-7)); l_71 = safe_add_func_int32_t_s_s(l_71, 9))
                    { /* block id: 287 */
                        l_536 = l_534;
                        /* statement id: 288 */
                        assert (l_536 == &l_535);
                    }
                    /* facts after for loop */
                    assert (l_536 == &l_535 || l_536 == &l_537);
                    (*l_541) = (safe_lshift_func_int16_t_s_s(((void*)0 != l_540), p_53));
                }
                else
                { /* block id: 291 */
                    if (p_53)
                        break;
                    l_544 = (safe_rshift_func_uint16_t_u_u(p_53, 13));
                }
                return p_53;
            }
            else
            { /* block id: 296 */
                const uint16_t l_545 = 0x5464L;
                int32_t *l_552 = &l_90;
                (*l_552) = ((l_545 & (4294967295UL ^ __builtin_clz((**l_510)))) && (safe_mul_func_int8_t_s_s((safe_add_func_int16_t_s_s(l_535.f0, l_545)), (((safe_rshift_func_int8_t_s_s(0L, 4)) > p_53) && (__builtin_parityll((**l_510)) ^ (**l_510))))));
                (*l_552) = 0xB2636098L;
            }
        }
        if (p_53)
            continue;
        l_534 = l_553;
        /* statement id: 302 */
        assert (l_534 == &l_554);
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_61(int32_t * p_62, const int32_t * const * p_63, int8_t * p_64)
{ /* block id: 132 */
    int32_t l_271 = 1L;
    struct S0 **l_277 = (void*)0;
    int32_t l_297 = (-1L);
    float **l_310 = (void*)0;
    union U2 l_319 = {0x7EL};
    union U2 *l_318 = &l_319;
    union U2 **l_317 = &l_318;
    int32_t *l_418 = &l_271;
    int32_t **l_417 = &l_418;
    const int32_t *l_430 = &l_271;
    int32_t l_431 = (-1L);
    struct S0 l_445 = {18,225,2164,0,-1L,-21,1,14,11};
    struct S0 *l_444 = &l_445;
    int8_t *l_478 = &l_319.f0;
    int32_t *l_479 = (void*)0;
    uint32_t l_480 = 0xD3BEA14DL;
    int8_t l_481 = 1L;
    const int16_t l_482 = (-5L);
    for (l_271 = (-23); (l_271 >= 22); ++l_271)
    { /* block id: 135 */
        int32_t l_274 = 0x3974108AL;
        int32_t *l_280 = (void*)0;
        int8_t *l_337 = &l_319.f0;
        const float l_361 = 0x1.6p+1;
        for (l_274 = (-4); (l_274 <= 28); l_274 = safe_add_func_uint16_t_u_u(l_274, 2))
        { /* block id: 138 */
            float l_279 = 0x0.8p+1;
            float *l_278 = &l_279;
            (*l_278) = (__builtin_ctz((l_277 == (void*)0)) < 0x8.AA047Ap+20);
            l_280 = l_278;
            /* statement id: 140 */
            assert (l_280 == &l_279);
        }
        /* facts after for loop */
        //assert (l_280 == dangling || l_280 == 0);
        for (l_274 = 0; (l_274 >= (-19)); l_274 = safe_sub_func_uint8_t_u_u(l_274, 1))
        { /* block id: 144 */
            int32_t l_285 = 0x2F596B8FL;
            int16_t l_307 = 0x5CA6L;
            const int32_t *l_316 = &l_297;
            union U1 l_326 = {0x71L};
            union U1 *l_325 = &l_326;
            union U1 **l_324 = &l_325;
            if ((safe_lshift_func_int8_t_s_s(l_271, 4)))
            { /* block id: 145 */
                int32_t *l_286 = &l_285;
                union U2 l_290 = {0x54L};
                union U2 *l_289 = &l_290;
                union U2 **l_288 = &l_289;
                union U1 l_303 = {3UL};
                union U1 *l_302 = &l_303;
                (*l_286) = l_285;
                if ((**p_63))
                { /* block id: 147 */
                    int32_t **l_287 = &l_286;
                    struct S0 l_300 = {20,2724,3642,0,0x3D4B9EDBL,-30,3,15,105};
                    struct S0 *l_299 = &l_300;
                    (*l_287) = (*p_63);
                    /* statement id: 148 */
                    //assert (l_286 == &l_54 || l_286 == &l_51);
                    if (((void*)0 != l_288))
                    { /* block id: 149 */
                        float *l_296 = (void*)0;
                        int32_t l_298 = 0x94EFD27CL;
                        struct S0 **l_301 = &l_299;
                        l_297 = (0x5.6p+1 >= (safe_sub_func_float_f_f((!0x1.Ep+1), ((safe_sub_func_float_f_f((-0x1.9p+1), (-0x1.Cp-1))) != l_271))));
                        l_298 = (l_271 | __builtin_popcountll((**l_287)));
                        (*l_301) = l_299;
                    }
                    else
                    { /* block id: 153 */
                        const union U1 *l_305 = (void*)0;
                        const union U1 **l_304 = &l_305;
                        int32_t l_306 = 0x5BA1AFD9L;
                        (*l_304) = l_302;
                        /* statement id: 154 */
                        assert (l_305 == &l_303);
                        if (l_297)
                            continue;
                        l_306 = (l_285 ^ (((*l_286) || 0x57B670F1L) | 0x7E7B49F2L));
                    }
                    (*l_287) = &l_297;
                    /* statement id: 158 */
                    assert (l_286 == &l_297);
                }
                else
                { /* block id: 159 */
                    if (l_307)
                        break;
                }
                /* facts after branching */
                assert (l_286 == &l_285 || l_286 == &l_297);
            }
            else
            { /* block id: 162 */
                int32_t **l_312 = &l_280;
                union U2 **l_320 = &l_318;
                for (l_307 = 0; (l_307 <= 25); ++l_307)
                { /* block id: 165 */
                    float ***l_311 = &l_310;
                    (*l_311) = l_310;
                    if (l_271)
                        continue;
                }
                (*l_312) = (*p_63);
                /* statement id: 169 */
                //assert (l_280 == &l_54 || l_280 == &l_51);
                for (l_285 = 16; (l_285 <= (-15)); l_285 = safe_sub_func_int16_t_s_s(l_285, 1))
                { /* block id: 172 */
                    int32_t l_315 = 0xC40C1327L;
                    l_315 = l_315;
                    l_316 = (*p_63);
                    /* statement id: 174 */
                    //assert (l_316 == &l_54 || l_316 == &l_51);
                }
                /* facts after for loop */
                //assert (l_316 == &l_54 || l_316 == &l_297 || l_316 == &l_51);
                l_320 = l_317;
            }
            /* facts after branching */
            //assert (l_316 == &l_54 || l_316 == &l_297 || l_316 == &l_51);
            l_297 = __builtin_clzll((~(safe_mod_func_int16_t_s_s((*l_316), (*l_316)))));
            (*l_324) = (void*)0;
            /* statement id: 179 */
            assert (l_325 == 0);
            for (l_285 = 0; (l_285 >= (-14)); l_285 = safe_sub_func_int8_t_s_s(l_285, 1))
            { /* block id: 182 */
                int64_t l_335 = (-1L);
                struct S0 l_356 = {21,5029,2671,0,-2L,-28,-2,2,19};
                struct S0 *l_355 = &l_356;
                int16_t l_367 = 3L;
                const float l_385 = 0x0.7p-1;
                int32_t *l_411 = &l_297;
                for (l_307 = 15; (l_307 > 0); l_307 = safe_sub_func_uint16_t_u_u(l_307, 7))
                { /* block id: 185 */
                    int16_t l_336 = 0x38BCL;
                    int32_t *l_338 = (void*)0;
                    int32_t *l_339 = &l_297;
                    int8_t * const *l_379 = &l_337;
                    int8_t * const **l_378 = &l_379;
                    int8_t * const *** const l_377 = &l_378;
                    int16_t l_402 = (-1L);
                    float *l_403 = (void*)0;
                    float l_405 = 0xB.CE28C6p+72;
                    float *l_404 = &l_405;
                    int32_t **l_406 = &l_280;
                    (*l_339) = ((safe_lshift_func_uint16_t_u_u(l_319.f0, 3)) || (((safe_add_func_uint16_t_u_u((l_335 < l_297), l_336)) >= (l_337 == (void*)0)) >= (*l_316)));
                    if ((**p_63))
                    { /* block id: 187 */
                        uint8_t l_354 = 0xDDL;
                        int64_t l_362 = 0xD69343E88D88C518LL;
                        float l_364 = 0xD.902BF3p+87;
                        float *l_363 = &l_364;
                        int32_t **l_376 = &l_339;
                        (*l_363) = (0xF.A2CD24p-83 != (safe_sub_func_float_f_f((safe_add_func_float_f_f((safe_div_func_float_f_f((safe_mul_func_float_f_f(((safe_mul_func_float_f_f((safe_mul_func_float_f_f((((safe_div_func_float_f_f(l_354, 0xC.DD1D02p-45)) <= ((l_319.f2 <= (((void*)0 != l_355) != (*l_339))) > (-0x1.2p-1))) <= (safe_div_func_float_f_f((safe_add_func_float_f_f(((__builtin_parityl((l_354 == (*l_339))) == l_361) >= l_354), l_356.f5)), 0x2.D223D8p-7))), l_354)), l_356.f1)) < l_319.f0), (*l_316))), l_354)), l_362)), l_356.f6)));
                        if ((**p_63))
                            continue;
                        (*l_339) = 0x9FFF0781L;
                        (*l_376) = func_65(p_64, (safe_div_func_float_f_f(l_367, ((safe_add_func_float_f_f((safe_div_func_float_f_f(((*l_316) != l_354), (*l_316))), ((safe_div_func_float_f_f((*l_316), (safe_mul_func_float_f_f(l_274, l_319.f2)))) < 0x2.12618Dp+84))) < (-0x1.Fp+1)))), &l_297, (*l_339));
                    }
                    else
                    { /* block id: 192 */
                        int8_t * const ***l_380 = &l_378;
                        int32_t ****l_381 = (void*)0;
                        int32_t **l_384 = &l_339;
                        int32_t ***l_383 = &l_384;
                        int32_t ****l_382 = &l_383;
                        l_380 = l_377;
                        (*l_317) = (*l_317);
                        (*l_382) = &p_63;
                        /* statement id: 195 */
                        assert (l_383 == &p_63);
                        if ((**p_63))
                            break;
                    }
                    (*l_404) = (safe_sub_func_float_f_f((((safe_sub_func_float_f_f(0x0.9819A1p+90, (safe_div_func_float_f_f((*l_316), (safe_div_func_float_f_f((-0x1.4p+1), (safe_div_func_float_f_f(((((((__builtin_clzll((safe_mod_func_uint16_t_u_u(((safe_mul_func_int16_t_s_s((l_335 <= l_356.f1), (0UL > func_82(func_84((l_356.f4 == ((l_297 == ((safe_div_func_int64_t_s_s(6L, 0xA3590E6B128E4D22LL)) == 6UL)) >= (*l_316))), l_319.f0, l_271, (*l_316)))))) >= (**p_63)), l_402))) < (*l_316)) != 0x0.1p+1) == l_335) != 0x1.Ap-1) <= 0x9.A45A44p+91) <= 0xE.4DF3D4p-54), l_271)))))))) > l_319.f0) == 0x8.F5CCE1p-29), l_297));
                    (*l_406) = func_73((**p_63));
                    /* statement id: 199 */
                    assert (l_280 == 0);
                }
                for (l_367 = (-28); (l_367 <= 9); l_367 = safe_add_func_uint32_t_u_u(l_367, 3))
                { /* block id: 203 */
                    const struct S0 *l_410 = (void*)0;
                    const struct S0 **l_409 = &l_410;
                    (*l_409) = &l_356;
                    /* statement id: 204 */
                    assert (l_410 == &l_356);
                }
                l_411 = (void*)0;
                /* statement id: 206 */
                assert (l_411 == 0);
                l_297 = (-0x1.4p-1);
            }
        }
        /* facts after for loop */
        //assert (l_280 == &l_54 || l_280 == dangling || l_280 == 0 || l_280 == &l_51);
        for (l_274 = 0; (l_274 > (-13)); l_274 = safe_sub_func_int8_t_s_s(l_274, 1))
        { /* block id: 212 */
            int32_t *l_416 = &l_297;
            (*l_416) = (safe_add_func_uint32_t_u_u(1UL, 1UL));
        }
    }
lbl_474:
    (*l_417) = (*p_63);
    /* statement id: 216 */
    //assert (l_418 == &l_54 || l_418 == &l_51);
    for (l_297 = 20; (l_297 != (-13)); --l_297)
    { /* block id: 219 */
        int32_t l_424 = (-1L);
        int8_t *l_426 = &l_319.f0;
        uint32_t l_427 = 0x89E1A996L;
        union U1 *l_443 = (void*)0;
        int32_t *l_475 = (void*)0;
        int32_t *l_476 = &l_424;
        int32_t **l_477 = &l_418;
        if ((**p_63))
        { /* block id: 220 */
            float l_422 = 0x0.14E303p-40;
            float *l_421 = &l_422;
            int32_t l_423 = 0x9CD34AE7L;
            (*l_421) = 0x7.3E5C07p-20;
            l_424 = l_423;
        }
        else
        { /* block id: 223 */
            int32_t **l_425 = &l_418;
            int64_t l_432 = 0x6942DBF3DB5F00A3LL;
            uint16_t l_462 = 5UL;
            (*l_425) = (*p_63);
            /* statement id: 224 */
            //assert (l_418 == &l_54 || l_418 == &l_51);
            (*l_417) = func_65(l_426, l_427, (*l_425), (*l_418));
            if ((1UL < ((safe_mul_func_uint8_t_u_u(l_427, (((**l_425) | 0xDC223B0BDB32C80ALL) && (**l_425)))) | l_424)))
            { /* block id: 226 */
                l_430 = (*p_63);
                /* statement id: 227 */
                //assert (l_430 == &l_54 || l_430 == &l_51);
                l_431 = l_427;
            }
            else
            { /* block id: 229 */
                int64_t l_442 = (-1L);
                if (l_432)
                    break;
                for (l_431 = 21; (l_431 > (-7)); l_431 = safe_sub_func_int8_t_s_s(l_431, 1))
                { /* block id: 233 */
                    float l_438 = (-0x6.Dp-1);
                    int32_t l_439 = 0x4A55E2D7L;
                    int32_t *l_446 = (void*)0;
                    int32_t *l_447 = &l_424;
                    float *l_456 = (void*)0;
                    float *l_457 = &l_438;
                    for (l_424 = 8; (l_424 < 20); l_424++)
                    { /* block id: 236 */
                        int32_t *l_437 = &l_271;
                        if (l_427)
                            break;
                        (*l_437) = 0x5763805FL;
                        (*l_425) = (*l_417);
                        (*l_417) = func_73(((((__builtin_parityll(l_424) != l_439) && (safe_add_func_uint16_t_u_u(l_442, l_439))) && func_82(l_443)) || l_442));
                        /* statement id: 240 */
                        assert (l_418 == 0);
                    }
                    (*l_447) = ((void*)0 == l_444);
                    (*l_457) = (safe_add_func_float_f_f(((((safe_div_func_float_f_f(((*l_447) <= ((safe_sub_func_float_f_f(l_427, __builtin_clzl((safe_lshift_func_uint8_t_u_s(l_442, 0))))) != l_442)), (*l_447))) == func_82(func_84((*p_64), (&p_63 == &p_63), l_432, l_442))) >= l_442) <= (*l_447)), l_427));
                }
                /* facts after for loop */
                //assert (l_418 == 0 || l_418 == &l_54 || l_418 == &l_51);
                for (l_424 = 0; (l_424 == 21); l_424 = safe_add_func_uint32_t_u_u(l_424, 7))
                { /* block id: 247 */
                    float l_466 = 0x1.4p-1;
                    float *l_465 = &l_466;
                    struct S0 *l_471 = &l_445;
                    int32_t *l_473 = &l_271;
                    (*l_465) = ((l_424 >= (safe_div_func_float_f_f((l_432 == (l_424 <= l_462)), (((l_442 < (safe_div_func_float_f_f(0x0.3E4821p+10, (((l_442 < (-0x6.8p-1)) > (((l_442 <= 0xA.8B8579p-34) == (-0x1.Dp+1)) >= 0xB.4E146Bp+72)) <= (*l_430))))) != l_427) > l_442)))) == 0x9.C674C4p-26);
                    for (l_442 = 0; (l_442 <= 4); l_442 = safe_add_func_int32_t_s_s(l_442, 2))
                    { /* block id: 251 */
                        int32_t *l_469 = &l_271;
                        int32_t **l_470 = &l_469;
                        struct S0 **l_472 = &l_471;
                        (*l_469) = (**p_63);
                        (*l_465) = __builtin_ffsll((0x7387L == (-7L)));
                        (*l_470) = (*p_63);
                        /* statement id: 254 */
                        //assert (l_469 == &l_54 || l_469 == &l_51);
                        (*l_472) = l_471;
                    }
                    (*l_473) = __builtin_popcountl(l_442);
                    if (l_319.f2)
                        goto lbl_474;
                }
            }
            /* facts after branching */
            //assert (l_418 == 0 || l_418 == &l_54 || l_418 == &l_51);
            if (l_424)
                break;
        }
        (*l_476) = (*l_430);
        (*l_477) = (*p_63);
        /* statement id: 264 */
        //assert (l_418 == &l_54 || l_418 == &l_51);
        (*l_477) = func_65(p_64, ((*p_63) != (*l_417)), func_65(l_478, (**l_477), func_65(l_478, ((*l_430) <= (*l_430)), l_479, l_480), (*l_476)), l_481);
        /* statement id: 265 */
        assert (l_418 == 0);
    }
    /* facts after for loop */
    //assert (l_418 == 0 || l_418 == &l_54 || l_418 == &l_51);
    return l_482;
}


/* ------------------------------------------ */
/* 
 * reads : l_71 l_679
 * writes:
 */
inline static int32_t * func_65(int8_t * p_66, float  p_67, int32_t * p_68, uint16_t  p_69)
{ /* block id: 57 */
    uint32_t l_116 = 18446744073709551615UL;
    const uint64_t l_144 = 0xA0FBD7C4E94C4356LL;
    union U1 l_203 = {0UL};
    union U1 *l_202 = &l_203;
    float *l_212 = (void*)0;
    struct S0 l_217 = {-26,2914,699,1,0xA9E36F56L,-16,4,9,12};
    struct S0 *l_216 = &l_217;
    struct S0 **l_215 = &l_216;
    if (l_116)
    { /* block id: 58 */
        uint64_t l_117 = 0x9C033C15289768AFLL;
        int32_t l_118 = 0x0EE2FB04L;
        union U1 l_124 = {0UL};
        union U1 *l_123 = &l_124;
        uint64_t l_131 = 0xEC869DFF36FBD3DFLL;
        int32_t *l_134 = &l_118;
        l_118 = (l_116 ^ l_117);
lbl_153:
        (*l_134) = ((safe_div_func_int64_t_s_s((((safe_mul_func_uint8_t_u_u(func_82(l_123), (safe_mul_func_int8_t_s_s(l_118, (safe_rshift_func_uint16_t_u_s(0x8DC0L, p_69)))))) != ((safe_mod_func_uint8_t_u_u(p_69, l_131)) != p_69)) == (safe_lshift_func_uint8_t_u_s(l_117, (*p_66)))), 1UL)) ^ l_118);
        (*l_134) = (safe_mod_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((+(*l_134)), (l_116 && p_69))), (safe_lshift_func_int8_t_s_u(((p_69 <= 0L) >= 0xEA8FD6C632212A48LL), 7))));
        if ((l_116 != ((*l_134) == (l_144 >= ((safe_rshift_func_uint8_t_u_s((*l_134), 6)) <= (func_82(&l_124) & ((safe_mul_func_int8_t_s_s((safe_sub_func_uint64_t_u_u((*l_134), l_116)), (safe_mul_func_int16_t_s_s((*l_134), l_144)))) >= (*l_134))))))))
        { /* block id: 62 */
            int32_t **l_154 = (void*)0;
            int32_t **l_155 = &l_134;
            if (l_117)
                goto lbl_153;
            (*l_155) = p_68;
            /* statement id: 64 */
            //assert (l_134 == 0 || l_134 == &l_297 || l_134 == &l_54 || l_134 == &l_51);
        }
        else
        { /* block id: 65 */
            return p_68;
            /* statement id: 66 */
            //assert (func_65_rv == 0 || func_65_rv == &l_297 || func_65_rv == &l_54 || func_65_rv == &l_51);
        }
        /* facts after branching */
        //assert (l_134 == 0 || l_134 == &l_297 || l_134 == &l_54 || l_134 == &l_51);
    }
    else
    { /* block id: 68 */
        uint8_t l_162 = 4UL;
        int32_t l_169 = (-1L);
        struct S0 l_176 = {-29,-3474,1769,0,1L,-30,-2,21,107};
        const struct S0 *l_175 = &l_176;
        int8_t l_182 = 0x31L;
        int8_t * const l_181 = &l_182;
        int32_t *l_208 = &l_169;
        uint8_t l_219 = 1UL;
        for (l_116 = (-11); (l_116 != 34); l_116 = safe_add_func_uint16_t_u_u(l_116, 9))
        { /* block id: 71 */
            uint64_t l_164 = 0x2E4F19BD61A28F2DLL;
            union U1 l_166 = {0xF4L};
            union U1 *l_165 = &l_166;
            float l_168 = 0xA.60D964p-59;
            float *l_167 = &l_168;
            (*l_167) = ((0x7.AE9268p+49 == __builtin_ia32_crc32qi(p_69, (safe_lshift_func_uint16_t_u_s(l_116, 0)))) == (((safe_div_func_float_f_f(l_162, (+l_164))) != (p_69 <= func_82(l_165))) < p_67));
        }
        l_169 = l_144;
        if ((l_116 ^ l_116))
        { /* block id: 75 */
            float l_171 = 0x2.B2AB3Ap-81;
            float *l_170 = &l_171;
            int32_t *l_174 = &l_169;
            struct S0 *l_178 = (void*)0;
            struct S0 **l_177 = &l_178;
            int8_t *l_245 = (void*)0;
            (*l_170) = (-0x6.Fp+1);
            (*l_174) = (safe_mul_func_int16_t_s_s(9L, (((void*)0 != p_68) > p_69)));
            (*l_177) = l_175;
            /* statement id: 78 */
            assert (l_178 == &l_176);
            if ((*l_174))
            { /* block id: 79 */
                float * const l_211 = &l_171;
                int32_t **l_214 = &l_208;
                if ((safe_lshift_func_uint16_t_u_s(p_69, p_69)))
                { /* block id: 80 */
                    union U1 l_186 = {0x61L};
                    union U1 *l_185 = &l_186;
                    int32_t **l_199 = &l_174;
                    int32_t *l_204 = &l_169;
                    p_67 = ((l_162 != ((p_66 == l_181) >= (safe_sub_func_float_f_f(func_82(l_185), (((((__builtin_clz((__builtin_ctzll(((safe_div_func_uint8_t_u_u((p_69 != ((safe_sub_func_uint16_t_u_u((safe_add_func_int32_t_s_s((((safe_mod_func_int32_t_s_s((*l_174), (safe_lshift_func_uint8_t_u_u((safe_div_func_int64_t_s_s(((p_69 < func_82(func_84(l_116, l_186.f0, p_69, l_186.f0))) >= p_69), 0xCE9D0E818DDB15D3LL)), 3)))) ^ 1UL) < 18446744073709551615UL), p_69)), 1UL)) <= p_69)), l_176.f4)) == p_69)) & (*p_66))) != p_67) >= l_186.f0) >= p_67) < (*l_174)) <= 0x1.49AC58p+53))))) != (-0x1.2p+1));
                    (*l_199) = func_73(p_69);
                    /* statement id: 82 */
                    assert (l_174 == 0);
                    (*l_204) = (__builtin_popcountl(p_69) ^ (safe_lshift_func_uint16_t_u_s(((void*)0 == l_202), 5)));
                    for (l_116 = 0; (l_116 > 45); l_116 = safe_add_func_int16_t_s_s(l_116, 5))
                    { /* block id: 86 */
                        float l_207 = (-0x2.Fp-1);
                        if (p_69)
                            break;
                        l_208 = (void*)0;
                        /* statement id: 88 */
                        assert (l_208 == 0);
                        (*l_170) = __builtin_bswap32((((safe_add_func_uint32_t_u_u(func_82(&l_186), (l_211 == l_212))) || 0xB9C6L) && l_144));
                    }
                    /* facts after for loop */
                    assert (l_208 == 0 || l_208 == &l_169);
                }
                else
                { /* block id: 91 */
                    uint8_t l_213 = 0xF8L;
                    (*l_174) = l_213;
                }
                /* facts after branching */
                assert (l_174 == &l_169 || l_174 == 0);
                assert (l_208 == 0 || l_208 == &l_169);
                (*l_214) = p_68;
                /* statement id: 94 */
                //assert (l_208 == 0 || l_208 == &l_297 || l_208 == &l_54 || l_208 == &l_51);
            }
            else
            { /* block id: 95 */
                struct S0 ***l_218 = &l_215;
                int32_t l_220 = (-9L);
                int32_t *l_236 = &l_220;
                union U1 *l_254 = &l_203;
                (*l_218) = l_215;
                if ((((0xB388L != func_82(func_84((*l_174), l_219, (l_220 < (safe_mul_func_uint8_t_u_u((safe_mul_func_int16_t_s_s((p_69 >= ((*l_174) | ((!__builtin_ctz(((safe_sub_func_uint64_t_u_u(__builtin_ffsl(p_69), ((safe_rshift_func_int16_t_s_u((0x0DL <= l_220), p_69)) > (*l_208)))) < 0xBE5548FEC5983163LL))) >= p_69))), p_69)), 1L))), l_220))) ^ 0x3FA7L) < 0x68BCL))
                { /* block id: 97 */
                    int32_t **l_232 = &l_208;
                    struct S0 *l_233 = (void*)0;
                    (*l_232) = func_73((*l_208));
                    /* statement id: 98 */
                    assert (l_208 == 0);
                    (*l_177) = l_233;
                    /* statement id: 99 */
                    assert (l_178 == 0);
                    for (l_169 = 0; (l_169 != 27); l_169++)
                    { /* block id: 102 */
                        p_67 = l_220;
                        (*l_170) = p_69;
                        l_236 = p_68;
                        /* statement id: 105 */
                        //assert (l_236 == 0 || l_236 == &l_297 || l_236 == &l_54 || l_236 == &l_51);
                    }
                    /* facts after for loop */
                    //assert (l_236 == 0 || l_236 == &l_220 || l_236 == &l_297 || l_236 == &l_54 || l_236 == &l_51);
                    if ((safe_sub_func_int16_t_s_s((((*l_174) == (safe_lshift_func_uint16_t_u_s(0x575CL, (safe_div_func_uint8_t_u_u(p_69, (*p_66)))))) || p_69), (safe_mod_func_int64_t_s_s(l_176.f3, (__builtin_bswap32(p_69) && (p_66 == l_245)))))))
                    { /* block id: 107 */
                        l_217.f5 = p_69;
                        return p_68;
                        /* statement id: 109 */
                        //assert (func_65_rv == 0 || func_65_rv == &l_297 || func_65_rv == &l_54 || func_65_rv == &l_51);
                    }
                    else
                    { /* block id: 110 */
                        struct S0 *l_250 = (void*)0;
                        int32_t l_251 = 0x4B51E4AAL;
                        union U2 l_257 = {0xE3L};
                        union U2 *l_256 = &l_257;
                        union U2 **l_255 = &l_256;
                        (*l_170) = (0xA.DDDCD2p+32 < (safe_mul_func_float_f_f(((safe_mul_func_float_f_f((l_250 != (*l_177)), l_251)) != (p_69 == (safe_add_func_float_f_f(l_251, (func_82(l_254) < (p_69 >= l_251)))))), p_67)));
                        (*l_255) = (void*)0;
                        /* statement id: 112 */
                        assert (l_256 == 0);
                    }
                }
                else
                { /* block id: 114 */
                    l_217.f5 = 0xE9DD07A3L;
                }
                /* facts after branching */
                assert (l_178 == &l_176 || l_178 == 0);
                assert (l_208 == &l_169 || l_208 == 0);
                //assert (l_236 == 0 || l_236 == &l_220 || l_236 == &l_297 || l_236 == &l_54 || l_236 == &l_51);
            }
            /* facts after branching */
            assert (l_174 == &l_169 || l_174 == 0);
            assert (l_178 == &l_176 || l_178 == 0);
            //assert (l_208 == &l_169 || l_208 == 0 || l_208 == &l_297 || l_208 == &l_54 || l_208 == &l_51);
        }
        else
        { /* block id: 118 */
            const int32_t l_260 = 0x51678A96L;
            if (l_203.f0)
            { /* block id: 119 */
                int32_t **l_258 = (void*)0;
                int32_t **l_259 = &l_208;
                int32_t l_261 = 0xB132ED61L;
lbl_262:
                (*l_259) = (void*)0;
                /* statement id: 120 */
                assert (l_208 == 0);
                l_261 = (l_260 && p_69);
                if (l_162)
                    goto lbl_262;
            }
            else
            { /* block id: 123 */
                int64_t l_265 = 0x61F976974A8696E9LL;
                int32_t **l_266 = &l_208;
                int32_t *l_267 = &l_169;
                (*l_208) = (safe_lshift_func_int16_t_s_u(l_260, 14));
                (*l_266) = func_73(l_265);
                /* statement id: 125 */
                assert (l_208 == 0);
                (*l_267) = p_69;
                (*l_266) = func_73((0x964D273EL & (p_69 || l_217.f4)));
            }
            /* facts after branching */
            assert (l_208 == 0);
        }
        /* facts after branching */
        //assert (l_208 == &l_169 || l_208 == 0 || l_208 == &l_297 || l_208 == &l_54 || l_208 == &l_51);
    }
    return p_68;
    /* statement id: 131 */
    //assert (func_65_rv == 0 || func_65_rv == &l_297 || func_65_rv == &l_54 || func_65_rv == &l_51);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_73(int32_t  p_74)
{ /* block id: 54 */
    float l_104 = 0x8.E9A154p-6;
    int32_t l_105 = 1L;
    int32_t *l_106 = &l_105;
    int32_t *l_107 = &l_105;
    int32_t *l_108 = &l_105;
    int32_t *l_109 = &l_105;
    int32_t *l_110 = &l_105;
    int32_t *l_111 = &l_105;
    int32_t *l_112 = &l_105;
    int32_t *l_113 = &l_105;
    int32_t *l_114 = &l_105;
    int32_t *l_115 = (void*)0;
    (*l_106) = l_105;
    return l_115;
    /* statement id: 56 */
    //assert (func_73_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_82(union U1 * p_83)
{ /* block id: 52 */
    uint8_t l_103 = 0xEFL;
    return l_103;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1 * func_84(int8_t  p_85, int8_t  p_86, uint32_t  p_87, uint8_t  p_88)
{ /* block id: 49 */
    int8_t **l_91 = (void*)0;
    int8_t * const *l_93 = (void*)0;
    int8_t * const **l_92 = &l_93;
    union U1 l_95 = {0xCAL};
    union U1 *l_94 = &l_95;
    union U1 *l_96 = &l_95;
    union U1 *l_97 = &l_95;
    union U1 *l_98 = &l_95;
    union U1 *l_99 = &l_95;
    union U1 *l_100 = &l_95;
    union U1 *l_101 = &l_95;
    union U1 *l_102 = (void*)0;
    (*l_92) = l_91;
    return l_102;
    /* statement id: 51 */
    //assert (func_84_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 186
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 13
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 10

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 232
   depth: 2, occurrence: 45
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 5
   depth: 6, occurrence: 2
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 5
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 22, occurrence: 2
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 246

XXX times a variable address is taken: 189
XXX times a pointer is dereferenced on RHS: 115
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 29
XXX times a pointer is dereferenced on LHS: 102
breakdown:
   depth: 1, occurrence: 97
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 353

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1270
   level: 2, occurrence: 124
XXX number of pointers point to pointers: 79
XXX number of pointers point to scalars: 113
XXX number of pointers point to structs: 17
XXX percent of pointers has null in alias set: 22.8
XXX average alias set size: 1.23

XXX times a non-volatile is read: 720
XXX times a non-volatile is write: 272
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 200
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 20
   depth: 2, occurrence: 31
   depth: 3, occurrence: 34
   depth: 4, occurrence: 49
   depth: 5, occurrence: 42

XXX percentage a fresh-made variable is used: 17.7
XXX percentage an existing variable is used: 82.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

