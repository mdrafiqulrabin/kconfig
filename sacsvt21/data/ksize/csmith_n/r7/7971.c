/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      4192225431
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   float  f1;
   uint16_t  f2;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   unsigned f0 : 25;
   signed f1 : 16;
   int64_t  f2;
   signed f3 : 28;
   unsigned f4 : 31;
};
#pragma pack(pop)

union U2 {
   int32_t  f0;
   float  f1;
   unsigned f2 : 22;
   struct S0  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint64_t  func_28(void);
inline static const int32_t * const * func_50(const int32_t * p_51, int32_t ** p_52);
static int32_t * func_53(uint32_t  p_54, int32_t ** p_55);
inline static uint32_t  func_62(struct S1  p_63, int32_t ** p_64, int32_t ** p_65);
inline static struct S1  func_66(uint32_t  p_67);
static int32_t ** func_72(int32_t ** p_73, int32_t * const  p_74, int32_t ** p_75, int32_t * const  p_76, uint32_t  p_77);
static float  func_80(int32_t ** p_81);
static int32_t ** func_82(int8_t  p_83, const int32_t * const  p_84, const struct S0  p_85, uint8_t  p_86);
inline static int32_t * func_87(uint32_t  p_88, int8_t  p_89, struct S0  p_90);
inline static int8_t  func_109(uint16_t  p_110, const int32_t ** p_111);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = (-1L);
    int32_t l_49 = 1L;
    int32_t *l_48 = &l_49;
    struct S0 l_401 = {4294967295UL,-0x1.Ep+1,65530UL};
    const int32_t *l_424 = &l_29;
    const int32_t **l_423 = &l_424;
    struct S1 l_429 = {5669,-242,0xD08208A4D0BFE20CLL,5311,7648};
    int32_t **l_464 = &l_48;
    int32_t ***l_463 = &l_464;
    int32_t ****l_462 = &l_463;
    int32_t *****l_461 = &l_462;
    int16_t l_465 = (-1L);
    struct S1 *l_467 = &l_429;
    struct S1 **l_466 = &l_467;
    union U2 **l_468 = (void*)0;
    int32_t **l_475 = &l_48;
    int32_t l_495 = 0L;
    int32_t l_502 = 1L;
    int32_t l_512 = (-10L);
    int64_t l_520 = 8L;
    int16_t l_530 = 0x28E8L;
    uint32_t l_557 = 0x72F70728L;
    uint32_t l_581 = 1UL;
    uint16_t l_619 = 0x2A93L;
    for (l_29 = (-6); (l_29 == (-16)); l_29 = safe_sub_func_int16_t_s_s(l_29, 2))
    { /* block id: 39 */
        int32_t l_36 = 0xD52A42BBL;
        int32_t *l_47 = &l_29;
        const int64_t l_58 = 0xFE0A4D2C643D4393LL;
        int32_t l_389 = 2L;
        uint8_t l_396 = 1UL;
        int32_t l_405 = 2L;
        int32_t *l_408 = &l_389;
        int32_t l_435 = 0x77A9AE85L;
        uint32_t l_442 = 0x0B38DC77L;
        union U2 *l_443 = (void*)0;
        int32_t ****l_460 = (void*)0;
        int32_t *****l_459 = &l_460;
        struct S1 l_469 = {2413,18,0x8E04EC45E47B91C3LL,14777,41653};
        uint16_t l_533 = 1UL;
        const int32_t *l_538 = &l_49;
        struct S0 l_544 = {0x8F8609A7L,0x8.FC8F1Ap+96,1UL};
        struct S0 *l_556 = &l_544;
        struct S1 ***l_560 = &l_466;
        int64_t l_617 = 0L;
        int32_t l_618 = (-1L);
    }
    return l_619;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * const * func_50(const int32_t * p_51, int32_t ** p_52)
{ /* block id: 175 */
    uint16_t l_338 = 0xCE0BL;
    const int32_t l_345 = (-2L);
    const int32_t *l_344 = &l_345;
    const int32_t **l_343 = &l_344;
    int32_t l_347 = 1L;
    int32_t *l_346 = &l_347;
    int32_t l_360 = 0x9C6E5BA7L;
    const struct S1 l_372 = {1445,-148,1L,-2573,36565};
    const struct S1 *l_371 = &l_372;
    const int32_t * const *l_377 = &l_344;
    const int32_t * const *l_378 = (void*)0;
    (*l_346) = (safe_add_func_uint64_t_u_u(l_338, (safe_rshift_func_uint8_t_u_u(func_109((safe_sub_func_int32_t_s_s(l_338, 0xA658F281L)), l_343), 1))));
    for (l_338 = 0; (l_338 == 25); l_338 = safe_add_func_int32_t_s_s(l_338, 5))
    { /* block id: 179 */
        int16_t l_350 = 0xDD9AL;
        struct S1 **l_373 = (void*)0;
        struct S1 l_376 = {431,137,1L,-5853,16599};
        struct S1 *l_375 = &l_376;
        struct S1 **l_374 = &l_375;
        if ((1L || ((0x6FL | (l_350 ^ (!(**p_52)))) & l_350)))
        { /* block id: 180 */
            int32_t * const *l_362 = &l_346;
            int32_t * const **l_361 = &l_362;
            for (l_347 = 0; (l_347 > (-27)); l_347 = safe_sub_func_uint16_t_u_u(l_347, 8))
            { /* block id: 183 */
                int32_t l_365 = 0xD89D66DDL;
                int32_t l_367 = 0xDC4AD3F9L;
                int32_t *l_366 = &l_367;
                (*l_366) = (safe_rshift_func_int8_t_s_u(((safe_sub_func_int16_t_s_s((safe_add_func_int8_t_s_s(((l_360 != (&l_343 == l_361)) | (-6L)), (*l_346))), (safe_add_func_int32_t_s_s(l_365, l_350)))) >= l_350), 2));
                (*l_343) = (*l_343);
            }
        }
        else
        { /* block id: 187 */
            int32_t l_368 = 0L;
            float l_370 = 0x0.8p+1;
            float *l_369 = &l_370;
            (*l_369) = l_368;
        }
        (*l_374) = l_371;
        /* statement id: 190 */
        assert (l_375 == &l_372);
    }
    return l_378;
    /* statement id: 192 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_53(uint32_t  p_54, int32_t ** p_55)
{ /* block id: 165 */
    const union U2 l_327 = {0x2C80A9E8L};
    const union U2 *l_326 = &l_327;
    int32_t l_331 = 0x5CCD36D1L;
    int32_t *l_330 = &l_331;
    const uint32_t l_334 = 2UL;
    float l_335 = 0x6.4E45B8p+24;
    for (p_54 = 1; (p_54 == 12); p_54 = safe_add_func_uint16_t_u_u(p_54, 6))
    { /* block id: 168 */
        struct S1 l_324 = {3569,250,0x60AF7DF84C63453BLL,4101,39172};
        struct S1 *l_325 = &l_324;
        const union U2 l_329 = {0L};
        const union U2 *l_328 = &l_329;
        (*l_325) = l_324;
        l_328 = l_326;
        /* statement id: 170 */
        assert (l_328 == &l_327);
    }
    l_330 = (*p_55);
    /* statement id: 172 */
    //assert (l_330 == &l_29 || l_330 == 0);
    l_331 = ((safe_div_func_int8_t_s_s(l_334, p_54)) || (p_54 != p_54));
    return (*p_55);
    /* statement id: 174 */
    //assert (func_53_rv == &l_29 || func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_62(struct S1  p_63, int32_t ** p_64, int32_t ** p_65)
{ /* block id: 47 */
    int64_t l_93 = 0x80D8AAF453288EE1LL;
    struct S0 l_94 = {0x311489D4L,0x2.4p-1,65534UL};
    float *l_321 = &l_94.f1;
    (*l_321) = func_80(func_82(p_63.f2, func_87(((safe_rshift_func_uint8_t_u_u(l_93, l_93)) != l_93), l_93, l_94), l_94, p_63.f4));
    return l_94.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_66(uint32_t  p_67)
{ /* block id: 42 */
    const int8_t l_68 = 0x6BL;
    int32_t l_70 = 0x8616691CL;
    int32_t *l_69 = &l_70;
    struct S1 l_71 = {5484,226,0x100F83BF0B62E56CLL,7821,39234};
    (*l_69) = l_68;
    return l_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_72(int32_t ** p_73, int32_t * const  p_74, int32_t ** p_75, int32_t * const  p_76, uint32_t  p_77)
{ /* block id: 45 */
    return p_73;
    /* statement id: 46 */
    //assert (func_72_rv == &l_47 || func_72_rv == &l_146 || func_72_rv == &l_48);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_80(int32_t ** p_81)
{ /* block id: 134 */
    int32_t l_283 = 0x09247627L;
    const int32_t **l_296 = (void*)0;
    union U2 l_314 = {0x7AF4D267L};
    union U2 *l_313 = &l_314;
    const int32_t ***l_316 = &l_296;
    const int32_t **** const l_315 = &l_316;
    int32_t **l_320 = (void*)0;
    int32_t ***l_319 = &l_320;
    int32_t ****l_318 = &l_319;
    int32_t *****l_317 = &l_318;
    for (l_283 = 0; (l_283 < (-18)); --l_283)
    { /* block id: 137 */
        int32_t l_286 = (-7L);
        const struct S1 l_298 = {4809,-203,0x7CBA297D261BF663LL,-8215,12648};
        for (l_286 = 0; (l_286 < 11); l_286 = safe_add_func_uint32_t_u_u(l_286, 1))
        { /* block id: 140 */
            const float l_289 = 0x0.7p-1;
            int32_t l_290 = 0x94971777L;
            struct S1 l_299 = {876,121,1L,-4503,9343};
            int64_t l_302 = 0x5371327729D68AA1LL;
            int32_t *l_304 = &l_290;
            if ((l_290 ^ 1UL))
            { /* block id: 141 */
                uint8_t l_291 = 255UL;
                int32_t *l_303 = &l_290;
                if ((((l_290 | (l_291 ^ (safe_sub_func_uint8_t_u_u(1UL, (((safe_lshift_func_int8_t_s_s(l_290, 3)) == 0x56A3L) && func_109((0xADB0L != 9L), l_296)))))) || 0xA004C85C767CC5C4LL) > 0L))
                { /* block id: 142 */
                    uint64_t l_297 = 0x5520F516C413E437LL;
                    return l_297;
                }
                else
                { /* block id: 144 */
                    int32_t *l_300 = &l_290;
                    union U2 *l_305 = (void*)0;
                    l_299 = l_298;
                    (*l_300) = l_291;
                    if ((+l_302))
                    { /* block id: 147 */
                        return l_298.f2;
                    }
                    else
                    { /* block id: 149 */
                        union U2 **l_306 = (void*)0;
                        union U2 **l_307 = &l_305;
                        l_304 = l_303;
                        (*l_307) = l_305;
                        if ((*l_304))
                            continue;
                    }
                }
            }
            else
            { /* block id: 155 */
                union U2 l_311 = {1L};
                union U2 *l_310 = &l_311;
                union U2 **l_309 = &l_310;
                union U2 ***l_308 = &l_309;
                union U2 ****l_312 = &l_308;
                (*l_312) = l_308;
            }
        }
    }
    l_313 = l_313;
    (*l_317) = l_315;
    /* statement id: 161 */
    assert (l_318 == &l_316);
    return l_314.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_82(int8_t  p_83, const int32_t * const  p_84, const struct S0  p_85, uint8_t  p_86)
{ /* block id: 124 */
    uint16_t l_264 = 6UL;
    struct S0 l_265 = {1UL,0x5.9786D4p-97,0xDAFAL};
    int32_t **l_266 = (void*)0;
    int32_t l_269 = 0x3FF5F7A2L;
    int32_t *l_268 = &l_269;
    int32_t **l_267 = &l_268;
    struct S1 l_270 = {5444,-167,1L,10592,18561};
    struct S1 *l_271 = (void*)0;
    int32_t **l_272 = &l_268;
    int32_t **l_273 = &l_268;
    int32_t **l_274 = &l_268;
    int32_t **l_275 = &l_268;
    int32_t **l_276 = &l_268;
    int32_t **l_277 = &l_268;
    int32_t **l_278 = &l_268;
    int32_t **l_279 = &l_268;
    int32_t **l_280 = &l_268;
    int32_t **l_281 = &l_268;
    int32_t **l_282 = (void*)0;
    for (p_86 = 0; (p_86 != 38); p_86++)
    { /* block id: 127 */
        int32_t l_262 = (-9L);
        int32_t *l_261 = &l_262;
        int32_t **l_263 = &l_261;
        (*l_261) = (p_85.f0 == 0x9D5BA957L);
        (*l_263) = p_84;
        /* statement id: 129 */
        //assert (l_261 == 0 || l_261 == &l_389 || l_261 == &l_49);
    }
    (*l_267) = func_87(p_85.f2, l_264, l_265);
    /* statement id: 131 */
    assert (l_268 == 0);
    l_270 = l_270;
    return l_282;
    /* statement id: 133 */
    //assert (func_82_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_87(uint32_t  p_88, int8_t  p_89, struct S0  p_90)
{ /* block id: 48 */
    int32_t l_100 = (-1L);
    int32_t *l_99 = &l_100;
    float l_106 = (-0x7.Ap-1);
    float *l_105 = &l_106;
    const int32_t *l_113 = (void*)0;
    const int32_t **l_112 = &l_113;
    float * const l_117 = (void*)0;
    int32_t l_133 = 0x23AF2BE4L;
    uint64_t l_138 = 0x9F9BE492C623687ELL;
    int32_t *l_150 = &l_100;
    int32_t *l_168 = &l_100;
    int32_t *l_193 = &l_100;
    int32_t *l_194 = &l_100;
    int32_t *l_224 = &l_100;
    int32_t *l_225 = &l_100;
    int32_t *l_226 = &l_100;
    int32_t *l_228 = &l_100;
    struct S1 l_253 = {208,198,-1L,-465,44077};
    struct S1 *l_254 = &l_253;
    int32_t *l_255 = &l_100;
    int32_t *l_256 = &l_100;
    int32_t *l_257 = &l_100;
    int32_t *l_258 = (void*)0;
lbl_207:
    (*l_105) = ((safe_mul_func_float_f_f(p_90.f1, (safe_mul_func_float_f_f(p_90.f0, ((l_99 != &l_100) >= (&l_100 == (void*)0)))))) == (safe_add_func_float_f_f((safe_mul_func_float_f_f((*l_99), (p_90.f0 > (*l_99)))), p_90.f1)));
    if ((safe_mod_func_uint32_t_u_u(((func_109(p_89, l_112) < ((void*)0 == l_117)) & p_89), p_89)))
    { /* block id: 53 */
        int32_t *l_118 = (void*)0;
        const int32_t *l_123 = &l_100;
        int32_t **l_140 = &l_99;
        int32_t *l_169 = &l_100;
        int32_t *l_170 = &l_100;
        int32_t *l_196 = &l_100;
        struct S0 l_208 = {0UL,0x0.Bp-1,4UL};
        int32_t *l_218 = &l_100;
        int32_t *l_219 = &l_100;
        int32_t *l_221 = &l_100;
        int32_t *l_222 = &l_100;
        int32_t *l_229 = (void*)0;
lbl_153:
        (*l_112) = l_118;
        for (p_88 = 13; (p_88 == 21); p_88 = safe_add_func_uint8_t_u_u(p_88, 9))
        { /* block id: 57 */
            const int32_t **l_121 = &l_113;
            int32_t *l_146 = &l_100;
            int64_t l_188 = (-1L);
            int32_t *l_195 = &l_100;
            int32_t *l_220 = &l_100;
            int32_t *l_223 = &l_100;
            int32_t *l_227 = &l_100;
            (*l_99) = __builtin_ffs(p_88);
            if ((((void*)0 == l_121) ^ p_89))
            { /* block id: 59 */
                const uint8_t l_122 = 248UL;
                int32_t *l_144 = &l_100;
                int32_t *l_147 = &l_100;
                int32_t *l_151 = &l_100;
                int32_t *l_152 = (void*)0;
                const int32_t **l_173 = &l_123;
                (*l_105) = (((void*)0 == (*l_112)) < l_122);
                if (((p_90.f2 <= p_90.f0) <= (((l_118 == l_123) >= (__builtin_popcountll((*l_123)) == l_122)) < 254UL)))
                { /* block id: 61 */
                    uint64_t l_130 = 0UL;
                    int32_t *l_142 = &l_100;
                    int32_t *l_145 = &l_100;
                    int32_t *l_148 = &l_100;
                    int32_t *l_149 = &l_100;
                    if (__builtin_popcount((safe_add_func_int32_t_s_s((safe_rshift_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u(l_130, (*l_99))) <= (safe_rshift_func_int8_t_s_s(l_133, (0x23B9L < (safe_add_func_uint32_t_u_u(p_90.f2, ((__builtin_ia32_crc32qi(p_89, ((safe_div_func_uint8_t_u_u(l_138, (l_122 & 7UL))) != p_90.f0)) != l_130) & 1L))))))), p_89)), p_90.f0))))
                    { /* block id: 62 */
                        int32_t *l_139 = &l_100;
                        (*l_99) = l_130;
                        return l_118;
                        /* statement id: 64 */
                        //assert (func_87_rv == 0);
                    }
                    else
                    { /* block id: 65 */
                        uint64_t l_141 = 3UL;
                        int32_t *l_143 = &l_100;
                        (*l_112) = l_123;
                        /* statement id: 66 */
                        assert (l_113 == &l_100);
                        (*l_112) = l_118;
                        /* statement id: 67 */
                        assert (l_113 == 0);
                        (**l_140) = ((l_140 != &l_123) && l_141);
                        return l_152;
                        /* statement id: 69 */
                        //assert (func_87_rv == 0);
                    }
                }
                else
                { /* block id: 71 */
                    const int32_t **l_155 = &l_113;
                    float *l_164 = &l_106;
                    if (l_100)
                        goto lbl_153;
                    (*l_146) = (-1L);
                    (*l_105) = (((-(p_90.f0 > (0x1.3E4D7Bp+58 < func_109(p_90.f0, l_155)))) == ((safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_sub_func_float_f_f(p_88, (safe_div_func_float_f_f(0x6.Fp-1, (*l_123))))), ((l_164 != (void*)0) == 0x3.7DA113p-64))), p_90.f2)) < p_89)) <= p_88);
                    for (p_89 = 26; (p_89 > (-15)); p_89 = safe_sub_func_int32_t_s_s(p_89, 1))
                    { /* block id: 77 */
                        int32_t *l_167 = &l_100;
                        return l_152;
                        /* statement id: 78 */
                        //assert (func_87_rv == 0);
                    }
                }
                p_90.f1 = (safe_sub_func_float_f_f((**l_140), func_109(p_90.f2, l_173)));
            }
            else
            { /* block id: 82 */
                uint16_t l_176 = 0x35E1L;
                int32_t *l_190 = &l_100;
                int32_t *l_191 = &l_100;
                int32_t *l_197 = (void*)0;
                int32_t * const l_212 = (void*)0;
                (*l_112) = (*l_112);
                if (((safe_rshift_func_int16_t_s_u(((p_89 && ((func_109(p_90.f0, l_121) < p_90.f2) >= ((*l_140) == (void*)0))) <= l_176), 1)) || (safe_mod_func_int32_t_s_s((l_176 != 18446744073709551607UL), 0xB7793343L))))
                { /* block id: 84 */
                    if (p_90.f0)
                        break;
                }
                else
                { /* block id: 86 */
                    const int32_t l_181 = (-1L);
                    int32_t *l_189 = &l_100;
                    int32_t *l_192 = &l_100;
                    (*l_105) = (safe_mul_func_float_f_f(l_181, ((safe_sub_func_float_f_f(l_176, (l_176 < (l_176 <= ((safe_div_func_float_f_f((p_88 >= (**l_140)), ((safe_sub_func_float_f_f(p_88, ((*l_150) >= p_89))) >= 0x2.969A1Bp+73))) <= l_188))))) <= (**l_140))));
                    return l_197;
                    /* statement id: 88 */
                    //assert (func_87_rv == 0);
                }
                for (l_138 = 0; (l_138 < 27); ++l_138)
                { /* block id: 92 */
                    int32_t *l_202 = &l_100;
                    const int32_t **l_204 = &l_123;
                    if ((((safe_lshift_func_int8_t_s_u(((void*)0 != l_202), 4)) || ((+func_109((*l_202), l_204)) || 8L)) && (safe_add_func_uint64_t_u_u(p_89, __builtin_ffsl(p_90.f0)))))
                    { /* block id: 93 */
                        (*l_121) = (*l_121);
                        if (p_90.f2)
                            continue;
                        (*l_204) = (*l_112);
                        /* statement id: 96 */
                        assert (l_123 == 0);
                    }
                    else
                    { /* block id: 97 */
                        if (p_88)
                            goto lbl_207;
                        p_90 = l_208;
                        (*l_121) = (*l_112);
                    }
                    (*l_105) = p_90.f2;
                    for (l_188 = 20; (l_188 != (-23)); --l_188)
                    { /* block id: 105 */
                        int32_t *l_211 = &l_100;
                        int32_t ***l_213 = &l_140;
                        l_123 = (*l_121);
                        /* statement id: 106 */
                        assert (l_123 == 0);
                        (*l_140) = l_211;
                        (*l_213) = func_72(&l_146, (*l_140), &l_197, l_212, (*l_191));
                        /* statement id: 108 */
                        assert (l_140 == &l_146);
                        if (p_90.f2)
                            break;
                    }
                }
                /* facts after for loop */
                assert (l_123 == &l_100 || l_123 == 0);
                assert (l_140 == &l_146 || l_140 == &l_99);
                (*l_105) = (((void*)0 == &l_146) > (+(((*l_150) <= ((safe_mul_func_float_f_f(__builtin_ffs((*l_196)), (((+(-0x1.Bp-1)) < p_90.f1) > p_90.f2))) < (-0x1.7p-1))) == 0x3.Fp-1)));
            }
            /* facts after branching */
            assert (l_123 == &l_100 || l_123 == 0);
            assert (l_140 == &l_146 || l_140 == &l_99);
            (*l_140) = (*l_140);
            return l_229;
            /* statement id: 115 */
            //assert (func_87_rv == 0);
        }
        (*l_225) = (safe_sub_func_int64_t_s_s(p_89, ((safe_mul_func_int8_t_s_s((safe_mod_func_uint16_t_u_u(65535UL, (((*l_123) && p_89) & (safe_rshift_func_uint16_t_u_s((safe_div_func_uint8_t_u_u(p_90.f2, (safe_div_func_uint32_t_u_u(((0x6E5AD535L || ((safe_lshift_func_int8_t_s_s(p_88, 4)) >= (*l_222))) == p_90.f2), 0x2F738AECL)))), (**l_140)))))), (*l_194))) ^ 0xEBL)));
        (*l_168) = ((*l_228) <= ((safe_sub_func_int64_t_s_s(0L, p_89)) >= (safe_lshift_func_uint16_t_u_u(func_109((safe_sub_func_int16_t_s_s(((void*)0 == (*l_140)), (*l_225))), &l_113), p_88))));
    }
    else
    { /* block id: 119 */
        int32_t *l_252 = (void*)0;
        (*l_112) = l_252;
    }
    (*l_254) = l_253;
    return l_258;
    /* statement id: 123 */
    //assert (func_87_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_109(uint16_t  p_110, const int32_t ** p_111)
{ /* block id: 50 */
    const uint16_t l_114 = 65535UL;
    int32_t l_116 = 1L;
    int32_t *l_115 = &l_116;
    (*l_115) = l_114;
    return p_110;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 198
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 25
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 17
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 1

XXX max expression depth: 16
breakdown:
   depth: 1, occurrence: 107
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1

XXX total number of pointers: 191

XXX times a variable address is taken: 169
XXX times a pointer is dereferenced on RHS: 99
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 6
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 84
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 864

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 245
   level: 2, occurrence: 57
   level: 3, occurrence: 13
   level: 4, occurrence: 19
   level: 5, occurrence: 13
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 86
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 27.2
XXX average alias set size: 1.24

XXX times a non-volatile is read: 595
XXX times a non-volatile is write: 224
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 12
   depth: 2, occurrence: 7
   depth: 3, occurrence: 11
   depth: 4, occurrence: 15
   depth: 5, occurrence: 21

XXX percentage a fresh-made variable is used: 13.7
XXX percentage an existing variable is used: 86.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

